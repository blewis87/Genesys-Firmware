CCS PCH C Compiler, Version 5.051, 21086               09-Feb-17 17:23

               Filename:   C:\Users\Brian\Dropbox\Metrionix\Firmware\2017-01-31 - E312\IntRF_E311.lst

               ROM used:   44434 bytes (68%)
                           Largest free fragment is 21098
               RAM used:   1355 (35%) at main() level
                           1479 (38%) worst case
               Stack used: 10 locations (5 in main + 5 for interrupts)
               Stack size: 31

*
00000:  GOTO   9E00
*
00008:  GOTO   00EE
0000C:  NOP   
0000E:  NOP   
00010:  NOP   
00012:  NOP   
00014:  NOP   
00016:  NOP   
00018:  MOVWF  04
0001A:  MOVFF  FD8,05
0001E:  MOVFF  FE0,06
00022:  MOVLB  0
00024:  MOVFF  FE9,0C
00028:  MOVFF  FEA,07
0002C:  MOVFF  FE1,08
00030:  MOVFF  FE2,09
00034:  MOVFF  FD9,0A
00038:  MOVFF  FDA,0B
0003C:  MOVFF  FF3,12
00040:  MOVFF  FF4,13
00044:  MOVFF  FFA,14
00048:  MOVFF  FF5,15
0004C:  MOVFF  FF6,16
00050:  MOVFF  FF7,17
00054:  MOVFF  00,0E
00058:  MOVFF  01,0F
0005C:  MOVFF  02,10
00060:  MOVFF  03,11
00064:  BTFSS  FA0.6
00066:  GOTO   0070
0006A:  BTFSC  FA1.6
0006C:  GOTO   19C4
00070:  BTFSS  FF0.4
00072:  GOTO   007C
00076:  BTFSC  FF0.1
00078:  GOTO   16FE
0007C:  BTFSS  F7A.1
0007E:  GOTO   0088
00082:  BTFSC  F7B.1
00084:  GOTO   2CAE
00088:  BTFSS  FA0.3
0008A:  GOTO   0094
0008E:  BTFSC  FA1.3
00090:  GOTO   08BA
00094:  BTFSS  FF2.3
00096:  GOTO   00A0
0009A:  BTFSC  FF2.0
0009C:  GOTO   07CA
000A0:  MOVFF  0E,00
000A4:  MOVFF  0F,01
000A8:  MOVFF  10,02
000AC:  MOVFF  11,03
000B0:  MOVFF  0C,FE9
000B4:  MOVFF  07,FEA
000B8:  BSF    07.7
000BA:  MOVFF  08,FE1
000BE:  MOVFF  09,FE2
000C2:  MOVFF  0A,FD9
000C6:  MOVFF  0B,FDA
000CA:  MOVFF  12,FF3
000CE:  MOVFF  13,FF4
000D2:  MOVFF  14,FFA
000D6:  MOVFF  15,FF5
000DA:  MOVFF  16,FF6
000DE:  MOVFF  17,FF7
000E2:  MOVF   04,W
000E4:  MOVFF  06,FE0
000E8:  MOVFF  05,FD8
000EC:  RETFIE 0
000EE:  MOVWF  1A
000F0:  MOVFF  FD8,1B
000F4:  MOVFF  FE0,1C
000F8:  MOVLB  0
000FA:  MOVFF  FE9,22
000FE:  MOVFF  FEA,1D
00102:  MOVFF  FE1,1E
00106:  MOVFF  FE2,1F
0010A:  MOVFF  FD9,20
0010E:  MOVFF  FDA,21
00112:  MOVFF  FF3,28
00116:  MOVFF  FF4,29
0011A:  MOVFF  FFA,2A
0011E:  MOVFF  FF5,2B
00122:  MOVFF  FF6,2C
00126:  MOVFF  FF7,2D
0012A:  MOVFF  00,24
0012E:  MOVFF  01,25
00132:  MOVFF  02,26
00136:  MOVFF  03,27
0013A:  BTFSS  F7A.2
0013C:  GOTO   0146
00140:  BTFSC  F7B.2
00142:  GOTO   3060
00146:  BTFSS  F7A.0
00148:  GOTO   0152
0014C:  BTFSC  F7B.0
0014E:  GOTO   1F0A
00152:  BTFSS  FF2.4
00154:  GOTO   015E
00158:  BTFSC  FF2.1
0015A:  GOTO   0800
0015E:  MOVFF  24,00
00162:  MOVFF  25,01
00166:  MOVFF  26,02
0016A:  MOVFF  27,03
0016E:  MOVFF  22,FE9
00172:  MOVFF  1D,FEA
00176:  BSF    1D.7
00178:  MOVFF  1E,FE1
0017C:  MOVFF  1F,FE2
00180:  MOVFF  20,FD9
00184:  MOVFF  21,FDA
00188:  MOVFF  28,FF3
0018C:  MOVFF  29,FF4
00190:  MOVFF  2A,FFA
00194:  MOVFF  2B,FF5
00198:  MOVFF  2C,FF6
0019C:  MOVFF  2D,FF7
001A0:  MOVF   1A,W
001A2:  MOVFF  1C,FE0
001A6:  MOVFF  1B,FD8
001AA:  RETFIE 0
.................... // required device includes/settings 
.................... #include <18F46K22.h> 
.................... //////////// Standard Header file for the PIC18F46K22 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F46K22 
001AC:  ADDLW  BA
001AE:  MOVWF  FF6
001B0:  MOVLW  01
001B2:  ADDWFC FF7,F
001B4:  TBLRD*+
001B6:  MOVF   FF5,W
001B8:  RETURN 0
001BA:  DATA 00,00
001BC:  DATA 89,11
001BE:  DATA 12,23
001C0:  DATA 9B,32
001C2:  DATA 24,46
001C4:  DATA AD,57
001C6:  DATA 36,65
001C8:  DATA BF,74
001CA:  DATA 48,8C
001CC:  DATA C1,9D
001CE:  DATA 5A,AF
001D0:  DATA D3,BE
001D2:  DATA 6C,CA
001D4:  DATA E5,DB
001D6:  DATA 7E,E9
001D8:  DATA F7,F8
001DA:  DATA 81,10
001DC:  DATA 08,01
001DE:  DATA 93,33
001E0:  DATA 1A,22
001E2:  DATA A5,56
001E4:  DATA 2C,47
001E6:  DATA B7,75
001E8:  DATA 3E,64
001EA:  DATA C9,9C
001EC:  DATA 40,8D
001EE:  DATA DB,BF
001F0:  DATA 52,AE
001F2:  DATA ED,DA
001F4:  DATA 64,CB
001F6:  DATA FF,F9
001F8:  DATA 76,E8
001FA:  DATA 02,21
001FC:  DATA 8B,30
001FE:  DATA 10,02
00200:  DATA 99,13
00202:  DATA 26,67
00204:  DATA AF,76
00206:  DATA 34,44
00208:  DATA BD,55
0020A:  DATA 4A,AD
0020C:  DATA C3,BC
0020E:  DATA 58,8E
00210:  DATA D1,9F
00212:  DATA 6E,EB
00214:  DATA E7,FA
00216:  DATA 7C,C8
00218:  DATA F5,D9
0021A:  DATA 83,31
0021C:  DATA 0A,20
0021E:  DATA 91,12
00220:  DATA 18,03
00222:  DATA A7,77
00224:  DATA 2E,66
00226:  DATA B5,54
00228:  DATA 3C,45
0022A:  DATA CB,BD
0022C:  DATA 42,AC
0022E:  DATA D9,9E
00230:  DATA 50,8F
00232:  DATA EF,FB
00234:  DATA 66,EA
00236:  DATA FD,D8
00238:  DATA 74,C9
0023A:  DATA 04,42
0023C:  DATA 8D,53
0023E:  DATA 16,61
00240:  DATA 9F,70
00242:  DATA 20,04
00244:  DATA A9,15
00246:  DATA 32,27
00248:  DATA BB,36
0024A:  DATA 4C,CE
0024C:  DATA C5,DF
0024E:  DATA 5E,ED
00250:  DATA D7,FC
00252:  DATA 68,88
00254:  DATA E1,99
00256:  DATA 7A,AB
00258:  DATA F3,BA
0025A:  DATA 85,52
0025C:  DATA 0C,43
0025E:  DATA 97,71
00260:  DATA 1E,60
00262:  DATA A1,14
00264:  DATA 28,05
00266:  DATA B3,37
00268:  DATA 3A,26
0026A:  DATA CD,DE
0026C:  DATA 44,CF
0026E:  DATA DF,FD
00270:  DATA 56,EC
00272:  DATA E9,98
00274:  DATA 60,89
00276:  DATA FB,BB
00278:  DATA 72,AA
0027A:  DATA 06,63
0027C:  DATA 8F,72
0027E:  DATA 14,40
00280:  DATA 9D,51
00282:  DATA 22,25
00284:  DATA AB,34
00286:  DATA 30,06
00288:  DATA B9,17
0028A:  DATA 4E,EF
0028C:  DATA C7,FE
0028E:  DATA 5C,CC
00290:  DATA D5,DD
00292:  DATA 6A,A9
00294:  DATA E3,B8
00296:  DATA 78,8A
00298:  DATA F1,9B
0029A:  DATA 87,73
0029C:  DATA 0E,62
0029E:  DATA 95,50
002A0:  DATA 1C,41
002A2:  DATA A3,35
002A4:  DATA 2A,24
002A6:  DATA B1,16
002A8:  DATA 38,07
002AA:  DATA CF,FF
002AC:  DATA 46,EE
002AE:  DATA DD,DC
002B0:  DATA 54,CD
002B2:  DATA EB,B9
002B4:  DATA 62,A8
002B6:  DATA F9,9A
002B8:  DATA 70,8B
002BA:  DATA 08,84
002BC:  DATA 81,95
002BE:  DATA 1A,A7
002C0:  DATA 93,B6
002C2:  DATA 2C,C2
002C4:  DATA A5,D3
002C6:  DATA 3E,E1
002C8:  DATA B7,F0
002CA:  DATA 40,08
002CC:  DATA C9,19
002CE:  DATA 52,2B
002D0:  DATA DB,3A
002D2:  DATA 64,4E
002D4:  DATA ED,5F
002D6:  DATA 76,6D
002D8:  DATA FF,7C
002DA:  DATA 89,94
002DC:  DATA 00,85
002DE:  DATA 9B,B7
002E0:  DATA 12,A6
002E2:  DATA AD,D2
002E4:  DATA 24,C3
002E6:  DATA BF,F1
002E8:  DATA 36,E0
002EA:  DATA C1,18
002EC:  DATA 48,09
002EE:  DATA D3,3B
002F0:  DATA 5A,2A
002F2:  DATA E5,5E
002F4:  DATA 6C,4F
002F6:  DATA F7,7D
002F8:  DATA 7E,6C
002FA:  DATA 0A,A5
002FC:  DATA 83,B4
002FE:  DATA 18,86
00300:  DATA 91,97
00302:  DATA 2E,E3
00304:  DATA A7,F2
00306:  DATA 3C,C0
00308:  DATA B5,D1
0030A:  DATA 42,29
0030C:  DATA CB,38
0030E:  DATA 50,0A
00310:  DATA D9,1B
00312:  DATA 66,6F
00314:  DATA EF,7E
00316:  DATA 74,4C
00318:  DATA FD,5D
0031A:  DATA 8B,B5
0031C:  DATA 02,A4
0031E:  DATA 99,96
00320:  DATA 10,87
00322:  DATA AF,F3
00324:  DATA 26,E2
00326:  DATA BD,D0
00328:  DATA 34,C1
0032A:  DATA C3,39
0032C:  DATA 4A,28
0032E:  DATA D1,1A
00330:  DATA 58,0B
00332:  DATA E7,7F
00334:  DATA 6E,6E
00336:  DATA F5,5C
00338:  DATA 7C,4D
0033A:  DATA 0C,C6
0033C:  DATA 85,D7
0033E:  DATA 1E,E5
00340:  DATA 97,F4
00342:  DATA 28,80
00344:  DATA A1,91
00346:  DATA 3A,A3
00348:  DATA B3,B2
0034A:  DATA 44,4A
0034C:  DATA CD,5B
0034E:  DATA 56,69
00350:  DATA DF,78
00352:  DATA 60,0C
00354:  DATA E9,1D
00356:  DATA 72,2F
00358:  DATA FB,3E
0035A:  DATA 8D,D6
0035C:  DATA 04,C7
0035E:  DATA 9F,F5
00360:  DATA 16,E4
00362:  DATA A9,90
00364:  DATA 20,81
00366:  DATA BB,B3
00368:  DATA 32,A2
0036A:  DATA C5,5A
0036C:  DATA 4C,4B
0036E:  DATA D7,79
00370:  DATA 5E,68
00372:  DATA E1,1C
00374:  DATA 68,0D
00376:  DATA F3,3F
00378:  DATA 7A,2E
0037A:  DATA 0E,E7
0037C:  DATA 87,F6
0037E:  DATA 1C,C4
00380:  DATA 95,D5
00382:  DATA 2A,A1
00384:  DATA A3,B0
00386:  DATA 38,82
00388:  DATA B1,93
0038A:  DATA 46,6B
0038C:  DATA CF,7A
0038E:  DATA 54,48
00390:  DATA DD,59
00392:  DATA 62,2D
00394:  DATA EB,3C
00396:  DATA 70,0E
00398:  DATA F9,1F
0039A:  DATA 8F,F7
0039C:  DATA 06,E6
0039E:  DATA 9D,D4
003A0:  DATA 14,C5
003A2:  DATA AB,B1
003A4:  DATA 22,A0
003A6:  DATA B9,92
003A8:  DATA 30,83
003AA:  DATA C7,7B
003AC:  DATA 4E,6A
003AE:  DATA D5,58
003B0:  DATA 5C,49
003B2:  DATA E3,3D
003B4:  DATA 6A,2C
003B6:  DATA F1,1E
003B8:  DATA 78,0F
003BA:  CLRF   FF7
003BC:  ADDLW  CA
003BE:  MOVWF  FF6
003C0:  MOVLW  03
003C2:  ADDWFC FF7,F
003C4:  TBLRD*+
003C6:  MOVF   FF5,W
003C8:  RETURN 0
003CA:  DATA 45,6E
003CC:  DATA 74,65
003CE:  DATA 72,20
003D0:  DATA 44,65
003D2:  DATA 65,70
003D4:  DATA 20,53
003D6:  DATA 6C,65
003D8:  DATA 65,70
003DA:  DATA 00,00
003DC:  CLRF   FF7
003DE:  ADDLW  EC
003E0:  MOVWF  FF6
003E2:  MOVLW  03
003E4:  ADDWFC FF7,F
003E6:  TBLRD*+
003E8:  MOVF   FF5,W
003EA:  RETURN 0
003EC:  DATA 52,65
003EE:  DATA 61,73
003F0:  DATA 6F,6E
003F2:  DATA 3A,20
003F4:  DATA 20,20
003F6:  DATA 20,20
003F8:  DATA 20,20
003FA:  DATA 20,20
003FC:  DATA 00,00
003FE:  CLRF   FF7
00400:  ADDLW  0E
00402:  MOVWF  FF6
00404:  MOVLW  04
00406:  ADDWFC FF7,F
00408:  TBLRD*+
0040A:  MOVF   FF5,W
0040C:  RETURN 0
0040E:  DATA 20,53
00410:  DATA 65,61
00412:  DATA 72,63
00414:  DATA 68,69
00416:  DATA 6E,67
00418:  DATA 20,3F
0041A:  DATA 3F,3F
0041C:  DATA 3F,20
0041E:  DATA 00,00
00420:  CLRF   FF7
00422:  ADDLW  30
00424:  MOVWF  FF6
00426:  MOVLW  04
00428:  ADDWFC FF7,F
0042A:  TBLRD*+
0042C:  MOVF   FF5,W
0042E:  RETURN 0
00430:  DATA 6E,6E
00432:  DATA 6E,6E
00434:  DATA 20,69
00436:  DATA 69,69
00438:  DATA 20,73
0043A:  DATA 73,73
0043C:  DATA 20,64
0043E:  DATA 64,64
00440:  DATA 00,00
00442:  CLRF   FF7
00444:  ADDLW  52
00446:  MOVWF  FF6
00448:  MOVLW  04
0044A:  ADDWFC FF7,F
0044C:  TBLRD*+
0044E:  MOVF   FF5,W
00450:  RETURN 0
00452:  DATA 53,57
00454:  DATA 31,20
00456:  DATA 74,6F
00458:  DATA 20,4A
0045A:  DATA 6F,69
0045C:  DATA 6E,20
0045E:  DATA 20,20
00460:  DATA 20,20
00462:  DATA 00,00
00464:  CLRF   FF7
00466:  ADDLW  74
00468:  MOVWF  FF6
0046A:  MOVLW  04
0046C:  ADDWFC FF7,F
0046E:  TBLRD*+
00470:  MOVF   FF5,W
00472:  RETURN 0
00474:  DATA 53,74
00476:  DATA 72,6F
00478:  DATA 6E,67
0047A:  DATA 65,73
0047C:  DATA 74,3A
0047E:  DATA 20,20
00480:  DATA 20,20
00482:  DATA 20,20
00484:  DATA 00,00
00486:  CLRF   FF7
00488:  ADDLW  96
0048A:  MOVWF  FF6
0048C:  MOVLW  04
0048E:  ADDWFC FF7,F
00490:  TBLRD*+
00492:  MOVF   FF5,W
00494:  RETURN 0
00496:  DATA 20,53
00498:  DATA 65,61
0049A:  DATA 72,63
0049C:  DATA 68,20
0049E:  DATA 53,75
004A0:  DATA 63,63
004A2:  DATA 65,73
004A4:  DATA 73,20
004A6:  DATA 00,00
004A8:  CLRF   FF7
004AA:  ADDLW  B8
004AC:  MOVWF  FF6
004AE:  MOVLW  04
004B0:  ADDWFC FF7,F
004B2:  TBLRD*+
004B4:  MOVF   FF5,W
004B6:  RETURN 0
004B8:  DATA 4E,65
004BA:  DATA 78,74
004BC:  DATA 20,6A
004BE:  DATA 6F,69
004C0:  DATA 6E,3A
004C2:  DATA 20,20
004C4:  DATA 20,20
004C6:  DATA 20,20
004C8:  DATA 00,00
004CA:  CLRF   FF7
004CC:  ADDLW  DA
004CE:  MOVWF  FF6
004D0:  MOVLW  04
004D2:  ADDWFC FF7,F
004D4:  TBLRD*+
004D6:  MOVF   FF5,W
004D8:  RETURN 0
004DA:  DATA 20,20
004DC:  DATA 20,20
004DE:  DATA 20,20
004E0:  DATA 20,20
004E2:  DATA 20,20
004E4:  DATA 20,20
004E6:  DATA 20,20
004E8:  DATA 20,20
004EA:  DATA 00,00
004EC:  CLRF   FF7
004EE:  ADDLW  FC
004F0:  MOVWF  FF6
004F2:  MOVLW  04
004F4:  ADDWFC FF7,F
004F6:  TBLRD*+
004F8:  MOVF   FF5,W
004FA:  RETURN 0
004FC:  DATA 56,62
004FE:  DATA 61,74
00500:  DATA 74,20
00502:  DATA 3D,20
00504:  DATA 20,20
00506:  DATA 20,20
00508:  DATA 20,56
0050A:  DATA 20,20
0050C:  DATA 00,00
0050E:  CLRF   FF7
00510:  ADDLW  1E
00512:  MOVWF  FF6
00514:  MOVLW  05
00516:  ADDWFC FF7,F
00518:  TBLRD*+
0051A:  MOVF   FF5,W
0051C:  RETURN 0
0051E:  DATA 53,68
00520:  DATA 74,64
00522:  DATA 77,6E
00524:  DATA 20,43
00526:  DATA 61,75
00528:  DATA 73,65
0052A:  DATA 3A,20
0052C:  DATA 20,20
0052E:  DATA 00,00
00530:  CLRF   FF7
00532:  ADDLW  40
00534:  MOVWF  FF6
00536:  MOVLW  05
00538:  ADDWFC FF7,F
0053A:  TBLRD*+
0053C:  MOVF   FF5,W
0053E:  RETURN 0
00540:  DATA 76,20
00542:  DATA 20,20
00544:  DATA 20,20
00546:  DATA 20,72
00548:  DATA 20,20
0054A:  DATA 20,20
0054C:  DATA 74,20
0054E:  DATA 20,20
00550:  DATA 00,00
00552:  CLRF   FF7
00554:  ADDLW  62
00556:  MOVWF  FF6
00558:  MOVLW  05
0055A:  ADDWFC FF7,F
0055C:  TBLRD*+
0055E:  MOVF   FF5,W
00560:  RETURN 0
00562:  DATA 63,20
00564:  DATA 20,20
00566:  DATA 20,20
00568:  DATA 20,71
0056A:  DATA 20,20
0056C:  DATA 20,20
0056E:  DATA 61,20
00570:  DATA 20,20
00572:  DATA 00,00
00574:  CLRF   FF7
00576:  ADDLW  84
00578:  MOVWF  FF6
0057A:  MOVLW  05
0057C:  ADDWFC FF7,F
0057E:  TBLRD*+
00580:  MOVF   FF5,W
00582:  RETURN 0
00584:  DATA 6D,20
00586:  DATA 20,20
00588:  DATA 20,20
0058A:  DATA 20,20
0058C:  DATA 6E,20
0058E:  DATA 20,20
00590:  DATA 20,20
00592:  DATA 2A,20
00594:  DATA 00,00
00596:  CLRF   FF7
00598:  ADDLW  A6
0059A:  MOVWF  FF6
0059C:  MOVLW  05
0059E:  ADDWFC FF7,F
005A0:  TBLRD*+
005A2:  MOVF   FF5,W
005A4:  RETURN 0
005A6:  DATA 70,20
005A8:  DATA 20,20
005AA:  DATA 20,20
005AC:  DATA 20,20
005AE:  DATA 2E,20
005B0:  DATA 20,20
005B2:  DATA 20,20
005B4:  DATA 20,20
005B6:  DATA 00,00
005B8:  CLRF   FF7
005BA:  ADDLW  C8
005BC:  MOVWF  FF6
005BE:  MOVLW  05
005C0:  ADDWFC FF7,F
005C2:  TBLRD*+
005C4:  MOVF   FF5,W
005C6:  RETURN 0
005C8:  DATA 2A,2A
005CA:  DATA 2A,00
005CC:  CLRF   FF7
005CE:  ADDLW  DC
005D0:  MOVWF  FF6
005D2:  MOVLW  05
005D4:  ADDWFC FF7,F
005D6:  TBLRD*+
005D8:  MOVF   FF5,W
005DA:  RETURN 0
005DC:  DATA 62,72
005DE:  DATA 20,20
005E0:  DATA 20,20
005E2:  DATA 63,68
005E4:  DATA 20,20
005E6:  DATA 20,20
005E8:  DATA 6D,70
005EA:  DATA 20,20
005EC:  DATA 00,00
005EE:  CLRF   FF7
005F0:  ADDLW  FE
005F2:  MOVWF  FF6
005F4:  MOVLW  05
005F6:  ADDWFC FF7,F
005F8:  TBLRD*+
005FA:  MOVF   FF5,W
005FC:  RETURN 0
005FE:  DATA 72,20
00600:  DATA 20,20
00602:  DATA 2F,20
00604:  DATA 20,20
00606:  DATA 20,76
00608:  DATA 67,20
0060A:  DATA 20,2E
0060C:  DATA 20,20
0060E:  DATA 00,00
00610:  CLRF   FF7
00612:  ADDLW  20
00614:  MOVWF  FF6
00616:  MOVLW  06
00618:  ADDWFC FF7,F
0061A:  TBLRD*+
0061C:  MOVF   FF5,W
0061E:  RETURN 0
00620:  DATA 73,79
00622:  DATA 73,74
00624:  DATA 65,6D
00626:  DATA 20,73
00628:  DATA 74,61
0062A:  DATA 74,65
0062C:  DATA 20,20
0062E:  DATA 20,20
00630:  DATA 00,00
00632:  CLRF   FF7
00634:  ADDLW  42
00636:  MOVWF  FF6
00638:  MOVLW  06
0063A:  ADDWFC FF7,F
0063C:  TBLRD*+
0063E:  MOVF   FF5,W
00640:  RETURN 0
00642:  DATA 53,65
00644:  DATA 74,75
00646:  DATA 70,20
00648:  DATA 4D,61
0064A:  DATA 6E,61
0064C:  DATA 67,65
0064E:  DATA 72,2E
00650:  DATA 2E,2E
00652:  DATA 00,00
00654:  CLRF   FF7
00656:  ADDLW  64
00658:  MOVWF  FF6
0065A:  MOVLW  06
0065C:  ADDWFC FF7,F
0065E:  TBLRD*+
00660:  MOVF   FF5,W
00662:  RETURN 0
00664:  DATA 20,20
00666:  DATA 52,65
00668:  DATA 6C,65
0066A:  DATA 61,73
0066C:  DATA 65,20
0066E:  DATA 53,57
00670:  DATA 31,20
00672:  DATA 20,20
00674:  DATA 00,00
00676:  CLRF   FF7
00678:  ADDLW  86
0067A:  MOVWF  FF6
0067C:  MOVLW  06
0067E:  ADDWFC FF7,F
00680:  TBLRD*+
00682:  MOVF   FF5,W
00684:  RETURN 0
00686:  DATA 44,65
00688:  DATA 61,6C
0068A:  DATA 20,57
0068C:  DATA 69,74
0068E:  DATA 68,20
00690:  DATA 50,61
00692:  DATA 63,6B
00694:  DATA 65,74
00696:  DATA 00,00
00698:  CLRF   FF7
0069A:  ADDLW  A8
0069C:  MOVWF  FF6
0069E:  MOVLW  06
006A0:  ADDWFC FF7,F
006A2:  TBLRD*+
006A4:  MOVF   FF5,W
006A6:  RETURN 0
006A8:  DATA 56,4C
006AA:  DATA 56,20
006AC:  DATA 43,61
006AE:  DATA 6C,69
006B0:  DATA 62,72
006B2:  DATA 61,74
006B4:  DATA 69,6F
006B6:  DATA 6E,20
006B8:  DATA 00,00
006BA:  CLRF   FF7
006BC:  ADDLW  CA
006BE:  MOVWF  FF6
006C0:  MOVLW  06
006C2:  ADDWFC FF7,F
006C4:  TBLRD*+
006C6:  MOVF   FF5,W
006C8:  RETURN 0
006CA:  DATA 42,65
006CC:  DATA 67,69
006CE:  DATA 6E,69
006D0:  DATA 6E,67
006D2:  DATA 2E,2E
006D4:  DATA 2E,2E
006D6:  DATA 2E,2E
006D8:  DATA 2E,2E
006DA:  DATA 00,00
006DC:  CLRF   FF7
006DE:  ADDLW  EC
006E0:  MOVWF  FF6
006E2:  MOVLW  06
006E4:  ADDWFC FF7,F
006E6:  TBLRD*+
006E8:  MOVF   FF5,W
006EA:  RETURN 0
006EC:  DATA 43,6C
006EE:  DATA 6F,73
006F0:  DATA 65,20
006F2:  DATA 43,43
006F4:  DATA 50,3D
006F6:  DATA 20,20
006F8:  DATA 20,20
006FA:  DATA 20,20
006FC:  DATA 00,00
006FE:  CLRF   FF7
00700:  ADDLW  0E
00702:  MOVWF  FF6
00704:  MOVLW  07
00706:  ADDWFC FF7,F
00708:  TBLRD*+
0070A:  MOVF   FF5,W
0070C:  RETURN 0
0070E:  DATA 4F,70
00710:  DATA 65,6E
00712:  DATA 20,43
00714:  DATA 43,50
00716:  DATA 20,3D
00718:  DATA 20,20
0071A:  DATA 20,20
0071C:  DATA 20,20
0071E:  DATA 00,00
00720:  CLRF   FF7
00722:  ADDLW  30
00724:  MOVWF  FF6
00726:  MOVLW  07
00728:  ADDWFC FF7,F
0072A:  TBLRD*+
0072C:  MOVF   FF5,W
0072E:  RETURN 0
00730:  DATA 52,65
00732:  DATA 73,65
00734:  DATA 74,74
00736:  DATA 69,6E
00738:  DATA 67,20
0073A:  DATA 4D,6F
0073C:  DATA 74,65
0073E:  DATA 21,21
00740:  DATA 00,00
00742:  CLRF   FF7
00744:  ADDLW  52
00746:  MOVWF  FF6
00748:  MOVLW  07
0074A:  ADDWFC FF7,F
0074C:  TBLRD*+
0074E:  MOVF   FF5,W
00750:  RETURN 0
00752:  DATA 4D,6F
00754:  DATA 74,65
00756:  DATA 20,69
00758:  DATA 73,20
0075A:  DATA 44,65
0075C:  DATA 61,64
0075E:  DATA 20,20
00760:  DATA 20,20
00762:  DATA 00,00
00764:  CLRF   FF7
00766:  ADDLW  74
00768:  MOVWF  FF6
0076A:  MOVLW  07
0076C:  ADDWFC FF7,F
0076E:  TBLRD*+
00770:  MOVF   FF5,W
00772:  RETURN 0
00774:  DATA 53,65
00776:  DATA 61,72
00778:  DATA 63,68
0077A:  DATA 20,53
0077C:  DATA 74,72
0077E:  DATA 6F,6E
00780:  DATA 67,20
00782:  DATA 31,20
00784:  DATA 00,00
00786:  CLRF   FF7
00788:  ADDLW  96
0078A:  MOVWF  FF6
0078C:  MOVLW  07
0078E:  ADDWFC FF7,F
00790:  TBLRD*+
00792:  MOVF   FF5,W
00794:  RETURN 0
00796:  DATA 53,65
00798:  DATA 61,72
0079A:  DATA 63,68
0079C:  DATA 20,53
0079E:  DATA 74,72
007A0:  DATA 6F,6E
007A2:  DATA 67,20
007A4:  DATA 32,20
007A6:  DATA 00,00
007A8:  CLRF   FF7
007AA:  ADDLW  B8
007AC:  MOVWF  FF6
007AE:  MOVLW  07
007B0:  ADDWFC FF7,F
007B2:  TBLRD*+
007B4:  MOVF   FF5,W
007B6:  RETURN 0
007B8:  DATA 20,20
007BA:  DATA 49,6E
007BC:  DATA 69,74
007BE:  DATA 20,4A
007C0:  DATA 6F,69
007C2:  DATA 6E,20
007C4:  DATA 20,20
007C6:  DATA 20,20
007C8:  DATA 00,00
*
01968:  MOVLB  5
0196A:  CLRF   x91
0196C:  CLRF   x92
0196E:  MOVLW  01
01970:  MOVWF  x93
01972:  CLRF   FDA
01974:  CLRF   FD9
01976:  MOVLW  05
01978:  MOVWF  x96
0197A:  MOVLW  89
0197C:  MOVWF  x95
0197E:  MOVLW  05
01980:  MOVWF  FEA
01982:  MOVLW  8D
01984:  MOVWF  FE9
01986:  MOVFF  596,FE2
0198A:  MOVFF  595,FE1
0198E:  MOVFF  593,594
01992:  BCF    FD8.0
01994:  MOVF   FE5,W
01996:  MULWF  FEE
01998:  MOVF   FF3,W
0199A:  ADDWFC x91,F
0199C:  MOVF   FF4,W
0199E:  ADDWFC x92,F
019A0:  DECFSZ x94,F
019A2:  BRA    1992
019A4:  MOVFF  591,FDE
019A8:  MOVFF  592,591
019AC:  CLRF   x92
019AE:  BTFSC  FD8.0
019B0:  INCF   x92,F
019B2:  INCF   x95,F
019B4:  BTFSC  FD8.2
019B6:  INCF   x96,F
019B8:  INCF   x93,F
019BA:  MOVF   x93,W
019BC:  SUBLW  05
019BE:  BNZ   197E
019C0:  MOVLB  0
019C2:  RETURN 0
*
0210E:  TSTFSZ 01
02110:  BRA    2118
02112:  TSTFSZ 02
02114:  BRA    211A
02116:  BRA    2126
02118:  INCF   02,F
0211A:  MOVFF  00,FEE
0211E:  DECFSZ 01,F
02120:  BRA    211A
02122:  DECFSZ 02,F
02124:  BRA    211A
02126:  RETURN 0
*
023C0:  BTFSC  FD8.1
023C2:  BRA    23CC
023C4:  MOVLW  05
023C6:  MOVWF  FEA
023C8:  MOVLW  A5
023CA:  MOVWF  FE9
023CC:  CLRF   00
023CE:  CLRF   01
023D0:  CLRF   02
023D2:  CLRF   03
023D4:  MOVLB  5
023D6:  CLRF   xA5
023D8:  CLRF   xA6
023DA:  CLRF   xA7
023DC:  CLRF   xA8
023DE:  MOVF   xA4,W
023E0:  IORWF  xA3,W
023E2:  IORWF  xA2,W
023E4:  IORWF  xA1,W
023E6:  BZ    2440
023E8:  MOVLW  20
023EA:  MOVWF  xA9
023EC:  BCF    FD8.0
023EE:  RLCF   x9D,F
023F0:  RLCF   x9E,F
023F2:  RLCF   x9F,F
023F4:  RLCF   xA0,F
023F6:  RLCF   xA5,F
023F8:  RLCF   xA6,F
023FA:  RLCF   xA7,F
023FC:  RLCF   xA8,F
023FE:  MOVF   xA4,W
02400:  SUBWF  xA8,W
02402:  BNZ   2414
02404:  MOVF   xA3,W
02406:  SUBWF  xA7,W
02408:  BNZ   2414
0240A:  MOVF   xA2,W
0240C:  SUBWF  xA6,W
0240E:  BNZ   2414
02410:  MOVF   xA1,W
02412:  SUBWF  xA5,W
02414:  BNC   2434
02416:  MOVF   xA1,W
02418:  SUBWF  xA5,F
0241A:  MOVF   xA2,W
0241C:  BTFSS  FD8.0
0241E:  INCFSZ xA2,W
02420:  SUBWF  xA6,F
02422:  MOVF   xA3,W
02424:  BTFSS  FD8.0
02426:  INCFSZ xA3,W
02428:  SUBWF  xA7,F
0242A:  MOVF   xA4,W
0242C:  BTFSS  FD8.0
0242E:  INCFSZ xA4,W
02430:  SUBWF  xA8,F
02432:  BSF    FD8.0
02434:  RLCF   00,F
02436:  RLCF   01,F
02438:  RLCF   02,F
0243A:  RLCF   03,F
0243C:  DECFSZ xA9,F
0243E:  BRA    23EC
02440:  MOVFF  5A5,FEF
02444:  MOVFF  5A6,FEC
02448:  MOVFF  5A7,FEC
0244C:  MOVFF  5A8,FEC
02450:  MOVLB  0
02452:  RETURN 0
*
04174:  CLRF   01
04176:  CLRF   02
04178:  CLRF   00
0417A:  CLRF   03
0417C:  MOVLB  5
0417E:  MOVF   x74,W
04180:  BNZ   4186
04182:  MOVF   x73,W
04184:  BZ    41B6
04186:  MOVLW  10
04188:  MOVWF  x75
0418A:  BCF    FD8.0
0418C:  RLCF   x71,F
0418E:  RLCF   x72,F
04190:  RLCF   00,F
04192:  RLCF   03,F
04194:  MOVF   x74,W
04196:  SUBWF  03,W
04198:  BNZ   419E
0419A:  MOVF   x73,W
0419C:  SUBWF  00,W
0419E:  BNC   41AE
041A0:  MOVF   x73,W
041A2:  SUBWF  00,F
041A4:  BTFSS  FD8.0
041A6:  DECF   03,F
041A8:  MOVF   x74,W
041AA:  SUBWF  03,F
041AC:  BSF    FD8.0
041AE:  RLCF   01,F
041B0:  RLCF   02,F
041B2:  DECFSZ x75,F
041B4:  BRA    418A
041B6:  MOVLB  0
041B8:  RETURN 0
*
04608:  MOVLW  8E
0460A:  MOVWF  00
0460C:  MOVFF  56A,01
04610:  MOVFF  569,02
04614:  CLRF   03
04616:  MOVF   01,F
04618:  BNZ   462C
0461A:  MOVFF  02,01
0461E:  CLRF   02
04620:  MOVLW  08
04622:  SUBWF  00,F
04624:  MOVF   01,F
04626:  BNZ   462C
04628:  CLRF   00
0462A:  BRA    463C
0462C:  BCF    FD8.0
0462E:  BTFSC  01.7
04630:  BRA    463A
04632:  RLCF   02,F
04634:  RLCF   01,F
04636:  DECF   00,F
04638:  BRA    462C
0463A:  BCF    01.7
0463C:  RETURN 0
0463E:  MOVLB  5
04640:  MOVF   x69,W
04642:  BTFSC  FD8.2
04644:  BRA    4790
04646:  MOVWF  x75
04648:  MOVF   x6D,W
0464A:  BTFSC  FD8.2
0464C:  BRA    4790
0464E:  SUBWF  x75,F
04650:  BNC   465C
04652:  MOVLW  7F
04654:  ADDWF  x75,F
04656:  BTFSC  FD8.0
04658:  BRA    4790
0465A:  BRA    4668
0465C:  MOVLW  81
0465E:  SUBWF  x75,F
04660:  BTFSS  FD8.0
04662:  BRA    4790
04664:  BTFSC  FD8.2
04666:  BRA    4790
04668:  MOVFF  575,00
0466C:  CLRF   01
0466E:  CLRF   02
04670:  CLRF   03
04672:  CLRF   x74
04674:  MOVFF  56A,573
04678:  BSF    x73.7
0467A:  MOVFF  56B,572
0467E:  MOVFF  56C,571
04682:  MOVLW  19
04684:  MOVWF  x75
04686:  MOVF   x70,W
04688:  SUBWF  x71,F
0468A:  BC    46A6
0468C:  MOVLW  01
0468E:  SUBWF  x72,F
04690:  BC    46A6
04692:  SUBWF  x73,F
04694:  BC    46A6
04696:  SUBWF  x74,F
04698:  BC    46A6
0469A:  INCF   x74,F
0469C:  INCF   x73,F
0469E:  INCF   x72,F
046A0:  MOVF   x70,W
046A2:  ADDWF  x71,F
046A4:  BRA    46F6
046A6:  MOVF   x6F,W
046A8:  SUBWF  x72,F
046AA:  BC    46D0
046AC:  MOVLW  01
046AE:  SUBWF  x73,F
046B0:  BC    46D0
046B2:  SUBWF  x74,F
046B4:  BC    46D0
046B6:  INCF   x74,F
046B8:  INCF   x73,F
046BA:  MOVF   x6F,W
046BC:  ADDWF  x72,F
046BE:  MOVF   x70,W
046C0:  ADDWF  x71,F
046C2:  BNC   46F6
046C4:  INCF   x72,F
046C6:  BNZ   46F6
046C8:  INCF   x73,F
046CA:  BNZ   46F6
046CC:  INCF   x74,F
046CE:  BRA    46F6
046D0:  MOVF   x6E,W
046D2:  IORLW  80
046D4:  SUBWF  x73,F
046D6:  BC    46F4
046D8:  MOVLW  01
046DA:  SUBWF  x74,F
046DC:  BC    46F4
046DE:  INCF   x74,F
046E0:  MOVF   x6E,W
046E2:  IORLW  80
046E4:  ADDWF  x73,F
046E6:  MOVF   x6F,W
046E8:  ADDWF  x72,F
046EA:  BNC   46BE
046EC:  INCF   x73,F
046EE:  BNZ   46BE
046F0:  INCF   x74,F
046F2:  BRA    46BE
046F4:  BSF    03.0
046F6:  DECFSZ x75,F
046F8:  BRA    46FC
046FA:  BRA    4712
046FC:  BCF    FD8.0
046FE:  RLCF   x71,F
04700:  RLCF   x72,F
04702:  RLCF   x73,F
04704:  RLCF   x74,F
04706:  BCF    FD8.0
04708:  RLCF   03,F
0470A:  RLCF   02,F
0470C:  RLCF   01,F
0470E:  RLCF   x76,F
04710:  BRA    4686
04712:  BTFSS  x76.0
04714:  BRA    4722
04716:  BCF    FD8.0
04718:  RRCF   01,F
0471A:  RRCF   02,F
0471C:  RRCF   03,F
0471E:  RRCF   x76,F
04720:  BRA    4726
04722:  DECF   00,F
04724:  BZ    4790
04726:  BTFSC  x76.7
04728:  BRA    4766
0472A:  BCF    FD8.0
0472C:  RLCF   x71,F
0472E:  RLCF   x72,F
04730:  RLCF   x73,F
04732:  RLCF   x74,F
04734:  MOVF   x70,W
04736:  SUBWF  x71,F
04738:  BC    4748
0473A:  MOVLW  01
0473C:  SUBWF  x72,F
0473E:  BC    4748
04740:  SUBWF  x73,F
04742:  BC    4748
04744:  SUBWF  x74,F
04746:  BNC   477C
04748:  MOVF   x6F,W
0474A:  SUBWF  x72,F
0474C:  BC    4758
0474E:  MOVLW  01
04750:  SUBWF  x73,F
04752:  BC    4758
04754:  SUBWF  x74,F
04756:  BNC   477C
04758:  MOVF   x6E,W
0475A:  IORLW  80
0475C:  SUBWF  x73,F
0475E:  BC    4766
04760:  MOVLW  01
04762:  SUBWF  x74,F
04764:  BNC   477C
04766:  INCF   03,F
04768:  BNZ   477C
0476A:  INCF   02,F
0476C:  BNZ   477C
0476E:  INCF   01,F
04770:  BNZ   477C
04772:  INCF   00,F
04774:  BZ    4790
04776:  RRCF   01,F
04778:  RRCF   02,F
0477A:  RRCF   03,F
0477C:  MOVFF  56A,575
04780:  MOVF   x6E,W
04782:  XORWF  x75,F
04784:  BTFSS  x75.7
04786:  BRA    478C
04788:  BSF    01.7
0478A:  BRA    4798
0478C:  BCF    01.7
0478E:  BRA    4798
04790:  CLRF   00
04792:  CLRF   01
04794:  CLRF   02
04796:  CLRF   03
04798:  MOVLB  0
0479A:  RETURN 0
0479C:  MOVLB  5
0479E:  MOVF   x69,W
047A0:  SUBLW  B6
047A2:  MOVWF  x69
047A4:  CLRF   03
047A6:  MOVFF  56A,56D
047AA:  BSF    x6A.7
047AC:  BCF    FD8.0
047AE:  RRCF   x6A,F
047B0:  RRCF   x6B,F
047B2:  RRCF   x6C,F
047B4:  RRCF   03,F
047B6:  RRCF   02,F
047B8:  RRCF   01,F
047BA:  RRCF   00,F
047BC:  DECFSZ x69,F
047BE:  BRA    47AC
047C0:  BTFSS  x6D.7
047C2:  BRA    47DA
047C4:  COMF   00,F
047C6:  COMF   01,F
047C8:  COMF   02,F
047CA:  COMF   03,F
047CC:  INCF   00,F
047CE:  BTFSC  FD8.2
047D0:  INCF   01,F
047D2:  BTFSC  FD8.2
047D4:  INCF   02,F
047D6:  BTFSC  FD8.2
047D8:  INCF   03,F
047DA:  MOVLB  0
047DC:  RETURN 0
*
0492C:  MOVLB  5
0492E:  MOVF   x6B,W
04930:  MULWF  x6D
04932:  MOVFF  FF3,01
04936:  MOVFF  FF4,00
0493A:  MULWF  x6E
0493C:  MOVF   FF3,W
0493E:  ADDWF  00,F
04940:  MOVF   x6C,W
04942:  MULWF  x6D
04944:  MOVF   FF3,W
04946:  ADDWFC 00,W
04948:  MOVWF  02
0494A:  MOVLB  0
0494C:  RETURN 0
*
05B9C:  ADDWF  FE8,W
05B9E:  CLRF   FF7
05BA0:  RLCF   FF7,F
05BA2:  ADDLW  B7
05BA4:  MOVWF  FF6
05BA6:  MOVLW  5B
05BA8:  ADDWFC FF7,F
05BAA:  TBLRD*-
05BAC:  MOVF   FF5,W
05BAE:  MOVWF  FFA
05BB0:  TBLRD*
05BB2:  MOVF   FF5,W
05BB4:  MOVWF  FF9
05BB6:  DATA 78,56
05BB8:  DATA 08,54
05BBA:  DATA 78,56
05BBC:  DATA 94,5B
05BBE:  DATA 94,5B
05BC0:  DATA B8,58
05BC2:  DATA B8,58
05BC4:  DATA 94,5B
05BC6:  DATA 5A,5A
05BC8:  DATA F6,5A
*
068D6:  MOVLB  5
068D8:  MOVF   x68,W
068DA:  CLRF   01
068DC:  SUBWF  x67,W
068DE:  BC    68E6
068E0:  MOVFF  567,00
068E4:  BRA    68FE
068E6:  CLRF   00
068E8:  MOVLW  08
068EA:  MOVWF  x69
068EC:  RLCF   x67,F
068EE:  RLCF   00,F
068F0:  MOVF   x68,W
068F2:  SUBWF  00,W
068F4:  BTFSC  FD8.0
068F6:  MOVWF  00
068F8:  RLCF   01,F
068FA:  DECFSZ x69,F
068FC:  BRA    68EC
068FE:  MOVLB  0
06900:  RETURN 0
*
07FB8:  ADDWF  FE8,W
07FBA:  CLRF   FF7
07FBC:  RLCF   FF7,F
07FBE:  ADDLW  D3
07FC0:  MOVWF  FF6
07FC2:  MOVLW  7F
07FC4:  ADDWFC FF7,F
07FC6:  TBLRD*-
07FC8:  MOVF   FF5,W
07FCA:  MOVWF  FFA
07FCC:  TBLRD*
07FCE:  MOVF   FF5,W
07FD0:  MOVWF  FF9
07FD2:  DATA 70,71
07FD4:  DATA 86,71
07FD6:  DATA AE,7F
07FD8:  DATA AE,7F
07FDA:  DATA AE,7F
07FDC:  DATA AE,7F
07FDE:  DATA AE,7F
07FE0:  DATA AE,7F
07FE2:  DATA AE,7F
07FE4:  DATA AE,7F
07FE6:  DATA AE,7F
07FE8:  DATA AE,7F
07FEA:  DATA AE,7F
07FEC:  DATA AE,7F
07FEE:  DATA AE,7F
07FF0:  DATA 8C,71
07FF2:  DATA A2,71
07FF4:  DATA B8,71
07FF6:  DATA AE,7F
07FF8:  DATA AE,7F
07FFA:  DATA AE,7F
07FFC:  DATA AE,7F
07FFE:  DATA AE,7F
08000:  DATA AE,7F
08002:  DATA AE,7F
08004:  DATA AE,7F
08006:  DATA AE,7F
08008:  DATA AE,7F
0800A:  DATA AE,7F
0800C:  DATA AE,7F
0800E:  DATA AE,7F
08010:  DATA CE,71
08012:  DATA 3C,72
08014:  DATA AA,72
08016:  DATA 02,73
08018:  DATA AE,7F
0801A:  DATA AE,7F
0801C:  DATA AE,7F
0801E:  DATA AE,7F
08020:  DATA AE,7F
08022:  DATA AE,7F
08024:  DATA AE,7F
08026:  DATA AE,7F
08028:  DATA AE,7F
0802A:  DATA AE,7F
0802C:  DATA AE,7F
0802E:  DATA AE,7F
08030:  DATA F2,73
08032:  DATA 24,74
08034:  DATA 4A,74
08036:  DATA E6,74
08038:  DATA 0C,75
0803A:  DATA 7E,76
0803C:  DATA 96,77
0803E:  DATA AE,7F
08040:  DATA AE,7F
08042:  DATA AE,7F
08044:  DATA AE,7F
08046:  DATA AE,7F
08048:  DATA AE,7F
0804A:  DATA AE,7F
0804C:  DATA AE,7F
0804E:  DATA AE,7F
08050:  DATA E8,77
08052:  DATA F8,78
08054:  DATA 22,79
08056:  DATA 20,7B
08058:  DATA DE,7C
0805A:  DATA E6,7E
0805C:  DATA FE,7E
....................  
.................... #list 
....................  
.................... #device adc=10  
.................... #device high_ints=TRUE 
....................                   
.................... // standard libraries 
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #include <stdint.h>          
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... ////                           stdint.h                                //// 
.................... ////                                                                   //// 
.................... //// Standard integer definitions.                                     //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDINT 
....................  
.................... #define _STDINT 
....................  
.................... //////////// exact width 
....................  
.................... typedef signed int8 int8_t; 
.................... typedef unsigned int8 uint8_t; 
.................... typedef signed int16 int16_t; 
.................... typedef unsigned int16 uint16_t; 
.................... typedef signed int32 int32_t; 
.................... typedef unsigned int32 uint32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int24_t; 
.................... //typedef unsigned int24 uint24_t; 
.................... typedef signed int64 int64_t; 
.................... typedef unsigned int64 uint64_t; 
.................... #endif 
....................  
.................... #define INT8_MAX  (127) 
.................... #define INT8_MIN  (-128) 
.................... #define UINT8_MAX (255) 
....................  
.................... #define INT16_MAX  (32767) 
.................... #define INT16_MIN  (-32768) 
.................... #define UINT16_MAX (65535) 
....................  
.................... #define INT32_MAX  (2147483647) 
.................... #define INT32_MIN  (-2147483648) 
.................... #define UINT32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT24_MAX  (8388607) 
.................... //#define INT24_MIN  (-8388608) 
.................... //#define UINT24_MAX (16777215) 
....................  
.................... #define INT64_MAX  (9223372036854775807) 
.................... #define INT64_MIN  (-9223372036854775808) 
.................... #define UINT64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// minimum width 
....................  
.................... typedef signed int8 int_least8_t; 
.................... typedef unsigned int8 uint_least8_t; 
.................... typedef signed int16 int_least16_t; 
.................... typedef unsigned int16 uint_least16_t; 
.................... typedef signed int32 int_least32_t; 
.................... typedef unsigned int32 uint_least32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int_least24_t; 
.................... //typedef unsigned int24 uint_least24_t; 
.................... typedef signed int64 int_least64_t; 
.................... typedef unsigned int64 uint_least64_t; 
.................... #endif 
....................  
.................... #define INT_LEAST8_MAX  (127) 
.................... #define INT_LEAST8_MIN  (-128) 
.................... #define UINT_LEAST8_MAX (255) 
....................  
.................... #define INT_LEAST16_MAX  (32767) 
.................... #define INT_LEAST16_MIN  (-32768) 
.................... #define UINT_LEAST16_MAX (65535) 
....................  
.................... #define INT_LEAST32_MAX  (2147483647) 
.................... #define INT_LEAST32_MIN  (-2147483648) 
.................... #define UINT_LEAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_LEAST24_MAX  (8388607) 
.................... //#define INT_LEAST24_MIN  (-8388608) 
.................... //#define UINT_LEAST24_MAX (16777215) 
....................  
.................... #define INT_LEAST64_MAX  (9223372036854775807) 
.................... #define INT_LEAST64_MIN  (-9223372036854775808) 
.................... #define UINT_LEAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// fastest width 
....................  
.................... #if defined(__PCD__) 
.................... typedef signed int16 int_fast8_t; 
.................... typedef unsigned int16 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (32767) 
.................... #define INT_FAST8_MIN  (-32768) 
.................... #define UINT_FAST8_MAX (65535) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... //typedef signed int24 int_fast24_t; 
.................... //typedef unsigned int24 uint_fast24_t; 
.................... typedef signed int64 int_fast64_t; 
.................... typedef unsigned int64 uint_fast64_t; 
.................... #else 
.................... typedef signed int8 int_fast8_t; 
.................... typedef unsigned int8 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (127) 
.................... #define INT_FAST8_MIN  (-128) 
.................... #define UINT_FAST8_MAX (255) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... #endif 
....................  
.................... typedef signed int32 int_fast32_t; 
.................... typedef unsigned int32 uint_fast32_t; 
....................  
.................... #define INT_FAST16_MAX  (32767) 
.................... #define INT_FAST16_MIN  (-32768) 
.................... #define UINT_FAST16_MAX (65535) 
....................  
.................... #define INT_FAST32_MAX  (2147483647) 
.................... #define INT_FAST32_MIN  (-2147483648) 
.................... #define UINT_FAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_FAST24_MAX  (8388607) 
.................... //#define INT_FAST24_MIN  (-8388608) 
.................... //#define UINT_FAST24_MAX (16777215) 
....................  
.................... #define INT_FAST64_MAX  (9223372036854775807) 
.................... #define INT_FAST64_MIN  (-9223372036854775808) 
.................... #define UINT_FAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... //////////// big enough to hold pointers (OPTIONAL) 
....................  
.................... /// TODO 
....................  
.................... /// intptr_t uintptr_t 
....................  
.................... /// INTPTRN_MIN INTPTRN_MAX UINTPTRN_MAX 
....................  
....................  
.................... /////////// greatest width (OPTIONAL) 
....................  
.................... /// TODO 
....................  
.................... /// intmax_t uintmax_t 
....................  
.................... /// INTMAXN_MIN INTMAXN_MAX UINTMAXN_MAX 
....................  
.................... /// INTMAX_C(value) UINTMAX_C(value) 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... size_t mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
*
041BA:  CLRF   19
041BC:  BTFSC  FF2.7
041BE:  BSF    19.7
041C0:  BCF    FF2.7
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
041C2:  MOVFF  34,58C
041C6:  MOVFF  33,58B
041CA:  MOVFF  32,58A
041CE:  MOVFF  31,589
041D2:  MOVLW  41
041D4:  MOVLB  5
041D6:  MOVWF  x90
041D8:  MOVLW  C6
041DA:  MOVWF  x8F
041DC:  MOVLW  4E
041DE:  MOVWF  x8E
041E0:  MOVLW  6D
041E2:  MOVWF  x8D
041E4:  MOVLB  0
041E6:  CALL   1968
041EA:  BTFSC  19.7
041EC:  BSF    FF2.7
041EE:  MOVLW  39
041F0:  MOVLB  5
041F2:  ADDWF  00,W
041F4:  MOVWF  31
041F6:  MOVLW  30
041F8:  ADDWFC 01,W
041FA:  MOVWF  32
041FC:  MOVLW  00
041FE:  ADDWFC 02,W
04200:  MOVWF  33
04202:  MOVLW  00
04204:  ADDWFC 03,W
04206:  MOVWF  34
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
04208:  MOVFF  33,00
0420C:  MOVFF  34,01
04210:  CLRF   02
04212:  CLRF   03
04214:  MOVFF  34,549
04218:  MOVFF  33,548
0421C:  MOVFF  34,572
04220:  MOVFF  33,571
04224:  MOVLW  7F
04226:  MOVWF  x74
04228:  SETF   x73
0422A:  MOVLB  0
0422C:  RCALL  4174
0422E:  MOVFF  00,01
04232:  MOVFF  03,02
04236:  GOTO   4278 (RETURN)
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
*
04160:  MOVFF  54B,34
04164:  MOVFF  54A,33
04168:  MOVFF  549,32
0416C:  MOVFF  548,31
04170:  GOTO   4276 (RETURN)
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdlibm.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... /*********************************************************************/ 
.................... #ifndef _STDLIBM 
.................... #define _STDLIBM 
....................  
.................... /* Memory Management Functions*/ 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... typedef struct nodet { 
....................    unsigned int8 size; 
....................    unsigned int8 next; }node_t; 
.................... #elif defined(__PCM__) 
.................... typedef struct nodet { 
....................    unsigned int8 size; 
....................    unsigned int16 next; }node_t; 
.................... #elif defined(__PCH__) 
.................... typedef struct nodet { 
....................    unsigned int16 size; 
....................    unsigned int16 next; }node_t; 
.................... #elif defined(__PCD__) 
.................... typedef struct nodet { 
....................    unsigned int16 size; 
....................    unsigned int16 next; }node_t; 
.................... #endif 
....................  
.................... #if !defined(STDLIBM_MANUAL_DYNAMIC_MEMORY) 
....................    #USE DYNAMIC_MEMORY 
.................... #endif 
....................  
.................... #ifndef debug_stdlibm 
....................    #define debug_stdlibm(s) 
.................... #else 
....................    #define __DO_DEBUG_STDLIBM 
....................     
....................    char g_DebugStdlibmStr[50]; 
....................     
....................    #if defined(__PCD__) 
....................       #if (defined(__PIC24E__)||defined(__dsPIC33E__)) 
....................          #define INVALID_MEMORY_LOCATION(x) ((x >= (getenv("RAM")+0x800)) || bit_test(x, 0)) 
....................       #else 
....................          #define INVALID_MEMORY_LOCATION(x) ((x >= (getenv("RAM")+0x1000)) || bit_test(x, 0)) 
....................       #endif 
....................    #else 
....................       #define INVALID_MEMORY_LOCATION(x) (x >= getenv("RAM")) 
....................    #endif 
.................... #endif 
....................  
.................... #include <memmgmt.c> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #if defined(__PCH__) 
....................  #define _MEMMGMT_CSIZE 32768 
....................  #define _MEMMGMT_POS 15 
.................... #elif defined(__PCD__) 
....................    #define _MEMMGMT_CSIZE 32768 
....................    #define _MEMMGMT_POS 15 
.................... #else 
....................    #define _MEMMGMT_CSIZE 127 
....................    #define _MEMMGMT_POS 7 
.................... #endif 
....................  
.................... node_t * create_node(unsigned int16 size, node_t *ptr) // create node at given location 
.................... { 
....................    node_t *result; 
....................    result =ptr; 
....................    result->size=size; 
....................    result->next = NULL; 
....................    return result; 
.................... } 
.................... void update_node(node_t *node, unsigned int16 size) // update the size of given node 
.................... { 
....................    node->size=size; 
.................... } 
....................  
.................... /* Insert node immediately after place */ //old,new 
.................... void insert_node_after(node_t *place, node_t *node)// place the node after another given node 
.................... { 
....................     if (place->next==NULL) 
....................        node->next= NULL; 
....................     else 
....................        node->next=place->next; 
....................     place->next=node; 
.................... } 
....................  
.................... ///////////////////////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... void remove_node(node_t *node) {// remove the given node from the memlist 
....................    node_t *ptr; 
....................    for(ptr=__DYNAMIC_HEAD;ptr->next!=node;ptr=ptr->next); 
....................    ptr->next=node->next; 
....................    node=NULL; 
.................... } 
....................  
.................... ///////////////////////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... #if defined(__DO_DEBUG_STDLIBM) 
.................... void print_list() { // print the current memlist 
....................     node_t *node; 
....................     debug_stdlibm("\r\nThe list is \n\r"); 
....................     for(node = __DYNAMIC_HEAD; node != NULL; node = node->next) 
....................     { 
....................         sprintf(g_DebugStdlibmStr, "H:0x%lx S:0x%lx N:0x%lx\n\r", node, node->size, node->next); 
....................         debug_stdlibm(g_DebugStdlibmStr); 
....................         if (INVALID_MEMORY_LOCATION(node->next)) 
....................         { 
....................            debug_stdlibm("Breaking because of invalid next node\r\n"); 
....................            break; 
....................         }    
....................     } 
....................     sprintf(g_DebugStdlibmStr, "size of node_t %u\r\n",sizeof(node_t)); 
....................     debug_stdlibm(g_DebugStdlibmStr); 
.................... } 
.................... #endif 
....................  
....................  
....................  
....................  
.................... void traverse() 
.................... { 
....................    node_t *node,*temp; 
....................    unsigned int16 nsize,nextsize; 
....................    node=__DYNAMIC_HEAD; 
....................    while(node!=NULL) 
....................    { 
....................      #if defined(__DO_DEBUG_STDLIBM) 
....................       if (INVALID_MEMORY_LOCATION(node)) 
....................       { 
....................          sprintf(g_DebugStdlibmStr, "traverse() invalid node (0x%LX)\r\n", node); 
....................          debug_stdlibm(g_DebugStdlibmStr); 
....................          break; 
....................       }    
....................      #endif 
....................      if(!bit_test(node->size,_MEMMGMT_POS))// node free 
....................       { 
....................          nsize=node->size; 
....................          temp=(unsigned int16)node->next; 
....................         #if defined(__DO_DEBUG_STDLIBM) 
....................          if (INVALID_MEMORY_LOCATION(temp)) 
....................          { 
....................             sprintf(g_DebugStdlibmStr, "traverse() invalid temp (0x%LX)\r\n", node); 
....................             debug_stdlibm(g_DebugStdlibmStr); 
....................             break; 
....................          } 
....................         #endif 
....................          if(!bit_test(temp->size,_MEMMGMT_POS)&& (temp==((unsigned int16)node+nsize+sizeof(node_t))))//next node free and consecutive, so combine 
....................          { 
....................             nextsize=temp->size; 
....................             nsize+=nextsize+sizeof(node_t); 
....................             remove_node(temp); 
....................             update_node(node,nsize); 
....................          } 
....................          else 
....................          node=node->next; 
....................       } 
....................       else 
....................       node=node->next; 
....................    } 
.................... } 
....................  
.................... char *malloc(size_t size) 
.................... { 
....................    node_t *node,*new; 
....................    unsigned int16 nsize; 
....................    #if defined(__PCD__) 
....................    if (size % 2) 
....................       size++; 
....................    #endif 
....................    node=__DYNAMIC_HEAD; 
....................     
....................   #if defined(__DO_DEBUG_STDLIBM) 
....................    sprintf(g_DebugStdlibmStr, "malloc() size=%lu ", size); 
....................    debug_stdlibm(g_DebugStdlibmStr); 
....................   #endif 
....................          
....................    while(node!=NULL) // chk until end of memlist 
....................    { 
....................      #if defined(__DO_DEBUG_STDLIBM) 
....................       if (INVALID_MEMORY_LOCATION(node)) 
....................       { 
....................          sprintf(g_DebugStdlibmStr, " invalid node (0x%LX)\r\n", node); 
....................          debug_stdlibm(g_DebugStdlibmStr); 
....................          print_list(); 
....................          return(0); 
....................       } 
....................      #endif 
....................       if(!bit_test(node->size,_MEMMGMT_POS) && node->size >=size) // node is free and > = req size 
....................       { 
....................          nsize=node->size;    //nsize = size of the node that "node" being pointed at 
....................          if(nsize>size +sizeof(node_t)) //node > req size, so split and add new node to memlist 
....................          { 
....................             new=create_node(nsize-size-sizeof(node_t),(unsigned int16)node+sizeof(node_t)+size); 
....................             insert_node_after(node,new); 
....................             update_node(node,size+_MEMMGMT_CSIZE); 
....................          } 
....................          else//not enough space for new node so use original size 
....................          update_node(node,nsize+_MEMMGMT_CSIZE); 
....................          //end if 
....................          break; 
....................       }//end if 
....................       node=node->next; 
....................    }//end while 
....................    if(node==NULL)// reached end without finding an appropriate node 
....................    { 
....................       debug_stdlibm("Not enough memory for mallocation\r\n"); 
....................       return NULL; 
....................    } 
....................    else 
....................    { 
....................      #if defined(__DO_DEBUG_STDLIBM) 
....................       sprintf(g_DebugStdlibmStr, "%LX\r\n", (char *)node+sizeof(node_t)); 
....................       debug_stdlibm(g_DebugStdlibmStr); 
....................      #endif 
....................       return (char *)node+sizeof(node_t); // return pounsigned int8er to allocated space 
....................    } 
.................... } 
....................  
.................... char *calloc(size_t nmemb,size_t size) 
.................... { 
....................    node_t *node,*new; 
....................    unsigned int16 nsize,resize; 
....................    node=__DYNAMIC_HEAD; 
....................    resize=nmemb*size; 
....................    #if defined(__PCD__) 
....................    if(resize%2) 
....................       resize++; 
....................    #endif 
....................    while(node!=NULL) // chk until end of memlist 
....................    { 
....................      #if defined(__DO_DEBUG_STDLIBM) 
....................       if (INVALID_MEMORY_LOCATION(node)) 
....................       { 
....................          sprintf(g_DebugStdlibmStr, "malloc() invalid node (0x%LX)\r\n", node); 
....................          debug_stdlibm(g_DebugStdlibmStr); 
....................          print_list(); 
....................          return(0); 
....................       } 
....................      #endif 
....................       if(!bit_test(node->size,_MEMMGMT_POS) && node->size >=resize)// node is free and > = req size 
....................       { 
....................          nsize=node->size; 
....................          if(nsize>resize+sizeof(node_t))//node > req size, so split and add new node to memlist 
....................          { 
....................             new=create_node(nsize-resize-sizeof(node_t),(unsigned int16)node+sizeof(node_t)+resize); 
....................             insert_node_after(node,new); 
....................             update_node(node,resize+_MEMMGMT_CSIZE); 
....................          } 
....................          else//not enough space for new node so use original size 
....................          update_node(node,nsize+_MEMMGMT_CSIZE); 
....................          //end if 
....................          break; 
....................       }//end if 
....................       node=node->next; 
....................    }//end while 
....................    if(node==NULL)// reached end without finding an appropriate node 
....................    { 
....................       debug_stdlibm("Not enough memory for callocation\r\n"); 
....................       return NULL; 
....................    } 
....................    else 
....................    { 
....................       memset((unsigned int16)node+sizeof(node_t),0,resize);// initialize to 0 
....................       return (char *)(unsigned int16)node+sizeof(node_t);// return pounsigned int8er to allocated space 
....................    } 
.................... } 
.................... void free( void * ptr) 
.................... { 
....................    node_t *node; 
....................    unsigned int16 nsize; 
....................  
....................   #if defined(__DO_DEBUG_STDLIBM) 
....................    sprintf(g_DebugStdlibmStr, "free() 0x%LX\r\n", ptr); 
....................    debug_stdlibm(g_DebugStdlibmStr); 
....................   #endif 
....................  
....................    if(ptr==NULL) // not a valid pounsigned int8er 
....................       return; 
....................    else 
....................    { 
....................       node=ptr-sizeof(node_t); 
....................       if(bit_test(node->size,_MEMMGMT_POS))// node occupied 
....................       { 
....................          nsize=node->size-_MEMMGMT_CSIZE; 
....................          update_node(node,nsize); 
....................          ptr=NULL; 
....................  
....................       } 
....................       else // wrong input, return 
....................       { 
....................          ptr=NULL; 
....................          return; 
....................       } 
....................    } 
....................    traverse(); 
.................... } 
....................  
.................... char *realloc(void *ptr,size_t size) 
.................... { 
....................    node_t *node,*new,*temp; 
....................    unsigned int16 nsize,nextsize; 
....................    char *newptr; 
....................    #if defined(__PCD__) 
....................    if(size %2) 
....................       size++; 
....................    #endif 
....................    if(ptr==NULL)// null pounsigned int8er, so malloc the req memory 
....................       return(malloc(size)); 
....................    else if(size==0) 
....................    { 
....................       free(ptr); 
....................       return(NULL); 
....................    } 
....................    else 
....................    { 
....................       node=ptr-sizeof(node_t); 
....................       if(bit_test(node->size,_MEMMGMT_POS))// chk if valid pounsigned int8er 
....................       { 
....................          nsize=node->size-_MEMMGMT_CSIZE; 
....................          temp=(unsigned int16)node->next; 
....................          if(nsize>size)// block > req size 
....................          { 
....................         
....................                if(!bit_test(temp->size,_MEMMGMT_POS) && (temp==((unsigned int16)node+nsize+sizeof(node_t))))// next block free and consecutive 
....................                { 
....................                   update_node(node,size+_MEMMGMT_CSIZE); // update block 
....................                   nextsize=temp->size; 
....................                   remove_node(temp); 
....................                   new=create_node(nextsize+(nsize-size),(unsigned int16)node+size+sizeof(node_t)); 
....................                   insert_node_after(node,new); 
....................                    
....................  
....................                } 
....................                else if (nsize>size +sizeof(node_t))//node > req size, so split and add new node to memlist 
....................                { 
....................                   update_node(node,size+_MEMMGMT_CSIZE); // update block 
....................                   new=create_node(nsize-size-sizeof(node_t),(unsigned int16)node+sizeof(node_t)+size); 
....................                   insert_node_after(node,new); 
....................                } 
....................                else//not enough space for new node so use original size 
....................                update_node(node,nsize+_MEMMGMT_CSIZE); // update block 
....................  
....................          } 
....................          else // block < req size 
....................          { 
....................             if(!bit_test(temp->size,_MEMMGMT_POS) && (temp==((unsigned int16)node+nsize+sizeof(node_t))))// next block free and consecutive 
....................             { 
....................                nextsize=temp->size; 
....................                if(nextsize>=size-nsize) // next block >=difference 
....................                { 
....................                   if(nextsize>size-nsize+sizeof(node_t))//next node > req size, so split and add new node to memlist 
....................                   { 
....................                       update_node(node,size+_MEMMGMT_CSIZE);// update block 
....................                       remove_node(temp); 
....................                       new=create_node(nextsize-(size-nsize),(unsigned int16)node+size+sizeof(node_t)); 
....................                       insert_node_after(node,new); 
....................                   } 
....................                   else//not enough space for new node in next node, so use original size 
....................                   { 
....................                       update_node(node,nsize+nextsize+_MEMMGMT_CSIZE);// update block 
....................                       remove_node(temp); 
....................                   } 
....................                } 
....................                else  //next block free but too small for new size 
....................                { 
....................                   newptr = malloc(size);  //use malloc to find new block 
....................                   if(newptr == NULL) 
....................                      return(NULL);        //return NULL if malloc was unable to find new block 
....................                     
....................                   memcpy(newptr, ptr, nsize);   //copy original data to new block 
....................                   free(ptr);                    //free original block 
....................                   return(newptr);               //return new pointer 
....................                } 
....................             } 
....................             else  //next block not free 
....................             { 
....................                newptr = malloc(size);  //use malloc to find new block 
....................                if(newptr == NULL)       
....................                   return(NULL);        //return NULL if malloc was unable to find new block 
....................                 
....................                memcpy(newptr, ptr, nsize);   //copy original data to new block 
....................                free(ptr);                    //free original block 
....................                return(newptr);               //return new pointer 
....................             } 
....................          } 
....................          return (char *)node+sizeof(node_t); // return pounsigned int8er to the reallocated block 
....................       } 
....................       else // not allocated use malloc 
....................       { 
....................          return(malloc(size)); 
....................       } 
....................    } 
....................  } 
.................... #ENDIF 
....................  
....................  
.................... // configuration files   
.................... #include "pic_config.h" 
.................... //IF NO primary oscillator is used, no need for FCMEN or PRIMARY_SW 
.................... // or IESO; also for debug purposes place INTRC at IO pin RA6 
.................... // THINK ABOUT PUT config setting! and transitions out of sleep that require 
.................... // accurate timing for UART 
....................  
.................... /////////////////////Fuses Start/////////////////////////////////////////////// 
.................... #FUSES CCP2B3 //CCP2 input/output multiplexed with RB3 
.................... #FUSES CCP2D2 //CCP2 input/output multiplexed with RD2 
.................... #FUSES CCP3E0 //CCP3 input/output multiplexed with RE0 
.................... #FUSES HFOFST //High Frequency INTRC starts clocking CPU immediately  
.................... #FUSES HSH //High speed Osc, high power 16MHz-25MHz 
.................... #FUSES IESO //Internal External Switch Over mode enabled  
.................... #FUSES MCLR //Master Clear pin enabled  
.................... #FUSES NOBROWNOUT //No brownout reset  
.................... #FUSES NOCPB //No Boot Block code protection  
.................... #FUSES NOCPD //No EE protection  
.................... #FUSES NODEBUG //No Debug mode for ICD 
.................... #FUSES NOEBTR //Memory not protected from table reads  
.................... #FUSES NOEBTRB //Boot block not protected from table reads  
.................... #FUSES NOFCMEN //Fail-safe clock monitor disabled  
.................... #FUSES NOLVP //No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O  
.................... #FUSES NOPBADEN //PORTB pins are configured as digital I/O on RESET 
.................... #FUSES NOPLLEN //4X HW PLL disabled, 4X PLL enabled in software   
.................... #FUSES NOPROTECT //Code not protected from reading  
.................... #FUSES NOWRT //Program memory not write protected  
.................... #FUSES NOWRTB //Boot block not write protected  
.................... #FUSES NOWRTC //configuration not registers write protected  
.................... #FUSES NOWRTD //Data EEPROM not write protected  
.................... #FUSES NOXINST //Extended set extension and Indexed Addressing mode disabled (Legacy mode)  
.................... #FUSES PRIMARY_SW //Primary clock can be disabled in software  
.................... #FUSES PUT //Power Up Timer 
.................... #FUSES STVREN //Stack full/underflow will cause reset 
.................... #FUSES TIMER3B5 //Timer3 Clock In is on pin B5  
.................... #FUSES WDT32768 //Watch Dog Timer uses 1:32768 Postscale  
.................... #FUSES WDT_SW //No Watch Dog Timer, enabled in Software  
.................... //#FUSES WDT //Watch Dog Timer enabled.  
.................... /////////////////////Fuses End///////////////////////////////////////////////// 
....................                                            
.................... /////////////////////Serial and I2C Timing Setup Start///////////////////////// 
.................... #use delay(clock=3,686,400)  
.................... #use RS232 (uart1, baud=115200)        
.................... #use delay(clock=250KHZ) 
.................... // setup i2c for use on 250khz main clock 
.................... #use i2c(master, I2C1, NOINIT, FORCE_HW, SLOW) 
.................... #use  fast_io(all) 
.................... /////////////////////Serial and I2C Timing Setup End/////////////////////////// 
....................  
.................... /////////////////////Special Function Registers Start////////////////////////// 
....................  
.................... #byte    WREG     =  0x0FE8 
.................... #byte    STATUS   =  0x0FD8 
.................... #BIT     CARRY       =  STATUS.0 
....................  
.................... #byte    STKPTR   =  0x0FFC 
.................... #BIT     STKUNF      = STKPTR.6 
.................... #BIT     STKFUL      = STKPTR.7 
....................  
.................... #byte    RCON     =  0x0FD0 
.................... #BIT     IPEN        = RCON.7 
....................  
.................... #byte    INTCON   =  0x0FF2 
.................... #BIT     RBIF        = INTCON.0 
.................... #BIT     INT0IF      = INTCON.1 
.................... #BIT     TMR0IF      = INTCON.2                                                                                                           
.................... #BIT     RBIE        = INTCON.3 
.................... #BIT     INT0IE      = INTCON.4 
.................... #BIT     TMR0IE      = INTCON.5                                                                                                    
.................... #byte    INTCON2  =  0x0FF1 
.................... #BIT     RBPU        = INTCON2.7   
.................... // RBPU lo to allow individual PORTB pullups 
.................... #byte    INTCON3  =  0x0FF0   
.................... #BIT     INT1IF      =  INTCON3.0 
.................... #BIT     INT2IF      =  INTCON3.1 
....................  
.................... #byte    T0CON    =  0x0FD5 
.................... #BIT     TMR0ON      = T0CON.7 
....................  
.................... #byte    OSCCON   =  0x0FD3 
.................... #BIT     SCS0        = OSCCON.0 
.................... #BIT     SCS1        = OSCCON.1 
.................... #BIT     HFIOFS      = OSCCON.2 
.................... #BIT     OSTS        = OSCCON.3 
.................... #BIT     IDLEN       = OSCCON.7 
.................... #byte    OSCCON2  =  0x0FD2 
.................... #BIT     LFIOFS      = OSCCON2.0 
.................... #BIT     MFIOFS      = OSCCON2.1 
.................... #BIT     PRISD       = OSCCON2.2 
.................... #BIT     SOSCGO      = OSCCON2.3 
.................... #BIT     MFIOSEL     = OSCCON2.4 
.................... #BIT     SOSCRUN     = OSCCON2.6 
.................... #BIT     PLLRDY      = OSCCON2.7 
.................... #byte    OSCTUNE  =  0x0F9B 
.................... #BIT     PLLEN       = OSCTUNE.6 
.................... #BIT     INTSRC      = OSCTUNE.7 
....................  
.................... // Timer registers 
.................... #byte    TMR1H    =  0x0FCF 
.................... #byte    TMR1L    =  0x0FCE 
.................... #byte    T1CON    =  0x0FCD 
.................... #BIT     TMR1ON      = T1CON.0 
.................... #byte    T1GCON   =  0x0FCC 
.................... #BIT     T1GGO       = T1GCON.3 
....................  
.................... #byte    T2CON    =  0x0FBA 
.................... #BIT     TMR2ON      = T2CON.2 
.................... #BIT     T2CKPS0     = T2CON.0 
.................... #BIT     T2CKPS1     = T2CON.1 
.................... #byte    PR2      =  0x0FBB 
....................  
.................... #byte    TMR3H    =  0x0FB3 
.................... #byte    TMR3L    =  0x0FB2 
.................... #byte    T3CON    =  0x0FB1 
.................... #BIT     TMR3ON      =  T3CON.0 
.................... #byte    T3GCON   =  0x0FB4 
.................... #BIT     T3GGO       = T3GCON.3 
....................  
.................... #byte    T4CON    =  0x0F51 
.................... #BIT     TMR4ON      = T4CON.2 
.................... #byte    PR4      =  0x0F52 
....................  
....................  
.................... #byte    TMR5H    =  0x0F50 
.................... #byte    TMR5L    =  0x0F4F      
.................... #byte    T5CON    =  0x0F4E 
.................... #BIT     TMR5ON      = T5CON.0 
.................... #byte    T5GCON   =  0x0F4D 
.................... #BIT     T5GGO       = T5GCON.3 
....................  
.................... #byte    T6CON    =  0x0F4A 
.................... #BIT     TMR6ON      = T6CON.2 
.................... #byte    PR6      =  0x0F4B 
....................  
.................... // ADC registers 
.................... #word    ADRES    =  0x0FC3 
.................... #byte    ADCON0   =  0x0FC2 
.................... #BIT     ADON        =  ADCON0.0 
.................... #BIT     ADGO        =  ADCON0.1 
.................... #byte    ADCON2   =  0x0FC0 
.................... #define  ADC_SETUP_DEF  0xFF   // right justified read, 20TAD acquisition time (insurance), FRC 
....................  
.................... // CCP registers       
.................... #byte    CCPR1H   =  0x0FBF 
.................... #byte    CCPR1L   =  0x0FBE 
.................... #byte    CCP1CON  =  0x0FBD 
.................... #byte    CCPR2H   =  0x0F68 
.................... #byte    CCPR2L   =  0x0F67 
.................... #byte    CCP2CON  =  0x0F66 
.................... #byte    CCPR3H   =  0x0F5F 
.................... #byte    CCPR3L   =  0x0F5E 
.................... #byte    CCP3CON  =  0x0F5D 
.................... #byte    CCPR4H   =  0x0F59 
.................... #byte    CCPR4L   =  0x0F58 
.................... #byte    CCP4CON  =  0x0F57 
.................... #byte    CCPR5H   =  0x0F56 
.................... #byte    CCPR5L   =  0x0F55 
.................... #byte    CCP5CON  =  0x0F54 
....................  
.................... #byte    CCPTMRS0 =  0x0F49 
.................... #byte    CCPTMRS1 =  0x0F48 
.................... #byte    PSTR1CON =  0x0FB9 
.................... #byte    BAUDCON1 =  0x0FB8 
....................  
.................... #byte    SPBRGH1  =  0x0FB0 
.................... #byte    SPBRG1   =  0x0FAF 
.................... #byte    RCREG1   =  0x0FAE 
.................... #byte    TXREG1   =  0x0FAD 
.................... #byte    TXSTA1   =  0x0FAC 
.................... #BIT     TRMT1       = TXSTA1.1     // 1: empty xmit reg, 0: xmit in progress 
.................... #byte    RCSTA1   =  0x0FAB 
.................... #BIT     FERR1       = RCSTA1.2 
....................  
.................... #byte    PIR1     =  0x0F9E 
.................... #BIT     TMR1IF      = PIR1.0 
.................... #BIT     TMR2IF      = PIR1.1 
.................... #BIT     SSP1IF      = PIR1.3 
.................... #BIT     ADIF        = PIR1.6 
.................... #byte    PIR2     =  0x0FA1 
.................... #BIT     CCP2IF      = PIR2.0 
.................... #BIT     TMR3IF      = PIR2.1 
.................... #BIT     BCL1IF      = PIR2.3 
.................... #BIT     C1IF        = PIR2.6 
.................... #BIT     OSCFIF      = PIR2.7 
.................... #byte    PIR3     =  0x0FA4 
.................... #BIT     TMR5GIF     = PIR3.2 
.................... #BIT     TMR3GIF     = PIR3.1 
.................... #BIT     TMR1GIF     = PIR3.0 
.................... #byte    PIR4     =  0x0F7B 
.................... #BIT     CCP3IF      = PIR4.0 
.................... #BIT     CCP4IF      = PIR4.1 
.................... #BIT     CCP5IF      = PIR4.2 
.................... #byte    PIR5     =  0x0F7E 
.................... #BIT     TMR4IF      = PIR5.0 
.................... #BIT     TMR5IF      = PIR5.1 
.................... #BIT     TMR6IF      = PIR5.2 
....................  
.................... #byte    PIE1     =  0x0F9D 
.................... #BIT     TMR2IE      =  PIE1.1 
.................... #byte    PIE2     =  0x0FA0 
.................... #BIT     CCP2IE      =  PIE2.0 
.................... #byte    PIE3     =  0x0FA3 
.................... #byte    PIE4     =  0x0F7A 
.................... #byte    PIE5     =  0x0F7D 
....................  
.................... #byte    IPR1     = 0x0F9F 
.................... #byte    IPR2     = 0x0FA2 
.................... #byte    IPR3     = 0x0FA5 
.................... #byte    IPR4     = 0x0F7C 
.................... #byte    IPR5     = 0x0F7F 
....................  
.................... #byte    LATA     =  0x0F89 
.................... #byte    PORTA    =  0x0F80 
.................... #byte    TRISA    =  0x0F92 
.................... #byte    LATB     =  0x0F8A 
.................... #byte    PORTB    =  0x0F81 
.................... #byte    TRISB    =  0x0F93 
.................... #byte    LATC     =  0x0F8B 
.................... #byte    PORTC    =  0x0F82 
.................... #byte    TRISC    =  0x0F94 
.................... #byte    LATD     =  0x0F8C 
.................... #byte    PORTD    =  0x0F83 
.................... #byte    TRISD    =  0x0F95 
.................... #byte    LATE     =  0x0F8D 
.................... #byte    PORTE    =  0x0F84 
.................... #byte    TRISE    =  0x0F96 
....................  
.................... #byte    PSTR2CON =  0x0F63 
.................... #byte    IOCB     =  0x0F62 
.................... #byte    WPUB     =  0x0F61 
.................... #byte    PSTR3CON =  0x0F5A 
....................  
.................... #byte    CM1CON0  =  0x0F79 
.................... #bit     C1ON        = CM1CON0.7 
.................... #bit     C1POL       = CM1CON0.4 
.................... #byte    CM2CON0  =  0x0F78 
.................... #byte    CM2CON1  =  0x0F79 
....................  
.................... #byte    VREFCON0 =  0x0F42 
.................... #bit     FVREN    =  VREFCON0.7     //fixed voltage ref enable 
.................... #bit     FVRST    =  VREFCON0.6     //fixed voltage ref stable 
.................... #bit     FVRS1    =  VREFCON0.5     //fixed voltage select 1 
.................... #bit     FVRS0    =  VREFCON0.4     //fixed voltage select 0 
.................... #byte    VREFCON1 =  0x0F41 
.................... #byte    VREFCON2 =  0x0F40 
....................  
.................... #byte    PMD0     =  0x0F3F 
.................... #byte    PMD1     =  0x0F3E 
.................... #byte    PMD2     =  0x0F3D 
.................... #byte    CTMUICON =  0x0F43 
.................... #byte    CTMUCONL =  0x0F44 
.................... #byte    CTMUCONH =  0x0F45 
.................... #byte    SRCON1   =  0x0F46 
.................... #byte    SRCON0   =  0x0F47 
....................  
.................... #byte    SSP1CON2 =  0x0FC5 
.................... #BIT     SEN         = SSP1CON2.0 
.................... #BIT     PEN         = SSP1CON2.2 
.................... #byte    SSP1CON1 =  0x0FC6 
.................... #BIT     WCOL        = SSP1CON1.7 
.................... #byte    SSP1STAT =  0x0FC7 
.................... #BIT     I2CBUSY     = SSP1STAT.0 
....................  
.................... #define  RCON_INIT    0b00010011 
.................... // OR with RCON to SET BORn, PORn and RIn bits 
....................  
.................... /////////////////////Special Function Registers End//////////////////////////// 
....................  
.................... /////////////////////I/0 Lines and Initialization Start//////////////////////// 
....................   
.................... //  PORTA/B/C _ COLD and TRISA/B/C _ NORM are fine for lowest_pwr() I/O setup 
....................  
.................... ////////////////////ADC channel choices 
.................... #define V_EXT_REF    0        // AN0 = RA0, 1.2V accurate reference 
....................                               // use 1.2V accurate ref for measurements 
.................... #define V_VLVI       1        // AN1 = RA1 
.................... #define V_GEN        12       // AN12 = RB0 (INT0) 
.................... #define V_XDC        13       // Extra IO 1, now used for XDCR measurements 
....................       
.................... #define V_DAC        30       // DAC output may be read by ADC 
.................... #define V_FIXED      31       // 1.024/2.048/4.096V Fixed Reference (internal) 
....................  
....................  
.................... ////////////////////PORT A///////////////////// 
....................  
.................... //    V_EXT_REF    PIN_A0      // external reference, analog AN0 
.................... //    V_VLVI       PIN_A1      // sense line, valve motor current, analog AN1 
.................... #define LED2n        PIN_A2      // RA2 output, active lo 
.................... #define MOTE_RX_CTSn PIN_A3      // RA3 input active lo 
....................                                  //  mote asserts to tell micro it is 
....................                                  //  clear to rcv data from micro; 
....................                                  //  was _DUST_MTCTS 
....................                                  //  set as output, init hi 
.................... #define GPS_PWRn     PIN_A4      // RA4 output, active lo 
.................... #define MOTE_TX_CTSn PIN_A5      // RA5 output, active lo,  
....................                                  //  assert to initiate rcv data from MOTE, 
....................                                  //  byte level handshake; 
....................                                  //  was _DUST_SPCTS                                
.................... //      OSC2         PIN_A6      // xtal osc output connection 
.................... //      OSC1         PIN_A7      // xtal osc input connection 
....................  
.................... #define TRISA_NORM   0b10001011 
....................                                  // A0 analog 
....................                                  // A1 analog 
....................                                  // A2 output 
....................                                  // A3 input 
....................                                  // A4 output 
....................                                  // A5 output 
....................                                  // A6 output 
....................                                  // A7 input 
.................... #define PORTA_INIT   0b01110100 
....................                                  // A0 analog (0) 
....................                                  // A1 analog (0)  
....................                                  // A2 output active lo (1) 
....................                                  // A3 input (0) 
....................                                  // A4 output active lo (1) 
....................                                  // A5 output active lo (1) 
....................                                  // A6 output (1) 
....................                                  // A7 input (0) 
.................... #define PORTA_IDLE   PORTA_INIT 
.................... #define PORTA_DEEP   PORTA_INIT 
....................  
....................  
.................... ////////////////////PORT B//////////////////// 
....................  
.................... #define V_GEN_INT    PIN_B0      // RB0 input, high for significant v_gen; 
....................                                  //  generally analog, but may be input; 
....................                                  //  INT0 
....................                                   
.................... #define GPS_TXRDY    PIN_B1      // RB1 input, high indicates GPS has data 
....................                                  //  ready to transmit to micro 
....................                                   
.................... #define MOTE_TX_RTSn PIN_B2      // RB2 input, active lo 
....................                                  //  mote asserts to tell micro it is 
....................                                  //   ready to send data to micro; 
....................                                  //  was _DUST_MTRTS; INT2    
....................                                   
.................... #define LTC3105_CTRL PIN_B3      // output, active hi, P2A-pwm, 
....................                                  //  shdn/enab input of 3105 
....................                                  //  hi for max chg aggressiveness (lower RPM) 
....................  
.................... #BIT    LTC3105_CTRL_pinstate   = LATB.3 
....................  
....................  
.................... #define SW1n         PIN_B4      // usually an input, active lo 
....................                                  //  note can be IOC 
.................... #define LED1n        PIN_B4      // may become an output, active lo 
....................  
.................... #define ADC_XDCR     PIN_B5      // wired as input (ADC) to analog XDCR signal 
....................                                                                  
.................... #define SPARE2       PIN_B6      // consider as an input (PGC); 
....................                                  //  wired to VLV_XDCR header     
.................... #define SPARE3       PIN_B7      // consider as an input (PGD) 
....................  
.................... #define TRISB_NORM   0b11110111 
....................                                  // B0 input (INT0) 
....................                                  // B1 input (INT1) 
....................                                  // B2 input (INT2) 
....................                                  // B3 output 
....................                                  // B4 input (usually, may become an output) 
....................                                  // B5 input (spare) 
....................                                  // B6 input (PGC) 
....................                                  // B7 input (PGD)                                             
.................... #define TRISB_LED    0b11100111 
....................                                  // same as TRISB_NORM, but PIN_B4 is output 
....................                                                                                 
.................... #define PORTB_INIT   0b00011000 
....................                                  // B0 input (0) 
....................                                  // B1 input (0) 
....................                                  // B2 input (0) 
....................                                  // B3 output (LTC3105_CTRL) hi=fully charge (1) 
....................                                  // B4 usually an input,  
....................                                  //   may be output active lo (1) 
....................                                  // B5 input unused (0) 
....................                                  // B6 may be spare I/O (PGC)  
....................                                  // B7 may be spare I/O (PGD) 
.................... #define PORTB_IDLE   0b00010000  // only difference here is that LTC3105 is 
....................                                  //  shut down              
.................... #define PORTB_DEEP   PORTB_IDLE 
....................  
....................                                    
.................... #define PORTB_PULLUPS            0b00010010 
.................... #define PORTB_PULLUPS_WITH_XDCR  0b00110010             
....................                                  // only MOTE_TX_RTSn (pin B2)  
....................                                  // and SW1/LED1 are pulled up by defualt. 
....................                                  // ADC_XDCR (pin B5) is turned on for a second to detect  
....................                                  //    if the XDCR is plugged in or not during XDCR_init()   
....................                                                                         
....................                                 
....................                                                                                             
.................... ////////////////////PORT C//////////////////// 
....................  
.................... //      SOSCO        PIN_C0      // xtal osc output connection 
.................... //      SOCSI        PIN_C1      // for debug, we can look at frequency here 
.................... #define BRK_CTRLn    PIN_C2      // P1A-pwm, to gates of FETs -- 
....................                                  //  lo for max braking force, hi for no brake 
....................  
.................... #BIT     BRK_pinstate   = LATC.2                               
....................  
.................... //      SCL1         PIN_C3      // I2C clock 
.................... //      SDA1         PIN_C4      // I2C data 
.................... #define XDCR_PWR     PIN_C5      // output, active hi 
.................... //      MOTE_RX      PIN_C6      // UART1 TX output 
.................... //      MOTE_TX      PIN_C7      // UART1 RX input 
....................  
.................... #define TRISC_NORM   0b10011010 
....................                                  // C0 output 
....................                                  // C1 input 
....................                                  // C2 output 
....................                                  // C3/C4 inputs (I2C) 
....................                                  // C5 output 
....................                                  // C6 output (UART TX / MOTE_RX) 
....................                                  // C7 input  (UART RX / MOTE_TX) 
....................  
.................... #define PORTC_INIT   0b01000101 
....................                                  // C0 output (1) 
....................                                  // C1 input (0) 
....................                                  // C2 output (SPD_CTRL hi=no braking) (1) 
....................                                  // C3/4 I2C, init as inputs (0) 
....................                                  // C5 output active hi (0) 
....................                                  // C6 output (1) 
....................                                  // C7 input (0) 
.................... #define PORTC_IDLE   PORTC_INIT 
.................... #define PORTC_DEEP   PORTC_INIT 
....................  
.................... ////////////////////PORT D//////////////////// 
.................... #define GPS_ON       PIN_D0      // output, active hi 
.................... #define MOTE_TIMEn   PIN_D1      // output, active lo, gets time from mote 
.................... #define LCD_RESETn   PIN_D2      // output, active lo 
.................... #define AUX_PWR      PIN_D3      // output, active hi, turns on AUX pwr 
.................... #define MOTE_RESETn  PIN_D4      // output, active lo 
.................... #define MOTE_RX_RTSn PIN_D5      // output, active lo 
....................                                  //  micro asserts to tell mote it is  
....................                                  //   ready to send data to mote 
.................... #define GPS_RX       PIN_D6      // UART2 TX output 
.................... #define GPS_TX       PIN_D7      // UART2 RX input 
....................  
.................... #define TRISD_NORM   0b10000000 
....................                                  // D0 output 
....................                                  // D1 output 
....................                                  // D2 output (spare) 
....................                                  // D3 output 
....................                                  // D4 output 
....................                                  // D5 output 
....................                                  // D6 output 
....................                                  // D7 input 
....................  
.................... #define PORTD_INIT   0b01110110 
....................                                  // D0 output active hi (0) 
....................                                  // D1 output active lo (1) 
....................                                  // D2 output active lo (1) 
....................                                  // D3 output active hi (0) 
....................                                  // D4 output active lo (1) 
....................                                  // D5 output active lo (1) 
....................                                  // D6 output (1) 
....................                                  // D7 input (0) 
.................... #define PORTD_IDLE   PORTD_INIT 
.................... #define PORTD_DEEP   PORTD_INIT 
....................  
.................... ////////////////////PORT E//////////////////// 
.................... #define VLV_CTRL1    PIN_E0      // P3A-pwm, to H-bridge re valve  
.................... #define VLV_CTRL2    PIN_E1      // P3B-pwm, to H-bridge re valve 
.................... #define GEN_RPM      PIN_E2      // CCP5 input 
.................... //       MCLRn       PIN_E3 
....................  
.................... #define TRISE_NORM   0b00001100 
....................                                  // E0 output 
....................                                  // E1 output 
....................                                  // E2 input 
....................                                  // E3 master clear input 
....................  
.................... #define PORTE_INIT   0b00000000 
....................                                  // E0 output (E0,E1 = 00 for coast state) 
....................                                  // E1 output 
....................                                  // E2 input (0) 
....................                                  // E3 input (0) 
.................... #define PORTE_IDLE   PORTE_INIT  // TURNS off the power supply to  
....................                                  //  the valve motor 
.................... #define PORTE_DEEP   PORTE_INIT 
....................  
.................... /////////////////////I/0 Lines and Initialization End////////////////////////// 
....................  
....................  
.................... /////////////////////Timer 0 Start///////////////////////////////////////////// 
....................  
.................... // THESE VALUES ARE DEPENDENT UPON CRYSTAL FREQUENCY 
.................... // Modify with care 
.................... #define  T0_OSC    4340 
.................... // After calibration of 1MHz HFINTOSC timebase to 921.6KHz: 4/Fosc = 4340 nsec 
....................  
.................... // Assume 16 bit timer0 input is FOSC div 128 (timer 0 prescaler) 
.................... // Thus one count every 128*T0_OSC nanoseconds                      
.................... #define T0_SETUP(MS) {  setup_timer_0(T0_DIV_128); \ 
....................                         set_timer0(65536 - (1000000*MS + 64*T0_OSC)/(128*T0_OSC)); } 
.................... // Note roundoff fix                     
.................... // For use with the routine setup_T0_int(*) 
....................  
.................... //Timer 0 options 
.................... #define  T0_500US    65534 
.................... #define  T0_1MS      65536 - 1000/256 
.................... #define  T0_10MS     65536 - 10000/256 
.................... #define  T0_20MS     65536 - 20000/256 
.................... #define  T0_50MS     65536 - 50000/256 
.................... #define  T0_100MS    65536 - 100000/256 
.................... #define  T0_175MS    65536 - 175000/256 
.................... #define  T0_250MS    65536 - 250000/256 
.................... #define  T0_500MS    65536 - 500000/256 
.................... #define  T0_1S       65536 - 1000000/256 
.................... #define  T0_2S       65536 - 2000000/256 
.................... #define  T0_3S       65536 - 3000000/256 
.................... #define  T0_4S       65536 - 4000000/256 
.................... #define  T0_6S       65536 - 6000000/256 
.................... #define  T0_16S      65536 - 16000000/256 
.................... // the max is actually 16.7 seconds 
....................  
.................... /////////////////////Timer 0 End/////////////////////////////////////////////// 
....................  
.................... /////////////////////Timer 2 Start///////////////////////////////////////////// 
....................  
.................... // For use with the routine setup_T2_int(*) 
.................... // The equivalent tick duration for timer2 is 
.................... //  adjusted depending on Fosc to be approx 256usec 
.................... // Timer2 counts up from 0 to match PR2 in order to set int flag 
.................... #define T2_1MS       3 
.................... #define T2_2MS       7 
.................... #define T2_3MS       11 
.................... #define T2_4MS       15 
.................... #define T2_5MS       19 
.................... #define T2_6MS       23 
.................... #define T2_7MS       27 
.................... #define T2_8MS       31 
.................... #define T2_9MS       35 
.................... #define T2_10MS      39 
.................... #define T2_15MS      59 
.................... #define T2_20MS      79 
.................... #define T2_25MS      99 
.................... #define T2_30MS      119 
.................... #define T2_40MS      159 
.................... #define T2_50MS      199 
.................... #define T2_60MS      239 
.................... #define T2_64MS      255 
.................... // cannot set to higher than 64 milliseconds  
....................  
.................... ////////////////////Timer 2 End//////////////////////////////////////////////// 
....................  
.................... /////////////////////Timer 4 Start///////////////////////////////////////////// 
....................  
.................... // For use with the routine setup_T4_int(*) 
.................... // The equivalent tick duration for timer4 is 
.................... //  adjusted depending on Fosc to be approx 256usec 
.................... // Timer4 counts up from 0 to match PR4 in order to set int flag 
.................... #define T4_500US     1 
.................... #define T4_1MS       3 
.................... #define T4_2MS       7 
.................... #define T4_3MS       11 
.................... #define T4_4MS       15 
.................... #define T4_5MS       19 
.................... #define T4_6MS       23 
.................... #define T4_7MS       27 
.................... #define T4_8MS       31 
.................... #define T4_9MS       35 
.................... #define T4_10MS      39 
.................... #define T4_15MS      59 
.................... #define T4_20MS      79 
.................... #define T4_25MS      99 
.................... #define T4_30MS      119 
.................... #define T4_40MS      159 
.................... #define T4_50MS      199 
.................... #define T4_60MS      239 
.................... #define T4_64MS      255 
.................... // cannot set to higher than 64 milliseconds  
....................  
.................... ////////////////////Timer 4 End//////////////////////////////////////////////// 
....................  
....................  
.................... ////////////////////Battery-Voltage Start////////////////////////////////////// 
.................... // magic number based upon 4 samples averages with 1.2V reference! 
.................... // 12.20 format (4.8V) 
.................... #define VAL32_FVR_BAT      4.8 * 1048576 // 5033164.8 = 4CCCCD 
....................  
.................... ////////////////////Battery-Voltage End//////////////////////////////////////// 
....................  
....................  
....................  
.................... ////////////////////Restart Causes Start/////////////////////////////////////// 
.................... /* 
.................... // reset_cause is set to one of these values before any reset_cpu instruction 
....................  
.................... #define WARM_RESTART          0x00  // commanded: joins if needed 
.................... #define SPIN_RESTART          0x10  // generator wakeup from Deep sleep  
....................                                     //  or idle sleep 
....................                                     //  like WARM_RESTART                                         
.................... #define FRC_RJOIN_RESTART     0x20  // commanded to duplicate behavior of 
....................                                     //  unexpected mote state change during 
....................                                     //  RUN; like WARM_RESTART; mote rejoins 
....................                                     //  and informs manager 
.................... #define RJOIN_RESTART         0x30  // unexpected mote state change during 
....................                                     //  RUN; like WARM_RESTART; mote rejoins 
....................                                     //  and informs manager   
.................... #define COLD_RESTART          0x50  // commanded: force join 
.................... */ 
.................... ////////////////////Restart Causes End///////////////////////////////////////// 
....................  
.................... ////////////////////Extra LCD Start//////////////////////////////////////////// 
.................... /* 
.................... // New Haven display part number NHD-C0216CIZ-FSW-FBW-3V3 special characters 
.................... #define  CROSS_CHAR        0xF7 
.................... // small cross 
.................... #define  BOX_CHAR          0xDB 
.................... // rectangle 
.................... #define  TOPLINE_CHAR      0xFF 
.................... // top line designates battery full, no charging needed 
.................... #define  NOTEQU_CHAR       0xFD 
.................... // equ with slash 
.................... #define  NOCHG_CHAR        0xE4 
.................... // c with slash, cent symbol, indicates charger circuit OFF 
.................... #define  MAXCHG_CHAR       'C' 
.................... #define  MINBRAKE_CHAR     'b' 
.................... #define  MAXBRAKE_CHAR     'B' 
.................... // PFHI character, indicates maximum braking force 
.................... #define  NOVLV_CHAR        'v' 
.................... // a PERIOD indicates valve PWM set for NO MOTION 
.................... #define  MAXVLV_CHAR       'V' 
.................... // ! indicates valve PWM set for MAX speed 
....................  
.................... #define  APPOS_CHAR        0x27 
.................... // appostrophe character: ' 
....................  
....................  
.................... //#define  APPROX_CHAR       0x00 
.................... // custom approx equal character loaded at LCD_INIT 
....................  
.................... // custom characters loaded during LCD_INIT 
.................... #define  LEV1_CHAR         0x00 
.................... #define  LEV2_CHAR         0x01 
.................... #define  LEV3_CHAR         '_' 
.................... #define  LEV4_CHAR         0x02 
.................... #define  LEV5_CHAR         0x03 
.................... #define  LEV6_CHAR         '-' 
.................... #define  LEV7_CHAR         0x04 
.................... #define  LEV8_CHAR         0x05 
.................... #define  LEV9_CHAR         0x06 
.................... #define  LEV10_CHAR        0xFF 
....................  
.................... #define  BIGBOX_CHAR       0x07 
.................... #define  WAYLOW_CHAR       0xFB 
.................... // << 
.................... #define  WAYHI_CHAR        0xFC 
.................... // >> 
.................... #define  CIRCLE_CHAR       0xF2 
.................... // small circle 
....................  
.................... */ 
.................... ////////////////////Extra LCD End////////////////////////////////////////////// 
.................... ////////////////////EEPROM Locations Start///////////////////////////////////// 
....................  
.................... // EEPROM LOCATIONS 
.................... #define EE_ADDCHG_DUR      0x0002 
....................    // Configures add-charging time in seconds 
....................    // 2 bytes, low byte at 0x0002 
.................... #define ADDCHG_DUR_DEF     4 
....................    // 4 minutes? 
.................... #define EE_PRECHG_DUR      0x0004 
....................    // Configures precharging time in seconds 
....................    // 2 bytes, low byte at 0x0004 
.................... #define PRECHG_DUR_DEF     10 
....................    // 1.5 minutes?  
.................... #define CHGLOOPS_PER_MIN   110 
....................    // determined experimentally, each loop is about 545 msec 
....................    //  which is a bit longer than I would prefer (!), but oh well. 
....................    //  JG 2015 Jun16 
....................     
.................... // 0x00A thru 0x00F        reserved 
.................... #define EE_NETW_ID         0x0010 
....................    // 2 bytes, low byte at 0x0010; for now, network ID defaults to 0x04CD. 
.................... #define EE_PRENETW_ID      0x0012 
....................    // 2 bytes, low byte at 0x0012; for now, network ID defaults to 0x04CD. 
....................  
....................  
.................... // 0013 reserved 
.................... #define EE_LOCATION     0x0014 
....................    // 2 bytes, low byte at 0x0014; associates sprinkler with particular 
....................    //  physical location on CP 
.................... #define EE_PRELOCATION  0x0016 
....................    // 2 bytes, low byte at 0x0016, previous association of sprinkler with 
....................    //  particular physical location on CP 
....................  
....................    // 0x018 thru 0x01F     reserved 
....................  
.................... // IDLE behavior specified at 0x0020 thru 0x0033 
.................... #define EE_IDLE_OPT        0x0020 
....................    // Configures IDLE behavior.  Applies if battery low during operational 
....................    //  state 
....................    //  0x00  send out Panic Message once when panic level is reached according 
....................    //         to voltage-based algorithm 
....................    //  0x01  send out Panic Message once when panic level is reached according 
....................    //         to charge-based algorithm 
.................... #define MAX_IDLE_OPT       1 
....................    // If manager tries to write any idle_opt value larger than this to EEPROM 
....................    //  a NACK occurs; see above for idle option choices 
.................... #define LEN_IDLE_BLOCK     15 
....................    // There are 15 bytes in the idle block 
....................  
.................... #define EE_IDLE_PROFILE    0x0021 
....................    // Saved only upon entering IDLE state; 
....................    //  profile number which was running or had last been run. 
....................    // 0 for default profile, 1, 2, 3 for controller-specified profile choices 
....................    //  other numbers, use 0 
.................... #define EE_IDLE_STEP       0x0022 
....................    // Saved only upon entering IDLE state; 
....................    //  step number of profile which was running or had last been run. 
....................    //  Step 0xFF indicates that we were not within a profile 
....................    //  Step 0x10 thru 0xFE invalid. 
.................... #define EE_IDLE_STIME      0x0023 
....................    // 2 bytes, low byte at 0x0023, high byte at 0x0024 
....................    // Saved only upon entering IDLE state; 
....................    //  amount of time in seconds that rate was controlled according 
....................    //  to EE_IDLE_STEP at time when IDLE state entered; 
....................    //  set to 0x0000 if EE_IDLE_STEP=0xFF. 
.................... #define EE_IDLE_LOOP       0x0025 
....................    // 2 bytes, low byte at 0x0025, high byte at 0x0026 
....................    // Saved only upon entering IDLE state; 
....................    //  for looping profiles, loop number at time when IDLE state entered; 
....................    //  set to 0x0000 for non-looping profiles, set to 
....................    //  0x0000 if EE_IDLE_STEP=0xFF. (looping beyond 0xFFFF is recorded as 
....................    //  0xFFFF) 
.................... #define EE_IDLE_CHG        0x0027 
....................    // 2 bytes, low byte at 0x0027, high byte at 0x0028 
....................    // Configures used charge in millicoulombs for 
....................    //  charge-based shutdown method (TBD); applies if EE_IDLE.1 is set 
.................... #define EE_IDLE_SHDN_DLY   0x0029 
....................    // 2 bytes, low byte at 0x0029, high byte at 0x002A 
....................    // Configures time in units of 67 secs (TMR0 ints during IDLE) 
....................    //  between sensing of low battery and self-shutdown 
....................  
.................... ////////////////////EEPROM Locations End/////////////////////////////////////// 
.................... //*************************************************************** 
.................... /* 
.................... #define DAY_SECS           24*3600 
....................  
.................... #define VAL32_FVR_BAT      4.8 * 1048576 // 5033164.8 = 4CCCCD 
.................... // magic number based upon 4 samples averages with 1.2V reference! 
.................... // 12.20 format (4.8V) 
....................  
.................... #define NETWORK_ID_DEF  0x04CD 
.................... // 04CD flipped bytes to match received network ID (JG!~?) 
.................... // this is the net_id for BlueBox#0 
.................... #define NETWORK_ID_MAX  NETWORK_ID_DEF + 250 
.................... // We could actually go from 0 (0x04CD) to 254, with 255 being illegal 
.................... //  as what would be read from cleared EEPROM 
....................  
.................... #define MAX_SP_NUM      499 
.................... // based on maximum number of motes that can be supported by Blue Box 
.................... #define MAX_SP_CP       200 
.................... // highest sprinkler number which uses the WARNER VALVE parameters 
.................... //  otherwise uses the BENCH VALVE SIMULATOR parameters 
....................  
.................... // state of charge levels 
....................  
.................... #define R2T             23040 
....................    // 0x00005A00 
....................    // Divide this number by RPM to get the target CCP2 capture value 
....................    //  representative of speed. 
....................    // 23040 RPM/(CCP2-prev_count) = 19200Hz * 6/5, where 19.2KHz is fosc/4, 
....................    //  (1 rising edge occurs per capture event) and 6/5 RPM/Hz is the 
....................    //  generator-dependent relationship between its output frequency and its 
....................    //  RPM. 
....................    // For example, 10RPM results in 2304 counts in the capture register 
.................... #define R2Tx4      R2T*4 
....................  
.................... #define VMOTION_TIMEOUT    60 
.................... // if valve travels longer than this time, a timeout error occurs 
....................  
.................... #define RPM_MIN            4 
.................... #define RPM_MAX            400 
.................... // when target_RPM = 0, we are in a braking mode 
....................  
.................... #define PERIOD_5RPM        4608 
....................  
.................... #define SHUT_DEL_DEF       30 
.................... // default shutdown delay to ensure that all motes get broadcast msg: 30 sec 
.................... // also used to ensure that manager acknowledges errors and first_msg in a  
.................... //  timely manner (else there will be a repeat 
.................... #define REPEAT_LIMIT       4 
.................... // number of times that an unsolicited msg will repeat waiting for an 
.................... //  ACK from the manager. 
....................  
.................... #define STARTUP_DELAY      4 
.................... // delay in units of 1/4 sec at startup before opening valve for 
.................... //  first time 
....................  
.................... #define RSSI_MIN           -64 
.................... // -64 dBm; minimum rssi of an advertising message required 
.................... //   for that network to be a viable net to join 
.................... // BRIAN, this value may be TOO SENSITIVE 
.................... #define LISTEN_TIME        20 
.................... // number of seconds to dwell in promiscuous hi-power listen mode 
.................... //  in search of networks to join when mote has been cold-booted 
.................... // MUST be 1-27 -- 15s is occassionally too short a time 
.................... #define LISTEN_T1          65536 - LISTEN_TIME*2400 
.................... // 76.8KHz clock (19.2KHz counting up at timer1 div8.... 
....................  
....................  
.................... #define TIMER2_SETUP_XTAL        T2_DIV_BY_4, 199, 8 
.................... // for 3.6864MHz xtal, this is the value used in setup_timer_2  
.................... // to achieve 1152Hz PWM frequency (for braking purposes) 
.................... // AND interrupt rate (used for valve algorithms) of 144Hz 
.................... //  (check valve current approx once every 7msec) 
.................... // Increments "RTC" by 7 when keeping track of time (about 0.8% fast!) 
.................... #define FAST_CLK  0 
.................... #define FAST_MS   7 
....................  
.................... #define TIMER2_SETUP_250K        T2_DIV_BY_1, 199, 16 
.................... // for 250KHz internal clock, this is the value used in setup_timer_2  
.................... // to achieve 312.5KHz PWM frequency (for braking purposes) 
.................... // AND interrupt rate of ~104Hz 
.................... // Increments "RTC" by 51 when keeping track of time (about 0.4% slow if  
.................... //    250KHZ internal clock is accurate, which it is not) 
.................... #define MED_CLK   1 
.................... #define MED_MS    51 
....................  
.................... #define TIMER2_SETUP_31K         T1_DIV_BY_1, 199, 4 
.................... // for 31KHz LFINTOSC (inaccurate), this is value used in setup_timner_2 
.................... // to achieve interrupt rate of 9.7Hz (103msec) 
.................... // Not meant to be accurate, no need for variable braking when running at 31KHz 
.................... #define SLOW_CLK  2 
.................... #define SLOW_MS   103 
....................  
.................... //#define TIMER3_CCP2_SETUP       T3_DIV_BY_8 | T3_CCP2 | T3_INTERNAL 
.................... #define TIMER3_CCP2_SETUP       T3_DIV_BY_8 | T3_INTERNAL 
.................... //  This is the value used by setup_timer_3 in order to monitor real time 
.................... //   and to provide a time reference (CCP_2) for measurement of sprinkler RPM. 
.................... // 3.6864MHz div4 div8 = 57.6KHz 
.................... //*****NOTE THIS IS AN ISSUE WITH 3.6864MHz clock 
....................  
.................... #define TIMER3_AD_SETUP           
.................... //  This is the value used by setup_timer_3 in order to automatically 
.................... //   have the ADC monitor the valve current during the initial closure 
.................... //   of the valve. 
.................... //  1.832MHz clock here.  Checks ADC  
....................  
.................... #define CCP1_BRK  CCP_PWM_H_H | CCP_PULSE_STEERING_A | CCP_PULSE_STEERING_SYNC 
.................... //  This is the value used by setup_ccp1 in order to enable PWM-controlled  
.................... //   braking 
.................... #define CCP1_CHG  CCP_PWM_H_H | CCP_PULSE_STEERING_D | CCP_PULSE_STEERING_SYNC 
.................... //  This is value used by setup_cc1 in order to enable PWM-controlled 
.................... //   charging level 
.................... #define CCP1_BOTHn (CCP_PWM_H_H | CCP_PULSE_STEERING_A | CCP_PULSE_STEERING_D | CCP_PULSE_STEERING_SYNC) 
.................... //  This value is sued during transitions to/from full battery situation 
.................... //   CCP_BOTHn provides for charge enable pulse and braking pulsing IN PHASE 
.................... #define CCP1_BOTHi (CCP_PWM_H_L | CCP_PULSE_STEERING_A | CCP_PULSE_STEERING_D | CCP_PULSE_STEERING_SYNC) 
.................... //  CCP_BOTHi provides for charge enable pulse and braking pulsing OUT OF PHASE 
....................  
.................... #define IDLE_LOOP_31       T2_DIV_BY_16,160,1 
.................... // setup for timer2 determines length of lo-power sleeping between 
.................... //  mote message checks -- basically and roughly times the idle loop 
.................... // 31KHz clock, T2 div 16, 160 counts -> 3Hz 
.................... //  thus overflow in about 330 msec 
.................... // For calculating battery check and time check and rejoin timeout, 
.................... //  we assume that each idle loop takes ~400msec.  Longer than 330 because 
.................... //  because of the execution of the steps after timer2 
.................... //  wakes us up and before we go back into idle_sleep.  [150 loops per minute] 
.................... // And note that LFINTOSC is a +/-10% (or so) oscillator, so idle timing 
.................... //  is rough. 
....................  
.................... /* 
.................... #define IDLE_LOOP_76       T2_DIV_BY_16,197,2 
.................... // setup for timer 2 determines length of sleeping between mote 
.................... //  message checks while idling 
.................... // With 76.8KHz clock, timer increments every 833.3usec;  
.................... //  overflows every 198*.833msec = 165msec; interrupts every 330msec 
.................... // (see idle_sleep routine) 
.................... #define IDLE_LOOPS_PERMIN   182 
.................... // This number based on discussion above; change IDLE_LOOP_76 and 
.................... //  IDLE_LOOPS_PERMIN together 
.................... //#define TIMECHK_IDLELOOPS  25 
....................  
.................... #define TIMECHK_IDLEMINS   300 
.................... // DEBUG SETTING FOR TEST: 5 hours.... 
.................... #define TIMECHK_IDLELOOPS  TIMECHK_IDLEMINS*IDLE_LOOPS_PERMIN 
.................... // This amounts to checking network time once every 10 mins. 
....................  
.................... #define TIMCHK_INTERVAL    3600 
.................... // number of seconds between timechecks when knowtime_fl = TRUE 
.................... #define BATCHK_INTERVAL    900 
.................... // number of seconds between battery checks! 
.................... #define BATCHK_MARCH       840 
.................... // what this means is that when there is a marching order change 
.................... //  we preset the batchk_timer to this value... 
.................... // Thus 60 seconds after the valve has been adjusted, we THEN 
.................... //  check battery health (which could lead to a charging on or off  
.................... //  transition..... 
....................  
.................... #define MAX_JOINTIME       1800 
.................... // SHOULD BE ABOUT 1/2 hour or 1800 secs!!!!!! 
.................... // seconds to wait for a join to happen 
.................... ///  even at 1/2 hr, MAY BE TOO SHORT for a full 500 count mesh! 
....................  
.................... #define JOIN_MINSMAX       30 
.................... // Number of minutes that we wait for mote to become operational after  
.................... //  the first join; then we say goodnight 
....................  
.................... #define FIRSTDANCE_INTERVAL   120 
.................... // retry the MSG_IDENTIFIER if no acknowledge within this interval 
....................  
.................... #define REJOIN_INTERVAL       1800 
.................... // number of seconds after which we give up on rejoining! 
.................... */ 
.................... /* 
.................... #define RUN_LOOPS_PERMIN   120 
.................... // assume we are consistently at 500msec per loop 
....................  
.................... #define REJOIN_TIMEOUT     1800 
.................... // number of seconds at which we decide to GIVE up on rejoining! 
.................... #define TIMECHK_RUNSECS    3600 
.................... // check net time every hour 
.................... #define BATCHK_RUNSECS     3600 
.................... // check battery at least every hour 
.................... #define REJOIN_RUNSECS     1800 
.................... // cannot join if have attempted for more than 1/2 hour 
.................... #define REJOIN_DISP_LIM    REJOIN_RUNSECS - 3 
.................... // display REJOIN message during run for 3 seconds after rejoin is 
.................... //  initiated 
....................  
....................  
.................... #define  _ACTIVE_MIN   102 
.................... // if Vdd is 3.3V, this represents .33 volt at the generator 
....................  
.................... #define OPER_BCHK_INTVL    36600 
....................    // check the battery level every OPER_BCHK_INTVL tmr2 interrupts 
....................    //  during operation; 36600 for once every 10 minutes 
....................  
.................... #define FSLEEP_DEL   2 
....................    // wait this number of seconds after receipt of force_warm or force_sleep 
....................    //  manager commands before acting... allows time for ACK 
.................... */ 
....................  
.................... /* 
....................  
.................... #define NO_BRK             0 
.................... #define MAX_BRK            400 
.................... // MAX_BRK for absolute minimum speed 
....................     
.................... // min and max charging aggressiveness values (PWM)    
.................... #define MIN_CHGAGGR        0 
.................... #define MAX_CHGAGGR        400 
....................  
.................... #DEFINE MAX_CHGDUTY        0x320 
....................  
.................... #define MIN_PWM            0 
.................... #define MAX_PWM            400 
....................   
....................  
.................... #define FLAGS1_BNOCH       0x00 
.................... // no charge during BRK control as requested by operator 
....................  
.................... #define FLAGS1_NOFLO       0x01 
....................  
.................... #define FLAGS1_MANRPM      0x02 
.................... // manual set of MPPC (0x0 00-0x1FF), RPM CONTROL 
.................... #define FLAGS1_RPMOLD      0x03 
.................... // old table lookup for RPM control 
....................  
.................... // new adaptive algorith 
.................... #define FLAGS1_DYNLO       0x04 
.................... // most aggressive charging, PWM control of brake 
.................... #define FLAGS1_DYNMID      0x05 
.................... // variable MPPC 0-FF, no brake 
.................... #define FLAGS1_DYNHI       0x06 
.................... // variable PWM control of EN_3105, MPPC = 0xFF, no  brake 
....................  
.................... #define FLAGS1_RNOCH       0x07 
.................... // no charge during RPM control as requested by operator 
....................  
.................... #define FLAGS1_TRANS2F     0x08 
.................... #define FLAGS1_TRANS2N     0x09 
.................... // 08:09 for transitioning states to smooth out battery full situations while 
.................... //  dynamically charging  
....................  
.................... #define FLAGS1_MANBRK      0x0A 
.................... // manual set of MPPC (0x000-0x1FF), NO RPM CONTROL 
.................... #define FLAGS1_BRKOLD      0x0B 
.................... // old formula calc for BRK control 
....................  
.................... #define FLAGS1_MAXCHG      0x0C 
.................... // defined max charging state 
....................  
.................... #define FLAGS1_FREE        0x0D 
.................... // defined state for free spin 
....................  
.................... #define FLAGS1_MANPWM      0x0E 
.................... // manual setting of MPPC and PWM control of 3105 enable 
....................  
.................... #define FLAGS1_DYNFULL     0x0F 
.................... // no charge during BRK control as requested by operator 
....................  
....................    
.................... //#define FLAGS_READY        0x00 
....................  
.................... #define VOPEN_FULL         0x8000 
.................... // Valve to max open 
.................... #define VCLOSE_FULL        0 
.................... #define VUNKNOWN           0xFFFF 
....................  
.................... // RPM increases as cur_MPPC goes from 0 to FF 
.................... #define MPPC_MAX           0x01FF 
.................... #define MPPC_DYNMAX        0xFF 
.................... // value of MPPC during dynamic control mode at which we shift into 
.................... //  hi speed mode wherein we duty cycle modulate the charging circuit! 
.................... #define MPPC_MIN           0x00a 
.................... #define MPPC_ADDCHG        0x0D1 
.................... // This may need to be adjusted if we change the manner in which MPPC is set 
.................... //  during braking. See prep_4_brake reoutine 
....................  
.................... #define MPPC_DUTYLIM       0x320 
....................    // 0x320 = 800 
....................    // maximum duty cycle for charger (special modes) 
....................     
.................... //#define MPPC_CHGOFF        0x1FF 
.................... // What should MPPC be set to when charging is NOT happening?  Does it matter? 
....................  
.................... #define MPPC_DYNCHG    0x0FF 
.................... // This is the default STARTING POINT for the MPPC setpt during dynamic 
.................... //  charging control 
.................... #define MPPC_STEP2F     1 
.................... // This is the MPPC value step change which takes place during transitions 
.................... // from _DYNMID to full battery situation 
.................... #define MPPC_STEP2N     1 
.................... // This is the MPPC value step change which takes place during transitions 
.................... // from full battery situation to Dynamic charging situation 
....................  
.................... #define TRANS_PERSTEP   1 
.................... // This is the target period value step change which takes place during  
.................... // transitions from _DYNMID to full battery situation 
.................... #define TRANS_PWMSTEP   8 
.................... // This is the step change for the PWM when routed to the charger and while 
.................... //  transitioning from _DYNHI to full battery situation 
....................  
.................... #define CHRGING_THRESH     0x0011 
....................    // A/D counts difference between UNLOADED and LOADED Vchg measurement 
....................    // indicates whether or not we are (significantly) charging the battery now. 
....................    // We compare this value to (VchgU-VchgL) where this is in units of ADC 
....................    //  counts -- at 3mV per count, 50mv would be a CHRGING_THRESH of ~17. 
....................  
.................... #define NOSPIN_LIMIT       16 
....................    // Number of ~half-seconds of low or no rotation that must occur in order to 
....................    //  show the nospin display and alert the manager 
....................  
.................... #define NUM_4_STAT         64 
....................    // This is number of rpm measurements to process prior to determination of 
....................    //  AveRPM and Max/Min (~30sec interval) 
....................    // Also signals reporting to the manager 
.................... #define SHIFT_4_STAT       5 
....................    // This is intead of dividing by NUM_4_STAT; change these two values 
....................    //  together 
....................  
.................... #define TEN_MIN            600 
....................    // This is the number of seconds in ten minutes; used to time mandatory 
....................    //  battery checks 
....................  
.................... // defines for prechg_opt 
.................... // TIME or Alternative (voltage-based?) Algorithm utiling regulated RPM 
.................... #define PRECHG_TIME_RPM    0x00 
....................  
....................  
.................... // defines for msg_id (Manager->Mote Payload message ID to Micro) 
.................... #define MSG_FULL              0x01 
.................... #define MSG_WATER_ON          0x02 
.................... #define MSG_WATER_OFF         0x03 
....................    
.................... #define MSG_FORCE_WARM        0x06 
....................  
.................... #define MSG_SHUT_DEL_RD       0x0E 
.................... #define MSG_SHUT_DEL_WR       0x0F 
....................  
.................... #define MSG_FIRMWARE_RD       0x24 
....................  
.................... #define MSG_FORCE_TIME        0x29 
....................  
.................... #define MSG_FORCE_COLD_DEL    0x2B 
.................... #define MSG_FORCE_COLD        0x2C 
....................  
.................... #define MSG_FORCE_REJOIN_DEL  0x2E 
.................... #define MSG_FORCE_REJOIN      0x2F 
....................  
.................... #define MSG_MGR_ACK           0x30 
.................... #define MSG_MGR_NACK          0x31 
....................  
.................... #define MSG_SP_NUM_WR         0x44 
....................  
.................... #define MSG_DEFINE_TEST       0x49 
.................... #define MSG_MARCH1            0x50 
.................... // for IMMEDIATE or future MARCHING ORDER, closed loop RPM, timed valve 
.................... #define MSG_MARCH2            0x51 
.................... // for IMMEDIATE or future MARCHING ORDER, closed RPM and FLOW 
.................... #define MSG_READY             0x52 
.................... #define MSG_TEST              0x53 
.................... #define MSG_DEMO              0x54 
.................... // for immediate open loop setting of valve, brake, charger, etc. 
....................  
.................... #define MSG_REPORT_VALVE      0x59 
....................  
.................... #define MSG_SLEEPNOW          0x5B 
.................... #define MSG_SHUTDOWNC_DEL     0x5C 
.................... #define MSG_SHUTDOWNC         0x5D 
.................... #define MSG_SHUTDOWNO_DEL     0x5E 
.................... #define MSG_SHUTDOWNO         0x5F 
....................  
.................... #define MSG_HEALTH            0x60 
.................... #define MSG_CAL_VALVE         0x61 
.................... // short form of MSG_STD solicited by manager to get LOCATION, STATE, ERRORS 
....................  
.................... // defines for msg_id (Micro to Mote) 
.................... #define MSG_ACK            0x80 
.................... #define MSG_NACK           0x81 
.................... #define MSG_ERROR          0x82 
.................... #define MSG_MICRO_RESPONSE 0x83 
.................... #define MSG_FIRST          0x84 
.................... #define MSG_VCAL           0x85 
....................  
.................... // defines for various unsolicited messages 
.................... #define BATTERRb           7 
.................... //Indicates to LV program that the startup was 
.................... //  rocky due to a DEAD BATTERY! (bit7 set) 
.................... #define LOSPINb            6 
.................... // Indicates to LV program that the freespin speed measured during the  
.................... //  opening dance was less than FREESPIN_MIN (bit6 set) 
.................... #define OCDIFFb            5 
.................... // Indicates to LV program that the 1st open time and the 1st close 
.................... //  time differ by greater than 25% (bit5 set) 
.................... #define REJOINEDb          4 
.................... // Indicates that a rejoin occurred 
....................  
.................... // Note 3:2 carry information about 1st valve open 
.................... // and  1:0 carry information about 1st valve close 
.................... // as follows: 0b00   OK 
.................... //             0b01   timeout 
.................... //             0b10   TOO SHORT of a duration for valve motion 
.................... #define OPENSHORTb         3 
.................... #define OPENLONGb          2 
.................... #define CLOSESHORTb        1 
.................... #define CLOSELONGb         0 
....................  
.................... // defines for error codes as communicated to manager 
.................... #define NO_ERRCODE         0x00 
.................... #define BATOK_ERRCODE      0x03 
....................  
.................... #define FRC_SLEEP_ERRCODE  0x05 
.................... // manager forces system into a sleep state and decommissions the mote 
....................  
.................... #define LOC_ERRCODE        0x21 
.................... #define CPASSOC_ERRCODE    0x22 
.................... #define LOC_CP_ERRCODE     0x23 
....................  
.................... #define ADDCHG_WARNCODE    0x80 
.................... //#define LOWBAT_ERRCODE     0x80 
.................... #define PS_ERRCODE         0x81 
....................          // Vdd too high 
.................... #define WEAKBAT_WARNCODE   0x82 
.................... #define DEADBAT_ERRCODE    0x83 
....................  
.................... // defines for state variable 
.................... #define  DEV_INIT          0x00 
.................... #define  DEV_JOINING       0x01 
.................... #define  DEV_1STEXCH       0x02 
.................... #define  DEV_READY         0x03 
.................... #define  DEV_RUN           0x04 
.................... #define  DEV_PAUSED        0x05 
.................... #define  DEV_IDLE          0x06 
.................... #define  DEV_SLEEP         0x07 
.................... #define  DEV_TEST          0x08 
.................... #define  DEV_DEMO          0x09 
....................  
.................... // defines for vlv_state variable 
.................... #define  VLV_COASTING   0x00 
.................... #define  VLV_CLOSING    0x01 
.................... #define  VLV_OPENING    0x02 
.................... #define  VLV_BRAKING    0x03 
....................  
.................... #define  TYPE_NOXDCR    0x01 
.................... #define  TYPE_XDCR      0x02 
....................  
.................... // defines for sys_state variable 
.................... // F009+ 
.................... // 7:4 - major state indicator 
.................... // 3:0 - minor state indicator 
.................... //       .3 = joining_fl (also set if rejoining fails) 
.................... //       .2 = rejoining_fl 
.................... //       .1 = chgenab_fl 
.................... //       .0 = ctrlRPM_fl 
.................... #define INIT_STATE               0x00 
....................    // OR with joining_fl when established 
....................    // always leads to OPEN1_STATE; 
....................    // NEVER accepts packets (NACK), even if joined 
.................... #define LSTATE_INIT              0x00 
....................  
.................... #define OPEN1_STATE              0x10 
....................    // OR with joining_fl when established 
....................    // always leads to PRECHG_STATE; 
....................    // always from INIT_STATE; 
....................    // May process report commands. 
....................    // [Vmmmm:ss OPENING] countup display 
.................... #define LSTATE_OPEN1   0x01 
....................  
.................... #define PRECHG_STATE             0x22 
....................    // OR with joining_fl when established 
....................    // always leads to CLOSE_STATE; may be in and out quickly if no 
....................    //  precharging is necessary; 
....................    // always from OPEN1_STATE; 
....................    // May process report commands.. 
....................    // [Pmmmm:ss        ] countdown display 
.................... #define LSTATE_PRECHG   0x02 
....................  
.................... #define CLOSE1_STATE             0x32 
....................    // OR with joining_fl when established 
....................    // always leads to JOINING_STATE or READY_STATE; 
....................    // always from PRECHG_STATE; 
....................    // May process report commands. 
....................    // [Vmmmm:ss CLOSING] countup display 
.................... #define LSTATE_CLOSE1   0x03 
....................  
.................... #define JOINING_STATE            0x44 
....................    // always leads to READY_STATE 
....................    // always from CLOSE1_STATE 
....................    // Bypassed if warm start 
....................    // Cannot hear commands. 
....................    // [Jmmmm:ss  moteid] display 
.................... #define LSTATE_JOIN     0x04 
....................  
.................... #define REJOINING_STATE          0x48 
....................    // Leads to READY_ if rejoin is successful 
....................    //  or JFAIL_ if rejoin is unsuccessful 
....................    //  or ADDCHG_ if needed. 
....................    // Drops into this state when we are rejoining 
....................    //  AND there is no pending marching order 
....................    //  Preceeding state READY_ or  
....................    //   short-lived READY_ after completion of marching orders. 
....................    // [Rmmmm:ss  moteid] countup display 
....................    // Cannot hear commands. 
....................    // THINK ABOUT THIS 
....................  
.................... #define DISRUPT1_STATE           0x50 
.................... #define LSTATE_DIS1     0x05 
.................... #define DISRUPT2_STATE           0x60 
.................... #define LSTATE_DIS2     0x06 
.................... #define DISRUPT3_STATE           0x70 
.................... #define LSTATE_DIS3     0x07 
....................  
.................... #define READY_STATE              0x80 
....................    // leads to OPENING_STATE or VADJ_STATE 
....................    //  or to DISRUPT STATE; 
....................    // valve is closed in READY_STATE; 
....................    // from CLOSE1_STATE or or CLOSING_STATE 
....................    // Processes all commands 
....................    // ['yy:ddd:hh:mm:ss] display 
.................... #define LSTATE_READY    0x08 
....................  
.................... #define JFAIL_STATE              0x8C 
....................    // Eventually leads to shutdown of sprinkler 
....................    // Indicates cannot join and we have given up AND all marching orders 
....................    //  have completed 
....................    // Drops into this state from REJOINING_STATE 
....................    // Cannot hear commands. 
....................    // ['yy:ddd:hh:mm:ss] display 
.................... #define LSTATE_JFAIL    0x10 
.................... // band-aid 
....................     
.................... #define OPENING_STATE            0x90 
....................    // OR with rejoining_fl (and joining_fl if failure to join) 
....................    // May be brief if at open-valve end-stop; 
....................    // Leads to either BRK_ or RPM_ or ADDCHG_; 
....................    // From BRK_STATE or RPM_STATE or READY_STATE or PAUSE_STATE or REJOINING_ 
....................    // May process report, param and march commands. 
....................    // [Vmmmm:ss OPENING] countup display 
.................... #define LSTATE_OPENING  0x09 
....................  
.................... #define CLOSING_STATE            0xB2 
....................    // OR with rejoining_fl (and joining_fl if failure to join) 
....................    // May be brief if at close-valve end-stop; 
....................    // Leads to either READY_, PAUSE_. 
....................    // From BRK_STATE or RPM_STATE. 
....................    // May process report, param and march commands. 
....................    // [Vmmmm:ss CLOSING] countup display 
.................... #define LSTATE_CLOSING  0x0B 
....................  
.................... #define VADJ_STATE               0xC0 
....................    // OR with rejoining_fl (and joining_fl if failure to join) 
....................    // May be brief if valve DOES NOT NEED adjustment; 
....................    // Leads to either BRK_STATE or RPM_STATE; 
....................    // From BRK_STATE or RPM_STATE or READY_STATE or PAUSE_STATE 
....................    // May process report, param and march commands. 
....................    // [Vmmmm:ss rrr!RRR] countup display shows current rpm ! desired RPM 
.................... #define LSTATE_VADJ     0x0C 
....................  
.................... #define PAUSE_STATE              0xD0 
....................    // OR with rejoining_fl (and joining_fl if failure to join) 
....................    // Leads to READY_ or OPENING_ or VADJ_ 
....................    // From READY_ or CLOSING_ 
....................    //  (CLOSING_ may have followed BRK_ or RPM_) 
....................    // May process report, param and march commands. 
....................    // either [ mmmm:ss  NOFLOW] countup display  
....................    //     or [Xmmmm:ss  NOFLOW] countdown display if pending order  
.................... #define LSTATE_PAUSE    0x0D 
....................  
.................... #define BRK_STATE                0xE0 
....................    // OR with rejoining_fl (and joining_fl if failure to join) 
....................    //  and OR with chgenab_fl 
....................    // Leads to CLOSING_ or OPENING_ or VADJ_ or READY_; 
....................    // From VADJ_ or OPENING_ 
....................    // May process report, param and march commands. 
....................    // either [ mmmm:ss rrrBbbb] countup display (current RPM B brake force) 
....................    //     or [Xmmmm:ss rrrBbbb] countdown display if pending order   
.................... #define LSTATE_BRK      0x0E 
....................  
.................... #define RPM_STATE       0xF1 
....................    // OR with rejoining_fl (and joining_fl if failure to join) 
....................    //  and OR with chgenab_fl 
....................    // leads to CLOSING_ or OPENING_ or VADJ_ or READY_; 
....................    // from VADJ_STATE or OPENING_STATE 
....................    // May process report, param and march commands. 
....................    // either [ mmmm:ss rrr*RRR] countup display (current RPM / desired RPM) 
....................    //     or [Xmmmm:ss rrr*RRR] countdown display if pending order  
.................... #define LSTATE_RPM      0x0F 
....................  
.................... #define JOIN_MASK       0x0C 
.................... // AND with sys_state to extract both fl_joining and fl_rejoining bits 
.................... #define STATE_MASK      0xF3 
.................... // AND with sys_state to clear both fl_joining and fl_rejoining bits 
.................... #define RPM_CH_MASK     0x03 
.................... // AND with sys_state to extract RPM control bit (0) and charging bit (1) 
....................  
....................  
.................... #define FREESPIN_MIN       60 
.................... // If freespin measured at startup is less than FREESPIN_MIN, then  
.................... //  manager will be informed when UNSOLICITED message is sent 
.................... // See above regarding MSG_UNSOLICITED defines. 
....................  
.................... #define START_BRK          600 
....................    // Some intermediate braking at cold start perior to beginning of precharge 
.................... #define IDLE_BRK           200 
....................    // This is the braking force we apply during idling.... mostly important 
....................    //  for debugging purposes 
....................  
....................  
.................... // IFDEF WARNER we are using Eric's valve 
.................... // otherwise we are using Jake's test fixture 
.................... //#IFDEF   WARNER 
.................... //#define VALVE_STOP         990 
.................... //#ELSE 
.................... //#define VALVE_STOP         960 
.................... //#ENDIF 
....................  
.................... #define VCURLIM            900 
.................... // guess during new board debug Feb 18 2016 
....................  
.................... #define VALVE_STOP_W       990 
.................... #define VALVE_STOP_J       960 
....................    // This is the number of ADC counts below which we assume 
....................    //  the valve motor has hit a stop.  NOTE hardware has a .25 ohm  
....................    //  resistor to Vbat 
....................    // This value will depend on valve drive motor characteristics 
....................    //  *J for test bench; *W for Warner valve 
.................... */ 
.................... //************************************************************************** 
.................... /*    
....................    Experimentation with prototype valves during March/April 2015 brought up 
....................    problems with valve becoming STUCK at an endstop. 
....................    Solutions include:  
....................       1. DO NOT CHECK for excessive current during first few 
....................       nudges when COMING off an endstop 
....................       2. Once valve is moving along (past the initial nudge which overcomes 
....................       inertia) we can check for excessive current sooner in the nudge cycle 
....................    Care must be taken to accomodate various situations which could interfere 
....................       with this approach, such as when nudging is interrupted by the need to 
....................       acknowledge activity at the mote.    
....................   
....................   VALVE_CHKDEL0 is the time in ms to wait after the drive motor is 
....................   turned on before checking if we have excessive current as part of the 
....................   very first nudge which specifically overcomes the startup current 
....................   transient due to inertia 
....................  
....................  VALVE_CHKDEL0 will be dependent upon whether we are using the "WARNER" 
....................   valves or the in-house test fixture   
....................   
....................  VALVE_CHKDEL1 is the normal time in ms to wait after the drive motor is 
....................   turned on before checking if we have excessive current.  The assumption 
....................   for the choice of this value is that we have already overcome the startup 
....................   current transient due to inertia 
....................  
....................  VALVE_CHKNO is the number of nudges during which we DO NOT check for 
....................   excessive current in the case where the valve is specially coming off 
....................   of either the closed or open end stop 
....................  
....................  
....................  Flags specify the situation at hand: 
....................  atstop_fl     TRUE if we are currently at an endstop, this flag 
....................                ensures that the algorithm utilizes VALVE_CHKNO 
....................                 
....................  firstnudge_fl TRUE if we are starting the valve from rest and we are NOT 
....................                at an endstop; ensures that the algorithm utilizes VALVE_CHKDEL1 
....................                 
.................... EXCEPTION and possible issue in the future is the first nudge after  
.................... system startup.  We may or MAY NOT be at an endstop.  So we assume a 
.................... atstop_fl = TRUE.   
....................  
.................... If we are actually FULL OPEN, and get stuck (!) we can 
.................... detect this because the number of steps during initial open will be too few 
.................... (less than 2 or 3) and then we can try again with the atstop_fl set. 
....................  
.................... If we are actually at FULL CLOSED, and get stuck, again the first opening will 
.................... be too few steps and we must then try again with the atstop_fl set..... 
....................  
.................... Thus if after the startup dance, either close_time or open_time are  
.................... "unreasonable", we must simply do it again (although perhaps we could skip 
.................... the precharge if we have a good free-spin value).  This will be optimized 
.................... in a later version of the firmware.  
....................  
.................... condx                      atstop_fl      firstnudge_fl 
.................... ---------------------------------------------------- 
.................... 1st nudge after startup    TRUE           TRUE 
.................... (valve position unknown) 
.................... 1st nudge from endstop     TRUE           FALSE 
.................... 1st nudge norm             FALSE          TRUE 
.................... (or immediately after motion is interrupted by activity from mote) 
.................... subsequence nudges         FALSE          FALSE 
.................... */ 
.................... //*************************************************************************** 
....................  
.................... /* 
....................  
.................... //#define  VALVE_CHKNO       3 
.................... #define VALVE_NOCHK_W     3 
.................... #define VALVE_NOCHK_J     1 
....................  
.................... //#IFDEF   WARNER 
.................... //#define VALVE_ONTIME       150 
.................... //#define VALVE_CHKDEL0      100 
.................... //#ELSE 
.................... //#define VALVE_ONTIME       100 
.................... //#define VALVE_CHKDEL0      50 
.................... //#ENDIF 
....................  
.................... // These values are in milliseconds 
.................... #define VALVE_ONTIME_W     150 
.................... #define VALVE_CHK0_W       100 
.................... #define VALVE_ONTIME_J     100 
.................... #define VALVE_CHK0_J       50 
....................  
.................... // assume 16 bit counter triggered by FOSC div 64 (timer 0 prescaler) 
.................... // Thus one count every 64*T0_OSC nanoseconds 
.................... // Setup timer 0 for div64 and load with the value below for it to time out                         
....................  
.................... #define VALVE_TMR0SET0_W     (65536 - (1000000*(VALVE_ONTIME_W - VALVE_CHK0_W)+32*T0_OSC)/(64*T0_OSC)) 
.................... #define VALVE_TMR0SET0_J     (65536 - (1000000*(VALVE_ONTIME_J - VALVE_CHK0_J)+32*T0_OSC)/(64*T0_OSC)) 
.................... // THUS: if we delay CHK_DEL0 milliseconds, and then set a timer to timeout 
.................... //  according to VALVE_TMR0SET0, we have taken up a full CHUNK's worth of time 
....................  
.................... // once valve is in motion, only wait 20 msec before testing for endstop! 
.................... //  This is arbitrary and conservative. 
.................... #define VALVE_CHKDEL1      20 
.................... #define VALVE_TMR0SET1_W   (65536 - (1000000*(VALVE_ONTIME_W - VALVE_CHKDEL1)+32*T0_OSC)/(64*T0_OSC)) 
.................... #define VALVE_TMR0SET1_J   (65536 - (1000000*(VALVE_ONTIME_J - VALVE_CHKDEL1)+32*T0_OSC)/(64*T0_OSC)) 
.................... // THUS: if we delay CHK_DEL1 milliseconds, and then set a timer to timeout 
.................... //  according to VALVE_TMR0SET1, we have taken up a full CHUNK's worth of time 
....................  
....................    // VALVE_ONTIME is the number of milliseconds that the motor runs between 
....................    //  activity on mote checks 
....................    // VALVE_CHKDEL0 is the number of milliseconds we wait when motor is 
....................    //  first turned on to check for an endstop.  This accounts for the 
....................    //  inertial transient at first turn-on. 
....................     
.................... #define VALVE_ATSTOPDEL    50 
....................  
....................  
.................... #define VALVE_TIM0         (VALVE_ONTIME-VALVE_CHKDEL0) 
.................... // Set TMR0 to overflow after this number of millisecondes 
.................... //  Note that each tick of TMR0 during the move_valve routine is 
.................... //  32/19200 or 1.666 msec or 1667 microseconds 
.................... //  This convenient number is represented by the fraction 3/5 in the  
.................... //   define below 
.................... #define VALVE_TMR0SET0     256 - ((VALVE_TIM0*3)/5)  
.................... // THUS: if we delay CHK_DEL0 milliseconds, and then set a timer to timeout 
.................... //  according to VALVE_TMR0SET0, we have taken up a full CHUNK's worth of time 
....................   
....................  
....................  
....................  
.................... //#IFDEF   WARNER 
.................... //#define VCTR_LIMIT         200 
.................... //#ELSE 
.................... //#define VCTR_LIMIT         175 
.................... //#ENDIF 
....................  
.................... #define VALVE_CTRLIM_W       200 
.................... #define VALVE_CTRLIM_J       175 
.................... // little motions of valve motor should definitely get it to a stop 
.................... //  or to its destination;  if not we time out.  This number is somewhat 
.................... //  arbitrary 
....................  
.................... #define VCLASS2_LIM        38      
.................... // relative to 0 (full close) and 255 (full open) at what limit for  
.................... //  valve desired do we force bouncing off the nearest enstop? 
.................... // 15% would be 38 
.................... #define BOUNCE_OPEN        256-VCLASS2_LIM 
.................... #define BOUNCE_CLOSE       VCLASS2_LIM 
.................... #define V_ENDCTR_LIM       5 
.................... // force an endstop at least every 5 excursions 
....................  
....................  
.................... //#IFDEF   WARNER 
.................... //#define V_SINCEEND_LIM     400  
.................... //#ELSE 
.................... //#define V_SINCEEND_LIM     350 
.................... //#ENDIF 
.................... // force an endstop if cumulative motion has exceeded about 2 full paths 
.................... //  from open to closed 
.................... #define VALVE_SINCELIM_W   400 
.................... #define VALVE_SINCELIM_J   350 
....................  
....................  
.................... #define VFULL_TIM_LIM      7200 
.................... // if this number of seconds has passed since the full open2close or the 
.................... //  full close2open time has been remeasured, then force it. 
....................  
.................... // defines for vset_class variable 
.................... #define BOUNCE0_CL         0x01 
.................... #define BOUNCE0_OP         0x81 
.................... #define BOUNCE1_CL         0x02 
.................... #define BOUNCE1_OP         0x82 
.................... #define BOUNCE2_CL         0x03 
.................... #define BOUNCE2_OP         0x83 
.................... #define BOUNCE3_CL         0x04 
.................... #define BOUNCE3_OP         0x84 
....................  
.................... #define VTOOSHORT          60 
.................... // This is the minimum number of nudges for open to close or close to open 
.................... //  which is acceptable during startup dance.  If not VTOOSHORT, then 
.................... //  no problem is reported during first message after join 
.................... #define FREESPIN_LIM       120 
.................... // This is the minimum RPM which is 'acceptable' for free spin result! 
.................... // If not too slow, then no problem is reported during 
.................... //  first message after join 
....................  
.................... // EEPROM LOCATIONS 
.................... #define EE_ADDCHG_DUR      0x0002 
....................    // Configures add-charging time in seconds 
....................    // 2 bytes, low byte at 0x0002 
.................... #define ADDCHG_DUR_DEF     4 
....................    // 4 minutes? 
.................... #define EE_PRECHG_DUR      0x0004 
....................    // Configures precharging time in seconds 
....................    // 2 bytes, low byte at 0x0004 
.................... #define PRECHG_DUR_DEF     10 
....................    // 1.5 minutes?  
.................... #define CHGLOOPS_PER_MIN   110 
....................    // determined experimentally, each loop is about 545 msec 
....................    //  which is a bit longer than I would prefer (!), but oh well. 
....................    //  JG 2015 Jun16 
....................     
.................... // 0x00A thru 0x00F        reserved 
.................... #define EE_NETW_ID         0x0010 
....................    // 2 bytes, low byte at 0x0010; for now, network ID defaults to 0x04CD. 
.................... #define EE_PRENETW_ID      0x0012 
....................    // 2 bytes, low byte at 0x0012; for now, network ID defaults to 0x04CD. 
....................  
....................  
.................... // 0013 reserved 
.................... #define EE_LOCATION     0x0014 
....................    // 2 bytes, low byte at 0x0014; associates sprinkler with particular 
....................    //  physical location on CP 
.................... #define EE_PRELOCATION  0x0016 
....................    // 2 bytes, low byte at 0x0016, previous association of sprinkler with 
....................    //  particular physical location on CP 
....................  
....................    // 0x018 thru 0x01F     reserved 
....................  
.................... // IDLE behavior specified at 0x0020 thru 0x0033 
.................... #define EE_IDLE_OPT        0x0020 
....................    // Configures IDLE behavior.  Applies if battery low during operational 
....................    //  state 
....................    //  0x00  send out Panic Message once when panic level is reached according 
....................    //         to voltage-based algorithm 
....................    //  0x01  send out Panic Message once when panic level is reached according 
....................    //         to charge-based algorithm 
.................... #define MAX_IDLE_OPT       1 
....................    // If manager tries to write any idle_opt value larger than this to EEPROM 
....................    //  a NACK occurs; see above for idle option choices 
.................... #define LEN_IDLE_BLOCK     15 
....................    // There are 15 bytes in the idle block 
....................  
.................... #define EE_IDLE_PROFILE    0x0021 
....................    // Saved only upon entering IDLE state; 
....................    //  profile number which was running or had last been run. 
....................    // 0 for default profile, 1, 2, 3 for controller-specified profile choices 
....................    //  other numbers, use 0 
.................... #define EE_IDLE_STEP       0x0022 
....................    // Saved only upon entering IDLE state; 
....................    //  step number of profile which was running or had last been run. 
....................    //  Step 0xFF indicates that we were not within a profile 
....................    //  Step 0x10 thru 0xFE invalid. 
.................... #define EE_IDLE_STIME      0x0023 
....................    // 2 bytes, low byte at 0x0023, high byte at 0x0024 
....................    // Saved only upon entering IDLE state; 
....................    //  amount of time in seconds that rate was controlled according 
....................    //  to EE_IDLE_STEP at time when IDLE state entered; 
....................    //  set to 0x0000 if EE_IDLE_STEP=0xFF. 
.................... #define EE_IDLE_LOOP       0x0025 
....................    // 2 bytes, low byte at 0x0025, high byte at 0x0026 
....................    // Saved only upon entering IDLE state; 
....................    //  for looping profiles, loop number at time when IDLE state entered; 
....................    //  set to 0x0000 for non-looping profiles, set to 
....................    //  0x0000 if EE_IDLE_STEP=0xFF. (looping beyond 0xFFFF is recorded as 
....................    //  0xFFFF) 
.................... #define EE_IDLE_CHG        0x0027 
....................    // 2 bytes, low byte at 0x0027, high byte at 0x0028 
....................    // Configures used charge in millicoulombs for 
....................    //  charge-based shutdown method (TBD); applies if EE_IDLE.1 is set 
.................... #define EE_IDLE_SHDN_DLY   0x0029 
....................    // 2 bytes, low byte at 0x0029, high byte at 0x002A 
....................    // Configures time in units of 67 secs (TMR0 ints during IDLE) 
....................    //  between sensing of low battery and self-shutdown 
....................  
....................  
.................... // 0x02F thru 0x033        reserved 
....................  
.................... // PROFILE behavior specified at 0x0034 thru 0x003E 
.................... #define EE_PROFILE_OPT     0x0034 
....................    // Configures PROFILE behavior. 
....................    //  0x00 start profile0 (0x0050-0x007F) from the beginning 
....................    //  0x01 start profile1 (0x0090-0x00BF) from the beginning 
....................    //  0x02 start profile2 (0x00D0-0x00FF) from the beginning 
....................    //  0x03 start profile3 (0x0110-0x013F) from the beginning 
....................    //  0x04 start last used profile (EE_IDLE_PROFILE) from the beginning 
....................    //  0x05 start last used profile (EE_IDLE_PROFILE) from where it stopped 
.................... #define MAX_PROFILE_OPT    0x05 
....................    // profile option value cannot exceed this value 
....................  
....................  
.................... #define EE_SHUT_DEL        0x003E 
....................    // 2 bytes, low byte at 0x003E, high byte at 0x003F 
....................    // number of seconds between MSG_FORCE_COLD_DEL or MSG_SHUTDOWNx_DEL 
....................    //  and actual restart or shutdown 
....................    // For broadcast messages, ensures that all of the motes get the 
....................    //  message before they 'go away' 
....................  
.................... // GENERAL behavior specified at 0x0040 thru 0x004F 
.................... #define EE_GENERAL_OPT     0x0040 
....................    // Configures GENERAL behavior. 
....................    //  0x00 normal operation 
....................    //  0x01 test mode A (debug) 
....................    //  0x02 test mode B (time messages to DUST controller) 
....................    //  0x03 test mode C (debug and time messages) 
.................... #define MAX_GENERAL_OPT    0x03 
....................    // general option value cannot exceed this value 
....................  
.................... // 0x041 thru 0x04F        reserved 
....................  
.................... #define EE_REINFO          0x0050 
....................    // hold last known restart_cause 
....................  
.................... // 0x051 thru 0x05F        reserved 
....................  
.................... #define EE_DEADPROFILE     0x0060 
....................    // If death occurs during profiling, place profile number here (0,1,2,3) 
....................    //  else set to 0xFF 
.................... #define EE_DEADSTEP        0x0061 
....................    // Set to profile step number during which death occurred. 
.................... #define EE_DEADTIME        0x0062 
....................    // 2 bytes indicates how far along we were into the profile step when 
....................    //  dead battery was detected. 
.................... #define EE_DEADSTATE       0x0064 
....................    // system state during which dead battery was detected 
....................  
.................... // 0x065 thru 0x07F        reserved 
....................  
.................... #define EE_ERRORID         0x0080 
....................    // 2 bytes, low byte is the error_id and 
....................    //  high byte is errors1 -- saves last reason for a deep event error 
....................  
.................... #define EE_VSET_CLASS      0x0082 
.................... #define EE_V_ENDCTR        0x0083 
.................... #define EE_V_SINCEEND      0x0084 
.................... #define EE_O_C             0x0086 
.................... #define EE_C_O             0x0088 
....................  
.................... #define EE_RESTART_INFO    0x00A0 
.................... // 0x090 thru 0x0EF        reserved 
....................  
.................... #define EE_PROFILE0        0x00F0 
....................    // This is address of first byte of profile0 (default). 
....................    // May extend to 0x011F. 
....................    // 3 bytes per step, 16 steps.  Each step has 1 byte for RPM and 2 bytes 
....................    //  for duration in seconds.  If duration = 0x0000, then this means 
....................    //  "forever." 
....................    //  If 0x00 <= RPM <= RPM_MIN, then interpret RPM as RPM_MIN. 
....................    //  If RPM_MAX <= RPM <= 0xFF, then interpret RPM as RPM_MAX. 
....................    //  thus RPM = 0x00 and duration = 0xFFFF means single step rpm_min speed forever. 
....................    //  All bytes following duration = 0xFFFF in a profile are ignored. 
....................    //   RPM = 0xFF and duration = 0xFFFF is the end of profile marker for 
....................    //   "repeating" profiles".  0xFF / 0xFFFF cannot be the first step. 
....................    //  for steps preceeding duration = 0xFFFF, duration cannot = 0x0000! 
....................    //  Note that default profile is loaded into EEPROM by firmware 
....................    //   at start if none is present.  Controller can read or write 
....................    //   profiles. 
....................  
.................... // 0x120 thru 0x1EF        reserved 
....................  
.................... #define EE_VDD             0x1F0 
....................    // Two bytes; ADC-based estimate of Vdd (4.12 fixed pt format) 
.................... #define EE_VBATT           0x1F2 
....................    // Two bytes, ADC-based estimate of Vbatt 
.................... #define EE_VGEN            0x1F4 
....................    // Two bytes, ADC-based estimate of Vgen 
.................... #define EE_VSOLAR          0x1F6 
....................    // Two bytes, ADC-based estimate of Vsol 
....................  
....................  
.................... // SCRATCHPAD EEPROM 
....................  
.................... #define EE_DEBUG_1st       0x0200 
.................... #define EE_DEBUG_LAST      0x03F0 
....................  
.................... #define EE_FREE_1st        0x0200 
.................... #define EE_FREE_LAST       0x03BF      // free space never cleared 
.................... #define EE_SCRATCH_1ST     0x03F0 
.................... #define EE_SCRATCH_LAST    0x03F8      // scratch space cleared at start 
....................                                        //  (warm, cold, or xcold) 
....................    // This is the start and end of scrathpad memory in EEPROM.  To be used for 
....................    //  for debug purposes or TBD. 
....................  
.................... #define EE_BOOT_RECORD     0x0200      // new events and time 
.................... #define EE_NETID_TIME      0x0208 
.................... #define EE_MOTEOPER_TIME   0x020C 
.................... #define EE_MOTEIDLE_TIME   0x0210 
.................... #define EE_MSG_RECORD_0    0x0220 
.................... #define EE_MSG_RECORD_END  0x03BF 
....................  
.................... #define EE_SYS_STATE       0x03C0 
....................    // Address of state flags (echoes read only status) 
....................    // Written to EEPROM at significant state transitions 
.................... #define EE_INT_CTR         0x03E8 
....................    // Address of error/alarm flags (as many as 16 bytes) 
....................    // Written to EEPROM at significant state transitions 
.................... #define EE_CUR_PROFILE     0x03F0 
.................... #define EE_MSGBYTES_DBG    0x03F8 
.................... #define EE_PORTB_BIT       0x03F9 
.................... #define EE_PORTB_DIR       0x03FA 
....................  
....................  
....................     
....................  
....................    // for debug only 
....................  
.................... #define DUTYCYCLE_SET      0x40 
.................... // set join duty cycle for mote to this value at startup; approx 15% 
.................... #define SPECIALNV1_00      0x0000 
....................    // for rapid join time during debug, use with pkgen_setnv_special1(**) 
.................... #define SPECIALNV2_00      0x0005 
....................    // for rapid join time during debug, use with pkgen_setnv_special2(**) 
....................    // RAPID: 5 seconds to 0 seconds is a timing range having to do with 
....................    //  looking for advertisements during join 
....................    // NORMAL: 90 to 60 seconds..... 
.................... #define SPECIALNV1_01      0x003C 
....................    // for normal join time during debug, use with pkgen_setnv_special1(**) 
.................... #define SPECIALNV2_01      0x005A 
....................    // for normal join time during debug, use with pkgen_setnv_special2(**) 
....................  
.................... */ 
....................  
....................  
....................       /* signed int properties */ 
.................... #define INT_MAX 32767         /* signed integer minimum*/ 
.................... #define INT_MIN (-32768)      /*signed integer maximum*/ 
....................  
....................       /* signed long properties */ 
.................... #define LONG_MAX 2147483647        /* signed long maximum*/ 
.................... #define LONG_MIN (-2147483648) /* signed long minimum*/ 
....................  
.................... /* 
....................  
.................... // BELOW are constants and defines used in battery check routines 
....................  
.................... #define FVR_NOEE        2455 
.................... // approx 2V, any lower, don't attempt to run the micro or write to EE 
.................... //    fl_bat_NOEE 
.................... //    (BOX_CHAR here and below) 
....................  
.................... #define FVR_NODUST      2332 
.................... // 2.2 V; any lower, don't use the dust module; fl_batNODUST 
.................... //    ('D' here down to FVR_NOEE) 
....................  
.................... #define FVR_TEST        1819        
.................... // 2.7V threshold for testing purposes, display still visible 
....................  
.................... #define FVR_DEAD        1638 
.................... // 3.0V; dead battery, any lower, do not move valve; fl_batDEAD 
.................... //    ('d' here down to FVR_NODUST) 
....................  
.................... #define FVR_WEAK        1534 
.................... // 3.2V; below this point, battery dangerously weak  
.................... //  but can add charge, shout out; fl_batSHOUT, fl_addchg  
.................... //    ('-' here down to FVR_DEAD)) 
....................  
.................... #define FVR_ADDCHG      1511 
.................... // 3.25V; battery weak... below this point add charge, shout out 
.................... //    (! here down to FVR_WEAK); fl_batSHOUT, fl_addchg 
.................... // above this point, battery OK; fl_batOK 
.................... //    ('+' here up to FVR_ADEQUATE) 
....................  
.................... #define FVR_ADEQUATE    1488 
.................... // 3.30V; adequately charged if at or above this point; fl_batOK  
.................... //    ('f' here up to FVR_FULL) 
....................  
.................... #define FVR_FULL        1444 
.................... // 3.40V; battery full at or above this point; fl_batFULL 
.................... //    ('F' here up to FVR_TOOFULL) 
....................  
.................... #define FVR_TOOFULL     1327 
.................... // >=3.7 do not precharge, error condition?; fl_batTOOFULL 
.................... //    (TOPLINE_CHAR here and above) 
....................  
.................... // QCHK_FULL value is compared to 4x 1.2Vref as measured when sprinkler 
.................... //  is running and battery may be charging  (VfvrCAD) 
.................... // If the battery voltage measured during qchk_batt 
.................... //  is such that VfvrCAD < QCHK_FUL [indicates battery fully charged] 
.................... //  then charging will stop, hopefully in a smooth and controlled manner 
.................... //  before the charger hardware cannot charge due to its configuration. 
.................... // After this occurs, charging will not take place until the next marching 
.................... //  order, at which point a chk_batt happens and a different criterion applies. 
.................... // Note that qchk_batt() measures during running and charging! 
.................... // The flag fl_qbatFULL is set and not cleared until the next marching order 
.................... //  is processed. 
.................... #define QCHK_FULL       1391 
.................... // 1023/1391 * 4.8V = 3.53V 
.................... // charging never enabled (fl_qbatFULL set) when VfvrCAD < QCHK_FULL 
.................... //    (chargemark set to TOPLINE_CHAR whenever fl_qbatFULL is set) 
.................... //    (chargemark set to 'c' if !fl_qbatFULL and significant difference 
.................... //     between generator voltage while charging as compared to not charing) 
....................  
.................... #define BATT_HYST       12 
.................... // If the difference between the battery voltage at the start of a new 
.................... //  marching order as compared to the VfvrAD which was measured when 
.................... //  a bat full situation was last determined is greater than this amount, 
.................... //  then we turn charging back on; in other words, if the battery voltage 
.................... //  has dropped during the previous marching order to a great enough extent 
.................... //  AFTER we had already determined that the battery was full, then we turn 
.................... //  charging back on (Rev 030+) 
.................... // Approx a 30mV drop [somewhat arbitrary, but provides a form of hysteresis] 
....................  
.................... #define TM_BATCHK       7200 
....................    // number of seconds maximum between chk_batt() calls; 
....................  
....................  
.................... #define TM_SPINRPT      0xA1 
....................    // arbitrary 8 bit number which, when compared to low byte of seconds ctr 
....................    //  initiates the possible reporting of a spin error (should be greater than 
....................    //  32 seconds because that is the amount of time it takes for the variance 
....................    //  determination to take place (sizeof periods[]) 
....................    // Possible error states include: NOSPIN_ERRCODE, SPEEDLO_ERRCODE, 
....................    //  SPEEDHI_ERRCODE, SPEEDREG_ERRCODE 
....................    // NOSPIN: manager has told us that water is flowing, but 
....................    //  speed is too slow to detect (<~3RPM) 
....................    // SPEEDLO/SPEEDHI: average speed over previous 64 measurements is beyond 
....................    //  limit established (e.g., +/-3%) 
....................    // SPEEDREG: max speed (or min speed) over previous 64 measurements 
....................    //  exceeds limit establihsed (e.g. target+/-6%) 
....................    // In this code, spin checks occur once every 256 seconds, or whenever 
....................    //  requested by the manager (MSG_STATUS_RDONLY). 
....................    // If a problem is detected, an error message immediately goes out one time. 
....................    //  THUS spin errors will be sent at least every 256 seconds 
....................    //  (change later?) 
....................  
.................... #define ONE_WEEK     2235 
....................    // number of 4.51 minute intervals in a week (for DEAD BATT HANDLER) 
....................  
.................... #define DEAD_BATTERY    0xFF 
....................    // indicates that restart event was due to dead battery detection 
....................  
.................... #define GET_A_CHAR(value)   { TMR1L = 0x78;  \ 
....................                               TMR1IF = FALSE;  \ 
....................                               output_low(_DUST_SPCTS);  \ 
....................                               while (!(kbhit() || TMR1IF));  \ 
....................                               errors1 |= RCSTA; \ 
....................                               dust_recive_buffer[value] = RCREG; \ 
....................                               output_high(_DUST_SPCTS); \ 
....................                             } 
.................... #define GET_1_CHAR      { set_timer1(0); \ 
....................                           output_low(_DUST_SPCTS);  \ 
....................                           while (!kbhit() && bit_test(TMR1H,7));  \                          
....................                           *mm = RCREG; \ 
....................                           output_high(_DUST_SPCTS); \  
....................                           mm++; \ 
....................                         } 
....................                          
.................... #define GET_blah_CHAR      { output_low(_DUST_SPCTS);  \ 
....................                           while (!kbhit());  \                          
....................                           *mm = RCREG; \ 
....................                           output_high(_DUST_SPCTS); \  
....................                           mm++; \ 
....................                         } 
....................  
.................... #define GET_32CHARS  {  GET_A_CHAR(0) \ 
....................                         GET_A_CHAR(1) \ 
....................                         GET_A_CHAR(2) \ 
....................                         GET_A_CHAR(3) \ 
....................                         GET_A_CHAR(4) \ 
....................                         GET_A_CHAR(5) \ 
....................                         GET_A_CHAR(6) \ 
....................                         GET_A_CHAR(7) \ 
....................                         GET_A_CHAR(8) \ 
....................                         GET_A_CHAR(9) \ 
....................                         GET_A_CHAR(10) \ 
....................                         GET_A_CHAR(11) \ 
....................                         GET_A_CHAR(12) \ 
....................                         GET_A_CHAR(13) \ 
....................                         GET_A_CHAR(14) \ 
....................                         GET_A_CHAR(15) \ 
....................                         GET_A_CHAR(16) \ 
....................                         GET_A_CHAR(17) \ 
....................                         GET_A_CHAR(18) \ 
....................                         GET_A_CHAR(19) \ 
....................                         GET_A_CHAR(20) \ 
....................                         GET_A_CHAR(21) \ 
....................                         GET_A_CHAR(22) \ 
....................                         GET_A_CHAR(23) \ 
....................                         GET_A_CHAR(24) \ 
....................                         GET_A_CHAR(25) \ 
....................                         GET_A_CHAR(26) \ 
....................                         GET_A_CHAR(27) \ 
....................                         GET_A_CHAR(28) \ 
....................                         GET_A_CHAR(29) \ 
....................                         GET_A_CHAR(30) \ 
....................                         GET_A_CHAR(31) } 
....................                          
.................... #define GET_REST_OF_CHARS  {  GET_1_CHAR \ 
....................                               GET_1_CHAR \ 
....................                               GET_1_CHAR \ 
....................                               GET_1_CHAR \ 
....................                               GET_1_CHAR \ 
....................                               GET_1_CHAR \ 
....................                               GET_1_CHAR \ 
....................                               GET_1_CHAR \ 
....................                               GET_1_CHAR \ 
....................                               GET_1_CHAR \ 
....................                               GET_1_CHAR \ 
....................                               GET_1_CHAR \ 
....................                               GET_1_CHAR \ 
....................                               GET_1_CHAR \ 
....................                               GET_1_CHAR \ 
....................                               GET_1_CHAR \ 
....................                               GET_1_CHAR \ 
....................                               GET_1_CHAR \ 
....................                               GET_1_CHAR \ 
....................                               GET_1_CHAR \ 
....................                               GET_1_CHAR \ 
....................                               GET_1_CHAR \ 
....................                               GET_1_CHAR \ 
....................                               GET_1_CHAR \ 
....................                               GET_1_CHAR \ 
....................                               GET_1_CHAR \ 
....................                               GET_1_CHAR \ 
....................                               GET_1_CHAR \ 
....................                               GET_1_CHAR \ 
....................                               GET_1_CHAR \ 
....................                               GET_1_CHAR \ } 
....................  
....................  
.................... // see MOTETIME.xlsx 
.................... // 1/1/2013 midnight .... 1/1/2062 midnight 
.................... UNSIGNED INT32 CONST YRLUKUP [50] = { 
....................    0x50E22700,0x52C35A80,0x54A48E00,0x5685C180,0x58684680, 
....................    0x5A497A00,0x5C2AAD80,0x5E0BE100,0x5FEE6600,0x61CF9980, 
....................    0x63B0CD00,0x65920080,0x67748580,0x6955B900,0x6B36EC80, 
....................    0x6D182000,0x6EFAA500,0x70DBD880,0x72BD0C00,0x749E3F80, 
....................    0x7680C480,0x7861F800,0x7A432B80,0x7C245F00,0x7E06E400, 
....................    0x7FE81780,0x81C94B00,0x83AA7E80,0x858D0380,0x876E3700, 
....................    0x894F6A80,0x8B309E00,0x8D132300,0x8EF45680,0x90D58A00, 
....................    0x92B6BD80,0x94994280,0x967A7600,0x985BA980,0x9A3CDD00, 
....................    0x9C1F6200,0x9E009580,0x9FE1C900,0xA1C2FC80,0xA3A58180, 
....................    0xA586B500,0xA767E880,0xA9491C00,0xAB2BA100,0xAD0CD480}; 
....................     
....................  
.................... UNSIGNED INT8 CONST BYTE_2_PCT [256] = { 
....................     0, 0, 1, 1, 2, 2, 2, 3, 3, 4, 4, 4, 5, 5, 5, 6,  
....................     6, 7, 7, 7, 8, 8, 9, 9, 9,10,10,11,11,11,12,12, 
....................    13,13,13,14,14,15,15,15,16,16,16,17,17,18,18,18, 
....................    19,19,20,20,20,21,21,22,22,22,23,23,24,24,24,25, 
....................    25,25,26,26,27,27,27,28,28,29,29,29,30,30,31,31, 
....................    31,32,32,33,33,33,34,34,35,35,35,36,36,36,37,37, 
....................    38,38,38,39,39,40,40,40,41,41,42,42,42,43,43,44, 
....................    44,44,45,45,45,46,46,47,47,47,48,48,49,49,49,50, 
....................    50,51,51,51,52,52,53,53,53,54,54,55,55,55,56,56, 
....................    56,57,57,58,58,58,59,59,60,60,60,61,61,62,62,62, 
....................    63,63,64,64,64,65,65,65,66,66,67,67,67,68,68,69, 
....................    69,69,70,70,71,71,71,72,72,73,73,73,74,74,75,75, 
....................    75,76,76,76,77,77,78,78,78,79,79,80,80,80,81,81, 
....................    82,82,82,83,83,84,84,84,85,85,85,86,86,87,87,87, 
....................    88,88,89,89,89,90,90,91,91,91,92,92,93,93,93,94, 
....................    94,95,95,95,96,96,96,97,97,98,98,98,99,99,100,100 }; 
....................     
.................... UNSIGNED INT8 CONST BYTE99_2_10S [100] = { 
....................    '0', '0', '0', '0', '0', '0', '0', '0', '0', '0',  
....................    '1', '1', '1', '1', '1', '1', '1', '1', '1', '1',  
....................    '2', '2', '2', '2', '2', '2', '2', '2', '2', '2',  
....................    '3', '3', '3', '3', '3', '3', '3', '3', '3', '3',  
....................    '4', '4', '4', '4', '4', '4', '4', '4', '4', '4',  
....................    '5', '5', '5', '5', '5', '5', '5', '5', '5', '5',  
....................    '6', '6', '6', '6', '6', '6', '6', '6', '6', '6',  
....................    '7', '7', '7', '7', '7', '7', '7', '7', '7', '7',  
....................    '8', '8', '8', '8', '8', '8', '8', '8', '8', '8',  
....................    '9', '9', '9', '9', '9', '9', '9', '9', '9', '9' }; 
....................  
.................... UNSIGNED INT8 CONST BYTE99_2_1S [100] = { 
....................    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 
....................    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 
....................    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 
....................    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 
....................    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 
....................    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 
....................    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 
....................    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 
....................    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 
....................    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9' }; 
....................     
.................... */ 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... #include "defines.h" 
.................... // defines.h                                                                
.................... // 
.................... // contains all non-pic (and non-dn2500.h) related defines and macros 
....................  
.................... ////////////////////Defines Table of Contents////////////////////////////////// 
.................... //Version 
.................... //Priority Queue 
.................... //Time Queue 
.................... //Command Stack 
.................... //Sprinkler Stack 
.................... //Gen RPM                               
.................... //Control Algorithm 
.................... //Valve                
.................... //XDCR           
.................... //RB ISR         
.................... //I2C Addresses  
.................... //LCD         
.................... //DUST    
.................... //Errors   
....................              
.................... ////////////////////Version//////////////////////////////////////////////////// 
.................... #define FIRMWARE_VERSION 0xE312           
....................  
....................                             
.................... // Defines designed to simply debugging and program development process         
.................... #DEFINE DISABLE_NO_SPIN_RECOVERY          1 
.................... #DEFINE DISABLE_MAG_DECOUPLING_RECOVERY   1               
.................... #DEFINE DISABLE_RECAL_VLV                 1 
....................                                     
.................... ////////////////////Priority Queue///////////////////////////////////////////// 
.................... // Maximum number of items in priority queue. Each item is 1 byte and in RAM 
.................... // Actual number of items is max - 1 as item 0 is reserved for sorting use 
.................... #define MAX_PRIORITY_QUEUE_ITEMS   20 
....................  
.................... // Priority Queue items (identified by their priority) (1-255) 
.................... // lower number is higher priority 
.................... #define EMPTY_PRIORITY_QUEUE           0x00 
....................  
.................... #define WAIT_FOR_BOOT_EVENT            0x10 
.................... #define RESET_MOTE                     0x11 
....................  
.................... #define DEAL_WITH_NEW_PACKET           0x20 
....................  
.................... #define VALVE_MOVE_ERROR               0x30 
.................... #define CALIBRATE_VALVE_1              0x31 
.................... #define CALIBRATE_VALVE_2              0x32                   
.................... #define CALIBRATE_VALVE_3              0x33 
.................... #define CALIBRATE_VALVE_4              0x34 
.................... #define CALIBRATE_VALVE_5              0x35 
.................... #define CALIBRATE_VALVE_6              0x36 
.................... #define CALIBRATE_FSR_1                0x37 
.................... #define CALIBRATE_FSR_2                0x38            
.................... #define CALIBRATE_FSR_3                0x39 
.................... #define CALIBRATE_FSR_4                0X3A 
.................... #define MOVE_VALVE_MAG_DECOUPLING_RECOVERY 0x3C              
.................... #define MOVE_VALVE_NO_SPIN_RECOVERY        0x3D  
.................... #define OPEN_VALVE_UNKNOWN_STATE       0x3E 
.................... #define CLOSE_VALVE_UNKNOWN_STATE      0x3F 
.................... #define MOVE_VALVE                     0x40 
....................  
.................... #define START_GPS_AQUISITION           0x50 
.................... #define CHECK_GPS_FOR_LOCK             0x51  
.................... #define TAKE_XCDR_MESUREMENT_1         0x55 
.................... #define TAKE_XCDR_MESUREMENT_2         0x56   
.................... #define OPTIMIZE_MPPC                  0xA0 
....................  
.................... #define CHECK_BATTERY_STATE            0xA1 
.................... #define CHECK_MOTE_TEMP                0xA2 
.................... #define UPDATE_MOTE_TIME               0xA3 
.................... #define UPDATE_MOTE_NETWORK_INFO       0xA4 
....................  
.................... #define SEARCH_FOR_STRONGEST_1         0xB1 
.................... #define SEARCH_FOR_STRONGEST_2         0xB2 
.................... #define INIT_JOIN                      0xB3 
.................... #define CHECK_MOTE_STATE               0xB4 
.................... #define CHECK_MOTE_INFO                0xB5 
....................  
.................... #define BUSCOL_RESET                   0xC0 
....................  
.................... #define LCD_DISPLAY_RUN_MODULATION     0xD1 
.................... #define LCD_DISPLAY_RUN_NO_MODULATION  0xD2 
.................... #define LCD_DISPLAY_RBUF               0xD3 
.................... #define LCD_UPDATE                     0xD4 
....................  
.................... #define CPU_RESET                      0xF0 
.................... #define SHUTDOWN_SYSTEM                0xF1 
....................  
.................... // Macros used to push things to priority queue 
.................... #define PUSH_PRIORITY_QUEUE_MACRO(x)                                          \ 
.................... {disable_interrupts(INT_CCP4);                                                  \ 
.................... push_priority_queue(x);                                                       \ 
.................... enable_interrupts(INT_CCP4);} 
....................                                   
.................... #define PUSH_PRIORITY_QUEUE_ISR_MACRO(x) {push_priority_queue_ISR(x);}  
....................                                   
.................... ////////////////////Time Queue///////////////////////////////////////////////// 
.................... // Maximum number of items in time queue. Each item is 5 bytes and in RAM 
.................... // Actual number of items is max - 1 as item 0 is reserved for sorting use 
.................... #define MAX_TIME_QUEUE_ITEMS   5 
....................  
.................... // empty spot in the time queue, used as return item to signify empty top spot 
.................... #define EMPTY_TIME_QUEUE 0 
....................  
.................... // struct of individual time queue item 
.................... struct TimeQueueItem  
.................... { 
....................    uint32_t time_to_execute; 
....................    uint8_t pq_priority; 
.................... }; 
....................  
.................... // Macro for pushing items onto the time queue 
.................... #define PUSH_TIME_QUEUE_MACRO(x,y)  {disable_interrupts(INT_CCP4);            \ 
....................                                     push_time_queue(x,y);                     \ 
....................                                     enable_interrupts(INT_CCP4);}   
....................                                  
.................... ////////////////////Periodic checks/updates done in the time queue 
.................... // How often "long-term" checks are done within ccp4 (timer interrupt) in seconds 
....................    // - mote state (reacts as necessary) 
....................    // - battery state (turns off/on charging, sends warnings, etc.) 
....................    // - mote temp (logs data, sends warnings, etc.) 
....................    // - mote utc time (updates utc time if valid) 
.................... #define PERIODIC_CHECKS_TIME      32 
....................  
.................... ////////////////////Command Queue////////////////////////////////////////////// 
.................... // depth of command queue 
.................... #define MAX_COMMAND_QUEUE_ITEMS 10 
....................  
.................... // maximum number of sprinkler zones in each command coming from manager 
.................... #define MAX_NUM_SPRINKLER_ZONES 4 
....................  
.................... // struct for individual sprinkler zone settings 
.................... struct SprinklerZoneSettingsItem 
.................... { 
....................    uint16_t vlv_open_amount; 
....................    uint16_t spin_rate; 
....................    uint8_t duty_cycle; 
.................... }; 
....................  
.................... // struct for a single command (coming from manager) and item in the command 
.................... // queue 
.................... struct CommandQueueItem 
.................... { 
....................    uint32_t start_time; 
....................    uint32_t end_time; 
....................    struct SprinklerZoneSettingsItem* sprinkler_settings; 
....................    uint8_t num_of_zones; 
....................    uint8_t control_loop_mechanism; 
.................... }; 
....................  
.................... ////////////////////Sprinkler Queue//////////////////////////////////////////// 
.................... // depth of sprinkler queue (ONLY SETUP FOR 2 AT THE MOMENT) 
.................... //#define MAX_SPRINKLER_QUEUE_ITEMS 2 
.................... #define MAX_SPRINKLER_QUEUE_ITEMS 10 
....................  
.................... // struct for single sprinkler queue item 
.................... struct SprinklerQueueItem 
.................... { 
....................    uint32_t start_time; 
....................    uint32_t end_time; 
....................    uint16_t vlv_open_amount; 
....................    uint16_t spin_rate; 
....................    uint8_t zone_num; 
....................    uint8_t control_loop_mechanism; 
.................... }; 
....................  
.................... #define EMPTY_SPINKLER_QUEUE 0 
.................... /////////////////////Message Queue///////////////////////////////////////////// 
.................... // depth of message queue 
.................... #define MAX_MESSAGE_QUEUE_ITEMS 10  
....................  
.................... // empty spot in the message queue, used as return item to signify empty top spot 
.................... #define EMPTY_MESSAGE_QUEUE 0 
....................  
.................... // how many times will messages be attempted before an error message/bit is sent/set 
.................... #define MAX_UNSOLICITED_MESSAGE_ATTEMPTS 3 
....................                                                                      
.................... // how long to wait between message reattempts in seconds 
.................... #define MESSAGE_RESEND_WAIT_PERIOD 60 
....................  
.................... // how often identical error messages are able to be resent (if there haven't been any other types of error messages) in seconds 
.................... #define ERR_MESSAGE_WAIT_PERIOD 60                                                             
....................                                                                                             
.................... // struct for single message queue item 
.................... struct MessageQueueItem 
.................... {                                            
....................    uint32_t time_to_send; 
....................    uint8_t message_type; 
....................    uint16_t msg_seq; 
....................    uint8_t attempt_num; 
.................... }; 
....................  
.................... // Macro for pushing items onto the message queue 
.................... #define PUSH_MESSAGE_QUEUE_MACRO(x)  {disable_interrupts(INT_CCP4);           \ 
....................                                        push_message_queue(x);                 \ 
....................                                        enable_interrupts(INT_CCP4);}    
....................                                         
.................... #define PUSH_MESSAGE_QUEUE_ISR_MACRO(x)  {disable_interrupts(INT_CCP4);       \ 
....................                                           push_message_queue_isr(x);              \ 
....................                                           enable_interrupts(INT_CCP4);}                                           
....................                                         
.................... // Macro for deleting items off the message queue 
.................... #define REMOVE_MESSAGE_QUEUE_MACRO(x)  {disable_interrupts(INT_CCP4);         \ 
....................                                        remove_message_queue_item(x);          \ 
....................                                        enable_interrupts(INT_CCP4);}                                        
....................  
.................... /////////////////////Gen RPM/////////////////////////////////////////////////// 
.................... #define CCP_PER_RPM     2576980378L                                      
.................... // 39322 shifted 16 places left 
.................... // The timer used for the RPM measurement (CCP5) is 32.768KHz clock 
.................... // Stepper has 50 poles.... 
.................... // stepper output frequency = 50 * revs/sec = 50/60 * RPM                    
.................... // stepper output period = 1.2 / RPM 
.................... // CCP counter period = 1/32768 
.................... // CCP counts = (1.2/RPM) / (1/32768) = 39321.6 / RPM 
.................... // RPM = 39322/(CCP counts)  
....................                                                            
.................... #define T5_PER_RPM      69120 
.................... // assumes 921.6KHz div4 div4 into TIMER5 (or use of CCP5 with TMR5) 
.................... // assumes that stepper has 50 poles.... 
.................... // stepper output frequency = 50 * revs/sec = 50/60 * RPM 
.................... // stepper output period = 1.2 / RPM 
.................... // CCP counter period = 16/921.6K 
.................... // CCP counts = (1.2/RPM) / (16/921.6K) = 69120 / RPM 
.................... // RPM = 69120/(CCP counts) 
....................  
.................... ////////////////////Control Algorithm Defines////////////////////////////////// 
.................... // Min/Max Value of braking 
.................... #define NO_BRK    0 
.................... #define MAX_BRK   400 
....................  
.................... // Min/Max Value of charging 
.................... #define NO_CHARGE    0 
.................... #define MAX_CHARGE   400 
....................  
.................... // Min/Max Value of MPPC 
.................... #define NO_MPPC    0x07 
.................... #define MAX_MPPC   0xFF 
....................  
.................... // Min/Max setting of rpm 
.................... #define MIN_RPM_SETTING    10  
.................... #define MAX_RPM_SETTING    250 
....................  
.................... // Min/Max Value of fixture dac setting 
.................... // Set DAC on lab fixture to 0xC00 to sink ALL the current from the power 
.................... // source...  750mA (Test fixture setup:  full scale (0x1000) draws 1A 
.................... #define NO_FIXTURE    0x000 
.................... #define MAX_FIXTURE   0xC00 
....................  
.................... // Battery Charging cutoffs (in adc counts summed over 4 samples) 
.................... // When to stop charging the battery (3.5V while charging) 
.................... #define BATTERY_STOP_CHARGING    1402 
.................... // Hysteresis to start charging the battery again (3.3V while NOT charging) 
.................... #define BATTERY_START_CHARGING   1490 
.................... // When to warn the manager that the battery is dying (3.1V while NOT charging) 
.................... #define BATTERY_WARN             1584      
.................... // When to put the mote to sleep (3.0V while NOT charging) 
.................... #define BATTERY_DEAD             1637   
....................  
.................... // defines for global_control_loop_mechanism 
.................... // Shows what is being used to control rpm in control loop 
.................... // No rpm control is generally used for test modes                                   
.................... // No rpm control fsr will set braking and charging to 0 for FSR Calibration      
....................                                     
.................... // where to "jump into" the control loop. 
.................... //    basically, regular mode with both engaged, but it will evaluate if it should go into 
.................... //    BRAKE_AND_CHARGE or BRAKE_ONLY         
.................... #define BRAKE_AND_CHARGE_START      0x00 
.................... // regular mode with charging turned on        
.................... #define BRAKE_AND_CHARGE            0x01 
.................... // regular mode with charging turned off (due to full battery most likely) 
.................... #define BRAKE_ONLY                  0x02 
.................... // test mode where charging is force off 
.................... #define FORCE_BRAKE_ONLY            0x03 
.................... // test mode where braking is forced off 
.................... #define FORCE_CHARGE_ONLY           0x04 
.................... // test mode where brake and charge are set 
.................... #define NO_RPM_CONTROL              0x05 
.................... // test mode where brake and charge are set and dynamic mppc is used 
.................... #define NO_RPM_CONTROL_DYN_MPPC     0x06 
.................... // FSR calibration (no brake/charge/rpm control) 
.................... #define NO_RPM_CONTROL_FSR          0x07 
.................... // magnetic decoupling recovery 
.................... #define NO_SPIN_RECOVERY            0x08 
.................... // magnetic decoupling recovery             
.................... #define MAG_DECOUPLING_RECOVERY     0x09   
.................... // idle (nothing in the queue). Disable control loop    
.................... #define NO_SPRINKLER_CONTROL        0xFF                    
....................                                                          
.................... ////////////////////Valve////////////////////////////////////////////////////// 
.................... // Starting position of the DAC (also works as the eeprom stored inital value) 
.................... #define VLV_POSITION_UNKNOWN         0xFFFF 
.................... // Fully closed valve position                                                 
.................... #define VLV_POSITION_CLOSED          0x0000 
.................... // Fully open valve position      
.................... #define VLV_POSITION_OPENED          0x8000 
....................  
.................... // moved to eeprom stuff 
.................... /* 
.................... // Maximum value of "near closed" range 
.................... #define VLV_NEAR_CLOSED_RANGE_MAX    0x1000 
.................... // Maximum value of "near opened" range 
.................... #define VLV_NEAR_OPENED_RANGE_MAX    0x7000 
.................... */ 
.................... // default valve position for pre-calibration                     
.................... #define VLV_PRECALIBRAION_POSITION   0x4000 
.................... // Amount to move open in calibration routine 1 in units of valve position 
.................... #define VLV_CAL_1_MOVEMENT           0x2000     
....................  
.................... //moved to eeprom stuff 
.................... /* 
.................... // DAC level while opening near the fully open end 
.................... #define DAC_LVL_OPENING_NEAR_OPENED       22        
.................... // DAC level while opening near the fully closed end 
.................... #define DAC_LVL_OPENING_NEAR_CLOSED       15    
.................... // DAC level while closing near the fully open end 
.................... #define DAC_LVL_CLOSING_NEAR_OPENED       15 
.................... // DAC level while closing near the fully closed end 
.................... #define DAC_LVL_CLOSING_NEAR_CLOSED       21 
.................... // DAC level while moving in the middle of the valve range and it's default 
.................... #define DAC_LVL_IN_MIDDLE                 18 
.................... // DAC level for the inital current boost/lowered current limit   
.................... #define DAC_LVL_INIT_CURRENT_BOOST        15             
.................... */ 
....................  
.................... // Valve timeout in millispans (maximum number of millispans that it can move  
.................... //    without error).  1024 is the full range. 
.................... #define VALVE_TIMEOUT                     1500 
....................  
.................... // Number of movements since an endstop before triggering a re-calibration of 
.................... //    endstop position (done before/triggered by a pending move) 
.................... #define VLV_MOVES_BEFORE_RECAL            25          
....................                                               
.................... // moved to eeprom stuff 
.................... /* 
.................... // Amount of millispans that a current boost/lovered dac level is implemented. 
.................... //    This is done outside of the (NEAR_CLOSED/OPEN_RANGE) 
.................... //    @ 45 seconds to close, 30 = 1.3 seconds 
.................... #define VLV_INIT_CURRENT_BOOST_TIME_1024THS   30      
.................... */                                     
....................  
.................... // default time_to_open/close.  This is the number of 2ndary Osccilator ticks 
.................... //    for 1/1024th of the span if the entire open-close takes 45 seconds. 
.................... #define DEFAULT_VLV_TIME_TO_OPEN          1280   
.................... #define DEFAULT_VLV_TIME_TO_CLOSE         1280        
....................     
.................... // if vlv_time_to_close/open is below this number, errors are thrown and calibration  
.................... //     is thrown away.  750 = 23.4375 seconds 
.................... #define ERROR_VLV_CAL_TIME                 750    
....................  
.................... // moved to eeprom stuff 
.................... /* 
.................... // valve not-spinning and magnetic de-coupling defines                                                     
.................... // below this number is the regime where we watch for the vgen not spinning case 
.................... #define VLV_NOT_SPIN_LIMIT                0x6000 
.................... // where we send the valve when we want to fix it.  If it gets fixed before reaching this valve position 
.................... //    it stops. If it does not get fixed by the time it reaches this position, it sends an error and stops. 
.................... #define VLV_NOT_SPIN_FIX                  0x7000 
....................                                             
.................... // above this rpm, consider magnetic coupling or not-spinning fixed 
.................... #define NOT_SPINNING_MAG_DECOUPLING_RPM_FIXED   8        
....................                                                    
.................... // above this number is the regime where we watch for the vgen not spinning case 
.................... #define VLV_MAGNETIC_COUPLING_LIMIT       0x6000        
.................... // where to move the valve at a time when trying to recover  
.................... #define VLV_MAGNETIC_COUPLING_FIX         0x2000          
.................... // amount to move the valve at a time when trying to recover 
....................                                                   
.................... // how many seconds it takes to consider the rpm to be zero (or infinite for higher valve settings)  
.................... // 8 = 7.5 RPM (8 may be max of what ccp5 can handle without overflow)             
.................... #define RPM_TIMEOUT                      8        
.................... */                                                         
....................  
.................... // defines for testing valve state 
.................... #define  IS_VLV_COASTING   (LATE == 0) 
.................... #define  IS_VLV_CLOSING    (LATE == 0x01) 
.................... #define  IS_VLV_OPENING    (LATE == 0x02) 
.................... #define  IS_VLV_BRAKING    (LATE == 0x03) 
....................  
.................... // macros for making the valve move 
.................... #define  mV_COASTm   {LATE=0;} 
.................... #define  mV_CLOSEm   {LATE=0x01;} 
.................... #define  mV_OPENm    {LATE=0x02;} 
.................... #define  mV_BRAKEm   {LATE=0x03;}                                                                                                                      
....................  
.................... ////////////////////XDCR///////////////////////////////////////////////////////  
.................... // limit for detecting if the XDCR is plugged in or not.   
.................... // there is a ~5.6M resistor pulling the line up to vcc. 
.................... // It sums 8 measurements and with the weak pullups is usually around 6200 
.................... // To account for variation, we will set 5000 (around 75 psi on the 100 psi sensor) 
.................... // as the limit to detect it.         
.................... #define XDCR_ADC_OFF_LIMIT 5000      
....................                                                      
.................... ////////////////////RB ISR/////////////////////////////////////////////////////   
.................... // seconds you have to press SW1 until it activate the long press function 
.................... #define SW1_ISR_LONG_PRESS_TIME 5  
....................                                              
.................... ////////////////////I2C Addresses////////////////////////////////////////////// 
.................... #define LCD_ADDRESS 0x7C 
.................... #define XDCR_ADDRESS 0x48         
.................... #define FIXTURE_DAC_ADDRESS 0x40     
....................                                     
.................... ////////////////////LCD Defines////////////////////////////////////////////////     
.................... // total number of lcd pages defined in switch-case in LCD_update_diplay() 
.................... // JG: Actually there are 4 defined in the switch-case, but only 
.................... //  want to see 3 at this time 
.................... #define TOTAL_LCD_PAGES 4                              
....................  
.................... ////////////////////LED Defines Start//////////////////////////////////////////    
.................... // make sure to disable INT_RB4 to not have the led trigger an IOC int 
.................... #define LED1_ON       disable_interrupts(INT_RB4); set_tris_b(TRISB_LED); output_low(LED1n); 
.................... #define LED1_OFF      set_tris_b(TRISB_NORM); enable_interrupts(INT_RB4); 
....................  
.................... #define LED2_ON       output_low(LED2n); 
.................... #define LED2_OFF      output_high(LED2n); 
....................  
.................... ////////////////////LED Defines End//////////////////////////////////////////// 
....................  
.................... ////////////////////DUST Defines/////////////////////////////////////////////// 
.................... // moved to eeprom stuff      
.................... /*                                             
.................... // amount of seconds for mote to stay searching for advertisements                     
.................... #define MOTE_SEARCH_TIME 120        
.................... // amount of time the mote will stay disconnected from the network before shutting down (900 = 15 min)    
.................... #define MOTE_NETWORK_SHUTDOWN_TIMEOUT 900            
.................... */ 
....................  
.................... // Min temperature before sending a warning/shutdown 
.................... #define MOTE_MIN_TEMP_WARNING   -35 
.................... #define MOTE_MAX_TEMP_WARNING    80                                       
.................... #define MOTE_MIN_TEMP_SHUTDOWN   -40 
.................... #define MOTE_MAX_TEMP_SHUTDOWN   85                                                             
....................  
.................... //Crazy macro for finding control escape 
.................... #define STUFF_BYTE(x, y, z)  { \ 
....................     if ((x==CONTROL_ESCAPE)||(x==FLAG_SEQUENCE)) { \ 
....................         y[z++] = CONTROL_ESCAPE; \ 
....................         y[z++] = x ^ XOR_BYTE; \ 
....................     } else { \ 
....................         y[z++] = x;     \ 
....................     } \ 
.................... } 
....................  
.................... #define STUFF_BYTE_ISR(x, y, z)  { \ 
....................     if ((x==CONTROL_ESCAPE)||(x==FLAG_SEQUENCE)) { \ 
....................         y[z++] = CONTROL_ESCAPE; \ 
....................         y[z++] = x ^ XOR_BYTE; \ 
....................     } else { \ 
....................         y[z++] = x;     \ 
....................     } \ 
.................... }       
....................  
.................... // Default newtork ID of bluebox  
.................... // Somewhat arbitrary, but we will refer to 04cd blue box as center pivot number 0 
.................... //    ...which is the default listed below 
.................... #define NETWORK_ID_DEF  0x04cd                                 
....................                                                         
.................... // defines for msg_id (Manager->Mote Payload message ID to Micro) 
.................... #define MSG_MGR_ACK                       0x01 
.................... #define MSG_MGR_NACK                      0x02 
....................                                                           
.................... #define MSG_MGR_FULL_REPORT               0x10 
.................... #define MSG_MGR_HEALTH_REPORT             0x11 
.................... #define MSG_MGR_VALVE_REPORT              0x12 
....................  
.................... #define MSG_MGR_WARM_RESTART              0x20 
.................... #define MSG_MGR_COLD_RESTART              0x21 
.................... #define MSG_MGR_FORCE_REJOIN              0x22 
.................... #define MSG_MGR_SHUTDOWN                  0x23 
....................  
.................... #define MSG_MGR_UPDATE_SP_NUM             0x30 
.................... #define MSG_MGR_CAL_VALVE                 0x31 
.................... #define MSG_MGR_CAL_FSR                   0x32 
.................... #define MSG_MGR_AQUIRE_GPS                0x33 
.................... #define MSG_MGR_UPDATE_EEPROM             0x34  
.................... #define MSG_MGR_READ_EEPROM               0x35  
.................... #define MSG_MGR_READ_XDCR                 0x36 
....................  
.................... #define MSG_MGR_RUN_CMD_NO_MOD            0x40 
.................... #define MSG_MGR_RUN_CMD_MOD               0x41 
.................... #define MSG_MGR_TEST_NO_RPM_CTRL          0x42 
.................... #define MSG_MGR_TEST_RPM_CTRL             0x43 
.................... #define MSG_MGR_DEMO                      0x44 
.................... #define MSG_MGR_CLEAR_SPINKLER_CMD_QUEUE  0x45 
.................... #define MSG_MGR_FORCE_VALVE_MOVEMENT      0x46 
....................  
.................... // defines for msg_id (Micro to Mote) 
.................... #define MSG_MOTE_UNSOLICITED              0x00 
.................... #define MSG_MOTE_ACK                      0x80 
.................... #define MSG_MOTE_NACK                     0x81          
....................  
.................... #define MSG_MOTE_FULL_REPORT              0x90 
.................... #define MSG_MOTE_HEALTH_REPORT            0x91 
.................... #define MSG_MOTE_VALVE_REPORT             0x92                  
.................... #define MSG_MOTE_SPINKLER_CMD_RESPONSE    0x93 
.................... #define MSG_MOTE_JOIN_MSG                 0x94       
.................... #define MSG_MOTE_UPDATE_SP_NUM_RESPONSE   0x95 
.................... #define MSG_MOTE_GPS_POINT_MSG            0x96    
.................... #define MSG_MOTE_EEPROM_READ_RESPONSE     0x97 
.................... #define MSG_MOTE_XDCR_READ_MSG            0x98    
.................... #define MSG_MOTE_ERROR_MSG                0xA0 
....................  
....................  
.................... ////////////////////Status Defines///////////////////////////////////////////// 
.................... ////////////////////Mote Statuses (for global_mote_status) 
.................... /* From jack_dn2500.h 
.................... // Mote Status values 
.................... #define MOTESTATE_INIT           0x00     // Mote is booting. 
.................... #define MOTESTATE_IDLE           0x01     // Mote is accepting config cmds.   
....................                                           //  Upon receiving a join cmd, mote  
....................                                           //  moves into the Searching state. 
....................                                           //  Idle state is low power state. 
.................... #define MOTESTATE_SEARCHING      0x02     // Mote's rcvr is on with a  
....................                                           //  configurable duty cycle while 
....................                                           //  mote is actively searching for net.  
.................... #define MOTESTATE_NEGOTIATING    0x03     // Mote has detected a network  
....................                                           //  and is attempting to connect. 
.................... #define MOTESTATE_CONNECTED      0x04     // Mote has joined the net 
.................... #define MOTESTATE_OPERATIONAL    0x05     // Mote has links to both net mgr and 
....................                                           //  gateway; ready to send data. 
.................... #define MOTESTATE_DISCONNECTED   0x06     // Mote is disconnected. 
.................... #define MOTESTATE_RADIOTEST      0x07 
.................... #define MOTESTATE_PROMISCUOUS    0x08 
.................... #define MOTESTATE_UNKNOWN        0xFF 
.................... */ 
....................  
.................... ////////////////////System States (for global_system_state)       
.................... // system is initalizing, but not ready to run yet      
.................... #define SYSTEM_INIT                       0x00        
.................... // system is paused while sprinkling (for something like going over a waterway, for example) 
.................... //    Not sure if this needs to be used. 
.................... #define SYSTEM_PAUSE                      0x01   
.................... // system is running (sprinkling and control loop running) 
.................... #define SYSTEM_RUN                        0x02  
.................... // system is on and ready for commands, but not in the control loop (lower power)           
.................... #define SYSTEM_IDLE                       0x03        
.................... // system is sleeping (powered down?). Not sure if this needs to be used 
.................... #define SYSTEM_SLEEP                      0x04 
.................... // valve opening a little bit to ensure we dont jam into close endstop 
.................... #define SYSTEM_CAL_VLV_1                  0x10 
.................... // valve closing towards closing endstop pre-calibration 
.................... #define SYSTEM_CAL_VLV_2                  0x11 
.................... // valve opening fully from fully closed for calibration                         
.................... #define SYSTEM_CAL_VLV_3                  0x12 
.................... // doing FSR w/ valve fully open 
.................... #define SYSTEM_CAL_VLV_4                  0x13 
.................... // valve closing fully from fully open for calibration 
.................... #define SYSTEM_CAL_VLV_5                  0x14 
.................... // calibration routine is done, send message to manager and prepare system for 
.................... //    idle/run mode 
.................... #define SYSTEM_CAL_VLV_6                  0x15 
.................... // valve is moving towards one of the endstops trying to recalibrate it's position 
.................... #define SYSTEM_RECAL_VLV_MOVES            0x16 
.................... // valve is moving (outside of calibrate valve routine) 
.................... #define SYSTEM_MOVE_VALVE                 0x17 
.................... // Move valve to desired setting 
.................... #define SYSTEM_CAL_FSR_1                  0x18 
.................... // do fsr calibration 
.................... #define SYSTEM_CAL_FSR_2                  0x19 
.................... // move valve back to original position 
.................... #define SYSTEM_CAL_FSR_3                  0x1A 
.................... // fsr is done, send message to manager and restore previous state/run mode 
.................... #define SYSTEM_CAL_FSR_4 
....................  
.................... // system is searching for a network 
.................... #define SYSTEM_SEARCHING_FOR_NETWORK      0x20 
.................... // system is connecting to a network 
.................... #define SYSTEM_CONNECTING_TO_NETWORK      0x21 
.................... // ????? 
.................... #define SYSTEM_STATE_UNKNOWN              0xFF     
....................  
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////////////////////Error Defines////////////////////////////////////////////// 
.................... /////////////////////////////////////////////////////////////////////////////// 
....................  
.................... ////////////////////Deep sleep/shutdown/restart reasons/errors 
.................... // stored in global_shutdown_errors_bitfield and EEPROM and shown on screen before deep sleep 
.................... // no error 
.................... #define NO_ERR                            0x00 
.................... // mote doesn't respond after a reset 
.................... #define ERR_FAIL_ON_MOTE_RESET            0x01 
.................... // mote receives no advertisement from managers 
.................... #define ERR_NO_ADV_WHILE_SEARCHING        0x02 
.................... // mote has set it's network manager id during search succesfully 
.................... #define NEW_NETWORK_ID_SET                0x03 
.................... // mote does not respond properly to a request 
.................... #define ERR_MOTE_UNRESPONSIVE             0x04 
.................... // mote is outside of operating range (defined under dust) 
.................... #define ERR_MOTE_OUT_OF_TEMP_RANGE        0x05 
.................... // network was unable to join properly 
.................... #define ERR_NETWORK_JOIN_FAIL             0x06 
.................... // unable to set join duty on mote properly 
.................... #define ERR_MTJOINDUTY                    0x07 
.................... // unable to join network with joinkey 
.................... #define ERR_MTJOINKEY                     0x08 
.................... // warm restart requested by manager 
.................... #define WARM_RESTART_REQUEST              0x09 
.................... // cold restart requested by manager 
.................... #define COLD_RESTART_REQUEST              0x0A 
.................... // shutdown requested by manager           
.................... #define MANAGER_SHUTDOWN_REQUEST          0x0B 
.................... // battery is dead 
.................... #define ERR_BATT_DEAD_SLEEP               0x0C 
.................... // network timeout 
.................... #define ERR_NO_NETWORK_TIMEOUT            0x0D 
....................  
.................... // freshly programmed (EEPROM defaults to all F,F,F...F) 
.................... #define NEWLY_PROGRAMMED                  0xFF 
....................  
....................  
.................... ////////////////////global error bitfield errors for sending to manager 
.................... // unsolicited message not ack'd after max attempts 
.................... #define ERR_MSG_UNSOLICITED_MESSAGE_NOT_ACKD       0x00000001 
.................... // state incompatible with requested action 
.................... #define ERR_MSG_INCOMPATIBLE_STATE                 0x00000002 
.................... // valve not calibrated (so it can't move to a position) 
.................... #define ERR_MSG_VLV_NOT_CALIBRATED                 0x00000004 
.................... // mote was unresponsive in system (busy likely) 
.................... #define ERR_MSG_MOTE_UNRESPONSIVE                  0x00000008 
.................... // rpm set point is too high to reach (no charging or braking and still no go) 
.................... #define ERR_MSG_RPM_TOO_HIGH_TO_REACH              0x00000010 
.................... // rpm is too low to reach (full charging, braking and still no go) 
.................... #define ERR_MSG_RPM_TOO_LOW_TO_REACH               0x00000020 
.................... // mote temperature is out of range (sleep) 
.................... #define ERR_MSG_MOTE_TEMP_OUT_OF_RANGE             0x00000040 
.................... // battery is low (warning) 
.................... #define ERR_MSG_BATT_LOW_WARN                      0x00000080 
.................... // battery is dead (going to sleep) 
.................... #define ERR_MSG_BATT_DEAD_SLEEP                    0x00000100 
.................... // valve calibration was invalid (too short) 
.................... #define ERR_MSG_VLV_CAL_FAIL                       0x00000200 
.................... // valve hit an endstop outside of the "closing when opened" etc. areas (close to the endstops) 
.................... #define ERR_MSG_VLV_MOVE_FAIL                      0x00000400 
.................... // not spinning condition detected, recovery attempt proceeding 
.................... #define ERR_MSG_NOT_SPINNING                       0x00000800 
.................... // magnetic decoupling condition detected, recovery attempt proceeding 
.................... #define ERR_MSG_MAG_DECOUPLING                     0x00001000                      
.................... // not spinning condition or magnetic decoupling condition recovery failed (going to sleep (another message afterwards)) 
.................... #define ERR_MSG_MAG_NOT_SPIN_RECOVERY_FAILED       0x00002000 
.................... // signal that system is in invalid state to do run command (e.g. cal vlv, recal vlv, fsr) 
.................... #define ERR_MSG_SPINKLER_CMD_DELAYED_INVALID_STATE 0x00004000    
.................... // signal that the mote is going to shutdown/sleep (or with another reason) 
.................... #define ERR_MSG_MOTE_GOING_TO_DEEP_SLEEP           0x80000000 
....................  
.................... /* 
.................... // message needs to be sent now! Disregard message waiting time. 
.................... #define ERR_MSG_HIGH_PRIORITY                    0x80000000 
.................... */ 
....................  
.................... ////////////////////NACK Bitfield Errors 
....................  
.................... // valve position not calibrated 
.................... #define NACK_BITFIELD_VLV_POSITION_UNKNOWN         0x00000001 
.................... // invalid valve setting requested 
.................... #define NACK_BITFIELD_INVALID_VLV_SETTING          0x00000002 
.................... // invalid rpm setting requested 
.................... #define NACK_BITFIELD_INVALID_RPM_SETTING          0x00000004 
.................... // invalid brake pwm setting requested 
.................... #define NACK_BITFIELD_INVALID_BRAKE_SETTING        0x00000008 
.................... // invalid charge pwm setting requested 
.................... #define NACK_BITFIELD_INVALID_CHARGE_SETTING       0x00000010 
.................... // state incompatible with requested action 
.................... #define NACK_BITFIELD_INCOMPATIBLE_STATE           0x00000020 
.................... // battery is too low for requested action 
.................... #define NACK_BITFIELD_BATT_TOO_LOW                 0x00000040 
.................... // don't have the required hardware for requested operation (e.g. gps, xdcr) 
.................... #define NACK_BITFIELD_INVALID_HARDWARE             0x00000080 
.................... // info recived during eeprom update is invalid (invalid range, number of bytes) 
.................... #define NACK_BITFIELD_INVALID_EEPROM_SETTINGS      0x00000100 
.................... // invalid mppc setting requested 
.................... #define NACK_BITFIELD_INVALID_MPPC_SETTING         0x00000200 
....................  
.................... ////////////////////get and send dustmsg_ISR Errors and pkdecode errors 
.................... // Where the errors start (for checking return values in deal_with_mote) 
.................... #define ERR_BAD_PAYLOAD                   249 
.................... #define ERR_DUSTMSG_START_OF_ERRORS       250 
.................... // CRC errors in pkdecode 
.................... #define ERR_DUSTMSG_CRC                   251 
.................... // Timeout on first byte 
.................... #define ERR_DUSTMSG_TIMEOUT               252 
.................... // RS232 errors from getc() 
.................... #define ERR_DUSTMSG_RS232                 253 
.................... // Framing Error 
.................... #define ERR_DUSTMSG_FRAMING_ERROR         254 
.................... // Message < 6 bytes (too short) 
.................... #define ERR_DUSTMSG_MESSAGE_LENGTH        255 
....................  
....................  
.................... #include "function_headers.h"                   
.................... //pic.h 
.................... void fosc_pri(void); 
.................... void fosc_pri_ISR(void); 
.................... void fosc_4m(void); 
.................... void fosc_1m(void); 
.................... void fosc_250k(void); 
.................... void fosc_250k_ISR(void); 
.................... void fosc_31250(void);  
.................... void fosc_31250_ISR(void);  
.................... void fosc_sec(void); 
.................... void osc_init(void); 
.................... void setup_T0_int(uint16_t value); 
.................... void setup_T2_int(uint8_t value); 
.................... void setup_T4_int(uint8_t value); 
.................... void periph_init(void); 
.................... void vars_init(void);      
.................... void deep_sleep(); 
.................... void start_rtc(void); 
.................... void safeI2C_start(void); 
.................... void safeI2C_write(uint8_t value);  
.................... void setup_rb4_int(void);                                   
.................... void write_system_state(uint8_t system_state_to_change_to);  
.................... uint8_t read_system_state(void);  
....................                                                               
.................... //eeprom.h 
.................... uint8_t read_ee1(uint16_t source); 
.................... uint16_t read_ee2(uint16_t source); 
.................... uint32_t read_ee4(uint16_t source); 
.................... void write_ee1(uint16_t dest, uint8_t dat8); 
.................... void write_ee2(uint16_t dest, uint16_t dat16); 
.................... void write_ee4(uint16_t dest, uint32_t dat32); 
.................... void store_all_eeprom_values(void);   
.................... void read_all_eeprom_values(void);                   
.................... void store_vcal_eeprom_values(void);   
.................... void read_all_eeprom_variables(void);                               
....................  
.................... //periph.h (LCD + XDCR) 
.................... //LCD declerations 
.................... void LCD_init(void); 
.................... void LCD_line1(unsigned char *text); 
.................... void LCD_line2(unsigned char *text); 
.................... void LCD_place_text(unsigned char *text, int1 row, uint8_t col, uint8_t length); 
.................... void LCD_place_char(char ascii, int1 row, uint8_t col); 
.................... void LCD_place_uint8(uint8_t num, int1 row, uint8_t col, uint8_t length); 
.................... void LCD_place_uint16(uint16_t num, int1 row, uint8_t col, uint8_t length); 
.................... void LCD_place_uint32(uint32_t num, int1 row, uint8_t col, uint8_t length); 
.................... void LCD_clear(void); 
.................... void LCD_clear_line1(void); 
.................... void LCD_clear_line2(void); 
.................... void LCD_position(int position); 
.................... void LCD_char(char ascii); 
.................... void LCD_shutdown(void); 
.................... void LCD_startup_splash(void); 
.................... void LCD_display_priority_time_stacks(void); 
.................... void LCD_display_priority_time_stacks_2(void); 
.................... void LCD_display_priority_queue(void);    
.................... void LCD_display_message_queue(void);  
.................... void LCD_display_battery_voltage(int1 lcd_line); 
.................... void LCD_display_batt_voltage(int1 lcd_line, uint8_t col, uint8_t precision); 
.................... void LCD_display_vgen(int1 lcd_line, uint8_t col, uint8_t precision); 
.................... void LCD_update_diplay(void);      
.................... void XDCR_init(void);   
.................... void adc_XDCR_init(void); 
.................... uint16_t XDCR_measure(void);  
.................... uint16_t adc_XDCR_measure(void);     
.................... void fixture_init(void); 
....................  
.................... //dust.h 
.................... void mote_init(void); 
.................... void mote_reset(void); 
.................... uint8_t mote_sleep(void); 
.................... void search_for_strongest(void); 
.................... void process_advert(void); 
.................... uint8_t initiate_join(void); 
.................... void mote_state_check(void); 
.................... void mote_temp_check(void); 
.................... void mote_time_update(void); 
.................... void init_msgSEQ(void); 
.................... void deal_with_mote_ISR(void); 
.................... uint8_t get_dustmsg_ISR(void); 
.................... void  dust_hdlc_pkgen(uint8_t* prefix, uint8_t size, uint8_t* buf, uint8_t size_buf); 
.................... void  dust_hdlc_pkgen_ISR(uint8_t* prefix, uint8_t size, uint8_t* buf, uint8_t size_buf); 
.................... uint8_t dust_hdlc_pksend(); 
.................... uint8_t dust_hdlc_pksend_ISR(); 
.................... uint8_t dust_hdlc_pkdecode_ISR(uint8_t bytes_to_decode); 
.................... uint16_t fcs_fcs16(uint16_t fcs, uint8_t data); 
.................... uint16_t fcs_fcs16_ISR(uint16_t fcs, uint8_t data); 
.................... static uint16_t fcs_calc(uint8_t* p, uint16_t size); 
.................... static uint16_t fcs_calc_ISR(uint8_t* p, uint16_t size); 
.................... uint8_t deal_with_packet(void); 
.................... void prepare_prefix_and_payload(uint8_t payload_buf_length); 
.................... void prepare_prefix_and_payload_ISR(uint8_t payload_buf_length); 
.................... void generate_message_and_send(); 
.................... void generate_message_and_send_ISR(); 
.................... void send_full_report(uint8_t command_id_in_response_to, uint16_t msg_seq); 
.................... void send_health_report(uint8_t command_id_in_response_to, uint16_t msg_seq); 
.................... void send_valve_report(uint8_t command_id_in_response_to, uint16_t msg_seq); 
.................... void send_sprinkler_cmd_response(uint8_t command_id_in_response_to, uint16_t msg_seq); 
.................... void send_update_sp_num_response(uint8_t command_id_in_response_to, uint16_t msg_seq); 
.................... void send_read_eeprom_response(uint8_t command_id_in_response_to, uint16_t msg_seq, uint16_t eeprom_location, uint32_t eeprom_data);  
.................... void send_pressure_xdcr_msg(uint8_t command_id_in_response_to, uint16_t msg_seq);  
.................... void send_pressure_xdcr_msg_ISR(uint8_t command_id_in_response_to, uint16_t msg_seq);  
.................... void send_ack(uint8_t command_id_in_response_to, uint16_t msg_seq); 
.................... void send_nack(uint8_t command_id_in_response_to, uint16_t msg_seq, uint32_t nack_bitfield); 
.................... void send_health_report_ISR(uint8_t command_id_in_response_to, uint16_t msg_seq); 
.................... void send_valve_report_ISR(uint8_t command_id_in_response_to, uint16_t msg_seq); 
.................... void send_join_msg_ISR(uint8_t command_id_in_response_to, uint16_t msg_seq); 
.................... void send_gps_point_msg_ISR(uint8_t command_id_in_response_to, uint16_t msg_seq); 
.................... void send_error_msg_ISR(uint8_t command_id_in_response_to, uint16_t msg_seq); 
....................  
.................... //util.h 
.................... void flash_leds(uint8_t num_of_flashes); 
.................... void flash_leds_ISR(uint8_t num_of_flashes); 
.................... void happy_lites(void); 
.................... char *word_to_4dig_new (uint16_t xword); 
.................... uint16_t convert_rpm_to_period(uint16_t rpm); 
.................... uint16_t convert_period_to_rpm(uint16_t period); 
.................... uint16_t convert_period_to_rpm_ISR(uint16_t period); 
.................... uint8_t  hi2asc(uint8_t xbyte); 
.................... uint8_t  lo2asc(uint8_t xbyte); 
....................  
.................... //stacks_queues.h 
.................... void clear_priority_queue(); 
.................... uint8_t pop_priority_queue(); 
.................... int1 push_priority_queue(uint8_t new_priority_queue_item); 
.................... void push_priority_queue_ISR(uint8_t new_priority_queue_item); 
.................... void push_priority_queue_ISR2(uint8_t new_priority_queue_item); 
.................... void clear_time_queue(); 
.................... int1 pop_time_queue();  
.................... void pop_time_queue_ISR(); 
.................... int1 push_time_queue(uint32_t time_to_execute, uint8_t priority); 
.................... void push_time_queue_ISR(uint32_t time_to_execute, uint8_t priority); 
.................... void allocate_command_queue(void); 
.................... void clear_command_queue(void); 
.................... int1 push_command_queue(struct CommandQueueItem new_command_queue_item); 
.................... void clear_message_queue(void); 
.................... void clear_sprinkler_queue(void); 
.................... void push_sprinkler_queue(uint32_t start_time,uint32_t end_time,uint16_t vlv_open_amount,uint16_t spin_rate,uint8_t zone_num, uint8_t control_loop_mechanism); 
.................... void pop_sprinkler_queue_ISR(void); 
.................... void pop_message_queue_and_send_ISR(void); 
.................... void push_message_queue(uint8_t message_type); 
.................... void push_message_queue_ISR(uint8_t message_type); 
.................... void remove_message_queue_item(uint16_t msg_seq); 
.................... void remove_message_queue_item_ISR(uint16_t msg_seq); 
....................                                              
.................... //control.h 
.................... void setup_gen_rpm(void); 
.................... uint16_t calc_gen_rpm(void);                           
.................... int1  is_brake_duty_valid(uint16_t value); 
.................... int1  is_charge_duty_valid(uint16_t value); 
.................... int1  is_mppc_valid(uint8_t value); 
.................... int1  is_rpm_setting_valid(uint16_t value); 
.................... void set_brake_duty(uint16_t value); 
.................... void set_charge_duty(uint16_t value);                                  
.................... void set_mppc(uint8_t value); 
.................... void set_fixture_dac(uint16_t dac_value); 
.................... void adjust_brake_for_rpm(uint16_t rpm_set_value); 
.................... void adjust_brake_for_vgen(uint16_t vgen_set_value); 
.................... void adjust_fixture_for_rpm(uint16_t fixture_set_value); 
.................... void setup_control_update_speed_vgen(); 
.................... void adjust_mppc(void);        
.................... void update_control_loop(void); 
.................... void stop_current_spinkler_setting(void); 
.................... void stop_current_spinkler_setting_ISR(void); 
....................  
.................... //battery.h 
.................... uint16_t get_vgen(int1 charge_state); 
.................... uint16_t get_vbatt(int1 charge_state); 
.................... uint16_t get_vbatt_ISR(int1 charge_state); 
.................... uint32_t calc_vbatt(uint16_t vref_count); 
.................... uint16_t calc_vbatt_BCD(uint16_t vref_count); 
.................... uint16_t calc_vgen_BCD(uint16_t vref_count); 
.................... void check_and_deal_with_battery(void); 
....................  
.................... //valve.h 
.................... void  cl_valve(void); 
.................... void  op_valve(void); 
.................... void  cl_valve_timed(uint32_t num_ints); 
.................... void  op_valve_timed(uint32_t num_ints); 
.................... void  comparator_setup(void); 
.................... uint16_t calc_valve_movement_time(uint16_t current_location, uint16_t destination); 
.................... void  set_comp_dac_level(void); 
.................... void  set_comp_dac_level_ISR(void); 
.................... int1  is_valve_position_valid(uint16_t value); 
.................... int1  is_valve_value_full_open_or_close(uint16_t value); 
....................  
.................... #include "jack_dn2500.h" 
.................... /* 
....................  * $HeadURL: https://svn/appeng/trunk/dev/src/api/dust_dn2500.h $ 
....................  * $Id: dust_dn2500.h 261 2010-02-19 23:34:29Z kottaway $ 
....................  * 
....................  * Copyright (c) 2006, Dust Networks, Inc 
....................  * All rights reserved. 
....................  * Redistribution and use in source and binary forms, with or without 
....................  * modification, are permitted provided that the following conditions are met: 
....................  * 
....................  *     * Redistributions of source code must retain the above copyright 
....................  *       notice, this list of conditions and the following disclaimer. 
....................  *     * Redistributions in binary form must reproduce the above copyright 
....................  *       notice, this list of conditions and the following disclaimer in the 
....................  *       documentation and/or other materials provided with the distribution. 
....................  *     * Neither the name of Dust Networks, Inc nor the 
....................  *       names of its contributors may be used to endorse or promote products 
....................  *       derived from this software without specific prior written permission. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED BY DUST NETWORKS, INC AND CONTRIBUTORS "AS IS" AND ANY 
....................  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
....................  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
....................  * DISCLAIMED. IN NO EVENT SHALL DUST NETWORKS, INC AND CONTRIBUTORS BE LIABLE FOR ANY 
....................  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
....................  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
....................  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND 
....................  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
....................  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
....................  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  
....................  * 
....................  * This documentation might include technical inaccuracies or other errors.  
....................  * Corrections and improvements might be incorporated in new versions of the  
....................  * documentation. Dust Networks does not assume any liability arising out of  
....................  * the application or use of any products or services and specifically disclaims  
....................  * any and all liability, including without limitation consequential or incidental damages. 
....................  * 
....................  *  
....................  * 
....................  * Dust Networks reserves the right to make corrections, modifications, enhancements, 
....................  * improvements, and other changes to its products or services at any time and to  
....................  * discontinue any product or service without notice. Customers should obtain the  
....................  * latest relevant information before usage and should verify that such information  
....................  * is current and complete. 
....................  */ 
....................   
....................  // NOTE THAT THIS FILE WAS UPDATED TO INCLUDE THE SEARCH capability 
....................  //  now included in the Eterna parts (JG June 2013) 
....................  
.................... /* Max user data size.  This limit is specific to the  
....................  * amount of data that can be sent via radio to/from the Manager. 
....................  * This is not an HDLC limit which might include byte stuffing. 
....................  */ 
.................... #define MAX_USER_DATA_SIZE       94 
....................  
.................... // prior to encoding for transmission 
.................... // cmd(1), len_pkt(1), flags(1), destaddr(2), svc_index(1), appdomain(1), 
.................... // priority(1), reserved(2), sequence_num(1), len_data(1), MAX_USER_DATA_SIZE 
.................... #define MAX_SEND_REQUEST         MAX_USER_DATA_SIZE + 12 
....................  
.................... // include now the delimiters (2), the FCS (w/ byte stuffing could be 4), 
.................... //  of the 12 bytes added above, there may be an extra 2 due to byte stuffing 
.................... //  and the message can be MAX_USER_DATA_SIZE*2 worst case! 
.................... #define MAX_SEND_BUFFER          MAX_USER_DATA_SIZE*2 + 2 + 4 + 12 + 2 
.................... // This adds up to 208! 
....................  
.................... // after decoding the received message 
.................... // cmd(1), len_pkt(1), flags(1), sourceaddr(2), sequence_num(1), len_data(1),  
.................... // MAX_USER_DATA_SIZE 
.................... #define MAX_DATA_RCVD            MAX_USER_DATA_SIZE + 7 
....................  
.................... // prior to decoding, raw rcv data 
.................... // include delimiters (2), the FCS (4 max), of the 7 bytes above there may be 
.................... //  an extra stuffed byte, and the message can be MAX_USER_DATA_SIZE*2! 
.................... #define MAX_RCV_BUFFER           MAX_USER_DATA_SIZE*2 + 2 + 4 + 7 + 1 
.................... // This adds up to 202 
....................   
.................... #define MAX_JOINKEY_SIZE         16 
....................  
.................... #define MAX_BURST_MESSAGE        3 
....................  
.................... #define DESTADDR_GATEWAY         0xF981 
.................... #define DESTADDR_SWAPPED         0x81F9 
.................... #define DESTADDR_HI              0xF9 
.................... #define DESTADDR_LO              0x81 
....................  
.................... // Microprocessor to Mote Commands 
.................... #define CMD_SET            0x01     // Sets param on the mote. 
.................... #define CMD_GET            0x02     // Gets param from mote 
.................... #define CMD_SETNV          0x03     // Stores param in the motes NV 
.................... #define CMD_GETNV          0x04     // Retrieves param from the motes NV 
.................... #define CMD_SEND           0x05     // Packet destined for the network. 
.................... #define CMD_JOIN           0x06     // Requests that mote attempt to join 
.................... #define CMD_DISCONNECT     0x07     // Requests that mote disconnect 
.................... #define CMD_RESET          0x08     // Resets mote. 
.................... #define CMD_SLEEP          0x09     // Shuts down periphs & puts mote to sleep 
.................... #define CMD_TESTRADIOTX    0x0B     // Initiate a series of packet transmissions. 
.................... #define CMD_TESTRADIORX    0x0C     // Test radio reception for a specified chan. 
.................... #define CMD_CLEARNV        0x10     // Resets the motes NV to factory default.. 
.................... #define CMD_SEARCH         0x11     // new Search for networks capability 
....................                                     // (Eterna parts) 
....................  
.................... // Mote to Microprocessor Commands 
.................... #define CMD_TIME           0x0D     // Time and mote state information. 
.................... #define CMD_SERVICE        0x0E     // Notifies micro of changes in service stat. 
.................... #define CMD_EVENT          0x0F     // Notifies micro of new has occurred. 
.................... #define CMD_ADVERT         0x12     // Notifies micro that an adv has been rcvd. 
.................... #define CMD_DATA           0x81     // Packet from the network to the micro. 
....................  
....................  
.................... // Result Codes 
.................... #define RC_OK              0x00     // Operation was successfully completed. 
.................... #define RC_EXE_ERR         0x01     // Reserved. 
.................... #define RC_PARAM_ERR       0x02     // Reserved. 
.................... #define RC_BUSY            0x03     // Operation on this service is in progress. 
.................... #define RC_INVALID_LEN     0x04     // Invalid packet length. 
.................... #define RC_INV_STATE       0x05     // Invalid mote state for command. 
.................... #define RC_UNSUPPORTED     0x06     // Command not supported for hardware. 
.................... #define RC_UNKNOWN_PARAM   0x07     // Unknown parameter value. 
.................... #define RC_UNKNOWN_CMD     0x08     // Unknown command. 
.................... #define RC_WRITE_FAIL      0x09     // Write failure. 
.................... #define RC_READ_FAIL       0x0A     // Read failure. 
.................... #define RC_LOW_VOLTAGE     0x0B     // Voltage check failed. 
.................... #define RC_NO_RESOURCES    0x0C     // No resources (max # services active) 
.................... #define RC_INCOMPLETE_JOIN 0x0D     // Incomplete join information. 
.................... #define RC_NOT_FOUND       0x0E     // Parameter not found. 
.................... #define RC_INVALID_VALUE   0x0F     // Invalid value. 
....................  
....................  
.................... // Parameter Types 
.................... #define PARAM_MACADDR      0x01     // setNV, getNV 
.................... #define PARAM_JOINKEY      0x02     // setNV 
.................... #define PARAM_NETWORKID    0x03     // setNV, getNV 
.................... #define PARAM_TXPOWER      0x04     // set, setNV, getNV 
.................... #define PARAM_POWERINFO    0x05     // setNV, getNV 
.................... #define PARAM_JOINDUTY     0x06     // set 
....................                                     // Allows micro to control  ratio of listen 
....................                                     //  to sleep time during network search 
.................... #define PARAM_BATTLIFE     0x07     // set 
....................                                     // Allows micro to update the remaining  
....................                                     //  battery life that mote reports to mgr 
.................... #define PARAM_SERVICE      0x08     // set. get  
....................                                     // Allows device to initiate service request 
....................                                     //  or update an existing svc 
.................... #define PARAM_SPECIAL1     0x08     // setnv for special join timing, 1st param 
.................... #define PARAM_SPECIAL2     0x09     // setnv for special join timing, 2nd param 
.................... #define PARAM_EVENTMASK    0x0B     // set 
....................                                     // Allows micro to disable events that may  
....................                                     //  be sent in the mote's event notification 
.................... #define PARAM_MOTEINFO     0x0C     // get 
....................                                     // Gets static info about mote hw and sw 
.................... #define PARAM_NETWORKINFO  0x0D     // get 
....................                                     // Gets mote's current net-related params 
.................... #define PARAM_MOTESTATUS   0x0E     // get 
....................                                     // Gets  mote's state and  
....................                                     //  frequently changing information. 
.................... #define PARAM_TIME         0x0F     // get 
.................... #define PARAM_CHARGE       0x10     // get 
....................                                     // Gets  mote's charge consumption. 
.................... #define PARAM_RADIOSTATSRX 0x11     // get 
....................                                     // Gets results of the mote radio rx test 
.................... #define PARAM_TTL          0x13     // get 
....................                                     // Gets "time to live" 
.................... #define PARAM_OTAPLOCK     0x15     // setNV, getNV 
....................                                     // Over-the-air-programming lockout control 
....................  
....................  
.................... // re get service: Service State - note Bit7=0 for no service pending 
.................... //                                          Bit7=1 for service pending 
.................... #define SVCSTATE_INACTIVE        0x00 
.................... #define SVCSTATE_ACTIVE          0x01 
.................... #define SVCSTATE_REQUESTED       0x02 
....................  
.................... // re get/set service: Service Request Flags Bitmask Values 
.................... #define SVCFLAGS_SOURCE          0x01     // Mote is source of data generated. 
.................... #define SVCFLAGS_SINK            0x02     // Mote is receiver of data. 
.................... #define SVCFLAGS_INTERMITTENT    0x04     // Intermittent traffic  
....................                                           //  (as opposed to regular reporting). 
....................  
.................... // Application domain values 
.................... #define APPDOMAIN_PUBLISH        0x00 
.................... #define APPDOMAIN_EVENT          0x01  
.................... #define APPDOMAIN_MAINTENANCE    0x02  
.................... #define APPDOMAIN_BLOCKXFER      0x03 
....................  
.................... // Mote Status values 
.................... #define MOTESTATE_INIT           0x00     // Mote is  booting. 
.................... #define MOTESTATE_IDLE           0x01     // Mote is accepting config cmds.   
....................                                           //  Upon receiving a join cmd, mote  
....................                                           //  moves into the Searching state. 
....................                                           //  Idle state is low power state. 
.................... #define MOTESTATE_SEARCHING      0x02     // Motes rcvr is on with a  
....................                                           //  configurable duty cycle while 
....................                                           //  mote is actively searching for net.  
.................... #define MOTESTATE_NEGOTIATING    0x03     // Mote has detected a network  
....................                                           //  and is attempting to connect. 
.................... #define MOTESTATE_CONNECTED      0x04     // Mote has joined the net 
.................... #define MOTESTATE_OPERATIONAL    0x05     // Mote has links to both net mgr and 
....................                                           //  gateway; ready to send data. 
.................... #define MOTESTATE_DISCONNECTED   0x06     // Mote is disconnected. 
.................... #define MOTESTATE_RADIOTEST      0x07 
.................... #define MOTESTATE_PROMISCUOUS    0x08 
.................... #define MOTESTATE_UNKNOWN        0xFF 
....................  
.................... // mote alarms bit masks 
.................... #define ALARMS_NVERROR           0x01        // Non-volatile error. 
.................... #define ALARMS_LOW_VOLTAGE       0x02        // Mote voltage too low. 
.................... #define ALARMS_OTP               0x04        // One time programmable error 
....................  
....................  
.................... // re get POWERINFO: power source values 
.................... #define PWRSOURCE_LINE           0x00 
.................... #define PWRSOURCE_BATTERY        0x01 
.................... #define PWRSOURCE_SCAVENGE       0x02 
....................  
.................... // re set/get txpower 
.................... #define TXPOWER_MIN              -2       // minimum power; PA off*/ 
.................... #define TXPOWER_MAX              +8       // maximum power; PA on 
....................  
.................... // serviceIndication event codes 
.................... #define SVC_CREATED_UPDATED      0x00 
.................... #define SVC_DELETED              0x01 
.................... #define SVC_REJECTED             0x02 
.................... #define SVC_DELAYED_RESP         0x03 
....................  
.................... // serviceIndication Network Manager Codes 
.................... #define MGRCODE_SUCCESS             0     // no errors 
.................... #define MGRCODE_PARAM_TOOSMALL      4     // ERR: passed param too small 
.................... #define MGRCODE_BYTES_TOOFEW        5     // ERR: too few data bytes rcvd 
.................... #define MGRCODE_DEVICE_ERR          6     // ERR: device-specific cmd error 
.................... #define MGRCODE_SETNEAREST          8     // WARN: set to nearest possible val 
.................... #define MGRCODE_RESTRICTED          16    // ERR: access restricted 
.................... #define MGRCODE_BUSY                32    // ERR: network manager is busy  
.................... #define MGRCODE_DELAYED_ATTEMPT     33    // ERR: delayed response initiated 
....................                                           //      mgr will attempt to add links 
.................... #define MGRCODE_DENIED              65    // ERR: service request denied 
.................... #define MGRCODE_UNKNOWN_SVC         66    // ERR: unknown service flag 
.................... #define MGRCODE_UNKNOWN_APPDOMAIN   67    // ERR: unknown application domain 
.................... #define MGRCODE_UNKNOWN_NICKNAME    68    // ERR: unknown nickname 
....................  
.................... // re set batteryLife 
.................... #define PWRSTAT_NOMINAL             0x00 
.................... #define PWRSTAT_LOW                 0x01 
.................... #define PWRSTAT_CRIT_LOW            0x02 
.................... #define PWRSTAT_RECHARG_LOW         0x03 
.................... #define PWRSTAT_RECHARG_HIGH        0x04 
....................  
.................... #define BOOT_EVENT               0x01010101  // & with new_events_rcvd to 
....................                                              //  determine if boot event 
....................                                              //  occurred 
.................... #define ALARMS_EVENT             0x02020202 
.................... #define TIME_EVENT               0x04040404  // & with new_events_rcvd to 
....................                                              //  determine if UTC time ref 
....................                                              //  from mote has changed 
.................... #define JOIN_FAIL_EVENT          0x08080808 
.................... #define DISCONNECTED_EVENT       0x10101010 
.................... #define OPERATIONAL_EVENT        0x20202020  // mote has gateway to send data 
.................... #define CONFIG_EVENT             0x40404040 
....................  
....................  
.................... // EVENTMASK bit definitions 
.................... #define EVENTMASK_BOOT           0x01        // Mote booted up. 
.................... #define EVENTMASK_ALARMS         0x02        // Value of alarms field changed. 
.................... #define EVENTMASK_TIMECHANGE     0x04        // UTC time reference changed.     
.................... #define EVENTMASK_JOINFAIL       0x08        // Join operation failed. 
.................... #define EVENTMASK_DISCONNECT     0x10        // Mote has disconnected. 
.................... #define EVENTMASK_OPERATIONAL    0x20        // Mote has gateway to send data. 
.................... #define EVENTMASK_CONFIG         0x40        // Write has changed mote config. 
....................  
.................... //  
.................... // #define WRITEPROTECT_DISABLED    0x0         // bit 0 only 
.................... // #define WRITEPROTECT_ENABLED     0x1         // bit 0 only 
.................... // #define WRITEPROTECT_MASK        0x1 
....................  
.................... // FLAG bit masks & defines 
.................... //#define FLAG_TYPE_MASK          0x01 
.................... #define FLAG_TYPE_REQUEST           0x04     // from micro to mote re get/set 
....................                                              //  and re join, reset, etc 
.................... #define FLAG_TYPE_REQUEST2          0x05 
.................... #define FLAG_SEND_REQUEST           0x04     // from micro to mote with send 
....................                                              //  request only 
.................... #define FLAG_TYPE_TEST              0x00     // from micro to mote re 
....................                                              //  testradiorx and testradiotx 
.................... #define FLAG_MOTE_INDICATION        0x00     // from mote to micro re 
....................                                              //  indications: event, service, 
....................                                              //  time 
.................... #define FLAG_TYPE_RESPONSE          0x01 
.................... #define FLAG_MOTECMD_RESPONSE       0x05     // from mote to micro after 
....................                                              //  micro-initiated command 
....................                                              //  e.g. join, reset, send 
.................... #define FLAG_MICROIND_RESPONSE      0x05     // from micro to mote after 
....................                                              //  mote indication to micro 
....................                                              //  time/service/event/data 
.................... #define FLAG_SET_RESPONSE           0x05     // from mote to micro after set 
.................... #define FLAG_GET_RESPONSE           0x05     // from mote to micro after get 
....................                                              //  TEST THIS 
....................  
.................... #define FLAG_ID                     0x02 
.................... #define FLAG_ID_IGNORE              0x04 
.................... #define FLAG_END2END_RESPONSE       0x80 
.................... #define FLAG_TRANSPORT_TYPE_MASK    0x40 
....................  
....................  
.................... #define FLAG_NV_ONLY                   ~0x80 
.................... #define FLAG_NV_RAM                    0x80 
....................  
....................  
.................... // #define WRITE_PROTECT_MODE_OFF     0x00 // write allowed 
.................... // #define WRITE_PROTECT_MODE_ON      0x01 // write not allowed 
....................  
.................... // packet priorities 
.................... #define PRIORITY_LOW    0x00 
.................... #define PRIORITY_MED    0x01 
.................... #define PRIORITY_HI     0x02 
....................  
.................... // Pack on one byte boundaries because we "type cast" the data structures 
.................... //  to a destination buffer (array of bytes). 
....................  
.................... /*  
.................... //Structure Declarations 
.................... #define DUST_DN2500_HEADER  \ 
....................     uint8_t cmd;     \ 
....................     uint8_t len_pkt; \ 
....................     uint8_t flags; 
....................  
....................  
.................... // A structure defined like this represents the first 4 bytes of  
.................... //  send, join, disconnect, reset, sleep, testradioTX/RX, clearNV  
.................... //  (cmd types 5,6,7,8,9,B,C,10) 
.................... #define DUST_DN2500_HEADER_RESPONSE    \ 
....................     uint8_t cmd;     \ 
....................     uint8_t len_pkt; \ 
....................     uint8_t flags;   \ 
....................     uint8_t result; 
....................      
.................... // A structure defined like this represents the first 4 bytes of all  
.................... //  set, get, setNV, getNV responses (cmd types 1,2,3,4) 
.................... #define DUST_DN2500_PARAM_RESPONSE  \ 
....................     uint8_t cmd;     \ 
....................     uint8_t len_pkt; \ 
....................     uint8_t flags;   \ 
....................     uint8_t result;  \ 
....................     uint8_t parameter_type;        /* DUST_DN2500_CMD_[SET|GET]_PARAM_*  
.................... */ 
....................  
.................... typedef union _mote_to_micro 
.................... // cmd types 1,2,3,4;  5,6,7,8,9,B,C,10;  D,E,F,81 
.................... // get/set; send/join/discon/reset/sleep/testradio/clrNV;  time/svc/event/data  
.................... { 
....................    char      dust_rcvd[MAX_DATA_RCVD];    // THIS is the buffer for unstuffed 
....................                                           //  stripped received data 
....................    struct _set_param_response 
....................    // for set txPower, joinDutyCycle, batteryLife, eventMask 
....................    // for setNV macAddress, networkID, txPower, joinKey, powerInfo, OTAPlockout 
....................    //  and special1 and special2 
....................    // Mote response to micro after most set and setNV commands 
....................    { 
....................       uint8_t     cmd;                 // CMD_SET or CMD_SETNV 
....................       uint8_t     len_pkt;             // always 0x01   
....................       uint8_t     flags;               // expect FLAG_SET_RESPONSE 
....................       uint8_t     result;              // RC_* 
....................       uint8_t     param_type;          // PARAM_TXPOWER, PARAM_JOINTDUY, (set) 
....................                                        // PARAM_BATTLIFE, PARAM_EVENTMASK (set) 
....................                                        // PARAM_MACADDR, PARAM_NETWORKID, (setNV) 
....................                                        // PARAM_TXPOWER, PARAM_JOINKEY, (setNV)  
....................                                        // PARAM_POWERINFO, PARAM_OTAPLOCK (setNV) 
....................                                        // PARAM_SPECIAL1, PARAM_SPECIAL2 
....................    }  set_param_response; 
....................     
....................    struct _set_service_response 
....................    // Mote respnse to micro after set service ONLY 
....................    { 
....................       uint8_t     cmd;                 // CMD_SET 
....................       uint8_t     len_pkt;             // always 0x02 
....................       uint8_t     flags;               // expect FLAG_SET_RESPONSE 
....................       uint8_t     result;              // RC_* 
....................       uint8_t     param_type;          // PARAM_SERVICE 
....................       uint8_t     rem_svc_entries; 
....................    }  set_service_response; 
....................     
....................     struct _get_service_response  
....................    { 
....................       uint8_t     cmd;                 // CMD_GET 
....................       uint8_t     len_pkt;             // always 0x0B 
....................       uint8_t     flags;               // expect FLAG_GET_RESPONSE 
....................       uint8_t     result;              // RC_* 
....................       uint8_t     param_type;          // PARAM_SERVICE 
....................       uint8_t     svc_index; 
....................       uint8_t     svc_state;           // SVCSTATE_* 
....................       uint8_t     svc_flags;           // SVCRQST_* 
....................       uint8_t     app_domain;          // APPDOMAIN_* 
....................       uint16_t    destaddr;            // always 0xF981 
....................       uint32_t    time;                // Period/latency: intermittent flag set 
....................    } get_service_response; 
....................     
....................    struct _get_moteinfo_response  
....................    { 
....................       uint8_t     cmd;                 // CMD_GET 
....................       uint8_t     len_pkt;             // always 0x11 
....................       uint8_t     flags;               // expect FLAG_GET_RESPONSE 
....................       uint8_t     result;              // RC_* 
....................       uint8_t     param_type;          // PARAM_MOTEINFO 
....................       uint8_t     api_version; 
....................       uint8_t     serial_number[8]; 
....................       uint8_t     hw_model; 
....................       uint8_t     hw_version; 
....................       uint8_t     sw_major_ver; 
....................       uint8_t     sw_minor_ver; 
....................       uint8_t     sw_patch; 
....................       uint16_t    sw_build; 
....................    }  get_moteinfo_response; 
....................  
....................    struct _get_networkinfo_response 
....................    { 
....................       uint8_t     cmd;                 // CMD_GET 
....................       uint8_t     len_pkt;             // always 0x0D 
....................       uint8_t     flags;               // expect FLAG_GET_RESPONSE 
....................       uint8_t     result;              // RC_* 
....................       uint8_t     param_type;          // PARAM_NETWORKINFO 
....................       uint8_t     macaddr[8]; 
....................       uint16_t    mote_id; 
....................       uint16_t    network_id; 
....................    }  get_networkinfo_response; 
....................  
....................    struct _get_motestatus_response 
....................    { 
....................       uint8_t     cmd;                 // CMD_GET 
....................       uint8_t     len_pkt;             // always 0x0B 
....................       uint8_t     flags;               // expect FLAG_GET_RESPONSE 
....................       uint8_t     result;              // RC_* 
....................       uint8_t     param_type;          // PARAM_MOTESTATUS 
....................       uint8_t     mote_state;          // MOTESTATE_* 
....................       uint8_t     mote_state_reason;   // Reserved -- ignore 
....................       uint16_t    change_counter; 
....................       uint8_t     number_of_parents; 
....................       uint32_t    mote_alarms;         // ALARMS_* 
....................       uint8_t     reserved; 
....................    }  get_motestatus_response; 
....................  
....................    struct _get_time_response 
....................    { 
....................       uint8_t     cmd;                 // CMD_GET 
....................       uint8_t     len_pkt;             // always 0x10 
....................       uint8_t     flags;               // expect FLAG_GET_RESPONSE 
....................       uint8_t     result;              // RC_* 
....................       uint8_t     param_type;          // PARAM_TIME 
....................       uint32_t    utc_sec; 
....................       uint32_t    utc_usec; 
....................       uint8_t     asn[5];              // Absolute Slot No. (10msec slots since 
....................                                        //  boot). 
....................       uint16_t    asn_offset;          // usec into current slot number  
....................    }  get_time_response; 
....................     
....................    struct _get_charge_response 
....................    { 
....................       uint8_t     cmd;                 // CMD_GET 
....................       uint8_t     len_pkt;             // always 0x0B 
....................       uint8_t     flags;               // expect FLAG_GET_RESPONSE 
....................       uint8_t     result;              // RC_* 
....................       uint8_t     param_type;          // PARAM_CHARGE 
....................       uint32_t    charge_mC;           // charge since last reset 
....................       uint32_t    uptime_sec;          // uptime since last reset 
....................       int8_t      temp_celsius; 
....................       uint8_t     temp_frac_celsius;   // Temperature in 1/255 of Celsius 
....................    }  get_charge_response; 
....................     
....................    struct _get_testrx_response 
....................    { 
....................       uint8_t     cmd;                 // CMD_GET 
....................       uint8_t     len_pkt;             // always 0x05 
....................       uint8_t     flags;               // expect FLAG_GET_RESPONSE 
....................       uint8_t     result;              // RC_* 
....................       uint8_t     param_type;          // PARAM_RADIOSTATSRX 
....................       uint16_t    num_of_received_packets; 
....................       uint16_t    num_of_recep_failures; 
....................    }  get_testrx_response; 
....................   
....................    struct _getNV_macaddr_response 
....................    { 
....................       uint8_t     cmd;                 // CMD_GETNV 
....................       uint8_t     len_pkt;             // always 0x09 
....................       uint8_t     flags;               // expect FLAG_GET_RESPONSE 
....................       uint8_t     result;              // RC_* 
....................       uint8_t     param_type;          // PARAM_MACADDR 
....................       uint8_t     macaddr[8]; 
....................    }  getNV_macaddr_response; 
....................     
....................    struct _getNV_networkid_response 
....................    { 
....................       uint8_t     cmd;                 // CMD_GETNV 
....................       uint8_t     len_pkt;             // always 0x03 
....................       uint8_t     flags;               // expect FLAG_GET_RESPONSE 
....................       uint8_t     result;              // RC_NETWORKID 
....................       uint8_t     param_type;          // PARAM_NETWORKID 
....................       uint16_t    network_id; 
....................    }  getNV_networkid_response; 
....................     
....................    struct _getNV_txpower_response 
....................    { 
....................       uint8_t     cmd;                 // CMD_GETNV 
....................       uint8_t     len_pkt;             // always 0x02 
....................       uint8_t     flags;               // expect FLAG_GET_RESPONSE 
....................       uint8_t     result;              // RC_* 
....................       uint8_t     param_type;          // PARAM_TXPOWER 
....................       uint8_t     txpower; 
....................    }  getNV_txpower_response; 
....................     
....................    struct _getNV_powerinfo_response 
....................    { 
....................       uint8_t     cmd;                 // CMD_GETNV 
....................       uint8_t     len_pkt;             // always 0x0C 
....................       uint8_t     flags;               // expect FLAG_GET_RESPONSE 
....................       uint8_t     result;              // RC_* 
....................       uint8_t     param_type;          // PARAM_POWERINFO 
....................       uint8_t     power_source;        // PWRSOURCE_* 
....................       uint16_t    discharge_current_uA; 
....................       uint32_t    discharge_time_sec; 
....................       uint32_t    recharge_time_sec;     
....................    }  getNV_powerinfo_response; 
....................  
....................    struct _getnv_otaplock_response 
....................    { 
....................       uint8_t     cmd;                 // CMD_GETNV 
....................       uint8_t     len_pkt;             // always 0x02 
....................       uint8_t     flags;               // expect FLAG_GET_RESPONSE 
....................       uint8_t     result;              // RC_* 
....................       uint8_t     param_type;          // PARAM_OTAPLOCK 
....................       uint8_t     otaplock; 
....................    }  getnv_otaplock_response; 
....................     
....................    struct _cmd_response 
....................    { 
....................       uint8_t     cmd;                 // CMD_SEND, CMD_JOIN, 
....................                                        // CMD_DISCONNECT, CMD_RESET 
....................                                        // CMD_SLEEP, CMD_TESTRADIOTX, 
....................                                        // CMD_TESTRADIORX, CMD_CLEARNV 
....................       uint8_t     len_pkt;             // always 0x00 
....................       uint8_t     flags;               // always FLAG_MOTECMD_RESPONSE 
....................       uint8_t     result;              // RC_* 
....................    }  cmd_response; 
....................     
....................    struct _time_indication 
....................    // this is what you get from mote when you toggle _DUST_TIME 
....................    { 
....................       uint8_t     cmd;                 // CMD_TIME 
....................       uint8_t     len_pkt;             // always 0x0F 
....................       uint8_t     flags;               // See tables 98 and 1***************** 
....................       uint32_t    utc_sec; 
....................       uint32_t    utc_usec; 
....................       uint8_t     asn[5];              // Absolute Slot No. (10msec slots since 
....................                                        //  boot. 
....................       uint16_t    asn_offset;          // usec into current slot number 
....................    }  time_indication; 
....................     
....................    struct _service_indication 
....................    { 
....................       uint8_t     cmd;                 // CMD_SERVICE 
....................       uint8_t     len_pkt;             // always 0x0C 
....................       uint8_t     flags;               // See tables 98 and 1***************** 
....................       uint8_t     event_code;          // SVC_* 
....................       uint8_t     mgr_code;            // MGRCODE_* 
....................       uint8_t     svc_index; 
....................       uint8_t     svc_state;           // SVCSTATE_* 
....................       uint8_t     svc_flags;           // SVCRQST_* 
....................       uint8_t     app_domain;          // APPDOMAIN_* 
....................       uint16_t    destaddr;            // always 0xF981 
....................       uint32_t    time;                // Period/latency: intermittent flag set 
....................    }  service_indication; 
....................  
....................    struct _events_indication 
....................    { 
....................       uint8_t     cmd;                 // CMD_EVENT 
....................       uint8_t     len_pkt;             // always 0x09 
....................       uint8_t     flags;               // See tables 98 and 1***************** 
....................       uint32_t    new_events;          // EVENTMASK_* (?) 
....................       uint8_t     mote_state;          // MOTESTATE_* 
....................       uint32_t    mote_alarms;         // ALARMS_* 
....................    }  events_indication; 
....................     
....................    struct _advert_indication 
....................    { 
....................       uint8_t     cmd;                 // CMD_EVENT 
....................       uint8_t     len_pkt;             // always 0x09 
....................       uint8_t     flags; 
....................       uint16_t    network_id; 
....................       uint16_t    mote_id; 
....................       uint8_t     rssi;                // rcvd signal strength 
....................       uint8_t     hop_depth;           // (join priority) 
....................    }  advert_indication; 
....................     
....................    struct _data_from_net 
....................    { 
....................       uint8_t     cmd;                 // CMD_DATA 
....................       uint8_t     len_pkt;             // always len_data + 4 
....................       uint8_t     flags;               // See tables 98 and 1***************** 
....................       uint16_t    sourceaddr;          // always 0xF981 
....................       uint8_t     sequence_num;        // sequence number 
....................       uint8_t     len_data;            // packet data length (<=MAX_USER_DATA_SIZE) 
....................       uint8_t     data[MAX_USER_DATA_SIZE]; 
....................                                        // actual received data 
....................    }  data_from_net; 
.................... }  mote_to_micro;  
....................  
.................... /* 
.................... #define dust_dn2500_response_t                              dust_dn2500_param_response_t 
.................... #define dust_dn2500_set_param_tx_power_response_t           dust_dn2500_param_response_t 
.................... #define dust_dn2500_set_param_join_duty_cycle_response_t    dust_dn2500_param_response_t 
.................... #define dust_dn2500_set_param_battery_life_response_t       dust_dn2500_param_response_t 
.................... #define dust_dn2500_set_param_event_mask_response_t         dust_dn2500_param_response_t 
.................... #define dust_dn2500_set_param_write_protect_response_t      dust_dn2500_param_response_t 
.................... #define dust_dn2500_setnv_mac_address_response_t            dust_dn2500_param_response_t 
.................... #define dust_dn2500_setnv_network_id_response_t             dust_dn2500_param_response_t 
.................... #define dust_dn2500_setnv_tx_power_response_t               dust_dn2500_param_response_t 
.................... #define dust_dn2500_setnv_joinkey_response_t                dust_dn2500_param_response_t 
.................... #define dust_dn2500_setnv_otap_lockout_response_t           dust_dn2500_param_response_t 
.................... #define dust_dn2500_setnv_powerinfo_response_t              dust_dn2500_param_response_t 
.................... #define dust_dn2500_setnv_ttl_response_t                    dust_dn2500_param_response_t 
.................... #define dust_dn2500_send_response_t                         dust_dn2500_cmd_response_t 
.................... #define dust_dn2500_join_response_t                         dust_dn2500_cmd_response_t 
.................... #define dust_dn2500_search_response_t                       dust_dn2500_cmd_response_t 
.................... #define dust_dn2500_disconnect_response_t                   dust_dn2500_cmd_response_t 
.................... #define dust_dn2500_reset_response_t                        dust_dn2500_cmd_response_t 
.................... #define dust_dn2500_lowPowerSleep_response_t                dust_dn2500_cmd_response_t 
.................... #define dust_dn2500_testRadioTx_response_t                  dust_dn2500_cmd_response_t 
.................... #define dust_dn2500_testRadioRx_response_t                  dust_dn2500_cmd_response_t 
.................... #define dust_dn2500_clearnv_response_t                      dust_dn2500_cmd_response_t 
.................... #define dust_dn2500_set_param_hart_device_status_response_t dust_dn2500_param_response_t 
.................... #define dust_dn2500_set_param_hart_device_info_response_t   dust_dn2500_param_response_t 
.................... #define dust_dn2500_setnv_hart_antenna_gain_response_t      dust_dn2500_param_response_t 
....................  
.................... // MICRO TO MOTE RESPONSES AFTER TIME/SERVICE/EVENTS INDICATION OR DATA_FROM_NET 
.................... #define dust_dn2500_time_response_t    dust_dn2500_cmd_response_t 
.................... #define dust_dn2500_service_response_t dust_dn2500_cmd_response_t 
.................... #define dust_dn2500_events_response_t  dust_dn2500_cmd_response_t 
.................... #define dust_dn2500_data_response_t    dust_dn2500_cmd_response_t 
....................  
....................  
.................... struct dust_dn2500_cmd_response_t { 
....................     DUST_DN2500_HEADER_RESPONSE 
.................... }; 
.................... struct dust_dn2500_header_t { 
....................     DUST_DN2500_HEADER 
.................... }; 
....................  
.................... // WHAT UP WITH THIS....  hw/sw incompatibilities insurance?? -- ignore for now 
.................... // points to any extra bytes received that are not identified as a "dust" packet  
.................... struct dust_dn2500_unknown_data_t { 
....................    uint8_t*    data; 
....................    uint8_t     len; 
.................... }; 
.................... */ 
....................  
.................... // uint8_t     macaddr[8]; 
.................... uint8_t     joinkey[MAX_JOINKEY_SIZE]={0x44,0x55,0x53,0x54,0x4E,0x45,0x54,0x57,0x4F,0x52,0x4B,0x53,0x52,0x4F,0x43,0x4B}; 
.................... // need these declaration for pkgen_setnv_macaddr 
....................  
.................... /* 
.................... // The following structures exist in RAM as 'global'.  No need to pass 
.................... //  the structure to the packet generation routines defined below 
.................... struct _set_battlife_struct 
.................... // setup up battlife_days and pwrstat prior to pkgen_set_battlife() call 
.................... { 
....................    uint16_t    battlife_days; 
....................    uint8_t     pwrstat;                // PWRSTAT_* 
.................... }  set_battlife_struct; 
....................  
.................... struct _setnv_powerinfo_struct  
.................... // setup pwrsource, discharge_current_uA, discharge_time_sec, 
.................... //  and recharge_time_sec prior to pkgen_setnv_powerinfo() 
.................... { 
....................    uint8_t     pwrsource;              // PWRSOURCE_* 
....................    uint16_t    discharge_current_uA; 
....................    uint32_t    discharge_time_sec; 
....................    uint32_t    recharge_time_sec;     
.................... }  setnv_powerinfo_struct; 
....................  
.................... struct _set_svc_struct 
.................... // setup  svc_index; request_flags, app_domain and time  
.................... //  pwrstat prior to pkgen_set_battlife() call.  No need to setup dest_address 
.................... { 
....................    uint8_t     svc_index; 
....................    uint8_t     request_flags;          // SVCRQST_* 
....................    uint8_t     app_domain;             // APPDOMAIN_* 
....................    uint16_t    destaddr;               // always 0xF981 
....................                                        //  set properly in pkgen_set_service() 
....................    uint32_t    time;                   // Period/latency: intermittent flag set 
.................... }  set_svc_struct; 
....................  
.................... struct testradiotx_struct 
.................... // setup channel and num_packets prior to pkgen_testradiotx() call 
.................... { 
....................    uint8_t     channel;                // 0-15 
....................    uint16_t    num_packets; 
.................... }  testradiotx_struct; 
....................  
.................... struct testradiorx_struct 
.................... // setup channel and time_sec prior to pkgen_testradiorx() call 
.................... { 
....................    uint8_t     channel;                // 0-15  
....................    uint16_t    time_sec;               // rcv packets for this many secs 
.................... }  testradiorx_struct; 
.................... */ 
....................  
....................  
.................... /* ------------------------------------------------------------------------- */ 
.................... #define __swap32(src) (((uint32_t)src<<24)|(((uint32_t)src&0xff00)<<8)| \ 
....................                            (((uint32_t)src>>8)&0xff00)|((uint32_t)src>>24)) 
.................... #define __swap16(src) (((uint16_t)src<<8)|((uint16_t)src>>8)) 
.................... /* ------------------------------------------------------------------------- */ 
....................  
....................  
.................... /* ----------------------  Packet Generation Macros ------------------------ */ 
....................  
.................... /* setParameter<txPower> Request */ 
.................... #define pkgen_set_txpower(power) { \ 
....................     uint8_t prefix[] = {CMD_SET,0x02/*length*/,FLAG_TYPE_REQUEST,PARAM_TXPOWER}; \ 
....................     uint8_t pw       = power; \ 
....................     dust_hdlc_pkgen(prefix, 4, (uint8_t*)&pw, 1); \ 
.................... } 
....................  
.................... /* setParameter<joinDutyCycle> Request */ 
.................... #define pkgen_set_joinduty(cycle) { \ 
....................     uint8_t prefix[] = {CMD_SET,0x02/*length*/,FLAG_TYPE_REQUEST,PARAM_JOINDUTY}; \ 
....................     uint8_t cy       = cycle; \ 
....................     dust_hdlc_pkgen(prefix, 4, (uint8_t*)&cy, 1); \ 
.................... } 
....................  
.................... /* setParameter<batteryLife> Request */ 
.................... // structure is a declared global 
.................... #define pkgen_set_battlife() { \ 
....................     uint8_t  prefix[] = {CMD_SET,0x04/*length*/,FLAG_TYPE_REQUEST,PARAM_BATTLIFE}; \ 
....................     set_battlife_struct.battlife_days = __swap16(set_battlife_struct.battlife_days); \ 
....................     dust_hdlc_pkgen(prefix, 4, (uint8_t*)&set_battlife_struct, 3); \ 
.................... } 
....................  
.................... /* setParameter<service> Request */ 
.................... // structure is a declared global 
.................... #define pkgen_set_service() { \ 
....................     uint8_t  prefix[] = {CMD_SET,0x0A/*length*/,FLAG_TYPE_REQUEST,PARAM_SERVICE}; \ 
....................     set_svc_struct.destaddr = DESTADDR_SWAPPED; \ 
....................     set_svc_struct.time         = __swap32(set_svc_struct.time); \ 
....................     dust_hdlc_pkgen(prefix, 4, (uint8_t*)&set_svc_struct, 9); \ 
.................... } 
....................  
.................... /* setParameter<eventMask> Request */ 
.................... // eventmask is one of EVENTMASK_* 
.................... #define pkgen_set_eventmask(eventmask) { \ 
....................     uint8_t  prefix[] = {CMD_SET,0x05/*length*/,FLAG_TYPE_REQUEST,PARAM_EVENTMASK}; \ 
....................     uint32_t dstem    = __swap32(eventmask); \ 
....................     dust_hdlc_pkgen(prefix, 4, (uint8_t*)&dstem, 4); \ 
.................... } 
....................  
.................... /* getParameter<moteInfo> Request */ 
.................... #define pkgen_get_moteinfo() { \ 
....................     uint8_t cmd[] = {CMD_GET,0x01/*length*/,FLAG_TYPE_REQUEST,PARAM_MOTEINFO}; \ 
....................     dust_hdlc_pkgen((char*)(NULL), 0, cmd, 4); \ 
.................... } 
....................   
.................... /* getParameter<networkInfo> Request */ 
.................... #define pkgen_get_networkinfo() { \ 
....................     uint8_t cmd[] = {CMD_GET,0x01/*length*/,FLAG_TYPE_REQUEST,PARAM_NETWORKINFO}; \ 
....................     dust_hdlc_pkgen((char*)(NULL), 0, cmd, 4); \ 
.................... } 
....................  
.................... /* getParameter<moteStatus> Request */ 
.................... #define pkgen_get_motestatus() { \ 
....................     uint8_t cmd[] = {CMD_GET,0x01/*length*/,FLAG_TYPE_REQUEST,PARAM_MOTESTATUS}; \ 
....................     dust_hdlc_pkgen((char*)(NULL), 0, cmd, 4); \ 
.................... } 
....................  
.................... /* getParameter<time> Request */ 
.................... #define pkgen_get_time() { \ 
....................     uint8_t cmd[] = {CMD_GET,0x01/*length*/,FLAG_TYPE_REQUEST,PARAM_TIME}; \ 
....................     dust_hdlc_pkgen((char*)(NULL), 0, cmd, 4); \ 
.................... } 
....................  
.................... /* getParameter<charge> Request */ 
.................... #define pkgen_get_charge() { \ 
....................     uint8_t cmd[] = {CMD_GET,0x01/*length*/,FLAG_TYPE_REQUEST,PARAM_CHARGE}; \ 
....................     dust_hdlc_pkgen((char*)(NULL), 0, cmd, 4); \ 
.................... } 
....................  
.................... /* getParameter<testRadioRxStats> Request */ 
.................... #define pkgen_get_radiostatsrx() { \ 
....................     uint8_t cmd[] = {CMD_GET,0x01/*length*/,FLAG_TYPE_REQUEST,PARAM_RADIOSTATSRX}; \ 
....................     dust_hdlc_pkgen((char*)(NULL), 0, cmd, 4); \ 
.................... } 
....................  
.................... /* getParameter<service> Request */ 
.................... #define pkgen_get_service(service_idx) { \ 
....................     uint8_t prefix[] = {CMD_GET,0x02/*length*/,FLAG_TYPE_REQUEST,PARAM_SERVICE}; \ 
....................     uint8_t idx      = svc_index; \ 
....................     dust_hdlc_pkgen(prefix, 4, (uint8_t*)&idx, 1); \ 
.................... } 
....................  
.................... /* setNVParameter<macAddress> Request */ 
.................... // macaddr array is declared 
.................... #define pkgen_setnv_macaddr() { \ 
....................     uint8_t prefix[]   = {CMD_SETNV,0x0D/*length*/,FLAG_TYPE_REQUEST, 0x00, 0x00, 0x00, 0x00, PARAM_MACADDR}; \ 
....................     dust_hdlc_pkgen(prefix, 8, macaddr, 8); \ 
.................... } 
....................  
.................... /* setNVParameter<networkID> Request */ 
.................... #define pkgen_setnv_networkid(networkid) { \ 
....................     uint8_t prefix[] = {CMD_SETNV,0x07/*length*/,FLAG_TYPE_REQUEST, 0x00, 0x00, 0x00, 0x00, PARAM_NETWORKID}; \ 
....................     uint16_t net_id  = networkid; \ 
....................     dust_hdlc_pkgen(prefix, 8, (uint8_t*)&net_id, 2); \ 
.................... } 
....................  
.................... /* setNVParameter<txPower> Request */ 
.................... #define pkgen_setnv_txpower(txpower) { \ 
....................     uint8_t prefix[] = {CMD_SETNV,0x06/*length*/,FLAG_TYPE_REQUEST, 0x00, 0x00, 0x00, 0x00, PARAM_TXPOWER}; \ 
....................     uint8_t dst_power  = txpower; \ 
....................     dust_hdlc_pkgen(prefix, 8, (uint8_t*)&dst_power, 1); \ 
.................... } 
....................  
.................... /* setNVParameter<joinKey> Request */ 
.................... // joinkey array is declared 
....................  
.................... #define pkgen_setnv_joinkey(joinkey) { \ 
....................     uint8_t prefix[]   = {CMD_SETNV,0x15/*length*/,FLAG_TYPE_REQUEST, 0x00, 0x00, 0x00, 0x00, PARAM_JOINKEY}; \ 
....................     dust_hdlc_pkgen(prefix, 8, joinkey, 16); \ 
.................... } 
....................  
.................... //#define pkgen_setnv_joinkey(joinkey) { \ 
.................... //      uint8_t prefix[]   = {CMD_SETNV,0x15/*length*/,FLAG_TYPE_REQUEST, 0x00, 0x00, 0x00, 0x00, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}; \ 
.................... //      dust_hdlc_pkgen(prefix, 8,,16); \ 
.................... //} 
....................  
....................  
.................... /* setNVParameter<powerInfo> Request */ 
.................... // structure is a declared global 
.................... #define pkgen_setnv_powerinfo() { \ 
....................     uint8_t prefix[] = {CMD_SETNV,0x10/*length*/,FLAG_TYPE_REQUEST, 0x00, 0x00, 0x00, 0x00, PARAM_POWERINFO}; \ 
....................     setnv_powerinfo_struct.discharge_current_uA     = __swap16(setnv_powerinfo_struct.discharge_current_uA); \ 
....................     setnv_powerinfo_struct.discharge_time_sec       = __swap32(setnv_powerinfo_struct.discharge_time_sec); \ 
....................     setnv_powerinfo_struct.recharge_time_sec        = __swap32(setnv_powerinfo_struct.recharge_time_sec); \ 
....................     dust_hdlc_pkgen(prefix, 8, (uint8_t*)&setnv_powerinfo_struct, 11); \ 
.................... }  
....................  
.................... /* setNVParameter<OTAPlockout> Request */ 
.................... #define pkgen_setnv_otaplock(lockout) { \ 
....................    uint8_t prefix[] = {CMD_SETNV,0x06/*length*/,FLAG_TYPE_REQUEST, 0x00, 0x00, 0x00, 0x00, PARAM_OTAPLOCK}; \ 
....................    uint8_t otaplock = lockout; \ 
....................    dust_hdlc_pkgen(prefix, 8, (uint8_t*)&otaplock, 1); \ 
.................... } 
....................  
.................... /* setNVParameter<SpecialJoinTimingParams> Request */ 
.................... #define pkgen_setnv_special1(special1) { \ 
....................    uint8_t prefix[] = {CMD_SETNV,0x07/*length*/,0x02, 0x67, 0x12, 0x04, 0x04, PARAM_SPECIAL1}; \ 
....................    uint16_t spec_param1  = special1; \ 
....................    dust_hdlc_pkgen(prefix, 8, (uint8_t*)&spec_param1, 2); \ 
.................... } 
....................  
.................... /* setNVParameter<SpecialJoinTimingParams> Request */ 
.................... #define pkgen_setnv_special2(special2) { \ 
....................    uint8_t prefix[] = {CMD_SETNV,0x07/*length*/,0x00, 0x67, 0x12, 0x04, 0x04, PARAM_SPECIAL2}; \ 
....................    uint16_t spec_param2 = special2; \ 
....................    dust_hdlc_pkgen(prefix, 8, (uint8_t*)&spec_param2, 2); \ 
.................... } 
....................  
.................... /* getNVParameter<macAddress> Request */ 
.................... #define pkgen_getnv_macaddr() { \ 
....................     uint8_t cmd[] = {CMD_GETNV,0x05/*length*/,FLAG_TYPE_REQUEST, 0x00, 0x00, 0x00, 0x00, PARAM_MACADDR}; \ 
....................     dust_hdlc_pkgen((char*)(NULL), 0, cmd, 8); \ 
.................... } 
....................  
.................... /* getNVParameter<networkID> Request */ 
.................... #define pkgen_getnv_networkid() { \ 
....................     uint8_t cmd[] = {CMD_GETNV,0x05/*length*/,FLAG_TYPE_REQUEST, 0x00, 0x00, 0x00, 0x00, PARAM_NETWORKID}; \ 
....................     dust_hdlc_pkgen((char*)(NULL), 0, cmd, 8); \ 
.................... } 
....................  
.................... /* getNVParameter<txPower> Request */ 
.................... #define pkgen_getnv_txpower() { \ 
....................     uint8_t cmd[] = {CMD_GETNV,0x05/*length*/,FLAG_TYPE_REQUEST, 0x00, 0x00, 0x00, 0x00, PARAM_TXPOWER}; \ 
....................     dust_hdlc_pkgen((char*)(NULL), 0, cmd, 8); \ 
.................... } 
....................  
.................... /* getNVParameter<powerInfo> Request */ 
.................... #define pkgen_getnv_powerinfo() { \ 
....................     uint8_t cmd[] = {CMD_GETNV,0x05/*length*/,FLAG_TYPE_REQUEST, 0x00, 0x00, 0x00, 0x00, PARAM_POWERINFO}; \ 
....................     dust_hdlc_pkgen((char*)(NULL), 0, cmd, 8); \ 
.................... } 
....................  
.................... /* getNVParameter<OTAPlockout> Request */ 
.................... #define pkgen_getnv_otaplock() { \ 
....................     uint8_t cmd[]   = {CMD_GETNV,0x05/*length*/,FLAG_TYPE_REQUEST, 0x00, 0x00, 0x00, 0x00, PARAM_OTAPLOCK}; \ 
....................     dust_hdlc_pkgen((char*)(NULL), 0, cmd, 8); \ 
.................... } 
....................  
.................... // command to mote to test the radio transmitter 
.................... // structure is a declared global 
.................... #define pkgen_testradiotx() { \ 
....................     uint8_t  prefix[] = {CMD_TESTRADIOTX, 3 /*payload length*/, FLAG_TYPE_TEST}; \ 
....................     testradiotx_struct.num_packets = __swap16(testradiotx_struct.num_packets); \ 
....................     dust_hdlc_pkgen(prefix, 3, (uint8_t*)&testradiotx_struct, 3); \ 
.................... } 
....................  
.................... #define pkgen_testradiorx() { \ 
....................     uint8_t  prefix[] = {CMD_TESTRADIORX, 3 /*payload length*/, FLAG_TYPE_TEST}; \ 
....................     testradiorx_struct.time_sec = __swap16(testradiorx_struct.time_sec); \ 
....................     dust_hdlc_pkgen(prefix, 3, (uint8_t*)&testradiorx_struct, 3); \ 
.................... } 
....................  
.................... /* Join Request */ 
.................... #define pkgen_join() { \ 
....................     uint8_t cmd[]   = {CMD_JOIN,0x00/*payload length*/,FLAG_TYPE_REQUEST}; \ 
....................     dust_hdlc_pkgen((char*)(NULL), 0, cmd, 3); \ 
.................... } 
....................  
.................... /* Disconnect Request */ 
.................... #define pkgen_disconnect() { \ 
....................     uint8_t cmd[]   = {CMD_DISCONNECT,0x00/*payload length*/,FLAG_TYPE_REQUEST}; \ 
....................     dust_hdlc_pkgen((char*)(NULL), 0, cmd, 3); \ 
.................... } 
....................  
.................... /* Reset Request */ 
.................... #define pkgen_reset() { \ 
....................     uint8_t cmd[]   = {CMD_RESET,0x00/*payload length*/,FLAG_TYPE_REQUEST}; \ 
....................     dust_hdlc_pkgen((char*)(NULL), 0, cmd, 3); \ 
.................... } 
....................  
.................... /* lowPowerSleep Request */ 
.................... #define pkgen_sleep() { \ 
....................     uint8_t cmd[]   = {CMD_SLEEP,0x00/*payload length*/,FLAG_TYPE_REQUEST}; \ 
....................     dust_hdlc_pkgen((char*)(NULL), 0, cmd, 3); \ 
.................... } 
....................  
.................... /* ClearNV Request */ 
.................... #define pkgen_clearnv() { \ 
....................     uint8_t cmd[]   = {CMD_CLEARNV,0x00/*payload length*/,FLAG_TYPE_REQUEST}; \ 
....................     ((char*)(NULL), 0, cmd, 3); \ 
.................... } 
....................  
.................... /* Search Request */ 
.................... #define pkgen_search() { \ 
....................     uint8_t cmd[]   = {CMD_SEARCH,0x00/*payload length*/,FLAG_TYPE_REQUEST}; \ 
....................     dust_hdlc_pkgen((char*)(NULL), 0, cmd, 3); \ 
.................... } 
....................  
.................... // MOTE command responses.  The micro sends a response to mote  
.................... //  after having received an indication or a data packet 
....................  
.................... #define pkgen_time_ind_response(result_fl) { \ 
....................     uint8_t prefix[] = {CMD_TIME,0x00};   \ 
....................     uint16_t r        = result_fl; \ 
....................     dust_hdlc_pkgen(prefix, 2, (uint8_t*)&r, 2); \ 
.................... } 
....................  
.................... #define pkgen_service_ind_response(result_fl) { \ 
....................     uint8_t prefix[] = {CMD_SERVICE,0x00}; \ 
....................     uint16_t r       = result_fl; \ 
....................     dust_hdlc_pkgen(prefix, 2, (uint8_t*)&r, 2);  \ 
.................... } 
....................  
.................... #define pkgen_event_ind_response(result_fl) { \ 
....................     uint8_t prefix[] = {CMD_EVENT,0x00};  \ 
....................     uint16_t r        = result_fl; \ 
....................     dust_hdlc_pkgen(prefix, 2, (uint8_t*)&r, 2); \ 
.................... } 
....................  
.................... #define pkgen_advert_ind_response(result_fl) { \ 
....................     uint8_t prefix[] = {CMD_ADVERT,0x00}; \ 
....................     uint16_t r       = result_fl; \ 
....................     dust_hdlc_pkgen(prefix, 2, (uint8_t*)&r, 2); \ 
.................... } 
....................  
.................... #define pkgen_data_rcvd_response(result_fl) { \ 
....................     uint8_t prefix[] = {CMD_DATA,0x00};  \ 
....................     uint16_t r       = result_fl; \ 
....................     dust_hdlc_pkgen(prefix, 2, (uint8_t*)&r, 2); \ 
.................... } 
....................  
.................... // Added by brian 
.................... #define pkgen_mote_ack() { \ 
....................  uint8_t cmd[]   = {(flags_rcvd+1),response_type}; \ 
....................  dust_hdlc_pkgen((cmd_rcvd << 8), 2, cmd, 2); \ 
.................... } 
....................     
.................... //  
.................... /* 
.................... struct dust_dn2500_t { 
....................  
....................     // SET Parameters Responses 
....................     int8_t (*set_param_tx_power_response)(void* handle, struct dust_dn2500_set_param_tx_power_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................     int8_t (*set_param_join_duty_cycle_response)(void* handle, struct dust_dn2500_set_param_join_duty_cycle_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................     int8_t (*set_param_battery_life_response)(void* handle, struct dust_dn2500_set_param_battery_life_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................     int8_t (*set_param_service_response)(void* handle, struct dust_dn2500_set_param_service_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................     int8_t (*set_param_hart_device_status_response)(void* handle, struct dust_dn2500_set_param_hart_device_status_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................     int8_t (*set_param_hart_device_info_response)(void* handle, struct dust_dn2500_set_param_hart_device_info_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................     int8_t (*set_param_event_mask_response)(void* handle, struct dust_dn2500_set_param_event_mask_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................     int8_t (*set_param_write_protect_response)(void* handle, struct dust_dn2500_set_param_write_protect_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................  
....................     int8_t (*get_param_mote_info_response)(void* handle, struct dust_dn2500_get_param_mote_info_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................     int8_t (*get_param_network_info_response)(void* handle, struct dust_dn2500_get_param_network_info_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................     int8_t (*get_param_mote_status_response)(void* handle, struct dust_dn2500_get_param_mote_status_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................     int8_t (*get_param_time_response)(void* handle, struct dust_dn2500_get_param_time_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................     int8_t (*get_param_charge_response)(void* handle, struct dust_dn2500_get_param_charge_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................     int8_t (*get_param_test_radio_rxstats_response)(void* handle, struct dust_dn2500_get_param_test_radio_rxstats_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................     int8_t (*get_param_service_response)(void* handle, struct dust_dn2500_get_param_service_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................  
....................     // Non-Volatile Parameter Responses 
....................     int8_t (*setnv_mac_address_response)(void* handle, struct dust_dn2500_setnv_mac_address_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................     int8_t (*setnv_network_id_response)(void* handle, struct dust_dn2500_setnv_network_id_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................     int8_t (*setnv_tx_power_response)(void* handle, struct dust_dn2500_setnv_tx_power_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................     int8_t (*setnv_joinkey_response)(void* handle, struct dust_dn2500_setnv_joinkey_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................     int8_t (*setnv_powerinfo_response)(void* handle, struct dust_dn2500_setnv_powerinfo_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................     int8_t (*setnv_ttl_response)(void* handle, struct dust_dn2500_setnv_ttl_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................     int8_t (*setnv_hart_antenna_gain)(void* handle, struct dust_dn2500_setnv_hart_antenna_gain_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................     int8_t (*setnv_otap_lockout)(void* handle, struct dust_dn2500_setnv_otap_lockout_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................  
....................     int8_t (*getnv_mac_address_response)(void* handle, struct dust_dn2500_getnv_mac_address_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................     int8_t (*getnv_network_id_response)(void* handle, struct dust_dn2500_getnv_network_id_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................     int8_t (*getnv_tx_power_response)(void* handle, struct dust_dn2500_getnv_tx_power_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................     int8_t (*getnv_powerinfo_response)(void* handle, struct dust_dn2500_getnv_powerinfo_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................     int8_t (*getnv_ttl_response)(void* handle, struct dust_dn2500_getnv_ttl_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................     int8_t (*getnv_hart_antenna_gain)(void* handle, struct dust_dn2500_getnv_hart_antenna_gain_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................     int8_t (*getnv_otap_lockout)(void* handle, struct dust_dn2500_getnv_otap_lockout_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................  
....................     // Command Responses 
....................     int8_t (*send_response)(void* handle, struct dust_dn2500_send_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................     int8_t (*join_response)(void* handle, struct dust_dn2500_join_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................     int8_t (*disconnect_response)(void* handle, struct dust_dn2500_disconnect_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................     int8_t (*search_response)(void* handle, struct dust_dn2500_search_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................     int8_t (*reset_response)(void* handle, struct dust_dn2500_reset_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................     int8_t (*lowPowerSleep_response)(void* handle, struct dust_dn2500_lowPowerSleep_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................     int8_t (*hartPayload_response)(void* handle, struct dust_dn2500_hartPayload_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................     int8_t (*testRadioTx_response)(void* handle, struct dust_dn2500_testRadioTx_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................     int8_t (*testRadioRx_response)(void* handle, struct dust_dn2500_testRadioRx_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................     int8_t (*clearnv_response)(void* handle, struct dust_dn2500_clearnv_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................  
....................     // MOTE commands sent to sensor processor 
....................     int8_t (*time_request)(void* handle, struct dust_dn2500_time_request_t* p, struct dust_dn2500_unknown_data_t* un); 
....................     int8_t (*service_indication)(void* handle, struct dust_dn2500_service_indication_t* p, struct dust_dn2500_unknown_data_t* un); 
....................     int8_t (*events_request)(void* handle, struct dust_dn2500_events_request_t* p, struct dust_dn2500_unknown_data_t* un); 
....................     int8_t (*data_request)(void* handle, struct dust_dn2500_data_request_t* p, struct dust_dn2500_unknown_data_t* un); 
....................  
....................     // Unknown command 
....................     int8_t (*unknown_command)(void* handle, uint8_t* data, uint8_t len); 
....................  
....................     // source buffer 
....................     uint8_t     bf_src[MAX_ENCODED_PACKET_SIZE]; 
....................     uint8_t     len_src; 
....................  
....................     // destination buffer 
....................     uint8_t     bf_dest[MAX_DEST_BUF_SIZE]; 
....................     uint8_t     len_dest; 
....................  
....................     uint8_t     idx; 
....................      
....................  
....................     // Used in case SW version isn't in sync with HW firmware version 
....................    struct dust_dn2500_unknown_data_t unknown; 
.................... }; 
....................  
.................... // Utility commands to queue and clear packet data 
.................... int8_t dust_dn2500_q_clear(struct dust_dn2500_t* ia); 
.................... int8_t dust_dn2500_q_byte(struct dust_dn2500_t* ia, uint8_t byte); 
....................  
.................... // Routine to dispatch incoming packets to callbacks 
.................... int8_t dust_dn2500_dispatcher(struct pappy_t* md, struct dust_dn2500_t* ia, void* handle); 
.................... //user defined 
....................  
.................... */ 
....................  
.................... // HERE ARE ITEMS FROM DUST_HDLC.H 
.................... #define CONTROL_ESCAPE 0x7d 
.................... #define FLAG_SEQUENCE  0x7e 
.................... #define XOR_BYTE       0x20 
....................  
.................... /* Low level routine return values */ 
.................... #define DUST_HDLC_RTN_SUCCESS                     0 
.................... #define DUST_HDLC_RTN_NOT_ENOUGH_BUFFER_SPACE    -1 
.................... #define DUST_HDLC_RTN_BAD_CRC                    -2 
.................... #define DUST_HDLC_RTN_INVALID_PK_DELIMITERS      -3 
....................  
....................  
.................... // HERE ARE ITEMS FROM DUST_HDLC.C 
.................... #define FCS_INITIAL_FCS16 ((uint16_t) 0xffff) 
.................... #define FCS_GOOD_FCS16    ((uint16_t) 0xf0b8) 
....................  
.................... // We will use the routine that takes LESS PROCESSING TIME at the expense 
.................... //  or greater memory usage. 
....................  
.................... // lookup table for calculation of checksum 
.................... UNSIGNED INT16 CONST fcstab[256] =  { 
....................    0x0000, 0x1189, 0x2312, 0x329b, 0x4624, 0x57ad, 0x6536, 0x74bf, 
....................    0x8c48, 0x9dc1, 0xaf5a, 0xbed3, 0xca6c, 0xdbe5, 0xe97e, 0xf8f7, 
....................    0x1081, 0x0108, 0x3393, 0x221a, 0x56a5, 0x472c, 0x75b7, 0x643e, 
....................    0x9cc9, 0x8d40, 0xbfdb, 0xae52, 0xdaed, 0xcb64, 0xf9ff, 0xe876, 
....................    0x2102, 0x308b, 0x0210, 0x1399, 0x6726, 0x76af, 0x4434, 0x55bd, 
....................    0xad4a, 0xbcc3, 0x8e58, 0x9fd1, 0xeb6e, 0xfae7, 0xc87c, 0xd9f5, 
....................    0x3183, 0x200a, 0x1291, 0x0318, 0x77a7, 0x662e, 0x54b5, 0x453c, 
....................    0xbdcb, 0xac42, 0x9ed9, 0x8f50, 0xfbef, 0xea66, 0xd8fd, 0xc974, 
....................    0x4204, 0x538d, 0x6116, 0x709f, 0x0420, 0x15a9, 0x2732, 0x36bb, 
....................    0xce4c, 0xdfc5, 0xed5e, 0xfcd7, 0x8868, 0x99e1, 0xab7a, 0xbaf3, 
....................    0x5285, 0x430c, 0x7197, 0x601e, 0x14a1, 0x0528, 0x37b3, 0x263a, 
....................    0xdecd, 0xcf44, 0xfddf, 0xec56, 0x98e9, 0x8960, 0xbbfb, 0xaa72, 
....................    0x6306, 0x728f, 0x4014, 0x519d, 0x2522, 0x34ab, 0x0630, 0x17b9, 
....................    0xef4e, 0xfec7, 0xcc5c, 0xddd5, 0xa96a, 0xb8e3, 0x8a78, 0x9bf1, 
....................    0x7387, 0x620e, 0x5095, 0x411c, 0x35a3, 0x242a, 0x16b1, 0x0738, 
....................    0xffcf, 0xee46, 0xdcdd, 0xcd54, 0xb9eb, 0xa862, 0x9af9, 0x8b70, 
....................    0x8408, 0x9581, 0xa71a, 0xb693, 0xc22c, 0xd3a5, 0xe13e, 0xf0b7, 
....................    0x0840, 0x19c9, 0x2b52, 0x3adb, 0x4e64, 0x5fed, 0x6d76, 0x7cff, 
....................    0x9489, 0x8500, 0xb79b, 0xa612, 0xd2ad, 0xc324, 0xf1bf, 0xe036, 
....................    0x18c1, 0x0948, 0x3bd3, 0x2a5a, 0x5ee5, 0x4f6c, 0x7df7, 0x6c7e, 
....................    0xa50a, 0xb483, 0x8618, 0x9791, 0xe32e, 0xf2a7, 0xc03c, 0xd1b5, 
....................    0x2942, 0x38cb, 0x0a50, 0x1bd9, 0x6f66, 0x7eef, 0x4c74, 0x5dfd, 
....................    0xb58b, 0xa402, 0x9699, 0x8710, 0xf3af, 0xe226, 0xd0bd, 0xc134, 
....................    0x39c3, 0x284a, 0x1ad1, 0x0b58, 0x7fe7, 0x6e6e, 0x5cf5, 0x4d7c, 
....................    0xc60c, 0xd785, 0xe51e, 0xf497, 0x8028, 0x91a1, 0xa33a, 0xb2b3, 
....................    0x4a44, 0x5bcd, 0x6956, 0x78df, 0x0c60, 0x1de9, 0x2f72, 0x3efb, 
....................    0xd68d, 0xc704, 0xf59f, 0xe416, 0x90a9, 0x8120, 0xb3bb, 0xa232, 
....................    0x5ac5, 0x4b4c, 0x79d7, 0x685e, 0x1ce1, 0x0d68, 0x3ff3, 0x2e7a, 
....................    0xe70e, 0xf687, 0xc41c, 0xd595, 0xa12a, 0xb0a3, 0x8238, 0x93b1, 
....................    0x6b46, 0x7acf, 0x4854, 0x59dd, 0x2d62, 0x3ceb, 0x0e70, 0x1ff9, 
....................    0xf78f, 0xe606, 0xd49d, 0xc514, 0xb1ab, 0xa022, 0x92b9, 0x8330, 
....................    0x7bc7, 0x6a4e, 0x58d5, 0x495c, 0x3de3, 0x2c6a, 0x1ef1, 0x0f78 
.................... }; 
....................  
.................... /* 
.................... // EVEN MORE STUFF NOT RELEVANT TO JACK IMPLEMENTATION 
.................... // ITEMS FROM DUST_DN2500_HANDLER.H 
.................... // I THINK THESE ARE FUNCTION PROTOTYPES! 
.................... // set_parameter response packets received by sensor processor 
.................... int8_t dust_dn2500_set_param_tx_power_response(void* handle, struct dust_dn2500_set_param_tx_power_response_t* p, struct dust_dn2500_unknown_data_t* un); 
.................... int8_t dust_dn2500_set_param_join_duty_cycle_response(void* handle, struct dust_dn2500_set_param_join_duty_cycle_response_t* p, struct dust_dn2500_unknown_data_t* un); 
.................... int8_t dust_dn2500_set_param_battery_life_response(void* handle, struct dust_dn2500_set_param_battery_life_response_t* p, struct dust_dn2500_unknown_data_t* un); 
.................... int8_t dust_dn2500_set_param_service_response(void* handle, struct dust_dn2500_set_param_service_response_t* p, struct dust_dn2500_unknown_data_t* un); 
.................... int8_t dust_dn2500_set_param_event_mask_response(void* handle, struct dust_dn2500_set_param_event_mask_response_t* p, struct dust_dn2500_unknown_data_t* un); 
.................... int8_t dust_dn2500_set_param_hart_device_status_response(void* handle, struct dust_dn2500_set_param_hart_device_status_response_t* p, struct dust_dn2500_unknown_data_t* un); 
.................... int8_t dust_dn2500_set_param_hart_device_info_response(void* handle, struct dust_dn2500_set_param_hart_device_info_response_t* p, struct dust_dn2500_unknown_data_t* un); 
.................... int8_t dust_dn2500_set_param_write_protect_response(void* handle, struct dust_dn2500_set_param_write_protect_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................  
.................... // get_parameter response packets received by sensor processor 
.................... int8_t dust_dn2500_get_param_mote_info_response(void* handle, struct dust_dn2500_get_param_mote_info_response_t* p, struct dust_dn2500_unknown_data_t* un); 
.................... int8_t dust_dn2500_get_param_network_info_response(void* handle, struct dust_dn2500_get_param_network_info_response_t* p, struct dust_dn2500_unknown_data_t* un); 
.................... int8_t dust_dn2500_get_param_mote_status_response(void* handle, struct dust_dn2500_get_param_mote_status_response_t* p, struct dust_dn2500_unknown_data_t* un); 
.................... int8_t dust_dn2500_get_param_service_response(void* handle, struct dust_dn2500_get_param_service_response_t* p, struct dust_dn2500_unknown_data_t* un); 
.................... int8_t dust_dn2500_get_param_time_response(void* handle, struct dust_dn2500_get_param_time_response_t* p, struct dust_dn2500_unknown_data_t* un); 
.................... int8_t dust_dn2500_get_param_charge_response(void* handle, struct dust_dn2500_get_param_charge_response_t* p, struct dust_dn2500_unknown_data_t* un); 
.................... int8_t dust_dn2500_get_param_test_radio_rxstats_response(void* handle, struct dust_dn2500_get_param_test_radio_rxstats_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................  
.................... // get non-volatile response packets received by sensor processor 
.................... int8_t dust_dn2500_getnv_mac_address_response(void* handle, struct dust_dn2500_getnv_mac_address_response_t* p, struct dust_dn2500_unknown_data_t* un); 
.................... int8_t dust_dn2500_getnv_network_id_response(void* handle, struct dust_dn2500_getnv_network_id_response_t* p, struct dust_dn2500_unknown_data_t* un); 
.................... int8_t dust_dn2500_getnv_tx_power_response(void* handle, struct dust_dn2500_getnv_tx_power_response_t* p, struct dust_dn2500_unknown_data_t* un); 
.................... int8_t dust_dn2500_getnv_powerinfo_response(void* handle, struct dust_dn2500_getnv_powerinfo_response_t* p, struct dust_dn2500_unknown_data_t* un); 
.................... int8_t dust_dn2500_getnv_ttl_response(void* handle, struct dust_dn2500_getnv_ttl_response_t* p, struct dust_dn2500_unknown_data_t* un); 
.................... int8_t dust_dn2500_getnv_hart_antenna_gain(void* handle, struct dust_dn2500_getnv_hart_antenna_gain_response_t* p, struct dust_dn2500_unknown_data_t* un); 
.................... int8_t dust_dn2500_getnv_otap_lockout(void* handle, struct dust_dn2500_getnv_otap_lockout_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................  
.................... // set non-volatile response packets received by sensor processor 
.................... int8_t dust_dn2500_setnv_mac_address_response(void* handle, struct dust_dn2500_setnv_mac_address_response_t* p, struct dust_dn2500_unknown_data_t* un); 
.................... int8_t dust_dn2500_setnv_network_id_response(void* handle, struct dust_dn2500_setnv_network_id_response_t* p, struct dust_dn2500_unknown_data_t* un); 
.................... int8_t dust_dn2500_setnv_tx_power_response(void* handle, struct dust_dn2500_setnv_tx_power_response_t* p, struct dust_dn2500_unknown_data_t* un); 
.................... int8_t dust_dn2500_setnv_joinkey_response(void* handle, struct dust_dn2500_setnv_joinkey_response_t* p, struct dust_dn2500_unknown_data_t* un); 
.................... int8_t dust_dn2500_setnv_powerinfo_response(void* handle, struct dust_dn2500_setnv_powerinfo_response_t* p, struct dust_dn2500_unknown_data_t* un); 
.................... int8_t dust_dn2500_setnv_ttl_response(void* handle, struct dust_dn2500_setnv_ttl_response_t* p, struct dust_dn2500_unknown_data_t* un); 
.................... int8_t dust_dn2500_setnv_hart_antenna_gain(void* handle, struct dust_dn2500_setnv_hart_antenna_gain_response_t* p, struct dust_dn2500_unknown_data_t* un); 
.................... int8_t dust_dn2500_setnv_otap_lockout(void* handle, struct dust_dn2500_setnv_otap_lockout_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................  
.................... // motes response packets received by sensor processor 
.................... int8_t dust_dn2500_send_response(void* handle, struct dust_dn2500_send_response_t* p, struct dust_dn2500_unknown_data_t* un); 
.................... int8_t dust_dn2500_join_response(void* handle, struct dust_dn2500_join_response_t* p, struct dust_dn2500_unknown_data_t* un); 
.................... int8_t dust_dn2500_disconnect_response(void* handle, struct dust_dn2500_disconnect_response_t* p, struct dust_dn2500_unknown_data_t* un); 
.................... int8_t dust_dn2500_search_response(void* handle, struct dust_dn2500_search_response_t* p, struct dust_dn2500_unknown_data_t* un); 
.................... int8_t dust_dn2500_reset_response(void* handle, struct dust_dn2500_reset_response_t* p, struct dust_dn2500_unknown_data_t* un); 
.................... int8_t dust_dn2500_lowPowerSleep_response(void* handle, struct dust_dn2500_lowPowerSleep_response_t* p, struct dust_dn2500_unknown_data_t* un); 
.................... int8_t dust_dn2500_testRadioTx_response(void* handle, struct dust_dn2500_testRadioTx_response_t* p, struct dust_dn2500_unknown_data_t* un); 
.................... int8_t dust_dn2500_testRadioRx_response(void* handle, struct dust_dn2500_testRadioRx_response_t* p, struct dust_dn2500_unknown_data_t* un); 
.................... int8_t dust_dn2500_clearnv_response(void* handle, struct dust_dn2500_clearnv_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................  
.................... // Mote request packets received by sensor processor 
.................... int8_t dust_dn2500_time_request(void* handle, struct dust_dn2500_time_request_t* p, struct dust_dn2500_unknown_data_t* un); 
.................... int8_t dust_dn2500_service_indication(void* handle, struct dust_dn2500_service_indication_t* p, struct dust_dn2500_unknown_data_t* un); 
.................... int8_t dust_dn2500_events_request(void* handle, struct dust_dn2500_events_request_t* p, struct dust_dn2500_unknown_data_t* un); 
.................... int8_t dust_dn2500_data_request(void* handle, struct dust_dn2500_data_request_t* p, struct dust_dn2500_unknown_data_t* un); 
.................... int8_t dust_dn2500_unknown_command(void* handle, uint8_t* data, uint8_t len); 
....................  
.................... */ 
....................  
.................... #include "globals.h"                                
.................... // globals.h 
.................... // 
.................... // This file contains all of the global variables used in the firmware 
.................... //  
.................... // Add to this list carefull and keep it syncronized with vars_init().....                
....................            
.................... ////////////////////Global Variables Table of Contents///////////////////////// 
.................... //Test Globals 
.................... //LCD Globals 
.................... //Time Globals                                                                            
.................... //System Parameter Globals 
.................... //Hardware Enabled Globals                                
.................... //Control Related Globals                  
.................... //Valve Related Globals                                         
.................... //Mote Globals 
.................... //Priority Queue 
.................... //Time Queue                                                               
.................... //Sprinkler Stack                                                                                                 
.................... //Command Stack                     
.................... //System State Globals 
....................  
.................... //Where to put?                                                
.................... uint32_t global_last_connected_time = 0;         
.................... uint16_t global_xdcr_output = 0;                             
....................                                    
.................... // global that keeps track of why the system restarted/shutdown 
.................... uint8_t global_shutdown_cause = 0; 
.................... uint8_t global_previous_shutdown_cause = 0; 
....................  
.................... char global_firmware_version_string[5] = {'A','0','0','0',0};       
....................  
.................... ////////////////////Test Globals/////////////////////////////////////////////// 
.................... uint8_t test_global = 0; 
.................... uint8_t test_global_2 = 0; 
.................... uint32_t test_start_time = 0; 
.................... uint32_t test_end_time = 0; 
.................... uint16_t test_valve_open_1 = 0; 
.................... uint16_t test_rpm_1 = 0; 
.................... uint16_t test_duty_cycle_1 = 0; 
.................... uint16_t test_valve_open_2 = 0; 
.................... uint16_t test_rpm_2 = 0; 
.................... uint16_t test_duty_cycle_2 = 0; 
.................... uint16_t test_valve_open_3 = 0; 
.................... uint16_t test_rpm_3 = 0; 
.................... uint16_t test_duty_cycle_3 = 0; 
....................  
....................   
.................... ////////////////////LCD Globals//////////////////////////////////////////////// 
.................... unsigned char global_temp_line_buff[17]; 
.................... char* global_extra_lcd_ptr; 
....................                      
.................... // LCD skip update flag 
.................... // 0 = don't skip 
.................... // 1 = Last update skipped, clear screen and proceed as normal 
.................... // 2-255 = how many skips (plus 1) to skip.  LCD is updated 1/sec, so 4 =  
.................... //    3 seconds of skipping updates. 
.................... uint8_t     global_skip_lcd_update_count = 0;        
....................  
.................... // Current LCD page number 
.................... // 0 = don't display anything? 
.................... // 1-TOTAL_LCD_PAGES = display that page number     
.................... uint8_t     global_lcd_page_number = 1;       
....................                    
.................... ////////////////////Time Globals/////////////////////////////////////////////// 
.................... // keeps track of time since microprocessor has been awake in seconds 
.................... uint32_t global_rtc_time = 0; 
.................... // keeps track of the time within the mote system (taken from mote) 
.................... uint32_t global_utc_time = 0; 
.................... // keeps track of when SW1 was last depressed (for recognition of long press event) 
.................... uint32_t sw1_start_time = 0;   
.................... ////////////////////System Parameter Globals/////////////////////////////////// 
.................... uint16_t global_sprinkler_num = 0; 
....................  
.................... // More globals that we might actually want to keep 
.................... uint8_t     serial_number_rcvd[8] = {0,0,0,0,0,0,0,0}; 
.................... uint8_t     macaddr_rcvd[8] = {0,0,0,0,0,0,0,0}; 
....................  
.................... ////////////////////Hardware Enabled Globals/////////////////////////////////// 
.................... uint8_t  global_hardware_enabled = 0;                                                                
....................    #BIT  global_lcd_enabled         = global_hardware_enabled.0 
....................    #BIT  global_gps_enabled         = global_hardware_enabled.1 
....................    #BIT  global_xcdr_type1_enabled  = global_hardware_enabled.2 
....................    #BIT  global_xcdr_type2_enabled  = global_hardware_enabled.3 
....................    #BIT  global_fixture_enabled     = global_hardware_enabled.4 
....................    #BIT  global_temp1_enabled       = global_hardware_enabled.5 
....................    #BIT  global_dust_enabled        = global_hardware_enabled.6 
....................    #BIT  global_dust_operational    = global_hardware_enabled.7 
....................  
.................... ////////////////////Control Related Globals//////////////////////////////////// 
.................... // keeps track of rpms (updated via interrupt routine) 
.................... uint16_t global_current_period = 0; 
.................... uint16_t global_current_rpm; 
.................... uint16_t global_rpm_set_value = 100; 
.................... uint32_t global_last_rpm_value_time = 0; 
....................  
.................... // keeps track of duty cycles of brake and charge 
.................... uint16_t global_brake_duty = 0; 
.................... uint16_t global_charge_duty = MAX_CHARGE; 
.................... // keeps track of set points for brake and charge duty cycles 
.................... uint16_t global_brake_duty_set_value = 0; 
.................... uint16_t global_charge_duty_set_value = MAX_CHARGE; 
....................  
.................... // keeps track of mppc level 
.................... uint8_t  global_mppc_value = 100; 
.................... uint8_t  global_mppc_set_value = 100; 
.................... // keeps track of vgen 
.................... uint16_t global_vgen = 0; 
.................... // keeps track of fixture dac value 
.................... uint16_t global_fixture_dac_value = NO_FIXTURE; 
....................  
.................... // specifies how the rpm is being controlled (see defines for more info) 
.................... uint8_t global_control_loop_mechanism = NO_RPM_CONTROL_DYN_MPPC; 
.................... // JG: set to brake and charge for testing purposes Feb 2, 2017 
.................... //uint8_t global_control_loop_mechanism = BRAKE_AND_CHARGE_START; 
....................  
.................... ////////////////////Valve Related Globals////////////////////////////////////// 
.................... // keeps track of current valve position 
.................... uint16_t global_valve_position = VLV_PRECALIBRAION_POSITION;    
.................... // valve position set point 
.................... uint16_t global_valve_position_set_value = VLV_PRECALIBRAION_POSITION;    
....................                                 
.................... // 1/1024th of the time to go from open to close calculated by calibrate valve    
.................... //     routine in units of 2ndary oscillator ticks 
.................... uint16_t global_valve_time_to_close_1024th = DEFAULT_VLV_TIME_TO_CLOSE; 
.................... // 1/1024th of the time to go from close to open calculated by calibrate valve   
.................... //    routine in units of 2ndary oscillator ticks 
.................... uint16_t global_valve_time_to_open_1024th = DEFAULT_VLV_TIME_TO_OPEN; 
.................... // amount of time the valve has been in motion in units of 1/1024ths of a 
.................... //    millispan.  So, not really time, but distance. 
.................... uint16_t global_valve_time_in_motion_1024ths = 0; 
.................... // when the last valve calibration was done, in utc time 
.................... uint32_t global_valve_calibration_utc_time = 0; 
.................... // number of movements since last calibration/endstop  
.................... uint8_t  global_valve_movements_since_endstop = 0; 
....................  
.................... // calibrate FSR valve position (default is 0x2000, but should be set by message) 
.................... uint16_t global_calibrate_fsr_valve_position = 0x2000; 
.................... // calibrate FSR outcome in period (inverse of rpm).  Default/unknown is 0-1 
.................... uint16_t global_calibrate_fsr_period = 0-1; 
.................... // when the last fsr calibration was done, in utc time 
.................... uint32_t global_calibrate_fsr_utc_time = 0; 
....................  
.................... ////////////////////Mote Globals/////////////////////////////////////////////// 
.................... //event flags defined by mote 
.................... uint8_t  event_flags; 
....................    #BIT  fl_boot_event           = event_flags.0 
....................    #BIT  fl_alarm_event          = event_flags.1 
....................    #BIT  fl_time_event           = event_flags.2 
....................    #BIT  fl_joinfail_event       = event_flags.3 
....................    #BIT  fl_disconnected_event   = event_flags.4 
....................    #BIT  fl_operational_event    = event_flags.5 
....................    #BIT  fl_config_event         = event_flags.6 
....................    #BIT  fl_unknown_event        = event_flags.7 
....................  
.................... // Note that bytes_from_mote union contains the stripped unstuffed data 
.................... //  eg, bytes_from_mote.dust_rcvd[128] 
.................... mote_to_micro  bytes_from_mote; 
.................... mote_to_micro* p; 
....................  
.................... // It just can't get bigger than this! 
.................... // pkgen places message to be sent here 
.................... char        dust_send_buffer[MAX_SEND_BUFFER]; 
....................  
.................... // this is only for doing acks and only needs to be  
.................... // MAX_USER_DATA_SIZE*2 + 2 + 4 + 12 + 2 
.................... // MAX_USER_DATA_SIZE is 2 bytes for ack 
.................... char        dust_send_buffer_isr[2*2 + 2 + 4 + 12 + 2]; 
....................  
.................... // THIS is the buffer for RAW rcvd mote 
.................... //  mote packet data 
.................... char        dust_recive_buffer[MAX_RCV_BUFFER + 1]; 
....................  
.................... //  this is place 
.................... //  where the packet to be sent by micro 
.................... //  to NETWORK manager is placed prior 
.................... //  to dust_send_data call 
.................... char        payload_buff[MAX_USER_DATA_SIZE]; 
....................  
.................... // Keeps track of how many bytes to send and passed between pkgen and pksend 
.................... uint8_t num_of_bytes_to_send = 0; 
.................... uint8_t num_of_bytes_to_send_isr = 0; 
....................  
.................... // This is specific to the subroutine 
.................... //  pkgen_send() which creates the message 
.................... //  to be sent from the mote to the net                      
.................... uint8_t     send_prefix[12]; 
....................  
.................... // send_prefix[11] will be set to number of bytes in packet 
.................... // The send_prefix structure is as follows: 
.................... // [0]      CMD_SEND 
.................... // [1]      length of request       - this is payload length + 9 
.................... // [2]      FLAG_SEND_REQUEST 
.................... // [3]/[4]  destination address     - always DESTADDR_HI, DESTADDR_LO 
.................... // [5]      svc_index               - get this from service indication received 
.................... //                                     at join time 
.................... // [6]      APPDOMAIN_MAINTENANCE 
.................... // [7]      PRIORITY_HIGH 
.................... // [8][9]   reserved                - 0x00, 0x00  
.................... // [10]     sequence_num            - always 0xFF for mote-originated packets 
.................... // [11]     payload length          - length of the payload in bytes 
....................  
....................  
.................... // For ensuring a message was recieved properly from mote 
.................... uint8_t result_rcvd = 0; 
....................  
.................... // JG Jan 2017 
.................... int1 fl_alt_LCD; 
....................  
.................... // Flag for going through deal with mote ISR and going to sleep afterwards 
.................... int1 fl_mote_dealt; 
....................  
.................... // Flag for a sucessful get/set response eliminating a few other flags 
.................... int1  global_set_get_response; 
....................  
.................... // FLAGS TO GET RID OF! 
.................... // Flag for receiving an advertisment 
.................... int1  advert_rcvd_fl; 
.................... int1  setnetid_done_fl; 
.................... int1  ack_sent_fl; 
.................... int1  pkt_rcvd_fl; 
.................... int1  joinduty_done_fl; 
.................... int1  gettime_done_fl; 
.................... int1  fl_batNOEE; 
.................... int1  joinkey_done_fl; 
.................... int1  joincmd_done_fl; 
....................  
.................... uint8_t flags_rcvd = 0 ,param_type_rcvd = 0, svc_index_rcvd=0; 
.................... uint16_t mote_msgSEQ = 0; 
....................  
.................... //Globals for when advertisements are received 
.................... uint16_t network_id_rcvd = NETWORK_ID_DEF; 
.................... uint16_t mote_id_rcvd = 0; 
.................... int8_t rssi_rcvd = 0; 
.................... uint8_t hop_depth_rcvd = 0; 
....................  
.................... // global variable that keeps track of the current temperature of the mote.   
.................... //    It is updated every MOTE_CHECKS_TIME seconds 
.................... int8_t global_mote_temperature = 0; 
....................  
.................... ////////////////////Priority Queue///////////////////////////////////////////// 
.................... // Actual priority queue 
.................... volatile uint8_t global_priority_queue[MAX_PRIORITY_QUEUE_ITEMS] = {0}; 
.................... volatile uint8_t global_current_priority_queue_location = (0-1); 
....................  
.................... ////////////////////Time Queue///////////////////////////////////////////////// 
.................... // Actual time queue 
.................... struct TimeQueueItem global_time_queue[MAX_TIME_QUEUE_ITEMS] = {0}; 
.................... uint8_t global_current_time_queue_location = (0-1); 
....................  
.................... ////////////////////Sprinkler Queue//////////////////////////////////////////// 
.................... // Actual sprinkler queue 
.................... struct SprinklerQueueItem global_sprinkler_queue[MAX_SPRINKLER_QUEUE_ITEMS] = {0}; 
.................... uint8_t global_current_sprinkler_queue_location = (0-1); 
.................... // when the current sprinkler command is supposed to end 
.................... uint32_t global_current_sprinkler_settings_end_time = (0-1); 
....................  
.................... ////////////////////Command Queue////////////////////////////////////////////// 
.................... // Actual command queue              
.................... struct CommandQueueItem global_command_queue[MAX_COMMAND_QUEUE_ITEMS] = {0}; 
.................... uint8_t global_current_command_queue_location = (0-1); 
....................  
.................... ////////////////////Message Queue////////////////////////////////////////////// 
.................... // Actual command queue                 
.................... struct MessageQueueItem global_message_queue[MAX_MESSAGE_QUEUE_ITEMS] = {0}; 
.................... uint8_t global_current_message_queue_location = (0-1); 
.................... // global variable that stores the current errors encountered that will be sent 
.................... //    to the manager via an unsolicited error message 
.................... uint32_t global_error_message_bitfield = 0; 
....................  
.................... // the last error message's bitfield and send time for stopping reoccuring error messages 
.................... uint32_t last_error_message_sent_bitfield = 0; 
.................... uint32_t last_error_message_sent_rtc_time = 0; 
....................  
.................... ////////////////////System State Variables///////////////////////////////////// 
.................... uint8_t global_mote_state = MOTESTATE_UNKNOWN; 
.................... uint8_t global_system_state = SYSTEM_STATE_UNKNOWN; 
....................  
.................... ////////////////////Misc/////////////////////////////////////////////////////// 
....................  
....................  
.................... #include "eeprom.h" 
.................... // EEPROM.h 
.................... // This contains all things related to the EEPROM 
.................... // -functions 
.................... // -#defines for memory locations 
.................... // -#defines conveted to eeprom values to load/store out of EEPROM 
....................  
.................... ////////////////////EEPROM Locations Start/////////////////////////////////////////////////////////////  
....................                                                              
.................... // start of EEPROM locations 
.................... #define EE_START_LOCATION     0x0000 
.................... // Location ID                                                                    
.................... #define EE_SPRINKLER_NUM      0x0000 
.................... // Cause for shutdown/restart 
.................... #define EE_RESTART_CAUSE      0x0002                                               
.................... // Last valve calibrations and time            
.................... #define EE_VLV_TIME_TO_OPEN   0x0004                                      
.................... #define EE_VLV_TIME_TO_CLOSE  0x0006                                             
.................... #define EE_VLV_CAL_UTC_TIME   0x0008                                     
.................... // Last valve position 
.................... #define EE_VLV_POSITION       0x000C                                                    
....................                   
.................... // start of eeprom changable variables                                             
.................... #define EE_VLV_NEAR_CLOSED_RANGE_MAX 0x000E 
.................... #define EE_VLV_NEAR_OPENED_RANGE_MAX 0x0010               
.................... #define EE_DAC_LVL_OPENING_NEAR_OPENED 0x0012   
.................... #define EE_DAC_LVL_OPENING_NEAR_CLOSED 0x0014   
.................... #define EE_DAC_LVL_CLOSING_NEAR_OPENED 0x0016   
.................... #define EE_DAC_LVL_CLOSING_NEAR_CLOSED 0x0018   
.................... #define EE_DAC_LVL_IN_MIDDLE 0x001A 
.................... #define EE_DAC_LVL_INIT_CURRENT_BOOST 0x001C 
.................... #define EE_VLV_INIT_CURRENT_BOOST_TIME_1024THS 0x001E  
.................... #define EE_VLV_NOT_SPIN_LIMIT 0x0020   
.................... #define EE_VLV_NOT_SPIN_FIX 0x0022   
.................... #define EE_NOT_SPINNING_MAG_DECOUPLING_RPM_FIXED 0x0024   
.................... #define EE_VLV_MAGNETIC_COUPLING_LIMIT 0x0026   
.................... #define EE_VLV_MAGNETIC_COUPLING_FIX 0x0028   
.................... #define EE_RPM_TIMEOUT 0x002A 
.................... #define EE_MOTE_SEARCH_TIME 0x002C 
.................... #define EE_MOTE_NETWORK_SHUTDOWN_TIMEOUT 0x002E                                         
.................... // end of eeprom changeable variables 
....................  
.................... // last byte of EEPROM used 
.................... #define EE_END_LOCATION       0x002F     
....................                                           
....................  
.................... ////////////////////EEPROM Locations End/////////////////////////////////////////////////////////////// 
....................  
....................  ////////////////////EEPROM defines->globals Start//////////////////////////////////////////////////////   
.................... // Maximum value of "near closed" range 
.................... uint16_t VLV_NEAR_CLOSED_RANGE_MAX = 0x1000; 
.................... // Maximum value of "near opened" range 
.................... uint16_t VLV_NEAR_OPENED_RANGE_MAX =   0x7000;     
....................                                             
.................... // DAC level while opening near the fully open end 
.................... uint16_t DAC_LVL_OPENING_NEAR_OPENED =      24; 
.................... // DAC level while opening near the fully closed end 
.................... uint16_t DAC_LVL_OPENING_NEAR_CLOSED =      20;    
.................... // DAC level while closing near the fully open end 
.................... uint16_t DAC_LVL_CLOSING_NEAR_OPENED =      20; 
.................... // DAC level while closing near the fully closed end                         
.................... uint16_t DAC_LVL_CLOSING_NEAR_CLOSED =      24;  
.................... // DAC level while moving in the middle of the valve range and it's default 
.................... uint16_t DAC_LVL_IN_MIDDLE =                19;  
.................... // DAC level for the inital current boost/lowered current limit   
.................... uint16_t DAC_LVL_INIT_CURRENT_BOOST =       19;      
....................                                                             
.................... // Amount of millispans that a current boost/lovered dac level is implemented. 
.................... //    This is done outside of the (NEAR_CLOSED/OPEN_RANGE)    
.................... //    @ 45 seconds to close, 30 = 1.3 seconds 
.................... uint16_t VLV_INIT_CURRENT_BOOST_TIME_1024THS =  30;   
....................                                                
.................... // valve not-spinning and magnetic de-coupling defines                                                     
.................... // below this number is the regime where we watch for the not spinning case (low torque)  
.................... uint16_t VLV_NOT_SPIN_LIMIT =               0x4000; 
.................... // where we send the valve when we want to fix it.  If it gets fixed before reaching this valve position 
.................... //    it stops. If it does not get fixed by the time it reaches this position, it sends an error and stops. 
.................... uint16_t VLV_NOT_SPIN_FIX =                 0x7000; 
....................                                                
.................... // above this rpm, consider magnetic coupling or not-spinning fixed 
.................... uint8_t NOT_SPINNING_MAG_DECOUPLING_RPM_FIXED =  8;        
....................                                                    
.................... // above this number is the regime where we watch for the magnetic decoupling 
.................... uint16_t VLV_MAGNETIC_COUPLING_LIMIT =      0x5000;        
.................... // where to move the valve at a time when trying to recover  
.................... uint16_t VLV_MAGNETIC_COUPLING_FIX =        0x1000;              
.................... // amount to move the valve at a time when trying to recover    
....................                                                                            
.................... // how many seconds it takes to consider the rpm to be zero (or infinite for higher valve settings) 
.................... // 8 = 7.5 RPM (8 may be max of what ccp5 can handle without overflow)    
.................... // JG SAYS that RPM_TIMEOUT of 2 makes more sense because 
.................... //  any time which exceeds 1 second indicates that the RPM is less than 1.2, 
.................... //  a very low number which we can consider to equal 0. 
.................... uint16_t RPM_TIMEOUT =                     2; 
....................                                         
.................... // amount of seconds for mote to stay searching for advertisements                     
.................... uint16_t MOTE_SEARCH_TIME = 120;        
.................... // amount of time the mote will stay disconnected from the network before shutting down (1200 = 20 min)                                    
.................... uint16_t MOTE_NETWORK_SHUTDOWN_TIMEOUT = 1200;                      
....................  
.................... ////////////////////EEPROM defines->globals End////////////////////////////////////////////////////////  
....................   
.................... ////////////////////EEPROM Functions Start/////////////////////////////////////////////////////////////  
.................... uint8_t read_ee1(uint16_t source) 
.................... {                                                                  
....................    return read_eeprom(source); 
*
03266:  MOVFF  FF2,552
0326A:  BCF    FF2.7
0326C:  MOVFF  551,FAA
03270:  MOVFF  550,FA9
03274:  BCF    FA6.6
03276:  BCF    FA6.7
03278:  BSF    FA6.0
0327A:  MOVF   FA8,W
0327C:  MOVLB  5
0327E:  BTFSC  x52.7
03280:  BSF    FF2.7
03282:  MOVWF  01
03284:  MOVLB  0
03286:  RETURN 0
.................... }                 
.................... uint16_t read_ee2(uint16_t source) 
.................... { 
....................    return (make16(read_eeprom(source+1), read_eeprom(source))); 
*
03196:  MOVLW  01
03198:  MOVLB  5
0319A:  ADDWF  x50,W
0319C:  MOVWF  x52
0319E:  MOVLW  00
031A0:  ADDWFC x51,W
031A2:  MOVWF  x53
031A4:  MOVFF  FF2,554
031A8:  BCF    FF2.7
031AA:  MOVFF  553,FAA
031AE:  MOVFF  552,FA9
031B2:  BCF    FA6.6
031B4:  BCF    FA6.7
031B6:  BSF    FA6.0
031B8:  MOVF   FA8,W
031BA:  BTFSC  x54.7
031BC:  BSF    FF2.7
031BE:  MOVWF  x52
031C0:  MOVFF  FF2,553
031C4:  BCF    FF2.7
031C6:  MOVFF  551,FAA
031CA:  MOVFF  550,FA9
031CE:  BCF    FA6.6
031D0:  BCF    FA6.7
031D2:  BSF    FA6.0
031D4:  MOVF   FA8,W
031D6:  BTFSC  x53.7
031D8:  BSF    FF2.7
031DA:  MOVWF  x55
031DC:  MOVFF  552,03
031E0:  MOVF   x55,W
031E2:  MOVWF  01
031E4:  MOVF   03,W
031E6:  MOVWF  02
031E8:  MOVLB  0
031EA:  RETURN 0
.................... }  
.................... uint32_t read_ee4(uint16_t source) 
.................... { 
....................    return (make32(read_eeprom(source+3), read_eeprom(source+2), read_eeprom(source+1), read_eeprom(source))); 
*
032BA:  MOVLW  03
032BC:  MOVLB  5
032BE:  ADDWF  x50,W
032C0:  MOVWF  x52
032C2:  MOVLW  00
032C4:  ADDWFC x51,W
032C6:  MOVWF  x53
032C8:  MOVFF  FF2,554
032CC:  BCF    FF2.7
032CE:  MOVFF  553,FAA
032D2:  MOVFF  552,FA9
032D6:  BCF    FA6.6
032D8:  BCF    FA6.7
032DA:  BSF    FA6.0
032DC:  MOVF   FA8,W
032DE:  BTFSC  x54.7
032E0:  BSF    FF2.7
032E2:  MOVWF  x52
032E4:  MOVLW  02
032E6:  ADDWF  x50,W
032E8:  MOVWF  x55
032EA:  MOVLW  00
032EC:  ADDWFC x51,W
032EE:  MOVWF  x56
032F0:  MOVFF  FF2,553
032F4:  BCF    FF2.7
032F6:  MOVFF  556,FAA
032FA:  MOVFF  555,FA9
032FE:  BCF    FA6.6
03300:  BCF    FA6.7
03302:  BSF    FA6.0
03304:  MOVF   FA8,W
03306:  BTFSC  x53.7
03308:  BSF    FF2.7
0330A:  MOVWF  x55
0330C:  MOVLW  01
0330E:  ADDWF  x50,W
03310:  MOVWF  x56
03312:  MOVLW  00
03314:  ADDWFC x51,W
03316:  MOVWF  x57
03318:  MOVFF  FF2,558
0331C:  BCF    FF2.7
0331E:  MOVFF  557,FAA
03322:  MOVFF  556,FA9
03326:  BCF    FA6.6
03328:  BCF    FA6.7
0332A:  BSF    FA6.0
0332C:  MOVF   FA8,W
0332E:  BTFSC  x58.7
03330:  BSF    FF2.7
03332:  MOVWF  x56
03334:  MOVFF  FF2,557
03338:  BCF    FF2.7
0333A:  MOVFF  551,FAA
0333E:  MOVFF  550,FA9
03342:  BCF    FA6.6
03344:  BCF    FA6.7
03346:  BSF    FA6.0
03348:  MOVF   FA8,W
0334A:  BTFSC  x57.7
0334C:  BSF    FF2.7
0334E:  MOVWF  x59
03350:  MOVFF  552,03
03354:  MOVFF  555,02
03358:  MOVFF  556,01
0335C:  MOVFF  559,00
03360:  MOVLB  0
03362:  RETURN 0
.................... } 
....................  
.................... void write_ee1(uint16_t dest, uint8_t dat8) 
.................... { 
....................    write_eeprom(dest, dat8); 
*
03288:  MOVF   FF2,W
0328A:  MOVWF  00
0328C:  BCF    FF2.7
0328E:  MOVFF  551,FAA
03292:  MOVFF  550,FA9
03296:  MOVFF  552,FA8
0329A:  BCF    FA6.6
0329C:  BCF    FA6.7
0329E:  BSF    FA6.2
032A0:  MOVLB  F
032A2:  MOVLW  55
032A4:  MOVWF  FA7
032A6:  MOVLW  AA
032A8:  MOVWF  FA7
032AA:  BSF    FA6.1
032AC:  BTFSC  FA6.1
032AE:  BRA    32AC
032B0:  BCF    FA6.2
032B2:  MOVF   00,W
032B4:  IORWF  FF2,F
032B6:  MOVLB  0
032B8:  RETURN 0
.................... } 
....................  
.................... void write_ee2(uint16_t dest, uint16_t dat16) 
.................... { 
....................    write_eeprom(dest++, make8(dat16,0)); 
*
031EC:  MOVLB  5
031EE:  MOVF   x53,W
031F0:  MOVWF  03
031F2:  MOVF   x52,W
031F4:  INCF   x52,F
031F6:  BTFSC  FD8.2
031F8:  INCF   x53,F
031FA:  MOVWF  x56
031FC:  MOVFF  03,557
03200:  MOVFF  554,558
03204:  MOVF   FF2,W
03206:  MOVWF  00
03208:  BCF    FF2.7
0320A:  MOVFF  557,FAA
0320E:  MOVFF  556,FA9
03212:  MOVFF  558,FA8
03216:  BCF    FA6.6
03218:  BCF    FA6.7
0321A:  BSF    FA6.2
0321C:  MOVLB  F
0321E:  MOVLW  55
03220:  MOVWF  FA7
03222:  MOVLW  AA
03224:  MOVWF  FA7
03226:  BSF    FA6.1
03228:  BTFSC  FA6.1
0322A:  BRA    3228
0322C:  BCF    FA6.2
0322E:  MOVF   00,W
03230:  IORWF  FF2,F
....................    write_eeprom(dest, make8(dat16,1)); 
03232:  MOVFF  555,556
03236:  MOVFF  FF2,00
0323A:  BCF    FF2.7
0323C:  MOVFF  553,FAA
03240:  MOVFF  552,FA9
03244:  MOVFF  555,FA8
03248:  BCF    FA6.6
0324A:  BCF    FA6.7
0324C:  BSF    FA6.2
0324E:  MOVLW  55
03250:  MOVWF  FA7
03252:  MOVLW  AA
03254:  MOVWF  FA7
03256:  BSF    FA6.1
03258:  BTFSC  FA6.1
0325A:  BRA    3258
0325C:  BCF    FA6.2
0325E:  MOVF   00,W
03260:  IORWF  FF2,F
03262:  MOVLB  0
03264:  RETURN 0
.................... } 
....................  
.................... void write_ee4(uint16_t dest, uint32_t dat32) 
.................... { 
....................    write_eeprom(dest++, make8(dat32,0)); 
*
06AB6:  MOVLB  5
06AB8:  MOVF   x55,W
06ABA:  MOVWF  03
06ABC:  MOVF   x54,W
06ABE:  INCF   x54,F
06AC0:  BTFSC  FD8.2
06AC2:  INCF   x55,F
06AC4:  MOVWF  x5A
06AC6:  MOVFF  03,55B
06ACA:  MOVFF  556,55C
06ACE:  MOVF   FF2,W
06AD0:  MOVWF  00
06AD2:  BCF    FF2.7
06AD4:  MOVFF  55B,FAA
06AD8:  MOVFF  55A,FA9
06ADC:  MOVFF  55C,FA8
06AE0:  BCF    FA6.6
06AE2:  BCF    FA6.7
06AE4:  BSF    FA6.2
06AE6:  MOVLB  F
06AE8:  MOVLW  55
06AEA:  MOVWF  FA7
06AEC:  MOVLW  AA
06AEE:  MOVWF  FA7
06AF0:  BSF    FA6.1
06AF2:  BTFSC  FA6.1
06AF4:  BRA    6AF2
06AF6:  BCF    FA6.2
06AF8:  MOVF   00,W
06AFA:  IORWF  FF2,F
....................    write_eeprom(dest++, make8(dat32,1)); 
06AFC:  MOVLB  5
06AFE:  MOVF   x55,W
06B00:  MOVWF  03
06B02:  MOVF   x54,W
06B04:  INCF   x54,F
06B06:  BTFSC  FD8.2
06B08:  INCF   x55,F
06B0A:  MOVWF  x5A
06B0C:  MOVFF  03,55B
06B10:  MOVFF  557,55C
06B14:  MOVF   FF2,W
06B16:  MOVWF  00
06B18:  BCF    FF2.7
06B1A:  MOVFF  55B,FAA
06B1E:  MOVFF  55A,FA9
06B22:  MOVFF  55C,FA8
06B26:  BCF    FA6.6
06B28:  BCF    FA6.7
06B2A:  BSF    FA6.2
06B2C:  MOVLB  F
06B2E:  MOVLW  55
06B30:  MOVWF  FA7
06B32:  MOVLW  AA
06B34:  MOVWF  FA7
06B36:  BSF    FA6.1
06B38:  BTFSC  FA6.1
06B3A:  BRA    6B38
06B3C:  BCF    FA6.2
06B3E:  MOVF   00,W
06B40:  IORWF  FF2,F
....................    write_eeprom(dest++, make8(dat32,2)); 
06B42:  MOVLB  5
06B44:  MOVF   x55,W
06B46:  MOVWF  03
06B48:  MOVF   x54,W
06B4A:  INCF   x54,F
06B4C:  BTFSC  FD8.2
06B4E:  INCF   x55,F
06B50:  MOVWF  x5A
06B52:  MOVFF  03,55B
06B56:  MOVFF  558,55C
06B5A:  MOVF   FF2,W
06B5C:  MOVWF  00
06B5E:  BCF    FF2.7
06B60:  MOVFF  55B,FAA
06B64:  MOVFF  55A,FA9
06B68:  MOVFF  55C,FA8
06B6C:  BCF    FA6.6
06B6E:  BCF    FA6.7
06B70:  BSF    FA6.2
06B72:  MOVLB  F
06B74:  MOVLW  55
06B76:  MOVWF  FA7
06B78:  MOVLW  AA
06B7A:  MOVWF  FA7
06B7C:  BSF    FA6.1
06B7E:  BTFSC  FA6.1
06B80:  BRA    6B7E
06B82:  BCF    FA6.2
06B84:  MOVF   00,W
06B86:  IORWF  FF2,F
....................    write_eeprom(dest, make8(dat32,3)); 
06B88:  MOVFF  559,55A
06B8C:  MOVFF  FF2,00
06B90:  BCF    FF2.7
06B92:  MOVFF  555,FAA
06B96:  MOVFF  554,FA9
06B9A:  MOVFF  559,FA8
06B9E:  BCF    FA6.6
06BA0:  BCF    FA6.7
06BA2:  BSF    FA6.2
06BA4:  MOVLW  55
06BA6:  MOVWF  FA7
06BA8:  MOVLW  AA
06BAA:  MOVWF  FA7
06BAC:  BSF    FA6.1
06BAE:  BTFSC  FA6.1
06BB0:  BRA    6BAE
06BB2:  BCF    FA6.2
06BB4:  MOVF   00,W
06BB6:  IORWF  FF2,F
06BB8:  MOVLB  0
06BBA:  RETURN 0
.................... }                                              
....................  
.................... void store_all_eeprom_values(void) 
.................... {                                                                                                   
....................  
....................    // store valve calibration times in EEPROM 
....................    write_ee2(EE_VLV_TIME_TO_OPEN, global_valve_time_to_open_1024th); 
*
09D16:  MOVLB  5
09D18:  CLRF   x53
09D1A:  MOVLW  04
09D1C:  MOVWF  x52
09D1E:  MOVFF  C4,555
09D22:  MOVFF  C3,554
09D26:  MOVLB  0
09D28:  CALL   31EC
....................    write_ee2(EE_VLV_TIME_TO_CLOSE, global_valve_time_to_close_1024th); 
09D2C:  MOVLB  5
09D2E:  CLRF   x53
09D30:  MOVLW  06
09D32:  MOVWF  x52
09D34:  MOVFF  C2,555
09D38:  MOVFF  C1,554
09D3C:  MOVLB  0
09D3E:  CALL   31EC
....................    write_ee4(EE_VLV_CAL_UTC_TIME, global_valve_calibration_utc_time); 
09D42:  MOVLB  5
09D44:  CLRF   x55
09D46:  MOVLW  08
09D48:  MOVWF  x54
09D4A:  MOVFF  CA,559
09D4E:  MOVFF  C9,558
09D52:  MOVFF  C8,557
09D56:  MOVFF  C7,556
09D5A:  MOVLB  0
09D5C:  CALL   6AB6
....................    write_ee2(EE_VLV_POSITION, global_valve_position); 
09D60:  MOVLB  5
09D62:  CLRF   x53
09D64:  MOVLW  0C
09D66:  MOVWF  x52
09D68:  MOVFF  BE,555
09D6C:  MOVFF  BD,554
09D70:  MOVLB  0
09D72:  CALL   31EC
....................    // save the shutdown/restart reason in EEPROM 
....................    write_ee1(EE_RESTART_CAUSE, global_shutdown_cause);                                         
09D76:  MOVLB  5
09D78:  CLRF   x51
09D7A:  MOVLW  02
09D7C:  MOVWF  x50
09D7E:  MOVFF  4D,552
09D82:  MOVLB  0
09D84:  CALL   3288
09D88:  RETURN 0
....................                                                                          
.................... } 
....................  
....................  
.................... void read_all_eeprom_values(void) 
.................... { 
....................    // if EEPROM is freshly flashed, overwrite sprinkler number with 0 
....................    if (read_ee2(EE_SPRINKLER_NUM) == 0xFFFF) write_ee2(EE_SPRINKLER_NUM,0);      
*
03364:  MOVLB  5
03366:  CLRF   x51
03368:  CLRF   x50
0336A:  MOVLB  0
0336C:  RCALL  3196
0336E:  MOVFF  02,548
03372:  MOVFF  01,547
03376:  MOVLB  5
03378:  INCFSZ 01,W
0337A:  BRA    338E
0337C:  INCFSZ x48,W
0337E:  BRA    338E
03380:  CLRF   x53
03382:  CLRF   x52
03384:  CLRF   x55
03386:  CLRF   x54
03388:  MOVLB  0
0338A:  RCALL  31EC
0338C:  MOVLB  5
....................    // pull the sprinkler number from EEPROM  
....................    global_sprinkler_num = read_ee2(EE_SPRINKLER_NUM); 
0338E:  CLRF   x51
03390:  CLRF   x50
03392:  MOVLB  0
03394:  RCALL  3196
03396:  MOVFF  02,92
0339A:  MOVFF  01,91
....................    // grab the shutdown cause and overwrite it for next time 
....................    global_previous_shutdown_cause = read_ee1(EE_RESTART_CAUSE); 
0339E:  MOVLB  5
033A0:  CLRF   x51
033A2:  MOVLW  02
033A4:  MOVWF  x50
033A6:  MOVLB  0
033A8:  RCALL  3266
033AA:  MOVFF  01,4E
....................    write_ee1(EE_RESTART_CAUSE,NO_ERR); 
033AE:  MOVLB  5
033B0:  CLRF   x51
033B2:  MOVLW  02
033B4:  MOVWF  x50
033B6:  CLRF   x52
033B8:  MOVLB  0
033BA:  RCALL  3288
....................                                                     
....................    // read valve calibration times and position in EEPROM 
....................    // if freshly flashed, valve position should default to 0xFFFF, which 
....................    // is defined as VLV_POSITION_UNKNOWN 
....................    global_valve_time_to_open_1024th = read_ee2(EE_VLV_TIME_TO_OPEN); 
033BC:  MOVLB  5
033BE:  CLRF   x51
033C0:  MOVLW  04
033C2:  MOVWF  x50
033C4:  MOVLB  0
033C6:  RCALL  3196
033C8:  MOVFF  02,C4
033CC:  MOVFF  01,C3
....................    global_valve_time_to_close_1024th = read_ee2(EE_VLV_TIME_TO_CLOSE); 
033D0:  MOVLB  5
033D2:  CLRF   x51
033D4:  MOVLW  06
033D6:  MOVWF  x50
033D8:  MOVLB  0
033DA:  RCALL  3196
033DC:  MOVFF  02,C2
033E0:  MOVFF  01,C1
....................    global_valve_calibration_utc_time = read_ee4(EE_VLV_CAL_UTC_TIME); 
033E4:  MOVLB  5
033E6:  CLRF   x51
033E8:  MOVLW  08
033EA:  MOVWF  x50
033EC:  MOVLB  0
033EE:  RCALL  32BA
033F0:  MOVFF  03,CA
033F4:  MOVFF  02,C9
033F8:  MOVFF  01,C8
033FC:  MOVFF  00,C7
....................    global_valve_position = read_ee2(EE_VLV_POSITION); 
03400:  MOVLB  5
03402:  CLRF   x51
03404:  MOVLW  0C
03406:  MOVWF  x50
03408:  MOVLB  0
0340A:  RCALL  3196
0340C:  MOVFF  02,BE
03410:  MOVFF  01,BD
....................    // store unknown valve position incase it doesn't get stored properly on shutdown/restart 
....................    //    so the position isn't used from before 
....................    write_ee2(EE_VLV_POSITION, VLV_POSITION_UNKNOWN); 
03414:  MOVLB  5
03416:  CLRF   x53
03418:  MOVLW  0C
0341A:  MOVWF  x52
0341C:  SETF   x55
0341E:  SETF   x54
03420:  MOVLB  0
03422:  RCALL  31EC
03424:  GOTO   A106 (RETURN)
....................  
.................... } 
....................  
.................... void store_vcal_eeprom_values(void) 
.................... {   
....................    // store valve calibration times in EEPROM 
....................    write_ee2(EE_VLV_TIME_TO_OPEN, global_valve_time_to_open_1024th); 
*
0805E:  MOVLB  5
08060:  CLRF   x53
08062:  MOVLW  04
08064:  MOVWF  x52
08066:  MOVFF  C4,555
0806A:  MOVFF  C3,554
0806E:  MOVLB  0
08070:  CALL   31EC
....................    write_ee2(EE_VLV_TIME_TO_CLOSE, global_valve_time_to_close_1024th); 
08074:  MOVLB  5
08076:  CLRF   x53
08078:  MOVLW  06
0807A:  MOVWF  x52
0807C:  MOVFF  C2,555
08080:  MOVFF  C1,554
08084:  MOVLB  0
08086:  CALL   31EC
....................    write_ee4(EE_VLV_CAL_UTC_TIME, global_valve_calibration_utc_time); 
0808A:  MOVLB  5
0808C:  CLRF   x55
0808E:  MOVLW  08
08090:  MOVWF  x54
08092:  MOVFF  CA,559
08096:  MOVFF  C9,558
0809A:  MOVFF  C8,557
0809E:  MOVFF  C7,556
080A2:  MOVLB  0
080A4:  CALL   6AB6
080A8:  GOTO   A5FC (RETURN)
.................... }                                                               
....................  
.................... void read_all_eeprom_variables(void)     
.................... {                                        
....................    uint16_t temp_u16; 
....................  
....................    temp_u16 = read_ee2(EE_VLV_NEAR_CLOSED_RANGE_MAX);        
*
03428:  MOVLB  5
0342A:  CLRF   x51
0342C:  MOVLW  0E
0342E:  MOVWF  x50
03430:  MOVLB  0
03432:  RCALL  3196
03434:  MOVFF  02,548
03438:  MOVFF  01,547
....................    if (temp_u16 != 0xFFFF) VLV_NEAR_CLOSED_RANGE_MAX = temp_u16;  
0343C:  MOVLB  5
0343E:  INCFSZ x47,W
03440:  BRA    3448
03442:  INCFSZ x48,W
03444:  BRA    3448
03446:  BRA    3450
03448:  MOVFF  548,503
0344C:  MOVFF  547,502
....................     
....................    temp_u16 = read_ee2(EE_VLV_NEAR_OPENED_RANGE_MAX);        
03450:  CLRF   x51
03452:  MOVLW  10
03454:  MOVWF  x50
03456:  MOVLB  0
03458:  RCALL  3196
0345A:  MOVFF  02,548
0345E:  MOVFF  01,547
....................    if (temp_u16 != 0xFFFF) VLV_NEAR_OPENED_RANGE_MAX = temp_u16; 
03462:  MOVLB  5
03464:  INCFSZ x47,W
03466:  BRA    346E
03468:  INCFSZ x48,W
0346A:  BRA    346E
0346C:  BRA    3476
0346E:  MOVFF  548,505
03472:  MOVFF  547,504
....................     
....................    temp_u16 = read_ee2(EE_DAC_LVL_OPENING_NEAR_OPENED);        
03476:  CLRF   x51
03478:  MOVLW  12
0347A:  MOVWF  x50
0347C:  MOVLB  0
0347E:  RCALL  3196
03480:  MOVFF  02,548
03484:  MOVFF  01,547
....................    if (temp_u16 != 0xFFFF) DAC_LVL_OPENING_NEAR_OPENED = temp_u16; 
03488:  MOVLB  5
0348A:  INCFSZ x47,W
0348C:  BRA    3494
0348E:  INCFSZ x48,W
03490:  BRA    3494
03492:  BRA    349C
03494:  MOVFF  548,507
03498:  MOVFF  547,506
....................     
....................    temp_u16 = read_ee2(EE_DAC_LVL_OPENING_NEAR_CLOSED);        
0349C:  CLRF   x51
0349E:  MOVLW  14
034A0:  MOVWF  x50
034A2:  MOVLB  0
034A4:  RCALL  3196
034A6:  MOVFF  02,548
034AA:  MOVFF  01,547
....................    if (temp_u16 != 0xFFFF) DAC_LVL_OPENING_NEAR_CLOSED = temp_u16; 
034AE:  MOVLB  5
034B0:  INCFSZ x47,W
034B2:  BRA    34BA
034B4:  INCFSZ x48,W
034B6:  BRA    34BA
034B8:  BRA    34C2
034BA:  MOVFF  548,509
034BE:  MOVFF  547,508
....................     
....................    temp_u16 = read_ee2(EE_DAC_LVL_CLOSING_NEAR_OPENED);        
034C2:  CLRF   x51
034C4:  MOVLW  16
034C6:  MOVWF  x50
034C8:  MOVLB  0
034CA:  RCALL  3196
034CC:  MOVFF  02,548
034D0:  MOVFF  01,547
....................    if (temp_u16 != 0xFFFF) DAC_LVL_CLOSING_NEAR_OPENED = temp_u16; 
034D4:  MOVLB  5
034D6:  INCFSZ x47,W
034D8:  BRA    34E0
034DA:  INCFSZ x48,W
034DC:  BRA    34E0
034DE:  BRA    34E8
034E0:  MOVFF  548,50B
034E4:  MOVFF  547,50A
....................     
....................    temp_u16 = read_ee2(EE_DAC_LVL_CLOSING_NEAR_CLOSED);        
034E8:  CLRF   x51
034EA:  MOVLW  18
034EC:  MOVWF  x50
034EE:  MOVLB  0
034F0:  RCALL  3196
034F2:  MOVFF  02,548
034F6:  MOVFF  01,547
....................    if (temp_u16 != 0xFFFF) DAC_LVL_CLOSING_NEAR_CLOSED = temp_u16; 
034FA:  MOVLB  5
034FC:  INCFSZ x47,W
034FE:  BRA    3506
03500:  INCFSZ x48,W
03502:  BRA    3506
03504:  BRA    350E
03506:  MOVFF  548,50D
0350A:  MOVFF  547,50C
....................     
....................    temp_u16 = read_ee2(EE_DAC_LVL_IN_MIDDLE);        
0350E:  CLRF   x51
03510:  MOVLW  1A
03512:  MOVWF  x50
03514:  MOVLB  0
03516:  RCALL  3196
03518:  MOVFF  02,548
0351C:  MOVFF  01,547
....................    if (temp_u16 != 0xFFFF) DAC_LVL_IN_MIDDLE = temp_u16; 
03520:  MOVLB  5
03522:  INCFSZ x47,W
03524:  BRA    352C
03526:  INCFSZ x48,W
03528:  BRA    352C
0352A:  BRA    3534
0352C:  MOVFF  548,50F
03530:  MOVFF  547,50E
....................     
....................    temp_u16 = read_ee2(EE_DAC_LVL_INIT_CURRENT_BOOST);        
03534:  CLRF   x51
03536:  MOVLW  1C
03538:  MOVWF  x50
0353A:  MOVLB  0
0353C:  RCALL  3196
0353E:  MOVFF  02,548
03542:  MOVFF  01,547
....................    if (temp_u16 != 0xFFFF) DAC_LVL_INIT_CURRENT_BOOST = temp_u16; 
03546:  MOVLB  5
03548:  INCFSZ x47,W
0354A:  BRA    3552
0354C:  INCFSZ x48,W
0354E:  BRA    3552
03550:  BRA    355A
03552:  MOVFF  548,511
03556:  MOVFF  547,510
....................     
....................    temp_u16 = read_ee2(EE_VLV_INIT_CURRENT_BOOST_TIME_1024THS);        
0355A:  CLRF   x51
0355C:  MOVLW  1E
0355E:  MOVWF  x50
03560:  MOVLB  0
03562:  RCALL  3196
03564:  MOVFF  02,548
03568:  MOVFF  01,547
....................    if (temp_u16 != 0xFFFF) VLV_INIT_CURRENT_BOOST_TIME_1024THS = temp_u16; 
0356C:  MOVLB  5
0356E:  INCFSZ x47,W
03570:  BRA    3578
03572:  INCFSZ x48,W
03574:  BRA    3578
03576:  BRA    3580
03578:  MOVFF  548,513
0357C:  MOVFF  547,512
....................     
....................    temp_u16 = read_ee2(EE_VLV_NOT_SPIN_LIMIT);        
03580:  CLRF   x51
03582:  MOVLW  20
03584:  MOVWF  x50
03586:  MOVLB  0
03588:  RCALL  3196
0358A:  MOVFF  02,548
0358E:  MOVFF  01,547
....................    if (temp_u16 != 0xFFFF) VLV_NOT_SPIN_LIMIT = temp_u16; 
03592:  MOVLB  5
03594:  INCFSZ x47,W
03596:  BRA    359E
03598:  INCFSZ x48,W
0359A:  BRA    359E
0359C:  BRA    35A6
0359E:  MOVFF  548,515
035A2:  MOVFF  547,514
....................     
....................    temp_u16 = read_ee2(EE_VLV_NOT_SPIN_FIX);        
035A6:  CLRF   x51
035A8:  MOVLW  22
035AA:  MOVWF  x50
035AC:  MOVLB  0
035AE:  RCALL  3196
035B0:  MOVFF  02,548
035B4:  MOVFF  01,547
....................    if (temp_u16 != 0xFFFF) VLV_NOT_SPIN_FIX = temp_u16;   
035B8:  MOVLB  5
035BA:  INCFSZ x47,W
035BC:  BRA    35C4
035BE:  INCFSZ x48,W
035C0:  BRA    35C4
035C2:  BRA    35CC
035C4:  MOVFF  548,517
035C8:  MOVFF  547,516
....................     
....................    temp_u16 = read_ee2(EE_NOT_SPINNING_MAG_DECOUPLING_RPM_FIXED);        
035CC:  CLRF   x51
035CE:  MOVLW  24
035D0:  MOVWF  x50
035D2:  MOVLB  0
035D4:  RCALL  3196
035D6:  MOVFF  02,548
035DA:  MOVFF  01,547
....................    if (temp_u16 != 0xFFFF) NOT_SPINNING_MAG_DECOUPLING_RPM_FIXED = temp_u16;   
035DE:  MOVLB  5
035E0:  INCFSZ x47,W
035E2:  BRA    35EA
035E4:  INCFSZ x48,W
035E6:  BRA    35EA
035E8:  BRA    35EE
035EA:  MOVFF  547,518
....................     
....................    temp_u16 = read_ee2(EE_VLV_MAGNETIC_COUPLING_LIMIT);        
035EE:  CLRF   x51
035F0:  MOVLW  26
035F2:  MOVWF  x50
035F4:  MOVLB  0
035F6:  RCALL  3196
035F8:  MOVFF  02,548
035FC:  MOVFF  01,547
....................    if (temp_u16 != 0xFFFF) VLV_MAGNETIC_COUPLING_LIMIT = temp_u16;   
03600:  MOVLB  5
03602:  INCFSZ x47,W
03604:  BRA    360C
03606:  INCFSZ x48,W
03608:  BRA    360C
0360A:  BRA    3614
0360C:  MOVFF  548,51A
03610:  MOVFF  547,519
....................     
....................    temp_u16 = read_ee2(EE_VLV_MAGNETIC_COUPLING_FIX);        
03614:  CLRF   x51
03616:  MOVLW  28
03618:  MOVWF  x50
0361A:  MOVLB  0
0361C:  RCALL  3196
0361E:  MOVFF  02,548
03622:  MOVFF  01,547
....................    if (temp_u16 != 0xFFFF) VLV_MAGNETIC_COUPLING_FIX = temp_u16; 
03626:  MOVLB  5
03628:  INCFSZ x47,W
0362A:  BRA    3632
0362C:  INCFSZ x48,W
0362E:  BRA    3632
03630:  BRA    363A
03632:  MOVFF  548,51C
03636:  MOVFF  547,51B
....................     
....................    temp_u16 = read_ee2(EE_RPM_TIMEOUT);                       
0363A:  CLRF   x51
0363C:  MOVLW  2A
0363E:  MOVWF  x50
03640:  MOVLB  0
03642:  RCALL  3196
03644:  MOVFF  02,548
03648:  MOVFF  01,547
....................    if (temp_u16 != 0xFFFF) RPM_TIMEOUT = temp_u16;   
0364C:  MOVLB  5
0364E:  INCFSZ x47,W
03650:  BRA    3658
03652:  INCFSZ x48,W
03654:  BRA    3658
03656:  BRA    3660
03658:  MOVFF  548,51E
0365C:  MOVFF  547,51D
....................     
....................    temp_u16 = read_ee2(EE_MOTE_SEARCH_TIME);        
03660:  CLRF   x51
03662:  MOVLW  2C
03664:  MOVWF  x50
03666:  MOVLB  0
03668:  RCALL  3196
0366A:  MOVFF  02,548
0366E:  MOVFF  01,547
....................    if (temp_u16 != 0xFFFF) MOTE_SEARCH_TIME = temp_u16;   
03672:  MOVLB  5
03674:  INCFSZ x47,W
03676:  BRA    367E
03678:  INCFSZ x48,W
0367A:  BRA    367E
0367C:  BRA    3686
0367E:  MOVFF  548,520
03682:  MOVFF  547,51F
....................     
....................    temp_u16 = read_ee2(EE_MOTE_NETWORK_SHUTDOWN_TIMEOUT);        
03686:  CLRF   x51
03688:  MOVLW  2E
0368A:  MOVWF  x50
0368C:  MOVLB  0
0368E:  RCALL  3196
03690:  MOVFF  02,548
03694:  MOVFF  01,547
....................    if (temp_u16 != 0xFFFF) MOTE_NETWORK_SHUTDOWN_TIMEOUT = temp_u16;    
03698:  MOVLB  5
0369A:  INCFSZ x47,W
0369C:  BRA    36A4
0369E:  INCFSZ x48,W
036A0:  BRA    36A4
036A2:  BRA    36AC
036A4:  MOVFF  548,522
036A8:  MOVFF  547,521
036AC:  MOVLB  0
036AE:  GOTO   A10A (RETURN)
.................... } 
....................     
....................  
.................... ////////////////////EEPROM Functions End///////////////////////////////////////////////////////////////  
....................                                                                                                     
....................  
....................   
....................  
....................   
.................... // specific headers                    
.................... #include "pic.h" 
.................... // This file contains all functions related to PIC functions and setup 
....................  
.................... //Function Definitions 
....................  
.................... // These defines are used in the oscillator setup subroutines below. 
.................... // Note the situations of concern: 
.................... //    4MHz osc: TMR2 prescale 16, postscale 6, PR2=99;         DIV16_POST6  
.................... //       [PWM freq 625Hz, PWM resolution 400, TMR2 int rate: 9.6ms] 
.................... //    3.6864MHz osc: TMR2 prescale 16, postscale 6, PR2=99;    DIV16_POST6 
.................... //       [PWM freq 576Hz, PWM resolution 400, TMR2 int rate: 10.4ms] 
.................... //    1MHz osc: TMR2 prescale 4, postscale 6, PR2=99;          DIV4_POST6 
.................... //       [PWM freq 625Hz, PWM resolution 400, TMR2 int rate: 9.6ms] 
.................... //    250KHz osc: TMR2 prescale 16, postscale 6, PR2=99;       DIV1_POST6 
.................... //       [PWM freq 625Hz, PWM resolution 400, TMR2 int rate: 9.6ms] 
.................... //    32768Hz osc: TMR2 prescale 1, postscale 1, PR2=79;       DIV1_POST1 
.................... //       [no PWM, TMR2 int rate: 9.8ms] 
.................... //    31250Hz osc: TMR2 prescale 1, postscale 1, PR2=79;       DIV1_POST1 
.................... //       [no PWM, TMR2 int rate: 10.2ms] 
....................  
.................... // SEE p 177 of DS41412F [PIC18(L)F2X/4XK22 datasheet] 
.................... #define  DIV16_POST6    0b00101110 
.................... #define  DIV4_POST6     0b00101101 
.................... #define  DIV1_POST6     0b00101100 
.................... #define  DIV1_POST1     0b00000100 
....................  
.................... // Each of these subroutines 
.................... //    a. save INTCON (high and low global int enab bits) 
.................... //    b. disable global interrupts 
.................... //    c. select the oscillator 
.................... //    d. set up TMR2, which is used to produce the PWM waveforms 
.................... //       and to cause interrupts to checking, e.g., the valve motor current 
.................... //    e. set up delnum param used by the newdel_10ms routine, 
.................... //       which is oscillator-dependent 
.................... //    f. restore INTCON 
....................  
.................... // These routines simply set up OSCCON, T0CON, T2CON, PR2 and osctype. 
....................  
.................... // PR2 is selected to provide a resolution of 400 in the PWM duty cycle 
.................... //  when clock is 250KHz and above. 
.................... // Below 250KHz the duty cycle resolution is unimportant because we would  
.................... //  be idling... 
.................... // The combination of PR2 and T2CON (T2CON includes prescale (1/4/16)  
.................... //  and postscale (..6..) ensures that the TMR2 ints occur at the proper rate  
.................... //  of approx 10ms regardless of the oscillator choice. 
.................... // Finally T0CON is set such that the timer 0 prescaler is selected to provide 
.................... //  TMR0 functionality and accuracy largely independent of oscillator choice: 
.................... //  e.g., at 31250/250k/1m/4m clock, T0CON is set such that the prescaler is  
.................... //   set to 2/16/64/256 thus providing a consistent counting rate of 3906.25Hz 
.................... //   and a programmable overflow time ranging from 256us up to about 16.8s 
.................... //  Accuracy is a bit compromised when running with the 3.6864MHz primary  
.................... //   crystal, but this error is not significant.... (an 8.5% error...) 
....................  
.................... //  Interrupts disabled to prevent reentrancy 
.................... void     fosc_pri(void) 
.................... { 
....................    uint8_t     tmp_intcon; 
....................    tmp_intcon = INTCON & 0xC0; 
*
01144:  MOVF   FF2,W
01146:  ANDLW  C0
01148:  MOVLB  5
0114A:  MOVWF  xA0
....................    disable_interrupts(GLOBAL); 
0114C:  BCF    FF2.6
0114E:  BCF    FF2.7
01150:  BTFSC  FF2.7
01152:  BRA    114E
....................    OSCCON = 0x00;       // select primary xtal oscillator 
01154:  CLRF   FD3
....................    T0CON = T0_DIV_256;  // 278usec per tick 
01156:  MOVLW  07
01158:  MOVWF  FD5
....................    T2CON = 0b01110010;  // T2 scale factor 15*16 (248usec per tick equiv) 
0115A:  MOVLW  72
0115C:  MOVWF  FBA
....................    T4CON = 0b01110010;  // T4 scale factor 15*16 (248usec per tick equiv) 
0115E:  MOVLB  F
01160:  MOVWF  x51
....................    PR2 = 99;            
01162:  MOVLW  63
01164:  MOVWF  FBB
....................    INTCON |= tmp_intcon; 
01166:  MOVLB  5
01168:  MOVF   xA0,W
0116A:  IORWF  FF2,F
0116C:  MOVLB  0
0116E:  RETURN 0
.................... } 
....................  
.................... void     fosc_pri_ISR(void) 
.................... { 
....................    uint8_t     tmp_intcon; 
....................    tmp_intcon = INTCON & 0xC0; 
*
008E8:  MOVF   FF2,W
008EA:  ANDLW  C0
008EC:  MOVLB  5
008EE:  MOVWF  x83
....................    disable_interrupts(GLOBAL); 
008F0:  BCF    FF2.6
008F2:  BCF    FF2.7
008F4:  BTFSC  FF2.7
008F6:  BRA    08F2
....................    OSCCON = 0x00;       // select primary xtal oscillator 
008F8:  CLRF   FD3
....................    T0CON = T0_DIV_256;  // 278usec per tick 
008FA:  MOVLW  07
008FC:  MOVWF  FD5
....................    T2CON = 0b01110010;  // T2 scale factor 15*16 (248usec per tick equiv) 
008FE:  MOVLW  72
00900:  MOVWF  FBA
....................    T4CON = 0b01110010;  // T4 scale factor 15*16 (248usec per tick equiv) 
00902:  MOVLB  F
00904:  MOVWF  x51
....................    PR2 = 99; 
00906:  MOVLW  63
00908:  MOVWF  FBB
....................    INTCON |= tmp_intcon; 
0090A:  MOVLB  5
0090C:  MOVF   x83,W
0090E:  IORWF  FF2,F
00910:  MOVLB  0
00912:  GOTO   1712 (RETURN)
.................... } 
....................  
.................... void     fosc_4m(void) 
.................... { 
....................    uint8_t     tmp_intcon; 
....................    tmp_intcon = INTCON & 0xC0; 
....................    disable_interrupts(GLOBAL); 
....................    OSCCON = 0x52;       // select 4MHz internal oscillator 
....................    T0CON = T0_DIV_256;  // 256usec per tick 
....................    T2CON = 0b01111010;  // T2 scale factor 16x16 (256usec per tick equiv) 
....................    T4CON = 0b01111010;  // T4 scale factor 16x16 (256usec per tick equiv) 
....................    PR2 = 99; 
....................    INTCON |= tmp_intcon; 
.................... } 
....................  
....................  
.................... void     fosc_1m(void) 
.................... { 
....................    uint8_t     tmp_intcon; 
....................    tmp_intcon = INTCON & 0xC0; 
....................    disable_interrupts(GLOBAL); 
....................    OSCCON = 0x32;       // select 1MHz internal oscillator 
....................    T0CON = T0_DIV_64;   // 256usec per tick 
....................    T2CON = 0b00011010;  // T2 scale factor 4*16 (256usec per tick equiv) 
....................    T4CON = 0b00011010;  // T4 scale factor 4*16 (256usec per tick equiv) 
....................    PR2 = 99; 
....................    INTCON |= tmp_intcon; 
.................... } 
....................  
.................... void     fosc_250k(void) 
.................... { 
....................    uint8_t     tmp_intcon; 
....................    tmp_intcon = INTCON & 0xC0; 
*
0311C:  MOVF   FF2,W
0311E:  ANDLW  C0
03120:  MOVLB  5
03122:  MOVWF  x47
....................    disable_interrupts(GLOBAL); 
03124:  BCF    FF2.6
03126:  BCF    FF2.7
03128:  BTFSC  FF2.7
0312A:  BRA    3126
....................    OSCCON = 0x12;       // select 250KHz internal oscillator 
0312C:  MOVLW  12
0312E:  MOVWF  FD3
....................    T0CON = T0_DIV_16;   // 256usec per tick 
03130:  MOVLW  03
03132:  MOVWF  FD5
....................    T2CON = 0b00000010;  // T2 scale factor 1*16 (256usec per tick equiv) 
03134:  MOVLW  02
03136:  MOVWF  FBA
....................    T4CON = 0b00000010;  // T4 scale factor 1*16 (256usec per tick equiv) 
03138:  MOVLB  F
0313A:  MOVWF  x51
....................    PR2 = 99; 
0313C:  MOVLW  63
0313E:  MOVWF  FBB
....................    INTCON |= tmp_intcon; 
03140:  MOVLB  5
03142:  MOVF   x47,W
03144:  IORWF  FF2,F
03146:  MOVLB  0
03148:  GOTO   3154 (RETURN)
.................... } 
....................  
.................... void     fosc_250k_ISR(void)  
.................... { 
....................    uint8_t     tmp_intcon; 
....................    tmp_intcon = INTCON & 0xC0; 
....................    disable_interrupts(GLOBAL); 
....................    OSCCON = 0x12;       // select 250KHz internal oscillator 
....................    T0CON = T0_DIV_16;   // 256usec per tick 
....................    T2CON = 0b00000010;  // T2 scale factor 1*16 (256usec per tick equiv) 
....................    T4CON = 0b00000010;  // T4 scale factor 1*16 (256usec per tick equiv) 
....................    PR2 = 99; 
....................    INTCON |= tmp_intcon; 
.................... } 
....................  
.................... void     fosc_31250(void) 
.................... { 
....................    uint8_t     tmp_intcon; 
....................    tmp_intcon = INTCON & 0xC0; 
....................    disable_interrupts(GLOBAL); 
....................    OSCCON = 0x02;       // select 31250Hz internal oscillator 
....................    T0CON = T0_DIV_2;    // 256usec per tick 
....................    T2CON = 0b00001000;  // T2 scale factor 2*1 (256usec per tick equiv) 
....................    T4CON = 0b00001000;  // T4 scale factor 2*1 (256usec per tick equiv) 
....................    PR2 = 79; 
....................    INTCON |= tmp_intcon; 
.................... }       
....................  
.................... void     fosc_31250_ISR(void)  
.................... { 
....................    uint8_t     tmp_intcon; 
....................    tmp_intcon = INTCON & 0xC0; 
....................    disable_interrupts(GLOBAL); 
....................    OSCCON = 0x02;       // select 31250Hz internal oscillator 
....................    T0CON = T0_DIV_2;    // 256usec per tick 
....................    T2CON = 0b00001000;  // T2 scale factor 2*1 (256usec per tick equiv) 
....................    T4CON = 0b00001000;  // T4 scale factor 2*1 (256usec per tick equiv) 
....................    PR2 = 79; 
....................    INTCON |= tmp_intcon; 
.................... }       
....................  
.................... void     fosc_sec(void) 
.................... { 
....................    uint8_t     tmp_intcon; 
....................    tmp_intcon = INTCON & 0xC0; 
....................    disable_interrupts(GLOBAL); 
....................    OSCCON = 0x01;       // select secondary xtal oscillator 
....................    T0CON = T0_DIV_2;    // 244usec per tick 
....................    T2CON = 0b00001000;  // T2 scale factor 2*1 (244usec per tick equiv) 
....................    T4CON = 0b00001000;  // T4 scale factor 2*1 (244usec per tick equiv) 
....................    PR2 = 79; 
....................    INTCON |= tmp_intcon; 
.................... } 
....................  
.................... void osc_init(void) 
.................... { 
.................... // initalizes the oscillators/crystals, sets up delays, RS232, and i2c 
....................  
....................     
....................    // set stack pointer to 0 in case things restart 
....................    STKPTR = 0; 
0314C:  CLRF   FFC
....................     
....................    #use delay(clock=3,686,400) 
....................    #use RS232 (uart1, baud=115200, ERRORS) 
*
01170:  BTFSS  F9E.4
01172:  BRA    1170
01174:  MOVWF  FAD
01176:  RETURN 0
....................    //#use RS232 (uart2, baud=9600) 
....................     
....................    // start up 32.768KHz xtal oscillator 
....................    SOSCGO = TRUE; 
*
0314E:  BSF    FD2.3
....................    // use medium freq internal osc (lower power) for 250KHz and 500KHz choices   
....................    MFIOSEL = TRUE;   
03150:  BSF    FD2.4
....................     
....................    // switch to main 250k internal osc and setup delay functions                                     
....................    fosc_250k(); 
03152:  BRA    311C
....................    #use delay(clock=250KHZ) 
*
03736:  MOVLW  05
03738:  MOVWF  FEA
0373A:  MOVLW  60
0373C:  MOVWF  FE9
0373E:  MOVF   FEF,W
03740:  BZ    3750
03742:  MOVLW  13
03744:  MOVWF  00
03746:  DECFSZ 00,F
03748:  BRA    3746
0374A:  NOP   
0374C:  DECFSZ FEF,F
0374E:  BRA    3742
03750:  RETURN 0
....................     
....................    // setup i2c for use on 250khz main clock 
....................    #use i2c(master, I2C1, FORCE_HW, NO_STRETCH, FAST=10000) 
*
03154:  GOTO   A0C2 (RETURN)
*
03752:  BCF    FC6.7
03754:  BCF    F9E.3
03756:  MOVFF  578,FC9
0375A:  MOVLW  02
0375C:  BTFSC  FC6.7
0375E:  BRA    376A
03760:  BTFSS  F9E.3
03762:  BRA    3760
03764:  MOVLW  00
03766:  BTFSC  FC5.6
03768:  MOVLW  01
0376A:  MOVWF  01
0376C:  RETURN 0
.................... } 
....................  
....................     
....................    // during initialization, except for servicing the mote, the fosc is 
....................    //  always at 250KHz 
....................    // The #use delay above ensures that delay_ms instructions are  
....................    //  compiled properly 
....................    // Built-in compiler delay functionality works fine until mote ints 
....................    //  occur because mote service speeds up the clock and screws up the 
....................    //  compiler built-in delay function..... 
....................  
....................    // The assumption is that I2C communications takes place when system  
....................    //  clock is set to 250KHz 
....................     
.................... void     setup_T0_int(uint16_t value) 
.................... { 
.................... // Use this routine to set up TMR0 such that its flag sets after  
.................... //  the designated time. 
.................... // These are not functions that hang up processing.  They merely ensure 
.................... //  that something takes place before a programmable amount of time passes. 
.................... // 
.................... // Add more possibilities as required.... 
.................... // The defines for "value" can be found in the .h file 
....................    disable_interrupts(GLOBAL); 
*
036B2:  BCF    FF2.6
036B4:  BCF    FF2.7
036B6:  BTFSC  FF2.7
036B8:  BRA    36B4
....................    TMR0ON = FALSE; 
036BA:  BCF    FD5.7
....................    set_timer0(value); 
036BC:  MOVFF  565,FD7
036C0:  MOVFF  564,FD6
....................    TMR0IF = FALSE; 
036C4:  BCF    FF2.2
....................    TMR0ON = TRUE; 
036C6:  BSF    FD5.7
....................    enable_interrupts(GLOBAL); 
036C8:  MOVLW  C0
036CA:  IORWF  FF2,F
036CC:  RETURN 0
.................... } 
....................  
.................... void     setup_T2_int(uint8_t value) 
.................... { 
.................... // Use this routine during ISRs to set up TMR4 such that its flag sets 
.................... //  after the designated time. 
....................    TMR2ON = FALSE; 
*
04E6E:  BCF    FBA.2
....................    set_timer2(0); 
04E70:  CLRF   FBC
....................    PR2 = value; 
04E72:  MOVFF  547,FBB
....................    TMR2IF = FALSE; 
04E76:  BCF    F9E.1
....................    TMR2ON = TRUE; 
04E78:  BSF    FBA.2
04E7A:  RETURN 0
.................... } 
....................  
.................... void     setup_T4_int(uint8_t value) 
.................... { 
.................... // Use this routine during ISRs to set up TMR4 such that its flag sets 
.................... //  after the designated time. 
....................    TMR4ON = FALSE; 
*
00916:  MOVLB  F
00918:  BCF    x51.2
....................    set_timer4(0); 
0091A:  CLRF   x53
....................    PR4 = value; 
0091C:  MOVFF  5A0,F52
....................    TMR4IF = FALSE; 
00920:  BCF    F7E.0
....................    TMR4ON = TRUE; 
00922:  BSF    x51.2
00924:  MOVLB  0
00926:  RETURN 0
.................... } 
....................  
....................  
.................... void periph_init(void) 
.................... {  
....................    /* Initalizes and configures all perhips, ports, timers, etc. 
....................     * Items initalized include: 
....................     * Interrupts 
....................     * GPIOs 
....................     * Pullup resistors (Port B) 
....................     * Unused periphs in pic (turned off for lower power usage) 
....................     * Timers 
....................     * CCPs 
....................     *  
....................     */ 
....................  
....................    // extra insurance that we aren't interrupted while setting up periph    
....................    disable_interrupts(GLOBAL); 
*
03E84:  BCF    FF2.6
03E86:  BCF    FF2.7
03E88:  BTFSC  FF2.7
03E8A:  BRA    3E86
....................     
....................    // get I/O lines and hardware in general into LOWEST POSSIBLE current draw 
....................    setup_vref(VREF_OFF); 
03E8C:  MOVLB  F
03E8E:  CLRF   x42
....................    setup_dac(DAC_OFF); 
03E90:  CLRF   x41
....................    setup_adc(ADC_OFF); 
03E92:  BCF    FC2.0
....................     
....................    // ensure that the CTMU is off 
....................    CTMUICON = 0; 
03E94:  CLRF   x43
....................    CTMUCONL = 0; 
03E96:  CLRF   x44
....................    CTMUCONH = 0; 
03E98:  CLRF   x45
....................     
....................    // ensure that the SR latch is off 
....................    SRCON0 = 0; 
03E9A:  CLRF   x47
....................    SRCON1 = 0; 
03E9C:  CLRF   x46
....................  
....................    // turns off comarator. Funny define from PICklkk 
....................    setup_comparator(NC_NC_NC_NC); 
03E9E:  CLRF   F77
03EA0:  MOVLW  04
03EA2:  MOVWF  F78
03EA4:  MOVWF  F79
....................     
....................    /* definitively establishes that TMR2 is used to generate PWM frequency 
....................     * for P1x, P2x, P3x 
....................     */ 
....................    CCPTMRS0 = 0; 
03EA6:  CLRF   x49
....................    CCPTMRS1 = 0;     
03EA8:  CLRF   x48
....................     
....................    /* ADC setup (ports, configuration, reference) 
....................     * to perform an acquisition, select the channel and then turn on the ADC 
....................     * [ADON=TRUE]. Then do a read_adc() 
....................     */ 
....................    setup_adc_ports(sAN0|sAN1|sAN12); 
03EAA:  MOVF   FC1,W
03EAC:  ANDLW  F0
03EAE:  MOVWF  FC1
03EB0:  MOVLW  03
03EB2:  MOVWF  x38
03EB4:  MOVLW  00
03EB6:  MOVWF  x3C
03EB8:  MOVLW  01
03EBA:  MOVWF  x39
03EBC:  MOVLW  00
03EBE:  MOVWF  x3A
03EC0:  MOVWF  x3B
....................    ADCON2 = ADC_SETUP_DEF; 
03EC2:  SETF   FC0
....................    setup_adc_reference(VSS_VDD); 
03EC4:  BCF    FC1.0
03EC6:  BCF    FC1.1
03EC8:  BCF    FC1.2
03ECA:  BCF    FC1.3
....................     
....................    /* setup pullup resistors on Port B for Mote Uart flow and XDCR detection    
....................     * RB2 (MOTE_TX_RTSn)    
....................     */  
....................     // JG: think about this in light of other port_b_pullups code! 
....................    port_b_pullups(0b00000100); 
03ECC:  MOVLW  04
03ECE:  MOVWF  F61
03ED0:  BCF    FF1.7
....................                                            
....................    // turns uart off 
....................    setup_uart(FALSE); 
03ED2:  BCF    FAB.7
03ED4:  BCF    FAB.4
03ED6:  BCF    FAC.5
....................     
....................    // set the inital state and i/o characteristics for all ports 
....................    output_a(PORTA_INIT);                
03ED8:  MOVLW  74
03EDA:  MOVWF  F89
....................    output_b(PORTB_INIT); 
03EDC:  MOVLW  18
03EDE:  MOVWF  F8A
....................    output_c(PORTC_INIT); 
03EE0:  MOVLW  45
03EE2:  MOVWF  F8B
....................    output_d(PORTD_INIT); 
03EE4:  MOVLW  76
03EE6:  MOVWF  F8C
....................    output_e(PORTE_INIT); 
03EE8:  CLRF   F8D
....................    set_tris_a(TRISA_NORM); 
03EEA:  MOVLW  8B
03EEC:  MOVWF  F92
....................    set_tris_b(TRISB_NORM); 
03EEE:  MOVLW  F7
03EF0:  MOVWF  F93
....................    set_tris_c(TRISC_NORM); 
03EF2:  MOVLW  9A
03EF4:  MOVWF  F94
....................    set_tris_d(TRISD_NORM); 
03EF6:  MOVLW  80
03EF8:  MOVWF  F95
....................    set_tris_e(TRISE_NORM); 
03EFA:  BCF    F96.0
03EFC:  BCF    F96.1
03EFE:  BSF    F96.2
03F00:  BSF    F96.3
....................   
....................    //********************Timers setup start********************     
....................     
....................    // TMR0 for general timing functions 
....................    setup_timer_0(T0_OFF); 
03F02:  CLRF   FD5
....................     
....................    /* TMR1 is used in valve motion algorithm 
....................     * It is timed by the external secondary (32.768kHz) xtal 
....................     * Initalized in off mode 
....................     */ 
....................    setup_timer_1(T1_ENABLE_SOSC | T1_EXTERNAL | T1_DIV_BY_1); 
03F04:  MOVLW  8F
03F06:  MOVWF  FCD
03F08:  CLRF   FCC
....................    TMR1ON = FALSE; 
03F0A:  BCF    FCD.0
....................    set_timer1(0); 
03F0C:  CLRF   FCF
03F0E:  CLRF   FCE
....................     
....................    /* TMR2 is used in all PWM generation and to produce 
....................     * an interrupt event every approx 16msec if desired 
....................     * TMR2 setup handled by oscillator setup macro above 
....................     * Initalized in off mode 
....................     */ 
....................    TMR2ON = FALSE; 
03F10:  BCF    FBA.2
....................    set_timer2(0); 
03F12:  CLRF   FBC
....................     
....................    /* TMR3 is used to count seconds 
....................     * It is timed by the external secondary (32.768kHz) xtal 
....................     * It is set to 8000 and overflows FFFF in 1 second. 
....................     * It is then reset to 8000 after counting 1 second after overflow 
....................     * Initalized in on mode 125ms before overflow (F000) 
....................     */ 
....................    setup_timer_3(T3_ENABLE_SOSC | T3_EXTERNAL | T3_DIV_BY_1);   
03F14:  CLRF   FB4
03F16:  MOVWF  FB1
....................    TMR3ON = FALSE; 
03F18:  BCF    FB1.0
....................    set_timer3(0); 
03F1A:  CLRF   FB3
03F1C:  CLRF   FB2
....................       
....................    // TMR4 is not used 
....................    setup_timer_4(T4_DISABLED,0,1); 
03F1E:  MOVLW  00
03F20:  MOVWF  x51
03F22:  MOVLW  00
03F24:  MOVWF  x52
....................     
....................    /* TMR5 is dedicated to measurement of RPM 
....................     * It is timed by the external secondary (32.768kHz) xtal 
....................     * Initalized in off mode 
....................     */ 
....................    setup_timer_5(T5_ENABLE_SOSC|T5_EXTERNAL|T5_DIV_BY_1); 
03F26:  CLRF   x4D
03F28:  MOVLW  8F
03F2A:  MOVWF  x4E
....................    TMR5ON = FALSE; 
03F2C:  BCF    x4E.0
....................    set_timer5(0); 
03F2E:  CLRF   x50
03F30:  CLRF   x4F
....................     
....................    // TMR6 is not used 
....................    //setup_timer_6(T6_DISABLED,0,1); 
....................    TMR6ON = FALSE; 
03F32:  BCF    x4A.2
....................    set_timer6(0); 
03F34:  CLRF   x4C
....................     
....................    // sets up TMR2, TMR0, TMR6 CON   
....................    T0CON = T0_DIV_16;   
03F36:  MOVLW  03
03F38:  MOVWF  FD5
....................    T2CON = DIV1_POST6; 
03F3A:  MOVLW  2C
03F3C:  MOVWF  FBA
....................    T6CON = DIV1_POST6;                  
03F3E:  MOVWF  x4A
....................    PR2 = 99; 
03F40:  MOVLW  63
03F42:  MOVWF  FBB
....................    PR6 = 99;   
03F44:  MOVWF  x4B
....................     
....................    //********************Timers setup end********************     
....................     
....................    //********************CCP setup start********************     
....................     
....................    //setup_ccp1(CCP_USE_TIMER1_AND_TIMER2 | CCP_PWM_L_L | CCP_PULSE_STEERING_A); 
....................    // CCP1(pwm with TMR2) and P1A are specifically for braking control. 
....................    // Set as above when in use. 
....................    // When off, the BRK_CTRLn line can be set as an I/O for 
....................    //  either max brake (lo) of min (hi) brake. 
....................    // Note that duty cycle 0 for minimum braking,  
....................    //  duty cycle=400 for (almost) maximum braking. 
....................    setup_ccp1(CCP_OFF);          // CCP1 off for now 
03F46:  MOVLW  F0
03F48:  ANDWF  FBD,F
....................    // P1A (BRAKE_CTRLn) is initialized to brakes off (1) 
....................   
....................    //setup_ccp2(CCP_USE_TIMER1_AND_TIMER2 | CCP_PWM_H_H | CCP_PULSE_STEERING_A); 
....................    // CCP2(pwm with TMR2) and P2A are specifically for control of charging. 
....................    // Set above when in use. 
....................    // When off, the LTC3105_CTRL line can be set as an I/O for  
....................    //  either max charging (hi) or min (lo) charging. 
....................    // Note that duty cycle 0 for no charging, 
....................    //  duty cycle=400 for (almost) max charging. 
....................    setup_ccp2(CCP_OFF);          // CCP2 off for now 
03F4A:  ANDWF  F66,F
....................    // P2A (LTC3105_CTRL) is initialized to max charging aggressiveness (1) 
....................     
....................    //setup_ccp3(CCP_USE_TIMER1_AND_TIMER2 | CCP_PWM_L_L | CCP_PULSE_STEERING_A); 
....................    //setup_ccp3(CCP_USE_TIMER1_AND_TIMER2 | CCP_PWM_L_L | CCP_PULSE_STEERING_B); 
....................    //setup_ccp3(CCP_USE_TIMER1_AND_TIMER2 | CCP_COMPARE_RESET_TIMER); 
....................    // CCP3(compare)/TMR1 is for valve timing;  
....................    // CCP3(pwm)/TMR2 if for valve motor speed control 
....................    //Steer output to P3A for closing, steer output to P3B for opening; 
....................    // both VLV_CTRL1 (P3A) and VLV_CTRL2 (P3B) hi for braking; 
....................    // both VLV_CTRL1 (P3A) and VLV_CTRL2 (P3B) lo for coasting; 
....................    // pulse P3A lo while P3B hi for closing, pulse P3B while P3A hi for opening 
....................    //Compare mode used to time valve motion after ramp is finished. 
....................    //  Set CCPf_3 to 0x8000 and start TMR1 for 1sec interrupts; or use other 
....................    //  values for different timings.  General purpose timing when valve not 
....................    //  being timed. 
....................    setup_ccp3(CCP_OFF);          // CCP3 off for now 
03F4C:  ANDWF  x5D,F
....................  
....................    //setup_ccp4(CCP_USE_TIMER3_AND_TIMER4 | CCP_COMPARE_RESET_TIMER);  
....................    // CCP4/TMR3 serves only one purpose: the real-time-clock. 
....................    //  Set CCP_4 to 0x8000 and start TMR1 for 1sec interrupts 
....................     
....................    setup_ccp4(CCP_OFF);          // CCP4 off for now 
03F4E:  ANDWF  x57,F
....................     
....................    //setup_ccp(CCP_USE_TIMER5_AND_TIMER6 | CCP_CAPTURE_RE); 
....................    // CCP5/TMR5 serves only one purpose: measurement of spin rate.  
....................    setup_ccp5(CCP_OFF); 
03F50:  ANDWF  x54,F
....................  
....................    //********************CCP setup end********************    
....................     
....................    //********************INT setup start******************   
....................     
....................    /* Diables: 
....................     * Global int (all ints) 
....................     * All peripheral ints 
....................     * TMR0 overflow int 
....................     * INT0 ext int 
....................     * Port B IOC int 
....................     * Clears: 
....................     * TMROIF, INT0IF, RBIF 
....................     */ 
....................    INTCON = 0; 
03F52:  CLRF   FF2
....................     
....................    // PORTB pullups are enabled 
....................    // INTEDG0,1,2 on falling edge 
....................    // TMR0 and RBIP priority  is low 
....................    INTCON2 = 0; 
03F54:  CLRF   FF1
....................     
....................    // External INT1, INT2 disabled/cleared and set to low priority                               
....................    INTCON3 = 0; 
03F56:  CLRF   FF0
....................     
....................    // Int priority enabled (part of RCON) 
....................    IPEN = TRUE; 
03F58:  BSF    FD0.7
....................     
....................    // Clear all peripheral interrupts 
....................    PIR1 = 0;                            
03F5A:  CLRF   F9E
....................    PIR2 = 0; 
03F5C:  CLRF   FA1
....................    PIR3 = 0; 
03F5E:  CLRF   FA4
....................    PIR4 = 0; 
03F60:  CLRF   F7B
....................    PIR5 = 0; 
03F62:  CLRF   F7E
....................     
....................    // disable all peripheral interrupts 
....................    PIE1 = 0;                           
03F64:  CLRF   F9D
....................    PIE2 = 0; 
03F66:  CLRF   FA0
....................    PIE3 = 0; 
03F68:  CLRF   FA3
....................    PIE4 = 0; 
03F6A:  CLRF   F7A
....................    PIE5 = 0; 
03F6C:  CLRF   F7D
....................       
....................    //   IPR1 = 0; 
....................    //   IPR2 = 0; 
....................    //   IPR3 = 0; 
....................    //   IPR4 = 0; 
....................    //   IPR5 = 0; 
....................  
....................    // setup IOC to call INT_RB only on RB4 change 
....................    IOCB = 0b00010000;      
03F6E:  MOVLW  10
03F70:  MOVWF  F62
....................     
....................    //********************INT setup end********************  
....................                                 
....................    // initialize I2C 
....................    i2c_init(TRUE); 
03F72:  BCF    FCB.0
03F74:  BCF    FCB.1
03F76:  BCF    FCB.3
03F78:  MOVLW  06
03F7A:  MOVWF  FC8
03F7C:  MOVLW  28
03F7E:  MOVWF  FC6
03F80:  BSF    FC7.7
03F82:  BCF    FC7.6
....................                           
....................    // initalizes XDCR, sets global xdcr_enabled 
....................    adc_XDCR_init();                                     
03F84:  MOVLB  0
03F86:  GOTO   36CE
....................          
....................    // initalize LCD, sets global lcd_enabled 
....................    LCD_init(); 
03F8A:  RCALL  3856
....................     
....................    // set mppc value to 0                  
....................    set_mppc(global_mppc_value); 
03F8C:  MOVFF  B6,550
03F90:  RCALL  3CDC
....................     
....................    // set battery charge cycle to 100%   
....................    set_charge_duty(global_charge_duty); 
03F92:  MOVFF  B1,553
03F96:  MOVFF  B0,552
03F9A:  RCALL  3D68
....................     
....................    // initalize fixture, sets global fixture_enabled 
....................    fixture_init(); 
03F9C:  BRA    3E2A
....................     
....................    // Turn on LTC1541 and MCP4452  
....................    output_high(AUX_PWR); 
03F9E:  BSF    F8C.3
....................     
....................    /* This iS for power supply settling etc.. 
....................     * pause for 125ms or longer; should not hang; 
....................     */ 
....................    delay_ms(125); 
03FA0:  MOVLW  7D
03FA2:  MOVLB  5
03FA4:  MOVWF  x60
03FA6:  MOVLB  0
03FA8:  CALL   3736
03FAC:  GOTO   A10E (RETURN)
....................     
....................  
....................      
.................... } 
....................  
.................... void vars_init(void) 
.................... { 
.................... // initalizes all global variables to default values from globals.h 
....................  
.................... ////////////////////Global Variables Table of Contents///////////////////////// 
.................... //Test Globals 
.................... //LCD Globals 
.................... //Time Globals 
.................... //Hardware Enabled Globals 
.................... //Control Related Globals 
.................... //Mote Globals 
.................... //Priority Queue 
.................... //Time Queue 
.................... //Sprinkler Stack 
.................... //Command Stack 
.................... //System State Globals 
....................  
.................... ////////////////////Test Globals/////////////////////////////////////////////// 
....................    test_global = 0; 
....................    test_global_2 = 0; 
....................    test_start_time = 0; 
....................    test_end_time = 0; 
....................    test_valve_open_1 = 0; 
....................    test_rpm_1 = 0; 
....................    test_duty_cycle_1 = 0; 
....................    test_valve_open_2 = 0; 
....................    test_rpm_2 = 0; 
....................    test_duty_cycle_2 = 0; 
....................    test_valve_open_3 = 0; 
....................    test_rpm_3 = 0; 
....................    test_duty_cycle_3 = 0; 
....................   
.................... ////////////////////LCD Globals//////////////////////////////////////////////// 
....................    memset(global_temp_line_buff, 0, sizeof global_temp_line_buff); 
....................    global_extra_lcd_ptr = NULL; 
....................  
.................... ////////////////////Time Globals/////////////////////////////////////////////// 
....................    // keeps track of time since microprocessor has been awake in seconds 
....................    global_rtc_time = 0; 
....................    // keeps track of the time within the mote system (taken from mote) 
....................    global_utc_time = 0; 
....................  
.................... ////////////////////Hardware Enabled Globals/////////////////////////////////// 
....................    global_lcd_enabled = 0; 
....................    global_xcdr_type1_enabled = 0; 
....................    global_xcdr_type2_enabled = 0; 
....................    global_fixture_enabled = 0; 
....................    global_dust_enabled = 0; 
....................  
.................... ////////////////////Control Related Globals//////////////////////////////////// 
....................    // keeps track of rpms (updated via interrupt routine) 
....................    global_current_period = 0; 
....................    global_rpm_set_value = 100; 
....................    // keeps track of duty cycles of brake and charge 
....................    global_brake_duty = 0; 
....................    global_charge_duty = MAX_CHARGE; 
....................    // keeps track of mppc level 
....................    global_mppc_value = 100; 
....................    // keeps track of vgen 
....................    global_vgen = 0; 
....................    // keeps track of fixture dac value 
....................    global_fixture_dac_value = NO_FIXTURE; 
....................  
.................... ////////////////////Valve Related Globals////////////////////////////////////// 
.................... // keeps track of current valve position 
....................    global_valve_position = VLV_POSITION_UNKNOWN; 
....................  
.................... ////////////////////Mote Globals/////////////////////////////////////////////// 
....................    //event flags defined by mote 
....................    event_flags = 0; 
....................  
....................    // Note that bytes_from_mote union contains the stripped unstuffed data 
....................    //  eg, bytes_from_mote.dust_rcvd[128] 
....................     
....................    memset (&bytes_from_mote, 0, sizeof bytes_from_mote); 
....................    p = NULL; 
....................  
....................    // It just can't get bigger than this! 
....................    // pkgen places message to be sent here 
....................    memset(dust_send_buffer, 0, sizeof(dust_send_buffer)); 
....................  
....................    // this is only for doing acks and only needs to be  
....................    // MAX_USER_DATA_SIZE*2 + 2 + 4 + 12 + 2 
....................    // MAX_USER_DATA_SIZE is 2 bytes for ack 
....................    memset(dust_send_buffer_isr, 0, sizeof dust_send_buffer_isr); 
....................  
....................    // THIS is the buffer for RAW rcvd mote 
....................    //  mote packet data 
....................    memset(dust_recive_buffer, 0, sizeof dust_recive_buffer); 
....................  
....................    //  this is place 
....................    //  where the packet to be sent by micro 
....................    //  to NETWORK manager is placed prior 
....................    //  to dust_send_data call 
....................    memset(payload_buff, 0, sizeof payload_buff); 
....................  
....................    // Keeps track of how many bytes to send and passed between pkgen and pksend 
....................    num_of_bytes_to_send = 0; 
....................    num_of_bytes_to_send_isr = 0; 
....................  
....................    // This is specific to the subroutine 
....................    //  pkgen_send() which creates the message 
....................    //  to be sent from the mote to the net                      
....................    send_prefix[0] = CMD_SEND; 
....................    send_prefix[1] = 0; 
....................    send_prefix[2] = FLAG_SEND_REQUEST; 
....................    send_prefix[3] = DESTADDR_HI; 
....................    send_prefix[4] = DESTADDR_LO; 
....................    send_prefix[6] = APPDOMAIN_MAINTENANCE; 
....................    send_prefix[7] = PRIORITY_HI; 
....................    send_prefix[8] = 0; 
....................    send_prefix[9] = 0; 
....................    send_prefix[10] = 0xFF; 
....................    send_prefix[11] = 0; 
....................     
....................    // send_prefix[11] will be set to number of bytes in packet    
....................       // The send_prefix structure is as follows: 
....................       // [0]      CMD_SEND 
....................       // [1]      length of request       - this is payload length + 9 
....................       // [2]      FLAG_SEND_REQUEST 
....................       // [3]/[4]  destination address     - always DESTADDR_HI, DESTADDR_LO 
....................       // [5]      svc_index               - get this from service indication received 
....................       //                                     at join time 
....................       // [6]      APPDOMAIN_MAINTENANCE 
....................       // [7]      PRIORITY_HIGH 
....................       // [8][9]   reserved                - 0x00, 0x00  
....................       // [10]     sequence_num            - always 0xFF for mote-originated packets 
....................       // [11]     payload length          - length of the payload in bytes 
....................  
....................  
....................    // For ensuring a message was recieved properly from mote 
....................    result_rcvd = 0; 
....................  
....................    // Flag for going through deal with mote ISR and going to sleep afterwards 
....................    fl_mote_dealt = 0; 
....................    fl_alt_LCD = 0; 
....................  
....................    // Flag for a sucessful get/set response eliminating a few other flags 
....................    global_set_get_response = 0; 
....................  
....................    // FLAGS TO GET RID OF! 
....................    // Flag for receiving an advertisment 
....................    advert_rcvd_fl = 0; 
....................    setnetid_done_fl = 0; 
....................    ack_sent_fl = 0; 
....................    pkt_rcvd_fl = 0; 
....................    joinduty_done_fl = 0; 
....................    gettime_done_fl = 0; 
....................    fl_batNOEE = 0; 
....................    joinkey_done_fl = 0; 
....................    joincmd_done_fl = 0; 
....................  
....................    flags_rcvd = 0, param_type_rcvd = 0, svc_index_rcvd=0; 
....................    mote_msgSEQ = 0; 
....................  
....................    //Globals for when advertisements are received 
....................    network_id_rcvd = 0; 
....................    mote_id_rcvd = 0; 
....................    rssi_rcvd = 0; 
....................    hop_depth_rcvd = 0; 
....................  
....................    // More globals that we might actually want to keep 
....................    memset(serial_number_rcvd, 0, sizeof serial_number_rcvd); 
....................    memset(macaddr_rcvd, 0, sizeof macaddr_rcvd); 
....................  
.................... ////////////////////Priority Queue///////////////////////////////////////////// 
....................    // Actual priority queue 
....................    memset(global_priority_queue, 0, sizeof global_priority_queue); 
....................    global_current_priority_queue_location = (0-1); 
....................  
.................... ////////////////////Time Queue///////////////////////////////////////////////// 
....................    // Actual time queue 
....................    memset(global_time_queue, 0, sizeof global_time_queue); 
....................    global_current_time_queue_location = (0-1); 
....................  
.................... ////////////////////Sprinkler Queue//////////////////////////////////////////// 
....................    // Actual sprinkler queue 
....................    memset(global_sprinkler_queue, 0, sizeof global_sprinkler_queue); 
....................  
.................... ////////////////////Command Queue////////////////////////////////////////////// 
....................    // Actual command queue 
....................    memset(global_command_queue, 0, sizeof global_command_queue); 
....................  
.................... ////////////////////System State Variables///////////////////////////////////// 
....................    global_mote_state = MOTESTATE_UNKNOWN; 
....................    global_system_state = SYSTEM_STATE_UNKNOWN; 
.................... } 
....................  
.................... void deep_sleep(void) 
.................... {  // zzzzzzz....... 
....................  
.................... // Ways out of deep sleep: MCLR button, V_GEN_INT (int1) 
.................... // SW1 DOES not wake it up... 
....................  
....................    disable_interrupts(GLOBAL); 
*
0942C:  BCF    FF2.6
0942E:  BCF    FF2.7
09430:  BTFSC  FF2.7
09432:  BRA    942E
....................    strcpy (global_temp_line_buff, "Enter Deep Sleep"); 
09434:  CLRF   FEA
09436:  MOVLW  70
09438:  MOVWF  FE9
0943A:  MOVLW  00
0943C:  CALL   03BA
09440:  TBLRD*-
09442:  TBLRD*+
09444:  MOVF   FF5,W
09446:  MOVWF  FEE
09448:  IORLW  00
0944A:  BNZ   9442
....................    LCD_line1(global_temp_line_buff); 
0944C:  MOVLB  5
0944E:  CLRF   x60
09450:  MOVLW  70
09452:  MOVWF  x5F
09454:  MOVLB  0
09456:  CALL   37A0
....................    strcpy (global_temp_line_buff, "Reason:         "); 
0945A:  CLRF   FEA
0945C:  MOVLW  70
0945E:  MOVWF  FE9
09460:  MOVLW  00
09462:  CALL   03DC
09466:  TBLRD*-
09468:  TBLRD*+
0946A:  MOVF   FF5,W
0946C:  MOVWF  FEE
0946E:  IORLW  00
09470:  BNZ   9468
....................    global_temp_line_buff[8] = hi2asc(global_shutdown_cause); 
09472:  MOVFF  4D,560
09476:  CALL   3158
0947A:  MOVFF  01,78
....................    global_temp_line_buff[9] = lo2asc(global_shutdown_cause); 
0947E:  MOVFF  4D,560
09482:  CALL   3178
09486:  MOVFF  01,79
....................    LCD_line2(global_temp_line_buff);      
0948A:  MOVLB  5
0948C:  CLRF   x60
0948E:  MOVLW  70
09490:  MOVWF  x5F
09492:  MOVLB  0
09494:  CALL   37FA
....................     
....................    setup_T0_int(T0_6S); 
09498:  MOVLW  A4
0949A:  MOVLB  5
0949C:  MOVWF  x65
0949E:  MOVLW  73
094A0:  MOVWF  x64
094A2:  MOVLB  0
094A4:  CALL   36B2
....................    while (!TMR0IF); 
094A8:  BTFSS  FF2.2
094AA:  BRA    94A8
....................     
....................    LCD_shutdown(); 
094AC:  BRA    93B4
....................    output_a(PORTA_DEEP); 
094AE:  MOVLW  74
094B0:  MOVWF  F89
....................    output_b(PORTB_DEEP); 
094B2:  MOVLW  10
094B4:  MOVWF  F8A
....................    output_c(PORTC_DEEP); 
094B6:  MOVLW  45
094B8:  MOVWF  F8B
....................    output_d(PORTD_DEEP); 
094BA:  MOVLW  76
094BC:  MOVWF  F8C
....................    output_e(PORTE_DEEP); 
094BE:  CLRF   F8D
....................    set_tris_a(TRISA_NORM); 
094C0:  MOVLW  8B
094C2:  MOVWF  F92
....................    set_tris_b(TRISB_NORM); 
094C4:  MOVLW  F7
094C6:  MOVWF  F93
....................    set_tris_c(TRISC_NORM); 
094C8:  MOVLW  9A
094CA:  MOVWF  F94
....................    set_tris_d(TRISD_NORM); 
094CC:  MOVLW  80
094CE:  MOVWF  F95
....................    set_tris_e(TRISE_NORM); 
094D0:  BCF    F96.0
094D2:  BCF    F96.1
094D4:  BSF    F96.2
094D6:  BSF    F96.3
....................  
....................    setup_vref(VREF_OFF); 
094D8:  MOVLB  F
094DA:  CLRF   x42
....................    setup_dac(DAC_OFF); 
094DC:  CLRF   x41
....................    setup_adc(ADC_OFF); 
094DE:  BCF    FC2.0
....................    setup_CCP1(CCP_OFF); 
094E0:  MOVLW  F0
094E2:  ANDWF  FBD,F
....................    setup_CCP2(CCP_OFF); 
094E4:  ANDWF  F66,F
....................    setup_CCP3(CCP_OFF);    
094E6:  ANDWF  x5D,F
....................    setup_CCP4(CCP_OFF); 
094E8:  ANDWF  x57,F
....................    setup_CCP5(CCP_OFF); 
094EA:  ANDWF  x54,F
....................    setup_comparator(NC_NC_NC_NC); 
094EC:  CLRF   F77
094EE:  MOVLW  04
094F0:  MOVWF  F78
094F2:  MOVWF  F79
....................     
....................    clear_interrupt(INT_TIMER0); 
094F4:  BCF    FF2.2
....................    setup_timer_1(T1_DISABLED); 
094F6:  CLRF   FCD
094F8:  CLRF   FCC
....................    setup_timer_2(T2_DISABLED,0,1); 
094FA:  MOVLW  00
094FC:  MOVWF  FBA
094FE:  MOVLW  00
09500:  MOVWF  FBB
....................    setup_timer_3(T3_DISABLED); 
09502:  CLRF   FB4
09504:  CLRF   FB1
....................    setup_timer_4(T4_DISABLED,0,1); 
09506:  MOVWF  x51
09508:  MOVLW  00
0950A:  MOVWF  x52
....................    setup_timer_5(T5_DISABLED); 
0950C:  CLRF   x4D
0950E:  CLRF   x4E
....................    setup_timer_6(T6_DISABLED,0,1); 
09510:  MOVWF  x4A
09512:  MOVLW  00
09514:  MOVWF  x4B
....................     
....................    setup_wdt(WDT_OFF);    
09516:  BCF    FD1.0
....................  
....................    setup_uart(FALSE); 
09518:  BCF    FAB.7
0951A:  BCF    FAB.4
0951C:  BCF    FAC.5
....................  
....................    INTCON = 0;                         // TMR0, INT0. IOC ints disabled/cleared 
0951E:  CLRF   FF2
....................                                        //  High and Low Priority ints disabled 
....................    INTCON2 = 0;                        // RB port change int is low priority 
09520:  CLRF   FF1
....................                                        //  PORTB pullups are enabled 
....................    INTCON3 = 0;                        // INT1, INT2 ints disabled/cleared 
09522:  CLRF   FF0
....................    IPEN = TRUE;                        // Int priority enabled (part of RCON) 
09524:  BSF    FD0.7
....................     
....................    PIR1 = 0;                           // clear various interrupt flags 
09526:  CLRF   F9E
....................    PIR2 = 0; 
09528:  CLRF   FA1
....................    PIR3 = 0; 
0952A:  CLRF   FA4
....................    PIR4 = 0; 
0952C:  CLRF   F7B
....................    PIR5 = 0; 
0952E:  CLRF   F7E
....................     
....................    PIE1 = 0;                           // disable various interuupts 
09530:  CLRF   F9D
....................    PIE2 = 0; 
09532:  CLRF   FA0
....................    PIE3 = 0; 
09534:  CLRF   FA3
....................    PIE4 = 0; 
09536:  CLRF   F7A
....................    PIE5 = 0; 
09538:  CLRF   F7D
....................       
....................    IPR1 = 0; 
0953A:  CLRF   F9F
....................    IPR2 = 0; 
0953C:  CLRF   FA2
....................    IPR3 = 0; 
0953E:  CLRF   FA5
....................    IPR4 = 0; 
09540:  CLRF   F7C
....................    IPR5 = 0;   
09542:  CLRF   F7F
....................     
....................    IOCB = 0;                     // disable all PORTB interrupt on change 
09544:  CLRF   F62
....................                                  //  functionality 
....................    setup_adc_ports(NO_ANALOGS);                               
09546:  MOVF   FC1,W
09548:  ANDLW  F0
0954A:  MOVWF  FC1
0954C:  MOVLW  00
0954E:  MOVWF  x38
09550:  MOVWF  x3C
09552:  MOVWF  x39
09554:  MOVWF  x3A
09556:  MOVWF  x3B
....................    clear_interrupt(INT_EXT); 
09558:  BCF    FF2.1
....................    //clear_interrupt(INT_EXT2); 
....................    enable_interrupts(INT_EXT_L2H);  
0955A:  BSF    FF2.4
0955C:  BSF    FF1.6
....................    //enable_interrupts(INT_EXT2_H2L);  
....................    enable_interrupts(GLOBAL); 
0955E:  MOVLW  C0
09560:  IORWF  FF2,F
....................    delay_ms(1000);  
09562:  MOVLW  04
09564:  MOVLB  5
09566:  MOVWF  x5F
09568:  MOVLW  FA
0956A:  MOVWF  x60
0956C:  MOVLB  0
0956E:  CALL   3736
09572:  MOVLB  5
09574:  DECFSZ x5F,F
09576:  BRA    9568
....................       
....................    sleep(SLEEP_FULL); 
09578:  MOVFF  FD3,00
0957C:  BCF    FD3.7
0957E:  SLEEP 
09580:  MOVFF  00,FD3
....................  
....................    //reset_cpu(); 
....................    // wake up because of generator spin or SW1/Hall effect 
....................    if (input(V_GEN_INT)) 
09584:  BTFSS  F81.0
09586:  BRA    958A
....................    { 
....................    //   reset_cause = SPIN_RESTART; 
....................    // otherwise it was the SW1/Hall effect that woke it up 
....................       reset_cpu(); 
09588:  RESET
....................    } 
0958A:  MOVLB  0
0958C:  RETURN 0
....................    // deep sleep is exited by a MCLR, or V_GEN_INT (SPIN RESTART) 
....................    // If for some reason it woke up, but not because of a SPIN_RESTART 
....................    //  then simply go back to deep_sleep 
....................     
....................     
.................... }  
....................  
....................  
.................... void start_rtc(void) 
.................... { 
....................    global_rtc_time = 0; 
*
04050:  CLRF   x88
04052:  CLRF   x87
04054:  CLRF   x86
04056:  CLRF   x85
....................    CCP_4 = 0x8000; 
04058:  MOVLW  80
0405A:  MOVLB  F
0405C:  MOVWF  x59
0405E:  CLRF   x58
....................    setup_ccp4(CCP_USE_TIMER3_AND_TIMER4 | CCP_COMPARE_RESET_TIMER); 
04060:  MOVLW  0B
04062:  MOVWF  x57
04064:  MOVLW  FC
04066:  ANDWF  x48,F
04068:  MOVLW  01
0406A:  IORWF  x48,F
....................    CCP4IF = FALSE; 
0406C:  BCF    F7B.1
....................    setup_timer_3(T3_ENABLE_SOSC | T3_EXTERNAL_SYNC | T3_DIV_BY_1); 
0406E:  CLRF   FB4
04070:  MOVLW  8B
04072:  MOVWF  FB1
....................    set_timer3(0);    
04074:  CLRF   FB3
04076:  CLRF   FB2
....................    clear_interrupt(INT_CCP4); 
04078:  BCF    F7B.1
....................    enable_interrupts(INT_CCP4); 
0407A:  BSF    F7A.1
0407C:  MOVLB  0
0407E:  GOTO   A11E (RETURN)
.................... } 
....................  
.................... void safeI2C_start(void) 
.................... { 
....................    setup_T0_int(T0_10MS); 
*
03C8A:  MOVLB  5
03C8C:  SETF   x65
03C8E:  MOVLW  D9
03C90:  MOVWF  x64
03C92:  MOVLB  0
03C94:  RCALL  36B2
....................    while (I2CBUSY && !TMR0IF); 
03C96:  BTFSS  FC7.0
03C98:  BRA    3C9E
03C9A:  BTFSS  FF2.2
03C9C:  BRA    3C96
....................    if (!I2CBUSY) 
03C9E:  BTFSC  FC7.0
03CA0:  BRA    3CAA
....................       i2c_start(); 
03CA2:  BSF    FC5.0
03CA4:  BTFSC  FC5.0
03CA6:  BRA    3CA4
03CA8:  BRA    3CC6
....................    else 
....................    { 
....................       BCL1IF = FALSE; 
03CAA:  BCF    FA1.3
....................       WCOL = FALSE; 
03CAC:  BCF    FC6.7
....................       i2c_init(TRUE); 
03CAE:  BCF    FCB.0
03CB0:  BCF    FCB.1
03CB2:  BCF    FCB.3
03CB4:  MOVLW  06
03CB6:  MOVWF  FC8
03CB8:  MOVLW  28
03CBA:  MOVWF  FC6
03CBC:  BSF    FC7.7
03CBE:  BCF    FC7.6
....................       i2c_start(); 
03CC0:  BSF    FC5.1
03CC2:  BTFSC  FC5.1
03CC4:  BRA    3CC2
....................    } 
03CC6:  RETURN 0
....................        
.................... } 
....................  
.................... void safeI2C_write(uint8_t value) 
.................... { 
....................    // thinking that a spike on the data or clock line is f'ing up 
....................    // i2c transmission, this routine simply looks for the ACK and if 
....................    // it does not see it, tries ONE MORE TIME and one more time only! 
....................    int1  unsuccess_fl; 
....................     
....................    unsuccess_fl = i2c_write(value); 
03CC8:  MOVFF  551,578
03CCC:  RCALL  3752
03CCE:  MOVF   01,W
03CD0:  MOVLB  5
03CD2:  BCF    x52.0
03CD4:  BTFSC  01.0
03CD6:  BSF    x52.0
03CD8:  MOVLB  0
03CDA:  RETURN 0
.................... //   if (unsuccess_fl) 
.................... //      i2c_write(value); 
.................... }     
....................  
.................... void setup_rb4_int(void) 
.................... {            
....................    RBIF = FALSE; 
*
045FE:  BCF    FF2.0
....................    enable_interrupts(INT_RB4);       
04600:  BSF    FF2.3
04602:  BSF    F62.4
04604:  GOTO   A1AE (RETURN)
.................... }      
....................  
.................... void write_system_state(uint8_t system_state_to_change_to)     
.................... { 
....................         
....................    if ((global_system_state == SYSTEM_IDLE) && (system_state_to_change_to == SYSTEM_RUN))  
*
030EA:  MOVLB  5
030EC:  MOVF   x01,W
030EE:  SUBLW  03
030F0:  BNZ   30FA
030F2:  MOVF   x47,W
030F4:  SUBLW  02
030F6:  BNZ   30FA
....................    {                            
....................       // change processor speed?  
....................       //fosc_250k();  
....................    }                                              
030F8:  BRA    3114
....................    else if ((global_system_state == SYSTEM_RUN) && (system_state_to_change_to == SYSTEM_IDLE))                
030FA:  MOVF   x01,W
030FC:  SUBLW  02
030FE:  BNZ   3108
03100:  MOVF   x47,W
03102:  SUBLW  03
03104:  BNZ   3108
....................    { 
....................       // change processor speed? 
....................       //fosc_31250();             
....................    } 
03106:  BRA    3114
....................    else if ((global_system_state == SYSTEM_IDLE) && (system_state_to_change_to != SYSTEM_IDLE)) 
03108:  MOVF   x01,W
0310A:  SUBLW  03
0310C:  BNZ   3114
0310E:  MOVF   x47,W
03110:  SUBLW  03
03112:  BZ    3114
....................    {      
....................       // change processor speed?  
....................       //fosc_250k();      
....................    }                                     
....................    global_system_state = system_state_to_change_to; 
03114:  MOVFF  547,501
03118:  MOVLB  0
0311A:  RETURN 0
.................... }       
....................  
.................... uint8_t read_system_state(void) 
.................... { 
....................    return global_system_state; 
*
01DC6:  MOVLB  5
01DC8:  MOVFF  501,01
01DCC:  MOVLB  0
01DCE:  RETURN 0
.................... } 
....................    
....................  
.................... #include "dust.h"                                        
.................... void mote_init(void) 
.................... { 
....................    // sets the mote message sequence to a random number 
....................    init_msgSEQ(); 
*
04284:  BRA    423A
....................    // enable appropriate interrupts for mote response 
....................    clear_interrupt(INT_EXT2_H2L); 
04286:  BCF    FF0.1
....................    enable_interrupts(INT_EXT2_H2L); 
04288:  BSF    FF0.4
0428A:  BCF    FF1.4
0428C:  GOTO   A126 (RETURN)
.................... }    
....................     
.................... void mote_reset(void) 
.................... { 
....................    // Resets the mote, enables interrupts for the mote to respond, and 
....................    // schedules a WAIT_FOR_BOOT_EVENT to see if the mote responded 
....................   
....................    // Force an reset 
....................    output_low(MOTE_RESETn); 
*
044DE:  BCF    F8C.4
....................    // definitely long enough at any clock speed 
....................    setup_T0_int(T0_250MS); 
044E0:  MOVLW  FC
044E2:  MOVLB  5
044E4:  MOVWF  x65
044E6:  MOVLW  30
044E8:  MOVWF  x64
044EA:  MOVLB  0
044EC:  CALL   36B2
....................    while (!TMR0IF);    
044F0:  BTFSS  FF2.2
044F2:  BRA    44F0
....................    output_high(MOTE_RESETn); 
044F4:  BSF    F8C.4
....................       
....................    // add boot event checkup 
....................    PUSH_TIME_QUEUE_MACRO((global_rtc_time + 6), WAIT_FOR_BOOT_EVENT) 
044F6:  BCF    F7A.1
044F8:  MOVLW  06
044FA:  ADDWF  x85,W
044FC:  MOVLB  5
044FE:  MOVWF  x47
04500:  MOVLW  00
04502:  MOVLB  0
04504:  ADDWFC x86,W
04506:  MOVLB  5
04508:  MOVWF  x48
0450A:  MOVLW  00
0450C:  MOVLB  0
0450E:  ADDWFC x87,W
04510:  MOVLB  5
04512:  MOVWF  x49
04514:  MOVLW  00
04516:  MOVLB  0
04518:  ADDWFC x88,W
0451A:  MOVLB  5
0451C:  MOVWF  x4A
0451E:  MOVWF  x55
04520:  MOVFF  549,554
04524:  MOVFF  548,553
04528:  MOVFF  547,552
0452C:  MOVLW  10
0452E:  MOVWF  x56
04530:  MOVLB  0
04532:  RCALL  4290
04534:  BSF    F7A.1
04536:  RETURN 0
.................... } 
....................  
.................... uint8_t mote_sleep(void) 
.................... { 
....................    uint8_t  result_byte; 
....................  
....................    // set the join duty and timeout error handling 
....................    global_set_get_response = FALSE; 
*
09D8A:  MOVLB  3
09D8C:  BCF    x5C.2
....................    pkgen_sleep(); 
09D8E:  MOVLW  09
09D90:  MOVLB  5
09D92:  MOVWF  x48
09D94:  CLRF   x49
09D96:  MOVLW  04
09D98:  MOVWF  x4A
09D9A:  CLRF   x62
09D9C:  CLRF   x61
09D9E:  CLRF   x63
09DA0:  MOVLW  05
09DA2:  MOVWF  x65
09DA4:  MOVLW  48
09DA6:  MOVWF  x64
09DA8:  MOVLW  03
09DAA:  MOVWF  x66
09DAC:  MOVLB  0
09DAE:  CALL   5E58
....................    result_byte = dust_hdlc_pksend(); 
09DB2:  CALL   6102
09DB6:  MOVFF  01,547
....................    setup_T0_int(T0_250MS); 
09DBA:  MOVLW  FC
09DBC:  MOVLB  5
09DBE:  MOVWF  x65
09DC0:  MOVLW  30
09DC2:  MOVWF  x64
09DC4:  MOVLB  0
09DC6:  CALL   36B2
....................    while (!TMR0IF && !result_byte); 
09DCA:  BTFSC  FF2.2
09DCC:  BRA    9DDC
09DCE:  MOVLB  5
09DD0:  MOVF   x47,F
09DD2:  BTFSS  FD8.2
09DD4:  BRA    9DDA
09DD6:  MOVLB  0
09DD8:  BRA    9DCA
09DDA:  MOVLB  0
....................    if (TMR0IF || result_byte) 
09DDC:  BTFSC  FF2.2
09DDE:  BRA    9DE8
09DE0:  MOVLB  5
09DE2:  MOVF   x47,F
09DE4:  BZ    9DEC
09DE6:  MOVLB  0
....................    { 
....................       //return ERR_MOTE_UNRESPONSIVE; 
....................    } 
09DE8:  BRA    9DF4
09DEA:  MOVLB  5
....................    else 
....................    { 
....................       return NO_ERR; 
09DEC:  MOVLW  00
09DEE:  MOVWF  01
09DF0:  BRA    9DFA
09DF2:  MOVLB  0
....................    } 
....................    return NO_ERR; 
09DF4:  MOVLW  00
09DF6:  MOVWF  01
09DF8:  MOVLB  5
09DFA:  MOVLB  0
09DFC:  GOTO   ACFA (RETURN)
.................... } 
.................... void     search_for_strongest(void) 
*
0969A:  MOVLW  80
0969C:  MOVLB  5
0969E:  MOVWF  x48
096A0:  CLRF   x4A
096A2:  CLRF   x49
096A4:  CLRF   x4C
096A6:  CLRF   x4B
.................... { 
....................    uint8_t     result_byte; 
....................    int8_t      rssi_best = -128; 
....................    int16_t     net_id_best = 0, net_id_current = 0;; 
....................    uint32_t    search_start_time = 0; 
....................    int1        net_id_selected = 0; 
096A8:  CLRF   x50
096AA:  CLRF   x4F
096AC:  CLRF   x4E
096AE:  CLRF   x4D
096B0:  BCF    x51.0
....................     
....................    strcpy (global_temp_line_buff, " Searching ???? "); 
096B2:  CLRF   FEA
096B4:  MOVLW  70
096B6:  MOVWF  FE9
096B8:  MOVLW  00
096BA:  MOVLB  0
096BC:  CALL   03FE
096C0:  TBLRD*-
096C2:  TBLRD*+
096C4:  MOVF   FF5,W
096C6:  MOVWF  FEE
096C8:  IORLW  00
096CA:  BNZ   96C2
....................    LCD_line1(global_temp_line_buff); 
096CC:  MOVLB  5
096CE:  CLRF   x60
096D0:  MOVLW  70
096D2:  MOVWF  x5F
096D4:  MOVLB  0
096D6:  CALL   37A0
....................    strcpy (global_temp_line_buff, "nnnn iii sss ddd"); 
096DA:  CLRF   FEA
096DC:  MOVLW  70
096DE:  MOVWF  FE9
096E0:  MOVLW  00
096E2:  CALL   0420
096E6:  TBLRD*-
096E8:  TBLRD*+
096EA:  MOVF   FF5,W
096EC:  MOVWF  FEE
096EE:  IORLW  00
096F0:  BNZ   96E8
....................    LCD_line2(global_temp_line_buff); 
096F2:  MOVLB  5
096F4:  CLRF   x60
096F6:  MOVLW  70
096F8:  MOVWF  x5F
096FA:  MOVLB  0
096FC:  CALL   37FA
....................    
....................    //prepare mote message for searching 
....................    pkgen_search(); 
09700:  MOVLW  11
09702:  MOVLB  5
09704:  MOVWF  x52
09706:  CLRF   x53
09708:  MOVLW  04
0970A:  MOVWF  x54
0970C:  CLRF   x62
0970E:  CLRF   x61
09710:  CLRF   x63
09712:  MOVLW  05
09714:  MOVWF  x65
09716:  MOVLW  52
09718:  MOVWF  x64
0971A:  MOVLW  03
0971C:  MOVWF  x66
0971E:  MOVLB  0
09720:  CALL   5E58
....................    result_byte = dust_hdlc_pksend();          
09724:  CALL   6102
09728:  MOVFF  01,547
....................     
....................    // hangs until search begins or request times out; 
....................    setup_T0_int(T0_250MS); 
0972C:  MOVLW  FC
0972E:  MOVLB  5
09730:  MOVWF  x65
09732:  MOVLW  30
09734:  MOVWF  x64
09736:  MOVLB  0
09738:  CALL   36B2
....................    while (!TMR0IF && (global_mote_state != MOTESTATE_SEARCHING) && !result_byte); 
0973C:  BTFSC  FF2.2
0973E:  BRA    975A
09740:  MOVLB  5
09742:  MOVF   x00,W
09744:  SUBLW  02
09746:  BTFSS  FD8.2
09748:  BRA    974E
0974A:  MOVLB  0
0974C:  BRA    975A
0974E:  MOVF   x47,F
09750:  BTFSS  FD8.2
09752:  BRA    9758
09754:  MOVLB  0
09756:  BRA    973C
09758:  MOVLB  0
....................     
....................    //  immediately goes to sleep if ERR_MTNOTREADY 
....................    if (TMR0IF || global_mote_state != MOTESTATE_SEARCHING) 
0975A:  BTFSC  FF2.2
0975C:  BRA    9768
0975E:  MOVLB  5
09760:  MOVF   x00,W
09762:  SUBLW  02
09764:  BZ    9770
09766:  MOVLB  0
....................    { 
....................       global_shutdown_cause = ERR_NO_ADV_WHILE_SEARCHING; 
09768:  MOVLW  02
0976A:  MOVWF  4D
....................       deep_sleep();       
0976C:  RCALL  942C
0976E:  MOVLB  5
....................    } 
....................     
....................     
....................    // Search algorithm continues for MOTE_SEARCH_TIME or until net_id is selected 
....................    search_start_time = global_rtc_time; 
09770:  MOVFF  88,550
09774:  MOVFF  87,54F
09778:  MOVFF  86,54E
0977C:  MOVFF  85,54D
....................    while((global_rtc_time < (search_start_time + MOTE_SEARCH_TIME)) && !net_id_selected) 
09780:  MOVF   x1F,W
09782:  ADDWF  x4D,W
09784:  MOVWF  00
09786:  MOVF   x20,W
09788:  ADDWFC x4E,W
0978A:  MOVWF  01
0978C:  MOVLW  00
0978E:  ADDWFC x4F,W
09790:  MOVWF  02
09792:  MOVLW  00
09794:  ADDWFC x50,W
09796:  MOVWF  03
09798:  MOVLB  0
0979A:  MOVF   x88,W
0979C:  SUBWF  03,W
0979E:  BTFSS  FD8.0
097A0:  BRA    9952
097A2:  BNZ   97C0
097A4:  MOVF   x87,W
097A6:  SUBWF  02,W
097A8:  BTFSS  FD8.0
097AA:  BRA    9952
097AC:  BNZ   97C0
097AE:  MOVF   x86,W
097B0:  SUBWF  01,W
097B2:  BTFSS  FD8.0
097B4:  BRA    9952
097B6:  BNZ   97C0
097B8:  MOVF   00,W
097BA:  SUBWF  x85,W
097BC:  BTFSC  FD8.0
097BE:  BRA    9952
097C0:  MOVLB  5
097C2:  BTFSS  x51.0
097C4:  BRA    97CA
097C6:  MOVLB  0
097C8:  BRA    9952
....................    { 
....................       // use SW1 to exit early, give user a chance to select strongest netid 
....................       setup_T0_int(T0_2S); 
097CA:  MOVLW  E1
097CC:  MOVWF  x65
097CE:  MOVLW  7C
097D0:  MOVWF  x64
097D2:  MOVLB  0
097D4:  CALL   36B2
....................       while (!TMR0IF) 
097D8:  BTFSC  FF2.2
097DA:  BRA    9802
....................       { 
....................          if (!input(SW1n))                
097DC:  BTFSC  F81.4
097DE:  BRA    9800
....................          { 
....................             //wait for 250MS for debounce                    
....................             setup_T0_int(T0_250MS); 
097E0:  MOVLW  FC
097E2:  MOVLB  5
097E4:  MOVWF  x65
097E6:  MOVLW  30
097E8:  MOVWF  x64
097EA:  MOVLB  0
097EC:  CALL   36B2
....................             while (!TMR0IF);                                                  
097F0:  BTFSS  FF2.2
097F2:  BRA    97F0
....................             //check button after 250ms to see if it's still depressed, if so, exit 
....................             if (!input(SW1n)) 
097F4:  BTFSC  F81.4
097F6:  BRA    9800
....................             { 
....................                net_id_selected = TRUE; 
097F8:  MOVLB  5
097FA:  BSF    x51.0
....................                break; 
097FC:  MOVLB  0
097FE:  BRA    9802
....................             }                                                                
....................          } 
09800:  BRA    97D8
....................       } 
....................        
....................       // if a new advertisement flag is triggered                      
....................       if (advert_rcvd_fl) 
09802:  MOVLB  3
09804:  BTFSS  x5C.3
09806:  BRA    994C
....................          { 
....................             //saves current net id 
....................             net_id_current = network_id_rcvd; 
09808:  MOVFF  364,54C
0980C:  MOVFF  363,54B
....................             //displays information from advertisement 
....................             process_advert(); 
09810:  MOVLB  0
09812:  BRA    958E
....................             //reset advertisement flag 
....................             advert_rcvd_fl = FALSE; 
09814:  MOVLB  3
09816:  BCF    x5C.3
....................  
....................             //if the advertisement came from a manager, give user a chance to  
....................             //select it and exit 
....................             if (mote_id_rcvd == 1) 
09818:  DECFSZ x65,W
0981A:  BRA    994C
0981C:  MOVF   x66,F
0981E:  BTFSS  FD8.2
09820:  BRA    994C
....................             { 
....................                // if lcd is connected, give user a chance to select it 
....................                if (global_lcd_enabled == TRUE) 
09822:  MOVLB  0
09824:  BTFSS  xA3.0
09826:  BRA    98B8
....................                { 
....................                   strcpy (global_temp_line_buff, "SW1 to Join     "); 
09828:  CLRF   FEA
0982A:  MOVLW  70
0982C:  MOVWF  FE9
0982E:  MOVLW  00
09830:  CALL   0442
09834:  TBLRD*-
09836:  TBLRD*+
09838:  MOVF   FF5,W
0983A:  MOVWF  FEE
0983C:  IORLW  00
0983E:  BNZ   9836
....................                   global_temp_line_buff[12] = hi2asc(make8(network_id_rcvd,1)); 
09840:  MOVFF  364,55F
09844:  MOVFF  364,560
09848:  CALL   3158
0984C:  MOVFF  01,7C
....................                   global_temp_line_buff[13] = lo2asc(make8(network_id_rcvd,1)); 
09850:  MOVFF  364,55F
09854:  MOVFF  364,560
09858:  CALL   3178
0985C:  MOVFF  01,7D
....................                   global_temp_line_buff[14] = hi2asc(make8(network_id_rcvd,0)); 
09860:  MOVFF  363,55F
09864:  MOVFF  363,560
09868:  CALL   3158
0986C:  MOVFF  01,7E
....................                   global_temp_line_buff[15] = lo2asc(make8(network_id_rcvd,0)); 
09870:  MOVFF  363,55F
09874:  MOVFF  363,560
09878:  CALL   3178
0987C:  MOVFF  01,7F
....................                   LCD_line1(global_temp_line_buff); 
09880:  MOVLB  5
09882:  CLRF   x60
09884:  MOVLW  70
09886:  MOVWF  x5F
09888:  MOVLB  0
0988A:  CALL   37A0
....................                    
....................                   // give the user a chance to select the current NetID for 4sec 
....................                   setup_T0_int(T0_4S); 
0988E:  MOVLW  C2
09890:  MOVLB  5
09892:  MOVWF  x65
09894:  MOVLW  F7
09896:  MOVWF  x64
09898:  MOVLB  0
0989A:  CALL   36B2
....................                   while (!TMR0IF) 
0989E:  BTFSC  FF2.2
098A0:  BRA    98B8
....................                   {                               
....................                      if (!input(SW1n)) 
098A2:  BTFSC  F81.4
098A4:  BRA    98B6
....................                      { 
....................                         net_id_best = net_id_current; 
098A6:  MOVFF  54C,54A
098AA:  MOVFF  54B,549
....................                         net_id_selected = 1; 
098AE:  MOVLB  5
098B0:  BSF    x51.0
....................                         break; 
098B2:  MOVLB  0
098B4:  BRA    98B8
....................                      } 
098B6:  BRA    989E
....................                   } 
....................                } 
....................                 
....................                // store the strongest signal unless user selected network 
....................                if ((rssi_rcvd > rssi_best) && (net_id_selected == FALSE)) 
098B8:  MOVLB  5
098BA:  MOVF   x48,W
098BC:  XORLW  80
098BE:  MOVWF  00
098C0:  MOVLB  3
098C2:  MOVF   x67,W
098C4:  XORLW  80
098C6:  SUBWF  00,W
098C8:  BC    98E2
098CA:  MOVLB  5
098CC:  BTFSS  x51.0
098CE:  BRA    98D4
098D0:  MOVLB  3
098D2:  BRA    98E2
....................                { 
....................                   rssi_best = rssi_rcvd; 
098D4:  MOVFF  367,548
....................                   net_id_best = network_id_rcvd; 
098D8:  MOVFF  364,54A
098DC:  MOVFF  363,549
098E0:  MOVLB  3
....................                } 
....................                strcpy (global_temp_line_buff, "Strongest:      "); 
098E2:  CLRF   FEA
098E4:  MOVLW  70
098E6:  MOVWF  FE9
098E8:  MOVLW  00
098EA:  MOVLB  0
098EC:  CALL   0464
098F0:  TBLRD*-
098F2:  TBLRD*+
098F4:  MOVF   FF5,W
098F6:  MOVWF  FEE
098F8:  IORLW  00
098FA:  BNZ   98F2
....................                global_temp_line_buff[12] = hi2asc(make8(net_id_best,1)); 
098FC:  MOVFF  54A,55F
09900:  MOVFF  54A,560
09904:  CALL   3158
09908:  MOVFF  01,7C
....................                global_temp_line_buff[13] = lo2asc(make8(net_id_best,1)); 
0990C:  MOVFF  54A,55F
09910:  MOVFF  54A,560
09914:  CALL   3178
09918:  MOVFF  01,7D
....................                global_temp_line_buff[14] = hi2asc(make8(net_id_best,0)); 
0991C:  MOVFF  549,55F
09920:  MOVFF  549,560
09924:  CALL   3158
09928:  MOVFF  01,7E
....................                global_temp_line_buff[15] = lo2asc(make8(net_id_best,0)); 
0992C:  MOVFF  549,55F
09930:  MOVFF  549,560
09934:  CALL   3178
09938:  MOVFF  01,7F
....................                LCD_line1(global_temp_line_buff); 
0993C:  MOVLB  5
0993E:  CLRF   x60
09940:  MOVLW  70
09942:  MOVWF  x5F
09944:  MOVLB  0
09946:  CALL   37A0
0994A:  MOVLB  3
....................             } 
....................          } 
0994C:  MOVLB  5
0994E:  BRA    9780
09950:  MOVLB  0
....................       } 
....................                 
....................    disable_interrupts(GLOBAL); 
09952:  BCF    FF2.6
09954:  BCF    FF2.7
09956:  BTFSC  FF2.7
09958:  BRA    9954
....................     
....................    net_id_best = __swap16(net_id_best);        // swap the bytes [why?] 
0995A:  MOVFF  549,560
0995E:  MOVLB  5
09960:  CLRF   x5F
09962:  MOVF   x4A,W
09964:  CLRF   03
09966:  IORWF  x5F,W
09968:  MOVWF  00
0996A:  MOVF   03,W
0996C:  IORWF  x49,W
0996E:  MOVFF  00,549
09972:  MOVWF  x4A
....................    if (!net_id_best) 
09974:  MOVF   x49,W
09976:  IORWF  x4A,W
09978:  BNZ   9984
....................    { 
....................       // send to deep sleep as no network was found 
....................       global_shutdown_cause = ERR_NO_ADV_WHILE_SEARCHING; 
0997A:  MOVLW  02
0997C:  MOVWF  4D
....................       deep_sleep(); 
0997E:  MOVLB  0
09980:  RCALL  942C
09982:  MOVLB  5
....................    } 
....................    
....................    // now set the best network id into the motes NV memory 
....................    pkgen_setnv_networkid(net_id_best); 
09984:  MOVLW  03
09986:  MOVWF  x55
09988:  MOVLW  07
0998A:  MOVWF  x56
0998C:  MOVLW  04
0998E:  MOVWF  x57
09990:  CLRF   x58
09992:  CLRF   x59
09994:  CLRF   x5A
09996:  CLRF   x5B
09998:  MOVLW  03
0999A:  MOVWF  x5C
0999C:  MOVFF  54A,55E
099A0:  MOVFF  549,55D
099A4:  MOVLW  05
099A6:  MOVWF  x60
099A8:  MOVLW  5D
099AA:  MOVWF  x5F
099AC:  MOVLW  05
099AE:  MOVWF  x62
099B0:  MOVLW  55
099B2:  MOVWF  x61
099B4:  MOVLW  08
099B6:  MOVWF  x63
099B8:  MOVFF  560,565
099BC:  MOVFF  55F,564
099C0:  MOVLW  02
099C2:  MOVWF  x66
099C4:  MOVLB  0
099C6:  CALL   5E58
....................    result_byte = dust_hdlc_pksend(); 
099CA:  CALL   6102
099CE:  MOVFF  01,547
....................    setup_T0_int(T0_250MS); 
099D2:  MOVLW  FC
099D4:  MOVLB  5
099D6:  MOVWF  x65
099D8:  MOVLW  30
099DA:  MOVWF  x64
099DC:  MOVLB  0
099DE:  CALL   36B2
....................    while (!TMR0IF && !setnetid_done_fl && !result_byte); 
099E2:  BTFSC  FF2.2
099E4:  BRA    99FE
099E6:  MOVLB  3
099E8:  BTFSS  x5C.4
099EA:  BRA    99F0
099EC:  MOVLB  0
099EE:  BRA    99FE
099F0:  MOVLB  5
099F2:  MOVF   x47,F
099F4:  BTFSS  FD8.2
099F6:  BRA    99FC
099F8:  MOVLB  0
099FA:  BRA    99E2
099FC:  MOVLB  0
....................     
....................    if (TMR0IF || result_byte) 
099FE:  BTFSC  FF2.2
09A00:  BRA    9A0A
09A02:  MOVLB  5
09A04:  MOVF   x47,F
09A06:  BZ    9A12
09A08:  MOVLB  0
....................    { 
....................       // send to deep sleep network couldn't be joined 
....................       global_shutdown_cause = ERR_NETWORK_JOIN_FAIL; 
09A0A:  MOVLW  06
09A0C:  MOVWF  4D
....................       deep_sleep(); 
09A0E:  RCALL  942C
09A10:  MOVLB  5
....................    } 
....................     
....................    strcpy (global_temp_line_buff, " Search Success "); 
09A12:  CLRF   FEA
09A14:  MOVLW  70
09A16:  MOVWF  FE9
09A18:  MOVLW  00
09A1A:  MOVLB  0
09A1C:  CALL   0486
09A20:  TBLRD*-
09A22:  TBLRD*+
09A24:  MOVF   FF5,W
09A26:  MOVWF  FEE
09A28:  IORLW  00
09A2A:  BNZ   9A22
....................    LCD_line1(global_temp_line_buff); 
09A2C:  MOVLB  5
09A2E:  CLRF   x60
09A30:  MOVLW  70
09A32:  MOVWF  x5F
09A34:  MOVLB  0
09A36:  CALL   37A0
....................    strcpy (global_temp_line_buff, "Next join:      "); 
09A3A:  CLRF   FEA
09A3C:  MOVLW  70
09A3E:  MOVWF  FE9
09A40:  MOVLW  00
09A42:  CALL   04A8
09A46:  TBLRD*-
09A48:  TBLRD*+
09A4A:  MOVF   FF5,W
09A4C:  MOVWF  FEE
09A4E:  IORLW  00
09A50:  BNZ   9A48
....................    global_temp_line_buff[12] = hi2asc(make8(net_id_best,0)); 
09A52:  MOVFF  549,55F
09A56:  MOVFF  549,560
09A5A:  CALL   3158
09A5E:  MOVFF  01,7C
....................    global_temp_line_buff[13] = lo2asc(make8(net_id_best,0)); 
09A62:  MOVFF  549,55F
09A66:  MOVFF  549,560
09A6A:  CALL   3178
09A6E:  MOVFF  01,7D
....................    global_temp_line_buff[14] = hi2asc(make8(net_id_best,1)); 
09A72:  MOVFF  54A,55F
09A76:  MOVFF  54A,560
09A7A:  CALL   3158
09A7E:  MOVFF  01,7E
....................    global_temp_line_buff[15] = lo2asc(make8(net_id_best,1)); 
09A82:  MOVFF  54A,55F
09A86:  MOVFF  54A,560
09A8A:  CALL   3178
09A8E:  MOVFF  01,7F
....................    LCD_line2(global_temp_line_buff); 
09A92:  MOVLB  5
09A94:  CLRF   x60
09A96:  MOVLW  70
09A98:  MOVWF  x5F
09A9A:  MOVLB  0
09A9C:  CALL   37FA
....................  
....................    // Let it sit on the screen for a couple seconds 
....................    setup_T0_int(T0_2S); 
09AA0:  MOVLW  E1
09AA2:  MOVLB  5
09AA4:  MOVWF  x65
09AA6:  MOVLW  7C
09AA8:  MOVWF  x64
09AAA:  MOVLB  0
09AAC:  CALL   36B2
....................    while (!TMR0IF);       
09AB0:  BTFSS  FF2.2
09AB2:  BRA    9AB0
....................     
....................    happy_lites();                                            
09AB4:  CALL   4E20
....................                                                  
....................    // send to deep sleep as network id is now set 
....................    global_shutdown_cause |= NEW_NETWORK_ID_SET; 
09AB8:  MOVLW  03
09ABA:  IORWF  4D,F
....................    deep_sleep(); 
09ABC:  RCALL  942C
....................     
....................    return; 
09ABE:  GOTO   AD90 (RETURN)
.................... } 
....................  
.................... void  process_advert(void) 
.................... { 
....................    strcpy (global_temp_line_buff, "                "); 
*
0958E:  CLRF   FEA
09590:  MOVLW  70
09592:  MOVWF  FE9
09594:  MOVLW  00
09596:  CALL   04CA
0959A:  TBLRD*-
0959C:  TBLRD*+
0959E:  MOVF   FF5,W
095A0:  MOVWF  FEE
095A2:  IORLW  00
095A4:  BNZ   959C
....................  
....................    global_temp_line_buff[0] = hi2asc(make8(network_id_rcvd,1)); 
095A6:  MOVFF  364,55F
095AA:  MOVFF  364,560
095AE:  CALL   3158
095B2:  MOVFF  01,70
....................    global_temp_line_buff[1] = lo2asc(make8(network_id_rcvd,1)); 
095B6:  MOVFF  364,55F
095BA:  MOVFF  364,560
095BE:  CALL   3178
095C2:  MOVFF  01,71
....................    global_temp_line_buff[2] = hi2asc(make8(network_id_rcvd,0)); 
095C6:  MOVFF  363,55F
095CA:  MOVFF  363,560
095CE:  CALL   3158
095D2:  MOVFF  01,72
....................    global_temp_line_buff[3] = lo2asc(make8(network_id_rcvd,0)); 
095D6:  MOVFF  363,55F
095DA:  MOVFF  363,560
095DE:  CALL   3178
095E2:  MOVFF  01,73
....................    // NOTE network_id_rcvd is swapped when rcvd to simplify 
....................    //  the netID comparisons that take place later 
....................     
....................    LCD_line2(global_temp_line_buff);  
095E6:  MOVLB  5
095E8:  CLRF   x60
095EA:  MOVLW  70
095EC:  MOVWF  x5F
095EE:  MOVLB  0
095F0:  CALL   37FA
....................     
....................    mote_id_rcvd = __swap16(mote_id_rcvd);    // swap the bytes [why?] 
095F4:  MOVFF  365,560
095F8:  MOVLB  5
095FA:  CLRF   x5F
095FC:  MOVLB  3
095FE:  MOVF   x66,W
09600:  CLRF   03
09602:  MOVLB  5
09604:  IORWF  x5F,W
09606:  MOVLB  3
09608:  MOVWF  x65
0960A:  MOVF   03,W
0960C:  MOVLB  5
0960E:  IORWF  x60,W
09610:  MOVLB  3
09612:  MOVWF  x66
....................     
....................    LCD_place_uint16(mote_id_rcvd, 1, 5, 3); 
09614:  MOVFF  366,560
09618:  MOVFF  365,55F
0961C:  MOVLW  01
0961E:  MOVLB  5
09620:  MOVWF  x61
09622:  MOVLW  05
09624:  MOVWF  x62
09626:  MOVLW  03
09628:  MOVWF  x63
0962A:  MOVLB  0
0962C:  CALL   6828
....................  
....................     
....................       if (rssi_rcvd >= 0) 
09630:  MOVLB  3
09632:  BTFSC  x67.7
09634:  BRA    9656
....................       { 
....................          LCD_place_uint8(((uint8_t)(rssi_rcvd) + 128), 1, 9, 3); 
09636:  MOVLW  80
09638:  ADDWF  x67,W
0963A:  MOVLB  5
0963C:  MOVWF  x5F
0963E:  MOVWF  x60
09640:  MOVLW  01
09642:  MOVWF  x61
09644:  MOVLW  09
09646:  MOVWF  x62
09648:  MOVLW  03
0964A:  MOVWF  x63
0964C:  MOVLB  0
0964E:  CALL   6902
....................       } 
09652:  BRA    967E
09654:  MOVLB  3
....................       else 
....................       { 
....................          LCD_place_uint8((128 - abs(rssi_rcvd)), 1, 9, 3); 
09656:  MOVF   x67,W
09658:  BTFSS  x67.7
0965A:  BRA    9662
0965C:  MOVLW  00
0965E:  BSF    FD8.0
09660:  SUBFWB x67,W
09662:  XORLW  FF
09664:  ADDLW  81
09666:  MOVLB  5
09668:  MOVWF  x5F
0966A:  MOVWF  x60
0966C:  MOVLW  01
0966E:  MOVWF  x61
09670:  MOVLW  09
09672:  MOVWF  x62
09674:  MOVLW  03
09676:  MOVWF  x63
09678:  MOVLB  0
0967A:  CALL   6902
....................       } 
....................     
....................    LCD_place_uint8(hop_depth_rcvd, 1, 13, 3); 
0967E:  MOVFF  368,560
09682:  MOVLW  01
09684:  MOVLB  5
09686:  MOVWF  x61
09688:  MOVLW  0D
0968A:  MOVWF  x62
0968C:  MOVLW  03
0968E:  MOVWF  x63
09690:  MOVLB  0
09692:  CALL   6902
09696:  GOTO   9814 (RETURN)
.................... } 
....................  
.................... uint8_t     initiate_join(void) 
.................... { 
.................... // initiates a join by setting the joinduty to the max   
....................    uint8_t  result_byte; 
....................     
....................    // set the join duty and timeout error handling 
....................    global_set_get_response = FALSE; 
*
09AC2:  MOVLB  3
09AC4:  BCF    x5C.2
....................    pkgen_set_joinduty(0xFF); 
09AC6:  MOVLW  01
09AC8:  MOVLB  5
09ACA:  MOVWF  x48
09ACC:  MOVLW  02
09ACE:  MOVWF  x49
09AD0:  MOVLW  04
09AD2:  MOVWF  x4A
09AD4:  MOVLW  06
09AD6:  MOVWF  x4B
09AD8:  SETF   x4C
09ADA:  MOVLW  05
09ADC:  MOVWF  x62
09ADE:  MOVLW  48
09AE0:  MOVWF  x61
09AE2:  MOVLW  04
09AE4:  MOVWF  x63
09AE6:  MOVLW  05
09AE8:  MOVWF  x65
09AEA:  MOVLW  4C
09AEC:  MOVWF  x64
09AEE:  MOVLW  01
09AF0:  MOVWF  x66
09AF2:  MOVLB  0
09AF4:  CALL   5E58
....................    result_byte = dust_hdlc_pksend(); 
09AF8:  CALL   6102
09AFC:  MOVFF  01,547
....................    setup_T0_int(T0_250MS); 
09B00:  MOVLW  FC
09B02:  MOVLB  5
09B04:  MOVWF  x65
09B06:  MOVLW  30
09B08:  MOVWF  x64
09B0A:  MOVLB  0
09B0C:  CALL   36B2
....................    while (!TMR0IF && !global_set_get_response && !result_byte); 
09B10:  BTFSC  FF2.2
09B12:  BRA    9B2C
09B14:  MOVLB  3
09B16:  BTFSS  x5C.2
09B18:  BRA    9B1E
09B1A:  MOVLB  0
09B1C:  BRA    9B2C
09B1E:  MOVLB  5
09B20:  MOVF   x47,F
09B22:  BTFSS  FD8.2
09B24:  BRA    9B2A
09B26:  MOVLB  0
09B28:  BRA    9B10
09B2A:  MOVLB  0
....................    if (TMR0IF || result_byte) 
09B2C:  BTFSC  FF2.2
09B2E:  BRA    9B38
09B30:  MOVLB  5
09B32:  MOVF   x47,F
09B34:  BZ    9B40
09B36:  MOVLB  0
....................       return ERR_MTJOINDUTY;  
09B38:  MOVLW  07
09B3A:  MOVWF  01
09B3C:  BRA    9C36
09B3E:  MOVLB  5
....................     
....................    // set the joinkey and timeout error handling   
....................    global_set_get_response = FALSE; 
09B40:  MOVLB  3
09B42:  BCF    x5C.2
....................    pkgen_setnv_joinkey(joinkey); 
09B44:  MOVLW  03
09B46:  MOVLB  5
09B48:  MOVWF  x4D
09B4A:  MOVLW  15
09B4C:  MOVWF  x4E
09B4E:  MOVLW  04
09B50:  MOVWF  x4F
09B52:  CLRF   x50
09B54:  CLRF   x51
09B56:  CLRF   x52
09B58:  CLRF   x53
09B5A:  MOVLW  02
09B5C:  MOVWF  x54
09B5E:  MOVLW  05
09B60:  MOVWF  x62
09B62:  MOVLW  4D
09B64:  MOVWF  x61
09B66:  MOVLW  08
09B68:  MOVWF  x63
09B6A:  CLRF   x65
09B6C:  MOVLW  37
09B6E:  MOVWF  x64
09B70:  MOVLW  10
09B72:  MOVWF  x66
09B74:  MOVLB  0
09B76:  CALL   5E58
....................    result_byte = dust_hdlc_pksend(); 
09B7A:  CALL   6102
09B7E:  MOVFF  01,547
....................    setup_T0_int(T0_250MS); 
09B82:  MOVLW  FC
09B84:  MOVLB  5
09B86:  MOVWF  x65
09B88:  MOVLW  30
09B8A:  MOVWF  x64
09B8C:  MOVLB  0
09B8E:  CALL   36B2
....................    while (!TMR0IF && !global_set_get_response && !result_byte); 
09B92:  BTFSC  FF2.2
09B94:  BRA    9BAE
09B96:  MOVLB  3
09B98:  BTFSS  x5C.2
09B9A:  BRA    9BA0
09B9C:  MOVLB  0
09B9E:  BRA    9BAE
09BA0:  MOVLB  5
09BA2:  MOVF   x47,F
09BA4:  BTFSS  FD8.2
09BA6:  BRA    9BAC
09BA8:  MOVLB  0
09BAA:  BRA    9B92
09BAC:  MOVLB  0
....................    if (TMR0IF || result_byte) 
09BAE:  BTFSC  FF2.2
09BB0:  BRA    9BBA
09BB2:  MOVLB  5
09BB4:  MOVF   x47,F
09BB6:  BZ    9BC2
09BB8:  MOVLB  0
....................       return ERR_MTJOINKEY;   
09BBA:  MOVLW  08
09BBC:  MOVWF  01
09BBE:  BRA    9C36
09BC0:  MOVLB  5
....................        
....................    // NOTE that we assume that the non-volatile memory of the mote 
....................    //  contains a valid network ID.... 
....................    // The join could fail if blue box not found or if it is trying to join 
....................    //  to a nonvalid network ID 
....................     
....................    // actually send the join command 
....................    global_set_get_response = FALSE; 
09BC2:  MOVLB  3
09BC4:  BCF    x5C.2
....................    pkgen_join(); 
09BC6:  MOVLW  06
09BC8:  MOVLB  5
09BCA:  MOVWF  x55
09BCC:  CLRF   x56
09BCE:  MOVLW  04
09BD0:  MOVWF  x57
09BD2:  CLRF   x62
09BD4:  CLRF   x61
09BD6:  CLRF   x63
09BD8:  MOVLW  05
09BDA:  MOVWF  x65
09BDC:  MOVLW  55
09BDE:  MOVWF  x64
09BE0:  MOVLW  03
09BE2:  MOVWF  x66
09BE4:  MOVLB  0
09BE6:  CALL   5E58
....................    result_byte = dust_hdlc_pksend(); 
09BEA:  CALL   6102
09BEE:  MOVFF  01,547
....................    setup_T0_int(T0_250MS); 
09BF2:  MOVLW  FC
09BF4:  MOVLB  5
09BF6:  MOVWF  x65
09BF8:  MOVLW  30
09BFA:  MOVWF  x64
09BFC:  MOVLB  0
09BFE:  CALL   36B2
....................    while (!TMR0IF && !global_set_get_response && !result_byte); 
09C02:  BTFSC  FF2.2
09C04:  BRA    9C1E
09C06:  MOVLB  3
09C08:  BTFSS  x5C.2
09C0A:  BRA    9C10
09C0C:  MOVLB  0
09C0E:  BRA    9C1E
09C10:  MOVLB  5
09C12:  MOVF   x47,F
09C14:  BTFSS  FD8.2
09C16:  BRA    9C1C
09C18:  MOVLB  0
09C1A:  BRA    9C02
09C1C:  MOVLB  0
....................    if (TMR0IF || result_byte) 
09C1E:  BTFSC  FF2.2
09C20:  BRA    9C2A
09C22:  MOVLB  5
09C24:  MOVF   x47,F
09C26:  BZ    9C32
09C28:  MOVLB  0
....................       return ERR_NETWORK_JOIN_FAIL; 
09C2A:  MOVLW  06
09C2C:  MOVWF  01
09C2E:  BRA    9C36
09C30:  MOVLB  5
....................      
....................    return NO_ERR; 
09C32:  MOVLW  00
09C34:  MOVWF  01
09C36:  MOVLB  0
09C38:  GOTO   AD90 (RETURN)
.................... } 
....................  
.................... void mote_state_check(void) 
.................... { 
.................... // Asks mote what it's status is and responds accordingly (including following 
.................... // up on the mote status later) 
.................... // Restarts mote if needed, triggers join/rejoin if needed, and continues to  
.................... // check status until mote is operational 
....................    uint8_t result_byte; 
....................  
....................    // send the mote status package to the mote 
....................    global_set_get_response = FALSE; 
*
08C50:  MOVLB  3
08C52:  BCF    x5C.2
....................    pkgen_get_motestatus(); 
08C54:  MOVLW  02
08C56:  MOVLB  5
08C58:  MOVWF  x48
08C5A:  MOVLW  01
08C5C:  MOVWF  x49
08C5E:  MOVLW  04
08C60:  MOVWF  x4A
08C62:  MOVLW  0E
08C64:  MOVWF  x4B
08C66:  CLRF   x62
08C68:  CLRF   x61
08C6A:  CLRF   x63
08C6C:  MOVLW  05
08C6E:  MOVWF  x65
08C70:  MOVLW  48
08C72:  MOVWF  x64
08C74:  MOVLW  04
08C76:  MOVWF  x66
08C78:  MOVLB  0
08C7A:  CALL   5E58
....................    result_byte = dust_hdlc_pksend();                                               
08C7E:  CALL   6102
08C82:  MOVFF  01,547
....................    setup_T0_int(T0_250MS); 
08C86:  MOVLW  FC
08C88:  MOVLB  5
08C8A:  MOVWF  x65
08C8C:  MOVLW  30
08C8E:  MOVWF  x64
08C90:  MOVLB  0
08C92:  CALL   36B2
....................    while (!TMR0IF && !global_set_get_response && !result_byte); 
08C96:  BTFSC  FF2.2
08C98:  BRA    8CB2
08C9A:  MOVLB  3
08C9C:  BTFSS  x5C.2
08C9E:  BRA    8CA4
08CA0:  MOVLB  0
08CA2:  BRA    8CB2
08CA4:  MOVLB  5
08CA6:  MOVF   x47,F
08CA8:  BTFSS  FD8.2
08CAA:  BRA    8CB0
08CAC:  MOVLB  0
08CAE:  BRA    8C96
08CB0:  MOVLB  0
....................     
....................    // if the mote status request fails, trigger a mote reboot 
....................    if (TMR0IF || result_byte) 
08CB2:  BTFSC  FF2.2
08CB4:  BRA    8CBE
08CB6:  MOVLB  5
08CB8:  MOVF   x47,F
08CBA:  BZ    8D14
08CBC:  MOVLB  0
....................    { 
....................       PUSH_PRIORITY_QUEUE_MACRO(RESET_MOTE); 
08CBE:  BCF    F7A.1
08CC0:  MOVLW  11
08CC2:  MOVLB  5
08CC4:  MOVWF  x4E
08CC6:  MOVLB  0
08CC8:  CALL   4538
08CCC:  BSF    F7A.1
....................       PUSH_TIME_QUEUE_MACRO((global_rtc_time + 10), CHECK_MOTE_STATE) 
08CCE:  BCF    F7A.1
08CD0:  MOVLW  0A
08CD2:  ADDWF  x85,W
08CD4:  MOVLB  5
08CD6:  MOVWF  x4C
08CD8:  MOVLW  00
08CDA:  MOVLB  0
08CDC:  ADDWFC x86,W
08CDE:  MOVLB  5
08CE0:  MOVWF  x4D
08CE2:  MOVLW  00
08CE4:  MOVLB  0
08CE6:  ADDWFC x87,W
08CE8:  MOVLB  5
08CEA:  MOVWF  x4E
08CEC:  MOVLW  00
08CEE:  MOVLB  0
08CF0:  ADDWFC x88,W
08CF2:  MOVLB  5
08CF4:  MOVWF  x4F
08CF6:  MOVWF  x55
08CF8:  MOVFF  54E,554
08CFC:  MOVFF  54D,553
08D00:  MOVFF  54C,552
08D04:  MOVLW  B4
08D06:  MOVWF  x56
08D08:  MOVLB  0
08D0A:  CALL   4290
08D0E:  BSF    F7A.1
....................    } 
08D10:  BRA    8FB2
08D12:  MOVLB  5
....................    // if it has been more than MOTE_NETWORK_SHUTDOWN_TIMEOUT seconds since the mote  
....................    //    returned an operational state, and the mote is in the SYSTEM_RUN state or the SYSTEM_IDLE state 
....................    //    (not looking for a network) 
....................    else if (((global_rtc_time - global_last_connected_time) > MOTE_NETWORK_SHUTDOWN_TIMEOUT) && \ 
....................       ((read_system_state() == SYSTEM_RUN) || (read_system_state() == SYSTEM_IDLE)))    
08D14:  MOVF   47,W
08D16:  MOVLB  0
08D18:  SUBWF  x85,W
08D1A:  MOVLB  5
08D1C:  MOVWF  x4C
08D1E:  MOVF   48,W
08D20:  MOVLB  0
08D22:  SUBWFB x86,W
08D24:  MOVLB  5
08D26:  MOVWF  x4D
08D28:  MOVF   49,W
08D2A:  MOVLB  0
08D2C:  SUBWFB x87,W
08D2E:  MOVLB  5
08D30:  MOVWF  x4E
08D32:  MOVF   4A,W
08D34:  MOVLB  0
08D36:  SUBWFB x88,W
08D38:  MOVLB  5
08D3A:  MOVWF  x4F
08D3C:  MOVF   x4F,F
08D3E:  BNZ   8D52
08D40:  MOVF   x4E,F
08D42:  BNZ   8D52
08D44:  MOVF   x22,W
08D46:  SUBWF  x4D,W
08D48:  BNC   8DC0
08D4A:  BNZ   8D52
08D4C:  MOVF   x4C,W
08D4E:  SUBWF  x21,W
08D50:  BC    8DC0
08D52:  MOVLB  0
08D54:  CALL   1DC6
08D58:  MOVF   01,W
08D5A:  SUBLW  02
08D5C:  BZ    8D6E
08D5E:  CALL   1DC6
08D62:  MOVF   01,W
08D64:  SUBLW  03
08D66:  BTFSC  FD8.2
08D68:  BRA    8D6E
08D6A:  MOVLB  5
08D6C:  BRA    8DC0
....................    {                                       
....................          // set the shutdown cause and schedule a shutdown 10 seconds later 
....................          global_shutdown_cause = ERR_NO_NETWORK_TIMEOUT; 
08D6E:  MOVLW  0D
08D70:  MOVWF  4D
....................          PUSH_PRIORITY_QUEUE(OPEN_VALVE_UNKNOWN_STATE);   
08D72:  MOVLW  3E
08D74:  MOVLB  5
08D76:  MOVWF  x4E
08D78:  MOVLB  0
08D7A:  CALL   4538
....................          PUSH_TIME_QUEUE(global_rtc_time + 10, SHUTDOWN_SYSTEM);    
08D7E:  MOVLW  0A
08D80:  ADDWF  x85,W
08D82:  MOVLB  5
08D84:  MOVWF  x4C
08D86:  MOVLW  00
08D88:  MOVLB  0
08D8A:  ADDWFC x86,W
08D8C:  MOVLB  5
08D8E:  MOVWF  x4D
08D90:  MOVLW  00
08D92:  MOVLB  0
08D94:  ADDWFC x87,W
08D96:  MOVLB  5
08D98:  MOVWF  x4E
08D9A:  MOVLW  00
08D9C:  MOVLB  0
08D9E:  ADDWFC x88,W
08DA0:  MOVLB  5
08DA2:  MOVWF  x4F
08DA4:  MOVWF  x55
08DA6:  MOVFF  54E,554
08DAA:  MOVFF  54D,553
08DAE:  MOVFF  54C,552
08DB2:  MOVLW  F1
08DB4:  MOVWF  x56
08DB6:  MOVLB  0
08DB8:  CALL   4290
....................    } 
08DBC:  BRA    8FB2
08DBE:  MOVLB  5
....................     
....................    // if mote is idle or disconnected, initiate a join and check on mote later 
....................    else if ((global_mote_state == MOTESTATE_IDLE) ||                          \ 
....................       (global_mote_state == MOTESTATE_DISCONNECTED))   
08DC0:  DECFSZ x00,W
08DC2:  BRA    8DC6
08DC4:  BRA    8DCC
08DC6:  MOVF   x00,W
08DC8:  SUBLW  06
08DCA:  BNZ   8E20
....................    { 
....................       PUSH_PRIORITY_QUEUE_MACRO(INIT_JOIN); 
08DCC:  BCF    F7A.1
08DCE:  MOVLW  B3
08DD0:  MOVWF  x4E
08DD2:  MOVLB  0
08DD4:  CALL   4538
08DD8:  BSF    F7A.1
....................       PUSH_TIME_QUEUE_MACRO((global_rtc_time + 10), CHECK_MOTE_STATE) 
08DDA:  BCF    F7A.1
08DDC:  MOVLW  0A
08DDE:  ADDWF  x85,W
08DE0:  MOVLB  5
08DE2:  MOVWF  x4C
08DE4:  MOVLW  00
08DE6:  MOVLB  0
08DE8:  ADDWFC x86,W
08DEA:  MOVLB  5
08DEC:  MOVWF  x4D
08DEE:  MOVLW  00
08DF0:  MOVLB  0
08DF2:  ADDWFC x87,W
08DF4:  MOVLB  5
08DF6:  MOVWF  x4E
08DF8:  MOVLW  00
08DFA:  MOVLB  0
08DFC:  ADDWFC x88,W
08DFE:  MOVLB  5
08E00:  MOVWF  x4F
08E02:  MOVWF  x55
08E04:  MOVFF  54E,554
08E08:  MOVFF  54D,553
08E0C:  MOVFF  54C,552
08E10:  MOVLW  B4
08E12:  MOVWF  x56
08E14:  MOVLB  0
08E16:  CALL   4290
08E1A:  BSF    F7A.1
.................... //      LCD_place_char('D',1,15);     
....................    }                                                          
08E1C:  BRA    8FB2
08E1E:  MOVLB  5
....................     
....................    // if mote is in one of these odd/unwanted modes, trigger reset 
....................    // and a status check (to initiate a join) in the future 
....................    else if ((global_mote_state == MOTESTATE_RADIOTEST) ||                     \ 
....................       (global_mote_state == MOTESTATE_UNKNOWN))                      
08E20:  MOVF   x00,W
08E22:  SUBLW  07
08E24:  BZ    8E2A
08E26:  INCFSZ x00,W
08E28:  BRA    8E7E
....................    {    
....................       PUSH_PRIORITY_QUEUE_MACRO(RESET_MOTE); 
08E2A:  BCF    F7A.1
08E2C:  MOVLW  11
08E2E:  MOVWF  x4E
08E30:  MOVLB  0
08E32:  CALL   4538
08E36:  BSF    F7A.1
....................       PUSH_TIME_QUEUE_MACRO((global_rtc_time + 10), CHECK_MOTE_STATE) 
08E38:  BCF    F7A.1
08E3A:  MOVLW  0A
08E3C:  ADDWF  x85,W
08E3E:  MOVLB  5
08E40:  MOVWF  x4C
08E42:  MOVLW  00
08E44:  MOVLB  0
08E46:  ADDWFC x86,W
08E48:  MOVLB  5
08E4A:  MOVWF  x4D
08E4C:  MOVLW  00
08E4E:  MOVLB  0
08E50:  ADDWFC x87,W
08E52:  MOVLB  5
08E54:  MOVWF  x4E
08E56:  MOVLW  00
08E58:  MOVLB  0
08E5A:  ADDWFC x88,W
08E5C:  MOVLB  5
08E5E:  MOVWF  x4F
08E60:  MOVWF  x55
08E62:  MOVFF  54E,554
08E66:  MOVFF  54D,553
08E6A:  MOVFF  54C,552
08E6E:  MOVLW  B4
08E70:  MOVWF  x56
08E72:  MOVLB  0
08E74:  CALL   4290
08E78:  BSF    F7A.1
.................... //      LCD_place_char('U',1,15); 
....................    } 
08E7A:  BRA    8FB2
08E7C:  MOVLB  5
....................     
....................    // if mote is in promiscuous listen mode but the system state is not  
....................    //    searching for the network, restart as it's unwanted. 
....................    else if ((global_mote_state == MOTESTATE_PROMISCUOUS) &&                   \ 
....................       (!(read_system_state() == SYSTEM_SEARCHING_FOR_NETWORK))) 
08E7E:  MOVF   x00,W
08E80:  SUBLW  08
08E82:  BNZ   8EEC
08E84:  MOVLB  0
08E86:  CALL   1DC6
08E8A:  MOVF   01,W
08E8C:  SUBLW  20
08E8E:  BTFSS  FD8.2
08E90:  BRA    8E96
08E92:  MOVLB  5
08E94:  BRA    8EEC
....................    {                                                     
....................       PUSH_PRIORITY_QUEUE_MACRO(RESET_MOTE); 
08E96:  BCF    F7A.1
08E98:  MOVLW  11
08E9A:  MOVLB  5
08E9C:  MOVWF  x4E
08E9E:  MOVLB  0
08EA0:  CALL   4538
08EA4:  BSF    F7A.1
....................       PUSH_TIME_QUEUE_MACRO((global_rtc_time + 10), CHECK_MOTE_STATE) 
08EA6:  BCF    F7A.1
08EA8:  MOVLW  0A
08EAA:  ADDWF  x85,W
08EAC:  MOVLB  5
08EAE:  MOVWF  x4C
08EB0:  MOVLW  00
08EB2:  MOVLB  0
08EB4:  ADDWFC x86,W
08EB6:  MOVLB  5
08EB8:  MOVWF  x4D
08EBA:  MOVLW  00
08EBC:  MOVLB  0
08EBE:  ADDWFC x87,W
08EC0:  MOVLB  5
08EC2:  MOVWF  x4E
08EC4:  MOVLW  00
08EC6:  MOVLB  0
08EC8:  ADDWFC x88,W
08ECA:  MOVLB  5
08ECC:  MOVWF  x4F
08ECE:  MOVWF  x55
08ED0:  MOVFF  54E,554
08ED4:  MOVFF  54D,553
08ED8:  MOVFF  54C,552
08EDC:  MOVLW  B4
08EDE:  MOVWF  x56
08EE0:  MOVLB  0
08EE2:  CALL   4290
08EE6:  BSF    F7A.1
.................... //      LCD_place_char('N',1,15); 
....................    } 
08EE8:  BRA    8FB2
08EEA:  MOVLB  5
....................     
....................    // if the mote is booting or initiating a join, check up on it later 
....................    else if ((global_mote_state == MOTESTATE_INIT) ||                          \ 
....................       (global_mote_state == MOTESTATE_SEARCHING) ||                           \ 
....................       (global_mote_state == MOTESTATE_NEGOTIATING) ||                         \ 
....................       (global_mote_state == MOTESTATE_CONNECTED)) 
08EEC:  MOVF   x00,F
08EEE:  BZ    8F02
08EF0:  MOVF   x00,W
08EF2:  SUBLW  02
08EF4:  BZ    8F02
08EF6:  MOVF   x00,W
08EF8:  SUBLW  03
08EFA:  BZ    8F02
08EFC:  MOVF   x00,W
08EFE:  SUBLW  04
08F00:  BNZ   8F4A
....................    {                                                                                
....................       PUSH_TIME_QUEUE_MACRO((global_rtc_time + 10), CHECK_MOTE_STATE)   
08F02:  BCF    F7A.1
08F04:  MOVLW  0A
08F06:  MOVLB  0
08F08:  ADDWF  x85,W
08F0A:  MOVLB  5
08F0C:  MOVWF  x4C
08F0E:  MOVLW  00
08F10:  MOVLB  0
08F12:  ADDWFC x86,W
08F14:  MOVLB  5
08F16:  MOVWF  x4D
08F18:  MOVLW  00
08F1A:  MOVLB  0
08F1C:  ADDWFC x87,W
08F1E:  MOVLB  5
08F20:  MOVWF  x4E
08F22:  MOVLW  00
08F24:  MOVLB  0
08F26:  ADDWFC x88,W
08F28:  MOVLB  5
08F2A:  MOVWF  x4F
08F2C:  MOVWF  x55
08F2E:  MOVFF  54E,554
08F32:  MOVFF  54D,553
08F36:  MOVFF  54C,552
08F3A:  MOVLW  B4
08F3C:  MOVWF  x56
08F3E:  MOVLB  0
08F40:  CALL   4290
08F44:  BSF    F7A.1
.................... //      LCD_place_char('I',1,15);  
....................    } 
08F46:  BRA    8FB2
08F48:  MOVLB  5
....................     
....................    // mote is operational, do nothing 
....................    else if (global_mote_state == MOTESTATE_OPERATIONAL) 
08F4A:  MOVF   x00,W
08F4C:  SUBLW  05
08F4E:  BNZ   8F62
....................    {  
....................       global_last_connected_time = global_rtc_time; 
08F50:  MOVFF  88,4A
08F54:  MOVFF  87,49
08F58:  MOVFF  86,48
08F5C:  MOVFF  85,47
.................... //      LCD_place_char('O',1,15);      
....................       break; 
....................    } 
08F60:  BRA    8FB4
....................     
....................    // incase there is some other crazy mote status, restart mote and retry 
....................    else 
....................    { 
....................       PUSH_PRIORITY_QUEUE_MACRO(RESET_MOTE); 
08F62:  BCF    F7A.1
08F64:  MOVLW  11
08F66:  MOVWF  x4E
08F68:  MOVLB  0
08F6A:  CALL   4538
08F6E:  BSF    F7A.1
....................       PUSH_TIME_QUEUE_MACRO((global_rtc_time + 10), CHECK_MOTE_STATE) 
08F70:  BCF    F7A.1
08F72:  MOVLW  0A
08F74:  ADDWF  x85,W
08F76:  MOVLB  5
08F78:  MOVWF  x4C
08F7A:  MOVLW  00
08F7C:  MOVLB  0
08F7E:  ADDWFC x86,W
08F80:  MOVLB  5
08F82:  MOVWF  x4D
08F84:  MOVLW  00
08F86:  MOVLB  0
08F88:  ADDWFC x87,W
08F8A:  MOVLB  5
08F8C:  MOVWF  x4E
08F8E:  MOVLW  00
08F90:  MOVLB  0
08F92:  ADDWFC x88,W
08F94:  MOVLB  5
08F96:  MOVWF  x4F
08F98:  MOVWF  x55
08F9A:  MOVFF  54E,554
08F9E:  MOVFF  54D,553
08FA2:  MOVFF  54C,552
08FA6:  MOVLW  B4
08FA8:  MOVWF  x56
08FAA:  MOVLB  0
08FAC:  CALL   4290
08FB0:  BSF    F7A.1
08FB2:  MOVLB  5
....................    } 
....................    break; 
08FB4:  MOVLB  0
08FB6:  GOTO   AD90 (RETURN)
.................... } 
....................  
.................... void mote_info_check(void) 
.................... // queries the mote to send back information including mac address (serial no), 
.................... //  hardware model/rev, API version, etc. 
.................... { 
....................    uint8_t result_byte; 
....................     
....................    // if the mote is not enabled/ready exit! 
....................    if (global_dust_enabled == FALSE) return; 
08FBA:  BTFSS  xA3.6
08FBC:  BRA    9040
....................        
....................    // set the response flag 
....................    global_set_get_response = FALSE; 
08FBE:  MOVLB  3
08FC0:  BCF    x5C.2
....................    // generate the message and send the message 
....................     
....................    pkgen_get_moteinfo(); 
08FC2:  MOVLW  02
08FC4:  MOVLB  5
08FC6:  MOVWF  x48
08FC8:  MOVLW  01
08FCA:  MOVWF  x49
08FCC:  MOVLW  04
08FCE:  MOVWF  x4A
08FD0:  MOVLW  0C
08FD2:  MOVWF  x4B
08FD4:  CLRF   x62
08FD6:  CLRF   x61
08FD8:  CLRF   x63
08FDA:  MOVLW  05
08FDC:  MOVWF  x65
08FDE:  MOVLW  48
08FE0:  MOVWF  x64
08FE2:  MOVLW  04
08FE4:  MOVWF  x66
08FE6:  MOVLB  0
08FE8:  CALL   5E58
....................    result_byte = dust_hdlc_pksend(); 
08FEC:  CALL   6102
08FF0:  MOVFF  01,547
....................    // set message timeout 
....................    setup_T0_int(T0_250MS); 
08FF4:  MOVLW  FC
08FF6:  MOVLB  5
08FF8:  MOVWF  x65
08FFA:  MOVLW  30
08FFC:  MOVWF  x64
08FFE:  MOVLB  0
09000:  CALL   36B2
....................    while (!TMR0IF && !global_set_get_response && !result_byte); 
09004:  BTFSC  FF2.2
09006:  BRA    9020
09008:  MOVLB  3
0900A:  BTFSS  x5C.2
0900C:  BRA    9012
0900E:  MOVLB  0
09010:  BRA    9020
09012:  MOVLB  5
09014:  MOVF   x47,F
09016:  BTFSS  FD8.2
09018:  BRA    901E
0901A:  MOVLB  0
0901C:  BRA    9004
0901E:  MOVLB  0
....................    // if the message fails, send an error message (kinda pointless though) 
....................    if (TMR0IF || result_byte) 
09020:  BTFSC  FF2.2
09022:  BRA    902C
09024:  MOVLB  5
09026:  MOVF   x47,F
09028:  BZ    9042
0902A:  MOVLB  0
....................    { 
....................       global_error_message_bitfield |= ERR_MOTE_UNRESPONSIVE; 
0902C:  MOVLB  4
0902E:  BSF    xF4.2
....................       PUSH_MESSAGE_QUEUE_MACRO(MSG_MOTE_ERROR_MSG); 
09030:  BCF    F7A.1
09032:  MOVLW  A0
09034:  MOVLB  5
09036:  MOVWF  x50
09038:  MOVLB  0
0903A:  CALL   4FE0
0903E:  BSF    F7A.1
09040:  MOVLB  5
....................    } 
09042:  MOVLB  0
09044:  GOTO   AD90 (RETURN)
....................     
.................... } 
....................  
.................... void mote_temp_check(void) 
.................... // queries the mote to send the temperature back and stores it in the global 
.................... //    variable global_mote_temperature  
.................... { 
....................    uint8_t result_byte; 
....................     
....................    // if the mote is not enabled/ready exit! 
....................    if (global_dust_enabled == FALSE) return; 
*
09282:  BTFSS  xA3.6
09284:  BRA    93AC
....................     
....................    // set the response flag 
....................    global_set_get_response = FALSE; 
09286:  MOVLB  3
09288:  BCF    x5C.2
....................    // generate the message and send the message 
....................    pkgen_get_charge(); 
0928A:  MOVLW  02
0928C:  MOVLB  5
0928E:  MOVWF  x48
09290:  MOVLW  01
09292:  MOVWF  x49
09294:  MOVLW  04
09296:  MOVWF  x4A
09298:  MOVLW  10
0929A:  MOVWF  x4B
0929C:  CLRF   x62
0929E:  CLRF   x61
092A0:  CLRF   x63
092A2:  MOVLW  05
092A4:  MOVWF  x65
092A6:  MOVLW  48
092A8:  MOVWF  x64
092AA:  MOVLW  04
092AC:  MOVWF  x66
092AE:  MOVLB  0
092B0:  CALL   5E58
....................    result_byte = dust_hdlc_pksend(); 
092B4:  CALL   6102
092B8:  MOVFF  01,547
....................    // set message timeout 
....................    setup_T0_int(T0_250MS); 
092BC:  MOVLW  FC
092BE:  MOVLB  5
092C0:  MOVWF  x65
092C2:  MOVLW  30
092C4:  MOVWF  x64
092C6:  MOVLB  0
092C8:  CALL   36B2
....................    while (!TMR0IF && !global_set_get_response && !result_byte); 
092CC:  BTFSC  FF2.2
092CE:  BRA    92E8
092D0:  MOVLB  3
092D2:  BTFSS  x5C.2
092D4:  BRA    92DA
092D6:  MOVLB  0
092D8:  BRA    92E8
092DA:  MOVLB  5
092DC:  MOVF   x47,F
092DE:  BTFSS  FD8.2
092E0:  BRA    92E6
092E2:  MOVLB  0
092E4:  BRA    92CC
092E6:  MOVLB  0
....................    // if the message fails, send an error message (kinda pointless though) 
....................    if (TMR0IF || result_byte) 
092E8:  BTFSC  FF2.2
092EA:  BRA    92F4
092EC:  MOVLB  5
092EE:  MOVF   x47,F
092F0:  BZ    930A
092F2:  MOVLB  0
....................    { 
....................       global_error_message_bitfield |= ERR_MOTE_UNRESPONSIVE; 
092F4:  MOVLB  4
092F6:  BSF    xF4.2
....................       PUSH_MESSAGE_QUEUE_MACRO(MSG_MOTE_ERROR_MSG); 
092F8:  BCF    F7A.1
092FA:  MOVLW  A0
092FC:  MOVLB  5
092FE:  MOVWF  x50
09300:  MOVLB  0
09302:  CALL   4FE0
09306:  BSF    F7A.1
09308:  MOVLB  5
....................    } 
....................     
....................    // if mote temp is outside of operating range, send an error message and queue up a shutdown 
....................    if ((global_mote_temperature < MOTE_MIN_TEMP_SHUTDOWN) || (global_mote_temperature > MOTE_MAX_TEMP_SHUTDOWN)) 
0930A:  MOVLB  3
0930C:  MOVF   x69,W
0930E:  XORLW  80
09310:  SUBLW  57
09312:  BC    931E
09314:  BTFSC  x69.7
09316:  BRA    9386
09318:  MOVF   x69,W
0931A:  SUBLW  55
0931C:  BC    9386
....................    { 
....................       // set message error bitfield and queue error message 
....................       global_error_message_bitfield |= (ERR_MSG_MOTE_TEMP_OUT_OF_RANGE | ERR_MSG_MOTE_GOING_TO_DEEP_SLEEP); 
0931E:  MOVLB  4
09320:  BSF    xF4.6
09322:  BSF    xF7.7
....................       PUSH_MESSAGE_QUEUE_MACRO(MSG_MOTE_ERROR_MSG); 
09324:  BCF    F7A.1
09326:  MOVLW  A0
09328:  MOVLB  5
0932A:  MOVWF  x50
0932C:  MOVLB  0
0932E:  CALL   4FE0
09332:  BSF    F7A.1
....................        
....................       // set the shutdown cause and schedule a shutdown 10 seconds later 
....................       PUSH_PRIORITY_QUEUE(OPEN_VALVE_UNKNOWN_STATE);   
09334:  MOVLW  3E
09336:  MOVLB  5
09338:  MOVWF  x4E
0933A:  MOVLB  0
0933C:  CALL   4538
....................       global_shutdown_cause = ERR_MOTE_OUT_OF_TEMP_RANGE; 
09340:  MOVLW  05
09342:  MOVWF  4D
....................       PUSH_TIME_QUEUE(global_rtc_time + 10, SHUTDOWN_SYSTEM); 
09344:  MOVLW  0A
09346:  ADDWF  x85,W
09348:  MOVLB  5
0934A:  MOVWF  x4C
0934C:  MOVLW  00
0934E:  MOVLB  0
09350:  ADDWFC x86,W
09352:  MOVLB  5
09354:  MOVWF  x4D
09356:  MOVLW  00
09358:  MOVLB  0
0935A:  ADDWFC x87,W
0935C:  MOVLB  5
0935E:  MOVWF  x4E
09360:  MOVLW  00
09362:  MOVLB  0
09364:  ADDWFC x88,W
09366:  MOVLB  5
09368:  MOVWF  x4F
0936A:  MOVWF  x55
0936C:  MOVFF  54E,554
09370:  MOVFF  54D,553
09374:  MOVFF  54C,552
09378:  MOVLW  F1
0937A:  MOVWF  x56
0937C:  MOVLB  0
0937E:  CALL   4290
....................    } 
09382:  BRA    93AC
09384:  MOVLB  3
....................       // if mote temp is ALMOST outside of operating range, send an error message 
....................    else if ((global_mote_temperature < MOTE_MIN_TEMP_WARNING) || (global_mote_temperature > MOTE_MAX_TEMP_WARNING)) 
09386:  MOVF   x69,W
09388:  XORLW  80
0938A:  SUBLW  5C
0938C:  BC    9398
0938E:  BTFSC  x69.7
09390:  BRA    93AE
09392:  MOVF   x69,W
09394:  SUBLW  50
09396:  BC    93AE
....................    { 
....................       // set message error bitfield and queue error message 
....................       global_error_message_bitfield |= (ERR_MSG_MOTE_TEMP_OUT_OF_RANGE); 
09398:  MOVLB  4
0939A:  BSF    xF4.6
....................       PUSH_MESSAGE_QUEUE_MACRO(MSG_MOTE_ERROR_MSG); 
0939C:  BCF    F7A.1
0939E:  MOVLW  A0
093A0:  MOVLB  5
093A2:  MOVWF  x50
093A4:  MOVLB  0
093A6:  CALL   4FE0
093AA:  BSF    F7A.1
093AC:  MOVLB  3
....................    } 
093AE:  MOVLB  0
093B0:  GOTO   AD90 (RETURN)
....................        
.................... } 
....................  
.................... void mote_time_update(void) 
.................... // queries the mote to for the utc time and update the micro's utc time 
.................... { 
....................    uint8_t result_byte; 
....................     
....................    // if the mote is not enabled/ready exit! 
....................    if (global_dust_enabled == FALSE) return; 
*
09048:  BTFSS  xA3.6
0904A:  BRA    90CE
....................     
....................    // set the response flag 
....................    global_set_get_response = FALSE; 
0904C:  MOVLB  3
0904E:  BCF    x5C.2
....................    // generate the message and send the message 
....................    pkgen_get_time(); 
09050:  MOVLW  02
09052:  MOVLB  5
09054:  MOVWF  x48
09056:  MOVLW  01
09058:  MOVWF  x49
0905A:  MOVLW  04
0905C:  MOVWF  x4A
0905E:  MOVLW  0F
09060:  MOVWF  x4B
09062:  CLRF   x62
09064:  CLRF   x61
09066:  CLRF   x63
09068:  MOVLW  05
0906A:  MOVWF  x65
0906C:  MOVLW  48
0906E:  MOVWF  x64
09070:  MOVLW  04
09072:  MOVWF  x66
09074:  MOVLB  0
09076:  CALL   5E58
....................    result_byte = dust_hdlc_pksend(); 
0907A:  CALL   6102
0907E:  MOVFF  01,547
....................    // set message timeout 
....................    setup_T0_int(T0_250MS); 
09082:  MOVLW  FC
09084:  MOVLB  5
09086:  MOVWF  x65
09088:  MOVLW  30
0908A:  MOVWF  x64
0908C:  MOVLB  0
0908E:  CALL   36B2
....................    while (!TMR0IF && !global_set_get_response && !result_byte); 
09092:  BTFSC  FF2.2
09094:  BRA    90AE
09096:  MOVLB  3
09098:  BTFSS  x5C.2
0909A:  BRA    90A0
0909C:  MOVLB  0
0909E:  BRA    90AE
090A0:  MOVLB  5
090A2:  MOVF   x47,F
090A4:  BTFSS  FD8.2
090A6:  BRA    90AC
090A8:  MOVLB  0
090AA:  BRA    9092
090AC:  MOVLB  0
....................    // if the message fails, send an error message (kinda pointless though) 
....................    if (TMR0IF || result_byte) 
090AE:  BTFSC  FF2.2
090B0:  BRA    90BA
090B2:  MOVLB  5
090B4:  MOVF   x47,F
090B6:  BZ    90D0
090B8:  MOVLB  0
....................    { 
....................       global_error_message_bitfield |= ERR_MOTE_UNRESPONSIVE; 
090BA:  MOVLB  4
090BC:  BSF    xF4.2
....................       PUSH_MESSAGE_QUEUE_MACRO(MSG_MOTE_ERROR_MSG); 
090BE:  BCF    F7A.1
090C0:  MOVLW  A0
090C2:  MOVLB  5
090C4:  MOVWF  x50
090C6:  MOVLB  0
090C8:  CALL   4FE0
090CC:  BSF    F7A.1
090CE:  MOVLB  5
....................    }      
090D0:  MOVLB  0
090D2:  GOTO   AD90 (RETURN)
.................... } 
....................  
.................... void get_mote_net_info(void) 
.................... // queries the mote to get the macaddress 
.................... { 
....................    uint8_t result_byte; 
....................     
....................    // if the mote is not enabled/ready exit! 
....................    if (global_dust_enabled == FALSE) return; 
090D6:  BTFSS  xA3.6
090D8:  BRA    915C
....................     
....................    // set the response flag 
....................    global_set_get_response = FALSE; 
090DA:  MOVLB  3
090DC:  BCF    x5C.2
....................    // generate the message and send the message 
....................    pkgen_get_networkinfo(); 
090DE:  MOVLW  02
090E0:  MOVLB  5
090E2:  MOVWF  x48
090E4:  MOVLW  01
090E6:  MOVWF  x49
090E8:  MOVLW  04
090EA:  MOVWF  x4A
090EC:  MOVLW  0D
090EE:  MOVWF  x4B
090F0:  CLRF   x62
090F2:  CLRF   x61
090F4:  CLRF   x63
090F6:  MOVLW  05
090F8:  MOVWF  x65
090FA:  MOVLW  48
090FC:  MOVWF  x64
090FE:  MOVLW  04
09100:  MOVWF  x66
09102:  MOVLB  0
09104:  CALL   5E58
....................    result_byte = dust_hdlc_pksend(); 
09108:  CALL   6102
0910C:  MOVFF  01,547
....................    // set message timeout 
....................    setup_T0_int(T0_250MS); 
09110:  MOVLW  FC
09112:  MOVLB  5
09114:  MOVWF  x65
09116:  MOVLW  30
09118:  MOVWF  x64
0911A:  MOVLB  0
0911C:  CALL   36B2
....................    while (!TMR0IF && !global_set_get_response && !result_byte); 
09120:  BTFSC  FF2.2
09122:  BRA    913C
09124:  MOVLB  3
09126:  BTFSS  x5C.2
09128:  BRA    912E
0912A:  MOVLB  0
0912C:  BRA    913C
0912E:  MOVLB  5
09130:  MOVF   x47,F
09132:  BTFSS  FD8.2
09134:  BRA    913A
09136:  MOVLB  0
09138:  BRA    9120
0913A:  MOVLB  0
....................    // if the message fails, send an error message (kinda pointless though) 
....................    if (TMR0IF || result_byte) 
0913C:  BTFSC  FF2.2
0913E:  BRA    9148
09140:  MOVLB  5
09142:  MOVF   x47,F
09144:  BZ    915E
09146:  MOVLB  0
....................    { 
....................       global_error_message_bitfield |= ERR_MOTE_UNRESPONSIVE; 
09148:  MOVLB  4
0914A:  BSF    xF4.2
....................       PUSH_MESSAGE_QUEUE_MACRO(MSG_MOTE_ERROR_MSG); 
0914C:  BCF    F7A.1
0914E:  MOVLW  A0
09150:  MOVLB  5
09152:  MOVWF  x50
09154:  MOVLB  0
09156:  CALL   4FE0
0915A:  BSF    F7A.1
0915C:  MOVLB  5
....................    }      
0915E:  MOVLB  0
09160:  GOTO   AD90 (RETURN)
.................... } 
....................  
.................... void init_msgSEQ(void) 
.................... { 
....................    // uses the battery voltage and vgen to seed the random number generator 
....................    srand((get_vbatt(0)<<16) || get_vgen(0)); 
*
0423A:  MOVLB  5
0423C:  CLRF   x66
0423E:  MOVLB  0
04240:  RCALL  40A4
04242:  MOVFF  02,548
04246:  MOVFF  01,547
0424A:  MOVLW  00
0424C:  CLRF   03
0424E:  IORWF  03,W
04250:  BNZ   4264
04252:  MOVLB  5
04254:  CLRF   x53
04256:  MOVLB  0
04258:  RCALL  40FE
0425A:  MOVF   01,W
0425C:  IORWF  02,W
0425E:  BNZ   4264
04260:  MOVLW  00
04262:  BRA    4266
04264:  MOVLW  01
04266:  MOVLB  5
04268:  MOVWF  x47
0426A:  CLRF   x4B
0426C:  CLRF   x4A
0426E:  CLRF   x49
04270:  MOVWF  x48
04272:  MOVLB  0
04274:  BRA    4160
....................    mote_msgSEQ = (uint16_t)rand(); 
04276:  BRA    41BA
04278:  MOVFF  02,362
0427C:  MOVFF  01,361
04280:  GOTO   4286 (RETURN)
.................... } 
....................  
.................... void deal_with_mote_ISR(void) 
*
0121A:  MOVLB  5
0121C:  CLRF   x86
0121E:  BCF    x87.0
01220:  CLRF   x88
01222:  CLRF   x89
01224:  CLRF   x8D
01226:  CLRF   x8C
01228:  CLRF   x8B
0122A:  CLRF   x8A
0122C:  CLRF   x91
0122E:  CLRF   x90
01230:  CLRF   x8F
01232:  CLRF   x8E
01234:  CLRF   x95
01236:  CLRF   x94
01238:  CLRF   x93
0123A:  CLRF   x92
0123C:  CLRF   x96
.................... { 
....................    uint8_t     i; 
....................     
....................    uint16_t    tmp2u16; 
....................     
....................    uint8_t     cmd_rcvd = 0; 
....................    int1        send_ack = FALSE; 
....................     
....................    uint8_t     response_type = 0; 
....................    uint8_t     len_data_rcvd = 0; 
....................    uint32_t    utc_sec_rcvd = 0; 
....................    uint32_t    utc_usec_rcvd = 0; 
....................    uint32_t    new_events_rcvd = 0; 
....................     
....................    // bytes grabbed by get_dustmsg and sent to pkdecode 
....................    uint8_t      num_of_bytes_rcvd_from_mote = 0; 
....................  
....................    // Actually grab the message from the mote 
....................    // gets bytes rcvd(global), dust_recive_buffer, some errors 
....................    num_of_bytes_rcvd_from_mote = get_dustmsg_ISR(); 
0123E:  MOVLB  0
01240:  GOTO   0928
01244:  MOVFF  01,596
....................     
....................    // Add error handling from get_dustmsg_ISR 
....................    // Send NACK? 
....................    
....................    //decodes the message and returns how many bytes were recived 
....................    dust_hdlc_pkdecode_ISR(num_of_bytes_rcvd_from_mote); 
01248:  MOVFF  596,59B
0124C:  BRA    0AB2
....................     
....................    // Add error handling from pkdecode 
....................    // Send NACK? 
....................     
....................    // get the command type 
....................    cmd_rcvd = bytes_from_mote.dust_rcvd[0];         
0124E:  MOVFF  D5,586
....................  
....................    // set these for CMD_TIME, _SERVICE, _EVENT, and _DATA 
....................    //   prefix_x[0] = cmd_rcvd; 
....................    //   prefix_x[1] = 0x00; 
....................    flags_rcvd = bytes_from_mote.dust_rcvd[2]; 
01252:  MOVFF  D7,35E
....................  
....................    response_type = RC_OK; 
01256:  MOVLB  5
01258:  CLRF   x88
....................     
....................    //  
....................    if (cmd_rcvd == CMD_SET || cmd_rcvd == CMD_GET || \ 
....................        cmd_rcvd == CMD_SETNV || cmd_rcvd == CMD_GETNV || \ 
....................        cmd_rcvd == CMD_SEND || cmd_rcvd == CMD_JOIN || \ 
....................        cmd_rcvd == CMD_DISCONNECT || cmd_rcvd == CMD_RESET || \ 
....................        cmd_rcvd == CMD_SLEEP || cmd_rcvd == CMD_TESTRADIOTX || \ 
....................        cmd_rcvd == CMD_TESTRADIORX || cmd_rcvd == CMD_CLEARNV || \ 
....................        cmd_rcvd == CMD_SEARCH) 
0125A:  DECFSZ x86,W
0125C:  BRA    1260
0125E:  BRA    12A8
01260:  MOVF   x86,W
01262:  SUBLW  02
01264:  BZ    12A8
01266:  MOVF   x86,W
01268:  SUBLW  03
0126A:  BZ    12A8
0126C:  MOVF   x86,W
0126E:  SUBLW  04
01270:  BZ    12A8
01272:  MOVF   x86,W
01274:  SUBLW  05
01276:  BZ    12A8
01278:  MOVF   x86,W
0127A:  SUBLW  06
0127C:  BZ    12A8
0127E:  MOVF   x86,W
01280:  SUBLW  07
01282:  BZ    12A8
01284:  MOVF   x86,W
01286:  SUBLW  08
01288:  BZ    12A8
0128A:  MOVF   x86,W
0128C:  SUBLW  09
0128E:  BZ    12A8
01290:  MOVF   x86,W
01292:  SUBLW  0B
01294:  BZ    12A8
01296:  MOVF   x86,W
01298:  SUBLW  0C
0129A:  BZ    12A8
0129C:  MOVF   x86,W
0129E:  SUBLW  10
012A0:  BZ    12A8
012A2:  MOVF   x86,W
012A4:  SUBLW  11
012A6:  BNZ   12AC
....................    { 
....................        // we are hoping that result_rcvd = RC_OK) 
....................        result_rcvd = bytes_from_mote.dust_rcvd[3]; 
012A8:  MOVFF  D8,35B
....................    }    
....................  
....................    // Determine parameter type and if the response was ok for set and get commands 
....................    if (cmd_rcvd == CMD_SET || cmd_rcvd == CMD_GET || \ 
....................        cmd_rcvd == CMD_SETNV || cmd_rcvd == CMD_GETNV) 
012AC:  DECFSZ x86,W
012AE:  BRA    12B2
012B0:  BRA    12C4
012B2:  MOVF   x86,W
012B4:  SUBLW  02
012B6:  BZ    12C4
012B8:  MOVF   x86,W
012BA:  SUBLW  03
012BC:  BZ    12C4
012BE:  MOVF   x86,W
012C0:  SUBLW  04
012C2:  BNZ   12D2
....................    {      
....................        param_type_rcvd = bytes_from_mote.dust_rcvd[4]; 
012C4:  MOVFF  D9,35F
....................        // this eliminates a bunch of flags for one response "ok" flag 
....................        if (result_rcvd == RC_OK) global_set_get_response = TRUE; 
012C8:  MOVLB  3
012CA:  MOVF   x5B,F
012CC:  BNZ   12D0
012CE:  BSF    x5C.2
012D0:  MOVLB  5
....................    } 
....................     
....................    // Main switch for all types of mote messages 
....................    switch (cmd_rcvd) 
012D2:  MOVF   x86,W
012D4:  XORLW  01
012D6:  MOVLB  0
012D8:  BZ    1340
012DA:  XORLW  03
012DC:  BZ    1352
012DE:  XORLW  01
012E0:  BTFSC  FD8.2
012E2:  BRA    14AE
012E4:  XORLW  07
012E6:  BTFSC  FD8.2
012E8:  BRA    14C0
012EA:  XORLW  01
012EC:  BTFSC  FD8.2
012EE:  BRA    1526
012F0:  XORLW  02
012F2:  BTFSC  FD8.2
012F4:  BRA    1526
012F6:  XORLW  0F
012F8:  BTFSC  FD8.2
012FA:  BRA    1526
012FC:  XORLW  01
012FE:  BTFSC  FD8.2
01300:  BRA    1526
01302:  XORLW  02
01304:  BTFSC  FD8.2
01306:  BRA    1526
01308:  XORLW  07
0130A:  BTFSC  FD8.2
0130C:  BRA    1526
0130E:  XORLW  1C
01310:  BTFSC  FD8.2
01312:  BRA    1526
01314:  XORLW  01
01316:  BTFSC  FD8.2
01318:  BRA    1528
0131A:  XORLW  17
0131C:  BTFSC  FD8.2
0131E:  BRA    153A
01320:  XORLW  0B
01322:  BTFSC  FD8.2
01324:  BRA    154E
01326:  XORLW  03
01328:  BTFSC  FD8.2
0132A:  BRA    1596
0132C:  XORLW  01
0132E:  BTFSC  FD8.2
01330:  BRA    15A2
01332:  XORLW  1D
01334:  BTFSC  FD8.2
01336:  BRA    1608
01338:  XORLW  93
0133A:  BTFSC  FD8.2
0133C:  BRA    1634
0133E:  BRA    1690
....................    {   
....................       // receipt of response after a SET command 
....................       case  CMD_SET: 
....................          // byte4 is the param_type for all SET responses 
....................          switch (param_type_rcvd) 
01340:  MOVLB  3
01342:  MOVF   x5F,W
01344:  XORLW  06
01346:  MOVLB  0
01348:  BZ    1350
0134A:  XORLW  0E
0134C:  BZ    1352
0134E:  BRA    1352
....................          {   
....................             case  PARAM_JOINDUTY: 
....................                break; 
01350:  BRA    1352
....................             case  PARAM_SERVICE: 
....................                //    save info, no ack 
....................                //    rem_svc_entries_rcvd = \ 
....................                //    bytes_from_mote.set_service_response.rem_svc_entries; 
....................                break; 
....................             default:           
....................          } 
....................           
....................       // receipt of response after a GET command 
....................       case  CMD_GET: 
....................          // byte4 is the param_type for all GET responses 
....................          switch (param_type_rcvd) 
01352:  MOVLB  3
01354:  MOVF   x5F,W
01356:  XORLW  08
01358:  MOVLB  0
0135A:  BZ    1376
0135C:  XORLW  04
0135E:  BZ    137C
01360:  XORLW  01
01362:  BZ    13C0
01364:  XORLW  03
01366:  BZ    141C
01368:  XORLW  01
0136A:  BTFSC  FD8.2
0136C:  BRA    1464
0136E:  XORLW  1F
01370:  BTFSC  FD8.2
01372:  BRA    14AA
01374:  BRA    14AE
....................          {   
....................             case  PARAM_SERVICE: 
....................                svc_index_rcvd = bytes_from_mote.get_service_response.svc_index; 
01376:  MOVFF  DA,360
....................                /* 
....................                svc_state_rcvd = bytes_from_mote.get_service_response.svc_state; 
....................                svc_flags_rcvd = bytes_from_mote.get_service_response.svc_flags; 
....................                app_domain_rcvd = \ 
....................                   bytes_from_mote.get_service_response.app_domain; 
....................                */ 
....................                //destaddr_rcvd = bytes_from_mote.get_service_response.destaddr; 
....................                //time_rcvd = bytes_from_mote.get_service_response.time; 
....................                break; 
0137A:  BRA    14AE
....................  
....................             case  PARAM_MOTEINFO: 
....................                for (i=0; i<8; i++) 
0137C:  MOVLB  5
0137E:  CLRF   x83
01380:  MOVF   x83,W
01382:  SUBLW  07
01384:  BNC   13BC
....................                   serial_number_rcvd[i] = \ 
....................                      bytes_from_mote.get_moteinfo_response.serial_number[i]; 
01386:  CLRF   03
01388:  MOVF   x83,W
0138A:  ADDLW  93
0138C:  MOVWF  01
0138E:  MOVLW  00
01390:  ADDWFC 03,F
01392:  MOVFF  01,59B
01396:  MOVFF  03,59C
0139A:  CLRF   03
0139C:  MOVF   x83,W
0139E:  ADDLW  DB
013A0:  MOVWF  FE9
013A2:  MOVLW  00
013A4:  ADDWFC 03,W
013A6:  MOVWF  FEA
013A8:  MOVFF  FEF,59D
013AC:  MOVFF  59C,FEA
013B0:  MOVFF  01,FE9
013B4:  MOVFF  59D,FEF
013B8:  INCF   x83,F
013BA:  BRA    1380
....................                    
....................                /* 
....................                api_version_rcvd = \ 
....................                   bytes_from_mote.get_moteinfo_response.api_version; 
....................                hw_model_rcvd = bytes_from_mote.get_moteinfo_response.hw_model; 
....................                hw_version_rcvd = \ 
....................                   bytes_from_mote.get_moteinfo_response.hw_version; 
....................                sw_major_ver_rcvd = \ 
....................                   bytes_from_mote.get_moteinfo_response.sw_major_ver; 
....................                sw_minor_ver_rcvd = \ 
....................                   bytes_from_mote.get_moteinfo_response.sw_minor_ver; 
....................                sw_patch_rcvd = bytes_from_mote.get_moteinfo_response.sw_patch; 
....................                sw_build_rcvd = bytes_from_mote.get_moteinfo_response.sw_build; 
....................                */ 
....................                break; 
013BC:  MOVLB  0
013BE:  BRA    14AE
....................  
....................             case  PARAM_NETWORKINFO: 
....................                for (i=0; i<8; i++) 
013C0:  MOVLB  5
013C2:  CLRF   x83
013C4:  MOVF   x83,W
013C6:  SUBLW  07
013C8:  BNC   1400
....................                   macaddr_rcvd[i] = \ 
....................                      bytes_from_mote.get_networkinfo_response.macaddr[i]; 
013CA:  CLRF   03
013CC:  MOVF   x83,W
013CE:  ADDLW  9B
013D0:  MOVWF  01
013D2:  MOVLW  00
013D4:  ADDWFC 03,F
013D6:  MOVFF  01,59B
013DA:  MOVFF  03,59C
013DE:  CLRF   03
013E0:  MOVF   x83,W
013E2:  ADDLW  DA
013E4:  MOVWF  FE9
013E6:  MOVLW  00
013E8:  ADDWFC 03,W
013EA:  MOVWF  FEA
013EC:  MOVFF  FEF,59D
013F0:  MOVFF  59C,FEA
013F4:  MOVFF  01,FE9
013F8:  MOVFF  59D,FEF
013FC:  INCF   x83,F
013FE:  BRA    13C4
....................                mote_id_rcvd = bytes_from_mote.get_networkinfo_response.mote_id; 
01400:  MOVFF  E3,366
01404:  MOVFF  E2,365
....................                tmp2u16 = bytes_from_mote.get_networkinfo_response.network_id; 
01408:  MOVFF  E5,585
0140C:  MOVFF  E4,584
....................                network_id_rcvd = make16(make8(tmp2u16,0),make8(tmp2u16,1)); 
01410:  MOVFF  584,364
01414:  MOVFF  585,363
....................  
....................                break; 
01418:  MOVLB  0
0141A:  BRA    14AE
....................  
....................             case  PARAM_MOTESTATUS: 
....................                global_mote_state = bytes_from_mote.get_motestatus_response.mote_state; 
0141C:  MOVFF  DA,500
....................                 
....................                // this is where I decide if the mote is alive or not 
....................                global_dust_enabled = TRUE; 
01420:  BSF    xA3.6
....................                 
....................                // If the mote isn't fully connected (operational) set the global 
....................                //    dust operational bit to false 
....................                if (global_mote_state != MOTESTATE_OPERATIONAL) 
01422:  MOVLB  5
01424:  MOVF   x00,W
01426:  SUBLW  05
01428:  BZ    1432
....................                { 
....................                   global_dust_operational = FALSE; 
0142A:  MOVLB  0
0142C:  BCF    xA3.7
....................                } 
0142E:  BRA    1462
01430:  MOVLB  5
....................                // If the mote is fully connected... 
....................                else  
....................                { 
....................                   // and it wasn't before... 
....................                   if (global_dust_operational == FALSE) 
01432:  MOVLB  0
01434:  BTFSC  xA3.7
01436:  BRA    1462
....................                   { 
....................   
....................                      // set it to be connected and send a join message! 
....................                      global_dust_operational = TRUE; 
01438:  BSF    xA3.7
....................                      PUSH_MESSAGE_QUEUE_ISR_MACRO(MSG_MOTE_JOIN_MSG); 
0143A:  BCF    F7A.1
0143C:  MOVLW  94
0143E:  MOVLB  5
01440:  MOVWF  x9B
01442:  MOVLB  0
01444:  CALL   0BF8
01448:  BSF    F7A.1
....................                      PUSH_PRIORITY_QUEUE_ISR_MACRO(UPDATE_MOTE_TIME); 
0144A:  MOVLW  A3
0144C:  MOVLB  5
0144E:  MOVWF  x9B
01450:  MOVLB  0
01452:  CALL   0808
....................                      PUSH_PRIORITY_QUEUE_ISR_MACRO(CHECK_MOTE_TEMP); 
01456:  MOVLW  A2
01458:  MOVLB  5
0145A:  MOVWF  x9B
0145C:  MOVLB  0
0145E:  CALL   0808
....................                   } 
....................                }    
....................                //mote_alarms_rcvd = \ 
....................                //   bytes_from_mote.get_motestatus_response.mote_alarms; 
.................... /* 
....................                change_counter_rcvd = \ 
....................                   bytes_from_mote.get_motestatus_response.change_counter; 
....................                number_of_parents_rcvd = \ 
....................                   bytes_from_mote.get_motestatus_response.number_of_parents; 
.................... */ 
....................                break; 
01462:  BRA    14AE
....................  
....................             case  PARAM_TIME: 
....................                utc_sec_rcvd = bytes_from_mote.get_time_response.utc_sec; 
01464:  MOVFF  DD,58D
01468:  MOVFF  DC,58C
0146C:  MOVFF  DB,58B
01470:  MOVFF  DA,58A
....................                global_utc_time = make32(make8(utc_sec_rcvd,0), \ 
....................                  make8(utc_sec_rcvd,1), make8(utc_sec_rcvd,2), \ 
....................                  make8(utc_sec_rcvd,3));     //  **fix byte order** 
01474:  MOVFF  58A,8C
01478:  MOVFF  58B,8B
0147C:  MOVFF  58C,8A
01480:  MOVFF  58D,89
....................                               
....................                utc_usec_rcvd = bytes_from_mote.get_time_response.utc_usec; 
01484:  MOVFF  E1,591
01488:  MOVFF  E0,590
0148C:  MOVFF  DF,58F
01490:  MOVFF  DE,58E
....................                if (mote_msgSEQ == 0) 
01494:  MOVLB  3
01496:  MOVF   x61,F
01498:  BNZ   14A6
0149A:  MOVF   x62,F
0149C:  BNZ   14A6
....................                { 
....................                   mote_msgSEQ = make16(make8(utc_usec_rcvd,2), \                   
....................                      make8(utc_usec_rcvd,3)); 
0149E:  MOVFF  590,362
014A2:  MOVFF  591,361
....................                } 
....................                // This value is used to establish a "random" value for  
....................                //  the mote message Sequence ID 
.................... /*                
....................                for (i=0; i<5; i++) 
....................                   asn_rcvd[i] = bytes_from_mote.get_time_response.asn[i]; 
....................                asn_offset_rcvd = bytes_from_mote.get_time_response.asn_offset; 
.................... */                
....................                break; 
014A6:  MOVLB  0
014A8:  BRA    14AE
....................  
....................             case  PARAM_CHARGE: 
....................                //charge_mC_rcvd = bytes_from_mote.get_charge_response.charge_mC; 
....................                //uptime_sec_rcvd = bytes_from_mote.get_charge_response.uptime_sec; 
....................                global_mote_temperature = \ 
....................                   bytes_from_mote.get_charge_response.temp_celsius; 
014AA:  MOVFF  E2,369
....................                //temp_frac_celsius_rcvd = \ 
....................                //   bytes_from_mote.get_charge_response.temp_frac_celsius; 
....................                break; 
.................... /* 
....................             case  PARAM_RADIOSTATSRX: 
....................                num_of_received_packets_rcvd = \ 
....................                   bytes_from_mote.get_testrx_response.num_of_received_packets; 
....................                num_of_recep_failures = \ 
....................                   bytes_from_mote.get_testrx_response.num_of_recep_failures; 
....................                break; 
.................... */ 
....................             default: 
....................          } 
....................  
....................       case  CMD_SETNV: 
....................       // receipt of response after a SETNV command 
....................           switch (param_type_rcvd) 
014AE:  MOVLB  3
014B0:  MOVF   x5F,W
014B2:  XORLW  02
014B4:  MOVLB  0
014B6:  BZ    14BE
014B8:  XORLW  01
014BA:  BZ    14C0
014BC:  BRA    14C0
....................          {  // byte4 is the param_type for all SETNV responses 
....................             /* 
....................             case PARAM_MACADDR: case  PARAM_TXPOWER: \ 
....................             case  PARAM_POWERINFO: case  PARAM_OTAPLOCK: \ 
....................             case PARAM_SPECIAL1: case PARAM_SPECIAL2: 
....................                break; 
....................             */ 
....................             case PARAM_JOINKEY:  
....................                break; 
014BE:  BRA    14C0
....................             case  PARAM_NETWORKID:  
....................                break; 
....................             default: 
....................          } 
....................  
....................       case  CMD_GETNV: 
....................       // receipt of response after a GETNV command 
....................          switch (param_type_rcvd) 
014C0:  MOVLB  3
014C2:  MOVF   x5F,W
014C4:  XORLW  01
014C6:  MOVLB  0
014C8:  BZ    14D0
014CA:  XORLW  02
014CC:  BZ    1512
014CE:  BRA    1526
....................          {  // byte4 is the param_type for all GETNV responses 
....................             case  PARAM_MACADDR: 
....................                for (i=0; i<8; i++) 
014D0:  MOVLB  5
014D2:  CLRF   x83
014D4:  MOVF   x83,W
014D6:  SUBLW  07
014D8:  BNC   1510
....................                   macaddr_rcvd[i] = \ 
....................                      bytes_from_mote.getNV_macaddr_response.macaddr[i]; 
014DA:  CLRF   03
014DC:  MOVF   x83,W
014DE:  ADDLW  9B
014E0:  MOVWF  01
014E2:  MOVLW  00
014E4:  ADDWFC 03,F
014E6:  MOVFF  01,59B
014EA:  MOVFF  03,59C
014EE:  CLRF   03
014F0:  MOVF   x83,W
014F2:  ADDLW  DA
014F4:  MOVWF  FE9
014F6:  MOVLW  00
014F8:  ADDWFC 03,W
014FA:  MOVWF  FEA
014FC:  MOVFF  FEF,59D
01500:  MOVFF  59C,FEA
01504:  MOVFF  01,FE9
01508:  MOVFF  59D,FEF
0150C:  INCF   x83,F
0150E:  BRA    14D4
....................                break; 
01510:  BRA    1524
....................  
....................             case  PARAM_NETWORKID: 
....................                tmp2u16 = bytes_from_mote.getNV_networkid_response.network_id; 
01512:  MOVFF  DB,585
01516:  MOVFF  DA,584
....................                network_id_rcvd = make16(make8(tmp2u16,0),make8(tmp2u16,1)); 
0151A:  MOVFF  584,364
0151E:  MOVFF  585,363
....................                break; 
01522:  MOVLB  5
01524:  MOVLB  0
....................  
....................             default: 
....................           } 
....................  
....................       case  CMD_SEND:         case  CMD_DISCONNECT: \ 
....................       case  CMD_RESET:        case  CMD_SLEEP:     case  CMD_TESTRADIOTX: \ 
....................       case  CMD_TESTRADIORX:  case  CMD_CLEARNV: 
....................          // info saved above; receipt of response after any of the 
....................          // the above; no ack 
....................          break; 
01526:  BRA    1690
....................       case CMD_SEARCH: 
....................          if (result_rcvd == RC_OK) 
01528:  MOVLB  3
0152A:  MOVF   x5B,F
0152C:  BNZ   1536
....................          { 
....................             global_mote_state= MOTESTATE_SEARCHING; 
0152E:  MOVLW  02
01530:  MOVLB  5
01532:  MOVWF  x00
01534:  MOVLB  3
....................          } 
....................          break; 
01536:  MOVLB  0
01538:  BRA    1690
....................       case CMD_JOIN: 
....................          if (result_rcvd == RC_OK) 
0153A:  MOVLB  3
0153C:  MOVF   x5B,F
0153E:  BNZ   1548
....................             global_mote_state = MOTESTATE_NEGOTIATING; 
01540:  MOVLW  03
01542:  MOVLB  5
01544:  MOVWF  x00
01546:  MOVLB  3
....................             joincmd_done_fl = TRUE; 
01548:  BSF    x5D.3
....................          break; 
0154A:  MOVLB  0
0154C:  BRA    1690
....................  
....................       case  CMD_TIME: 
....................       // receipt of response after a _TIME hardware interrupt 
....................          utc_sec_rcvd = bytes_from_mote.time_indication.utc_sec; 
0154E:  MOVFF  DB,58D
01552:  MOVFF  DA,58C
01556:  MOVFF  D9,58B
0155A:  MOVFF  D8,58A
....................          global_utc_time = make32(make8(utc_sec_rcvd,0), \ 
....................          make8(utc_sec_rcvd,1), make8(utc_sec_rcvd,2), \ 
....................          make8(utc_sec_rcvd,3));     //  **fix byte order** 
0155E:  MOVFF  58A,8C
01562:  MOVFF  58B,8B
01566:  MOVFF  58C,8A
0156A:  MOVFF  58D,89
....................          utc_usec_rcvd = bytes_from_mote.time_indication.utc_usec; 
0156E:  MOVFF  DF,591
01572:  MOVFF  DE,590
01576:  MOVFF  DD,58F
0157A:  MOVFF  DC,58E
....................          if (!mote_msgSEQ) 
0157E:  MOVLB  3
01580:  MOVF   x61,W
01582:  IORWF  x62,W
01584:  BNZ   158E
....................          { 
....................             mote_msgSEQ = make16(make8(utc_usec_rcvd,2), \                   
....................                make8(utc_usec_rcvd,3)); 
01586:  MOVFF  590,362
0158A:  MOVFF  591,361
....................          } 
....................  
....................          /* 
....................          for (i=0; i<5; i++) 
....................             asn_rcvd[i] = bytes_from_mote.time_indication.asn[i]; 
....................          asn_offset_rcvd = bytes_from_mote.time_indication.asn_offset; 
....................          */ 
....................  
.................... //         dust_hdlc_pkgen(prefix_x, 2, (uint8_t*)&r_x, 2);   // type A 
....................          send_ack = TRUE; 
0158E:  MOVLB  5
01590:  BSF    x87.0
....................          break; 
01592:  MOVLB  0
01594:  BRA    1690
....................  
....................       case  CMD_SERVICE: 
....................       // receipt of a service indication from from manager 
....................          //event_code_rcvd = bytes_from_mote.service_indication.event_code; 
....................          svc_index_rcvd = bytes_from_mote.service_indication.svc_index; 
01596:  MOVFF  DA,360
....................          /* 
....................          mgr_code_rcvd = bytes_from_mote.service_indication.mgr_code; 
....................          svc_state_rcvd = bytes_from_mote.service_indication.svc_state; 
....................          svc_flags_rcvd = bytes_from_mote.service_indication.svc_flags; 
....................          app_domain_rcvd = bytes_from_mote.service_indication.app_domain; 
....................          */ 
....................          //destaddr_rcvd = bytes_from_mote.service_indication.destaddr; 
....................          //time_rcvd = bytes_from_mote.service_indication.time; 
....................  
....................  //        dust_hdlc_pkgen(prefix_x, 2, (uint8_t*)&r_x, 2);   // type A 
....................  
....................          send_ack = TRUE; 
0159A:  MOVLB  5
0159C:  BSF    x87.0
....................          break; 
0159E:  MOVLB  0
015A0:  BRA    1690
....................  
....................       case  CMD_EVENT: 
....................       // receipt of an event indication from the mote 
....................          // this is where I decide if the mote is alive or not 
....................          global_dust_enabled = TRUE; 
015A2:  BSF    xA3.6
....................           
....................          new_events_rcvd = bytes_from_mote.events_indication.new_events; 
015A4:  MOVFF  DB,595
015A8:  MOVFF  DA,594
015AC:  MOVFF  D9,593
015B0:  MOVFF  D8,592
....................          global_mote_state = bytes_from_mote.events_indication.mote_state; 
015B4:  MOVFF  DC,500
....................           
....................          // If the mote isn't fully connected (operational) set the global 
....................          //    dust operational bit to false 
....................          if (global_mote_state != MOTESTATE_OPERATIONAL) 
015B8:  MOVLB  5
015BA:  MOVF   x00,W
015BC:  SUBLW  05
015BE:  BZ    15C8
....................          { 
....................             global_dust_operational = FALSE; 
015C0:  MOVLB  0
015C2:  BCF    xA3.7
....................          } 
015C4:  BRA    15F8
015C6:  MOVLB  5
....................          // If the mote is fully connected... 
....................          else  
....................          {                                
....................             // and it wasn't before... 
....................             if (global_dust_operational == FALSE) 
015C8:  MOVLB  0
015CA:  BTFSC  xA3.7
015CC:  BRA    15F8
....................             { 
....................                // set it to be connected and send a join message! 
....................                global_dust_operational = TRUE; 
015CE:  BSF    xA3.7
....................                PUSH_MESSAGE_QUEUE_ISR_MACRO(MSG_MOTE_JOIN_MSG); 
015D0:  BCF    F7A.1
015D2:  MOVLW  94
015D4:  MOVLB  5
015D6:  MOVWF  x9B
015D8:  MOVLB  0
015DA:  CALL   0BF8
015DE:  BSF    F7A.1
....................                                              
....................                PUSH_PRIORITY_QUEUE_ISR_MACRO(UPDATE_MOTE_TIME); 
015E0:  MOVLW  A3
015E2:  MOVLB  5
015E4:  MOVWF  x9B
015E6:  MOVLB  0
015E8:  CALL   0808
....................                PUSH_PRIORITY_QUEUE_ISR_MACRO(CHECK_MOTE_TEMP);    
015EC:  MOVLW  A2
015EE:  MOVLB  5
015F0:  MOVWF  x9B
015F2:  MOVLB  0
015F4:  CALL   0808
....................             } 
....................          } 
....................          //mote_alarms_rcvd = bytes_from_mote.events_indication.mote_alarms; 
....................  
....................          event_flags |= make8(new_events_rcvd,3);  // only last byte has 
015F8:  MOVLB  5
015FA:  MOVF   x95,W
015FC:  MOVLB  0
015FE:  IORWF  xD4,F
....................          // defined events for Eterna 
....................     
....................          send_ack = TRUE;           
01600:  MOVLB  5
01602:  BSF    x87.0
....................          break; 
01604:  MOVLB  0
01606:  BRA    1690
....................  
....................       case  CMD_ADVERT: 
....................       // receipt of an event indication from the mote 
....................          tmp2u16 = bytes_from_mote.advert_indication.network_id; 
01608:  MOVFF  D9,585
0160C:  MOVFF  D8,584
....................          network_id_rcvd = make16(make8(tmp2u16,0),make8(tmp2u16,1)); 
01610:  MOVFF  584,364
01614:  MOVFF  585,363
....................          mote_id_rcvd = bytes_from_mote.advert_indication.mote_id; 
01618:  MOVFF  DB,366
0161C:  MOVFF  DA,365
....................           
....................          rssi_rcvd = bytes_from_mote.advert_indication.rssi; 
01620:  MOVFF  DC,367
....................          hop_depth_rcvd = bytes_from_mote.advert_indication.hop_depth; 
01624:  MOVFF  DD,368
....................           
....................          advert_rcvd_fl = TRUE; 
01628:  MOVLB  3
0162A:  BSF    x5C.3
....................    //      dust_hdlc_pkgen(prefix_x, 2, (uint8_t*)&r_x, 2);   // type A 
....................  
....................          send_ack = TRUE; 
0162C:  MOVLB  5
0162E:  BSF    x87.0
....................          break; 
01630:  MOVLB  0
01632:  BRA    1690
....................  
....................       case  CMD_DATA: 
....................       // receipt of a data packet payload from the manager 
....................          //sourceaddr_rcvd = bytes_from_mote.data_from_net.sourceaddr; 
....................          //sequence_num_rcvd = bytes_from_mote.data_from_net.sequence_num; 
....................          len_data_rcvd = bytes_from_mote.data_from_net.len_data; 
01634:  MOVFF  DB,589
....................  
....................          if (len_data_rcvd <= MAX_USER_DATA_SIZE) 
01638:  MOVLB  5
0163A:  MOVF   x89,W
0163C:  SUBLW  5E
0163E:  BNC   1680
....................          { 
....................             for (i=0; i<len_data_rcvd; i++) 
01640:  CLRF   x83
01642:  MOVF   x89,W
01644:  SUBWF  x83,W
01646:  BC    167E
....................               payload_buff[i] = bytes_from_mote.data_from_net.data[i]; 
01648:  CLRF   03
0164A:  MOVF   x83,W
0164C:  ADDLW  EF
0164E:  MOVWF  01
01650:  MOVLW  02
01652:  ADDWFC 03,F
01654:  MOVFF  01,59B
01658:  MOVFF  03,59C
0165C:  CLRF   03
0165E:  MOVF   x83,W
01660:  ADDLW  DC
01662:  MOVWF  FE9
01664:  MOVLW  00
01666:  ADDWFC 03,W
01668:  MOVWF  FEA
0166A:  MOVFF  FEF,59D
0166E:  MOVFF  59C,FEA
01672:  MOVFF  01,FE9
01676:  MOVFF  59D,FEF
0167A:  INCF   x83,F
0167C:  BRA    1642
....................          } 
0167E:  BRA    1684
....................          else 
....................          {     
....................             response_type = RC_INVALID_LEN; 
01680:  MOVLW  04
01682:  MOVWF  x88
....................          } 
....................           
....................          send_ack = TRUE; 
01684:  BSF    x87.0
....................  
....................          PUSH_PRIORITY_QUEUE_ISR_MACRO(DEAL_WITH_NEW_PACKET)          
01686:  MOVLW  20
01688:  MOVWF  x9B
0168A:  MOVLB  0
0168C:  CALL   0808
....................          break; 
....................  
....................       default: 
....................    } 
....................  
....................    // Send acks for appropriate messages 
....................     if (send_ack) 
01690:  MOVLB  5
01692:  BTFSS  x87.0
01694:  BRA    16F8
....................    { 
....................       // generates the dust message 
....................       uint8_t pkgen_buf[2], cmd_rcvd_buf[2]; 
....................       pkgen_buf[0] = (flags_rcvd+1); 
01696:  MOVLW  01
01698:  MOVLB  3
0169A:  ADDWF  x5E,W
0169C:  MOVLB  5
0169E:  MOVWF  x97
....................       pkgen_buf[1] = response_type; 
016A0:  MOVFF  588,598
....................       cmd_rcvd_buf[0] = cmd_rcvd; 
016A4:  MOVFF  586,599
....................       cmd_rcvd_buf[1] = 0; 
016A8:  CLRF   x9A
....................        
....................       dust_hdlc_pkgen_ISR(cmd_rcvd_buf, 2, pkgen_buf , 2); 
016AA:  MOVLW  05
016AC:  MOVWF  x9C
016AE:  MOVLW  99
016B0:  MOVWF  x9B
016B2:  MOVLW  02
016B4:  MOVWF  x9D
016B6:  MOVLW  05
016B8:  MOVWF  x9F
016BA:  MOVLW  97
016BC:  MOVWF  x9E
016BE:  MOVLW  02
016C0:  MOVWF  xA0
016C2:  MOVLB  0
016C4:  CALL   0EB6
....................        
....................       // try 3 times to send the ack 
....................       for (i = 0; i < 3; i++) 
016C8:  MOVLB  5
016CA:  CLRF   x83
016CC:  MOVF   x83,W
016CE:  SUBLW  02
016D0:  BNC   16F8
....................       { 
....................          // successful ack send 
....................          if (dust_hdlc_pksend_ISR() == NO_ERR)  
016D2:  MOVLB  0
016D4:  RCALL  1178
016D6:  MOVF   01,F
016D8:  BNZ   16E2
....................          { 
....................             break; 
016DA:  MOVLB  5
016DC:  BRA    16F8
....................          } 
016DE:  BRA    16F4
016E0:  MOVLB  0
....................          // wait 50ms and try again 
....................          else 
....................          { 
....................             setup_T4_int(T4_50MS); 
016E2:  MOVLW  C7
016E4:  MOVLB  5
016E6:  MOVWF  xA0
016E8:  MOVLB  0
016EA:  CALL   0916
....................             while(!TMR4IF);     
016EE:  BTFSS  F7E.0
016F0:  BRA    16EE
016F2:  MOVLB  5
....................          } 
016F4:  INCF   x83,F
016F6:  BRA    16CC
....................        
....................       // Add error handling if no ack (not sure how) 
....................       } 
....................    } 
016F8:  MOVLB  0
016FA:  GOTO   1716 (RETURN)
.................... } 
....................  
....................  
.................... uint8_t get_dustmsg_ISR(void) 
*
00928:  MOVLB  5
0092A:  CLRF   x9B
.................... { 
.................... // After being prompted by a hardware interrupts on the UART lines 
.................... // this routine is called to actually collect the serial data and  
.................... // store it in dust_recive_buffer 
.................... // 
.................... // Returns the number of chars collected (1 char = 1 not 0) or some error code 
.................... // Error Codes: 
.................... // -ERR_GET_DUSTMSG_MESSAGE_LENGTH  
.................... // -ERR_GET_DUSTMSG_FRAMING_ERROR 
....................  
.................... //  When the hardware UART is specified by #use rs232(): 
.................... //  RS232_ERRORS is used only by the getc() function. 
.................... //  RS232_ERRORS is a copy of the RCSTA register except 
.................... //  that Bit 0 is used to indicate a parity error. 
.................... //  RS232 Errors are not yet implemented 
....................  
....................    uint8_t     bytes_rcvd = 0; 
....................     
....................    // Start the UART and pause for initialization 
....................    setup_uart(TRUE);           
0092C:  BSF    FAB.7
0092E:  BSF    FAB.4
00930:  BSF    FAC.5
....................    setup_T4_int(T4_500US); 
00932:  MOVLW  01
00934:  MOVWF  xA0
00936:  MOVLB  0
00938:  RCALL  0916
....................    while(!TMR4IF);        
0093A:  BTFSS  F7E.0
0093C:  BRA    093A
....................     
....................    // recieve up to MAX_RCV_BUFFER  
....................    for (bytes_rcvd = 0; bytes_rcvd < MAX_RCV_BUFFER; bytes_rcvd++) 
0093E:  MOVLB  5
00940:  CLRF   x9B
00942:  MOVF   x9B,W
00944:  SUBLW  C9
00946:  BNC   099E
....................    { 
....................       // clear to send a byte 
....................       output_low(MOTE_TX_CTSn);  
00948:  BCF    F89.5
....................        
....................       // setup individual byte timeout and wait for next char 
....................       setup_T4_int(T0_10MS);    
0094A:  MOVLW  D9
0094C:  MOVWF  xA0
0094E:  MOVLB  0
00950:  RCALL  0916
....................       while (!kbhit() && !TMR4IF);  
00952:  BTFSC  F9E.5
00954:  BRA    095A
00956:  BTFSS  F7E.0
00958:  BRA    0952
....................        
....................       // not clear to send the next byte until we process this one 
....................       output_high(MOTE_TX_CTSn); 
0095A:  BSF    F89.5
....................        
....................       // return error on byte timeout 
....................       if (TMR4IF)  
0095C:  BTFSS  F7E.0
0095E:  BRA    096C
....................       { 
....................          setup_uart(FALSE);  
00960:  BCF    FAB.7
00962:  BCF    FAB.4
00964:  BCF    FAC.5
....................          return ERR_DUSTMSG_TIMEOUT; 
00966:  MOVLW  FC
00968:  MOVWF  01
0096A:  BRA    0A0E
....................       } 
....................        
....................       // grab the byte from the receive register 
....................       dust_recive_buffer[bytes_rcvd] = RCREG1;         
0096C:  CLRF   03
0096E:  MOVLB  5
00970:  MOVF   x9B,W
00972:  ADDLW  24
00974:  MOVWF  FE9
00976:  MOVLW  02
00978:  ADDWFC 03,W
0097A:  MOVWF  FEA
0097C:  MOVFF  FAE,FEF
....................        
....................       // done with getting message, break out of loop 
....................       if ((dust_recive_buffer[bytes_rcvd] == FLAG_SEQUENCE) && (bytes_rcvd != 0)) 
00980:  CLRF   03
00982:  MOVF   x9B,W
00984:  ADDLW  24
00986:  MOVWF  FE9
00988:  MOVLW  02
0098A:  ADDWFC 03,W
0098C:  MOVWF  FEA
0098E:  MOVF   FEF,W
00990:  SUBLW  7E
00992:  BNZ   099A
00994:  MOVF   x9B,F
00996:  BZ    099A
....................       { 
....................          break;          
00998:  BRA    099E
....................       }  
0099A:  INCF   x9B,F
0099C:  BRA    0942
....................    } 
....................      
....................    // after the message is done, stop the uart 
....................    setup_uart(FALSE);  
0099E:  BCF    FAB.7
009A0:  BCF    FAB.4
009A2:  BCF    FAC.5
....................     
....................    // Check for errors 
....................    // at this point only possible errors are framing and message length 
....................    // Too long of a message (no ending flag sequence) 
....................    if ((bytes_rcvd == MAX_RCV_BUFFER) && (dust_recive_buffer[bytes_rcvd] != FLAG_SEQUENCE)) 
009A4:  MOVF   x9B,W
009A6:  SUBLW  CA
009A8:  BNZ   09CA
009AA:  CLRF   03
009AC:  MOVF   x9B,W
009AE:  ADDLW  24
009B0:  MOVWF  FE9
009B2:  MOVLW  02
009B4:  ADDWFC 03,W
009B6:  MOVWF  FEA
009B8:  MOVF   FEF,W
009BA:  SUBLW  7E
009BC:  BZ    09CA
....................    { 
....................       return ERR_DUSTMSG_MESSAGE_LENGTH; 
009BE:  MOVLW  FF
009C0:  MOVWF  01
009C2:  MOVLB  0
009C4:  BRA    0A0E
....................    } 
009C6:  BRA    0A0E
009C8:  MOVLB  5
....................    // Too small of a message, return error code 
....................    else if (bytes_rcvd < 5) 
009CA:  MOVF   x9B,W
009CC:  SUBLW  04
009CE:  BNC   09DA
....................    { 
....................       return ERR_DUSTMSG_MESSAGE_LENGTH; 
009D0:  MOVLW  FF
009D2:  MOVWF  01
009D4:  MOVLB  0
009D6:  BRA    0A0E
....................    } 
009D8:  BRA    0A0E
....................    // Framing error, return error code 
....................    else if ((dust_recive_buffer[0] != FLAG_SEQUENCE) || (dust_recive_buffer[bytes_rcvd] != FLAG_SEQUENCE)) 
009DA:  MOVLB  2
009DC:  MOVF   x24,W
009DE:  SUBLW  7E
009E0:  BNZ   09FA
009E2:  CLRF   03
009E4:  MOVLB  5
009E6:  MOVF   x9B,W
009E8:  ADDLW  24
009EA:  MOVWF  FE9
009EC:  MOVLW  02
009EE:  ADDWFC 03,W
009F0:  MOVWF  FEA
009F2:  MOVF   FEF,W
009F4:  SUBLW  7E
009F6:  BZ    0A06
009F8:  MOVLB  2
....................    { 
....................       return ERR_DUSTMSG_FRAMING_ERROR; 
009FA:  MOVLW  FE
009FC:  MOVWF  01
009FE:  MOVLB  0
00A00:  BRA    0A0E
....................    } 
00A02:  BRA    0A0E
00A04:  MOVLB  5
....................    // all is well, exit normally 
....................    else 
....................    {           
....................       // return how many bytes recieved in actual (starting at 1) number       
....................       return (bytes_rcvd + 1); 
00A06:  MOVLW  01
00A08:  ADDWF  x9B,W
00A0A:  MOVWF  01
00A0C:  MOVLB  0
....................    } 
00A0E:  GOTO   1244 (RETURN)
.................... } 
....................  
.................... void dust_hdlc_pkgen(uint8_t* prefix, uint8_t size, \ 
....................                        uint8_t* buf, uint8_t size_buf) 
*
05E58:  MOVLB  5
05E5A:  CLRF   x68
05E5C:  CLRF   x67
05E5E:  CLRF   x69
05E60:  CLRF   x6A
05E62:  CLRF   x6B
.................... { 
.................... // dust_hdlc_pkgen() 
.................... // 
.................... // Generate an HDLC packet ready for a mote. 
.................... // 
.................... // 1. Calc CRC-16 
.................... // 2. Add start delimiters (flag sequence) 
.................... // 3. Byte stuff 0x7e & 0x7d 
.................... // 4. Add end delimiters (flag sequence) 
.................... // 
....................      
....................    uint16_t    fcs16       = 0; 
....................    uint8_t     data8       = 0; 
....................    uint8_t     i           = 0; 
....................    uint8_t     j           = 0; 
....................  
.................... // Step 1 
....................    fcs16 = FCS_INITIAL_FCS16; 
05E64:  SETF   x68
05E66:  SETF   x67
....................     
....................    // FCS the prefix bytes 
....................    for (i = 0; i < size; i++) 
05E68:  CLRF   x6A
05E6A:  MOVF   x63,W
05E6C:  SUBWF  x6A,W
05E6E:  BC    5EA8
....................    { 
....................       fcs16 = fcs_fcs16(fcs16, prefix[i]); 
05E70:  MOVF   x6A,W
05E72:  ADDWF  x61,W
05E74:  MOVWF  FE9
05E76:  MOVLW  00
05E78:  ADDWFC x62,W
05E7A:  MOVWF  FEA
05E7C:  MOVFF  FEF,5A9
05E80:  CLRF   19
05E82:  BTFSC  FF2.7
05E84:  BSF    19.7
05E86:  BCF    FF2.7
05E88:  MOVFF  568,5A8
05E8C:  MOVFF  567,5A7
05E90:  MOVLB  0
05E92:  CALL   0E74
05E96:  BTFSC  19.7
05E98:  BSF    FF2.7
05E9A:  MOVFF  02,568
05E9E:  MOVFF  01,567
05EA2:  MOVLB  5
05EA4:  INCF   x6A,F
05EA6:  BRA    5E6A
....................    } 
....................     
....................    // FCS the data packet bytes 
....................    for (i = 0; i < size_buf; i++) 
05EA8:  CLRF   x6A
05EAA:  MOVF   x66,W
05EAC:  SUBWF  x6A,W
05EAE:  BC    5EE8
....................    { 
....................       fcs16 = fcs_fcs16(fcs16, buf[i]); 
05EB0:  MOVF   x6A,W
05EB2:  ADDWF  x64,W
05EB4:  MOVWF  FE9
05EB6:  MOVLW  00
05EB8:  ADDWFC x65,W
05EBA:  MOVWF  FEA
05EBC:  MOVFF  FEF,5A9
05EC0:  CLRF   19
05EC2:  BTFSC  FF2.7
05EC4:  BSF    19.7
05EC6:  BCF    FF2.7
05EC8:  MOVFF  568,5A8
05ECC:  MOVFF  567,5A7
05ED0:  MOVLB  0
05ED2:  CALL   0E74
05ED6:  BTFSC  19.7
05ED8:  BSF    FF2.7
05EDA:  MOVFF  02,568
05EDE:  MOVFF  01,567
05EE2:  MOVLB  5
05EE4:  INCF   x6A,F
05EE6:  BRA    5EAA
....................    } 
....................  
....................    // add 1's complement 
....................    fcs16 = ~(fcs16);  
05EE8:  COMF   x67,F
05EEA:  COMF   x68,F
....................  
.................... // Step 2 
....................    //Set initial delimiter 
....................    j = 0; 
05EEC:  CLRF   x6B
....................    dust_send_buffer[j++]  = FLAG_SEQUENCE; 
05EEE:  MOVF   x6B,W
05EF0:  INCF   x6B,F
05EF2:  CLRF   03
05EF4:  ADDLW  3C
05EF6:  MOVWF  FE9
05EF8:  MOVLW  01
05EFA:  ADDWFC 03,W
05EFC:  MOVWF  FEA
05EFE:  MOVLW  7E
05F00:  MOVWF  FEF
....................  
.................... // Step 3 
....................    // Stuff prefix buffer 
....................    for (i = 0; i < size; i++) 
05F02:  CLRF   x6A
05F04:  MOVF   x63,W
05F06:  SUBWF  x6A,W
05F08:  BC    5FA4
....................    { 
....................       STUFF_BYTE(prefix[i], dust_send_buffer, j); 
05F0A:  MOVF   x6A,W
05F0C:  ADDWF  x61,W
05F0E:  MOVWF  FE9
05F10:  MOVLW  00
05F12:  ADDWFC x62,W
05F14:  MOVWF  FEA
05F16:  MOVF   FEF,W
05F18:  SUBLW  7D
05F1A:  BZ    5F2E
05F1C:  MOVF   x6A,W
05F1E:  ADDWF  x61,W
05F20:  MOVWF  FE9
05F22:  MOVLW  00
05F24:  ADDWFC x62,W
05F26:  MOVWF  FEA
05F28:  MOVF   FEF,W
05F2A:  SUBLW  7E
05F2C:  BNZ   5F76
05F2E:  MOVF   x6B,W
05F30:  INCF   x6B,F
05F32:  CLRF   03
05F34:  ADDLW  3C
05F36:  MOVWF  FE9
05F38:  MOVLW  01
05F3A:  ADDWFC 03,W
05F3C:  MOVWF  FEA
05F3E:  MOVLW  7D
05F40:  MOVWF  FEF
05F42:  MOVF   x6B,W
05F44:  INCF   x6B,F
05F46:  CLRF   03
05F48:  ADDLW  3C
05F4A:  MOVWF  01
05F4C:  MOVLW  01
05F4E:  ADDWFC 03,F
05F50:  MOVFF  01,56C
05F54:  MOVFF  03,56D
05F58:  MOVF   x6A,W
05F5A:  ADDWF  x61,W
05F5C:  MOVWF  FE9
05F5E:  MOVLW  00
05F60:  ADDWFC x62,W
05F62:  MOVWF  FEA
05F64:  MOVF   FEF,W
05F66:  XORLW  20
05F68:  MOVWF  x6E
05F6A:  MOVFF  03,FEA
05F6E:  MOVFF  01,FE9
05F72:  MOVWF  FEF
05F74:  BRA    5FA0
05F76:  MOVF   x6B,W
05F78:  INCF   x6B,F
05F7A:  CLRF   03
05F7C:  ADDLW  3C
05F7E:  MOVWF  01
05F80:  MOVLW  01
05F82:  ADDWFC 03,F
05F84:  MOVF   x6A,W
05F86:  ADDWF  x61,W
05F88:  MOVWF  FE9
05F8A:  MOVLW  00
05F8C:  ADDWFC x62,W
05F8E:  MOVWF  FEA
05F90:  MOVFF  FEF,56E
05F94:  MOVFF  03,FEA
05F98:  MOVFF  01,FE9
05F9C:  MOVFF  56E,FEF
05FA0:  INCF   x6A,F
05FA2:  BRA    5F04
....................    } 
....................  
....................    // Stuff data buffer 
....................    for (i = 0; i < size_buf; i++) 
05FA4:  CLRF   x6A
05FA6:  MOVF   x66,W
05FA8:  SUBWF  x6A,W
05FAA:  BC    6046
....................    { 
....................       STUFF_BYTE(buf[i], dust_send_buffer, j); 
05FAC:  MOVF   x6A,W
05FAE:  ADDWF  x64,W
05FB0:  MOVWF  FE9
05FB2:  MOVLW  00
05FB4:  ADDWFC x65,W
05FB6:  MOVWF  FEA
05FB8:  MOVF   FEF,W
05FBA:  SUBLW  7D
05FBC:  BZ    5FD0
05FBE:  MOVF   x6A,W
05FC0:  ADDWF  x64,W
05FC2:  MOVWF  FE9
05FC4:  MOVLW  00
05FC6:  ADDWFC x65,W
05FC8:  MOVWF  FEA
05FCA:  MOVF   FEF,W
05FCC:  SUBLW  7E
05FCE:  BNZ   6018
05FD0:  MOVF   x6B,W
05FD2:  INCF   x6B,F
05FD4:  CLRF   03
05FD6:  ADDLW  3C
05FD8:  MOVWF  FE9
05FDA:  MOVLW  01
05FDC:  ADDWFC 03,W
05FDE:  MOVWF  FEA
05FE0:  MOVLW  7D
05FE2:  MOVWF  FEF
05FE4:  MOVF   x6B,W
05FE6:  INCF   x6B,F
05FE8:  CLRF   03
05FEA:  ADDLW  3C
05FEC:  MOVWF  01
05FEE:  MOVLW  01
05FF0:  ADDWFC 03,F
05FF2:  MOVFF  01,56C
05FF6:  MOVFF  03,56D
05FFA:  MOVF   x6A,W
05FFC:  ADDWF  x64,W
05FFE:  MOVWF  FE9
06000:  MOVLW  00
06002:  ADDWFC x65,W
06004:  MOVWF  FEA
06006:  MOVF   FEF,W
06008:  XORLW  20
0600A:  MOVWF  x6E
0600C:  MOVFF  03,FEA
06010:  MOVFF  01,FE9
06014:  MOVWF  FEF
06016:  BRA    6042
06018:  MOVF   x6B,W
0601A:  INCF   x6B,F
0601C:  CLRF   03
0601E:  ADDLW  3C
06020:  MOVWF  01
06022:  MOVLW  01
06024:  ADDWFC 03,F
06026:  MOVF   x6A,W
06028:  ADDWF  x64,W
0602A:  MOVWF  FE9
0602C:  MOVLW  00
0602E:  ADDWFC x65,W
06030:  MOVWF  FEA
06032:  MOVFF  FEF,56E
06036:  MOVFF  03,FEA
0603A:  MOVFF  01,FE9
0603E:  MOVFF  56E,FEF
06042:  INCF   x6A,F
06044:  BRA    5FA6
....................    } 
....................  
....................    // Add least significiant byte 1st (RFC 1622). Do byte stuffing. 
....................    data8 = (uint8_t)(fcs16 & 0xff); 
06046:  MOVFF  567,569
....................    STUFF_BYTE(data8, dust_send_buffer, j); 
0604A:  MOVF   x69,W
0604C:  SUBLW  7D
0604E:  BZ    6056
06050:  MOVF   x69,W
06052:  SUBLW  7E
06054:  BNZ   6082
06056:  MOVF   x6B,W
06058:  INCF   x6B,F
0605A:  CLRF   03
0605C:  ADDLW  3C
0605E:  MOVWF  FE9
06060:  MOVLW  01
06062:  ADDWFC 03,W
06064:  MOVWF  FEA
06066:  MOVLW  7D
06068:  MOVWF  FEF
0606A:  MOVF   x6B,W
0606C:  INCF   x6B,F
0606E:  CLRF   03
06070:  ADDLW  3C
06072:  MOVWF  FE9
06074:  MOVLW  01
06076:  ADDWFC 03,W
06078:  MOVWF  FEA
0607A:  MOVF   x69,W
0607C:  XORLW  20
0607E:  MOVWF  FEF
06080:  BRA    6096
06082:  MOVF   x6B,W
06084:  INCF   x6B,F
06086:  CLRF   03
06088:  ADDLW  3C
0608A:  MOVWF  FE9
0608C:  MOVLW  01
0608E:  ADDWFC 03,W
06090:  MOVWF  FEA
06092:  MOVFF  569,FEF
....................  
....................    // Add most significiant byte 2nd (RFC 1622). Do byte stuffing. 
....................    data8 = (uint8_t)((fcs16>>8) & 0xff); 
06096:  MOVFF  568,569
....................    STUFF_BYTE(data8, dust_send_buffer, j); 
0609A:  MOVF   x69,W
0609C:  SUBLW  7D
0609E:  BZ    60A6
060A0:  MOVF   x69,W
060A2:  SUBLW  7E
060A4:  BNZ   60D2
060A6:  MOVF   x6B,W
060A8:  INCF   x6B,F
060AA:  CLRF   03
060AC:  ADDLW  3C
060AE:  MOVWF  FE9
060B0:  MOVLW  01
060B2:  ADDWFC 03,W
060B4:  MOVWF  FEA
060B6:  MOVLW  7D
060B8:  MOVWF  FEF
060BA:  MOVF   x6B,W
060BC:  INCF   x6B,F
060BE:  CLRF   03
060C0:  ADDLW  3C
060C2:  MOVWF  FE9
060C4:  MOVLW  01
060C6:  ADDWFC 03,W
060C8:  MOVWF  FEA
060CA:  MOVF   x69,W
060CC:  XORLW  20
060CE:  MOVWF  FEF
060D0:  BRA    60E6
060D2:  MOVF   x6B,W
060D4:  INCF   x6B,F
060D6:  CLRF   03
060D8:  ADDLW  3C
060DA:  MOVWF  FE9
060DC:  MOVLW  01
060DE:  ADDWFC 03,W
060E0:  MOVWF  FEA
060E2:  MOVFF  569,FEF
....................  
.................... // Step 4 
....................    // CHECK_BUF_SIZE(j+1); 
....................    dust_send_buffer[j++]  = FLAG_SEQUENCE; 
060E6:  MOVF   x6B,W
060E8:  INCF   x6B,F
060EA:  CLRF   03
060EC:  ADDLW  3C
060EE:  MOVWF  FE9
060F0:  MOVLW  01
060F2:  ADDWFC 03,W
060F4:  MOVWF  FEA
060F6:  MOVLW  7E
060F8:  MOVWF  FEF
....................  
....................    // Set the number of bytes actually written 
....................    num_of_bytes_to_send = j; 
060FA:  MOVFF  56B,34D
....................     
....................    return; 
060FE:  MOVLB  0
06100:  RETURN 0
.................... } 
....................  
.................... void dust_hdlc_pkgen_ISR(uint8_t* prefix, uint8_t size, \ 
....................                        uint8_t* buf, uint8_t size_buf) 
*
00EB6:  MOVLB  5
00EB8:  CLRF   xA2
00EBA:  CLRF   xA1
00EBC:  CLRF   xA3
00EBE:  CLRF   xA4
00EC0:  CLRF   xA5
.................... { 
.................... // Generate an HDLC packet ready for a mote. 
.................... // 
.................... // 1. Calc CRC-16 
.................... // 2. Add start delimiters (flag sequence) 
.................... // 3. Byte stuff 0x7e & 0x7d 
.................... // 4. Add end delimiters (flag sequence) 
.................... // 
....................      
....................    uint16_t    fcs16       = 0; 
....................    uint8_t     data8       = 0; 
....................    uint8_t     i           = 0; 
....................    uint8_t     j           = 0; 
....................  
.................... // Step 1 
....................    fcs16 = FCS_INITIAL_FCS16; 
00EC2:  SETF   xA2
00EC4:  SETF   xA1
....................     
....................    // FCS the prefix bytes 
....................    for (i = 0; i < size; i++) 
00EC6:  CLRF   xA4
00EC8:  MOVF   x9D,W
00ECA:  SUBWF  xA4,W
00ECC:  BC    0EF8
....................    { 
....................       fcs16 = fcs_fcs16(fcs16, prefix[i]); 
00ECE:  MOVF   xA4,W
00ED0:  ADDWF  x9B,W
00ED2:  MOVWF  FE9
00ED4:  MOVLW  00
00ED6:  ADDWFC x9C,W
00ED8:  MOVWF  FEA
00EDA:  MOVFF  FEF,5A9
00EDE:  MOVFF  5A2,5A8
00EE2:  MOVFF  5A1,5A7
00EE6:  MOVLB  0
00EE8:  RCALL  0E74
00EEA:  MOVFF  02,5A2
00EEE:  MOVFF  01,5A1
00EF2:  MOVLB  5
00EF4:  INCF   xA4,F
00EF6:  BRA    0EC8
....................    } 
....................     
....................    // FCS the data packet bytes 
....................    for (i = 0; i < size_buf; i++) 
00EF8:  CLRF   xA4
00EFA:  MOVF   xA0,W
00EFC:  SUBWF  xA4,W
00EFE:  BC    0F2A
....................    { 
....................       fcs16 = fcs_fcs16(fcs16, buf[i]); 
00F00:  MOVF   xA4,W
00F02:  ADDWF  x9E,W
00F04:  MOVWF  FE9
00F06:  MOVLW  00
00F08:  ADDWFC x9F,W
00F0A:  MOVWF  FEA
00F0C:  MOVFF  FEF,5A9
00F10:  MOVFF  5A2,5A8
00F14:  MOVFF  5A1,5A7
00F18:  MOVLB  0
00F1A:  RCALL  0E74
00F1C:  MOVFF  02,5A2
00F20:  MOVFF  01,5A1
00F24:  MOVLB  5
00F26:  INCF   xA4,F
00F28:  BRA    0EFA
....................    } 
....................  
....................    // add 1's complement 
....................    fcs16 = ~(fcs16);  
00F2A:  COMF   xA1,F
00F2C:  COMF   xA2,F
....................  
.................... // Step 2 
....................    //Set initial delimiter 
....................    j = 0; 
00F2E:  CLRF   xA5
....................    dust_send_buffer_isr[j++]  = FLAG_SEQUENCE; 
00F30:  MOVF   xA5,W
00F32:  INCF   xA5,F
00F34:  CLRF   03
00F36:  ADDLW  0C
00F38:  MOVWF  FE9
00F3A:  MOVLW  02
00F3C:  ADDWFC 03,W
00F3E:  MOVWF  FEA
00F40:  MOVLW  7E
00F42:  MOVWF  FEF
....................  
.................... // Step 3 
....................    // Stuff prefix buffer 
....................    for (i = 0; i < size; i++) 
00F44:  CLRF   xA4
00F46:  MOVF   x9D,W
00F48:  SUBWF  xA4,W
00F4A:  BC    0FE6
....................    { 
....................       STUFF_BYTE(prefix[i], dust_send_buffer_isr, j); 
00F4C:  MOVF   xA4,W
00F4E:  ADDWF  x9B,W
00F50:  MOVWF  FE9
00F52:  MOVLW  00
00F54:  ADDWFC x9C,W
00F56:  MOVWF  FEA
00F58:  MOVF   FEF,W
00F5A:  SUBLW  7D
00F5C:  BZ    0F70
00F5E:  MOVF   xA4,W
00F60:  ADDWF  x9B,W
00F62:  MOVWF  FE9
00F64:  MOVLW  00
00F66:  ADDWFC x9C,W
00F68:  MOVWF  FEA
00F6A:  MOVF   FEF,W
00F6C:  SUBLW  7E
00F6E:  BNZ   0FB8
00F70:  MOVF   xA5,W
00F72:  INCF   xA5,F
00F74:  CLRF   03
00F76:  ADDLW  0C
00F78:  MOVWF  FE9
00F7A:  MOVLW  02
00F7C:  ADDWFC 03,W
00F7E:  MOVWF  FEA
00F80:  MOVLW  7D
00F82:  MOVWF  FEF
00F84:  MOVF   xA5,W
00F86:  INCF   xA5,F
00F88:  CLRF   03
00F8A:  ADDLW  0C
00F8C:  MOVWF  01
00F8E:  MOVLW  02
00F90:  ADDWFC 03,F
00F92:  MOVFF  01,5A6
00F96:  MOVFF  03,5A7
00F9A:  MOVF   xA4,W
00F9C:  ADDWF  x9B,W
00F9E:  MOVWF  FE9
00FA0:  MOVLW  00
00FA2:  ADDWFC x9C,W
00FA4:  MOVWF  FEA
00FA6:  MOVF   FEF,W
00FA8:  XORLW  20
00FAA:  MOVWF  xA8
00FAC:  MOVFF  03,FEA
00FB0:  MOVFF  01,FE9
00FB4:  MOVWF  FEF
00FB6:  BRA    0FE2
00FB8:  MOVF   xA5,W
00FBA:  INCF   xA5,F
00FBC:  CLRF   03
00FBE:  ADDLW  0C
00FC0:  MOVWF  01
00FC2:  MOVLW  02
00FC4:  ADDWFC 03,F
00FC6:  MOVF   xA4,W
00FC8:  ADDWF  x9B,W
00FCA:  MOVWF  FE9
00FCC:  MOVLW  00
00FCE:  ADDWFC x9C,W
00FD0:  MOVWF  FEA
00FD2:  MOVFF  FEF,5A8
00FD6:  MOVFF  03,FEA
00FDA:  MOVFF  01,FE9
00FDE:  MOVFF  5A8,FEF
00FE2:  INCF   xA4,F
00FE4:  BRA    0F46
....................    } 
....................  
....................    // Stuff data buffer 
....................    for (i = 0; i < size_buf; i++) 
00FE6:  CLRF   xA4
00FE8:  MOVF   xA0,W
00FEA:  SUBWF  xA4,W
00FEC:  BC    1088
....................    { 
....................       STUFF_BYTE(buf[i], dust_send_buffer_isr, j); 
00FEE:  MOVF   xA4,W
00FF0:  ADDWF  x9E,W
00FF2:  MOVWF  FE9
00FF4:  MOVLW  00
00FF6:  ADDWFC x9F,W
00FF8:  MOVWF  FEA
00FFA:  MOVF   FEF,W
00FFC:  SUBLW  7D
00FFE:  BZ    1012
01000:  MOVF   xA4,W
01002:  ADDWF  x9E,W
01004:  MOVWF  FE9
01006:  MOVLW  00
01008:  ADDWFC x9F,W
0100A:  MOVWF  FEA
0100C:  MOVF   FEF,W
0100E:  SUBLW  7E
01010:  BNZ   105A
01012:  MOVF   xA5,W
01014:  INCF   xA5,F
01016:  CLRF   03
01018:  ADDLW  0C
0101A:  MOVWF  FE9
0101C:  MOVLW  02
0101E:  ADDWFC 03,W
01020:  MOVWF  FEA
01022:  MOVLW  7D
01024:  MOVWF  FEF
01026:  MOVF   xA5,W
01028:  INCF   xA5,F
0102A:  CLRF   03
0102C:  ADDLW  0C
0102E:  MOVWF  01
01030:  MOVLW  02
01032:  ADDWFC 03,F
01034:  MOVFF  01,5A6
01038:  MOVFF  03,5A7
0103C:  MOVF   xA4,W
0103E:  ADDWF  x9E,W
01040:  MOVWF  FE9
01042:  MOVLW  00
01044:  ADDWFC x9F,W
01046:  MOVWF  FEA
01048:  MOVF   FEF,W
0104A:  XORLW  20
0104C:  MOVWF  xA8
0104E:  MOVFF  03,FEA
01052:  MOVFF  01,FE9
01056:  MOVWF  FEF
01058:  BRA    1084
0105A:  MOVF   xA5,W
0105C:  INCF   xA5,F
0105E:  CLRF   03
01060:  ADDLW  0C
01062:  MOVWF  01
01064:  MOVLW  02
01066:  ADDWFC 03,F
01068:  MOVF   xA4,W
0106A:  ADDWF  x9E,W
0106C:  MOVWF  FE9
0106E:  MOVLW  00
01070:  ADDWFC x9F,W
01072:  MOVWF  FEA
01074:  MOVFF  FEF,5A8
01078:  MOVFF  03,FEA
0107C:  MOVFF  01,FE9
01080:  MOVFF  5A8,FEF
01084:  INCF   xA4,F
01086:  BRA    0FE8
....................    } 
....................  
....................    // Add least significiant byte 1st (RFC 1622). Do byte stuffing. 
....................    data8 = (uint8_t)(fcs16 & 0xff); 
01088:  MOVFF  5A1,5A3
....................    STUFF_BYTE(data8, dust_send_buffer_isr, j); 
0108C:  MOVF   xA3,W
0108E:  SUBLW  7D
01090:  BZ    1098
01092:  MOVF   xA3,W
01094:  SUBLW  7E
01096:  BNZ   10C4
01098:  MOVF   xA5,W
0109A:  INCF   xA5,F
0109C:  CLRF   03
0109E:  ADDLW  0C
010A0:  MOVWF  FE9
010A2:  MOVLW  02
010A4:  ADDWFC 03,W
010A6:  MOVWF  FEA
010A8:  MOVLW  7D
010AA:  MOVWF  FEF
010AC:  MOVF   xA5,W
010AE:  INCF   xA5,F
010B0:  CLRF   03
010B2:  ADDLW  0C
010B4:  MOVWF  FE9
010B6:  MOVLW  02
010B8:  ADDWFC 03,W
010BA:  MOVWF  FEA
010BC:  MOVF   xA3,W
010BE:  XORLW  20
010C0:  MOVWF  FEF
010C2:  BRA    10D8
010C4:  MOVF   xA5,W
010C6:  INCF   xA5,F
010C8:  CLRF   03
010CA:  ADDLW  0C
010CC:  MOVWF  FE9
010CE:  MOVLW  02
010D0:  ADDWFC 03,W
010D2:  MOVWF  FEA
010D4:  MOVFF  5A3,FEF
....................  
....................    // Add most significiant byte 2nd (RFC 1622). Do byte stuffing. 
....................    data8 = (uint8_t)((fcs16>>8) & 0xff); 
010D8:  MOVFF  5A2,5A3
....................    STUFF_BYTE(data8, dust_send_buffer_isr, j); 
010DC:  MOVF   xA3,W
010DE:  SUBLW  7D
010E0:  BZ    10E8
010E2:  MOVF   xA3,W
010E4:  SUBLW  7E
010E6:  BNZ   1114
010E8:  MOVF   xA5,W
010EA:  INCF   xA5,F
010EC:  CLRF   03
010EE:  ADDLW  0C
010F0:  MOVWF  FE9
010F2:  MOVLW  02
010F4:  ADDWFC 03,W
010F6:  MOVWF  FEA
010F8:  MOVLW  7D
010FA:  MOVWF  FEF
010FC:  MOVF   xA5,W
010FE:  INCF   xA5,F
01100:  CLRF   03
01102:  ADDLW  0C
01104:  MOVWF  FE9
01106:  MOVLW  02
01108:  ADDWFC 03,W
0110A:  MOVWF  FEA
0110C:  MOVF   xA3,W
0110E:  XORLW  20
01110:  MOVWF  FEF
01112:  BRA    1128
01114:  MOVF   xA5,W
01116:  INCF   xA5,F
01118:  CLRF   03
0111A:  ADDLW  0C
0111C:  MOVWF  FE9
0111E:  MOVLW  02
01120:  ADDWFC 03,W
01122:  MOVWF  FEA
01124:  MOVFF  5A3,FEF
....................  
.................... // Step 4 
....................    // CHECK_BUF_SIZE(j+1); 
....................    dust_send_buffer_isr[j++]  = FLAG_SEQUENCE; 
01128:  MOVF   xA5,W
0112A:  INCF   xA5,F
0112C:  CLRF   03
0112E:  ADDLW  0C
01130:  MOVWF  FE9
01132:  MOVLW  02
01134:  ADDWFC 03,W
01136:  MOVWF  FEA
01138:  MOVLW  7E
0113A:  MOVWF  FEF
....................  
....................    // Set the number of bytes actually written 
....................    num_of_bytes_to_send_isr = j; 
0113C:  MOVFF  5A5,34E
....................     
....................    return; 
01140:  MOVLB  0
01142:  RETURN 0
.................... } 
....................  
.................... uint8_t dust_hdlc_pksend() 
.................... { 
.................... // This routine actually sends out the packet from the micro to the mote 
....................  
....................    uint8_t     n; 
....................    uint8_t     tmp_oscccon, tmp_t2con, tmp_pr2, tmp_t0con; 
....................     
....................    // save the crystal status for later restore 
....................    tmp_oscccon = OSCCON; 
*
06102:  MOVFF  FD3,560
....................    tmp_t2con = T2CON; 
06106:  MOVFF  FBA,561
....................    tmp_pr2 = PR2; 
0610A:  MOVFF  FBB,562
....................    tmp_t0con = T0CON; 
0610E:  MOVFF  FD5,563
06112:  CLRF   19
06114:  BTFSC  FF2.7
06116:  BSF    19.7
06118:  BCF    FF2.7
....................     
....................    // turn on high-speed crystal for UART communication 
....................    fosc_pri(); 
0611A:  CALL   1144
0611E:  BTFSC  19.7
06120:  BSF    FF2.7
....................  
....................    // prepare mote to recieve data 
....................    output_low(MOTE_RX_RTSn); 
06122:  BCF    F8C.5
....................    
....................    // turn on uart and wait for it to initalize 
....................    setup_uart(TRUE);                      
06124:  BSF    FAB.7
06126:  BSF    FAB.4
06128:  BSF    FAC.5
....................    setup_T0_int(T0_500US); 
0612A:  MOVLB  5
0612C:  SETF   x65
0612E:  MOVLW  FE
06130:  MOVWF  x64
06132:  MOVLB  0
06134:  CALL   36B2
....................    while(!TMR0IF);    
06138:  BTFSS  FF2.2
0613A:  BRA    6138
....................  
....................    // loop for sending out bytes 
....................    for (n = 0; n < num_of_bytes_to_send; n++) 
0613C:  MOVLB  5
0613E:  CLRF   x5F
06140:  MOVLB  3
06142:  MOVF   x4D,W
06144:  MOVLB  5
06146:  SUBWF  x5F,W
06148:  BC    6194
....................    { 
....................       // setup send timeout for error handling 
....................       setup_T0_int(T0_10MS); 
0614A:  SETF   x65
0614C:  MOVLW  D9
0614E:  MOVWF  x64
06150:  MOVLB  0
06152:  CALL   36B2
....................  
....................       // wait until a transmit is done or timeout error 
....................       while (!TRMT1 && !TMR0IF); 
06156:  BTFSC  FAC.1
06158:  BRA    615E
0615A:  BTFSS  FF2.2
0615C:  BRA    6156
....................        
....................       // if the timeout occured before the tranmit finished 
....................       if (TMR0IF) 
0615E:  BTFSS  FF2.2
06160:  BRA    6172
....................       { 
....................          // tell mote that it is no longer going to recieve data 
....................          output_high(MOTE_RX_RTSn); 
06162:  BSF    F8C.5
....................          // turn off uart 
....................          setup_uart(FALSE); 
06164:  BCF    FAB.7
06166:  BCF    FAB.4
06168:  BCF    FAC.5
....................          // return error code 
....................          return ERR_DUSTMSG_TIMEOUT; 
0616A:  MOVLW  FC
0616C:  MOVWF  01
0616E:  BRA    61B6
....................       } 
06170:  BRA    618E
....................       // if transmit buffer is open 
....................       else 
....................       { 
....................          // send byte to mote 
....................          putc(dust_send_buffer[n]); 
06172:  CLRF   03
06174:  MOVLB  5
06176:  MOVF   x5F,W
06178:  ADDLW  3C
0617A:  MOVWF  FE9
0617C:  MOVLW  01
0617E:  ADDWFC 03,W
06180:  MOVWF  FEA
06182:  MOVFF  FEF,564
06186:  MOVF   x64,W
06188:  MOVLB  0
0618A:  CALL   1170
....................       } 
0618E:  MOVLB  5
06190:  INCF   x5F,F
06192:  BRA    6140
....................    } 
....................     
....................    // wait until the last transmit is done 
....................    while (!TRMT1); 
06194:  BTFSS  FAC.1
06196:  BRA    6194
....................  
....................    // tell mote that it no longer is going to recieve data 
....................    output_high(MOTE_RX_RTSn); 
06198:  BSF    F8C.5
....................     
....................    // turn off the uart 
....................    setup_uart(FALSE); 
0619A:  BCF    FAB.7
0619C:  BCF    FAB.4
0619E:  BCF    FAC.5
....................     
....................    //fosc_250k(); 
....................    
....................    // restore the crystal status 
....................    OSCCON = tmp_oscccon; 
061A0:  MOVFF  560,FD3
....................    T2CON = tmp_t2con; 
061A4:  MOVFF  561,FBA
....................    T0CON = tmp_t0con; 
061A8:  MOVFF  563,FD5
....................    PR2 = tmp_PR2; 
061AC:  MOVFF  562,FBB
....................     
....................    // return no error 
....................    return NO_ERR; 
061B0:  MOVLW  00
061B2:  MOVWF  01
061B4:  MOVLB  0
061B6:  RETURN 0
.................... } 
....................  
.................... uint8_t dust_hdlc_pksend_ISR() 
.................... { 
.................... // We're now running at 3.6864MHz at 115.2K baud 
.................... // This routine actually sends out the packet from the micro to the mote 
....................     
....................    uint8_t     n; 
....................    uint8_t     tmp_oscccon, tmp_t2con, tmp_pr2, tmp_t0con; 
....................     
....................    // save the crystal status for later restore 
....................    tmp_oscccon = OSCCON; 
*
01178:  MOVFF  FD3,59C
....................    tmp_t2con = T2CON; 
0117C:  MOVFF  FBA,59D
....................    tmp_pr2 = PR2; 
01180:  MOVFF  FBB,59E
....................    tmp_t0con = T0CON; 
01184:  MOVFF  FD5,59F
....................     
....................    // turn on high-speed crystal for UART communication 
....................    fosc_pri(); 
01188:  RCALL  1144
....................  
....................    // prepare mote to recieve data 
....................    output_low(MOTE_RX_RTSn); 
0118A:  BCF    F8C.5
....................    
....................    // turn on uart and wait for it to initalize 
....................    setup_uart(TRUE);                      
0118C:  BSF    FAB.7
0118E:  BSF    FAB.4
01190:  BSF    FAC.5
....................    setup_T4_int(T4_500US); 
01192:  MOVLW  01
01194:  MOVLB  5
01196:  MOVWF  xA0
01198:  MOVLB  0
0119A:  CALL   0916
....................    while(!TMR4IF);    
0119E:  BTFSS  F7E.0
011A0:  BRA    119E
....................  
....................    for (n = 0; n < num_of_bytes_to_send_isr; n++) 
011A2:  MOVLB  5
011A4:  CLRF   x9B
011A6:  MOVLB  3
011A8:  MOVF   x4E,W
011AA:  MOVLB  5
011AC:  SUBWF  x9B,W
011AE:  BC    11F6
....................    { 
....................       // setup send timeout for error handling 
....................       setup_T4_int(T4_10MS); 
011B0:  MOVLW  27
011B2:  MOVWF  xA0
011B4:  MOVLB  0
011B6:  CALL   0916
....................  
....................       // wait until a transmit is done or timeout error 
....................       while (!TRMT1 && !TMR4IF); 
011BA:  BTFSC  FAC.1
011BC:  BRA    11C2
011BE:  BTFSS  F7E.0
011C0:  BRA    11BA
....................        
....................       // if the timeout occured before the tranmit finished 
....................       if (TMR4IF) 
011C2:  BTFSS  F7E.0
011C4:  BRA    11D6
....................       { 
....................          // tell mote that it is no longer going to recieve data 
....................          output_high(MOTE_RX_RTSn); 
011C6:  BSF    F8C.5
....................          // turn off uart 
....................          setup_uart(FALSE); 
011C8:  BCF    FAB.7
011CA:  BCF    FAB.4
011CC:  BCF    FAC.5
....................          // return error code 
....................          return ERR_DUSTMSG_TIMEOUT; 
011CE:  MOVLW  FC
011D0:  MOVWF  01
011D2:  BRA    1218
....................       } 
011D4:  BRA    11F0
....................       // if transmit buffer is open 
....................       else 
....................       { 
....................          // send byte to mote 
....................          putc(dust_send_buffer_isr[n]); 
011D6:  CLRF   03
011D8:  MOVLB  5
011DA:  MOVF   x9B,W
011DC:  ADDLW  0C
011DE:  MOVWF  FE9
011E0:  MOVLW  02
011E2:  ADDWFC 03,W
011E4:  MOVWF  FEA
011E6:  MOVFF  FEF,5A0
011EA:  MOVF   xA0,W
011EC:  MOVLB  0
011EE:  RCALL  1170
....................       } 
011F0:  MOVLB  5
011F2:  INCF   x9B,F
011F4:  BRA    11A6
....................    } 
....................     
....................    // wait until the last transmit is done 
....................    while (!TRMT1); 
011F6:  BTFSS  FAC.1
011F8:  BRA    11F6
....................  
....................    // tell mote that it no longer is going to recieve data 
....................    output_high(MOTE_RX_RTSn); 
011FA:  BSF    F8C.5
....................     
....................    // turn off the uart 
....................    setup_uart(FALSE); 
011FC:  BCF    FAB.7
011FE:  BCF    FAB.4
01200:  BCF    FAC.5
....................     
....................    // restore the crystal status 
....................    OSCCON = tmp_oscccon; 
01202:  MOVFF  59C,FD3
....................    T2CON = tmp_t2con; 
01206:  MOVFF  59D,FBA
....................    T0CON = tmp_t0con; 
0120A:  MOVFF  59F,FD5
....................    PR2 = tmp_PR2; 
0120E:  MOVFF  59E,FBB
....................     
....................    // return no error 
....................    return NO_ERR; 
01212:  MOVLW  00
01214:  MOVWF  01
01216:  MOVLB  0
01218:  RETURN 0
.................... } 
....................  
.................... uint8_t dust_hdlc_pkdecode_ISR(uint8_t bytes_to_decode) 
*
00AB2:  MOVLB  5
00AB4:  CLRF   x9D
00AB6:  CLRF   x9C
00AB8:  CLRF   xA4
.................... { 
.................... /* 
....................  * Decode an HDLC packet from Mote. 
....................  * 
....................  * NOTE: The destination buffer must contain an extra 
....................  *       2 bytes to hold CRC data.  This requirement 
....................  *       simplifies the code and improves performance. 
....................  * 
....................  * 1. Remove delimiters 
....................  * 2. Unstuff *payload* and CRC bytes 
....................  * 3. Assemble CRC bytes 
....................  * 4. Check CRC 
....................  *  
....................  * Returns error messages or the number of byte decoded 
.................... */ 
....................  
.................... //  Note changes to routine as supplied by Dust: 
.................... //  The buffer and buffer size for the storage of received packet 
.................... //   are hardwired to be dust_recive_buffer[128] for the raw data 
.................... //   and bytes_from_mote.dust_rcvd for the unstuffed and stripped data 
....................  
....................    uint16_t    crc16       = 0; 
....................    uint8_t*    src_ptr; 
....................    uint8_t*    src_ptr_end; 
....................    uint8_t*    dest_ptr; 
....................  
....................    uint8_t      dust_bytes_rcvd = 0; 
....................  
.................... // 1 Check for start/end delimiters 
....................     if ((FLAG_SEQUENCE != dust_recive_buffer[0]) || 
....................         (FLAG_SEQUENCE != dust_recive_buffer[bytes_to_decode-1]))  
00ABA:  MOVLB  2
00ABC:  MOVF   x24,W
00ABE:  SUBLW  7E
00AC0:  BNZ   0ADC
00AC2:  MOVLW  01
00AC4:  MOVLB  5
00AC6:  SUBWF  x9B,W
00AC8:  CLRF   03
00ACA:  ADDLW  24
00ACC:  MOVWF  FE9
00ACE:  MOVLW  02
00AD0:  ADDWFC 03,W
00AD2:  MOVWF  FEA
00AD4:  MOVF   FEF,W
00AD6:  SUBLW  7E
00AD8:  BZ    0AE4
00ADA:  MOVLB  2
....................     { 
....................         // return framing error 
....................         return ERR_DUSTMSG_FRAMING_ERROR; 
00ADC:  MOVLW  FE
00ADE:  MOVWF  01
00AE0:  BRA    0BF2
00AE2:  MOVLB  5
....................     } 
....................  
.................... // 2 Unstuff *payload* and CRC data into destination buffer 
....................     dest_ptr    = bytes_from_mote.dust_rcvd; 
00AE4:  CLRF   xA3
00AE6:  MOVLW  D5
00AE8:  MOVWF  xA2
....................     src_ptr_end = &dust_recive_buffer[bytes_to_decode-1]; 
00AEA:  MOVLW  01
00AEC:  SUBWF  x9B,W
00AEE:  CLRF   03
00AF0:  ADDLW  24
00AF2:  MOVWF  01
00AF4:  MOVLW  02
00AF6:  ADDWFC 03,F
00AF8:  MOVFF  01,5A0
00AFC:  MOVFF  03,5A1
....................     for (src_ptr = &dust_recive_buffer[1]; src_ptr < src_ptr_end; src_ptr++) 
00B00:  MOVLW  02
00B02:  MOVWF  x9F
00B04:  MOVLW  25
00B06:  MOVWF  x9E
00B08:  MOVF   x9F,W
00B0A:  SUBWF  xA1,W
00B0C:  BNC   0B7E
00B0E:  BNZ   0B16
00B10:  MOVF   xA0,W
00B12:  SUBWF  x9E,W
00B14:  BC    0B7E
....................     { 
....................         if (*src_ptr == CONTROL_ESCAPE) { 
00B16:  MOVFF  59F,03
00B1A:  MOVFF  59E,FE9
00B1E:  MOVFF  59F,FEA
00B22:  MOVF   FEF,W
00B24:  SUBLW  7D
00B26:  BNZ   0B54
....................            src_ptr++; /* skip to next byte, which contains the actual data */ 
00B28:  INCF   x9E,F
00B2A:  BTFSC  FD8.2
00B2C:  INCF   x9F,F
....................             *dest_ptr++ = *src_ptr ^ XOR_BYTE; 
00B2E:  MOVFF  5A3,5A6
00B32:  MOVF   xA2,W
00B34:  INCF   xA2,F
00B36:  BTFSC  FD8.2
00B38:  INCF   xA3,F
00B3A:  MOVWF  xA5
00B3C:  MOVFF  59E,FE9
00B40:  MOVFF  59F,FEA
00B44:  MOVF   FEF,W
00B46:  XORLW  20
00B48:  MOVFF  5A6,FEA
00B4C:  MOVFF  5A5,FE9
00B50:  MOVWF  FEF
....................         } 
00B52:  BRA    0B76
....................         else 
....................         { 
....................             *dest_ptr++ = *src_ptr; 
00B54:  MOVFF  5A3,5A6
00B58:  MOVF   xA2,W
00B5A:  INCF   xA2,F
00B5C:  BTFSC  FD8.2
00B5E:  INCF   xA3,F
00B60:  MOVFF  59E,FE9
00B64:  MOVFF  59F,FEA
00B68:  MOVFF  FEF,5A7
00B6C:  MOVFF  5A6,FEA
00B70:  MOVWF  FE9
00B72:  MOVFF  5A7,FEF
....................         } 
00B76:  INCF   x9E,F
00B78:  BTFSC  FD8.2
00B7A:  INCF   x9F,F
00B7C:  BRA    0B08
....................     } 
....................  
.................... // 3 Assemble CRC 
....................     dest_ptr--;                 /* now points to MSBs */ 
00B7E:  MOVF   xA2,W
00B80:  BTFSC  FD8.2
00B82:  DECF   xA3,F
00B84:  DECF   xA2,F
....................     crc16 = *dest_ptr-- << 8; 
00B86:  MOVFF  5A3,03
00B8A:  MOVF   xA2,W
00B8C:  BTFSC  FD8.2
00B8E:  DECF   xA3,F
00B90:  DECF   xA2,F
00B92:  MOVWF  FE9
00B94:  MOVFF  03,FEA
00B98:  MOVFF  FEF,59D
00B9C:  CLRF   x9C
....................     crc16 += *dest_ptr;         /* add LSBs */ 
00B9E:  MOVFF  5A2,FE9
00BA2:  MOVFF  5A3,FEA
00BA6:  MOVF   FEF,W
00BA8:  ADDWF  x9C,F
00BAA:  MOVLW  00
00BAC:  ADDWFC x9D,F
....................  
....................     /* Fill in the number of bytes actually written */ 
....................    dust_bytes_rcvd = (uint8_t)(dest_ptr - bytes_from_mote.dust_rcvd); 
00BAE:  MOVLW  D5
00BB0:  SUBWF  xA2,W
00BB2:  MOVWF  00
00BB4:  MOVLW  00
00BB6:  SUBWFB xA3,W
00BB8:  MOVFF  00,5A4
....................  
.................... // 4 Return error if CRCs don't match       
....................     if (fcs_calc_ISR(bytes_from_mote.dust_rcvd, dust_bytes_rcvd) != crc16 )  
00BBC:  CLRF   xA6
00BBE:  MOVLW  D5
00BC0:  MOVWF  xA5
00BC2:  CLRF   xA8
00BC4:  MOVFF  5A4,5A7
00BC8:  MOVLB  0
00BCA:  BRA    0A56
00BCC:  MOVFF  02,5A6
00BD0:  MOVFF  01,5A5
00BD4:  MOVLB  5
00BD6:  MOVF   x9C,W
00BD8:  SUBWF  01,W
00BDA:  BNZ   0BE2
00BDC:  MOVF   x9D,W
00BDE:  SUBWF  xA6,W
00BE0:  BZ    0BEC
....................     { 
....................        // indicate bad CRC 
....................        return ERR_DUSTMSG_CRC;       
00BE2:  MOVLW  FB
00BE4:  MOVWF  01
00BE6:  MOVLB  2
00BE8:  BRA    0BF2
00BEA:  MOVLB  5
....................     } 
....................    return dust_bytes_rcvd; 
00BEC:  MOVFF  5A4,01
00BF0:  MOVLB  2
00BF2:  MOVLB  0
00BF4:  GOTO   124E (RETURN)
.................... } 
....................  
.................... uint16_t fcs_fcs16(uint16_t fcs, uint8_t data) 
.................... { 
....................    return (fcs >> 8) ^ fcstab[(fcs ^ data) & 0xff]; 
*
00E74:  MOVFF  5A8,5AA
00E78:  MOVLB  5
00E7A:  CLRF   xAB
00E7C:  MOVF   xA7,W
00E7E:  XORWF  xA9,W
00E80:  MOVWF  xAC
00E82:  CLRF   xAD
00E84:  BCF    FD8.0
00E86:  RLCF   xAC,W
00E88:  MOVWF  02
00E8A:  RLCF   xAD,W
00E8C:  MOVWF  03
00E8E:  MOVF   02,W
00E90:  MOVFF  03,FF7
00E94:  MOVLB  0
00E96:  CALL   01AC
00E9A:  TBLRD*+
00E9C:  MOVFF  FF5,03
00EA0:  MOVLB  5
00EA2:  XORWF  xAA,W
00EA4:  MOVWF  00
00EA6:  MOVF   03,W
00EA8:  XORWF  xAB,W
00EAA:  MOVWF  03
00EAC:  MOVFF  00,01
00EB0:  MOVWF  02
00EB2:  MOVLB  0
00EB4:  RETURN 0
.................... } 
....................  
.................... uint16_t fcs_fcs16_ISR(uint16_t fcs, uint8_t data) 
.................... { 
....................    return (fcs >> 8) ^ fcstab[(fcs ^ data) & 0xff]; 
*
00A12:  MOVFF  5AD,5AF
00A16:  MOVLB  5
00A18:  CLRF   xB0
00A1A:  MOVF   xAC,W
00A1C:  XORWF  xAE,W
00A1E:  MOVWF  xB1
00A20:  CLRF   xB2
00A22:  BCF    FD8.0
00A24:  RLCF   xB1,W
00A26:  MOVWF  02
00A28:  RLCF   xB2,W
00A2A:  MOVWF  03
00A2C:  MOVF   02,W
00A2E:  MOVFF  03,FF7
00A32:  MOVLB  0
00A34:  CALL   01AC
00A38:  TBLRD*+
00A3A:  MOVFF  FF5,03
00A3E:  MOVLB  5
00A40:  XORWF  xAF,W
00A42:  MOVWF  00
00A44:  MOVF   03,W
00A46:  XORWF  xB0,W
00A48:  MOVWF  03
00A4A:  MOVFF  00,01
00A4E:  MOVWF  02
00A50:  MOVLB  0
00A52:  GOTO   0A88 (RETURN)
.................... } 
....................  
.................... static uint16_t fcs_calc(uint8_t* p, uint16_t size) 
.................... { 
.................... /* fcs_calc() 
....................  * 
....................  * Calculate the 2 byte CRC-16 value given a buffer. 
....................  * 
....................  * Returns: 
....................  *      2 byte CRC-16 value 
....................  */ 
....................     uint16_t    fcs = 0; 
....................     fcs = FCS_INITIAL_FCS16; 
....................     while (size) { 
....................         fcs = fcs_fcs16(fcs, *p++); 
....................         size--; 
....................     } 
....................     return ~fcs; /* add 1's complement */ 
.................... } 
....................  
.................... static uint16_t fcs_calc_ISR(uint8_t* p, uint16_t size) 
00A56:  MOVLB  5
00A58:  CLRF   xAA
00A5A:  CLRF   xA9
.................... { 
....................     uint16_t    fcs = 0; 
....................     fcs = FCS_INITIAL_FCS16; 
00A5C:  SETF   xAA
00A5E:  SETF   xA9
....................     while (size) { 
00A60:  MOVF   xA7,W
00A62:  IORWF  xA8,W
00A64:  BZ    0A9C
....................         fcs = fcs_fcs16_ISR(fcs, *p++); 
00A66:  MOVFF  5A6,03
00A6A:  MOVF   xA5,W
00A6C:  INCF   xA5,F
00A6E:  BTFSC  FD8.2
00A70:  INCF   xA6,F
00A72:  MOVWF  FE9
00A74:  MOVFF  03,FEA
00A78:  MOVFF  FEF,5AE
00A7C:  MOVFF  5AA,5AD
00A80:  MOVFF  5A9,5AC
00A84:  MOVLB  0
00A86:  BRA    0A12
00A88:  MOVFF  02,5AA
00A8C:  MOVFF  01,5A9
....................         size--; 
00A90:  MOVLB  5
00A92:  MOVF   xA7,W
00A94:  BTFSC  FD8.2
00A96:  DECF   xA8,F
00A98:  DECF   xA7,F
00A9A:  BRA    0A60
....................     } 
....................     return ~fcs; /* add 1's complement */ 
00A9C:  MOVFF  5AA,03
00AA0:  COMF   03,F
00AA2:  MOVF   xA9,W
00AA4:  XORLW  FF
00AA6:  MOVWF  01
00AA8:  MOVFF  03,02
00AAC:  MOVLB  0
00AAE:  GOTO   0BCC (RETURN)
.................... } 
....................  
.................... uint8_t deal_with_packet(void) 
.................... { 
....................    uint8_t  command_id_received; 
....................    uint16_t mgr_msgSEQ; 
....................    uint32_t temp_uint32; 
....................    // clear out for use as NACK bitfield each time 
....................    temp_uint32 = 0; 
*
0711E:  MOVLB  5
07120:  CLRF   x4D
07122:  CLRF   x4C
07124:  CLRF   x4B
07126:  CLRF   x4A
....................    static struct CommandQueueItem command_queue_item; 
....................    static struct SprinklerZoneSettingsItem sprinkler_zone_settings_item; 
....................    &command_queue_item.sprinkler_settings = &sprinkler_zone_settings_item; 
07128:  MOVLW  05
0712A:  MOVWF  x2D
0712C:  MOVLW  30
0712E:  MOVWF  x2C
....................     
....................    // This Dust-recommended prepend for messages (both from manager to mote and 
....................    //    from mote to manager) ensures that we do not conflict with any future 
....................    //    Hart-related aspects.  
....................     
....................    // This prepend is in the same spot for messages going either direction 
....................    // Return with an error if any char is incorrect 
....................    if ((payload_buff[0] != 0x00) || (payload_buff[1] != 0x00) ||              \ 
....................       (payload_buff[2] != 0xFC) || (payload_buff[3] != 0x12)) 
07130:  MOVLB  2
07132:  MOVF   xEF,F
07134:  BNZ   7146
07136:  MOVF   xF0,F
07138:  BNZ   7146
0713A:  MOVF   xF1,W
0713C:  SUBLW  FC
0713E:  BNZ   7146
07140:  MOVF   xF2,W
07142:  SUBLW  12
07144:  BZ    714E
....................    {    
....................       return ERR_BAD_PAYLOAD; 
07146:  MOVLW  F9
07148:  MOVWF  01
0714A:  GOTO   7FB2
....................    } 
....................     
....................    // The mgr_msgSEQ, a sequence number used by the manager software to identify 
....................    //    messages which are ACK'd or NACK'd always follows the prepend. 
....................    mgr_msgSEQ = make16(payload_buff[5],payload_buff[4]); 
0714E:  MOVFF  2F4,549
07152:  MOVFF  2F3,548
....................     
....................    // Then comes the msg_rcvd identifier which is the packet's intent, 
....................    //    such as 'give me a full report,' or 'do a warm start.' 
....................    // We leave payload_buff[6] alone so the command ID is identical for the  
....................    //    response message 
....................    command_id_received = payload_buff[6]; 
07156:  MOVFF  2F5,547
....................   
....................    // Switch for sorting through different messages recieved 
....................    switch (command_id_received) 
0715A:  MOVLW  01
0715C:  MOVLB  5
0715E:  SUBWF  x47,W
07160:  ADDLW  BA
07162:  BTFSC  FD8.0
07164:  GOTO   7FB0
07168:  ADDLW  46
0716A:  MOVLB  0
0716C:  GOTO   7FB8
....................    { 
....................    // Manager ACKs or NACKs unsolicited messages from micro to manager such as: 
....................    //    a. Message at startup 
....................    //    b. ERROR messages 
....................    //    c. Valve calibrate response 
....................    //    d. Bulk data dump 
....................     
.................... //////// Manager ACKs/NACKs//////// 
....................       // Manager ACKs 
....................       case MSG_MGR_ACK: 
....................          // clear off unsolicited message of proper msgSEQ 
....................          REMOVE_MESSAGE_QUEUE_MACRO(mgr_msgSEQ); 
07170:  BCF    F7A.1
07172:  MOVFF  549,54F
07176:  MOVFF  548,54E
0717A:  GOTO   5C42
0717E:  BSF    F7A.1
....................          break; 
07180:  MOVLB  5
07182:  GOTO   7FB0
....................                                                         
....................       // Manager NACKs    
....................       case MSG_MGR_NACK: 
....................          // Do nothing. Messages will get resent as if it never got acked by 
....................          //    manager 
....................          break;    
07186:  MOVLB  5
07188:  GOTO   7FB0
....................        
.................... //////// Report Requests//////// 
....................       // Manager requests a full report 
....................       case MSG_MGR_FULL_REPORT: 
....................          send_full_report(command_id_received, mgr_msgSEQ);   
0718C:  MOVFF  547,54E
07190:  MOVFF  549,550
07194:  MOVFF  548,54F
07198:  CALL   6212
....................          break; 
0719C:  MOVLB  5
0719E:  GOTO   7FB0
....................       // Manager requests a health report 
....................       case MSG_MGR_HEALTH_REPORT: 
....................          send_health_report(command_id_received, mgr_msgSEQ); 
071A2:  MOVFF  547,54E
071A6:  MOVFF  549,550
071AA:  MOVFF  548,54F
071AE:  GOTO   652C
....................          break; 
071B2:  MOVLB  5
071B4:  GOTO   7FB0
....................       // Manager requests a valve report 
....................       case MSG_MGR_VALVE_REPORT: 
....................          send_valve_report(command_id_received, mgr_msgSEQ); 
071B8:  MOVFF  547,54E
071BC:  MOVFF  549,550
071C0:  MOVFF  548,54F
071C4:  CALL   65B2
....................          break; 
071C8:  MOVLB  5
071CA:  GOTO   7FB0
....................        
.................... //////// Restart/Shutdown Commands////////                                            
....................       // Manager requests a warm restart (micro reboots) 
....................       case MSG_MGR_WARM_RESTART: 
....................          send_ack(command_id_received, mgr_msgSEQ); 
071CE:  MOVFF  547,54E
071D2:  MOVFF  549,550
071D6:  MOVFF  548,54F
071DA:  CALL   66E6
....................          // set the shutdown cause 
....................          global_shutdown_cause = WARM_RESTART_REQUEST; 
071DE:  MOVLW  09
071E0:  MOVWF  4D
....................          // save the shutdown/restart reason in EEPROM 
....................          write_ee1(EE_RESTART_CAUSE, global_shutdown_cause); 
071E2:  MOVLB  5
071E4:  CLRF   x51
071E6:  MOVLW  02
071E8:  MOVWF  x50
071EA:  MOVFF  4D,552
071EE:  MOVLB  0
071F0:  CALL   3288
....................          // restart micro                                                         
....................          PUSH_TIME_QUEUE_MACRO(global_rtc_time + 5, CPU_RESET);  
071F4:  BCF    F7A.1
071F6:  MOVLW  05
071F8:  ADDWF  x85,W
071FA:  MOVLB  5
071FC:  MOVWF  x4E
071FE:  MOVLW  00
07200:  MOVLB  0
07202:  ADDWFC x86,W
07204:  MOVLB  5
07206:  MOVWF  x4F
07208:  MOVLW  00
0720A:  MOVLB  0
0720C:  ADDWFC x87,W
0720E:  MOVLB  5
07210:  MOVWF  x50
07212:  MOVLW  00
07214:  MOVLB  0
07216:  ADDWFC x88,W
07218:  MOVLB  5
0721A:  MOVWF  x51
0721C:  MOVWF  x55
0721E:  MOVFF  550,554
07222:  MOVFF  54F,553
07226:  MOVFF  54E,552
0722A:  MOVLW  F0
0722C:  MOVWF  x56
0722E:  MOVLB  0
07230:  CALL   4290
07234:  BSF    F7A.1
....................          break;  
07236:  MOVLB  5
07238:  GOTO   7FB0
....................       // Manager requests a cold restart (mote and micro reboot)   
....................       case MSG_MGR_COLD_RESTART: 
....................          send_ack(command_id_received, mgr_msgSEQ); 
0723C:  MOVFF  547,54E
07240:  MOVFF  549,550
07244:  MOVFF  548,54F
07248:  CALL   66E6
....................          // set the shutdown cause 
....................          global_shutdown_cause = COLD_RESTART_REQUEST; 
0724C:  MOVLW  0A
0724E:  MOVWF  4D
....................          // save the shutdown/restart reason in EEPROM 
....................          write_ee1(EE_RESTART_CAUSE, global_shutdown_cause); 
07250:  MOVLB  5
07252:  CLRF   x51
07254:  MOVLW  02
07256:  MOVWF  x50
07258:  MOVFF  4D,552
0725C:  MOVLB  0
0725E:  CALL   3288
....................          // restart micro 
....................          PUSH_TIME_QUEUE_MACRO(global_rtc_time + 5, CPU_RESET); 
07262:  BCF    F7A.1
07264:  MOVLW  05
07266:  ADDWF  x85,W
07268:  MOVLB  5
0726A:  MOVWF  x4E
0726C:  MOVLW  00
0726E:  MOVLB  0
07270:  ADDWFC x86,W
07272:  MOVLB  5
07274:  MOVWF  x4F
07276:  MOVLW  00
07278:  MOVLB  0
0727A:  ADDWFC x87,W
0727C:  MOVLB  5
0727E:  MOVWF  x50
07280:  MOVLW  00
07282:  MOVLB  0
07284:  ADDWFC x88,W
07286:  MOVLB  5
07288:  MOVWF  x51
0728A:  MOVWF  x55
0728C:  MOVFF  550,554
07290:  MOVFF  54F,553
07294:  MOVFF  54E,552
07298:  MOVLW  F0
0729A:  MOVWF  x56
0729C:  MOVLB  0
0729E:  CALL   4290
072A2:  BSF    F7A.1
....................          break; 
072A4:  MOVLB  5
072A6:  GOTO   7FB0
....................       // Manager requests a rejoin (restart mote and rejoin)  
....................       case MSG_MGR_FORCE_REJOIN: 
....................          send_ack(command_id_received, mgr_msgSEQ); 
072AA:  MOVFF  547,54E
072AE:  MOVFF  549,550
072B2:  MOVFF  548,54F
072B6:  CALL   66E6
....................          // schedule rejoin/restart mote 
....................          PUSH_TIME_QUEUE_MACRO(global_rtc_time + 5, RESET_MOTE); 
072BA:  BCF    F7A.1
072BC:  MOVLW  05
072BE:  ADDWF  x85,W
072C0:  MOVLB  5
072C2:  MOVWF  x4E
072C4:  MOVLW  00
072C6:  MOVLB  0
072C8:  ADDWFC x86,W
072CA:  MOVLB  5
072CC:  MOVWF  x4F
072CE:  MOVLW  00
072D0:  MOVLB  0
072D2:  ADDWFC x87,W
072D4:  MOVLB  5
072D6:  MOVWF  x50
072D8:  MOVLW  00
072DA:  MOVLB  0
072DC:  ADDWFC x88,W
072DE:  MOVLB  5
072E0:  MOVWF  x51
072E2:  MOVWF  x55
072E4:  MOVFF  550,554
072E8:  MOVFF  54F,553
072EC:  MOVFF  54E,552
072F0:  MOVLW  11
072F2:  MOVWF  x56
072F4:  MOVLB  0
072F6:  CALL   4290
072FA:  BSF    F7A.1
....................          break; 
072FC:  MOVLB  5
072FE:  GOTO   7FB0
....................       // Manager requests a shutdown (deep sleep, move valve to specified position 
....................       //    and at a certain time) 
....................       case MSG_MGR_SHUTDOWN: 
....................          send_ack(command_id_received, mgr_msgSEQ); 
07302:  MOVFF  547,54E
07306:  MOVFF  549,550
0730A:  MOVFF  548,54F
0730E:  CALL   66E6
....................          // set valve posisition and move valve 
....................          global_valve_position_set_value = make16(payload_buff[12], payload_buff[11]); 
07312:  MOVFF  2FB,C0
07316:  MOVFF  2FA,BF
....................          PUSH_PRIORITY_QUEUE_MACRO(MOVE_VALVE); 
0731A:  BCF    F7A.1
0731C:  MOVLW  40
0731E:  MOVLB  5
07320:  MOVWF  x4E
07322:  MOVLB  0
07324:  CALL   4538
07328:  BSF    F7A.1
....................          // set the shutdown cause 
....................          global_shutdown_cause = MANAGER_SHUTDOWN_REQUEST; 
0732A:  MOVLW  0B
0732C:  MOVWF  4D
....................          // figure out the shutdown time in rtc time (given in utc time or 0 for NOW) 
....................          // temp_uint32 is now the utc shutdown time 
....................          temp_uint32 = make32(payload_buff[10], payload_buff[9],payload_buff[8], payload_buff[7]); 
0732E:  MOVFF  2F9,54D
07332:  MOVFF  2F8,54C
07336:  MOVFF  2F7,54B
0733A:  MOVFF  2F6,54A
....................           
....................          // if shutdown isn't now (time = 0), utc_shutdown_time + rtc_time - utc_time = rtc_shutdown_time 
....................          if (temp_uint32 != 0) 
0733E:  MOVLB  5
07340:  MOVF   x4A,F
07342:  BNZ   7350
07344:  MOVF   x4B,F
07346:  BNZ   7350
07348:  MOVF   x4C,F
0734A:  BNZ   7350
0734C:  MOVF   x4D,F
0734E:  BZ    73BE
....................          { 
....................             temp_uint32 += global_rtc_time - global_utc_time; 
07350:  MOVLB  0
07352:  MOVF   x89,W
07354:  SUBWF  x85,W
07356:  MOVWF  00
07358:  MOVF   x8A,W
0735A:  SUBWFB x86,W
0735C:  MOVWF  01
0735E:  MOVF   x8B,W
07360:  SUBWFB x87,W
07362:  MOVWF  02
07364:  MOVF   x8C,W
07366:  SUBWFB x88,W
07368:  MOVWF  03
0736A:  MOVF   00,W
0736C:  MOVLB  5
0736E:  ADDWF  x4A,F
07370:  MOVF   01,W
07372:  ADDWFC x4B,F
07374:  MOVF   02,W
07376:  ADDWFC x4C,F
07378:  MOVF   03,W
0737A:  ADDWFC x4D,F
....................             // in some rare cases, this simple math might give a huge number (more than an hour past current rtc 
....................             //    time.) In that case, time should be now. 
....................             // The rare case would be when there is latency in the network more than the  
....................             //    elapsed rtc time. 
....................             if (temp_uint32 > (global_rtc_time + 3600)) 
0737C:  MOVLW  10
0737E:  MOVLB  0
07380:  ADDWF  x85,W
07382:  MOVWF  00
07384:  MOVLW  0E
07386:  ADDWFC x86,W
07388:  MOVWF  01
0738A:  MOVLW  00
0738C:  ADDWFC x87,W
0738E:  MOVWF  02
07390:  MOVLW  00
07392:  ADDWFC x88,W
07394:  MOVWF  03
07396:  MOVLB  5
07398:  SUBWF  x4D,W
0739A:  BNC   73BC
0739C:  BNZ   73B4
0739E:  MOVF   02,W
073A0:  SUBWF  x4C,W
073A2:  BNC   73BC
073A4:  BNZ   73B4
073A6:  MOVF   01,W
073A8:  SUBWF  x4B,W
073AA:  BNC   73BC
073AC:  BNZ   73B4
073AE:  MOVF   x4A,W
073B0:  SUBWF  00,W
073B2:  BC    73BC
....................             {  
....................                temp_uint32 = 0; 
073B4:  CLRF   x4D
073B6:  CLRF   x4C
073B8:  CLRF   x4B
073BA:  CLRF   x4A
....................             } 
....................          } 
073BC:  BRA    73CE
....................          // shutdown time is now (sent time is 0) 
....................          else 
....................          { 
....................             temp_uint32 = global_rtc_time; 
073BE:  MOVFF  88,54D
073C2:  MOVFF  87,54C
073C6:  MOVFF  86,54B
073CA:  MOVFF  85,54A
....................          }                                   
....................          // schedule the shutdown 
....................          PUSH_TIME_QUEUE_MACRO(temp_uint32, SHUTDOWN_SYSTEM); 
073CE:  BCF    F7A.1
073D0:  MOVFF  54D,555
073D4:  MOVFF  54C,554
073D8:  MOVFF  54B,553
073DC:  MOVFF  54A,552
073E0:  MOVLW  F1
073E2:  MOVWF  x56
073E4:  MOVLB  0
073E6:  CALL   4290
073EA:  BSF    F7A.1
....................          break; 
073EC:  MOVLB  5
073EE:  GOTO   7FB0
....................  
.................... //////// Erraneous Commands//////// 
....................       case MSG_MGR_UPDATE_SP_NUM: 
....................          // update sprinkler number 
....................          // check if number is in a valid range, NACK if no good. 
....................          global_sprinkler_num = make16(payload_buff[8], payload_buff[7]); 
073F2:  MOVFF  2F7,92
073F6:  MOVFF  2F6,91
....................          // write sprinkler number 
....................          write_ee2(EE_SPRINKLER_NUM, global_sprinkler_num); 
073FA:  MOVLB  5
073FC:  CLRF   x53
073FE:  CLRF   x52
07400:  MOVFF  92,555
07404:  MOVFF  91,554
07408:  MOVLB  0
0740A:  CALL   31EC
....................          send_update_sp_num_response(command_id_received, mgr_msgSEQ); 
0740E:  MOVFF  547,54E
07412:  MOVFF  549,550
07416:  MOVFF  548,54F
0741A:  GOTO   670C
....................          break; 
0741E:  MOVLB  5
07420:  GOTO   7FB0
....................       case MSG_MGR_CAL_VALVE: 
....................          send_ack(command_id_received, mgr_msgSEQ);             
07424:  MOVFF  547,54E
07428:  MOVFF  549,550
0742C:  MOVFF  548,54F
07430:  CALL   66E6
....................          // schedule calibrate valve 
....................          PUSH_PRIORITY_QUEUE_MACRO(CALIBRATE_VALVE_1);    
07434:  BCF    F7A.1
07436:  MOVLW  31
07438:  MOVLB  5
0743A:  MOVWF  x4E
0743C:  MOVLB  0
0743E:  CALL   4538
07442:  BSF    F7A.1
....................          break; 
07444:  MOVLB  5
07446:  GOTO   7FB0
....................       case MSG_MGR_CAL_FSR:          
....................          if (read_system_state() != SYSTEM_RUN)    
0744A:  CALL   1DC6
0744E:  MOVF   01,W
07450:  SUBLW  02
07452:  BZ    745A
....................          {        
....................             temp_uint32 |= NACK_BITFIELD_INCOMPATIBLE_STATE; 
07454:  MOVLB  5
07456:  BSF    x4A.5
07458:  MOVLB  0
....................          }                                                     
....................          if (global_valve_position == VLV_POSITION_UNKNOWN) 
0745A:  INCFSZ xBD,W
0745C:  BRA    7468
0745E:  INCFSZ xBE,W
07460:  BRA    7468
....................          { 
....................             temp_uint32 |= NACK_BITFIELD_VLV_POSITION_UNKNOWN;     
07462:  MOVLB  5
07464:  BSF    x4A.0
07466:  MOVLB  0
....................          } 
....................          if (!is_valve_position_valid(make16(payload_buff[8], payload_buff[7])))    
07468:  MOVFF  2F7,54F
0746C:  MOVFF  2F6,54E
07470:  MOVFF  2F7,551
07474:  MOVFF  2F6,550
07478:  CALL   6740
0747C:  MOVF   01,F
0747E:  BNZ   7486
....................          {                                                                       
....................             temp_uint32 |= NACK_BITFIELD_INVALID_VLV_SETTING;                     
07480:  MOVLB  5
07482:  BSF    x4A.1
07484:  MOVLB  0
....................          } 
....................          // if the NACK bitfield contains anything, send the nack instead of proceeding 
....................          if (temp_uint32 != 0)          
07486:  MOVLB  5
07488:  MOVF   x4A,F
0748A:  BNZ   7498
0748C:  MOVF   x4B,F
0748E:  BNZ   7498
07490:  MOVF   x4C,F
07492:  BNZ   7498
07494:  MOVF   x4D,F
07496:  BZ    74BE
....................          { 
....................             send_nack(command_id_received, mgr_msgSEQ, temp_uint32); 
07498:  MOVFF  547,54E
0749C:  MOVFF  549,550
074A0:  MOVFF  548,54F
074A4:  MOVFF  54D,554
074A8:  MOVFF  54C,553
074AC:  MOVFF  54B,552
074B0:  MOVFF  54A,551
074B4:  MOVLB  0
074B6:  CALL   6762
....................          }                                             
074BA:  BRA    74E0
074BC:  MOVLB  5
....................          else                                              
....................          {                  
....................             send_ack(command_id_received, mgr_msgSEQ); 
074BE:  MOVFF  547,54E
074C2:  MOVFF  549,550
074C6:  MOVFF  548,54F
074CA:  MOVLB  0
074CC:  CALL   66E6
....................             // schedule calibrate valve                    
....................             PUSH_PRIORITY_QUEUE_MACRO(CALIBRATE_FSR_1);   
074D0:  BCF    F7A.1
074D2:  MOVLW  37
074D4:  MOVLB  5
074D6:  MOVWF  x4E
074D8:  MOVLB  0
074DA:  CALL   4538
074DE:  BSF    F7A.1
....................          } 
....................          break; 
074E0:  MOVLB  5
074E2:  GOTO   7FB0
....................           
....................       case MSG_MGR_AQUIRE_GPS:  
....................          send_ack(command_id_received, mgr_msgSEQ); 
074E6:  MOVFF  547,54E
074EA:  MOVFF  549,550
074EE:  MOVFF  548,54F
074F2:  CALL   66E6
....................          // start gps point aquisition                         
....................          PUSH_PRIORITY_QUEUE_MACRO(START_GPS_AQUISITION);               
074F6:  BCF    F7A.1
074F8:  MOVLW  50
074FA:  MOVLB  5
074FC:  MOVWF  x4E
074FE:  MOVLB  0
07500:  CALL   4538
07504:  BSF    F7A.1
....................          break; 
07506:  MOVLB  5
07508:  GOTO   7FB0
....................                                                                           
....................       case MSG_MGR_UPDATE_EEPROM:                                
....................          LCD_clear();                                                 
0750C:  CALL   5C08
....................          LCD_place_uint16(make16(payload_buff[8], payload_buff[7]),0,0,5);   
07510:  MOVFF  2F7,54F
07514:  MOVFF  2F6,54E
07518:  MOVFF  2F7,560
0751C:  MOVFF  2F6,55F
07520:  MOVLB  5
07522:  CLRF   x61
07524:  CLRF   x62
07526:  MOVLW  05
07528:  MOVWF  x63
0752A:  MOVLB  0
0752C:  CALL   6828
....................          LCD_place_uint8(payload_buff[9],0,7,3);          
07530:  MOVFF  2F8,560
07534:  MOVLB  5
07536:  CLRF   x61
07538:  MOVLW  07
0753A:  MOVWF  x62
0753C:  MOVLW  03
0753E:  MOVWF  x63
07540:  MOVLB  0
07542:  CALL   6902
....................          LCD_place_uint32(make32(payload_buff[13],payload_buff[12],payload_buff[11],payload_buff[10]),1,0,8); 
07546:  MOVFF  2FC,551
0754A:  MOVFF  2FB,550
0754E:  MOVFF  2FA,54F
07552:  MOVFF  2F9,54E
07556:  MOVFF  2FC,555
0755A:  MOVFF  2FB,554
0755E:  MOVFF  2FA,553
07562:  MOVFF  2F9,552
07566:  MOVLW  01
07568:  MOVLB  5
0756A:  MOVWF  x56
0756C:  CLRF   x57
0756E:  MOVLW  08
07570:  MOVWF  x58
07572:  MOVLB  0
07574:  CALL   6996
....................          global_skip_lcd_update_count = 3;         
07578:  MOVLW  03
0757A:  MOVWF  x83
....................                                                                                                  
....................          // if eeprom location is outside of the valid range                                      
....................          //    (not in between start and end location (taking into account the number of bytes))    
....................          if ((make16(payload_buff[8], payload_buff[7]) < EE_START_LOCATION) ||                        \                      
....................             ((make16(payload_buff[8], payload_buff[7]) + payload_buff[9] - 1) > EE_END_LOCATION) ||   \                                                
....................             // also check if number of bytes != 1, 2, or 4 
....................             (!((payload_buff[9] == 1) || (payload_buff[9] == 2) || (payload_buff[9] == 4))))        
0757C:  MOVFF  2F7,54F
07580:  MOVFF  2F6,54E
07584:  MOVLB  2
07586:  MOVF   xF8,W
07588:  MOVLB  5
0758A:  ADDWF  x4E,F
0758C:  MOVLW  00
0758E:  ADDWFC x4F,F
07590:  MOVLW  01
07592:  SUBWF  x4E,F
07594:  MOVLW  00
07596:  SUBWFB x4F,F
07598:  BNZ   75B6
0759A:  MOVF   x4E,W
0759C:  SUBLW  2F
0759E:  BNC   75B6
075A0:  MOVLB  2
075A2:  DECFSZ xF8,W
075A4:  BRA    75A8
075A6:  BRA    75D6
075A8:  MOVF   xF8,W
075AA:  SUBLW  02
075AC:  BZ    75D6
075AE:  MOVF   xF8,W
075B0:  SUBLW  04
075B2:  BZ    75D6
075B4:  MOVLB  5
....................          {                                                                                         
....................             send_nack(command_id_received, mgr_msgSEQ, NACK_BITFIELD_INVALID_EEPROM_SETTINGS);     
075B6:  MOVFF  547,54E
075BA:  MOVFF  549,550
075BE:  MOVFF  548,54F
075C2:  CLRF   x54
075C4:  CLRF   x53
075C6:  MOVLW  01
075C8:  MOVWF  x52
075CA:  CLRF   x51
075CC:  MOVLB  0
075CE:  CALL   6762
....................          }                                                                                            
075D2:  BRA    7678
075D4:  MOVLB  2
....................          // valid location and number of bytes                      
....................          else                                    
....................          {                                                                                                 
....................             if (payload_buff[9] == 1) 
075D6:  DECFSZ xF8,W
075D8:  BRA    75F8
....................             { 
....................                write_ee1(make16(payload_buff[8], payload_buff[7]),payload_buff[10]); 
075DA:  MOVFF  2F7,54F
075DE:  MOVFF  2F6,54E
075E2:  MOVFF  2F7,551
075E6:  MOVFF  2F6,550
075EA:  MOVFF  2F9,552
075EE:  MOVLB  0
075F0:  CALL   3288
....................             } 
075F4:  BRA    7664
075F6:  MOVLB  2
....................             else if (payload_buff[9] == 2)                
075F8:  MOVF   xF8,W
075FA:  SUBLW  02
075FC:  BNZ   7628
....................             {                                           
....................                write_ee2(make16(payload_buff[8], payload_buff[7]),make16(payload_buff[11],payload_buff[10])); 
075FE:  MOVFF  2F7,54F
07602:  MOVFF  2F6,54E
07606:  MOVFF  2FA,551
0760A:  MOVFF  2F9,550
0760E:  MOVFF  2F7,553
07612:  MOVFF  2F6,552
07616:  MOVFF  2FA,555
0761A:  MOVFF  2F9,554
0761E:  MOVLB  0
07620:  CALL   31EC
....................             } 
07624:  BRA    7664
07626:  MOVLB  2
....................             else if (payload_buff[9] == 4)                                            
07628:  MOVF   xF8,W
0762A:  SUBLW  04
0762C:  BNZ   7666
....................             { 
....................                write_ee4(make16(payload_buff[8], payload_buff[7]),make32(payload_buff[13],payload_buff[12],payload_buff[11],payload_buff[10])); 
0762E:  MOVFF  2F7,54F
07632:  MOVFF  2F6,54E
07636:  MOVFF  2FC,553
0763A:  MOVFF  2FB,552
0763E:  MOVFF  2FA,551
07642:  MOVFF  2F9,550
07646:  MOVFF  2F7,555
0764A:  MOVFF  2F6,554
0764E:  MOVFF  2FC,559
07652:  MOVFF  2FB,558
07656:  MOVFF  2FA,557
0765A:  MOVFF  2F9,556
0765E:  MOVLB  0
07660:  CALL   6AB6
07664:  MOVLB  2
....................             } 
....................             send_ack(command_id_received, mgr_msgSEQ); 
07666:  MOVFF  547,54E
0766A:  MOVFF  549,550
0766E:  MOVFF  548,54F
07672:  MOVLB  0
07674:  CALL   66E6
....................          } 
....................          break;  
07678:  MOVLB  5
0767A:  GOTO   7FB0
....................        
....................       case MSG_MGR_READ_EEPROM:                                                                              
....................          // if eeprom location is outside of the valid range                                      
....................          //    (not in between start and end location (taking into account the number of bytes))    
....................          if ((make16(payload_buff[8], payload_buff[7]) < EE_START_LOCATION) ||                        \                      
....................             ((make16(payload_buff[8], payload_buff[7]) + payload_buff[9] - 1) > EE_END_LOCATION) ||   \                                                
....................             // also check if number of bytes != 1, 2, or 4 
....................             (!((payload_buff[9] == 1) || (payload_buff[9] == 2) || (payload_buff[9] == 4))))        
0767E:  MOVFF  2F7,54F
07682:  MOVFF  2F6,54E
07686:  MOVLB  2
07688:  MOVF   xF8,W
0768A:  MOVLB  5
0768C:  ADDWF  x4E,F
0768E:  MOVLW  00
07690:  ADDWFC x4F,F
07692:  MOVLW  01
07694:  SUBWF  x4E,F
07696:  MOVLW  00
07698:  SUBWFB x4F,F
0769A:  BNZ   76B8
0769C:  MOVF   x4E,W
0769E:  SUBLW  2F
076A0:  BNC   76B8
076A2:  MOVLB  2
076A4:  DECFSZ xF8,W
076A6:  BRA    76AA
076A8:  BRA    76D8
076AA:  MOVF   xF8,W
076AC:  SUBLW  02
076AE:  BZ    76D8
076B0:  MOVF   xF8,W
076B2:  SUBLW  04
076B4:  BZ    76D8
076B6:  MOVLB  5
....................          {                                                                                         
....................             send_nack(command_id_received, mgr_msgSEQ, NACK_BITFIELD_INVALID_EEPROM_SETTINGS);     
076B8:  MOVFF  547,54E
076BC:  MOVFF  549,550
076C0:  MOVFF  548,54F
076C4:  CLRF   x54
076C6:  CLRF   x53
076C8:  MOVLW  01
076CA:  MOVWF  x52
076CC:  CLRF   x51
076CE:  MOVLB  0
076D0:  CALL   6762
....................          }                                                                                            
076D4:  BRA    7790
076D6:  MOVLB  2
....................          // valid location and number of bytes                      
....................          else                                    
....................          {                                                                                                 
....................             if (payload_buff[9] == 1) 
076D8:  DECFSZ xF8,W
076DA:  BRA    7702
....................             {                                 
....................                temp_uint32 = read_ee1(make16(payload_buff[8], payload_buff[7])); 
076DC:  MOVFF  2F7,54F
076E0:  MOVFF  2F6,54E
076E4:  MOVFF  2F7,551
076E8:  MOVFF  2F6,550
076EC:  MOVLB  0
076EE:  CALL   3266
076F2:  MOVLB  5
076F4:  CLRF   x4D
076F6:  CLRF   x4C
076F8:  CLRF   x4B
076FA:  MOVFF  01,54A
....................             } 
076FE:  BRA    775E
07700:  MOVLB  2
....................             else if (payload_buff[9] == 2)                
07702:  MOVF   xF8,W
07704:  SUBLW  02
07706:  BNZ   7730
....................             {                                           
....................                temp_uint32 = read_ee2(make16(payload_buff[8], payload_buff[7]));        
07708:  MOVFF  2F7,54F
0770C:  MOVFF  2F6,54E
07710:  MOVFF  2F7,551
07714:  MOVFF  2F6,550
07718:  MOVLB  0
0771A:  CALL   3196
0771E:  MOVLB  5
07720:  CLRF   x4D
07722:  CLRF   x4C
07724:  MOVFF  02,54B
07728:  MOVFF  01,54A
....................             } 
0772C:  BRA    775E
0772E:  MOVLB  2
....................             else if (payload_buff[9] == 4)                                            
07730:  MOVF   xF8,W
07732:  SUBLW  04
07734:  BNZ   775C
....................             { 
....................                temp_uint32 = read_ee4(make16(payload_buff[8], payload_buff[7])); 
07736:  MOVFF  2F7,54F
0773A:  MOVFF  2F6,54E
0773E:  MOVFF  2F7,551
07742:  MOVFF  2F6,550
07746:  MOVLB  0
07748:  CALL   32BA
0774C:  MOVFF  03,54D
07750:  MOVFF  02,54C
07754:  MOVFF  01,54B
07758:  MOVFF  00,54A
0775C:  MOVLB  5
....................             } 
....................             send_read_eeprom_response(command_id_received, mgr_msgSEQ, make16(payload_buff[8], payload_buff[7]), temp_uint32);   
0775E:  MOVFF  2F7,54F
07762:  MOVFF  2F6,54E
07766:  MOVFF  547,550
0776A:  MOVFF  549,552
0776E:  MOVFF  548,551
07772:  MOVFF  2F7,554
07776:  MOVFF  2F6,553
0777A:  MOVFF  54D,558
0777E:  MOVFF  54C,557
07782:  MOVFF  54B,556
07786:  MOVFF  54A,555
0778A:  MOVLB  0
0778C:  GOTO   6BBC
....................          } 
....................          break; 
07790:  MOVLB  5
07792:  GOTO   7FB0
....................        
....................       case MSG_MGR_READ_XDCR:                                                     
....................          // if the type1 (fancy expensive all-sensors xdcrs) are connected    
....................          if (global_xcdr_type1_enabled)                                      
07796:  BTFSS  xA3.2
07798:  BRA    77BC
....................          {                              
....................             // ack it (yes, because it takes ~50ms for the xdcr to settle, it must be an 
....................             //    unsolicited response that happens later) 
....................             send_ack(command_id_received, mgr_msgSEQ);       
0779A:  MOVFF  547,54E
0779E:  MOVFF  549,550
077A2:  MOVFF  548,54F
077A6:  CALL   66E6
....................             // schedule calibrate valve                               
....................             PUSH_PRIORITY_QUEUE_MACRO(TAKE_XCDR_MESUREMENT_1);   
077AA:  BCF    F7A.1
077AC:  MOVLW  55
077AE:  MOVLB  5
077B0:  MOVWF  x4E
077B2:  MOVLB  0
077B4:  CALL   4538
077B8:  BSF    F7A.1
....................          }                                       
077BA:  BRA    77E2
....................          // if a xdcr isn't connected, then nack it! 
....................          else                                
....................          {   
....................             temp_uint32 |= NACK_BITFIELD_INVALID_HARDWARE; 
077BC:  MOVLB  5
077BE:  BSF    x4A.7
....................             send_nack(command_id_received, mgr_msgSEQ, temp_uint32);   
077C0:  MOVFF  547,54E
077C4:  MOVFF  549,550
077C8:  MOVFF  548,54F
077CC:  MOVFF  54D,554
077D0:  MOVFF  54C,553
077D4:  MOVFF  54B,552
077D8:  MOVFF  54A,551
077DC:  MOVLB  0
077DE:  CALL   6762
....................          }        
....................          break;                                          
077E2:  MOVLB  5
077E4:  GOTO   7FB0
....................                                                                      
....................           
.................... //////// Run/Test/Demo Commands////////         
....................       case MSG_MGR_RUN_CMD_NO_MOD: 
....................              
....................          if (global_valve_position == VLV_POSITION_UNKNOWN) 
077E8:  INCFSZ xBD,W
077EA:  BRA    77F6
077EC:  INCFSZ xBE,W
077EE:  BRA    77F6
....................          { 
....................             temp_uint32 |= NACK_BITFIELD_VLV_POSITION_UNKNOWN; 
077F0:  MOVLB  5
077F2:  BSF    x4A.0
077F4:  MOVLB  0
....................          } 
....................          if (!is_valve_position_valid(make16(payload_buff[16], payload_buff[15]))) 
077F6:  MOVFF  2FF,54F
077FA:  MOVFF  2FE,54E
077FE:  MOVFF  2FF,551
07802:  MOVFF  2FE,550
07806:  CALL   6740
0780A:  MOVF   01,F
0780C:  BNZ   7814
....................          { 
....................             temp_uint32 |= NACK_BITFIELD_INVALID_VLV_SETTING; 
0780E:  MOVLB  5
07810:  BSF    x4A.1
07812:  MOVLB  0
....................          } 
....................          if (!is_rpm_setting_valid(make16(payload_buff[18], payload_buff[17]))) 
07814:  MOVFF  301,54F
07818:  MOVFF  300,54E
0781C:  MOVFF  301,551
07820:  MOVFF  300,550
07824:  CALL   6C16
07828:  MOVF   01,F
0782A:  BNZ   7832
....................          { 
....................             temp_uint32 |= NACK_BITFIELD_INVALID_RPM_SETTING; 
0782C:  MOVLB  5
0782E:  BSF    x4A.2
07830:  MOVLB  0
....................          } 
....................   
....................          // if the NACK bitfield contains anything, send the nack instead of proceeding 
....................          if (temp_uint32 != 0) 
07832:  MOVLB  5
07834:  MOVF   x4A,F
07836:  BNZ   7844
07838:  MOVF   x4B,F
0783A:  BNZ   7844
0783C:  MOVF   x4C,F
0783E:  BNZ   7844
07840:  MOVF   x4D,F
07842:  BZ    786A
....................          { 
....................             send_nack(command_id_received, mgr_msgSEQ, temp_uint32);  
07844:  MOVFF  547,54E
07848:  MOVFF  549,550
0784C:  MOVFF  548,54F
07850:  MOVFF  54D,554
07854:  MOVFF  54C,553
07858:  MOVFF  54B,552
0785C:  MOVFF  54A,551
07860:  MOVLB  0
07862:  CALL   6762
....................          }      
07866:  BRA    78F4
07868:  MOVLB  5
....................          // add non-modulated run command to command queue  
....................          else 
....................          { 
....................             push_sprinkler_queue(make32(payload_buff[10],payload_buff[9],payload_buff[8],payload_buff[7]), \ 
....................                make32(payload_buff[14],payload_buff[13],payload_buff[12],payload_buff[11]), \ 
....................                make16(payload_buff[16], payload_buff[15]), make16(payload_buff[18], payload_buff[17]), \ 
....................                0, BRAKE_AND_CHARGE_START); 
0786A:  MOVFF  2F9,551
0786E:  MOVFF  2F8,550
07872:  MOVFF  2F7,54F
07876:  MOVFF  2F6,54E
0787A:  MOVFF  2FD,555
0787E:  MOVFF  2FC,554
07882:  MOVFF  2FB,553
07886:  MOVFF  2FA,552
0788A:  MOVFF  2FF,557
0788E:  MOVFF  2FE,556
07892:  MOVFF  301,559
07896:  MOVFF  300,558
0789A:  MOVFF  2F9,55D
0789E:  MOVFF  2F8,55C
078A2:  MOVFF  2F7,55B
078A6:  MOVFF  2F6,55A
078AA:  MOVFF  2FD,561
078AE:  MOVFF  2FC,560
078B2:  MOVFF  2FB,55F
078B6:  MOVFF  2FA,55E
078BA:  MOVFF  2FF,563
078BE:  MOVFF  2FE,562
078C2:  MOVFF  301,565
078C6:  MOVFF  300,564
078CA:  CLRF   x66
078CC:  CLRF   x67
078CE:  MOVLB  0
078D0:  CALL   6C44
....................              
....................             // have the micro check the battery to determine the proper charging 
....................             PUSH_PRIORITY_QUEUE_MACRO(CHECK_BATTERY_STATE);  
078D4:  BCF    F7A.1
078D6:  MOVLW  A1
078D8:  MOVLB  5
078DA:  MOVWF  x4E
078DC:  MOVLB  0
078DE:  CALL   4538
078E2:  BSF    F7A.1
....................             send_sprinkler_cmd_response(command_id_received, mgr_msgSEQ); 
078E4:  MOVFF  547,54E
078E8:  MOVFF  549,550
078EC:  MOVFF  548,54F
078F0:  GOTO   6E82
....................          } 
....................          break; 
078F4:  MOVLB  5
078F6:  BRA    7FB0
....................           
....................       case MSG_MGR_RUN_CMD_MOD: 
....................          // since this isn't implemented, nack it 
....................          temp_uint32 |= NACK_BITFIELD_INCOMPATIBLE_STATE;   
078F8:  MOVLB  5
078FA:  BSF    x4A.5
....................          send_nack(command_id_received, mgr_msgSEQ, temp_uint32); 
078FC:  MOVFF  547,54E
07900:  MOVFF  549,550
07904:  MOVFF  548,54F
07908:  MOVFF  54D,554
0790C:  MOVFF  54C,553
07910:  MOVFF  54B,552
07914:  MOVFF  54A,551
07918:  MOVLB  0
0791A:  CALL   6762
....................                               
....................          // add modulated run command to command queue 
....................          // send_sprinkler_cmd_response(command_id_received, mgr_msgSEQ); 
....................          break; 
0791E:  MOVLB  5
07920:  BRA    7FB0
....................                                                    
....................       case MSG_MGR_TEST_NO_RPM_CTRL:    
....................              
....................          // this test added by JG 
....................          if (!is_valve_value_full_open_or_close(make16(payload_buff[8], payload_buff[7]))) 
07922:  MOVFF  2F7,54F
07926:  MOVFF  2F6,54E
0792A:  MOVFF  2F7,551
0792E:  MOVFF  2F6,550
07932:  CALL   7098
07936:  MOVF   01,F
07938:  BNZ   7948
....................          { 
....................             if (global_valve_position == VLV_POSITION_UNKNOWN)   
0793A:  INCFSZ xBD,W
0793C:  BRA    7948
0793E:  INCFSZ xBE,W
07940:  BRA    7948
....................             {                                                     
....................                temp_uint32 |= NACK_BITFIELD_VLV_POSITION_UNKNOWN;  
07942:  MOVLB  5
07944:  BSF    x4A.0
07946:  MOVLB  0
....................             }                             
....................          }              
....................          if (!is_valve_position_valid(make16(payload_buff[8], payload_buff[7]))) 
07948:  MOVFF  2F7,54F
0794C:  MOVFF  2F6,54E
07950:  MOVFF  2F7,551
07954:  MOVFF  2F6,550
07958:  CALL   6740
0795C:  MOVF   01,F
0795E:  BNZ   7966
....................          { 
....................             temp_uint32 |= NACK_BITFIELD_INVALID_VLV_SETTING; 
07960:  MOVLB  5
07962:  BSF    x4A.1
07964:  MOVLB  0
....................          }  
....................          if (!is_brake_duty_valid(make16(payload_buff[10], payload_buff[9]))) 
07966:  MOVFF  2F9,54F
0796A:  MOVFF  2F8,54E
0796E:  MOVFF  2F9,551
07972:  MOVFF  2F8,550
07976:  GOTO   70BC
0797A:  MOVF   01,F
0797C:  BNZ   7984
....................          { 
....................             temp_uint32 |= NACK_BITFIELD_INVALID_BRAKE_SETTING; 
0797E:  MOVLB  5
07980:  BSF    x4A.3
07982:  MOVLB  0
....................          } 
....................          if (!is_charge_duty_valid(make16(payload_buff[12], payload_buff[11]))) 
07984:  MOVFF  2FB,54F
07988:  MOVFF  2FA,54E
0798C:  MOVFF  2FB,551
07990:  MOVFF  2FA,550
07994:  GOTO   70E0
07998:  MOVF   01,F
0799A:  BNZ   79A2
....................          { 
....................             temp_uint32 |= NACK_BITFIELD_INVALID_CHARGE_SETTING; 
0799C:  MOVLB  5
0799E:  BSF    x4A.4
079A0:  MOVLB  0
....................          } 
....................          // if in mppc non-dynamic mode, check mppc 
....................          if ((payload_buff[14] == FALSE) && (!is_mppc_valid(payload_buff[13]))) 
079A2:  MOVLB  2
079A4:  MOVF   xFD,F
079A6:  BNZ   79C2
079A8:  MOVFF  2FC,54E
079AC:  MOVLB  0
079AE:  GOTO   7104
079B2:  MOVF   01,F
079B4:  BTFSC  FD8.2
079B6:  BRA    79BC
079B8:  MOVLB  2
079BA:  BRA    79C2
....................          { 
....................             temp_uint32 |= NACK_BITFIELD_INVALID_MPPC_SETTING; 
079BC:  MOVLB  5
079BE:  BSF    x4B.1
079C0:  MOVLB  2
....................          } 
....................           
....................          // if the NACK bitfield contains anything, send the nack instead of proceeding 
....................          if (temp_uint32 != 0) 
079C2:  MOVLB  5
079C4:  MOVF   x4A,F
079C6:  BNZ   79D4
079C8:  MOVF   x4B,F
079CA:  BNZ   79D4
079CC:  MOVF   x4C,F
079CE:  BNZ   79D4
079D0:  MOVF   x4D,F
079D2:  BZ    79FA
....................          { 
....................             send_nack(command_id_received, mgr_msgSEQ, temp_uint32); 
079D4:  MOVFF  547,54E
079D8:  MOVFF  549,550
079DC:  MOVFF  548,54F
079E0:  MOVFF  54D,554
079E4:  MOVFF  54C,553
079E8:  MOVFF  54B,552
079EC:  MOVFF  54A,551
079F0:  MOVLB  0
079F2:  CALL   6762
....................          } 
079F6:  BRA    7B1C
079F8:  MOVLB  5
....................          // add non-modulated run command to command queue  
....................          else 
....................          { 
....................                                                  
....................             // deal with JG-added special cases of commands to fully open or 
....................             //  or fully close the valve in cases whete the valve has not 
....................             //  yet been calibrated 
....................             if ((make16(payload_buff[8], payload_buff[7]) == VLV_POSITION_OPENED) \ 
....................                && (global_valve_position == VLV_POSITION_UNKNOWN)) 
079FA:  MOVFF  2F7,54F
079FE:  MOVFF  2F6,54E
07A02:  MOVF   x4E,F
07A04:  BNZ   7A36
07A06:  MOVF   x4F,W
07A08:  SUBLW  80
07A0A:  BNZ   7A36
07A0C:  MOVLB  0
07A0E:  INCFSZ xBD,W
07A10:  BRA    7A14
07A12:  BRA    7A18
07A14:  MOVLB  5
07A16:  BRA    7A36
07A18:  INCFSZ xBE,W
07A1A:  BRA    7A1E
07A1C:  BRA    7A22
07A1E:  MOVLB  5
07A20:  BRA    7A36
....................             { 
....................                PUSH_PRIORITY_QUEUE_MACRO(OPEN_VALVE_UNKNOWN_STATE); 
07A22:  BCF    F7A.1
07A24:  MOVLW  3E
07A26:  MOVLB  5
07A28:  MOVWF  x4E
07A2A:  MOVLB  0
07A2C:  CALL   4538
07A30:  BSF    F7A.1
....................             } 
07A32:  BRA    7A7E
07A34:  MOVLB  5
....................              
....................             else if ((make16(payload_buff[8], payload_buff[7]) == VLV_POSITION_CLOSED) \ 
....................                && (global_valve_position == VLV_POSITION_UNKNOWN)) 
07A36:  MOVFF  2F7,54F
07A3A:  MOVFF  2F6,54E
07A3E:  MOVF   x4E,F
07A40:  BNZ   7A70
07A42:  MOVF   x4F,F
07A44:  BNZ   7A70
07A46:  MOVLB  0
07A48:  INCFSZ xBD,W
07A4A:  BRA    7A4E
07A4C:  BRA    7A52
07A4E:  MOVLB  5
07A50:  BRA    7A70
07A52:  INCFSZ xBE,W
07A54:  BRA    7A58
07A56:  BRA    7A5C
07A58:  MOVLB  5
07A5A:  BRA    7A70
....................             { 
....................                PUSH_PRIORITY_QUEUE_MACRO(CLOSE_VALVE_UNKNOWN_STATE); 
07A5C:  BCF    F7A.1
07A5E:  MOVLW  3F
07A60:  MOVLB  5
07A62:  MOVWF  x4E
07A64:  MOVLB  0
07A66:  CALL   4538
07A6A:  BSF    F7A.1
....................             } 
07A6C:  BRA    7A7E
07A6E:  MOVLB  5
....................               
....................             else 
....................             { 
....................                PUSH_PRIORITY_QUEUE_MACRO(MOVE_VALVE); 
07A70:  BCF    F7A.1
07A72:  MOVLW  40
07A74:  MOVWF  x4E
07A76:  MOVLB  0
07A78:  CALL   4538
07A7C:  BSF    F7A.1
....................             }                                        
....................                         
....................             global_brake_duty_set_value = (make16(payload_buff[10], payload_buff[9])); 
07A7E:  MOVFF  2F9,B3
07A82:  MOVFF  2F8,B2
....................             global_charge_duty_set_value = (make16(payload_buff[12], payload_buff[11])); 
07A86:  MOVFF  2FB,B5
07A8A:  MOVFF  2FA,B4
....................                                 
....................             // clear queue 
....................             clear_sprinkler_queue();  
07A8E:  CALL   53A0
....................              
....................             if (payload_buff[14] == FALSE)                                               
07A92:  MOVLB  2
07A94:  MOVF   xFD,F
07A96:  BNZ   7AD2
....................             { 
....................                // set test parameters with no rpm control and preset mppc value    
....................                push_sprinkler_queue(0, 0-1,make16(payload_buff[8], payload_buff[7]), 0, \ 
....................                0, NO_RPM_CONTROL);      
07A98:  MOVFF  2F7,54F
07A9C:  MOVFF  2F6,54E
07AA0:  MOVLB  5
07AA2:  CLRF   x5D
07AA4:  CLRF   x5C
07AA6:  CLRF   x5B
07AA8:  CLRF   x5A
07AAA:  SETF   x61
07AAC:  SETF   x60
07AAE:  SETF   x5F
07AB0:  SETF   x5E
07AB2:  MOVFF  2F7,563
07AB6:  MOVFF  2F6,562
07ABA:  CLRF   x65
07ABC:  CLRF   x64
07ABE:  CLRF   x66
07AC0:  MOVLW  05
07AC2:  MOVWF  x67
07AC4:  MOVLB  0
07AC6:  CALL   6C44
....................                global_mppc_set_value = payload_buff[13];  
07ACA:  MOVFF  2FC,B7
....................             } 
07ACE:  BRA    7B08
07AD0:  MOVLB  2
....................             else if (payload_buff[14] == TRUE)         
07AD2:  DECFSZ xFD,W
07AD4:  BRA    7B0A
....................             { 
....................                // set test parameters with no rpm control and dynamic mppc 
....................                push_sprinkler_queue(0, 0-1,make16(payload_buff[8], payload_buff[7]), 0, \ 
....................                0, NO_RPM_CONTROL_DYN_MPPC); 
07AD6:  MOVFF  2F7,54F
07ADA:  MOVFF  2F6,54E
07ADE:  MOVLB  5
07AE0:  CLRF   x5D
07AE2:  CLRF   x5C
07AE4:  CLRF   x5B
07AE6:  CLRF   x5A
07AE8:  SETF   x61
07AEA:  SETF   x60
07AEC:  SETF   x5F
07AEE:  SETF   x5E
07AF0:  MOVFF  2F7,563
07AF4:  MOVFF  2F6,562
07AF8:  CLRF   x65
07AFA:  CLRF   x64
07AFC:  CLRF   x66
07AFE:  MOVLW  06
07B00:  MOVWF  x67
07B02:  MOVLB  0
07B04:  CALL   6C44
07B08:  MOVLB  2
....................             } 
....................             send_full_report(command_id_received, mgr_msgSEQ); 
07B0A:  MOVFF  547,54E
07B0E:  MOVFF  549,550
07B12:  MOVFF  548,54F
07B16:  MOVLB  0
07B18:  CALL   6212
....................          } 
....................          break; 
07B1C:  MOVLB  5
07B1E:  BRA    7FB0
....................           
....................       case MSG_MGR_TEST_RPM_CTRL: 
....................        
....................          // this test added by JG 
....................          if (!is_valve_value_full_open_or_close(make16(payload_buff[8], payload_buff[7]))) 
07B20:  MOVFF  2F7,54F
07B24:  MOVFF  2F6,54E
07B28:  MOVFF  2F7,551
07B2C:  MOVFF  2F6,550
07B30:  CALL   7098
07B34:  MOVF   01,F
07B36:  BNZ   7B46
....................          { 
....................             if (global_valve_position == VLV_POSITION_UNKNOWN) 
07B38:  INCFSZ xBD,W
07B3A:  BRA    7B46
07B3C:  INCFSZ xBE,W
07B3E:  BRA    7B46
....................             { 
....................                temp_uint32 |= NACK_BITFIELD_VLV_POSITION_UNKNOWN; 
07B40:  MOVLB  5
07B42:  BSF    x4A.0
07B44:  MOVLB  0
....................             } 
....................          } 
....................          if (!is_valve_position_valid(make16(payload_buff[8], payload_buff[7]))) 
07B46:  MOVFF  2F7,54F
07B4A:  MOVFF  2F6,54E
07B4E:  MOVFF  2F7,551
07B52:  MOVFF  2F6,550
07B56:  CALL   6740
07B5A:  MOVF   01,F
07B5C:  BNZ   7B64
....................          { 
....................             temp_uint32 |= NACK_BITFIELD_INVALID_VLV_SETTING; 
07B5E:  MOVLB  5
07B60:  BSF    x4A.1
07B62:  MOVLB  0
....................          } 
....................          if (!is_rpm_setting_valid(make16(payload_buff[10], payload_buff[9]))) 
07B64:  MOVFF  2F9,54F
07B68:  MOVFF  2F8,54E
07B6C:  MOVFF  2F9,551
07B70:  MOVFF  2F8,550
07B74:  CALL   6C16
07B78:  MOVF   01,F
07B7A:  BNZ   7B82
....................          {                                
....................             temp_uint32 |= NACK_BITFIELD_INVALID_RPM_SETTING; 
07B7C:  MOVLB  5
07B7E:  BSF    x4A.2
07B80:  MOVLB  0
....................          } 
....................           
....................          // if the NACK bitfield contains anything, send the nack instead of proceeding 
....................          if (temp_uint32 != 0) 
07B82:  MOVLB  5
07B84:  MOVF   x4A,F
07B86:  BNZ   7B94
07B88:  MOVF   x4B,F
07B8A:  BNZ   7B94
07B8C:  MOVF   x4C,F
07B8E:  BNZ   7B94
07B90:  MOVF   x4D,F
07B92:  BZ    7BBA
....................          { 
....................             send_nack(command_id_received, mgr_msgSEQ, temp_uint32); 
07B94:  MOVFF  547,54E
07B98:  MOVFF  549,550
07B9C:  MOVFF  548,54F
07BA0:  MOVFF  54D,554
07BA4:  MOVFF  54C,553
07BA8:  MOVFF  54B,552
07BAC:  MOVFF  54A,551
07BB0:  MOVLB  0
07BB2:  CALL   6762
....................          } 
07BB6:  BRA    7CDA
07BB8:  MOVLB  5
....................          // add non-modulated run command to command queue  
....................          else 
....................          {  
....................             // clear queue  
....................             clear_sprinkler_queue(); 
07BBA:  MOVLB  0
07BBC:  CALL   53A0
....................              
....................             // set test parameters with rpm control 
....................             // JG: Add test of extra byte to address whether or not to 
....................             //  be have charging as part of the control loop 
....................             if (payload_buff[11] == 0xFF) 
07BC0:  MOVLB  2
07BC2:  INCFSZ xFA,W
07BC4:  BRA    7C06
....................             { 
....................                push_sprinkler_queue(0, 0-1,make16(payload_buff[8], payload_buff[7]), \ 
....................                   make16(payload_buff[10], payload_buff[9]), 0, BRAKE_AND_CHARGE_START); 
07BC6:  MOVFF  2F7,54F
07BCA:  MOVFF  2F6,54E
07BCE:  MOVFF  2F9,551
07BD2:  MOVFF  2F8,550
07BD6:  MOVLB  5
07BD8:  CLRF   x5D
07BDA:  CLRF   x5C
07BDC:  CLRF   x5B
07BDE:  CLRF   x5A
07BE0:  SETF   x61
07BE2:  SETF   x60
07BE4:  SETF   x5F
07BE6:  SETF   x5E
07BE8:  MOVFF  2F7,563
07BEC:  MOVFF  2F6,562
07BF0:  MOVFF  2F9,565
07BF4:  MOVFF  2F8,564
07BF8:  CLRF   x66
07BFA:  CLRF   x67
07BFC:  MOVLB  0
07BFE:  CALL   6C44
....................             } 
07C02:  BRA    7C44
07C04:  MOVLB  2
....................             else 
....................             { 
....................                push_sprinkler_queue(0, 0-1,make16(payload_buff[8], payload_buff[7]), \ 
....................                   make16(payload_buff[10], payload_buff[9]), 0, BRAKE_ONLY); 
07C06:  MOVFF  2F7,54F
07C0A:  MOVFF  2F6,54E
07C0E:  MOVFF  2F9,551
07C12:  MOVFF  2F8,550
07C16:  MOVLB  5
07C18:  CLRF   x5D
07C1A:  CLRF   x5C
07C1C:  CLRF   x5B
07C1E:  CLRF   x5A
07C20:  SETF   x61
07C22:  SETF   x60
07C24:  SETF   x5F
07C26:  SETF   x5E
07C28:  MOVFF  2F7,563
07C2C:  MOVFF  2F6,562
07C30:  MOVFF  2F9,565
07C34:  MOVFF  2F8,564
07C38:  CLRF   x66
07C3A:  MOVLW  02
07C3C:  MOVWF  x67
07C3E:  MOVLB  0
07C40:  CALL   6C44
....................             } 
....................                 
....................             // deal with JG-added special cases of commands to fully open or 
....................             //  or fully close the valve in cases whete the valve has not 
....................             //  yet been calibrated 
....................             if ((make16(payload_buff[8], payload_buff[7]) == VLV_POSITION_OPENED) \ 
....................                && (global_valve_position == VLV_POSITION_UNKNOWN)) 
07C44:  MOVFF  2F7,54F
07C48:  MOVFF  2F6,54E
07C4C:  MOVLB  5
07C4E:  MOVF   x4E,F
07C50:  BNZ   7C82
07C52:  MOVF   x4F,W
07C54:  SUBLW  80
07C56:  BNZ   7C82
07C58:  MOVLB  0
07C5A:  INCFSZ xBD,W
07C5C:  BRA    7C60
07C5E:  BRA    7C64
07C60:  MOVLB  5
07C62:  BRA    7C82
07C64:  INCFSZ xBE,W
07C66:  BRA    7C6A
07C68:  BRA    7C6E
07C6A:  MOVLB  5
07C6C:  BRA    7C82
....................             { 
....................                PUSH_PRIORITY_QUEUE_MACRO(OPEN_VALVE_UNKNOWN_STATE); 
07C6E:  BCF    F7A.1
07C70:  MOVLW  3E
07C72:  MOVLB  5
07C74:  MOVWF  x4E
07C76:  MOVLB  0
07C78:  CALL   4538
07C7C:  BSF    F7A.1
....................             } 
07C7E:  BRA    7CCA
07C80:  MOVLB  5
....................              
....................             else if ((make16(payload_buff[8], payload_buff[7]) == VLV_POSITION_CLOSED) \ 
....................                && (global_valve_position == VLV_POSITION_UNKNOWN)) 
07C82:  MOVFF  2F7,54F
07C86:  MOVFF  2F6,54E
07C8A:  MOVF   x4E,F
07C8C:  BNZ   7CBC
07C8E:  MOVF   x4F,F
07C90:  BNZ   7CBC
07C92:  MOVLB  0
07C94:  INCFSZ xBD,W
07C96:  BRA    7C9A
07C98:  BRA    7C9E
07C9A:  MOVLB  5
07C9C:  BRA    7CBC
07C9E:  INCFSZ xBE,W
07CA0:  BRA    7CA4
07CA2:  BRA    7CA8
07CA4:  MOVLB  5
07CA6:  BRA    7CBC
....................             { 
....................                PUSH_PRIORITY_QUEUE_MACRO(CLOSE_VALVE_UNKNOWN_STATE); 
07CA8:  BCF    F7A.1
07CAA:  MOVLW  3F
07CAC:  MOVLB  5
07CAE:  MOVWF  x4E
07CB0:  MOVLB  0
07CB2:  CALL   4538
07CB6:  BSF    F7A.1
....................             }                                      
07CB8:  BRA    7CCA
07CBA:  MOVLB  5
....................              
....................             else 
....................             { 
....................                PUSH_PRIORITY_QUEUE_MACRO(MOVE_VALVE);   
07CBC:  BCF    F7A.1
07CBE:  MOVLW  40
07CC0:  MOVWF  x4E
07CC2:  MOVLB  0
07CC4:  CALL   4538
07CC8:  BSF    F7A.1
....................             } 
....................             send_full_report(command_id_received, mgr_msgSEQ);    
07CCA:  MOVFF  547,54E
07CCE:  MOVFF  549,550
07CD2:  MOVFF  548,54F
07CD6:  CALL   6212
....................          } 
....................          break;  
07CDA:  MOVLB  5
07CDC:  BRA    7FB0
....................           
....................       case MSG_MGR_DEMO: 
....................          if (global_valve_position == VLV_POSITION_UNKNOWN) 
07CDE:  INCFSZ xBD,W
07CE0:  BRA    7CEC
07CE2:  INCFSZ xBE,W
07CE4:  BRA    7CEC
....................          { 
....................             temp_uint32 |= NACK_BITFIELD_VLV_POSITION_UNKNOWN; 
07CE6:  MOVLB  5
07CE8:  BSF    x4A.0
07CEA:  MOVLB  0
....................          }      
....................          // if the NACK bitfield contains anything, send the nack instead of proceeding 
....................          if (temp_uint32 != 0) 
07CEC:  MOVLB  5
07CEE:  MOVF   x4A,F
07CF0:  BNZ   7CFE
07CF2:  MOVF   x4B,F
07CF4:  BNZ   7CFE
07CF6:  MOVF   x4C,F
07CF8:  BNZ   7CFE
07CFA:  MOVF   x4D,F
07CFC:  BZ    7D24
....................          { 
....................             send_nack(command_id_received, mgr_msgSEQ, temp_uint32); 
07CFE:  MOVFF  547,54E
07D02:  MOVFF  549,550
07D06:  MOVFF  548,54F
07D0A:  MOVFF  54D,554
07D0E:  MOVFF  54C,553
07D12:  MOVFF  54B,552
07D16:  MOVFF  54A,551
07D1A:  MOVLB  0
07D1C:  CALL   6762
....................          }         
07D20:  BRA    7EE6
07D22:  MOVLB  5
....................          else 
....................          { 
....................             clear_sprinkler_queue(); 
07D24:  MOVLB  0
07D26:  CALL   53A0
....................             push_sprinkler_queue(global_utc_time, global_utc_time + 30, 0x4000, 100, 0, BRAKE_AND_CHARGE_START); 
07D2A:  MOVLW  1E
07D2C:  ADDWF  x89,W
07D2E:  MOVLB  5
07D30:  MOVWF  x4E
07D32:  MOVLW  00
07D34:  MOVLB  0
07D36:  ADDWFC x8A,W
07D38:  MOVLB  5
07D3A:  MOVWF  x4F
07D3C:  MOVLW  00
07D3E:  MOVLB  0
07D40:  ADDWFC x8B,W
07D42:  MOVLB  5
07D44:  MOVWF  x50
07D46:  MOVLW  00
07D48:  MOVLB  0
07D4A:  ADDWFC x8C,W
07D4C:  MOVLB  5
07D4E:  MOVWF  x51
07D50:  MOVFF  8C,55D
07D54:  MOVFF  8B,55C
07D58:  MOVFF  8A,55B
07D5C:  MOVFF  89,55A
07D60:  MOVWF  x61
07D62:  MOVFF  550,560
07D66:  MOVFF  54F,55F
07D6A:  MOVFF  54E,55E
07D6E:  MOVLW  40
07D70:  MOVWF  x63
07D72:  CLRF   x62
07D74:  CLRF   x65
07D76:  MOVLW  64
07D78:  MOVWF  x64
07D7A:  CLRF   x66
07D7C:  CLRF   x67
07D7E:  MOVLB  0
07D80:  CALL   6C44
....................             push_sprinkler_queue(global_utc_time + 30, global_utc_time + 60, 0x4000, 50, 0, BRAKE_AND_CHARGE_START); 
07D84:  MOVLW  1E
07D86:  ADDWF  x89,W
07D88:  MOVLB  5
07D8A:  MOVWF  x4E
07D8C:  MOVLW  00
07D8E:  MOVLB  0
07D90:  ADDWFC x8A,W
07D92:  MOVLB  5
07D94:  MOVWF  x4F
07D96:  MOVLW  00
07D98:  MOVLB  0
07D9A:  ADDWFC x8B,W
07D9C:  MOVLB  5
07D9E:  MOVWF  x50
07DA0:  MOVLW  00
07DA2:  MOVLB  0
07DA4:  ADDWFC x8C,W
07DA6:  MOVLB  5
07DA8:  MOVWF  x51
07DAA:  MOVLW  3C
07DAC:  MOVLB  0
07DAE:  ADDWF  x89,W
07DB0:  MOVLB  5
07DB2:  MOVWF  x52
07DB4:  MOVLW  00
07DB6:  MOVLB  0
07DB8:  ADDWFC x8A,W
07DBA:  MOVLB  5
07DBC:  MOVWF  x53
07DBE:  MOVLW  00
07DC0:  MOVLB  0
07DC2:  ADDWFC x8B,W
07DC4:  MOVLB  5
07DC6:  MOVWF  x54
07DC8:  MOVLW  00
07DCA:  MOVLB  0
07DCC:  ADDWFC x8C,W
07DCE:  MOVLB  5
07DD0:  MOVWF  x55
07DD2:  MOVFF  551,55D
07DD6:  MOVFF  550,55C
07DDA:  MOVFF  54F,55B
07DDE:  MOVFF  54E,55A
07DE2:  MOVWF  x61
07DE4:  MOVFF  554,560
07DE8:  MOVFF  553,55F
07DEC:  MOVFF  552,55E
07DF0:  MOVLW  40
07DF2:  MOVWF  x63
07DF4:  CLRF   x62
07DF6:  CLRF   x65
07DF8:  MOVLW  32
07DFA:  MOVWF  x64
07DFC:  CLRF   x66
07DFE:  CLRF   x67
07E00:  MOVLB  0
07E02:  CALL   6C44
....................             push_sprinkler_queue(global_utc_time + 60, global_utc_time + 90, 0x4000, 10, 0, BRAKE_AND_CHARGE_START); 
07E06:  MOVLW  3C
07E08:  ADDWF  x89,W
07E0A:  MOVLB  5
07E0C:  MOVWF  x4E
07E0E:  MOVLW  00
07E10:  MOVLB  0
07E12:  ADDWFC x8A,W
07E14:  MOVLB  5
07E16:  MOVWF  x4F
07E18:  MOVLW  00
07E1A:  MOVLB  0
07E1C:  ADDWFC x8B,W
07E1E:  MOVLB  5
07E20:  MOVWF  x50
07E22:  MOVLW  00
07E24:  MOVLB  0
07E26:  ADDWFC x8C,W
07E28:  MOVLB  5
07E2A:  MOVWF  x51
07E2C:  MOVLW  5A
07E2E:  MOVLB  0
07E30:  ADDWF  x89,W
07E32:  MOVLB  5
07E34:  MOVWF  x52
07E36:  MOVLW  00
07E38:  MOVLB  0
07E3A:  ADDWFC x8A,W
07E3C:  MOVLB  5
07E3E:  MOVWF  x53
07E40:  MOVLW  00
07E42:  MOVLB  0
07E44:  ADDWFC x8B,W
07E46:  MOVLB  5
07E48:  MOVWF  x54
07E4A:  MOVLW  00
07E4C:  MOVLB  0
07E4E:  ADDWFC x8C,W
07E50:  MOVLB  5
07E52:  MOVWF  x55
07E54:  MOVFF  551,55D
07E58:  MOVFF  550,55C
07E5C:  MOVFF  54F,55B
07E60:  MOVFF  54E,55A
07E64:  MOVWF  x61
07E66:  MOVFF  554,560
07E6A:  MOVFF  553,55F
07E6E:  MOVFF  552,55E
07E72:  MOVLW  40
07E74:  MOVWF  x63
07E76:  CLRF   x62
07E78:  CLRF   x65
07E7A:  MOVLW  0A
07E7C:  MOVWF  x64
07E7E:  CLRF   x66
07E80:  CLRF   x67
07E82:  MOVLB  0
07E84:  CALL   6C44
....................             push_sprinkler_queue(global_utc_time + 90, 0-1, VLV_POSITION_CLOSED, 0, 0, BRAKE_AND_CHARGE_START); 
07E88:  MOVLW  5A
07E8A:  ADDWF  x89,W
07E8C:  MOVLB  5
07E8E:  MOVWF  x4E
07E90:  MOVLW  00
07E92:  MOVLB  0
07E94:  ADDWFC x8A,W
07E96:  MOVLB  5
07E98:  MOVWF  x4F
07E9A:  MOVLW  00
07E9C:  MOVLB  0
07E9E:  ADDWFC x8B,W
07EA0:  MOVLB  5
07EA2:  MOVWF  x50
07EA4:  MOVLW  00
07EA6:  MOVLB  0
07EA8:  ADDWFC x8C,W
07EAA:  MOVLB  5
07EAC:  MOVWF  x51
07EAE:  MOVWF  x5D
07EB0:  MOVFF  550,55C
07EB4:  MOVFF  54F,55B
07EB8:  MOVFF  54E,55A
07EBC:  SETF   x61
07EBE:  SETF   x60
07EC0:  SETF   x5F
07EC2:  SETF   x5E
07EC4:  CLRF   x63
07EC6:  CLRF   x62
07EC8:  CLRF   x65
07ECA:  CLRF   x64
07ECC:  CLRF   x66
07ECE:  CLRF   x67
07ED0:  MOVLB  0
07ED2:  CALL   6C44
....................             send_ack(command_id_received, mgr_msgSEQ); 
07ED6:  MOVFF  547,54E
07EDA:  MOVFF  549,550
07EDE:  MOVFF  548,54F
07EE2:  CALL   66E6
....................             // add demo mode stuff to commmand queue 
....................          }                                 
....................       case MSG_MGR_CLEAR_SPINKLER_CMD_QUEUE: 
....................          clear_sprinkler_queue(); 
07EE6:  CALL   53A0
....................          send_full_report(command_id_received, mgr_msgSEQ); 
07EEA:  MOVFF  547,54E
07EEE:  MOVFF  549,550
07EF2:  MOVFF  548,54F
07EF6:  CALL   6212
....................          break;  
07EFA:  MOVLB  5
07EFC:  BRA    7FB0
....................        
....................       // To force the valve to move and change nothing else  
....................       //    (retrieve current settings for brake, charge, etc. 
....................       //    Will force the valve to go fully open/closed if uncalibrated (position unknown)    
....................       case MSG_MGR_FORCE_VALVE_MOVEMENT:               
....................          // if the valve position is unknown and we're trying to send it full open or full closed,  
....................          //    set the valve position to the precalibration (the middle) and proceed as the valve 
....................          //    will recalibrate its position 
....................          if ((global_valve_position == VLV_POSITION_UNKNOWN) &&                                       \ 
....................             (is_valve_value_full_open_or_close(make16(payload_buff[8], payload_buff[7]))))   
07EFE:  INCFSZ xBD,W
07F00:  BRA    7F26
07F02:  INCFSZ xBE,W
07F04:  BRA    7F26
07F06:  MOVFF  2F7,54F
07F0A:  MOVFF  2F6,54E
07F0E:  MOVFF  2F7,551
07F12:  MOVFF  2F6,550
07F16:  CALL   7098
07F1A:  MOVF   01,F
07F1C:  BZ    7F26
....................          {                            
....................             global_valve_position = VLV_PRECALIBRAION_POSITION;  
07F1E:  MOVLW  40
07F20:  MOVWF  xBE
07F22:  CLRF   xBD
....................          }       
07F24:  BRA    7F4C
....................           
....................          // if the valve position is unknown and we're trying to send it to a specific position, NACK it    
....................          else if ((global_valve_position == VLV_POSITION_UNKNOWN) &&                                  \ 
....................             (!is_valve_value_full_open_or_close(make16(payload_buff[8], payload_buff[7]))))  
07F26:  INCFSZ xBD,W
07F28:  BRA    7F4C
07F2A:  INCFSZ xBE,W
07F2C:  BRA    7F4C
07F2E:  MOVFF  2F7,54F
07F32:  MOVFF  2F6,54E
07F36:  MOVFF  2F7,551
07F3A:  MOVFF  2F6,550
07F3E:  CALL   7098
07F42:  MOVF   01,F
07F44:  BNZ   7F4C
....................          { 
....................             temp_uint32 |= NACK_BITFIELD_VLV_POSITION_UNKNOWN; 
07F46:  MOVLB  5
07F48:  BSF    x4A.0
07F4A:  MOVLB  0
....................          }           
....................           
....................          // if the NACK bitfield contains anything, send the nack instead of proceeding 
....................          if (temp_uint32 != 0)                                      
07F4C:  MOVLB  5
07F4E:  MOVF   x4A,F
07F50:  BNZ   7F5E
07F52:  MOVF   x4B,F
07F54:  BNZ   7F5E
07F56:  MOVF   x4C,F
07F58:  BNZ   7F5E
07F5A:  MOVF   x4D,F
07F5C:  BZ    7F84
....................          { 
....................             send_nack(command_id_received, mgr_msgSEQ, temp_uint32); 
07F5E:  MOVFF  547,54E
07F62:  MOVFF  549,550
07F66:  MOVFF  548,54F
07F6A:  MOVFF  54D,554
07F6E:  MOVFF  54C,553
07F72:  MOVFF  54B,552
07F76:  MOVFF  54A,551
07F7A:  MOVLB  0
07F7C:  CALL   6762
....................          }    
07F80:  BRA    7FAA
07F82:  MOVLB  5
....................          // otherwise, set the valve position, send a move valve command to the queue, and send a report 
....................          else  
....................          {     
....................             global_valve_position_set_value = make16(payload_buff[8], payload_buff[7]); 
07F84:  MOVFF  2F7,C0
07F88:  MOVFF  2F6,BF
....................             PUSH_PRIORITY_QUEUE_MACRO(MOVE_VALVE);   
07F8C:  BCF    F7A.1
07F8E:  MOVLW  40
07F90:  MOVWF  x4E
07F92:  MOVLB  0
07F94:  CALL   4538
07F98:  BSF    F7A.1
....................             send_valve_report(command_id_received, mgr_msgSEQ); 
07F9A:  MOVFF  547,54E
07F9E:  MOVFF  549,550
07FA2:  MOVFF  548,54F
07FA6:  CALL   65B2
....................          } 
....................          break;     
07FAA:  MOVLB  5
07FAC:  BRA    7FB0
07FAE:  MOVLB  5
07FB0:  MOVLB  2
....................    }        
07FB2:  MOVLB  0
07FB4:  GOTO   A3DC (RETURN)
.................... }  // deal_with_packet 
....................  
....................  
.................... void prepare_prefix_and_payload(uint8_t payload_buf_length) 
.................... { 
....................       // Setup send_prefix 
....................       send_prefix[0] = CMD_SEND; 
*
05DA0:  MOVLW  05
05DA2:  MOVLB  3
05DA4:  MOVWF  x4F
....................       // set the size part of the prefix to payload length + 9 other bytes 
....................       send_prefix[1] = payload_buf_length + 9; 
05DA6:  MOVLW  09
05DA8:  MOVLB  5
05DAA:  ADDWF  x59,W
05DAC:  MOVLB  3
05DAE:  MOVWF  x50
....................       send_prefix[2] = FLAG_SEND_REQUEST; 
05DB0:  MOVLW  04
05DB2:  MOVWF  x51
....................       send_prefix[3] = DESTADDR_HI; 
05DB4:  MOVLW  F9
05DB6:  MOVWF  x52
....................       send_prefix[4] = DESTADDR_LO; 
05DB8:  MOVLW  81
05DBA:  MOVWF  x53
....................       // setup the ???? 
....................       send_prefix[5] = svc_index_rcvd; 
05DBC:  MOVFF  360,354
....................       send_prefix[6] = APPDOMAIN_MAINTENANCE; 
05DC0:  MOVLW  02
05DC2:  MOVWF  x55
....................       send_prefix[7] = PRIORITY_HI; 
05DC4:  MOVWF  x56
....................       send_prefix[8] = 0; 
05DC6:  CLRF   x57
....................       send_prefix[9] = 0; 
05DC8:  CLRF   x58
....................       send_prefix[10] = 0xFF; 
05DCA:  SETF   x59
....................       send_prefix[11] = payload_buf_length; 
05DCC:  MOVFF  559,35A
....................       payload_buff[0] = 0x00; 
05DD0:  MOVLB  2
05DD2:  CLRF   xEF
....................       payload_buff[1] = 0x00; 
05DD4:  CLRF   xF0
....................       payload_buff[2] = 0xFC; 
05DD6:  MOVLW  FC
05DD8:  MOVWF  xF1
....................       payload_buff[3] = 0x12;  
05DDA:  MOVLW  12
05DDC:  MOVWF  xF2
05DDE:  MOVLB  0
05DE0:  RETURN 0
.................... } 
.................... void prepare_prefix_and_payload_ISR(uint8_t payload_buf_length) 
.................... { 
....................       // Setup send_prefix 
....................       send_prefix[0] = CMD_SEND; 
*
0224C:  MOVLW  05
0224E:  MOVLB  3
02250:  MOVWF  x4F
....................       // set the size part of the prefix to payload length + 9 other bytes 
....................       send_prefix[1] = payload_buf_length + 9; 
02252:  MOVLW  09
02254:  MOVLB  5
02256:  ADDWF  x8F,W
02258:  MOVLB  3
0225A:  MOVWF  x50
....................       send_prefix[2] = FLAG_SEND_REQUEST; 
0225C:  MOVLW  04
0225E:  MOVWF  x51
....................       send_prefix[3] = DESTADDR_HI; 
02260:  MOVLW  F9
02262:  MOVWF  x52
....................       send_prefix[4] = DESTADDR_LO; 
02264:  MOVLW  81
02266:  MOVWF  x53
....................       // setup the ???? 
....................       send_prefix[5] = svc_index_rcvd; 
02268:  MOVFF  360,354
....................       send_prefix[6] = APPDOMAIN_MAINTENANCE; 
0226C:  MOVLW  02
0226E:  MOVWF  x55
....................       send_prefix[7] = PRIORITY_HI;                                                                       
02270:  MOVWF  x56
....................       send_prefix[8] = 0; 
02272:  CLRF   x57
....................       send_prefix[9] = 0; 
02274:  CLRF   x58
....................       send_prefix[10] = 0xFF; 
02276:  SETF   x59
....................       send_prefix[11] = payload_buf_length; 
02278:  MOVFF  58F,35A
....................       payload_buff[0] = 0x00; 
0227C:  MOVLB  2
0227E:  CLRF   xEF
....................       payload_buff[1] = 0x00; 
02280:  CLRF   xF0
....................       payload_buff[2] = 0xFC;                           
02282:  MOVLW  FC
02284:  MOVWF  xF1
....................       payload_buff[3] = 0x12;  
02286:  MOVLW  12
02288:  MOVWF  xF2
0228A:  MOVLB  0
0228C:  RETURN 0
.................... } 
.................... void generate_message_and_send() 
.................... { 
....................    uint8_t n, res_byte; 
....................    // generate the message 
....................    dust_hdlc_pkgen(send_prefix, 12, payload_buff, send_prefix[11]); 
*
061B8:  MOVLW  03
061BA:  MOVLB  5
061BC:  MOVWF  x62
061BE:  MOVLW  4F
061C0:  MOVWF  x61
061C2:  MOVLW  0C
061C4:  MOVWF  x63
061C6:  MOVLW  02
061C8:  MOVWF  x65
061CA:  MOVLW  EF
061CC:  MOVWF  x64
061CE:  MOVFF  35A,566
061D2:  MOVLB  0
061D4:  RCALL  5E58
....................     
....................    // try to send the message a 3 times 
....................    for (n = 0; n < 3; n++) 
061D6:  MOVLB  5
061D8:  CLRF   x59
061DA:  MOVF   x59,W
061DC:  SUBLW  02
061DE:  BNC   620E
....................    { 
....................       // try to send the message 
....................       res_byte = dust_hdlc_pksend();    
061E0:  MOVLB  0
061E2:  RCALL  6102
061E4:  MOVFF  01,55A
....................       // timeout of 50ms if pksend returns an error 
....................       setup_T0_int(T0_50MS); 
061E8:  MOVLB  5
061EA:  SETF   x65
061EC:  MOVLW  3D
061EE:  MOVWF  x64
061F0:  MOVLB  0
061F2:  CALL   36B2
....................       // if the message doesn't return no error, try sending again 
....................       while ((res_byte != NO_ERR) && !TMR0IF);        
061F6:  MOVLB  5
061F8:  MOVF   x5A,F
061FA:  BZ    6200
061FC:  BTFSS  FF2.2
061FE:  BRA    61F8
....................       if (TMR0IF) 
06200:  BTFSS  FF2.2
06202:  BRA    6208
....................          continue; 
06204:  BRA    620A
06206:  BRA    620A
....................       else 
....................          break; 
06208:  BRA    620E
0620A:  INCF   x59,F
0620C:  BRA    61DA
....................    } 
0620E:  MOVLB  0
06210:  RETURN 0
.................... } 
.................... void generate_message_and_send_ISR() 
.................... { 
....................    uint8_t n, res_byte; 
....................    // generate the message 
....................    dust_hdlc_pkgen_ISR(send_prefix, 12, payload_buff, send_prefix[11]); 
*
022E8:  MOVLW  03
022EA:  MOVLB  5
022EC:  MOVWF  x9C
022EE:  MOVLW  4F
022F0:  MOVWF  x9B
022F2:  MOVLW  0C
022F4:  MOVWF  x9D
022F6:  MOVLW  02
022F8:  MOVWF  x9F
022FA:  MOVLW  EF
022FC:  MOVWF  x9E
022FE:  MOVFF  35A,5A0
02302:  MOVLB  0
02304:  CALL   0EB6
....................                                     
....................    // try to send the message a 3 times 
....................    for (n = 0; n < 3; n++) 
02308:  MOVLB  5
0230A:  CLRF   x8F
0230C:  MOVF   x8F,W
0230E:  SUBLW  02
02310:  BNC   2340
....................    { 
....................       // try to send the message 
....................       res_byte = dust_hdlc_pksend_ISR();    
02312:  MOVLB  0
02314:  CALL   1178
02318:  MOVFF  01,590
....................       // timeout of 50ms if pksend returns an error 
....................       setup_T4_int(T4_50MS);  
0231C:  MOVLW  C7
0231E:  MOVLB  5
02320:  MOVWF  xA0
02322:  MOVLB  0
02324:  CALL   0916
....................       // if the message doesn't return no error, try sending again 
....................       while ((res_byte != NO_ERR) && !TMR0IF);        
02328:  MOVLB  5
0232A:  MOVF   x90,F
0232C:  BZ    2332
0232E:  BTFSS  FF2.2
02330:  BRA    232A
....................       if (TMR4IF) 
02332:  BTFSS  F7E.0
02334:  BRA    233A
....................          continue; 
02336:  BRA    233C
02338:  BRA    233C
....................       else 
....................          break; 
0233A:  BRA    2340
0233C:  INCF   x8F,F
0233E:  BRA    230C
....................    } 
02340:  MOVLB  0
02342:  RETURN 0
.................... } 
.................... void send_full_report(uint8_t command_id_in_response_to, uint16_t msg_seq) 
.................... { 
....................    uint16_t temp_u16; 
....................    //flash led to help identifying motes  
....................    prepare_prefix_and_payload(58); 
*
06212:  MOVLW  3A
06214:  MOVLB  5
06216:  MOVWF  x59
06218:  MOVLB  0
0621A:  RCALL  5DA0
....................    payload_buff[4] = make8(msg_seq,0); 
0621C:  MOVFF  54F,2F3
06220:  MOVLB  2
....................    payload_buff[5] = make8(msg_seq,1); 
06222:  MOVFF  550,2F4
06226:  MOVLB  2
....................    payload_buff[6] = command_id_in_response_to; 
06228:  MOVFF  54E,2F5
....................    payload_buff[7] = MSG_MOTE_FULL_REPORT; 
0622C:  MOVLW  90
0622E:  MOVWF  xF6
....................    payload_buff[8] = make8(global_sprinkler_num, 0); 
06230:  MOVFF  91,2F7
06234:  MOVLB  2
....................    payload_buff[9] = make8(global_sprinkler_num, 1); 
06236:  MOVFF  92,2F8
0623A:  MOVLB  2
....................    payload_buff[10] = global_hardware_enabled; 
0623C:  MOVFF  A3,2F9
....................    payload_buff[11] = read_system_state(); 
06240:  MOVLB  0
06242:  CALL   1DC6
06246:  MOVFF  01,2FA
....................    // vbatt(unchanged charge state) 
....................    temp_u16 = get_vbatt(0); 
0624A:  MOVLB  5
0624C:  CLRF   x66
0624E:  MOVLB  0
06250:  CALL   40A4
06254:  MOVFF  02,552
06258:  MOVFF  01,551
....................    payload_buff[12] = make8(temp_u16, 0); 
0625C:  MOVFF  551,2FB
06260:  MOVLB  2
....................    payload_buff[13] = make8(temp_u16, 1); 
06262:  MOVFF  552,2FC
06266:  MOVLB  2
....................    // vbatt(no charging)        
....................    temp_u16 = get_vbatt(1); 
06268:  MOVLW  01
0626A:  MOVLB  5
0626C:  MOVWF  x66
0626E:  MOVLB  0
06270:  CALL   40A4
06274:  MOVFF  02,552
06278:  MOVFF  01,551
....................    payload_buff[14] = make8(temp_u16, 0); 
0627C:  MOVFF  551,2FD
06280:  MOVLB  2
....................    payload_buff[15] = make8(temp_u16, 1); 
06282:  MOVFF  552,2FE
06286:  MOVLB  2
....................    // vgen(unchanged charge state) 
....................    temp_u16 = get_vgen(0); 
06288:  MOVLB  5
0628A:  CLRF   x53
0628C:  MOVLB  0
0628E:  CALL   40FE
06292:  MOVFF  02,552
06296:  MOVFF  01,551
....................    payload_buff[16] = make8(temp_u16, 0); 
0629A:  MOVFF  551,2FF
0629E:  MOVLB  2
....................    payload_buff[17] = make8(temp_u16, 1);       
062A0:  MOVFF  552,300
062A4:  MOVLB  3
....................    disable_interrupts(INT_CCP5);              
062A6:  BCF    F7A.2
....................    temp_u16 = convert_period_to_rpm(global_current_period); 
062A8:  MOVFF  A5,554
062AC:  MOVFF  A4,553
062B0:  MOVLB  0
062B2:  RCALL  5DE2
062B4:  MOVFF  02,552
062B8:  MOVFF  01,551
....................    enable_interrupts(INT_CCP5); 
062BC:  BSF    F7A.2
....................    payload_buff[18] = make8(temp_u16, 0); 
062BE:  MOVFF  551,301
062C2:  MOVLB  3
....................    payload_buff[19] = make8(temp_u16, 1);                
062C4:  MOVFF  552,302
062C8:  MOVLB  3
....................    payload_buff[20] = make8(global_rpm_set_value,0); 
062CA:  MOVFF  A8,303
062CE:  MOVLB  3
....................    payload_buff[21] = make8(global_rpm_set_value,1); 
062D0:  MOVFF  A9,304
062D4:  MOVLB  3
....................    disable_interrupts(INT_CCP4); 
062D6:  BCF    F7A.1
....................    if (global_current_sprinkler_queue_location != 255) 
062D8:  MOVLB  4
062DA:  INCFSZ x25,W
062DC:  BRA    62E0
062DE:  BRA    6346
....................    { 
....................       payload_buff[22] = make8(global_sprinkler_queue[global_current_sprinkler_queue_location].spin_rate,0); 
062E0:  MOVF   x25,W
062E2:  MULLW  0E
062E4:  MOVF   FF3,W
062E6:  MOVLB  5
062E8:  CLRF   x54
062EA:  MOVWF  x53
062EC:  MOVLW  0A
062EE:  ADDWF  x53,W
062F0:  MOVWF  01
062F2:  MOVLW  00
062F4:  ADDWFC x54,W
062F6:  MOVWF  03
062F8:  MOVF   01,W
062FA:  ADDLW  99
062FC:  MOVWF  FE9
062FE:  MOVLW  03
06300:  ADDWFC 03,W
06302:  MOVWF  FEA
06304:  MOVFF  FEC,554
06308:  MOVF   FED,F
0630A:  MOVFF  FEF,305
0630E:  MOVLB  3
....................       payload_buff[23] = make8(global_sprinkler_queue[global_current_sprinkler_queue_location].spin_rate,1); 
06310:  MOVLB  4
06312:  MOVF   x25,W
06314:  MULLW  0E
06316:  MOVF   FF3,W
06318:  MOVLB  5
0631A:  CLRF   x54
0631C:  MOVWF  x53
0631E:  MOVLW  0A
06320:  ADDWF  x53,W
06322:  MOVWF  01
06324:  MOVLW  00
06326:  ADDWFC x54,W
06328:  MOVWF  03
0632A:  MOVF   01,W
0632C:  ADDLW  99
0632E:  MOVWF  FE9
06330:  MOVLW  03
06332:  ADDWFC 03,W
06334:  MOVWF  FEA
06336:  MOVFF  FEC,306
0633A:  MOVF   FED,F
0633C:  MOVFF  FEF,553
06340:  MOVLB  3
....................    } 
06342:  BRA    634C
06344:  MOVLB  4
....................    else 
....................    { 
....................       payload_buff[22] = 0; 
06346:  MOVLB  3
06348:  CLRF   x05
....................       payload_buff[23] = 0; 
0634A:  CLRF   x06
....................    } 
....................    payload_buff[24] = make8(global_brake_duty,0); 
0634C:  MOVFF  AE,307
06350:  MOVLB  3
....................    payload_buff[25] = make8(global_brake_duty,1); 
06352:  MOVFF  AF,308
06356:  MOVLB  3
....................    payload_buff[26] = make8(global_brake_duty_set_value,0); 
06358:  MOVFF  B2,309
0635C:  MOVLB  3
....................    payload_buff[27] = make8(global_brake_duty_set_value,1); 
0635E:  MOVFF  B3,30A
06362:  MOVLB  3
....................    payload_buff[28] = make8(global_charge_duty,0); 
06364:  MOVFF  B0,30B
06368:  MOVLB  3
....................    payload_buff[29] = make8(global_charge_duty,1); 
0636A:  MOVFF  B1,30C
0636E:  MOVLB  3
....................    payload_buff[30] = make8(global_charge_duty_set_value,0); 
06370:  MOVFF  B4,30D
06374:  MOVLB  3
....................    payload_buff[31] = make8(global_charge_duty_set_value,1); 
06376:  MOVFF  B5,30E
0637A:  MOVLB  3
....................    payload_buff[32] = global_mppc_value; 
0637C:  MOVFF  B6,30F
....................    payload_buff[33] = global_control_loop_mechanism; 
06380:  MOVFF  BC,310
....................    payload_buff[34] = make8(global_calibrate_fsr_valve_position, 0); 
06384:  MOVFF  CC,311
06388:  MOVLB  3
....................    payload_buff[35] = make8(global_calibrate_fsr_valve_position, 1); 
0638A:  MOVFF  CD,312
0638E:  MOVLB  3
....................    temp_u16 = convert_period_to_rpm(global_calibrate_fsr_period); 
06390:  MOVFF  CF,554
06394:  MOVFF  CE,553
06398:  MOVLB  0
0639A:  RCALL  5DE2
0639C:  MOVFF  02,552
063A0:  MOVFF  01,551
....................    payload_buff[36] = make8(temp_u16, 0); 
063A4:  MOVFF  551,313
063A8:  MOVLB  3
....................    payload_buff[37] = make8(temp_u16, 1); 
063AA:  MOVFF  552,314
063AE:  MOVLB  3
....................    payload_buff[38] = LATE; 
063B0:  MOVFF  F8D,315
....................    payload_buff[39] = make8(global_valve_position,0); 
063B4:  MOVFF  BD,316
063B8:  MOVLB  3
....................    payload_buff[40] = make8(global_valve_position,1); 
063BA:  MOVFF  BE,317
063BE:  MOVLB  3
....................    payload_buff[41] = make8(global_valve_position_set_value,0); 
063C0:  MOVFF  BF,318
063C4:  MOVLB  3
....................    payload_buff[42] = make8(global_valve_position_set_value,1); 
063C6:  MOVFF  C0,319
063CA:  MOVLB  3
....................    if (global_current_sprinkler_queue_location != 255) 
063CC:  MOVLB  4
063CE:  INCFSZ x25,W
063D0:  BRA    63D4
063D2:  BRA    64EA
....................    { 
....................       payload_buff[43] = make8(global_sprinkler_queue[global_current_sprinkler_queue_location].vlv_open_amount,0); 
063D4:  MOVF   x25,W
063D6:  MULLW  0E
063D8:  MOVF   FF3,W
063DA:  MOVLB  5
063DC:  CLRF   x54
063DE:  MOVWF  x53
063E0:  MOVLW  08
063E2:  ADDWF  x53,W
063E4:  MOVWF  01
063E6:  MOVLW  00
063E8:  ADDWFC x54,W
063EA:  MOVWF  03
063EC:  MOVF   01,W
063EE:  ADDLW  99
063F0:  MOVWF  FE9
063F2:  MOVLW  03
063F4:  ADDWFC 03,W
063F6:  MOVWF  FEA
063F8:  MOVFF  FEC,554
063FC:  MOVF   FED,F
063FE:  MOVFF  FEF,31A
06402:  MOVLB  3
....................       payload_buff[44] = make8(global_sprinkler_queue[global_current_sprinkler_queue_location].vlv_open_amount,1); 
06404:  MOVLB  4
06406:  MOVF   x25,W
06408:  MULLW  0E
0640A:  MOVF   FF3,W
0640C:  MOVLB  5
0640E:  CLRF   x54
06410:  MOVWF  x53
06412:  MOVLW  08
06414:  ADDWF  x53,W
06416:  MOVWF  01
06418:  MOVLW  00
0641A:  ADDWFC x54,W
0641C:  MOVWF  03
0641E:  MOVF   01,W
06420:  ADDLW  99
06422:  MOVWF  FE9
06424:  MOVLW  03
06426:  ADDWFC 03,W
06428:  MOVWF  FEA
0642A:  MOVFF  FEC,31B
0642E:  MOVF   FED,F
06430:  MOVFF  FEF,553
06434:  MOVLB  3
....................       payload_buff[45] = make8(global_sprinkler_queue[global_current_sprinkler_queue_location].start_time,0); 
06436:  MOVLB  4
06438:  MOVF   x25,W
0643A:  MULLW  0E
0643C:  MOVF   FF3,W
0643E:  MOVLB  5
06440:  CLRF   x54
06442:  MOVWF  x53
06444:  MOVLW  99
06446:  ADDWF  x53,W
06448:  MOVWF  FE9
0644A:  MOVLW  03
0644C:  ADDWFC x54,W
0644E:  MOVWF  FEA
06450:  MOVFF  FEF,31C
06454:  MOVFF  FEC,556
06458:  MOVFF  FEC,557
0645C:  MOVFF  FEC,558
06460:  MOVLB  3
....................       payload_buff[46] = make8(global_sprinkler_queue[global_current_sprinkler_queue_location].start_time,1); 
06462:  MOVLB  4
06464:  MOVF   x25,W
06466:  MULLW  0E
06468:  MOVF   FF3,W
0646A:  MOVLB  5
0646C:  CLRF   x54
0646E:  MOVWF  x53
06470:  MOVLW  99
06472:  ADDWF  x53,W
06474:  MOVWF  FE9
06476:  MOVLW  03
06478:  ADDWFC x54,W
0647A:  MOVWF  FEA
0647C:  MOVFF  FEF,555
06480:  MOVFF  FEC,31D
06484:  MOVFF  FEC,557
06488:  MOVFF  FEC,558
0648C:  MOVLB  3
....................       payload_buff[47] = make8(global_sprinkler_queue[global_current_sprinkler_queue_location].start_time,2); 
0648E:  MOVLB  4
06490:  MOVF   x25,W
06492:  MULLW  0E
06494:  MOVF   FF3,W
06496:  MOVLB  5
06498:  CLRF   x54
0649A:  MOVWF  x53
0649C:  MOVLW  99
0649E:  ADDWF  x53,W
064A0:  MOVWF  FE9
064A2:  MOVLW  03
064A4:  ADDWFC x54,W
064A6:  MOVWF  FEA
064A8:  MOVFF  FEF,555
064AC:  MOVFF  FEC,556
064B0:  MOVFF  FEC,31E
064B4:  MOVFF  FEC,558
064B8:  MOVLB  3
....................       payload_buff[48] = make8(global_sprinkler_queue[global_current_sprinkler_queue_location].start_time,3); 
064BA:  MOVLB  4
064BC:  MOVF   x25,W
064BE:  MULLW  0E
064C0:  MOVF   FF3,W
064C2:  MOVLB  5
064C4:  CLRF   x54
064C6:  MOVWF  x53
064C8:  MOVLW  99
064CA:  ADDWF  x53,W
064CC:  MOVWF  FE9
064CE:  MOVLW  03
064D0:  ADDWFC x54,W
064D2:  MOVWF  FEA
064D4:  MOVFF  FEF,555
064D8:  MOVFF  FEC,556
064DC:  MOVFF  FEC,557
064E0:  MOVFF  FEC,31F
064E4:  MOVLB  3
....................    } 
064E6:  BRA    64F8
064E8:  MOVLB  4
....................    else 
....................    { 
....................       payload_buff[43] = 0; 
064EA:  MOVLB  3
064EC:  CLRF   x1A
....................       payload_buff[44] = 0; 
064EE:  CLRF   x1B
....................       payload_buff[45] = 0; 
064F0:  CLRF   x1C
....................       payload_buff[46] = 0; 
064F2:  CLRF   x1D
....................       payload_buff[47] = 0; 
064F4:  CLRF   x1E
....................       payload_buff[48] = 0; 
064F6:  CLRF   x1F
....................    } 
....................    enable_interrupts(INT_CCP4); 
064F8:  BSF    F7A.1
....................    payload_buff[49] = make8(global_xdcr_output, 0); 
064FA:  MOVFF  4B,320
....................    payload_buff[50] = make8(global_xdcr_output, 1); 
064FE:  MOVFF  4C,321
....................    payload_buff[51] = make8(global_rtc_time,0); 
06502:  MOVFF  85,322
06506:  MOVLB  3
....................    payload_buff[52] = make8(global_rtc_time,1); 
06508:  MOVFF  86,323
0650C:  MOVLB  3
....................    payload_buff[53] = make8(global_rtc_time,2); 
0650E:  MOVFF  87,324
06512:  MOVLB  3
....................    payload_buff[54] = make8(global_rtc_time,3); 
06514:  MOVFF  88,325
06518:  MOVLB  3
....................    payload_buff[55] = global_previous_shutdown_cause; 
0651A:  MOVFF  4E,326
....................    payload_buff[56] = make8(FIRMWARE_VERSION,0); 
0651E:  MOVLW  12
06520:  MOVWF  x27
....................    payload_buff[57] = make8(FIRMWARE_VERSION,1);    
06522:  MOVLW  E3
06524:  MOVWF  x28
....................    generate_message_and_send(); 
06526:  MOVLB  0
06528:  RCALL  61B8
0652A:  RETURN 0
.................... } 
.................... void send_health_report(uint8_t command_id_in_response_to, uint16_t msg_seq) 
.................... {   
....................    uint16_t temp_u16; 
....................     
....................    prepare_prefix_and_payload(18); 
0652C:  MOVLW  12
0652E:  MOVLB  5
06530:  MOVWF  x59
06532:  MOVLB  0
06534:  RCALL  5DA0
....................    payload_buff[4] = make8(msg_seq,0); 
06536:  MOVFF  54F,2F3
0653A:  MOVLB  2
....................    payload_buff[5] = make8(msg_seq,1); 
0653C:  MOVFF  550,2F4
06540:  MOVLB  2
....................    payload_buff[6] = command_id_in_response_to; 
06542:  MOVFF  54E,2F5
....................    payload_buff[7] = MSG_MOTE_HEALTH_REPORT; 
06546:  MOVLW  91
06548:  MOVWF  xF6
....................    payload_buff[8] = make8(global_sprinkler_num, 0); 
0654A:  MOVFF  91,2F7
0654E:  MOVLB  2
....................    payload_buff[9] = make8(global_sprinkler_num, 1); 
06550:  MOVFF  92,2F8
06554:  MOVLB  2
....................    payload_buff[10] = global_hardware_enabled; 
06556:  MOVFF  A3,2F9
....................    payload_buff[11] = read_system_state(); 
0655A:  MOVLB  0
0655C:  CALL   1DC6
06560:  MOVFF  01,2FA
....................    // vbatt(unchanged charge state) 
....................    temp_u16 = get_vbatt(0); 
06564:  MOVLB  5
06566:  CLRF   x66
06568:  MOVLB  0
0656A:  CALL   40A4
0656E:  MOVFF  02,552
06572:  MOVFF  01,551
....................    payload_buff[12] = make8(temp_u16, 0); 
06576:  MOVFF  551,2FB
0657A:  MOVLB  2
....................    payload_buff[13] = make8(temp_u16, 1); 
0657C:  MOVFF  552,2FC
06580:  MOVLB  2
....................    // vbatt(no charging) 
....................    temp_u16 = get_vbatt(1); 
06582:  MOVLW  01
06584:  MOVLB  5
06586:  MOVWF  x66
06588:  MOVLB  0
0658A:  CALL   40A4
0658E:  MOVFF  02,552
06592:  MOVFF  01,551
....................    payload_buff[14] = make8(temp_u16, 0); 
06596:  MOVFF  551,2FD
0659A:  MOVLB  2
....................    payload_buff[15] = make8(temp_u16, 1); 
0659C:  MOVFF  552,2FE
065A0:  MOVLB  2
....................    payload_buff[16] = global_valve_movements_since_endstop; 
065A2:  MOVFF  CB,2FF
....................    // grab the most recent temperature 
....................    payload_buff[17] = global_mote_temperature; 
065A6:  MOVFF  369,300
....................    generate_message_and_send(); 
065AA:  MOVLB  0
065AC:  RCALL  61B8
065AE:  GOTO   71B2 (RETURN)
.................... } 
.................... void send_valve_report(uint8_t command_id_in_response_to, uint16_t msg_seq) 
.................... { 
....................    uint16_t temp_u16; 
....................     
....................    prepare_prefix_and_payload(28); 
065B2:  MOVLW  1C
065B4:  MOVLB  5
065B6:  MOVWF  x59
065B8:  MOVLB  0
065BA:  CALL   5DA0
....................    payload_buff[4] = make8(msg_seq,0); 
065BE:  MOVFF  54F,2F3
065C2:  MOVLB  2
....................    payload_buff[5] = make8(msg_seq,1); 
065C4:  MOVFF  550,2F4
065C8:  MOVLB  2
....................    payload_buff[6] = command_id_in_response_to;                                                         
065CA:  MOVFF  54E,2F5
....................    payload_buff[7] = MSG_MOTE_VALVE_REPORT; 
065CE:  MOVLW  92
065D0:  MOVWF  xF6
....................    payload_buff[8] = make8(global_sprinkler_num, 0); 
065D2:  MOVFF  91,2F7
065D6:  MOVLB  2
....................    payload_buff[9] = make8(global_sprinkler_num, 1); 
065D8:  MOVFF  92,2F8
065DC:  MOVLB  2
....................    payload_buff[10] = make8(global_valve_position, 0); 
065DE:  MOVFF  BD,2F9
065E2:  MOVLB  2
....................    payload_buff[11] = make8(global_valve_position, 1); 
065E4:  MOVFF  BE,2FA
065E8:  MOVLB  2
....................    payload_buff[12] = make8((global_valve_time_to_open_1024th << 4), 0); 
065EA:  MOVLB  0
065EC:  RLCF   xC3,W
065EE:  MOVLB  5
065F0:  MOVWF  x53
065F2:  MOVLB  0
065F4:  RLCF   xC4,W
065F6:  MOVLB  5
065F8:  MOVWF  x54
065FA:  RLCF   x53,F
065FC:  RLCF   x54,F
065FE:  RLCF   x53,F
06600:  RLCF   x54,F
06602:  RLCF   x53,F
06604:  RLCF   x54,F
06606:  MOVLW  F0
06608:  ANDWF  x53,F
0660A:  MOVFF  553,2FB
0660E:  MOVLB  2
....................    payload_buff[13] = make8((global_valve_time_to_open_1024th << 4), 1); 
06610:  MOVLB  0
06612:  RLCF   xC3,W
06614:  MOVLB  5
06616:  MOVWF  x53
06618:  MOVLB  0
0661A:  RLCF   xC4,W
0661C:  MOVLB  5
0661E:  MOVWF  x54
06620:  RLCF   x53,F
06622:  RLCF   x54,F
06624:  RLCF   x53,F
06626:  RLCF   x54,F
06628:  RLCF   x53,F
0662A:  RLCF   x54,F
0662C:  MOVLW  F0
0662E:  ANDWF  x53,F
06630:  MOVFF  554,2FC
06634:  MOVLB  2
....................    payload_buff[14] = make8((global_valve_time_to_close_1024th << 4), 0); 
06636:  MOVLB  0
06638:  RLCF   xC1,W
0663A:  MOVLB  5
0663C:  MOVWF  x53
0663E:  MOVLB  0
06640:  RLCF   xC2,W
06642:  MOVLB  5
06644:  MOVWF  x54
06646:  RLCF   x53,F
06648:  RLCF   x54,F
0664A:  RLCF   x53,F
0664C:  RLCF   x54,F
0664E:  RLCF   x53,F
06650:  RLCF   x54,F
06652:  MOVLW  F0
06654:  ANDWF  x53,F
06656:  MOVFF  553,2FD
0665A:  MOVLB  2
....................    payload_buff[15] = make8((global_valve_time_to_close_1024th << 4), 1); 
0665C:  MOVLB  0
0665E:  RLCF   xC1,W
06660:  MOVLB  5
06662:  MOVWF  x53
06664:  MOVLB  0
06666:  RLCF   xC2,W
06668:  MOVLB  5
0666A:  MOVWF  x54
0666C:  RLCF   x53,F
0666E:  RLCF   x54,F
06670:  RLCF   x53,F
06672:  RLCF   x54,F
06674:  RLCF   x53,F
06676:  RLCF   x54,F
06678:  MOVLW  F0
0667A:  ANDWF  x53,F
0667C:  MOVFF  554,2FE
06680:  MOVLB  2
....................    payload_buff[16] = make8(global_valve_calibration_utc_time, 0); 
06682:  MOVFF  C7,2FF
06686:  MOVLB  2
....................    payload_buff[17] = make8(global_valve_calibration_utc_time, 1); 
06688:  MOVFF  C8,300
0668C:  MOVLB  3
....................    payload_buff[18] = make8(global_valve_calibration_utc_time, 2); 
0668E:  MOVFF  C9,301
06692:  MOVLB  3
....................    payload_buff[19] = make8(global_valve_calibration_utc_time, 3); 
06694:  MOVFF  CA,302
06698:  MOVLB  3
....................    payload_buff[20] = make8(global_calibrate_fsr_valve_position, 0); 
0669A:  MOVFF  CC,303
0669E:  MOVLB  3
....................    payload_buff[21] = make8(global_calibrate_fsr_valve_position, 1); 
066A0:  MOVFF  CD,304
066A4:  MOVLB  3
....................    temp_u16 = convert_period_to_rpm(global_calibrate_fsr_period); 
066A6:  MOVFF  CF,554
066AA:  MOVFF  CE,553
066AE:  MOVLB  0
066B0:  CALL   5DE2
066B4:  MOVFF  02,552
066B8:  MOVFF  01,551
....................    payload_buff[22] = make8(temp_u16, 0); 
066BC:  MOVFF  551,305
066C0:  MOVLB  3
....................    payload_buff[23] = make8(temp_u16, 1); 
066C2:  MOVFF  552,306
066C6:  MOVLB  3
....................    payload_buff[24] = make8(global_calibrate_fsr_utc_time, 0); 
066C8:  MOVFF  D0,307
066CC:  MOVLB  3
....................    payload_buff[25] = make8(global_calibrate_fsr_utc_time, 1); 
066CE:  MOVFF  D1,308
066D2:  MOVLB  3
....................    payload_buff[26] = make8(global_calibrate_fsr_utc_time, 2); 
066D4:  MOVFF  D2,309
066D8:  MOVLB  3
....................    payload_buff[27] = make8(global_calibrate_fsr_utc_time, 3); 
066DA:  MOVFF  D3,30A
066DE:  MOVLB  3
....................    generate_message_and_send(); 
066E0:  MOVLB  0
066E2:  RCALL  61B8
066E4:  RETURN 0
.................... } 
.................... void send_sprinkler_cmd_response(uint8_t command_id_in_response_to, uint16_t msg_seq) 
.................... { 
....................    uint16_t temp_u16; 
....................     
....................    prepare_prefix_and_payload(25); 
*
06E82:  MOVLW  19
06E84:  MOVLB  5
06E86:  MOVWF  x59
06E88:  MOVLB  0
06E8A:  CALL   5DA0
....................    payload_buff[4] = make8(msg_seq,0); 
06E8E:  MOVFF  54F,2F3
06E92:  MOVLB  2
....................    payload_buff[5] = make8(msg_seq,1); 
06E94:  MOVFF  550,2F4
06E98:  MOVLB  2
....................    payload_buff[6] = command_id_in_response_to; 
06E9A:  MOVFF  54E,2F5
....................    payload_buff[7] = MSG_MOTE_SPINKLER_CMD_RESPONSE; 
06E9E:  MOVLW  93
06EA0:  MOVWF  xF6
....................    payload_buff[8] = make8(global_sprinkler_num, 0); 
06EA2:  MOVFF  91,2F7
06EA6:  MOVLB  2
....................    payload_buff[9] = make8(global_sprinkler_num, 1); 
06EA8:  MOVFF  92,2F8
06EAC:  MOVLB  2
....................    payload_buff[10] = global_hardware_enabled; 
06EAE:  MOVFF  A3,2F9
....................    payload_buff[11] = make8(global_rpm_set_value, 0); 
06EB2:  MOVFF  A8,2FA
06EB6:  MOVLB  2
....................    payload_buff[12] = make8(global_rpm_set_value, 1); 
06EB8:  MOVFF  A9,2FB
06EBC:  MOVLB  2
....................    disable_interrupts(INT_CCP4); 
06EBE:  BCF    F7A.1
....................    if (global_current_sprinkler_queue_location != 255) 
06EC0:  MOVLB  4
06EC2:  INCFSZ x25,W
06EC4:  BRA    6EC8
06EC6:  BRA    6F2E
....................    { 
....................       payload_buff[13] = make8(global_sprinkler_queue[global_current_sprinkler_queue_location].spin_rate,0); 
06EC8:  MOVF   x25,W
06ECA:  MULLW  0E
06ECC:  MOVF   FF3,W
06ECE:  MOVLB  5
06ED0:  CLRF   x54
06ED2:  MOVWF  x53
06ED4:  MOVLW  0A
06ED6:  ADDWF  x53,W
06ED8:  MOVWF  01
06EDA:  MOVLW  00
06EDC:  ADDWFC x54,W
06EDE:  MOVWF  03
06EE0:  MOVF   01,W
06EE2:  ADDLW  99
06EE4:  MOVWF  FE9
06EE6:  MOVLW  03
06EE8:  ADDWFC 03,W
06EEA:  MOVWF  FEA
06EEC:  MOVFF  FEC,554
06EF0:  MOVF   FED,F
06EF2:  MOVFF  FEF,2FC
06EF6:  MOVLB  2
....................       payload_buff[14] = make8(global_sprinkler_queue[global_current_sprinkler_queue_location].spin_rate,1); 
06EF8:  MOVLB  4
06EFA:  MOVF   x25,W
06EFC:  MULLW  0E
06EFE:  MOVF   FF3,W
06F00:  MOVLB  5
06F02:  CLRF   x54
06F04:  MOVWF  x53
06F06:  MOVLW  0A
06F08:  ADDWF  x53,W
06F0A:  MOVWF  01
06F0C:  MOVLW  00
06F0E:  ADDWFC x54,W
06F10:  MOVWF  03
06F12:  MOVF   01,W
06F14:  ADDLW  99
06F16:  MOVWF  FE9
06F18:  MOVLW  03
06F1A:  ADDWFC 03,W
06F1C:  MOVWF  FEA
06F1E:  MOVFF  FEC,2FD
06F22:  MOVF   FED,F
06F24:  MOVFF  FEF,553
06F28:  MOVLB  2
....................    } 
06F2A:  BRA    6F34
06F2C:  MOVLB  4
....................    else 
....................    { 
....................       payload_buff[13] = 0; 
06F2E:  MOVLB  2
06F30:  CLRF   xFC
....................       payload_buff[14] = 0; 
06F32:  CLRF   xFD
....................    } 
....................    payload_buff[15] = make8(global_valve_position_set_value,0); 
06F34:  MOVFF  BF,2FE
06F38:  MOVLB  2
....................    payload_buff[16] = make8(global_valve_position_set_value,1); 
06F3A:  MOVFF  C0,2FF
06F3E:  MOVLB  2
....................    if (global_current_sprinkler_queue_location != 255) 
06F40:  MOVLB  4
06F42:  INCFSZ x25,W
06F44:  BRA    6F48
06F46:  BRA    705E
....................    { 
....................       payload_buff[17] = make8(global_sprinkler_queue[global_current_sprinkler_queue_location].vlv_open_amount,0); 
06F48:  MOVF   x25,W
06F4A:  MULLW  0E
06F4C:  MOVF   FF3,W
06F4E:  MOVLB  5
06F50:  CLRF   x54
06F52:  MOVWF  x53
06F54:  MOVLW  08
06F56:  ADDWF  x53,W
06F58:  MOVWF  01
06F5A:  MOVLW  00
06F5C:  ADDWFC x54,W
06F5E:  MOVWF  03
06F60:  MOVF   01,W
06F62:  ADDLW  99
06F64:  MOVWF  FE9
06F66:  MOVLW  03
06F68:  ADDWFC 03,W
06F6A:  MOVWF  FEA
06F6C:  MOVFF  FEC,554
06F70:  MOVF   FED,F
06F72:  MOVFF  FEF,300
06F76:  MOVLB  3
....................       payload_buff[18] = make8(global_sprinkler_queue[global_current_sprinkler_queue_location].vlv_open_amount,1); 
06F78:  MOVLB  4
06F7A:  MOVF   x25,W
06F7C:  MULLW  0E
06F7E:  MOVF   FF3,W
06F80:  MOVLB  5
06F82:  CLRF   x54
06F84:  MOVWF  x53
06F86:  MOVLW  08
06F88:  ADDWF  x53,W
06F8A:  MOVWF  01
06F8C:  MOVLW  00
06F8E:  ADDWFC x54,W
06F90:  MOVWF  03
06F92:  MOVF   01,W
06F94:  ADDLW  99
06F96:  MOVWF  FE9
06F98:  MOVLW  03
06F9A:  ADDWFC 03,W
06F9C:  MOVWF  FEA
06F9E:  MOVFF  FEC,301
06FA2:  MOVF   FED,F
06FA4:  MOVFF  FEF,553
06FA8:  MOVLB  3
....................       payload_buff[19] = make8(global_sprinkler_queue[global_current_sprinkler_queue_location].start_time,0); 
06FAA:  MOVLB  4
06FAC:  MOVF   x25,W
06FAE:  MULLW  0E
06FB0:  MOVF   FF3,W
06FB2:  MOVLB  5
06FB4:  CLRF   x54
06FB6:  MOVWF  x53
06FB8:  MOVLW  99
06FBA:  ADDWF  x53,W
06FBC:  MOVWF  FE9
06FBE:  MOVLW  03
06FC0:  ADDWFC x54,W
06FC2:  MOVWF  FEA
06FC4:  MOVFF  FEF,302
06FC8:  MOVFF  FEC,556
06FCC:  MOVFF  FEC,557
06FD0:  MOVFF  FEC,558
06FD4:  MOVLB  3
....................       payload_buff[20] = make8(global_sprinkler_queue[global_current_sprinkler_queue_location].start_time,1); 
06FD6:  MOVLB  4
06FD8:  MOVF   x25,W
06FDA:  MULLW  0E
06FDC:  MOVF   FF3,W
06FDE:  MOVLB  5
06FE0:  CLRF   x54
06FE2:  MOVWF  x53
06FE4:  MOVLW  99
06FE6:  ADDWF  x53,W
06FE8:  MOVWF  FE9
06FEA:  MOVLW  03
06FEC:  ADDWFC x54,W
06FEE:  MOVWF  FEA
06FF0:  MOVFF  FEF,555
06FF4:  MOVFF  FEC,303
06FF8:  MOVFF  FEC,557
06FFC:  MOVFF  FEC,558
07000:  MOVLB  3
....................       payload_buff[21] = make8(global_sprinkler_queue[global_current_sprinkler_queue_location].start_time,2); 
07002:  MOVLB  4
07004:  MOVF   x25,W
07006:  MULLW  0E
07008:  MOVF   FF3,W
0700A:  MOVLB  5
0700C:  CLRF   x54
0700E:  MOVWF  x53
07010:  MOVLW  99
07012:  ADDWF  x53,W
07014:  MOVWF  FE9
07016:  MOVLW  03
07018:  ADDWFC x54,W
0701A:  MOVWF  FEA
0701C:  MOVFF  FEF,555
07020:  MOVFF  FEC,556
07024:  MOVFF  FEC,304
07028:  MOVFF  FEC,558
0702C:  MOVLB  3
....................       payload_buff[22] = make8(global_sprinkler_queue[global_current_sprinkler_queue_location].start_time,3); 
0702E:  MOVLB  4
07030:  MOVF   x25,W
07032:  MULLW  0E
07034:  MOVF   FF3,W
07036:  MOVLB  5
07038:  CLRF   x54
0703A:  MOVWF  x53
0703C:  MOVLW  99
0703E:  ADDWF  x53,W
07040:  MOVWF  FE9
07042:  MOVLW  03
07044:  ADDWFC x54,W
07046:  MOVWF  FEA
07048:  MOVFF  FEF,555
0704C:  MOVFF  FEC,556
07050:  MOVFF  FEC,557
07054:  MOVFF  FEC,305
07058:  MOVLB  3
....................    } 
0705A:  BRA    706C
0705C:  MOVLB  4
....................    else 
....................    { 
....................       payload_buff[17] = 0; 
0705E:  MOVLB  3
07060:  CLRF   x00
....................       payload_buff[18] = 0; 
07062:  CLRF   x01
....................       payload_buff[19] = 0; 
07064:  CLRF   x02
....................       payload_buff[20] = 0; 
07066:  CLRF   x03
....................       payload_buff[21] = 0; 
07068:  CLRF   x04
....................       payload_buff[22] = 0; 
0706A:  CLRF   x05
....................    } 
....................    enable_interrupts(INT_CCP4); 
0706C:  BSF    F7A.1
....................    // vbatt(no charging) 
....................    temp_u16 = get_vbatt(1); 
0706E:  MOVLW  01
07070:  MOVLB  5
07072:  MOVWF  x66
07074:  MOVLB  0
07076:  CALL   40A4
0707A:  MOVFF  02,552
0707E:  MOVFF  01,551
....................    payload_buff[23] = make8(temp_u16, 0); 
07082:  MOVFF  551,306
07086:  MOVLB  3
....................    payload_buff[24] = make8(temp_u16, 1); 
07088:  MOVFF  552,307
0708C:  MOVLB  3
....................    generate_message_and_send(); 
0708E:  MOVLB  0
07090:  CALL   61B8
07094:  GOTO   78F4 (RETURN)
.................... } 
.................... void send_update_sp_num_response(uint8_t command_id_in_response_to, uint16_t msg_seq) 
.................... { 
....................    prepare_prefix_and_payload(10); 
*
0670C:  MOVLW  0A
0670E:  MOVLB  5
06710:  MOVWF  x59
06712:  MOVLB  0
06714:  CALL   5DA0
....................    payload_buff[4] = make8(msg_seq,0); 
06718:  MOVFF  54F,2F3
0671C:  MOVLB  2
....................    payload_buff[5] = make8(msg_seq,1); 
0671E:  MOVFF  550,2F4
06722:  MOVLB  2
....................    payload_buff[6] = command_id_in_response_to; 
06724:  MOVFF  54E,2F5
....................    payload_buff[7] = MSG_MOTE_UPDATE_SP_NUM_RESPONSE; 
06728:  MOVLW  95
0672A:  MOVWF  xF6
....................    payload_buff[8] = make8(global_sprinkler_num, 0); 
0672C:  MOVFF  91,2F7
06730:  MOVLB  2
....................    payload_buff[9] = make8(global_sprinkler_num, 1); 
06732:  MOVFF  92,2F8
06736:  MOVLB  2
....................    generate_message_and_send(); 
06738:  MOVLB  0
0673A:  RCALL  61B8
0673C:  GOTO   741E (RETURN)
.................... }        
.................... void send_read_eeprom_response(uint8_t command_id_in_response_to, uint16_t msg_seq, uint16_t eeprom_location, uint32_t eeprom_data)  
.................... { 
....................    prepare_prefix_and_payload(16); 
*
06BBC:  MOVLW  10
06BBE:  MOVLB  5
06BC0:  MOVWF  x59
06BC2:  MOVLB  0
06BC4:  CALL   5DA0
....................    payload_buff[4] = make8(msg_seq,0);                                                    
06BC8:  MOVFF  551,2F3
06BCC:  MOVLB  2
....................    payload_buff[5] = make8(msg_seq,1); 
06BCE:  MOVFF  552,2F4
06BD2:  MOVLB  2
....................    payload_buff[6] = command_id_in_response_to; 
06BD4:  MOVFF  550,2F5
....................    payload_buff[7] = MSG_MOTE_EEPROM_READ_RESPONSE;  
06BD8:  MOVLW  97
06BDA:  MOVWF  xF6
....................    payload_buff[8] = make8(global_sprinkler_num, 0); 
06BDC:  MOVFF  91,2F7
06BE0:  MOVLB  2
....................    payload_buff[9] = make8(global_sprinkler_num, 1); 
06BE2:  MOVFF  92,2F8
06BE6:  MOVLB  2
....................    payload_buff[10] = make8(eeprom_location, 0); 
06BE8:  MOVFF  553,2F9
06BEC:  MOVLB  2
....................    payload_buff[11] = make8(eeprom_location, 1);   
06BEE:  MOVFF  554,2FA
06BF2:  MOVLB  2
....................    payload_buff[12] = make8(eeprom_data, 0);                          
06BF4:  MOVFF  555,2FB
06BF8:  MOVLB  2
....................    payload_buff[13] = make8(eeprom_data, 1);   
06BFA:  MOVFF  556,2FC
06BFE:  MOVLB  2
....................    payload_buff[14] = make8(eeprom_data, 2);     
06C00:  MOVFF  557,2FD
06C04:  MOVLB  2
....................    payload_buff[15] = make8(eeprom_data, 3);   
06C06:  MOVFF  558,2FE
06C0A:  MOVLB  2
....................    generate_message_and_send();    
06C0C:  MOVLB  0
06C0E:  CALL   61B8
06C12:  GOTO   7790 (RETURN)
.................... }                
.................... void send_pressure_xdcr_msg(uint8_t command_id_in_response_to, uint16_t msg_seq)    
.................... {                    
....................    prepare_prefix_and_payload(12); 
....................    payload_buff[4] = make8(msg_seq,0);                                                    
....................    payload_buff[5] = make8(msg_seq,1);       
....................    payload_buff[6] = command_id_in_response_to;                    
....................    payload_buff[7] = MSG_MOTE_XDCR_READ_MSG;           
....................    payload_buff[8] = make8(global_sprinkler_num, 0);    
....................    payload_buff[9] = make8(global_sprinkler_num, 1); 
....................    payload_buff[10] = make8(global_xdcr_output, 0);                  
....................    payload_buff[11] = make8(global_xdcr_output, 1);    
....................    generate_message_and_send();                               
.................... }        
.................... void send_ack(uint8_t command_id_in_response_to, uint16_t msg_seq) 
.................... { 
....................    prepare_prefix_and_payload(8); 
*
066E6:  MOVLW  08
066E8:  MOVLB  5
066EA:  MOVWF  x59
066EC:  MOVLB  0
066EE:  CALL   5DA0
....................    payload_buff[4] = make8(msg_seq,0); 
066F2:  MOVFF  54F,2F3
066F6:  MOVLB  2
....................    payload_buff[5] = make8(msg_seq,1); 
066F8:  MOVFF  550,2F4
066FC:  MOVLB  2
....................    payload_buff[6] = command_id_in_response_to; 
066FE:  MOVFF  54E,2F5
....................    payload_buff[7] = MSG_MOTE_ACK; 
06702:  MOVLW  80
06704:  MOVWF  xF6
....................    generate_message_and_send(); 
06706:  MOVLB  0
06708:  RCALL  61B8
0670A:  RETURN 0
.................... } 
.................... void send_nack(uint8_t command_id_in_response_to, uint16_t msg_seq, uint32_t nack_bitfield) 
.................... { 
....................    prepare_prefix_and_payload(12); 
*
06762:  MOVLW  0C
06764:  MOVLB  5
06766:  MOVWF  x59
06768:  MOVLB  0
0676A:  CALL   5DA0
....................    payload_buff[4] = make8(msg_seq,0); 
0676E:  MOVFF  54F,2F3
06772:  MOVLB  2
....................    payload_buff[5] = make8(msg_seq,1); 
06774:  MOVFF  550,2F4
06778:  MOVLB  2
....................    payload_buff[6] = command_id_in_response_to; 
0677A:  MOVFF  54E,2F5
....................    payload_buff[7] = MSG_MOTE_NACK; 
0677E:  MOVLW  81
06780:  MOVWF  xF6
....................    payload_buff[8] = make8(nack_bitfield, 0); 
06782:  MOVFF  551,2F7
06786:  MOVLB  2
....................    payload_buff[9] = make8(nack_bitfield, 1); 
06788:  MOVFF  552,2F8
0678C:  MOVLB  2
....................    payload_buff[10] = make8(nack_bitfield, 2); 
0678E:  MOVFF  553,2F9
06792:  MOVLB  2
....................    payload_buff[11] = make8(nack_bitfield, 3); 
06794:  MOVFF  554,2FA
06798:  MOVLB  2
....................    generate_message_and_send(); 
0679A:  MOVLB  0
0679C:  RCALL  61B8
0679E:  RETURN 0
.................... }                                        
....................  
.................... // unsolicted responses (only sent within CCP4 ISR) 
.................... void send_health_report_ISR(uint8_t command_id_in_response_to, uint16_t msg_seq) 
.................... { 
....................    uint16_t temp_u16; 
....................     
....................    prepare_prefix_and_payload_ISR(18); 
*
02344:  MOVLW  12
02346:  MOVLB  5
02348:  MOVWF  x8F
0234A:  MOVLB  0
0234C:  RCALL  224C
....................    payload_buff[4] = make8(msg_seq,0); 
0234E:  MOVFF  58B,2F3
02352:  MOVLB  2
....................    payload_buff[5] = make8(msg_seq,1); 
02354:  MOVFF  58C,2F4
02358:  MOVLB  2
....................    payload_buff[6] = command_id_in_response_to; 
0235A:  MOVFF  58A,2F5
....................    payload_buff[7] = MSG_MOTE_HEALTH_REPORT; 
0235E:  MOVLW  91
02360:  MOVWF  xF6
....................    payload_buff[8] = make8(global_sprinkler_num, 0); 
02362:  MOVFF  91,2F7
02366:  MOVLB  2
....................    payload_buff[9] = make8(global_sprinkler_num, 1); 
02368:  MOVFF  92,2F8
0236C:  MOVLB  2
....................    payload_buff[10] = global_hardware_enabled; 
0236E:  MOVFF  A3,2F9
....................    payload_buff[11] = global_system_state; 
02372:  MOVFF  501,2FA
....................  // vbatt(unchanged charge state) 
....................    temp_u16 = get_vbatt_ISR(0); 
02376:  MOVLB  5
02378:  CLRF   x8F
0237A:  MOVLB  0
0237C:  RCALL  228E
0237E:  MOVFF  02,58E
02382:  MOVFF  01,58D
....................    payload_buff[12] = make8(temp_u16, 0); 
02386:  MOVFF  58D,2FB
0238A:  MOVLB  2
....................    payload_buff[13] = make8(temp_u16, 1); 
0238C:  MOVFF  58E,2FC
02390:  MOVLB  2
....................    // vbatt(no charging) 
....................    temp_u16 = get_vbatt_ISR(1); 
02392:  MOVLW  01
02394:  MOVLB  5
02396:  MOVWF  x8F
02398:  MOVLB  0
0239A:  RCALL  228E
0239C:  MOVFF  02,58E
023A0:  MOVFF  01,58D
....................    payload_buff[14] = make8(temp_u16, 0); 
023A4:  MOVFF  58D,2FD
023A8:  MOVLB  2
....................    payload_buff[15] = make8(temp_u16, 1); 
023AA:  MOVFF  58E,2FE
023AE:  MOVLB  2
....................    payload_buff[16] = global_valve_movements_since_endstop; 
023B0:  MOVFF  CB,2FF
....................    payload_buff[17] = global_mote_temperature; 
023B4:  MOVFF  369,300
....................    generate_message_and_send_ISR(); 
023B8:  MOVLB  0
023BA:  RCALL  22E8
023BC:  GOTO   28EC (RETURN)
.................... } 
.................... void send_valve_report_ISR(uint8_t command_id_in_response_to, uint16_t msg_seq) 
.................... { 
....................    uint16_t temp_u16; 
....................    prepare_prefix_and_payload_ISR(28); 
*
024BE:  MOVLW  1C
024C0:  MOVLB  5
024C2:  MOVWF  x8F
024C4:  MOVLB  0
024C6:  RCALL  224C
....................    payload_buff[4] = make8(msg_seq,0); 
024C8:  MOVFF  58B,2F3
024CC:  MOVLB  2
....................    payload_buff[5] = make8(msg_seq,1); 
024CE:  MOVFF  58C,2F4
024D2:  MOVLB  2
....................    payload_buff[6] = command_id_in_response_to; 
024D4:  MOVFF  58A,2F5
....................    payload_buff[7] = MSG_MOTE_VALVE_REPORT; 
024D8:  MOVLW  92
024DA:  MOVWF  xF6
....................    payload_buff[8] = make8(global_sprinkler_num, 0); 
024DC:  MOVFF  91,2F7
024E0:  MOVLB  2
....................    payload_buff[9] = make8(global_sprinkler_num, 1); 
024E2:  MOVFF  92,2F8
024E6:  MOVLB  2
....................    payload_buff[10] = make8(global_valve_position, 0); 
024E8:  MOVFF  BD,2F9
024EC:  MOVLB  2
....................    payload_buff[11] = make8(global_valve_position, 1); 
024EE:  MOVFF  BE,2FA
024F2:  MOVLB  2
....................    payload_buff[12] = make8((global_valve_time_to_open_1024th << 4), 0); 
024F4:  MOVLB  0
024F6:  RLCF   xC3,W
024F8:  MOVLB  5
024FA:  MOVWF  x8F
024FC:  MOVLB  0
024FE:  RLCF   xC4,W
02500:  MOVLB  5
02502:  MOVWF  x90
02504:  RLCF   x8F,F
02506:  RLCF   x90,F
02508:  RLCF   x8F,F
0250A:  RLCF   x90,F
0250C:  RLCF   x8F,F
0250E:  RLCF   x90,F
02510:  MOVLW  F0
02512:  ANDWF  x8F,F
02514:  MOVFF  58F,2FB
02518:  MOVLB  2
....................    payload_buff[13] = make8((global_valve_time_to_open_1024th << 4), 1); 
0251A:  MOVLB  0
0251C:  RLCF   xC3,W
0251E:  MOVLB  5
02520:  MOVWF  x8F
02522:  MOVLB  0
02524:  RLCF   xC4,W
02526:  MOVLB  5
02528:  MOVWF  x90
0252A:  RLCF   x8F,F
0252C:  RLCF   x90,F
0252E:  RLCF   x8F,F
02530:  RLCF   x90,F
02532:  RLCF   x8F,F
02534:  RLCF   x90,F
02536:  MOVLW  F0
02538:  ANDWF  x8F,F
0253A:  MOVFF  590,2FC
0253E:  MOVLB  2
....................    payload_buff[14] = make8((global_valve_time_to_close_1024th << 4), 0); 
02540:  MOVLB  0
02542:  RLCF   xC1,W
02544:  MOVLB  5
02546:  MOVWF  x8F
02548:  MOVLB  0
0254A:  RLCF   xC2,W
0254C:  MOVLB  5
0254E:  MOVWF  x90
02550:  RLCF   x8F,F
02552:  RLCF   x90,F
02554:  RLCF   x8F,F
02556:  RLCF   x90,F
02558:  RLCF   x8F,F
0255A:  RLCF   x90,F
0255C:  MOVLW  F0
0255E:  ANDWF  x8F,F
02560:  MOVFF  58F,2FD
02564:  MOVLB  2
....................    payload_buff[15] = make8((global_valve_time_to_close_1024th << 4), 1); 
02566:  MOVLB  0
02568:  RLCF   xC1,W
0256A:  MOVLB  5
0256C:  MOVWF  x8F
0256E:  MOVLB  0
02570:  RLCF   xC2,W
02572:  MOVLB  5
02574:  MOVWF  x90
02576:  RLCF   x8F,F
02578:  RLCF   x90,F
0257A:  RLCF   x8F,F
0257C:  RLCF   x90,F
0257E:  RLCF   x8F,F
02580:  RLCF   x90,F
02582:  MOVLW  F0
02584:  ANDWF  x8F,F
02586:  MOVFF  590,2FE
0258A:  MOVLB  2
....................    payload_buff[16] = make8(global_valve_calibration_utc_time, 0); 
0258C:  MOVFF  C7,2FF
02590:  MOVLB  2
....................    payload_buff[17] = make8(global_valve_calibration_utc_time, 1); 
02592:  MOVFF  C8,300
02596:  MOVLB  3
....................    payload_buff[18] = make8(global_valve_calibration_utc_time, 2); 
02598:  MOVFF  C9,301
0259C:  MOVLB  3
....................    payload_buff[19] = make8(global_valve_calibration_utc_time, 3); 
0259E:  MOVFF  CA,302
025A2:  MOVLB  3
....................    payload_buff[20] = make8(global_calibrate_fsr_valve_position, 0); 
025A4:  MOVFF  CC,303
025A8:  MOVLB  3
....................    payload_buff[21] = make8(global_calibrate_fsr_valve_position, 1); 
025AA:  MOVFF  CD,304
025AE:  MOVLB  3
....................    temp_u16 = convert_period_to_rpm_ISR(global_calibrate_fsr_period); 
025B0:  MOVFF  CF,590
025B4:  MOVFF  CE,58F
025B8:  MOVLB  0
025BA:  BRA    2454
025BC:  MOVFF  02,58E
025C0:  MOVFF  01,58D
....................    payload_buff[22] = make8(temp_u16, 0); 
025C4:  MOVFF  58D,305
025C8:  MOVLB  3
....................    payload_buff[23] = make8(temp_u16, 1); 
025CA:  MOVFF  58E,306
025CE:  MOVLB  3
....................    payload_buff[24] = make8(global_calibrate_fsr_utc_time, 0); 
025D0:  MOVFF  D0,307
025D4:  MOVLB  3
....................    payload_buff[25] = make8(global_calibrate_fsr_utc_time, 1); 
025D6:  MOVFF  D1,308
025DA:  MOVLB  3
....................    payload_buff[26] = make8(global_calibrate_fsr_utc_time, 2); 
025DC:  MOVFF  D2,309
025E0:  MOVLB  3
....................    payload_buff[27] = make8(global_calibrate_fsr_utc_time, 3); 
025E2:  MOVFF  D3,30A
025E6:  MOVLB  3
....................    generate_message_and_send_ISR(); 
025E8:  MOVLB  0
025EA:  RCALL  22E8
025EC:  GOTO   28EC (RETURN)
.................... } 
.................... void send_join_msg_ISR(uint8_t command_id_in_response_to, uint16_t msg_seq) 
.................... { 
....................    prepare_prefix_and_payload_ISR(18); 
025F0:  MOVLW  12
025F2:  MOVLB  5
025F4:  MOVWF  x8F
025F6:  MOVLB  0
025F8:  RCALL  224C
....................    payload_buff[4] = make8(msg_seq,0); 
025FA:  MOVFF  58B,2F3
025FE:  MOVLB  2
....................    payload_buff[5] = make8(msg_seq,1); 
02600:  MOVFF  58C,2F4
02604:  MOVLB  2
....................    payload_buff[6] = command_id_in_response_to; 
02606:  MOVFF  58A,2F5
....................    payload_buff[7] = MSG_MOTE_JOIN_MSG; 
0260A:  MOVLW  94
0260C:  MOVWF  xF6
....................    payload_buff[8] = make8(global_sprinkler_num, 0); 
0260E:  MOVFF  91,2F7
02612:  MOVLB  2
....................    payload_buff[9] = make8(global_sprinkler_num, 1); 
02614:  MOVFF  92,2F8
02618:  MOVLB  2
....................    payload_buff[10] = global_hardware_enabled; 
0261A:  MOVFF  A3,2F9
....................    payload_buff[11] = make8(global_rtc_time,0); 
0261E:  MOVFF  85,2FA
02622:  MOVLB  2
....................    payload_buff[12] = make8(global_rtc_time,1); 
02624:  MOVFF  86,2FB
02628:  MOVLB  2
....................    payload_buff[13] = make8(global_rtc_time,2); 
0262A:  MOVFF  87,2FC
0262E:  MOVLB  2
....................    payload_buff[14] = make8(global_rtc_time,3);    
02630:  MOVFF  88,2FD
02634:  MOVLB  2
....................    payload_buff[15] = global_previous_shutdown_cause; 
02636:  MOVFF  4E,2FE
....................    payload_buff[16] = make8(FIRMWARE_VERSION,0); 
0263A:  MOVLW  12
0263C:  MOVWF  xFF
....................    payload_buff[17] = make8(FIRMWARE_VERSION,1);   
0263E:  MOVLW  E3
02640:  MOVLB  3
02642:  MOVWF  x00
....................    generate_message_and_send_ISR(); 
02644:  MOVLB  0
02646:  RCALL  22E8
02648:  GOTO   28EC (RETURN)
.................... } 
.................... void send_gps_point_msg_ISR(uint8_t command_id_in_response_to, uint16_t msg_seq) 
.................... { 
....................    prepare_prefix_and_payload_ISR(23); 
0264C:  MOVLW  17
0264E:  MOVLB  5
02650:  MOVWF  x8F
02652:  MOVLB  0
02654:  RCALL  224C
....................    payload_buff[4] = make8(msg_seq,0); 
02656:  MOVFF  58B,2F3
0265A:  MOVLB  2
....................    payload_buff[5] = make8(msg_seq,1); 
0265C:  MOVFF  58C,2F4
02660:  MOVLB  2
....................    payload_buff[6] = command_id_in_response_to; 
02662:  MOVFF  58A,2F5
....................    payload_buff[7] = MSG_MOTE_GPS_POINT_MSG; 
02666:  MOVLW  96
02668:  MOVWF  xF6
....................    payload_buff[8] = make8(global_sprinkler_num, 0); 
0266A:  MOVFF  91,2F7
0266E:  MOVLB  2
....................    payload_buff[9] = make8(global_sprinkler_num, 1); 
02670:  MOVFF  92,2F8
02674:  MOVLB  2
....................    generate_message_and_send_ISR(); 
02676:  MOVLB  0
02678:  RCALL  22E8
0267A:  GOTO   28EC (RETURN)
.................... }                  
.................... void send_pressure_xdcr_msg_ISR(uint8_t command_id_in_response_to, uint16_t msg_seq)    
.................... {                          
....................    prepare_prefix_and_payload_ISR(12);  
0267E:  MOVLW  0C
02680:  MOVLB  5
02682:  MOVWF  x8F
02684:  MOVLB  0
02686:  RCALL  224C
....................    payload_buff[4] = make8(msg_seq,0);                                                    
02688:  MOVFF  58B,2F3
0268C:  MOVLB  2
....................    payload_buff[5] = make8(msg_seq,1);       
0268E:  MOVFF  58C,2F4
02692:  MOVLB  2
....................    payload_buff[6] = command_id_in_response_to;                    
02694:  MOVFF  58A,2F5
....................    payload_buff[7] = MSG_MOTE_XDCR_READ_MSG;     
02698:  MOVLW  98
0269A:  MOVWF  xF6
....................    payload_buff[8] = make8(global_sprinkler_num, 0);    
0269C:  MOVFF  91,2F7
026A0:  MOVLB  2
....................    payload_buff[9] = make8(global_sprinkler_num, 1);                        
026A2:  MOVFF  92,2F8
026A6:  MOVLB  2
....................    payload_buff[10] = make8(global_xdcr_output, 0);                  
026A8:  MOVFF  4B,2F9
....................    payload_buff[11] = make8(global_xdcr_output, 1);       
026AC:  MOVFF  4C,2FA
....................    generate_message_and_send_ISR();                               
026B0:  MOVLB  0
026B2:  RCALL  22E8
026B4:  GOTO   28EC (RETURN)
.................... }  
.................... void send_error_msg_ISR(uint8_t command_id_in_response_to, uint16_t msg_seq) 
.................... { 
....................    prepare_prefix_and_payload_ISR(14); 
026B8:  MOVLW  0E
026BA:  MOVLB  5
026BC:  MOVWF  x8F
026BE:  MOVLB  0
026C0:  RCALL  224C
....................    payload_buff[4] = make8(msg_seq,0); 
026C2:  MOVFF  58B,2F3
026C6:  MOVLB  2
....................    payload_buff[5] = make8(msg_seq,1); 
026C8:  MOVFF  58C,2F4
026CC:  MOVLB  2
....................    payload_buff[6] = command_id_in_response_to; 
026CE:  MOVFF  58A,2F5
....................    payload_buff[7] = MSG_MOTE_ERROR_MSG; 
026D2:  MOVLW  A0
026D4:  MOVWF  xF6
....................    payload_buff[8] = make8(global_sprinkler_num, 0); 
026D6:  MOVFF  91,2F7
026DA:  MOVLB  2
....................    payload_buff[9] = make8(global_sprinkler_num, 1); 
026DC:  MOVFF  92,2F8
026E0:  MOVLB  2
....................    payload_buff[10] = make8(global_error_message_bitfield,0); 
026E2:  MOVFF  4F4,2F9
026E6:  MOVLB  2
....................    payload_buff[11] = make8(global_error_message_bitfield,1); 
026E8:  MOVFF  4F5,2FA
026EC:  MOVLB  2
....................    payload_buff[12] = make8(global_error_message_bitfield,2); 
026EE:  MOVFF  4F6,2FB
026F2:  MOVLB  2
....................    payload_buff[13] = make8(global_error_message_bitfield,3); 
026F4:  MOVFF  4F7,2FC
026F8:  MOVLB  2
....................    generate_message_and_send_ISR(); 
026FA:  MOVLB  0
026FC:  RCALL  22E8
026FE:  GOTO   28EC (RETURN)
.................... } 
....................  
.................... #include "periph.h"                                                       
.................... // This file contains all functions definitions for the LCD and XDCR 
.................... // The globals.h file is needed 
....................  
.................... ////////////////////LCD Functions Start///////////////////////////////////////// 
....................  
.................... //************************************************************** 
.................... // These routines communicate to the 16x2 LCD display via I2C. * 
.................... // Here are the HEX codes for the 32 display positions:        * 
.................... // Line 1   00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F    * 
.................... // Line 2   40 41 42 43 44 45 46 47 48 49 4A 4B 4C 4D 4E 4F    * 
.................... //************************************************************** 
....................  
.................... void LCD_init(void)    
.................... { 
....................    output_low(LCD_RESETn);                                
*
03856:  BCF    F8C.2
....................    
....................    delay_ms(1); 
03858:  MOVLW  14
0385A:  MOVWF  00
0385C:  DECFSZ 00,F
0385E:  BRA    385C
03860:  NOP   
....................     
....................    //setup_T0_int(T0_1MS); 
....................    //while (!TMR0IF); 
....................  
....................    output_high(LCD_RESETn); 
03862:  BSF    F8C.2
....................    //setup_T0_int(T0_100MS); 
....................    //while (!TMR0IF); 
....................     
....................    delay_ms(100); 
03864:  MOVLW  64
03866:  MOVLB  5
03868:  MOVWF  x60
0386A:  MOVLB  0
0386C:  RCALL  3736
....................    i2c_start(); 
0386E:  BSF    FC5.1
03870:  BTFSC  FC5.1
03872:  BRA    3870
....................     
....................    global_lcd_enabled = !i2c_write(LCD_ADDRESS);    // (0x7C)WRITE LCD address 
03874:  BCF    xA3.0
03876:  MOVLW  7C
03878:  MOVLB  5
0387A:  MOVWF  x78
0387C:  MOVLB  0
0387E:  RCALL  3752
03880:  MOVF   01,W
03882:  BNZ   3886
03884:  BSF    xA3.0
....................    if (!global_lcd_enabled) 
03886:  BTFSC  xA3.0
03888:  BRA    3892
....................    { 
....................       i2c_stop(); 
0388A:  BSF    FC5.2
0388C:  BTFSC  FC5.2
0388E:  BRA    388C
....................       return; 
03890:  BRA    3C88
....................    } 
....................  
....................    i2c_write(0x00);              // (0x00)Control byte 
03892:  MOVLB  5
03894:  CLRF   x78
03896:  MOVLB  0
03898:  RCALL  3752
....................    i2c_write(0x38);              // (0x38)Function Set: 8 bits, 
0389A:  MOVLW  38
0389C:  MOVLB  5
0389E:  MOVWF  x78
038A0:  MOVLB  0
038A2:  RCALL  3752
....................    i2c_stop();                   //  use Instruction Table 0 
038A4:  BSF    FC5.2
038A6:  BTFSC  FC5.2
038A8:  BRA    38A6
....................    delay_cycles(255); 
038AA:  MOVLW  54
038AC:  MOVWF  00
038AE:  DECFSZ 00,F
038B0:  BRA    38AE
038B2:  BRA    38B4
....................     
....................    i2c_start(); 
038B4:  BSF    FC5.0
038B6:  BTFSC  FC5.0
038B8:  BRA    38B6
....................    i2c_write(LCD_ADDRESS);     // (0x7C)WRITE LCD address 
038BA:  MOVLW  7C
038BC:  MOVLB  5
038BE:  MOVWF  x78
038C0:  MOVLB  0
038C2:  RCALL  3752
....................    i2c_write(0x00);     // (0x00)Control byte 
038C4:  MOVLB  5
038C6:  CLRF   x78
038C8:  MOVLB  0
038CA:  RCALL  3752
....................    i2c_write(0x40);     // set CG address 0 
038CC:  MOVLW  40
038CE:  MOVLB  5
038D0:  MOVWF  x78
038D2:  MOVLB  0
038D4:  RCALL  3752
....................    i2c_stop(); 
038D6:  BSF    FC5.2
038D8:  BTFSC  FC5.2
038DA:  BRA    38D8
....................    delay_cycles(255); 
038DC:  MOVLW  54
038DE:  MOVWF  00
038E0:  DECFSZ 00,F
038E2:  BRA    38E0
038E4:  BRA    38E6
....................    
....................    i2c_start();         // define special character  
038E6:  BSF    FC5.0
038E8:  BTFSC  FC5.0
038EA:  BRA    38E8
....................    i2c_write(LCD_ADDRESS);     // WRITE LCD address 
038EC:  MOVLW  7C
038EE:  MOVLB  5
038F0:  MOVWF  x78
038F2:  MOVLB  0
038F4:  RCALL  3752
....................    i2c_write(0x40);     // Datasend 
038F6:  MOVLW  40
038F8:  MOVLB  5
038FA:  MOVWF  x78
038FC:  MOVLB  0
038FE:  RCALL  3752
....................     
.................... // special char 0 (LEV1) 
....................    i2c_write(0b00000); 
03900:  MOVLB  5
03902:  CLRF   x78
03904:  MOVLB  0
03906:  RCALL  3752
....................    i2c_write(0b00000); 
03908:  MOVLB  5
0390A:  CLRF   x78
0390C:  MOVLB  0
0390E:  RCALL  3752
....................    i2c_write(0b00000); 
03910:  MOVLB  5
03912:  CLRF   x78
03914:  MOVLB  0
03916:  RCALL  3752
....................    i2c_write(0b00000); 
03918:  MOVLB  5
0391A:  CLRF   x78
0391C:  MOVLB  0
0391E:  RCALL  3752
....................    i2c_write(0b00000); 
03920:  MOVLB  5
03922:  CLRF   x78
03924:  MOVLB  0
03926:  RCALL  3752
....................    i2c_write(0b00000); 
03928:  MOVLB  5
0392A:  CLRF   x78
0392C:  MOVLB  0
0392E:  RCALL  3752
....................    i2c_write(0b00000); 
03930:  MOVLB  5
03932:  CLRF   x78
03934:  MOVLB  0
03936:  RCALL  3752
....................    i2c_write(0b11111); 
03938:  MOVLW  1F
0393A:  MOVLB  5
0393C:  MOVWF  x78
0393E:  MOVLB  0
03940:  RCALL  3752
.................... // special char 1 (LEV2) 
....................    i2c_write(0b00000); 
03942:  MOVLB  5
03944:  CLRF   x78
03946:  MOVLB  0
03948:  RCALL  3752
....................    i2c_write(0b00000); 
0394A:  MOVLB  5
0394C:  CLRF   x78
0394E:  MOVLB  0
03950:  RCALL  3752
....................    i2c_write(0b00000); 
03952:  MOVLB  5
03954:  CLRF   x78
03956:  MOVLB  0
03958:  RCALL  3752
....................    i2c_write(0b00000); 
0395A:  MOVLB  5
0395C:  CLRF   x78
0395E:  MOVLB  0
03960:  RCALL  3752
....................    i2c_write(0b00000); 
03962:  MOVLB  5
03964:  CLRF   x78
03966:  MOVLB  0
03968:  RCALL  3752
....................    i2c_write(0b00000); 
0396A:  MOVLB  5
0396C:  CLRF   x78
0396E:  MOVLB  0
03970:  RCALL  3752
....................    i2c_write(0b11111); 
03972:  MOVLW  1F
03974:  MOVLB  5
03976:  MOVWF  x78
03978:  MOVLB  0
0397A:  RCALL  3752
....................    i2c_write(0b11111); 
0397C:  MOVLW  1F
0397E:  MOVLB  5
03980:  MOVWF  x78
03982:  MOVLB  0
03984:  RCALL  3752
.................... // special char 2 (LEV4) 
....................    i2c_write(0b00000); 
03986:  MOVLB  5
03988:  CLRF   x78
0398A:  MOVLB  0
0398C:  RCALL  3752
....................    i2c_write(0b00000); 
0398E:  MOVLB  5
03990:  CLRF   x78
03992:  MOVLB  0
03994:  RCALL  3752
....................    i2c_write(0b00000); 
03996:  MOVLB  5
03998:  CLRF   x78
0399A:  MOVLB  0
0399C:  RCALL  3752
....................    i2c_write(0b00000); 
0399E:  MOVLB  5
039A0:  CLRF   x78
039A2:  MOVLB  0
039A4:  RCALL  3752
....................    i2c_write(0b00000); 
039A6:  MOVLB  5
039A8:  CLRF   x78
039AA:  MOVLB  0
039AC:  RCALL  3752
....................    i2c_write(0b11111); 
039AE:  MOVLW  1F
039B0:  MOVLB  5
039B2:  MOVWF  x78
039B4:  MOVLB  0
039B6:  RCALL  3752
....................    i2c_write(0b00000); 
039B8:  MOVLB  5
039BA:  CLRF   x78
039BC:  MOVLB  0
039BE:  RCALL  3752
....................    i2c_write(0b00000); 
039C0:  MOVLB  5
039C2:  CLRF   x78
039C4:  MOVLB  0
039C6:  RCALL  3752
.................... // special char 3 (LEV5) 
....................    i2c_write(0b00000); 
039C8:  MOVLB  5
039CA:  CLRF   x78
039CC:  MOVLB  0
039CE:  RCALL  3752
....................    i2c_write(0b00000); 
039D0:  MOVLB  5
039D2:  CLRF   x78
039D4:  MOVLB  0
039D6:  RCALL  3752
....................    i2c_write(0b00000); 
039D8:  MOVLB  5
039DA:  CLRF   x78
039DC:  MOVLB  0
039DE:  RCALL  3752
....................    i2c_write(0b00000); 
039E0:  MOVLB  5
039E2:  CLRF   x78
039E4:  MOVLB  0
039E6:  RCALL  3752
....................    i2c_write(0b11111); 
039E8:  MOVLW  1F
039EA:  MOVLB  5
039EC:  MOVWF  x78
039EE:  MOVLB  0
039F0:  RCALL  3752
....................    i2c_write(0b00000); 
039F2:  MOVLB  5
039F4:  CLRF   x78
039F6:  MOVLB  0
039F8:  RCALL  3752
....................    i2c_write(0b00000); 
039FA:  MOVLB  5
039FC:  CLRF   x78
039FE:  MOVLB  0
03A00:  RCALL  3752
....................    i2c_write(0b00000); 
03A02:  MOVLB  5
03A04:  CLRF   x78
03A06:  MOVLB  0
03A08:  RCALL  3752
.................... // special char 4 (LEV7) 
....................    i2c_write(0b00000); 
03A0A:  MOVLB  5
03A0C:  CLRF   x78
03A0E:  MOVLB  0
03A10:  RCALL  3752
....................    i2c_write(0b00000); 
03A12:  MOVLB  5
03A14:  CLRF   x78
03A16:  MOVLB  0
03A18:  RCALL  3752
....................    i2c_write(0b11111); 
03A1A:  MOVLW  1F
03A1C:  MOVLB  5
03A1E:  MOVWF  x78
03A20:  MOVLB  0
03A22:  RCALL  3752
....................    i2c_write(0b00000); 
03A24:  MOVLB  5
03A26:  CLRF   x78
03A28:  MOVLB  0
03A2A:  RCALL  3752
....................    i2c_write(0b00000); 
03A2C:  MOVLB  5
03A2E:  CLRF   x78
03A30:  MOVLB  0
03A32:  RCALL  3752
....................    i2c_write(0b00000); 
03A34:  MOVLB  5
03A36:  CLRF   x78
03A38:  MOVLB  0
03A3A:  RCALL  3752
....................    i2c_write(0b00000); 
03A3C:  MOVLB  5
03A3E:  CLRF   x78
03A40:  MOVLB  0
03A42:  RCALL  3752
....................    i2c_write(0b00000); 
03A44:  MOVLB  5
03A46:  CLRF   x78
03A48:  MOVLB  0
03A4A:  RCALL  3752
.................... // special char 5 (LEV8) 
....................    i2c_write(0b00000); 
03A4C:  MOVLB  5
03A4E:  CLRF   x78
03A50:  MOVLB  0
03A52:  RCALL  3752
....................    i2c_write(0b11111); 
03A54:  MOVLW  1F
03A56:  MOVLB  5
03A58:  MOVWF  x78
03A5A:  MOVLB  0
03A5C:  RCALL  3752
....................    i2c_write(0b00000); 
03A5E:  MOVLB  5
03A60:  CLRF   x78
03A62:  MOVLB  0
03A64:  RCALL  3752
....................    i2c_write(0b00000); 
03A66:  MOVLB  5
03A68:  CLRF   x78
03A6A:  MOVLB  0
03A6C:  RCALL  3752
....................    i2c_write(0b00000); 
03A6E:  MOVLB  5
03A70:  CLRF   x78
03A72:  MOVLB  0
03A74:  RCALL  3752
....................    i2c_write(0b00000); 
03A76:  MOVLB  5
03A78:  CLRF   x78
03A7A:  MOVLB  0
03A7C:  RCALL  3752
....................    i2c_write(0b00000); 
03A7E:  MOVLB  5
03A80:  CLRF   x78
03A82:  MOVLB  0
03A84:  RCALL  3752
....................    i2c_write(0b00000); 
03A86:  MOVLB  5
03A88:  CLRF   x78
03A8A:  MOVLB  0
03A8C:  RCALL  3752
.................... // special char 6 (LEV9) 
....................    i2c_write(0b11111); 
03A8E:  MOVLW  1F
03A90:  MOVLB  5
03A92:  MOVWF  x78
03A94:  MOVLB  0
03A96:  RCALL  3752
....................    i2c_write(0b11111); 
03A98:  MOVLW  1F
03A9A:  MOVLB  5
03A9C:  MOVWF  x78
03A9E:  MOVLB  0
03AA0:  RCALL  3752
....................    i2c_write(0b00000); 
03AA2:  MOVLB  5
03AA4:  CLRF   x78
03AA6:  MOVLB  0
03AA8:  RCALL  3752
....................    i2c_write(0b00000); 
03AAA:  MOVLB  5
03AAC:  CLRF   x78
03AAE:  MOVLB  0
03AB0:  RCALL  3752
....................    i2c_write(0b00000); 
03AB2:  MOVLB  5
03AB4:  CLRF   x78
03AB6:  MOVLB  0
03AB8:  RCALL  3752
....................    i2c_write(0b00000); 
03ABA:  MOVLB  5
03ABC:  CLRF   x78
03ABE:  MOVLB  0
03AC0:  RCALL  3752
....................    i2c_write(0b00000); 
03AC2:  MOVLB  5
03AC4:  CLRF   x78
03AC6:  MOVLB  0
03AC8:  RCALL  3752
....................    i2c_write(0b00000); 
03ACA:  MOVLB  5
03ACC:  CLRF   x78
03ACE:  MOVLB  0
03AD0:  RCALL  3752
....................    // special char 7 (BIGBOX) 
....................    i2c_write(0b11111); 
03AD2:  MOVLW  1F
03AD4:  MOVLB  5
03AD6:  MOVWF  x78
03AD8:  MOVLB  0
03ADA:  RCALL  3752
....................    i2c_write(0b11111); 
03ADC:  MOVLW  1F
03ADE:  MOVLB  5
03AE0:  MOVWF  x78
03AE2:  MOVLB  0
03AE4:  RCALL  3752
....................    i2c_write(0b11111); 
03AE6:  MOVLW  1F
03AE8:  MOVLB  5
03AEA:  MOVWF  x78
03AEC:  MOVLB  0
03AEE:  RCALL  3752
....................    i2c_write(0b11111); 
03AF0:  MOVLW  1F
03AF2:  MOVLB  5
03AF4:  MOVWF  x78
03AF6:  MOVLB  0
03AF8:  RCALL  3752
....................    i2c_write(0b11111); 
03AFA:  MOVLW  1F
03AFC:  MOVLB  5
03AFE:  MOVWF  x78
03B00:  MOVLB  0
03B02:  RCALL  3752
....................    i2c_write(0b11111); 
03B04:  MOVLW  1F
03B06:  MOVLB  5
03B08:  MOVWF  x78
03B0A:  MOVLB  0
03B0C:  RCALL  3752
....................    i2c_write(0b11111); 
03B0E:  MOVLW  1F
03B10:  MOVLB  5
03B12:  MOVWF  x78
03B14:  MOVLB  0
03B16:  RCALL  3752
....................    i2c_write(0b00000);  
03B18:  MOVLB  5
03B1A:  CLRF   x78
03B1C:  MOVLB  0
03B1E:  RCALL  3752
....................   
....................    i2c_stop();  
03B20:  BSF    FC5.2
03B22:  BTFSC  FC5.2
03B24:  BRA    3B22
....................  
....................    i2c_start(); 
03B26:  BSF    FC5.0
03B28:  BTFSC  FC5.0
03B2A:  BRA    3B28
....................    i2c_write(0x00);              // (0x00)Control byte 
03B2C:  MOVLB  5
03B2E:  CLRF   x78
03B30:  MOVLB  0
03B32:  RCALL  3752
....................    i2c_write(0x38);              // (0x38)Function Set: 8 bits, 
03B34:  MOVLW  38
03B36:  MOVLB  5
03B38:  MOVWF  x78
03B3A:  MOVLB  0
03B3C:  RCALL  3752
....................    i2c_stop();                   //  use Instruction Table 0 
03B3E:  BSF    FC5.2
03B40:  BTFSC  FC5.2
03B42:  BRA    3B40
....................     
....................    i2c_stop();  
03B44:  BSF    FC5.2
03B46:  BTFSC  FC5.2
03B48:  BRA    3B46
....................    delay_cycles(255); 
03B4A:  MOVLW  54
03B4C:  MOVWF  00
03B4E:  DECFSZ 00,F
03B50:  BRA    3B4E
03B52:  BRA    3B54
....................     
....................    i2c_start();                             
03B54:  BSF    FC5.0
03B56:  BTFSC  FC5.0
03B58:  BRA    3B56
....................    i2c_write(LCD_ADDRESS);     // (0x7C)WRITE LCD address 
03B5A:  MOVLW  7C
03B5C:  MOVLB  5
03B5E:  MOVWF  x78
03B60:  MOVLB  0
03B62:  RCALL  3752
....................    i2c_write(0x00);     // (0x00)Control byte 
03B64:  MOVLB  5
03B66:  CLRF   x78
03B68:  MOVLB  0
03B6A:  RCALL  3752
....................    i2c_write(0x38);     // (0x38)Function Set: 8 bits, use Instruction Table 0 
03B6C:  MOVLW  38
03B6E:  MOVLB  5
03B70:  MOVWF  x78
03B72:  MOVLB  0
03B74:  RCALL  3752
.................... //   delay_ms(40); 
....................    delay_cycles(255); 
03B76:  MOVLW  54
03B78:  MOVWF  00
03B7A:  DECFSZ 00,F
03B7C:  BRA    3B7A
03B7E:  BRA    3B80
....................    i2c_write(0x39);     // (0x39)Function Set: 8 bits, use Instruction Table 1 
03B80:  MOVLW  39
03B82:  MOVLB  5
03B84:  MOVWF  x78
03B86:  MOVLB  0
03B88:  RCALL  3752
.................... //   delay_ms(40); 
....................    delay_cycles(255); 
03B8A:  MOVLW  54
03B8C:  MOVWF  00
03B8E:  DECFSZ 00,F
03B90:  BRA    3B8E
03B92:  BRA    3B94
....................    i2c_write(0x14);     // (0x14)Internal OSC frequency 
03B94:  MOVLW  14
03B96:  MOVLB  5
03B98:  MOVWF  x78
03B9A:  MOVLB  0
03B9C:  RCALL  3752
....................    i2c_write(0x74);     // (0x78 recommended, JG prefers 0x74)Contrast set 
03B9E:  MOVLW  74
03BA0:  MOVLB  5
03BA2:  MOVWF  x78
03BA4:  MOVLB  0
03BA6:  RCALL  3752
....................    i2c_write(0x5E);     // (0x5E)ICON display ON, booster ON 
03BA8:  MOVLW  5E
03BAA:  MOVLB  5
03BAC:  MOVWF  x78
03BAE:  MOVLB  0
03BB0:  RCALL  3752
....................    i2c_write(0x6D);     // (0x6D)Follower circuit ON 
03BB2:  MOVLW  6D
03BB4:  MOVLB  5
03BB6:  MOVWF  x78
03BB8:  MOVLB  0
03BBA:  RCALL  3752
.................... //   delay_ms(200); 
....................    delay_cycles(255); 
03BBC:  MOVLW  54
03BBE:  MOVWF  00
03BC0:  DECFSZ 00,F
03BC2:  BRA    3BC0
03BC4:  BRA    3BC6
....................    i2c_write(0x0C);     // (0x0C)Entire display ON;  
03BC6:  MOVLW  0C
03BC8:  MOVLB  5
03BCA:  MOVWF  x78
03BCC:  MOVLB  0
03BCE:  RCALL  3752
....................                         // (0x0F)Entire display ON/blink at cursor 
....................    i2c_write(0x01);     // (0x01)Clear display 
03BD0:  MOVLW  01
03BD2:  MOVLB  5
03BD4:  MOVWF  x78
03BD6:  MOVLB  0
03BD8:  RCALL  3752
....................    delay_ms(40); 
03BDA:  MOVLW  28
03BDC:  MOVLB  5
03BDE:  MOVWF  x60
03BE0:  MOVLB  0
03BE2:  RCALL  3736
....................    i2c_write(0x06);     // (0x06)Entry Mode Set 
03BE4:  MOVLW  06
03BE6:  MOVLB  5
03BE8:  MOVWF  x78
03BEA:  MOVLB  0
03BEC:  RCALL  3752
.................... //   delay_ms(40); 
....................    delay_cycles(255); 
03BEE:  MOVLW  54
03BF0:  MOVWF  00
03BF2:  DECFSZ 00,F
03BF4:  BRA    3BF2
03BF6:  BRA    3BF8
....................    i2c_write(0x38); 
03BF8:  MOVLW  38
03BFA:  MOVLB  5
03BFC:  MOVWF  x78
03BFE:  MOVLB  0
03C00:  RCALL  3752
.................... //   delay_ms(40); 
....................    delay_cycles(255); 
03C02:  MOVLW  54
03C04:  MOVWF  00
03C06:  DECFSZ 00,F
03C08:  BRA    3C06
03C0A:  BRA    3C0C
....................    i2c_stop(); 
03C0C:  BSF    FC5.2
03C0E:  BTFSC  FC5.2
03C10:  BRA    3C0E
....................     
....................  
....................    i2c_start(); 
03C12:  BSF    FC5.0
03C14:  BTFSC  FC5.0
03C16:  BRA    3C14
....................    i2c_write(LCD_ADDRESS);     // (0x7C)WRITE LCD address 
03C18:  MOVLW  7C
03C1A:  MOVLB  5
03C1C:  MOVWF  x78
03C1E:  MOVLB  0
03C20:  RCALL  3752
....................    i2c_write(0x00);     // (0x00)Control byte 
03C22:  MOVLB  5
03C24:  CLRF   x78
03C26:  MOVLB  0
03C28:  RCALL  3752
....................    i2c_write(0x38);     // (0x38)Function Set: 8 bits, 
03C2A:  MOVLW  38
03C2C:  MOVLB  5
03C2E:  MOVWF  x78
03C30:  MOVLB  0
03C32:  RCALL  3752
....................                         //  use Instruction Table 0 
....................    i2c_write(0x18);     // Clear any shift 
03C34:  MOVLW  18
03C36:  MOVLB  5
03C38:  MOVWF  x78
03C3A:  MOVLB  0
03C3C:  RCALL  3752
....................    i2c_write(0x20);     // CGRAM = 0 
03C3E:  MOVLW  20
03C40:  MOVLB  5
03C42:  MOVWF  x78
03C44:  MOVLB  0
03C46:  RCALL  3752
....................    // JG Jan 30 2015 
....................    i2c_write(0x38); 
03C48:  MOVLW  38
03C4A:  MOVLB  5
03C4C:  MOVWF  x78
03C4E:  MOVLB  0
03C50:  RCALL  3752
....................     
....................    i2c_stop(); 
03C52:  BSF    FC5.2
03C54:  BTFSC  FC5.2
03C56:  BRA    3C54
....................     
....................    strcpy (global_temp_line_buff, "                "); 
03C58:  CLRF   FEA
03C5A:  MOVLW  70
03C5C:  MOVWF  FE9
03C5E:  MOVLW  00
03C60:  CALL   04CA
03C64:  TBLRD*-
03C66:  TBLRD*+
03C68:  MOVF   FF5,W
03C6A:  MOVWF  FEE
03C6C:  IORLW  00
03C6E:  BNZ   3C66
....................    LCD_line1(global_temp_line_buff); 
03C70:  MOVLB  5
03C72:  CLRF   x60
03C74:  MOVLW  70
03C76:  MOVWF  x5F
03C78:  MOVLB  0
03C7A:  RCALL  37A0
....................    LCD_line2(global_temp_line_buff); 
03C7C:  MOVLB  5
03C7E:  CLRF   x60
03C80:  MOVLW  70
03C82:  MOVWF  x5F
03C84:  MOVLB  0
03C86:  RCALL  37FA
....................  
....................    return; 
03C88:  RETURN 0
.................... } 
....................  
.................... void LCD_line1(unsigned char *text) 
.................... { 
....................    uint8_t  n; 
....................  
....................    if (!global_lcd_enabled) return;   
*
037A0:  BTFSS  xA3.0
037A2:  BRA    37F8
....................    LCD_position(0x00);   // Move to start of first line 
037A4:  MOVLB  5
037A6:  CLRF   x76
037A8:  MOVLB  0
037AA:  RCALL  376E
....................    i2c_start(); 
037AC:  BSF    FC5.0
037AE:  BTFSC  FC5.0
037B0:  BRA    37AE
....................    i2c_write(LCD_ADDRESS);   // WRITE LCD address 
037B2:  MOVLW  7C
037B4:  MOVLB  5
037B6:  MOVWF  x78
037B8:  MOVLB  0
037BA:  RCALL  3752
....................    i2c_write(0x40);    // Datasend 
037BC:  MOVLW  40
037BE:  MOVLB  5
037C0:  MOVWF  x78
037C2:  MOVLB  0
037C4:  RCALL  3752
....................    for(n=0;n<16;n++) 
037C6:  MOVLB  5
037C8:  CLRF   x61
037CA:  MOVF   x61,W
037CC:  SUBLW  0F
037CE:  BNC   37F0
....................    { 
....................       i2c_write(*text); 
037D0:  MOVFF  560,03
037D4:  MOVFF  55F,FE9
037D8:  MOVFF  560,FEA
037DC:  MOVFF  FEF,578
037E0:  MOVLB  0
037E2:  RCALL  3752
....................       ++text; 
037E4:  MOVLB  5
037E6:  INCF   x5F,F
037E8:  BTFSC  FD8.2
037EA:  INCF   x60,F
037EC:  INCF   x61,F
037EE:  BRA    37CA
....................    } 
....................    i2c_stop(); 
037F0:  BSF    FC5.2
037F2:  BTFSC  FC5.2
037F4:  BRA    37F2
037F6:  MOVLB  0
037F8:  RETURN 0
.................... } 
....................  
.................... void LCD_line2(unsigned char *text) 
.................... { 
....................    uint8_t  n; 
....................     
....................    if (!global_lcd_enabled) return; 
037FA:  BTFSS  xA3.0
037FC:  BRA    3854
....................    LCD_position(0x40);   // Move to start of second line 
037FE:  MOVLW  40
03800:  MOVLB  5
03802:  MOVWF  x76
03804:  MOVLB  0
03806:  RCALL  376E
....................    i2c_start(); 
03808:  BSF    FC5.0
0380A:  BTFSC  FC5.0
0380C:  BRA    380A
....................    i2c_write(LCD_ADDRESS);   // WRITE LCD address 
0380E:  MOVLW  7C
03810:  MOVLB  5
03812:  MOVWF  x78
03814:  MOVLB  0
03816:  RCALL  3752
....................    i2c_write(0x40);    // Datasend 
03818:  MOVLW  40
0381A:  MOVLB  5
0381C:  MOVWF  x78
0381E:  MOVLB  0
03820:  RCALL  3752
....................    for(n=0;n<16;n++) 
03822:  MOVLB  5
03824:  CLRF   x61
03826:  MOVF   x61,W
03828:  SUBLW  0F
0382A:  BNC   384C
....................    { 
....................       i2c_write(*text); 
0382C:  MOVFF  560,03
03830:  MOVFF  55F,FE9
03834:  MOVFF  560,FEA
03838:  MOVFF  FEF,578
0383C:  MOVLB  0
0383E:  RCALL  3752
....................       ++text; 
03840:  MOVLB  5
03842:  INCF   x5F,F
03844:  BTFSC  FD8.2
03846:  INCF   x60,F
03848:  INCF   x61,F
0384A:  BRA    3826
....................    } 
....................    i2c_stop(); 
0384C:  BSF    FC5.2
0384E:  BTFSC  FC5.2
03850:  BRA    384E
03852:  MOVLB  0
03854:  RETURN 0
.................... } 
....................  
.................... void LCD_place_text(unsigned char *text, int1 row, uint8_t col, uint8_t length) 
.................... { 
....................    //places text at a particular position (row (0 or 1), col (0-15)). 
....................    //not much error checking (for speed) on row/col or length (don't cause seg fault) 
....................     
....................    uint8_t n; 
....................     
....................    if (!global_lcd_enabled) return; 
*
067A0:  BTFSS  xA3.0
067A2:  BRA    6826
....................    if (col < 16) 
067A4:  MOVLB  5
067A6:  MOVF   x72,W
067A8:  SUBLW  0F
067AA:  BNC   6824
....................    { 
....................       if (row == 0) LCD_position(col);   //set LCD position (row,col) 
067AC:  MOVF   x71,F
067AE:  BNZ   67BE
067B0:  MOVFF  572,576
067B4:  MOVLB  0
067B6:  CALL   376E
067BA:  BRA    67CC
067BC:  MOVLB  5
....................       else LCD_position(0x40 + col); 
067BE:  MOVLW  40
067C0:  ADDWF  x72,W
067C2:  MOVWF  x75
067C4:  MOVWF  x76
067C6:  MOVLB  0
067C8:  CALL   376E
....................        
....................       i2c_start(); 
067CC:  BSF    FC5.0
067CE:  BTFSC  FC5.0
067D0:  BRA    67CE
....................       i2c_write(LCD_ADDRESS);   // WRITE LCD address 
067D2:  MOVLW  7C
067D4:  MOVLB  5
067D6:  MOVWF  x78
067D8:  MOVLB  0
067DA:  CALL   3752
....................       i2c_write(0x40);    // Datasend 
067DE:  MOVLW  40
067E0:  MOVLB  5
067E2:  MOVWF  x78
067E4:  MOVLB  0
067E6:  CALL   3752
....................       for(n = 0; ((n < length) && ((n + col) < 16)); n++) 
067EA:  MOVLB  5
067EC:  CLRF   x74
067EE:  MOVF   x73,W
067F0:  SUBWF  x74,W
067F2:  BC    681E
067F4:  MOVF   x72,W
067F6:  ADDWF  x74,W
067F8:  SUBLW  0F
067FA:  BNC   681E
....................       { 
....................         i2c_write(*text); 
067FC:  MOVFF  570,03
06800:  MOVFF  56F,FE9
06804:  MOVFF  570,FEA
06808:  MOVFF  FEF,578
0680C:  MOVLB  0
0680E:  CALL   3752
....................         ++text; 
06812:  MOVLB  5
06814:  INCF   x6F,F
06816:  BTFSC  FD8.2
06818:  INCF   x70,F
0681A:  INCF   x74,F
0681C:  BRA    67EE
....................       } 
....................       i2c_stop(); 
0681E:  BSF    FC5.2
06820:  BTFSC  FC5.2
06822:  BRA    6820
06824:  MOVLB  0
....................    } 
06826:  RETURN 0
.................... } 
....................  
.................... void LCD_place_char(char ascii, int1 row, uint8_t col) 
.................... { 
....................    //places a char at a particular position (row (0 or 1), col (0-15)). 
....................    //no error checking (for speed) on row/col (don't cause seg fault) 
....................     
....................    if (!global_lcd_enabled) return; 
*
04B72:  BTFSS  xA3.0
04B74:  BRA    4BA4
....................    if (col < 16) 
04B76:  MOVLB  5
04B78:  MOVF   x58,W
04B7A:  SUBLW  0F
04B7C:  BNC   4BA6
....................    { 
....................       if (row == 0) LCD_position(col);   //set LCD position (row,col) 
04B7E:  MOVF   x57,F
04B80:  BNZ   4B90
04B82:  MOVFF  558,576
04B86:  MOVLB  0
04B88:  CALL   376E
04B8C:  BRA    4B9E
04B8E:  MOVLB  5
....................       else LCD_position(0x40 + col); 
04B90:  MOVLW  40
04B92:  ADDWF  x58,W
04B94:  MOVWF  x59
04B96:  MOVWF  x76
04B98:  MOVLB  0
04B9A:  CALL   376E
....................        
....................       LCD_char(ascii); 
04B9E:  MOVFF  556,559
04BA2:  BRA    4B3E
04BA4:  MOVLB  5
....................    } 
04BA6:  MOVLB  0
04BA8:  RETURN 0
.................... } 
....................  
.................... void LCD_place_uint8(uint8_t num, int1 row, uint8_t col, uint8_t length) 
.................... { 
....................    uint8_t n;  
....................     
....................    if (!global_lcd_enabled) return;   
*
06902:  BTFSS  xA3.0
06904:  BRA    6990
....................     
....................    if (length <= 3) 
06906:  MOVLB  5
06908:  MOVF   x63,W
0690A:  SUBLW  03
0690C:  BNC   6992
....................    { 
....................       for (n = 0; n < 3; n++) 
0690E:  CLRF   x64
06910:  MOVF   x64,W
06912:  SUBLW  02
06914:  BNC   6956
....................       { 
....................          *(global_temp_line_buff + (2 - n)) = ('0' + (num%10)); 
06916:  MOVLW  02
06918:  BSF    FD8.0
0691A:  SUBFWB x64,W
0691C:  ADDLW  70
0691E:  MOVWF  01
06920:  CLRF   03
06922:  BTFSC  FD8.0
06924:  INCF   03,F
06926:  MOVWF  FE9
06928:  MOVFF  03,FEA
0692C:  MOVFF  560,567
06930:  MOVLW  0A
06932:  MOVWF  x68
06934:  MOVLB  0
06936:  RCALL  68D6
06938:  MOVF   00,W
0693A:  ADDLW  30
0693C:  MOVWF  FEF
....................          num/=10; 
0693E:  MOVFF  560,567
06942:  MOVLW  0A
06944:  MOVLB  5
06946:  MOVWF  x68
06948:  MOVLB  0
0694A:  RCALL  68D6
0694C:  MOVFF  01,560
06950:  MOVLB  5
06952:  INCF   x64,F
06954:  BRA    6910
....................       } 
....................       global_extra_lcd_ptr = global_temp_line_buff; 
06956:  MOVLB  0
06958:  CLRF   x82
0695A:  MOVLW  70
0695C:  MOVWF  x81
....................       for (n = length; n < 3; n++) 
0695E:  MOVFF  563,564
06962:  MOVLB  5
06964:  MOVF   x64,W
06966:  SUBLW  02
06968:  BNC   6978
....................       { 
....................          ++global_extra_lcd_ptr; 
0696A:  MOVLB  0
0696C:  INCF   x81,F
0696E:  BTFSC  FD8.2
06970:  INCF   x82,F
06972:  MOVLB  5
06974:  INCF   x64,F
06976:  BRA    6964
....................       } 
....................        
....................       LCD_place_text(global_extra_lcd_ptr,row, col, length); 
06978:  MOVFF  82,570
0697C:  MOVFF  81,56F
06980:  MOVFF  561,571
06984:  MOVFF  562,572
06988:  MOVFF  563,573
0698C:  MOVLB  0
0698E:  RCALL  67A0
06990:  MOVLB  5
....................    }    
06992:  MOVLB  0
06994:  RETURN 0
.................... } 
....................  
.................... void LCD_place_uint16(uint16_t num, int1 row, uint8_t col, uint8_t length) 
.................... { 
....................    uint8_t n;   
....................    char *global_temp_line_buff[5]; 
....................     
....................    if (!global_lcd_enabled) return;   
*
06828:  BTFSS  xA3.0
0682A:  BRA    68D0
....................     
....................    if (length <= 5) 
0682C:  MOVLB  5
0682E:  MOVF   x63,W
06830:  SUBLW  05
06832:  BNC   68D2
....................    { 
....................       for (n = 0; n < 5; n++) 
06834:  CLRF   x64
06836:  MOVF   x64,W
06838:  SUBLW  04
0683A:  BNC   6894
....................       { 
....................          *(global_temp_line_buff + (4 - n)) = ('0' + (num%10)); 
0683C:  MOVLW  04
0683E:  BSF    FD8.0
06840:  SUBFWB x64,W
06842:  ADDLW  65
06844:  MOVWF  01
06846:  MOVLW  05
06848:  MOVWF  03
0684A:  BTFSC  FD8.0
0684C:  INCF   03,F
0684E:  MOVFF  01,FE9
06852:  MOVFF  03,FEA
06856:  MOVFF  560,572
0685A:  MOVFF  55F,571
0685E:  CLRF   x74
06860:  MOVLW  0A
06862:  MOVWF  x73
06864:  MOVLB  0
06866:  CALL   4174
0686A:  MOVF   00,W
0686C:  ADDLW  30
0686E:  MOVWF  FEF
....................          num/=10; 
06870:  MOVFF  560,572
06874:  MOVFF  55F,571
06878:  MOVLB  5
0687A:  CLRF   x74
0687C:  MOVLW  0A
0687E:  MOVWF  x73
06880:  MOVLB  0
06882:  CALL   4174
06886:  MOVFF  02,560
0688A:  MOVFF  01,55F
0688E:  MOVLB  5
06890:  INCF   x64,F
06892:  BRA    6836
....................       } 
....................       global_extra_lcd_ptr = global_temp_line_buff; 
06894:  MOVLW  05
06896:  MOVLB  0
06898:  MOVWF  x82
0689A:  MOVLW  65
0689C:  MOVWF  x81
....................       for (n = length; n < 5; n++) 
0689E:  MOVFF  563,564
068A2:  MOVLB  5
068A4:  MOVF   x64,W
068A6:  SUBLW  04
068A8:  BNC   68B8
....................       { 
....................          ++global_extra_lcd_ptr; 
068AA:  MOVLB  0
068AC:  INCF   x81,F
068AE:  BTFSC  FD8.2
068B0:  INCF   x82,F
068B2:  MOVLB  5
068B4:  INCF   x64,F
068B6:  BRA    68A4
....................       } 
....................        
....................       LCD_place_text(global_extra_lcd_ptr,row, col, length); 
068B8:  MOVFF  82,570
068BC:  MOVFF  81,56F
068C0:  MOVFF  561,571
068C4:  MOVFF  562,572
068C8:  MOVFF  563,573
068CC:  MOVLB  0
068CE:  RCALL  67A0
068D0:  MOVLB  5
....................    }    
068D2:  MOVLB  0
068D4:  RETURN 0
.................... } 
....................  
.................... void LCD_place_uint32(uint32_t num, int1 row, uint8_t col, uint8_t length) 
.................... { 
....................    uint8_t n;   
....................     
....................    if (!global_lcd_enabled) return;   
*
06996:  BTFSS  xA3.0
06998:  BRA    6AB0
....................     
....................    if (length <= 10) 
0699A:  MOVLB  5
0699C:  MOVF   x58,W
0699E:  SUBLW  0A
069A0:  BTFSS  FD8.0
069A2:  BRA    6AB2
....................    { 
....................       for (n = 0; n < 10; n++) 
069A4:  CLRF   x59
069A6:  MOVF   x59,W
069A8:  SUBLW  09
069AA:  BNC   6A76
....................       { 
....................          *(global_temp_line_buff + (9 - n)) = ('0' + (num%10)); 
069AC:  MOVLW  09
069AE:  BSF    FD8.0
069B0:  SUBFWB x59,W
069B2:  ADDLW  70
069B4:  MOVWF  01
069B6:  CLRF   03
069B8:  BTFSC  FD8.0
069BA:  INCF   03,F
069BC:  MOVWF  x5A
069BE:  MOVFF  03,55B
069C2:  MOVFF  FEA,55D
069C6:  MOVFF  FE9,55C
069CA:  BSF    FD8.1
069CC:  MOVLW  05
069CE:  MOVWF  FEA
069D0:  MOVLW  5E
069D2:  MOVWF  FE9
069D4:  CLRF   19
069D6:  BTFSC  FF2.7
069D8:  BSF    19.7
069DA:  BCF    FF2.7
069DC:  MOVFF  555,5A0
069E0:  MOVFF  554,59F
069E4:  MOVFF  553,59E
069E8:  MOVFF  552,59D
069EC:  CLRF   xA4
069EE:  CLRF   xA3
069F0:  CLRF   xA2
069F2:  MOVLW  0A
069F4:  MOVWF  xA1
069F6:  MOVLB  0
069F8:  CALL   23C0
069FC:  BTFSC  19.7
069FE:  BSF    FF2.7
06A00:  MOVFF  55E,00
06A04:  MOVFF  55F,01
06A08:  MOVFF  560,02
06A0C:  MOVFF  561,03
06A10:  MOVFF  55D,FEA
06A14:  MOVFF  55C,FE9
06A18:  MOVLW  30
06A1A:  ADDWF  00,F
06A1C:  MOVLW  00
06A1E:  ADDWFC 01,F
06A20:  ADDWFC 02,F
06A22:  ADDWFC 03,F
06A24:  MOVFF  55B,FEA
06A28:  MOVFF  55A,FE9
06A2C:  MOVFF  00,FEF
....................          num/=10; 
06A30:  BCF    FD8.1
06A32:  CLRF   19
06A34:  BTFSC  FF2.7
06A36:  BSF    19.7
06A38:  BCF    FF2.7
06A3A:  MOVFF  555,5A0
06A3E:  MOVFF  554,59F
06A42:  MOVFF  553,59E
06A46:  MOVFF  552,59D
06A4A:  MOVLB  5
06A4C:  CLRF   xA4
06A4E:  CLRF   xA3
06A50:  CLRF   xA2
06A52:  MOVLW  0A
06A54:  MOVWF  xA1
06A56:  MOVLB  0
06A58:  CALL   23C0
06A5C:  BTFSC  19.7
06A5E:  BSF    FF2.7
06A60:  MOVFF  03,555
06A64:  MOVFF  02,554
06A68:  MOVFF  01,553
06A6C:  MOVFF  00,552
06A70:  MOVLB  5
06A72:  INCF   x59,F
06A74:  BRA    69A6
....................       } 
....................       global_extra_lcd_ptr = global_temp_line_buff; 
06A76:  MOVLB  0
06A78:  CLRF   x82
06A7A:  MOVLW  70
06A7C:  MOVWF  x81
....................       for (n = length; n < 10; n++) 
06A7E:  MOVFF  558,559
06A82:  MOVLB  5
06A84:  MOVF   x59,W
06A86:  SUBLW  09
06A88:  BNC   6A98
....................       { 
....................          ++global_extra_lcd_ptr; 
06A8A:  MOVLB  0
06A8C:  INCF   x81,F
06A8E:  BTFSC  FD8.2
06A90:  INCF   x82,F
06A92:  MOVLB  5
06A94:  INCF   x59,F
06A96:  BRA    6A84
....................       } 
....................        
....................       LCD_place_text(global_extra_lcd_ptr,row, col, length); 
06A98:  MOVFF  82,570
06A9C:  MOVFF  81,56F
06AA0:  MOVFF  556,571
06AA4:  MOVFF  557,572
06AA8:  MOVFF  558,573
06AAC:  MOVLB  0
06AAE:  RCALL  67A0
06AB0:  MOVLB  5
....................    }    
06AB2:  MOVLB  0
06AB4:  RETURN 0
.................... } 
....................  
.................... void LCD_clear(void) 
.................... { 
....................    if (!global_lcd_enabled) return; 
*
05C08:  BTFSS  xA3.0
05C0A:  BRA    5C40
....................     
....................    strcpy (global_temp_line_buff, "                "); 
05C0C:  CLRF   FEA
05C0E:  MOVLW  70
05C10:  MOVWF  FE9
05C12:  MOVLW  00
05C14:  CALL   04CA
05C18:  TBLRD*-
05C1A:  TBLRD*+
05C1C:  MOVF   FF5,W
05C1E:  MOVWF  FEE
05C20:  IORLW  00
05C22:  BNZ   5C1A
....................    LCD_line1(global_temp_line_buff); 
05C24:  MOVLB  5
05C26:  CLRF   x60
05C28:  MOVLW  70
05C2A:  MOVWF  x5F
05C2C:  MOVLB  0
05C2E:  CALL   37A0
....................    LCD_line2(global_temp_line_buff); 
05C32:  MOVLB  5
05C34:  CLRF   x60
05C36:  MOVLW  70
05C38:  MOVWF  x5F
05C3A:  MOVLB  0
05C3C:  CALL   37FA
05C40:  RETURN 0
.................... } 
....................  
.................... void LCD_clear_line1(void) 
.................... { 
....................    if (!global_lcd_enabled) return; 
....................     
....................    strcpy (global_temp_line_buff, "                "); 
....................    LCD_line1(global_temp_line_buff); 
.................... } 
....................  
.................... void LCD_clear_line2(void) 
.................... { 
....................    if (!global_lcd_enabled) return; 
....................     
....................    strcpy (global_temp_line_buff, "                "); 
....................    LCD_line2(global_temp_line_buff); 
.................... } 
....................  
.................... void LCD_position(int position) 
.................... { 
....................    if (!global_lcd_enabled) return; 
*
0376E:  BTFSS  xA3.0
03770:  BRA    379E
....................    i2c_start();                             
03772:  BSF    FC5.0
03774:  BTFSC  FC5.0
03776:  BRA    3774
....................    i2c_write(LCD_ADDRESS);     // (0x7C)WRITE LCD address 
03778:  MOVLW  7C
0377A:  MOVLB  5
0377C:  MOVWF  x78
0377E:  MOVLB  0
03780:  RCALL  3752
....................    i2c_write(0x00);     // (0x00)Control byte 
03782:  MOVLB  5
03784:  CLRF   x78
03786:  MOVLB  0
03788:  RCALL  3752
....................    i2c_write(0x80+position); //  
0378A:  MOVLW  80
0378C:  MOVLB  5
0378E:  ADDWF  x76,W
03790:  MOVWF  x77
03792:  MOVWF  x78
03794:  MOVLB  0
03796:  RCALL  3752
....................    i2c_stop(); 
03798:  BSF    FC5.2
0379A:  BTFSC  FC5.2
0379C:  BRA    379A
0379E:  RETURN 0
.................... } 
....................  
.................... void LCD_char(char ascii)    
.................... { 
....................    if (!global_lcd_enabled) return; 
*
04B3E:  BTFSS  xA3.0
04B40:  BRA    4B6E
....................    i2c_start();                             
04B42:  BSF    FC5.0
04B44:  BTFSC  FC5.0
04B46:  BRA    4B44
....................    i2c_write(LCD_ADDRESS);   // WRITE LCD address 
04B48:  MOVLW  7C
04B4A:  MOVLB  5
04B4C:  MOVWF  x78
04B4E:  MOVLB  0
04B50:  CALL   3752
....................    i2c_write(0x40);    // Datasend 
04B54:  MOVLW  40
04B56:  MOVLB  5
04B58:  MOVWF  x78
04B5A:  MOVLB  0
04B5C:  CALL   3752
....................    i2c_write(ascii);    //  
04B60:  MOVFF  559,578
04B64:  CALL   3752
....................    i2c_stop(); 
04B68:  BSF    FC5.2
04B6A:  BTFSC  FC5.2
04B6C:  BRA    4B6A
04B6E:  GOTO   4BA4 (RETURN)
.................... } 
....................  
.................... void LCD_shutdown(void)    
.................... {        
....................  
....................    if (!global_lcd_enabled) return;   
*
093B4:  BTFSS  xA3.0
093B6:  BRA    9428
....................        
....................    output_low(LCD_RESETn); 
093B8:  BCF    F8C.2
....................    delay_ms(5); 
093BA:  MOVLW  67
093BC:  MOVWF  00
093BE:  DECFSZ 00,F
093C0:  BRA    93BE
093C2:  BRA    93C4
....................    output_high(LCD_RESETn); 
093C4:  BSF    F8C.2
....................     
....................    i2c_start();                             
093C6:  BSF    FC5.0
093C8:  BTFSC  FC5.0
093CA:  BRA    93C8
....................    i2c_write(LCD_ADDRESS);     // WRITE LCD address 
093CC:  MOVLW  7C
093CE:  MOVLB  5
093D0:  MOVWF  x78
093D2:  MOVLB  0
093D4:  CALL   3752
....................    i2c_write(0x00);     // Control byte 
093D8:  MOVLB  5
093DA:  CLRF   x78
093DC:  MOVLB  0
093DE:  CALL   3752
....................    i2c_write(0x39);     // Function Set: 8 bits, use Instruction Table 1 
093E2:  MOVLW  39
093E4:  MOVLB  5
093E6:  MOVWF  x78
093E8:  MOVLB  0
093EA:  CALL   3752
....................    i2c_write(0x52);     // ICON display OFF, booster OFF 
093EE:  MOVLW  52
093F0:  MOVLB  5
093F2:  MOVWF  x78
093F4:  MOVLB  0
093F6:  CALL   3752
....................    i2c_write(0x60);     // Follower circuit OFF 
093FA:  MOVLW  60
093FC:  MOVLB  5
093FE:  MOVWF  x78
09400:  MOVLB  0
09402:  CALL   3752
....................    i2c_write(0x08);     // Entire display OFF 
09406:  MOVLW  08
09408:  MOVLB  5
0940A:  MOVWF  x78
0940C:  MOVLB  0
0940E:  CALL   3752
....................    i2c_stop(); 
09412:  BSF    FC5.2
09414:  BTFSC  FC5.2
09416:  BRA    9414
....................     
....................    output_low(LCD_RESETn); 
09418:  BCF    F8C.2
....................    delay_ms(5); 
0941A:  MOVLW  67
0941C:  MOVWF  00
0941E:  DECFSZ 00,F
09420:  BRA    941E
09422:  BRA    9424
....................    output_high(LCD_RESETn); 
09424:  BSF    F8C.2
....................    global_lcd_enabled = 0; 
09426:  BCF    xA3.0
09428:  GOTO   94AE (RETURN)
.................... } 
....................  
.................... void LCD_startup_splash(void) 
.................... {                               
....................    uint8_t n; 
....................     
....................    if (!global_lcd_enabled) return; 
....................     
....................    strcpy(global_temp_line_buff, "Jain Genesys    "); 
....................    for (n = 0; n < 16; n++) 
....................       { 
....................       LCD_place_text(global_temp_line_buff,0,(15-n),16); 
....................       setup_T0_int(T0_100MS); 
....................       while (!TMR0IF); 
....................       } 
....................    strcpy(global_temp_line_buff, "Version         ");    
....................    for (n = 0; n < 16; n++) 
....................    { 
....................       LCD_place_text(global_temp_line_buff,1,(15-n),16); 
....................       setup_T0_int(T0_100MS); 
....................       while (!TMR0IF); 
....................    }    
....................    strcpy(global_temp_line_buff, global_firmware_version_string); 
....................    LCD_place_text(global_temp_line_buff,1,8,4); 
....................    setup_T0_int(T0_2S); 
....................    while (!TMR0IF); 
....................    for (n = 0; n < 16; n++) 
....................    { 
....................       LCD_place_char(' ',0,(15-n)); 
....................       LCD_place_char(' ',1,(15-n)); 
....................       setup_T0_int(T0_100MS); 
....................       while (!TMR0IF);  
....................    }    
.................... } 
.................... /* 
.................... void LCD_display_battery_voltage(int1 lcd_line) 
.................... { 
....................    //Grabs and displays battery voltage on LCD 
....................    //Takes the LCD line that it should be displayed 
....................    //on as input. 
....................  
....................     
....................    uint8_t temp_bat_int_part = 0; 
....................    uint16_t temp_bat_fract_part = 0; 
....................    uint32_t temp_bat_both_part = 0; 
....................    char * digit_result; 
....................     
....................    if (!global_lcd_enabled) return; 
....................    //set line buffer to all spaces 
....................    char lcd_line_buff[17] = {' '}; 
....................     
....................    strcpy (lcd_line_buff, "Battery = ?.???V"); 
....................  
....................    // get the battery count (not charging) 
....................    // and convert it to a voltage 
....................    temp_bat_both_part = calc_vbatt(get_vbatt(1)); 
....................    temp_bat_fract_part = (uint16_t) (temp_bat_both_part); 
....................    temp_bat_int_part = (uint8_t) (temp_bat_both_part >> 16); 
....................    digit_result = word_to_4dig_new(temp_bat_fract_part); 
....................     
....................     
....................    if (digit_result != 0) 
....................    { 
....................       lcd_line_buff[10] = '0' + temp_bat_int_part; 
....................       lcd_line_buff[12] = digit_result[3]; 
....................       lcd_line_buff[13] = digit_result[2]; 
....................       lcd_line_buff[14] = digit_result[1]; 
....................    } 
....................    else 
....................    { 
....................       strcpy (lcd_line_buff, "Battery ERROR!  "); 
....................    } 
....................     
....................    if (lcd_line == 0) 
....................    { 
....................       LCD_line1(lcd_line_buff); 
....................    } 
....................    else if (lcd_line == 1) 
....................    { 
....................       LCD_line2(lcd_line_buff); 
....................    } 
.................... } 
....................  
.................... uint32_t LCD_battery_screen(uint16_t vRef) 
.................... { 
.................... //Puts the battery voltage on the LCD across both screens 
.................... // 
.................... } 
....................  
....................  
.................... void LCD_display_revision(int1 lcd_line) 
.................... { 
....................    if (!global_lcd_enabled) return; 
....................    strcpy (line2_buff, "Rev.            "); 
....................    tempo_u8 = make8(FIRMWARE_REV,1); 
....................    line2_buff[4] = hi2asc(tempo_u8); 
....................     
.................... #ifdef  WIP 
....................    line2_buff[4] += 0x20;     // lowercase if work in progress 
.................... #endif 
....................    line2_buff[5] = lo2asc(tempo_u8); 
....................    tempo_u8 = make8(FIRMWARE_REV,0); 
....................    line2_buff[6] = hi2asc(tempo_u8); 
....................    line2_buff[7] = lo2asc(tempo_u8); 
....................   
.................... } 
.................... */ 
....................  
.................... void LCD_display_priority_time_stacks(void) 
.................... {                                            
....................       if (!global_lcd_enabled) return;     
....................        
....................    disable_interrupts(GLOBAL); 
....................    LCD_place_uint8(global_current_priority_queue_location, 0, 0, 3);      
....................        
....................       if (global_current_priority_queue_location != 255) 
....................       {      
....................          LCD_place_uint8(global_priority_queue[global_current_priority_queue_location], 0, 4, 3); 
....................       } 
....................       else 
....................       {       
....................          strcpy (global_temp_line_buff, "   "); 
....................          LCD_place_text(global_temp_line_buff, 0, 4, 3); 
....................       } 
....................        
....................       LCD_place_uint8(global_current_time_queue_location, 0, 8, 3); 
....................        
....................       if (global_current_time_queue_location != 255) 
....................       { 
....................          LCD_place_uint8(global_priority_queue[global_current_time_queue_location], 0, 12, 3); 
....................       } 
....................       else 
....................       {       
....................          strcpy (global_temp_line_buff, "   "); 
....................          LCD_place_text(global_temp_line_buff, 0, 12, 3); 
....................       } 
....................       enable_interrupts(GLOBAL); 
.................... }  
....................  
.................... void LCD_display_priority_time_stacks_2(void) 
.................... { 
....................    uint8_t n; 
....................     
....................    disable_interrupts(INT_CCP4); 
....................    LCD_clear(); 
....................    for (n = 0; n < MAX_TIME_QUEUE_ITEMS; n++) 
....................    { 
....................       LCD_place_uint8(n,0,0,1); 
....................       LCD_place_uint8(global_time_queue[n].pq_priority,0,2,3);                       
....................       LCD_place_uint32(global_time_queue[n].time_to_execute,0,6,5); 
....................       LCD_place_uint8(global_current_time_queue_location, 0, 12, 3);        
....................       setup_T0_int(T0_250MS);                                                       
....................       while (!TMR0IF);     
....................    }                               
....................    enable_interrupts(INT_CCP4);                                  
.................... } 
....................  
.................... void LCD_display_priority_queue(void) 
.................... { 
....................    uint8_t n; 
....................     
....................    disable_interrupts(GLOBAL); 
....................    LCD_clear(); 
....................    for (n = 0; n < MAX_PRIORITY_QUEUE_ITEMS; n++) 
....................    { 
....................       LCD_place_uint8(n,0,0,2); 
....................       LCD_place_uint8(global_priority_queue[n],0,3,3); 
....................       LCD_place_uint8(global_current_priority_queue_location, 0, 7, 3); 
....................       if (global_priority_queue[n] != EMPTY_PRIORITY_QUEUE) 
....................          setup_T0_int(T0_1S); 
....................       while (!TMR0IF); 
....................    } 
....................    enable_interrupts(GLOBAL); 
.................... } 
....................                  
.................... void LCD_display_message_queue(void)  
.................... { 
....................    uint8_t n; 
....................    disable_interrupts(INT_CCP4); 
....................     
....................    for (n = global_current_message_queue_location; n != 255; n--) 
....................    {                                                                                                                          
....................       LCD_clear(); 
....................       LCD_place_uint8(n, 0, 0, 3);                                 
....................       LCD_place_uint32(global_message_queue[n].time_to_send, 0, 4, 10); 
....................       LCD_place_uint8(global_message_queue[n].message_type, 1, 0, 3); 
....................       LCD_place_uint16(global_message_queue[n].msg_seq, 1, 4, 5);  
....................       LCD_place_uint8(global_message_queue[n].attempt_num, 1, 10, 3);  
....................       while(input(SW1n)); 
....................    }                          
....................    LCD_clear(); 
....................    enable_interrupts(INT_CCP4);   
.................... }                                                                        
.................... void LCD_display_battery_voltage(int1 lcd_line) 
.................... {                                            
....................    if (!global_lcd_enabled) return;     
*
04D44:  BTFSS  xA3.0
04D46:  BRA    4DC2
....................        
....................    uint32_t battery_voltage = calc_vbatt(get_vbatt(1)); 
04D48:  MOVLW  01
04D4A:  MOVLB  5
04D4C:  MOVWF  x66
04D4E:  MOVLB  0
04D50:  CALL   40A4
04D54:  MOVFF  02,54D
04D58:  MOVFF  01,54C
04D5C:  MOVFF  02,54F
04D60:  MOVFF  01,54E
04D64:  BRA    47DE
04D66:  MOVFF  03,54B
04D6A:  MOVFF  02,54A
04D6E:  MOVFF  01,549
04D72:  MOVFF  00,548
....................    strcpy (global_temp_line_buff, "Vbatt =      V  "); 
04D76:  CLRF   FEA
04D78:  MOVLW  70
04D7A:  MOVWF  FE9
04D7C:  MOVLW  00
04D7E:  CALL   04EC
04D82:  TBLRD*-
04D84:  TBLRD*+
04D86:  MOVF   FF5,W
04D88:  MOVWF  FEE
04D8A:  IORLW  00
04D8C:  BNZ   4D84
....................    if (lcd_line == 0) LCD_line1(global_temp_line_buff); 
04D8E:  MOVLB  5
04D90:  MOVF   x47,F
04D92:  BNZ   4DA4
04D94:  CLRF   x60
04D96:  MOVLW  70
04D98:  MOVWF  x5F
04D9A:  MOVLB  0
04D9C:  CALL   37A0
04DA0:  BRA    4DB0
04DA2:  MOVLB  5
....................    else LCD_line2(global_temp_line_buff); 
04DA4:  CLRF   x60
04DA6:  MOVLW  70
04DA8:  MOVWF  x5F
04DAA:  MOVLB  0
04DAC:  CALL   37FA
....................    LCD_display_batt_voltage(lcd_line, 8, 2); 
04DB0:  MOVFF  547,54C
04DB4:  MOVLW  08
04DB6:  MOVLB  5
04DB8:  MOVWF  x4D
04DBA:  MOVLW  02
04DBC:  MOVWF  x4E
04DBE:  MOVLB  0
04DC0:  RCALL  4BAA
04DC2:  GOTO   A1B8 (RETURN)
.................... //   LCD_place_uint8((uint8_t)(battery_voltage>>16),lcd_line,8,1); 
.................... //   LCD_place_uint16((uint16_t)battery_voltage,lcd_line,10,4); 
.................... } 
....................  
.................... void LCD_display_batt_voltage(int1 lcd_line, uint8_t col, uint8_t precision) 
.................... { 
....................    // precision is the number of digits to the right of the decimal pt 
....................    // Valid values are 1, 2, 3 
....................    // The assumption is that there is a SINGLE digit preceeding the dp 
....................     
....................    if (!global_lcd_enabled) return; 
*
04BAA:  BTFSS  xA3.0
04BAC:  BRA    4D3E
....................  
....................    if (col>15) 
04BAE:  MOVLB  5
04BB0:  MOVF   x4D,W
04BB2:  SUBLW  0F
04BB4:  BC    4BBC
....................       return; 
04BB6:  MOVLB  0
04BB8:  BRA    4D3E
04BBA:  MOVLB  5
....................    if (precision > 3) 
04BBC:  MOVF   x4E,W
04BBE:  SUBLW  03
04BC0:  BC    4BC6
....................       precision = 3;   
04BC2:  MOVLW  03
04BC4:  MOVWF  x4E
....................     
....................    if ((precision == 3) && (col > 11)) 
04BC6:  MOVF   x4E,W
04BC8:  SUBLW  03
04BCA:  BNZ   4BD4
04BCC:  MOVF   x4D,W
04BCE:  SUBLW  0B
04BD0:  BC    4BD4
....................       precision--; 
04BD2:  DECF   x4E,F
....................    if ((precision == 2) && (col > 12)) 
04BD4:  MOVF   x4E,W
04BD6:  SUBLW  02
04BD8:  BNZ   4BE2
04BDA:  MOVF   x4D,W
04BDC:  SUBLW  0C
04BDE:  BC    4BE2
....................       precision--; 
04BE0:  DECF   x4E,F
....................    if ((precision == 1) && (col > 13)) 
04BE2:  DECFSZ x4E,W
04BE4:  BRA    4BEE
04BE6:  MOVF   x4D,W
04BE8:  SUBLW  0D
04BEA:  BC    4BEE
....................       precision--; 
04BEC:  DECF   x4E,F
....................        
....................    uint16_t battery_voltage_BCD = calc_vbatt_BCD(get_vbatt(1)); 
....................  
....................    uint8_t volts = '0' + (uint8_t)(battery_voltage_BCD >> 12); 
....................    uint8_t tenths = '0' + (uint8_t)((battery_voltage_BCD & 0x0F00) >> 8); 
....................    uint8_t hundredths = '0' + (uint8_t)((battery_voltage_BCD & 0x00F0) >> 4); 
....................    uint8_t thousandths = '0' + (uint8_t)(battery_voltage_BCD & 0x000F); 
04BEE:  MOVLW  01
04BF0:  MOVWF  x66
04BF2:  MOVLB  0
04BF4:  CALL   40A4
04BF8:  MOVFF  02,556
04BFC:  MOVFF  01,555
04C00:  MOVFF  02,558
04C04:  MOVFF  01,557
04C08:  BRA    494E
04C0A:  MOVFF  02,550
04C0E:  MOVFF  01,54F
04C12:  MOVLB  5
04C14:  SWAPF  x50,W
04C16:  MOVWF  02
04C18:  CLRF   03
04C1A:  MOVLW  0F
04C1C:  ANDWF  02,F
04C1E:  MOVF   02,W
04C20:  ADDLW  30
04C22:  MOVWF  x51
04C24:  CLRF   x55
04C26:  MOVF   x50,W
04C28:  ANDLW  0F
04C2A:  MOVWF  x56
04C2C:  CLRF   03
04C2E:  ADDLW  30
04C30:  MOVWF  x52
04C32:  MOVF   x4F,W
04C34:  ANDLW  F0
04C36:  MOVWF  x55
04C38:  CLRF   x56
04C3A:  RRCF   x56,W
04C3C:  MOVWF  03
04C3E:  RRCF   x55,W
04C40:  MOVWF  02
04C42:  RRCF   03,F
04C44:  RRCF   02,F
04C46:  RRCF   03,F
04C48:  RRCF   02,F
04C4A:  RRCF   03,F
04C4C:  RRCF   02,F
04C4E:  MOVLW  0F
04C50:  ANDWF  03,F
04C52:  MOVF   02,W
04C54:  ADDLW  30
04C56:  MOVWF  x53
04C58:  MOVF   x4F,W
04C5A:  ANDLW  0F
04C5C:  MOVWF  00
04C5E:  MOVF   00,W
04C60:  ADDLW  30
04C62:  MOVWF  x54
....................    
....................    switch (precision) 
04C64:  MOVF   x4E,W
04C66:  XORLW  00
04C68:  MOVLB  0
04C6A:  BZ    4C76
04C6C:  XORLW  01
04C6E:  BZ    4C84
04C70:  XORLW  03
04C72:  BZ    4C9E
04C74:  BRA    4CC2
....................    { 
....................       case 0: 
....................          if (tenths > '5') 
04C76:  MOVLB  5
04C78:  MOVF   x52,W
04C7A:  SUBLW  35
04C7C:  BC    4C80
....................             volts++; 
04C7E:  INCF   x51,F
....................          break; 
04C80:  MOVLB  0
04C82:  BRA    4CC2
....................        
....................       case 1: 
....................          if (hundredths > '5') 
04C84:  MOVLB  5
04C86:  MOVF   x53,W
04C88:  SUBLW  35
04C8A:  BC    4C8E
....................             tenths++; 
04C8C:  INCF   x52,F
....................          if (tenths > '9' ) 
04C8E:  MOVF   x52,W
04C90:  SUBLW  39
04C92:  BC    4C9A
....................          { 
....................             volts++; 
04C94:  INCF   x51,F
....................             tenths = '0'; 
04C96:  MOVLW  30
04C98:  MOVWF  x52
....................          } 
....................          break; 
04C9A:  MOVLB  0
04C9C:  BRA    4CC2
....................  
....................       case 2: 
....................          if (thousandths > '5') 
04C9E:  MOVLB  5
04CA0:  MOVF   x54,W
04CA2:  SUBLW  35
04CA4:  BC    4CA8
....................             hundredths++; 
04CA6:  INCF   x53,F
....................          if (hundredths > '9') 
04CA8:  MOVF   x53,W
04CAA:  SUBLW  39
04CAC:  BC    4CB4
....................          { 
....................             tenths++; 
04CAE:  INCF   x52,F
....................             hundredths = '0'; 
04CB0:  MOVLW  30
04CB2:  MOVWF  x53
....................          } 
....................          if (tenths > '9') 
04CB4:  MOVF   x52,W
04CB6:  SUBLW  39
04CB8:  BC    4CC0
....................          { 
....................             volts++; 
04CBA:  INCF   x51,F
....................             tenths = '0'; 
04CBC:  MOVLW  30
04CBE:  MOVWF  x52
....................          }          
....................          break; 
04CC0:  MOVLB  0
....................    } 
....................    
....................    LCD_place_char (volts, lcd_line, col++); 
04CC2:  MOVLB  5
04CC4:  MOVF   x4D,W
04CC6:  INCF   x4D,F
04CC8:  MOVWF  x55
04CCA:  MOVFF  551,556
04CCE:  MOVFF  54C,557
04CD2:  MOVWF  x58
04CD4:  MOVLB  0
04CD6:  RCALL  4B72
....................     
....................    if (precision) 
04CD8:  MOVLB  5
04CDA:  MOVF   x4E,F
04CDC:  BZ    4D40
....................    { 
....................       LCD_place_char ('.', lcd_line, col++); 
04CDE:  MOVF   x4D,W
04CE0:  INCF   x4D,F
04CE2:  MOVWF  x55
04CE4:  MOVLW  2E
04CE6:  MOVWF  x56
04CE8:  MOVFF  54C,557
04CEC:  MOVFF  555,558
04CF0:  MOVLB  0
04CF2:  RCALL  4B72
....................       LCD_place_char (tenths, lcd_line, col++); 
04CF4:  MOVLB  5
04CF6:  MOVF   x4D,W
04CF8:  INCF   x4D,F
04CFA:  MOVWF  x55
04CFC:  MOVFF  552,556
04D00:  MOVFF  54C,557
04D04:  MOVWF  x58
04D06:  MOVLB  0
04D08:  RCALL  4B72
....................         
....................       if (precision > 1) 
04D0A:  MOVLB  5
04D0C:  MOVF   x4E,W
04D0E:  SUBLW  01
04D10:  BC    4D28
....................          LCD_place_char (hundredths, lcd_line, col++); 
04D12:  MOVF   x4D,W
04D14:  INCF   x4D,F
04D16:  MOVWF  x55
04D18:  MOVFF  553,556
04D1C:  MOVFF  54C,557
04D20:  MOVWF  x58
04D22:  MOVLB  0
04D24:  RCALL  4B72
04D26:  MOVLB  5
....................       if (precision > 2) 
04D28:  MOVF   x4E,W
04D2A:  SUBLW  02
04D2C:  BC    4D40
....................          LCD_place_char (thousandths, lcd_line, col); 
04D2E:  MOVFF  554,556
04D32:  MOVFF  54C,557
04D36:  MOVFF  54D,558
04D3A:  MOVLB  0
04D3C:  RCALL  4B72
04D3E:  MOVLB  5
....................    } 
04D40:  MOVLB  0
04D42:  RETURN 0
.................... }     
....................   
.................... void LCD_display_vgen(int1 lcd_line, uint8_t col, uint8_t precision) 
.................... { 
....................    // precision is the number of digits to the right of the decimal pt 
....................    // Valid values are 1, 2, 3 
....................    // The assumption is that there are 2 digits preceding the decimpal point 
....................     
....................    if (!global_lcd_enabled) return; 
*
084B6:  BTFSS  xA3.0
084B8:  BRA    86A2
....................  
....................    if (col>15) 
084BA:  MOVLB  5
084BC:  MOVF   x49,W
084BE:  SUBLW  0F
084C0:  BC    84C8
....................       return; 
084C2:  MOVLB  0
084C4:  BRA    86A2
084C6:  MOVLB  5
....................    if (precision > 3) 
084C8:  MOVF   x4A,W
084CA:  SUBLW  03
084CC:  BC    84D2
....................       precision = 3;   
084CE:  MOVLW  03
084D0:  MOVWF  x4A
....................     
....................    if ((precision == 3) && (col > 10)) 
084D2:  MOVF   x4A,W
084D4:  SUBLW  03
084D6:  BNZ   84E0
084D8:  MOVF   x49,W
084DA:  SUBLW  0A
084DC:  BC    84E0
....................       precision--; 
084DE:  DECF   x4A,F
....................    if ((precision == 2) && (col > 11)) 
084E0:  MOVF   x4A,W
084E2:  SUBLW  02
084E4:  BNZ   84EE
084E6:  MOVF   x49,W
084E8:  SUBLW  0B
084EA:  BC    84EE
....................       precision--; 
084EC:  DECF   x4A,F
....................    if ((precision == 1) && (col > 12)) 
084EE:  DECFSZ x4A,W
084F0:  BRA    84FA
084F2:  MOVF   x49,W
084F4:  SUBLW  0C
084F6:  BC    84FA
....................       precision--; 
084F8:  DECF   x4A,F
....................        
....................    uint16_t vgen_BCD = calc_vgen_BCD(get_vgen(0)); 
....................  
....................    uint8_t tens = '0' + (uint8_t)(vgen_BCD >> 12)/10; 
....................    uint8_t volts = '0' + (uint8_t)(vgen_BCD >> 12)%10; 
....................    uint8_t tenths = '0' + (uint8_t)((vgen_BCD & 0x0F00) >> 8); 
....................    uint8_t hundredths = '0' + (uint8_t)((vgen_BCD & 0x00F0) >> 4); 
....................    uint8_t thousandths = '0' + (uint8_t)(vgen_BCD & 0x000F); 
084FA:  CLRF   x53
084FC:  MOVLB  0
084FE:  CALL   40FE
08502:  MOVFF  02,553
08506:  MOVFF  01,552
0850A:  MOVFF  02,555
0850E:  MOVFF  01,554
08512:  BRA    82B0
08514:  MOVFF  02,54C
08518:  MOVFF  01,54B
0851C:  MOVLB  5
0851E:  SWAPF  x4C,W
08520:  MOVWF  02
08522:  CLRF   03
08524:  MOVLW  0F
08526:  ANDWF  02,F
08528:  MOVFF  02,553
0852C:  MOVFF  02,567
08530:  MOVLW  0A
08532:  MOVWF  x68
08534:  MOVLB  0
08536:  CALL   68D6
0853A:  MOVF   01,W
0853C:  ADDLW  30
0853E:  MOVLB  5
08540:  MOVWF  x4D
08542:  SWAPF  x4C,W
08544:  MOVWF  02
08546:  CLRF   03
08548:  MOVLW  0F
0854A:  ANDWF  02,F
0854C:  MOVFF  02,553
08550:  MOVFF  02,567
08554:  MOVLW  0A
08556:  MOVWF  x68
08558:  MOVLB  0
0855A:  CALL   68D6
0855E:  MOVF   00,W
08560:  ADDLW  30
08562:  MOVLB  5
08564:  MOVWF  x4E
08566:  CLRF   x52
08568:  MOVF   x4C,W
0856A:  ANDLW  0F
0856C:  MOVWF  x53
0856E:  CLRF   03
08570:  ADDLW  30
08572:  MOVWF  x4F
08574:  MOVF   x4B,W
08576:  ANDLW  F0
08578:  MOVWF  x52
0857A:  CLRF   x53
0857C:  RRCF   x53,W
0857E:  MOVWF  03
08580:  RRCF   x52,W
08582:  MOVWF  02
08584:  RRCF   03,F
08586:  RRCF   02,F
08588:  RRCF   03,F
0858A:  RRCF   02,F
0858C:  RRCF   03,F
0858E:  RRCF   02,F
08590:  MOVLW  0F
08592:  ANDWF  03,F
08594:  MOVF   02,W
08596:  ADDLW  30
08598:  MOVWF  x50
0859A:  MOVF   x4B,W
0859C:  ANDLW  0F
0859E:  MOVWF  00
085A0:  MOVF   00,W
085A2:  ADDLW  30
085A4:  MOVWF  x51
....................    
....................    switch (precision) 
085A6:  MOVF   x4A,W
085A8:  XORLW  00
085AA:  MOVLB  0
085AC:  BZ    85B8
085AE:  XORLW  01
085B0:  BZ    85C6
085B2:  XORLW  03
085B4:  BZ    85E0
085B6:  BRA    8604
....................    { 
....................       case 0: 
....................          if (tenths > '5') 
085B8:  MOVLB  5
085BA:  MOVF   x4F,W
085BC:  SUBLW  35
085BE:  BC    85C2
....................             volts++; 
085C0:  INCF   x4E,F
....................          break; 
085C2:  MOVLB  0
085C4:  BRA    8604
....................        
....................       case 1: 
....................          if (hundredths > '5') 
085C6:  MOVLB  5
085C8:  MOVF   x50,W
085CA:  SUBLW  35
085CC:  BC    85D0
....................             tenths++; 
085CE:  INCF   x4F,F
....................          if (tenths > '9' ) 
085D0:  MOVF   x4F,W
085D2:  SUBLW  39
085D4:  BC    85DC
....................          { 
....................             volts++; 
085D6:  INCF   x4E,F
....................             tenths = '0'; 
085D8:  MOVLW  30
085DA:  MOVWF  x4F
....................          } 
....................          break; 
085DC:  MOVLB  0
085DE:  BRA    8604
....................  
....................       case 2: 
....................          if (thousandths > '5') 
085E0:  MOVLB  5
085E2:  MOVF   x51,W
085E4:  SUBLW  35
085E6:  BC    85EA
....................             hundredths++; 
085E8:  INCF   x50,F
....................          if (hundredths > '9') 
085EA:  MOVF   x50,W
085EC:  SUBLW  39
085EE:  BC    85F6
....................          { 
....................             tenths++; 
085F0:  INCF   x4F,F
....................             hundredths = '0'; 
085F2:  MOVLW  30
085F4:  MOVWF  x50
....................          } 
....................          if (tenths > '9') 
085F6:  MOVF   x4F,W
085F8:  SUBLW  39
085FA:  BC    8602
....................          { 
....................             volts++; 
085FC:  INCF   x4E,F
....................             tenths = '0'; 
085FE:  MOVLW  30
08600:  MOVWF  x4F
....................          }          
....................          break; 
08602:  MOVLB  0
....................    } 
....................    
....................    LCD_place_char (tens, lcd_line, col++); 
08604:  MOVLB  5
08606:  MOVF   x49,W
08608:  INCF   x49,F
0860A:  MOVWF  x52
0860C:  MOVFF  54D,556
08610:  MOVFF  548,557
08614:  MOVWF  x58
08616:  MOVLB  0
08618:  CALL   4B72
....................    LCD_place_char (volts, lcd_line, col++); 
0861C:  MOVLB  5
0861E:  MOVF   x49,W
08620:  INCF   x49,F
08622:  MOVWF  x52
08624:  MOVFF  54E,556
08628:  MOVFF  548,557
0862C:  MOVWF  x58
0862E:  MOVLB  0
08630:  CALL   4B72
....................     
....................    if (precision) 
08634:  MOVLB  5
08636:  MOVF   x4A,F
08638:  BZ    86A4
....................    { 
....................       LCD_place_char ('.', lcd_line, col++); 
0863A:  MOVF   x49,W
0863C:  INCF   x49,F
0863E:  MOVWF  x52
08640:  MOVLW  2E
08642:  MOVWF  x56
08644:  MOVFF  548,557
08648:  MOVFF  552,558
0864C:  MOVLB  0
0864E:  CALL   4B72
....................       LCD_place_char (tenths, lcd_line, col++); 
08652:  MOVLB  5
08654:  MOVF   x49,W
08656:  INCF   x49,F
08658:  MOVWF  x52
0865A:  MOVFF  54F,556
0865E:  MOVFF  548,557
08662:  MOVWF  x58
08664:  MOVLB  0
08666:  CALL   4B72
....................         
....................       if (precision > 1) 
0866A:  MOVLB  5
0866C:  MOVF   x4A,W
0866E:  SUBLW  01
08670:  BC    868A
....................          LCD_place_char (hundredths, lcd_line, col++); 
08672:  MOVF   x49,W
08674:  INCF   x49,F
08676:  MOVWF  x52
08678:  MOVFF  550,556
0867C:  MOVFF  548,557
08680:  MOVWF  x58
08682:  MOVLB  0
08684:  CALL   4B72
08688:  MOVLB  5
....................       if (precision > 2) 
0868A:  MOVF   x4A,W
0868C:  SUBLW  02
0868E:  BC    86A4
....................          LCD_place_char (thousandths, lcd_line, col); 
08690:  MOVFF  551,556
08694:  MOVFF  548,557
08698:  MOVFF  549,558
0869C:  MOVLB  0
0869E:  CALL   4B72
086A2:  MOVLB  5
....................    } 
086A4:  MOVLB  0
086A6:  GOTO   8BA4 (RETURN)
.................... }     
....................  
.................... void LCD_display_shutdown_cause(int1 lcd_line)            
.................... {                    
....................    if (!global_lcd_enabled) return;     
*
04DC6:  BTFSS  xA3.0
04DC8:  BRA    4E1C
....................     
....................    strcpy (global_temp_line_buff, "Shtdwn Cause:   "); 
04DCA:  CLRF   FEA
04DCC:  MOVLW  70
04DCE:  MOVWF  FE9
04DD0:  MOVLW  00
04DD2:  CALL   050E
04DD6:  TBLRD*-
04DD8:  TBLRD*+
04DDA:  MOVF   FF5,W
04DDC:  MOVWF  FEE
04DDE:  IORLW  00
04DE0:  BNZ   4DD8
....................    global_temp_line_buff[14] = hi2asc(global_previous_shutdown_cause); 
04DE2:  MOVFF  4E,560
04DE6:  CALL   3158
04DEA:  MOVFF  01,7E
....................    global_temp_line_buff[15] = lo2asc(global_previous_shutdown_cause); 
04DEE:  MOVFF  4E,560
04DF2:  CALL   3178
04DF6:  MOVFF  01,7F
....................    if (lcd_line == 0) LCD_line1(global_temp_line_buff); 
04DFA:  MOVLB  5
04DFC:  MOVF   x47,F
04DFE:  BNZ   4E10
04E00:  CLRF   x60
04E02:  MOVLW  70
04E04:  MOVWF  x5F
04E06:  MOVLB  0
04E08:  CALL   37A0
04E0C:  BRA    4E1C
04E0E:  MOVLB  5
....................    else LCD_line2(global_temp_line_buff); 
04E10:  CLRF   x60
04E12:  MOVLW  70
04E14:  MOVWF  x5F
04E16:  MOVLB  0
04E18:  CALL   37FA
04E1C:  GOTO   A1C4 (RETURN)
.................... } 
....................                                      
.................... void LCD_update_diplay(void)            
*
086AA:  MOVLW  20
086AC:  MOVLB  5
086AE:  MOVWF  x47
.................... {                                       
....................    // char for displaying mote state    
....................    char state_char = ' ';                 
....................        
....................    switch(global_lcd_page_number)       
086B0:  MOVLB  0
086B2:  MOVF   x84,W
086B4:  XORLW  01
086B6:  BZ    86CC
086B8:  XORLW  03
086BA:  BTFSC  FD8.2
086BC:  BRA    8810
086BE:  XORLW  01
086C0:  BTFSC  FD8.2
086C2:  BRA    8A96
086C4:  XORLW  07
086C6:  BTFSC  FD8.2
086C8:  BRA    8BA8
086CA:  BRA    8C44
....................    {     
....................       // display screen 1     
....................       case 1:                                    
....................          // This is where you should put the stuff that doesn't need to be updated all the time 
....................          // last update was skipped, clear screen and fill screen         
....................          if (global_skip_lcd_update_count == 1) 
086CC:  DECFSZ x83,W
086CE:  BRA    8722
....................          { 
....................             LCD_clear();                                         
086D0:  CALL   5C08
....................             global_skip_lcd_update_count = 0;   
086D4:  CLRF   x83
....................             strcpy (global_temp_line_buff, "v      r    t   "); 
086D6:  CLRF   FEA
086D8:  MOVLW  70
086DA:  MOVWF  FE9
086DC:  MOVLW  00
086DE:  CALL   0530
086E2:  TBLRD*-
086E4:  TBLRD*+
086E6:  MOVF   FF5,W
086E8:  MOVWF  FEE
086EA:  IORLW  00
086EC:  BNZ   86E4
....................             LCD_line1(global_temp_line_buff);            
086EE:  MOVLB  5
086F0:  CLRF   x60
086F2:  MOVLW  70
086F4:  MOVWF  x5F
086F6:  MOVLB  0
086F8:  CALL   37A0
....................             strcpy (global_temp_line_buff, "c      q    a   "); 
086FC:  CLRF   FEA
086FE:  MOVLW  70
08700:  MOVWF  FE9
08702:  MOVLW  00
08704:  CALL   0552
08708:  TBLRD*-
0870A:  TBLRD*+
0870C:  MOVF   FF5,W
0870E:  MOVWF  FEE
08710:  IORLW  00
08712:  BNZ   870A
....................             LCD_line2(global_temp_line_buff);    
08714:  MOVLB  5
08716:  CLRF   x60
08718:  MOVLW  70
0871A:  MOVWF  x5F
0871C:  MOVLB  0
0871E:  CALL   37FA
....................          }                                                  
....................                                 
....................          // This is where you put what you want on the screen                                        
....................          // v indicates Valve position 
....................          // r indicates speed of rotation Rpm 
....................          // t indicates message Type 
....................          // c indicates real-time Clock in seconds 
....................          // q indicates message Queue location 
....................          // a indicates Attempt_num 
....................          LCD_place_uint16(global_valve_position, 0, 1, 5);           
08722:  MOVFF  BE,560
08726:  MOVFF  BD,55F
0872A:  MOVLB  5
0872C:  CLRF   x61
0872E:  MOVLW  01
08730:  MOVWF  x62
08732:  MOVLW  05
08734:  MOVWF  x63
08736:  MOVLB  0
08738:  CALL   6828
....................          LCD_place_uint16(global_current_rpm,0,8,3);            
0873C:  MOVFF  A7,560
08740:  MOVFF  A6,55F
08744:  MOVLB  5
08746:  CLRF   x61
08748:  MOVLW  08
0874A:  MOVWF  x62
0874C:  MOVLW  03
0874E:  MOVWF  x63
08750:  MOVLB  0
08752:  CALL   6828
....................          LCD_place_uint32(global_rtc_time, 1,1,5);                      
08756:  MOVFF  88,555
0875A:  MOVFF  87,554
0875E:  MOVFF  86,553
08762:  MOVFF  85,552
08766:  MOVLW  01
08768:  MOVLB  5
0876A:  MOVWF  x56
0876C:  MOVWF  x57
0876E:  MOVLW  05
08770:  MOVWF  x58
08772:  MOVLB  0
08774:  CALL   6996
....................          //LCD_place_uint16(global_xdcr_output, 1, 8, 5);                 
....................          //LCD_place_uint32(global_utc_time, 1,1,10);           
....................                                                                                       
....................          LCD_place_uint8(global_current_message_queue_location, 1, 8, 3); 
08778:  MOVFF  4F3,560
0877C:  MOVLW  01
0877E:  MOVLB  5
08780:  MOVWF  x61
08782:  MOVLW  08
08784:  MOVWF  x62
08786:  MOVLW  03
08788:  MOVWF  x63
0878A:  MOVLB  0
0878C:  CALL   6902
....................          if (global_current_message_queue_location != 255) 
08790:  MOVLB  4
08792:  INCFSZ xF3,W
08794:  BRA    8798
08796:  BRA    880E
....................          {                              
....................             LCD_place_uint8(global_message_queue[global_current_message_queue_location].message_type,0,13,3); 
08798:  MOVF   xF3,W
0879A:  MULLW  08
0879C:  MOVF   FF3,W
0879E:  MOVLB  5
087A0:  CLRF   x49
087A2:  MOVWF  x48
087A4:  MOVLW  04
087A6:  ADDWF  x48,W
087A8:  MOVWF  01
087AA:  MOVLW  00
087AC:  ADDWFC x49,W
087AE:  MOVWF  03
087B0:  MOVF   01,W
087B2:  ADDLW  A3
087B4:  MOVWF  FE9
087B6:  MOVLW  04
087B8:  ADDWFC 03,W
087BA:  MOVWF  FEA
087BC:  MOVFF  FEF,560
087C0:  CLRF   x61
087C2:  MOVLW  0D
087C4:  MOVWF  x62
087C6:  MOVLW  03
087C8:  MOVWF  x63
087CA:  MOVLB  0
087CC:  CALL   6902
....................             LCD_place_uint8(global_message_queue[global_current_message_queue_location].attempt_num,1,13,3); 
087D0:  MOVLB  4
087D2:  MOVF   xF3,W
087D4:  MULLW  08
087D6:  MOVF   FF3,W
087D8:  MOVLB  5
087DA:  CLRF   x49
087DC:  MOVWF  x48
087DE:  MOVLW  07
087E0:  ADDWF  x48,W
087E2:  MOVWF  01
087E4:  MOVLW  00
087E6:  ADDWFC x49,W
087E8:  MOVWF  03
087EA:  MOVF   01,W
087EC:  ADDLW  A3
087EE:  MOVWF  FE9
087F0:  MOVLW  04
087F2:  ADDWFC 03,W
087F4:  MOVWF  FEA
087F6:  MOVFF  FEF,560
087FA:  MOVLW  01
087FC:  MOVWF  x61
087FE:  MOVLW  0D
08800:  MOVWF  x62
08802:  MOVLW  03
08804:  MOVWF  x63
08806:  MOVLB  0
08808:  CALL   6902
0880C:  MOVLB  4
....................          }    
....................                 
....................       break;  
0880E:  BRA    8C4A
....................       // display screen 2  
....................       case 2:               
....................          // This is where you should put the stuff that doesn't need to be updated all the time 
....................          // last update was skipped, clear screen and fill screen         
....................          if (global_skip_lcd_update_count == 1)   
08810:  DECFSZ x83,W
08812:  BRA    8866
....................          {                                         
....................             LCD_clear();                                         
08814:  CALL   5C08
....................             global_skip_lcd_update_count = 0; 
08818:  CLRF   x83
....................             strcpy (global_temp_line_buff, "m       n     * "); 
0881A:  CLRF   FEA
0881C:  MOVLW  70
0881E:  MOVWF  FE9
08820:  MOVLW  00
08822:  CALL   0574
08826:  TBLRD*-
08828:  TBLRD*+
0882A:  MOVF   FF5,W
0882C:  MOVWF  FEE
0882E:  IORLW  00
08830:  BNZ   8828
....................             LCD_line1(global_temp_line_buff);            
08832:  MOVLB  5
08834:  CLRF   x60
08836:  MOVLW  70
08838:  MOVWF  x5F
0883A:  MOVLB  0
0883C:  CALL   37A0
....................             strcpy (global_temp_line_buff, "p       .       "); 
08840:  CLRF   FEA
08842:  MOVLW  70
08844:  MOVWF  FE9
08846:  MOVLW  00
08848:  CALL   0596
0884C:  TBLRD*-
0884E:  TBLRD*+
08850:  MOVF   FF5,W
08852:  MOVWF  FEE
08854:  IORLW  00
08856:  BNZ   884E
....................             LCD_line2(global_temp_line_buff);    
08858:  MOVLB  5
0885A:  CLRF   x60
0885C:  MOVLW  70
0885E:  MOVWF  x5F
08860:  MOVLB  0
08862:  CALL   37FA
....................          }                                                       
....................                     
....................          // This is the place where you put what you want onto the screen 
....................          // m indicates Mote ID (hex) 
....................          // n indicates Net ID (hex) 
....................          // * indicates mote state (Booting, Idle, Searching, 
....................          //                         Negotiating, Connected, 
....................          //                         Operational, Disconnected, 
....................          //                         Radio test, Promiscuous Listen) 
....................          // p indicates sprinkler Position (2 digit pivot#, 3 digit location) 
....................          // . is the decimal pt in the battery voltage (2 decimal precision) 
....................          // final 4 places are for Firmware Rev 1st char A-F (e.g. A123) 
....................          // last four characters of line 2 is the hex firmware 
....................          //  revision, e.g. D308    
....................           
....................          // place the mac address on the LCD 
....................          global_temp_line_buff[0] = hi2asc(macaddr_rcvd[5]); 
08866:  MOVFF  A0,560
0886A:  CALL   3158
0886E:  MOVFF  01,70
....................          global_temp_line_buff[1] = lo2asc(macaddr_rcvd[5]); 
08872:  MOVFF  A0,560
08876:  CALL   3178
0887A:  MOVFF  01,71
....................          global_temp_line_buff[2] = hi2asc(macaddr_rcvd[6]); 
0887E:  MOVFF  A1,560
08882:  CALL   3158
08886:  MOVFF  01,72
....................          global_temp_line_buff[3] = lo2asc(macaddr_rcvd[6]); 
0888A:  MOVFF  A1,560
0888E:  CALL   3178
08892:  MOVFF  01,73
....................          global_temp_line_buff[4] = hi2asc(macaddr_rcvd[7]); 
08896:  MOVFF  A2,560
0889A:  CALL   3158
0889E:  MOVFF  01,74
....................          global_temp_line_buff[5] = lo2asc(macaddr_rcvd[7]); 
088A2:  MOVFF  A2,560
088A6:  CALL   3178
088AA:  MOVFF  01,75
....................          LCD_place_text(global_temp_line_buff,0,1,6);  
088AE:  MOVLB  5
088B0:  CLRF   x70
088B2:  MOVLW  70
088B4:  MOVWF  x6F
088B6:  CLRF   x71
088B8:  MOVLW  01
088BA:  MOVWF  x72
088BC:  MOVLW  06
088BE:  MOVWF  x73
088C0:  MOVLB  0
088C2:  CALL   67A0
....................                                 
....................          // place the network id on the LCD                        
....................          global_temp_line_buff[0] = hi2asc(make8(network_id_rcvd,1)); 
088C6:  MOVFF  364,548
088CA:  MOVFF  364,560
088CE:  CALL   3158
088D2:  MOVFF  01,70
....................          global_temp_line_buff[1] = lo2asc(make8(network_id_rcvd,1)); 
088D6:  MOVFF  364,548
088DA:  MOVFF  364,560
088DE:  CALL   3178
088E2:  MOVFF  01,71
....................          global_temp_line_buff[2] = hi2asc(make8(network_id_rcvd,0)); 
088E6:  MOVFF  363,548
088EA:  MOVFF  363,560
088EE:  CALL   3158
088F2:  MOVFF  01,72
....................          global_temp_line_buff[3] = lo2asc(make8(network_id_rcvd,0)); 
088F6:  MOVFF  363,548
088FA:  MOVFF  363,560
088FE:  CALL   3178
08902:  MOVFF  01,73
....................          LCD_place_text(global_temp_line_buff,0,9,4);        
08906:  MOVLB  5
08908:  CLRF   x70
0890A:  MOVLW  70
0890C:  MOVWF  x6F
0890E:  CLRF   x71
08910:  MOVLW  09
08912:  MOVWF  x72
08914:  MOVLW  04
08916:  MOVWF  x73
08918:  MOVLB  0
0891A:  CALL   67A0
....................           
....................          // put the mote state on the LCD       
....................          switch (global_mote_state) 
0891E:  MOVLB  5
08920:  MOVF   x00,W
08922:  XORLW  00
08924:  MOVLB  0
08926:  BZ    894A
08928:  XORLW  01
0892A:  BZ    8952
0892C:  XORLW  03
0892E:  BZ    895A
08930:  XORLW  01
08932:  BZ    8962
08934:  XORLW  07
08936:  BZ    896A
08938:  XORLW  01
0893A:  BZ    8972
0893C:  XORLW  03
0893E:  BZ    897A
08940:  XORLW  01
08942:  BZ    8982
08944:  XORLW  0F
08946:  BZ    898A
08948:  BRA    8994
....................          {               
....................             case MOTESTATE_INIT: 
....................                // booting 
....................                state_char = 'B'; 
0894A:  MOVLW  42
0894C:  MOVLB  5
0894E:  MOVWF  x47
....................                break;   
08950:  BRA    899A
....................             case MOTESTATE_IDLE: 
....................                state_char = 'I'; 
08952:  MOVLW  49
08954:  MOVLB  5
08956:  MOVWF  x47
....................                break;  
08958:  BRA    899A
....................             case MOTESTATE_SEARCHING: 
....................                state_char = 'S'; 
0895A:  MOVLW  53
0895C:  MOVLB  5
0895E:  MOVWF  x47
....................                break;      
08960:  BRA    899A
....................             case MOTESTATE_NEGOTIATING: 
....................                state_char = 'N'; 
08962:  MOVLW  4E
08964:  MOVLB  5
08966:  MOVWF  x47
....................                break; 
08968:  BRA    899A
....................             case MOTESTATE_CONNECTED: 
....................                state_char = 'C'; 
0896A:  MOVLW  43
0896C:  MOVLB  5
0896E:  MOVWF  x47
....................                break;  
08970:  BRA    899A
....................             case MOTESTATE_OPERATIONAL: 
....................                state_char = 'O'; 
08972:  MOVLW  4F
08974:  MOVLB  5
08976:  MOVWF  x47
....................                break;  
08978:  BRA    899A
....................             case MOTESTATE_DISCONNECTED: 
....................                state_char = 'D'; 
0897A:  MOVLW  44
0897C:  MOVLB  5
0897E:  MOVWF  x47
....................                break;   
08980:  BRA    899A
....................             case MOTESTATE_RADIOTEST: 
....................                state_char = 'R'; 
08982:  MOVLW  52
08984:  MOVLB  5
08986:  MOVWF  x47
....................                break;   
08988:  BRA    899A
....................             case MOTESTATE_PROMISCUOUS: 
....................                state_char = 'P'; 
0898A:  MOVLW  50
0898C:  MOVLB  5
0898E:  MOVWF  x47
....................                break;  
08990:  BRA    899A
08992:  MOVLB  0
....................             default: 
....................                state_char = '*'; 
08994:  MOVLW  2A
08996:  MOVLB  5
08998:  MOVWF  x47
....................                break;    
....................          }                      
....................          LCD_place_char(state_char, 0, 15);           
0899A:  MOVFF  547,556
0899E:  CLRF   x57
089A0:  MOVLW  0F
089A2:  MOVWF  x58
089A4:  MOVLB  0
089A6:  CALL   4B72
....................                   
....................          // put the sprinkler position??? on the LCD                              
....................          strcpy(global_temp_line_buff, "***"); 
089AA:  CLRF   FEA
089AC:  MOVLW  70
089AE:  MOVWF  FE9
089B0:  MOVLW  00
089B2:  CALL   05B8
089B6:  TBLRD*-
089B8:  TBLRD*+
089BA:  MOVF   FF5,W
089BC:  MOVWF  FEE
089BE:  IORLW  00
089C0:  BNZ   89B8
....................          if (state_char == 'O') 
089C2:  MOVLB  5
089C4:  MOVF   x47,W
089C6:  SUBLW  4F
089C8:  BNZ   89F6
....................             LCD_place_uint8((uint8_t)(network_id_rcvd - NETWORK_ID_DEF), 1, 1, 2); 
089CA:  MOVLW  CD
089CC:  MOVLB  3
089CE:  SUBWF  x63,W
089D0:  MOVWF  00
089D2:  MOVLW  04
089D4:  SUBWFB x64,W
089D6:  MOVWF  03
089D8:  MOVFF  00,548
089DC:  MOVLB  5
089DE:  MOVFF  00,560
089E2:  MOVLW  01
089E4:  MOVWF  x61
089E6:  MOVWF  x62
089E8:  MOVLW  02
089EA:  MOVWF  x63
089EC:  MOVLB  0
089EE:  CALL   6902
089F2:  BRA    8A0C
089F4:  MOVLB  5
....................          else 
....................             LCD_place_text(global_temp_line_buff,1,1,2); 
089F6:  CLRF   x70
089F8:  MOVLW  70
089FA:  MOVWF  x6F
089FC:  MOVLW  01
089FE:  MOVWF  x71
08A00:  MOVWF  x72
08A02:  MOVLW  02
08A04:  MOVWF  x73
08A06:  MOVLB  0
08A08:  CALL   67A0
....................                                        
....................          // put the sprinkler number on the LCD 
....................          if (global_sprinkler_num > 999) 
08A0C:  MOVF   x92,W
08A0E:  SUBLW  02
08A10:  BC    8A36
08A12:  XORLW  FF
08A14:  BNZ   8A1C
08A16:  MOVF   x91,W
08A18:  SUBLW  E7
08A1A:  BC    8A36
....................             LCD_place_text(global_temp_line_buff,1,3,3); 
08A1C:  MOVLB  5
08A1E:  CLRF   x70
08A20:  MOVLW  70
08A22:  MOVWF  x6F
08A24:  MOVLW  01
08A26:  MOVWF  x71
08A28:  MOVLW  03
08A2A:  MOVWF  x72
08A2C:  MOVWF  x73
08A2E:  MOVLB  0
08A30:  CALL   67A0
08A34:  BRA    8A50
....................          else 
....................             LCD_place_uint16(global_sprinkler_num, 1, 3, 3); 
08A36:  MOVFF  92,560
08A3A:  MOVFF  91,55F
08A3E:  MOVLW  01
08A40:  MOVLB  5
08A42:  MOVWF  x61
08A44:  MOVLW  03
08A46:  MOVWF  x62
08A48:  MOVWF  x63
08A4A:  MOVLB  0
08A4C:  CALL   6828
....................           
....................          // put the battery voltage on the LCD 
....................          LCD_display_batt_voltage(1, 7, 2);                 
08A50:  MOVLW  01
08A52:  MOVLB  5
08A54:  MOVWF  x4C
08A56:  MOVLW  07
08A58:  MOVWF  x4D
08A5A:  MOVLW  02
08A5C:  MOVWF  x4E
08A5E:  MOVLB  0
08A60:  CALL   4BAA
....................           
....................          // put the firmware version on the LCD 
....................          strcpy(global_temp_line_buff, global_firmware_version_string);       
08A64:  CLRF   FEA
08A66:  MOVLW  70
08A68:  MOVWF  FE9
08A6A:  CLRF   FE2
08A6C:  MOVLW  4F
08A6E:  MOVWF  FE1
08A70:  MOVF   FE7,F
08A72:  MOVFF  FE6,FEE
08A76:  BNZ   8A70
....................          LCD_place_text(global_temp_line_buff,1,12,4);   
08A78:  MOVLB  5
08A7A:  CLRF   x70
08A7C:  MOVLW  70
08A7E:  MOVWF  x6F
08A80:  MOVLW  01
08A82:  MOVWF  x71
08A84:  MOVLW  0C
08A86:  MOVWF  x72
08A88:  MOVLW  04
08A8A:  MOVWF  x73
08A8C:  MOVLB  0
08A8E:  CALL   67A0
....................                                                              
....................          break;         
08A92:  MOVLB  4
08A94:  BRA    8C4A
....................        
....................       // another screen 
....................       case 3: 
....................         
....................          if (global_skip_lcd_update_count == 1)   
08A96:  DECFSZ x83,W
08A98:  BRA    8AEC
....................          {                                         
....................             LCD_clear();                                         
08A9A:  CALL   5C08
....................             global_skip_lcd_update_count = 0; 
08A9E:  CLRF   x83
....................             strcpy (global_temp_line_buff, "br    ch    mp  "); 
08AA0:  CLRF   FEA
08AA2:  MOVLW  70
08AA4:  MOVWF  FE9
08AA6:  MOVLW  00
08AA8:  CALL   05CC
08AAC:  TBLRD*-
08AAE:  TBLRD*+
08AB0:  MOVF   FF5,W
08AB2:  MOVWF  FEE
08AB4:  IORLW  00
08AB6:  BNZ   8AAE
....................             LCD_line1(global_temp_line_buff);            
08AB8:  MOVLB  5
08ABA:  CLRF   x60
08ABC:  MOVLW  70
08ABE:  MOVWF  x5F
08AC0:  MOVLB  0
08AC2:  CALL   37A0
....................             strcpy (global_temp_line_buff, "r   /    vg  .  "); 
08AC6:  CLRF   FEA
08AC8:  MOVLW  70
08ACA:  MOVWF  FE9
08ACC:  MOVLW  00
08ACE:  CALL   05EE
08AD2:  TBLRD*-
08AD4:  TBLRD*+
08AD6:  MOVF   FF5,W
08AD8:  MOVWF  FEE
08ADA:  IORLW  00
08ADC:  BNZ   8AD4
....................             LCD_line2(global_temp_line_buff);    
08ADE:  MOVLB  5
08AE0:  CLRF   x60
08AE2:  MOVLW  70
08AE4:  MOVWF  x5F
08AE6:  MOVLB  0
08AE8:  CALL   37FA
....................          }                                                       
....................                     
....................          // This is the place where you put what you want onto the screen 
....................          // br indicates BRaking duty cycle (0-400) 
....................          // ch indicates CHarging duty cycle (0-400) 
....................          // mp indicates MPpc setting (2-digit HEX) 
....................          // r.../... indicates measured RPM / target RMP 
....................          // vg indicates detected voltage from generator 00.00 
....................           
....................          LCD_place_uint16(global_brake_duty,0,2,3);  
08AEC:  MOVFF  AF,560
08AF0:  MOVFF  AE,55F
08AF4:  MOVLB  5
08AF6:  CLRF   x61
08AF8:  MOVLW  02
08AFA:  MOVWF  x62
08AFC:  MOVLW  03
08AFE:  MOVWF  x63
08B00:  MOVLB  0
08B02:  CALL   6828
....................          LCD_place_uint16(global_charge_duty,0,8,3); 
08B06:  MOVFF  B1,560
08B0A:  MOVFF  B0,55F
08B0E:  MOVLB  5
08B10:  CLRF   x61
08B12:  MOVLW  08
08B14:  MOVWF  x62
08B16:  MOVLW  03
08B18:  MOVWF  x63
08B1A:  MOVLB  0
08B1C:  CALL   6828
....................          LCD_place_char(hi2asc(global_mppc_value),0,14); 
08B20:  MOVFF  B6,560
08B24:  CALL   3158
08B28:  MOVFF  01,548
08B2C:  MOVFF  01,556
08B30:  MOVLB  5
08B32:  CLRF   x57
08B34:  MOVLW  0E
08B36:  MOVWF  x58
08B38:  MOVLB  0
08B3A:  CALL   4B72
....................          LCD_place_char(lo2asc(global_mppc_value),0,15); 
08B3E:  MOVFF  B6,560
08B42:  CALL   3178
08B46:  MOVFF  01,548
08B4A:  MOVFF  01,556
08B4E:  MOVLB  5
08B50:  CLRF   x57
08B52:  MOVLW  0F
08B54:  MOVWF  x58
08B56:  MOVLB  0
08B58:  CALL   4B72
....................           
....................          LCD_place_uint16(global_current_rpm,1,1,3); 
08B5C:  MOVFF  A7,560
08B60:  MOVFF  A6,55F
08B64:  MOVLW  01
08B66:  MOVLB  5
08B68:  MOVWF  x61
08B6A:  MOVWF  x62
08B6C:  MOVLW  03
08B6E:  MOVWF  x63
08B70:  MOVLB  0
08B72:  CALL   6828
....................          LCD_place_uint16(global_rpm_set_value,1,5,3); 
08B76:  MOVFF  A9,560
08B7A:  MOVFF  A8,55F
08B7E:  MOVLW  01
08B80:  MOVLB  5
08B82:  MOVWF  x61
08B84:  MOVLW  05
08B86:  MOVWF  x62
08B88:  MOVLW  03
08B8A:  MOVWF  x63
08B8C:  MOVLB  0
08B8E:  CALL   6828
....................           
....................          // put the vgen voltage on the LCD 
....................  
....................          LCD_display_vgen(1, 11, 2); 
08B92:  MOVLW  01
08B94:  MOVLB  5
08B96:  MOVWF  x48
08B98:  MOVLW  0B
08B9A:  MOVWF  x49
08B9C:  MOVLW  02
08B9E:  MOVWF  x4A
08BA0:  MOVLB  0
08BA2:  BRA    84B6
....................  
....................       break; 
08BA4:  MOVLB  4
08BA6:  BRA    8C4A
....................        
....................       // extra screen 
....................       case 4: 
....................          if (global_skip_lcd_update_count == 1) 
08BA8:  DECFSZ x83,W
08BAA:  BRA    8BFE
....................          {                                         
....................             LCD_clear();                                         
08BAC:  CALL   5C08
....................             global_skip_lcd_update_count = 0; 
08BB0:  CLRF   x83
....................             strcpy (global_temp_line_buff, "system state    "); 
08BB2:  CLRF   FEA
08BB4:  MOVLW  70
08BB6:  MOVWF  FE9
08BB8:  MOVLW  00
08BBA:  CALL   0610
08BBE:  TBLRD*-
08BC0:  TBLRD*+
08BC2:  MOVF   FF5,W
08BC4:  MOVWF  FEE
08BC6:  IORLW  00
08BC8:  BNZ   8BC0
....................             LCD_line1(global_temp_line_buff);            
08BCA:  MOVLB  5
08BCC:  CLRF   x60
08BCE:  MOVLW  70
08BD0:  MOVWF  x5F
08BD2:  MOVLB  0
08BD4:  CALL   37A0
....................             strcpy (global_temp_line_buff, "                "); 
08BD8:  CLRF   FEA
08BDA:  MOVLW  70
08BDC:  MOVWF  FE9
08BDE:  MOVLW  00
08BE0:  CALL   04CA
08BE4:  TBLRD*-
08BE6:  TBLRD*+
08BE8:  MOVF   FF5,W
08BEA:  MOVWF  FEE
08BEC:  IORLW  00
08BEE:  BNZ   8BE6
....................             LCD_line2(global_temp_line_buff);    
08BF0:  MOVLB  5
08BF2:  CLRF   x60
08BF4:  MOVLW  70
08BF6:  MOVWF  x5F
08BF8:  MOVLB  0
08BFA:  CALL   37FA
....................          }     
....................             LCD_place_uint8(read_system_state(),0,13,3);  
08BFE:  CALL   1DC6
08C02:  MOVFF  01,548
08C06:  MOVFF  01,560
08C0A:  MOVLB  5
08C0C:  CLRF   x61
08C0E:  MOVLW  0D
08C10:  MOVWF  x62
08C12:  MOVLW  03
08C14:  MOVWF  x63
08C16:  MOVLB  0
08C18:  CALL   6902
....................             LCD_place_uint32(global_last_rpm_value_time,1,0,10);  
08C1C:  MOVFF  AD,555
08C20:  MOVFF  AC,554
08C24:  MOVFF  AB,553
08C28:  MOVFF  AA,552
08C2C:  MOVLW  01
08C2E:  MOVLB  5
08C30:  MOVWF  x56
08C32:  CLRF   x57
08C34:  MOVLW  0A
08C36:  MOVWF  x58
08C38:  MOVLB  0
08C3A:  CALL   6996
....................          break;    
08C3E:  MOVLB  4
08C40:  BRA    8C4A
08C42:  MOVLB  0
....................                                                                        
....................       // if somehow global_lcd_page_number get incremented above the last page, clear the LCD    
....................       default: 
....................          LCD_clear();                
08C44:  CALL   5C08
....................       break;     
08C48:  MOVLB  4
....................    }                                              
08C4A:  MOVLB  0
08C4C:  GOTO   A9BC (RETURN)
.................... }       
....................  
....................                                                                                                    
.................... void XDCR_init(void) 
.................... { 
....................    i2c_start(); 
....................  
....................    global_xcdr_type1_enabled = !i2c_write(XDCR_ADDRESS);    // (0x48) WRITE LCD address? 
....................    if (!global_xcdr_type1_enabled) 
....................    { 
....................       i2c_stop();                                     
....................       delay_cycles(255); 
....................       output_low(XDCR_PWR);   
....................       return;                             
....................    }                              
....................    //i2c_write(0b00000000);                                    
....................    i2c_write(0x00);  
....................    i2c_stop();            
....................    // set up the ADC here 
.................... }     
....................                
.................... void adc_XDCR_init(void) 
*
036CE:  MOVLB  5
036D0:  CLRF   x49
036D2:  CLRF   x48
.................... {    
....................    uint8_t n; 
....................    uint16_t xdcr_output_sum = 0; 
....................     
....................    // turn on pullup resisitor on xdcr line (so you can check if it's connected)                     
....................    port_b_pullups(PORTB_PULLUPS_WITH_XDCR);   
036D4:  MOVLW  32
036D6:  MOVWF  F61
....................     
....................    // turn on XDCR and wait 100ms for the adc to settle (really only 25ms or so is needed) 
....................    output_high(XDCR_PWR);       
036D8:  BSF    F8B.5
....................    setup_T0_int(T0_100MS);                                     
036DA:  MOVLW  FE
036DC:  MOVWF  x65
036DE:  MOVLW  7A
036E0:  MOVWF  x64
036E2:  MOVLB  0
036E4:  RCALL  36B2
....................    while(!TMR0IF);           
036E6:  BTFSS  FF2.2
036E8:  BRA    36E6
....................               
....................    // turn on ADC                   
....................    ADON = TRUE;                
036EA:  BSF    FC2.0
....................                                    
....................    // set adc to V_EXTRA_IO_1 (pin 7 on header going "across river") 
....................    set_adc_channel(ADC_XDCR);       
036EC:  MOVLW  34
036EE:  MOVWF  01
036F0:  MOVF   FC2,W
036F2:  ANDLW  83
036F4:  IORWF  01,W
036F6:  MOVWF  FC2
....................  
....................    // sum up 8 samples from the adc (.3 ms/sample @ 250Khz clock)                                                                                                                                                                            
....................    for (n = 0; n < 8; n++) 
036F8:  MOVLB  5
036FA:  CLRF   x47
036FC:  MOVF   x47,W
036FE:  SUBLW  07
03700:  BNC   3714
....................    {                                                                                                                                                                                                         
....................       xdcr_output_sum += read_adc(); 
03702:  BSF    FC2.1
03704:  BTFSC  FC2.1
03706:  BRA    3704
03708:  MOVF   FC3,W
0370A:  ADDWF  x48,F
0370C:  MOVF   FC4,W
0370E:  ADDWFC x49,F
03710:  INCF   x47,F
03712:  BRA    36FC
....................    }                     
....................         
....................    // turn off XDCR power 
....................    output_low(XDCR_PWR);  
03714:  BCF    F8B.5
....................                                                     
....................    // turn off adc                                                                                          
....................    ADON = FALSE;             
03716:  BCF    FC2.0
....................                                    
....................    if (xdcr_output_sum < XDCR_ADC_OFF_LIMIT) 
03718:  MOVF   x49,W
0371A:  SUBLW  13
0371C:  BNC   372C
0371E:  BNZ   3726
03720:  MOVF   x48,W
03722:  SUBLW  87
03724:  BNC   372C
....................    { 
....................       global_xcdr_type1_enabled = TRUE;    
03726:  MOVLB  0
03728:  BSF    xA3.2
0372A:  MOVLB  5
....................    }                                             
....................                          
....................    // return pullups to normal state (without testing if XDCR is there)                            
....................    port_b_pullups(PORTB_PULLUPS);         
0372C:  MOVLW  12
0372E:  MOVWF  F61
03730:  MOVLB  0
03732:  GOTO   3F8A (RETURN)
.................... }                                     
....................  
.................... uint16_t XDCR_measure(void)                                          
.................... {                                          
....................    uint32_t temp_u32;                                           
....................      
....................    i2c_start(); 
....................                                                      
....................    // (0x49) READ ADC address?                 
....................    i2c_write(XDCR_ADDRESS + 1);    
....................                                      
....................    temp_u32 = make32(i2c_read(TRUE), i2c_read(TRUE), i2c_read(FALSE), 0); 
.................... //   LCD_clear();                     
.................... //   LCD_place_uint32(temp_u32,0,0,10);   
.................... //   global_skip_lcd_update_count = 5;               
....................                                       
....................    i2c_stop();                                                          
....................                                             
....................    if ((make8(temp_u32,3) & 0xC0) == 0xC0)  
....................    {                                 
....................       return 0xFFFF;        // saturated top of scale 
....................    }                                                                                     
....................    else if (!(make8(temp_u32,3) & 0xC0))                          
....................    {                                                                           
....................       return 0;             // saturated bottom of scale 
....................    }             
....................    else                                     
....................    {                                                                                                                                                                          
....................       temp_u32 = temp_u32<<2;           // ignore "Bit23 Sig" and "Bit22 MSB" 
.................... //      LCD_clear();                                     
.................... //      LCD_place_uint8(make8(temp_u32,1),1,0,3); 
.................... //     global_skip_lcd_update_count = 5;                                                                                   
....................       return make16(make8(temp_u32,3), make8(temp_u32,2));               
....................    }                                                               
.................... } 
....................  
.................... uint16_t adc_XDCR_measure()     
*
08218:  MOVLB  5
0821A:  CLRF   x49
0821C:  CLRF   x48
.................... {                           
....................    uint8_t n; 
....................    uint16_t adc_value = 0;                   
....................     
....................    // if the XDCR isn't connected, return 0 (really, you should never see 0 with adc noise)                      
....................    if (!global_xcdr_type1_enabled) return 0;        
0821E:  MOVLB  0
08220:  BTFSC  xA3.2
08222:  BRA    822C
08224:  MOVLW  00
08226:  MOVWF  01
08228:  MOVWF  02
0822A:  BRA    826A
....................     
....................    // turn on ADC         
....................    ADON = TRUE;                
0822C:  BSF    FC2.0
....................                                    
....................    // set adc to V_EXTRA_IO_1 (pin 7 on header going "across river" 
....................    set_adc_channel(ADC_XDCR);       
0822E:  MOVLW  34
08230:  MOVWF  01
08232:  MOVF   FC2,W
08234:  ANDLW  83
08236:  IORWF  01,W
08238:  MOVWF  FC2
....................                                      
....................    // sum up 8 samples from the adc (.3 ms/sample @ 250Khz clock)                                                                                                                                                                              
....................    for (n=0; n<8; n++) 
0823A:  MOVLB  5
0823C:  CLRF   x47
0823E:  MOVF   x47,W
08240:  SUBLW  07
08242:  BNC   8256
....................    {                                                                                                                                                                                                         
....................       adc_value += read_adc(); 
08244:  BSF    FC2.1
08246:  BTFSC  FC2.1
08248:  BRA    8246
0824A:  MOVF   FC3,W
0824C:  ADDWF  x48,F
0824E:  MOVF   FC4,W
08250:  ADDWFC x49,F
08252:  INCF   x47,F
08254:  BRA    823E
....................    }                     
....................                       
....................    // turn off XDCR power 
....................    output_low(XDCR_PWR);  
08256:  BCF    F8B.5
....................                 
....................    // turn off adc                                                                                          
....................    ADON = FALSE;             
08258:  BCF    FC2.0
....................                                                   
....................    // store XDCR output globally (not shifted)                                               
....................    global_xdcr_output = adc_value;         
0825A:  MOVFF  549,4C
0825E:  MOVFF  548,4B
....................                     
....................    // return the voltage shifted by 3 bits to scale from (0-1023) * 8 to 0-65535 or close enough     
....................    return global_xdcr_output;                     
08262:  MOVFF  4B,01
08266:  MOVFF  4C,02
0826A:  MOVLB  0
0826C:  GOTO   A93A (RETURN)
.................... } 
....................  
....................  
.................... void  fixture_init()          
.................... { 
....................    uint8_t  resbyte;               
....................    resbyte = 0;                                                                                              
*
03E2A:  MOVLB  5
03E2C:  CLRF   x47
....................     
....................    safeI2C_start();         
03E2E:  MOVLB  0
03E30:  RCALL  3C8A
....................     
....................    resbyte += i2c_write(FIXTURE_DAC_ADDRESS);                 // FIXTURE DAC ADDRESS 
03E32:  MOVLW  40
03E34:  MOVLB  5
03E36:  MOVWF  x78
03E38:  MOVLB  0
03E3A:  RCALL  3752
03E3C:  MOVF   01,W
03E3E:  MOVLB  5
03E40:  ADDWF  x47,F
....................  
....................    resbyte += i2c_write (0x60);                // use internal reference 
03E42:  MOVLW  60
03E44:  MOVWF  x78
03E46:  MOVLB  0
03E48:  RCALL  3752
03E4A:  MOVF   01,W
03E4C:  MOVLB  5
03E4E:  ADDWF  x47,F
....................    resbyte += i2c_write (0x00);                // set DAC to 0 
03E50:  CLRF   x78
03E52:  MOVLB  0
03E54:  RCALL  3752
03E56:  MOVF   01,W
03E58:  MOVLB  5
03E5A:  ADDWF  x47,F
....................    resbyte += i2c_write (0x00);                // low nibble not used (12 bit DAC) 
03E5C:  CLRF   x78
03E5E:  MOVLB  0
03E60:  RCALL  3752
03E62:  MOVF   01,W
03E64:  MOVLB  5
03E66:  ADDWF  x47,F
....................     
....................    if (resbyte != 0) global_fixture_enabled = TRUE; 
03E68:  MOVF   x47,F
03E6A:  BZ    3E72
03E6C:  MOVLB  0
03E6E:  BSF    xA3.4
03E70:  MOVLB  5
....................    i2c_stop(); 
03E72:  BSF    FC5.2
03E74:  BTFSC  FC5.2
03E76:  BRA    3E74
....................     
....................    set_fixture_dac(NO_FIXTURE); 
03E78:  CLRF   x49
03E7A:  CLRF   x48
03E7C:  MOVLB  0
03E7E:  BRA    3DD6
03E80:  GOTO   3F9E (RETURN)
.................... }                              
....................  
.................... #include "control.h"                      
.................... void setup_gen_rpm(void) 
.................... { 
....................    setup_timer_5(T5_ENABLE_SOSC | T5_EXTERNAL_SYNC | T5_DIV_BY_1); 
*
04082:  MOVLB  F
04084:  CLRF   x4D
04086:  MOVLW  8B
04088:  MOVWF  x4E
....................    setup_ccp5(CCP_USE_TIMER5_AND_TIMER6 | CCP_CAPTURE_RE);  
0408A:  CLRF   x54
0408C:  MOVLW  05
0408E:  MOVWF  x54
04090:  MOVLW  F3
04092:  ANDWF  x48,F
04094:  MOVLW  08
04096:  IORWF  x48,F
....................    clear_interrupt(INT_CCP5);     // insurance 
04098:  BCF    F7B.2
....................  
....................    disable_interrupts(INT_TIMER5); 
0409A:  BCF    F7D.1
....................    enable_interrupts(INT_CCP5); 
0409C:  BSF    F7A.2
0409E:  MOVLB  0
040A0:  GOTO   A122 (RETURN)
.................... } 
....................  
.................... uint16_t calc_gen_rpm(void) 
.................... {   
....................    uint16_t current_rpm16; 
....................    uint32_t current_rpm32; 
....................     
....................       
....................    disable_interrupts(INT_CCP5);                 
*
04F00:  BCF    F7A.2
....................    current_rpm32 = global_last_rpm_value_time; 
04F02:  MOVFF  AD,555
04F06:  MOVFF  AC,554
04F0A:  MOVFF  AB,553
04F0E:  MOVFF  AA,552
....................    enable_interrupts(INT_CCP5);        
04F12:  BSF    F7A.2
....................                                             
....................    // if the last measurement of rpm was more than RPM_TIMEOUT seconds ago 
....................    if ((global_rtc_time - current_rpm32) > RPM_TIMEOUT)            
04F14:  MOVLB  5
04F16:  MOVF   x52,W
04F18:  MOVLB  0
04F1A:  SUBWF  x85,W
04F1C:  MOVLB  5
04F1E:  MOVWF  x56
04F20:  MOVF   x53,W
04F22:  MOVLB  0
04F24:  SUBWFB x86,W
04F26:  MOVLB  5
04F28:  MOVWF  x57
04F2A:  MOVF   x54,W
04F2C:  MOVLB  0
04F2E:  SUBWFB x87,W
04F30:  MOVLB  5
04F32:  MOVWF  x58
04F34:  MOVF   x55,W
04F36:  MOVLB  0
04F38:  SUBWFB x88,W
04F3A:  MOVLB  5
04F3C:  MOVWF  x59
04F3E:  MOVF   x59,F
04F40:  BNZ   4F54
04F42:  MOVF   x58,F
04F44:  BNZ   4F54
04F46:  MOVF   x1E,W
04F48:  SUBWF  x57,W
04F4A:  BNC   4F5E
04F4C:  BNZ   4F54
04F4E:  MOVF   x56,W
04F50:  SUBWF  x1D,W
04F52:  BC    4F5E
....................    {  
.................... #IFNDEF DISABLE_NO_SPIN_RECOVERY    
....................       if (global_valve_position <= VLV_NOT_SPIN_LIMIT) 
.................... #ENDIF 
....................       { 
....................          return 0;                                
04F54:  MOVLW  00
04F56:  MOVWF  01
04F58:  MOVWF  02
04F5A:  BRA    4FDA
....................       } 
....................  
.................... #IFNDEF DISABLE_MAG_DECOUPLING_RECOVERY 
....................       else if(global_valve_position >= VLV_MAGNETIC_COUPLING_LIMIT) 
....................       { 
....................          return 0-1; 
....................       } 
.................... #ENDIF 
....................    }  
04F5C:  BRA    4FD4
....................     
....................    // otherwise, calculate rpms as usual 
....................    else 
....................    {  
....................       disable_interrupts(INT_CCP5); 
04F5E:  BCF    F7A.2
....................       current_rpm32 = CCP_PER_RPM/(make32(0,0,make8(global_current_period,1), make8(global_current_period,0)));    
04F60:  MOVFF  A5,556
04F64:  MOVFF  A4,557
04F68:  CLRF   x5B
04F6A:  CLRF   x5A
04F6C:  MOVFF  A5,559
04F70:  MOVFF  A4,558
04F74:  BCF    FD8.1
04F76:  CLRF   19
04F78:  BTFSC  FF2.7
04F7A:  BSF    19.7
04F7C:  BCF    FF2.7
04F7E:  MOVLW  99
04F80:  MOVWF  xA0
04F82:  MOVWF  x9F
04F84:  MOVWF  x9E
04F86:  MOVLW  9A
04F88:  MOVWF  x9D
04F8A:  MOVFF  55B,5A4
04F8E:  MOVFF  55A,5A3
04F92:  MOVFF  A5,5A2
04F96:  MOVFF  A4,5A1
04F9A:  MOVLB  0
04F9C:  CALL   23C0
04FA0:  BTFSC  19.7
04FA2:  BSF    FF2.7
04FA4:  MOVFF  03,555
04FA8:  MOVFF  02,554
04FAC:  MOVFF  01,553
04FB0:  MOVFF  00,552
....................       enable_interrupts(INT_CCP5); 
04FB4:  BSF    F7A.2
....................       current_rpm16 = make16(make8(current_rpm32,3), make8(current_rpm32,2)); 
04FB6:  MOVFF  555,551
04FBA:  MOVFF  554,550
....................       if (bit_test(current_rpm32, 15)) 
04FBE:  MOVLB  5
04FC0:  BTFSS  x53.7
04FC2:  BRA    4FCA
....................       { 
....................          current_rpm16++; 
04FC4:  INCF   x50,F
04FC6:  BTFSC  FD8.2
04FC8:  INCF   x51,F
....................       } 
....................       return current_rpm16; 
04FCA:  MOVFF  550,01
04FCE:  MOVFF  551,02
04FD2:  BRA    4FDA
....................    } 
....................    return 0; 
04FD4:  MOVLW  00
04FD6:  MOVWF  01
04FD8:  MOVWF  02
04FDA:  MOVLB  0
04FDC:  GOTO   53F0 (RETURN)
.................... } 
....................  
.................... int1  is_brake_duty_valid(uint16_t value) 
.................... // returns true if valid range for brake duty cycle 
.................... { 
....................    if (value > MAX_BRK) return FALSE; 
*
070BC:  MOVLB  5
070BE:  MOVF   x51,W
070C0:  SUBLW  00
070C2:  BC    70D6
070C4:  XORLW  FF
070C6:  BNZ   70CE
070C8:  MOVF   x50,W
070CA:  SUBLW  90
070CC:  BC    70D6
070CE:  MOVLW  00
070D0:  MOVWF  01
070D2:  BRA    70DA
070D4:  BRA    70DA
....................    else if ((value < NO_BRK) && (NO_BRK != 0)) return FALSE; 
....................    else return TRUE; 
070D6:  MOVLW  01
070D8:  MOVWF  01
070DA:  MOVLB  0
070DC:  GOTO   797A (RETURN)
.................... } 
.................... int1  is_charge_duty_valid(uint16_t value) 
.................... // returns true if valid range for charge duty cycle 
.................... { 
....................    if (value > MAX_CHARGE) return FALSE; 
070E0:  MOVLB  5
070E2:  MOVF   x51,W
070E4:  SUBLW  00
070E6:  BC    70FA
070E8:  XORLW  FF
070EA:  BNZ   70F2
070EC:  MOVF   x50,W
070EE:  SUBLW  90
070F0:  BC    70FA
070F2:  MOVLW  00
070F4:  MOVWF  01
070F6:  BRA    70FE
070F8:  BRA    70FE
....................    else if ((value < NO_CHARGE) && (NO_CHARGE != 0)) return FALSE; 
....................    else return TRUE; 
070FA:  MOVLW  01
070FC:  MOVWF  01
070FE:  MOVLB  0
07100:  GOTO   7998 (RETURN)
.................... } 
.................... int1  is_mppc_valid(uint8_t value) 
.................... // returns true if valid range for mppc 
.................... { 
....................    if (value > MAX_MPPC) return FALSE; 
....................    else if ((value < NO_MPPC) && (NO_MPPC != 0)) return FALSE; 
07104:  MOVLB  5
07106:  MOVF   x4E,W
07108:  SUBLW  06
0710A:  BNC   7114
0710C:  MOVLW  00
0710E:  MOVWF  01
07110:  BRA    7118
07112:  BRA    7118
....................    else return TRUE; 
07114:  MOVLW  01
07116:  MOVWF  01
07118:  MOVLB  0
0711A:  GOTO   79B2 (RETURN)
.................... } 
.................... int1  is_rpm_setting_valid(uint16_t value) 
.................... // returns true if valid range for rpm 
.................... { 
....................    if (value > MAX_RPM_SETTING) return FALSE; 
*
06C16:  MOVLB  5
06C18:  MOVF   x51,F
06C1A:  BNZ   6C22
06C1C:  MOVF   x50,W
06C1E:  SUBLW  FA
06C20:  BC    6C2A
06C22:  MOVLW  00
06C24:  MOVWF  01
06C26:  BRA    6C40
06C28:  BRA    6C40
....................    else if ((value < MIN_RPM_SETTING) && (MIN_RPM_SETTING != 0)) return FALSE; 
06C2A:  MOVF   x51,F
06C2C:  BNZ   6C3C
06C2E:  MOVF   x50,W
06C30:  SUBLW  09
06C32:  BNC   6C3C
06C34:  MOVLW  00
06C36:  MOVWF  01
06C38:  BRA    6C40
06C3A:  BRA    6C40
....................    else return TRUE; 
06C3C:  MOVLW  01
06C3E:  MOVWF  01
06C40:  MOVLB  0
06C42:  RETURN 0
.................... } 
.................... void  set_brake_duty(uint16_t value) 
.................... { 
....................    if (value == NO_BRK) 
*
052F8:  MOVLB  5
052FA:  MOVF   x52,F
052FC:  BNZ   530A
052FE:  MOVF   x53,F
05300:  BNZ   530A
....................    { 
....................       setup_ccp1(CCP_OFF); 
05302:  MOVLW  F0
05304:  ANDWF  FBD,F
....................       output_high(BRK_CTRLn);    // no braking 
05306:  BSF    F8B.2
....................    } 
05308:  BRA    535A
....................    else if (value == MAX_BRK) 
0530A:  MOVF   x52,W
0530C:  SUBLW  90
0530E:  BNZ   531C
05310:  DECFSZ x53,W
05312:  BRA    531C
....................    { 
....................       setup_ccp1(CCP_OFF); 
05314:  MOVLW  F0
05316:  ANDWF  FBD,F
....................       output_low(BRK_CTRLn);     // maximum braking 
05318:  BCF    F8B.2
....................    } 
0531A:  BRA    535A
....................     
....................    else 
....................    {       
....................       setup_ccp1(CCP_USE_TIMER5_AND_TIMER6 | CCP_PWM_L_L | CCP_PULSE_STEERING_A); 
0531C:  BCF    F8B.2
0531E:  MOVLW  0F
05320:  MOVWF  FBD
05322:  CLRF   FB7
05324:  CLRF   FB6
05326:  MOVLW  01
05328:  MOVWF  FB9
0532A:  MOVLW  FC
0532C:  MOVLB  F
0532E:  ANDWF  x49,F
05330:  MOVLW  02
05332:  IORWF  x49,F
....................       // increase pwm duty1 for slower speed 
....................       CCP1CON |= (make8(value,0) & 0x03) << 4; 
05334:  MOVLB  5
05336:  MOVF   x52,W
05338:  ANDLW  03
0533A:  MOVWF  00
0533C:  SWAPF  00,F
0533E:  MOVLW  F0
05340:  ANDWF  00,F
05342:  MOVF   00,W
05344:  IORWF  FBD,F
....................       CCPR1L = make8((value>>2),0); 
05346:  RRCF   x53,W
05348:  MOVWF  x55
0534A:  RRCF   x52,W
0534C:  MOVWF  x54
0534E:  RRCF   x55,F
05350:  RRCF   x54,F
05352:  MOVLW  3F
05354:  ANDWF  x55,F
05356:  MOVFF  554,FBE
....................    } 
....................     
....................    global_brake_duty = value; 
0535A:  MOVFF  553,AF
0535E:  MOVFF  552,AE
05362:  MOVLB  0
05364:  RETURN 0
.................... } 
....................  
.................... void     set_charge_duty(uint16_t value) 
.................... { 
....................    if (value == NO_CHARGE) 
*
03D68:  MOVLB  5
03D6A:  MOVF   x52,F
03D6C:  BNZ   3D7A
03D6E:  MOVF   x53,F
03D70:  BNZ   3D7A
....................    { 
....................       setup_ccp2(CCP_OFF); 
03D72:  MOVLW  F0
03D74:  ANDWF  F66,F
....................       output_low(LTC3105_CTRL);     // lo for NO CHARGING 
03D76:  BCF    F8A.3
....................    } 
03D78:  BRA    3DCA
....................    else if (value == MAX_CHARGE) 
03D7A:  MOVF   x52,W
03D7C:  SUBLW  90
03D7E:  BNZ   3D8C
03D80:  DECFSZ x53,W
03D82:  BRA    3D8C
....................    { 
....................       setup_ccp2(CCP_OFF); 
03D84:  MOVLW  F0
03D86:  ANDWF  F66,F
....................       output_high(LTC3105_CTRL);    // maximum charging aggressiveness 
03D88:  BSF    F8A.3
....................    } 
03D8A:  BRA    3DCA
....................     
....................    else 
....................    {    
....................       //setup_ccp2(CCP_USE_TIMER1_AND_TIMER2 | CCP_PWM_H_H | CCP_PULSE_STEERING_A); 
....................       setup_ccp2(CCP_USE_TIMER5_AND_TIMER6 | CCP_PWM_H_H | CCP_PULSE_STEERING_A); 
03D8C:  BCF    F8A.3
03D8E:  MOVLW  0C
03D90:  MOVWF  F66
03D92:  CLRF   F65
03D94:  CLRF   F64
03D96:  MOVLW  01
03D98:  MOVWF  F63
03D9A:  MOVLW  E7
03D9C:  MOVLB  F
03D9E:  ANDWF  x49,F
03DA0:  MOVLW  10
03DA2:  IORWF  x49,F
....................       // increase pwm duty2 for slower speed 
....................       CCP2CON |= (make8(value,0) & 0x03) << 4; 
03DA4:  MOVLB  5
03DA6:  MOVF   x52,W
03DA8:  ANDLW  03
03DAA:  MOVWF  00
03DAC:  SWAPF  00,F
03DAE:  MOVLW  F0
03DB0:  ANDWF  00,F
03DB2:  MOVF   00,W
03DB4:  IORWF  F66,F
....................       CCPR2L = make8((value>>2),0); 
03DB6:  RRCF   x53,W
03DB8:  MOVWF  x55
03DBA:  RRCF   x52,W
03DBC:  MOVWF  x54
03DBE:  RRCF   x55,F
03DC0:  RRCF   x54,F
03DC2:  MOVLW  3F
03DC4:  ANDWF  x55,F
03DC6:  MOVFF  554,F67
....................    } 
....................    global_charge_duty = value; 
03DCA:  MOVFF  553,B1
03DCE:  MOVFF  552,B0
03DD2:  MOVLB  0
03DD4:  RETURN 0
.................... }                   
....................  
.................... void set_mppc(uint8_t value) 
.................... { 
....................    // for large scale PCBs 
....................     
....................    safeI2C_start(); 
*
03CDC:  RCALL  3C8A
....................  
....................    safei2c_write(0x58);   // address 
03CDE:  MOVLW  58
03CE0:  MOVLB  5
03CE2:  MOVWF  x51
03CE4:  MOVLB  0
03CE6:  RCALL  3CC8
....................    safei2c_write(0x00);   // Pot 0 command 
03CE8:  MOVLB  5
03CEA:  CLRF   x51
03CEC:  MOVLB  0
03CEE:  RCALL  3CC8
....................    safei2c_write(value);  
03CF0:  MOVFF  550,551
03CF4:  RCALL  3CC8
....................    safei2c_write(0x10);   // Pot 1 command 
03CF6:  MOVLW  10
03CF8:  MOVLB  5
03CFA:  MOVWF  x51
03CFC:  MOVLB  0
03CFE:  RCALL  3CC8
....................    safei2c_write(value);  
03D00:  MOVFF  550,551
03D04:  RCALL  3CC8
....................    safei2c_write(0x60);   // Pot 2 command 
03D06:  MOVLW  60
03D08:  MOVLB  5
03D0A:  MOVWF  x51
03D0C:  MOVLB  0
03D0E:  RCALL  3CC8
....................    safei2c_write(value);  
03D10:  MOVFF  550,551
03D14:  RCALL  3CC8
....................    safei2c_write(0x70);   // Pot 3 command 
03D16:  MOVLW  70
03D18:  MOVLB  5
03D1A:  MOVWF  x51
03D1C:  MOVLB  0
03D1E:  RCALL  3CC8
....................    safei2c_write(value);     
03D20:  MOVFF  550,551
03D24:  RCALL  3CC8
....................    i2c_stop(); 
03D26:  BSF    FC5.2
03D28:  BTFSC  FC5.2
03D2A:  BRA    3D28
....................  
....................    // and connect all four pots 
....................    safeI2C_start(); 
03D2C:  RCALL  3C8A
....................     
....................    safei2c_write(0x58);  
03D2E:  MOVLW  58
03D30:  MOVLB  5
03D32:  MOVWF  x51
03D34:  MOVLB  0
03D36:  RCALL  3CC8
....................    safei2c_write(0x40);   // TCON0 
03D38:  MOVLW  40
03D3A:  MOVLB  5
03D3C:  MOVWF  x51
03D3E:  MOVLB  0
03D40:  RCALL  3CC8
....................    safei2c_write(0xff);   // Connect 0 and 1 
03D42:  MOVLB  5
03D44:  SETF   x51
03D46:  MOVLB  0
03D48:  RCALL  3CC8
....................    safei2c_write(0xa0);   // TCON1 
03D4A:  MOVLW  A0
03D4C:  MOVLB  5
03D4E:  MOVWF  x51
03D50:  MOVLB  0
03D52:  RCALL  3CC8
....................    safei2c_write(0xff);   // Connect 2 and 3 
03D54:  MOVLB  5
03D56:  SETF   x51
03D58:  MOVLB  0
03D5A:  RCALL  3CC8
....................    i2c_stop(); 
03D5C:  BSF    FC5.2
03D5E:  BTFSC  FC5.2
03D60:  BRA    3D5E
....................     
....................    global_mppc_value = value; 
03D62:  MOVFF  550,B6
03D66:  RETURN 0
.................... } 
....................  
.................... void  set_fixture_dac(uint16_t dac_value) 
.................... { 
....................    safeI2C_start(); 
*
03DD6:  RCALL  3C8A
....................  
.................... //   fl_FIXTURE = !i2c_write(0x40);   // (0x40) Write FIXTURE DAC address 
.................... //   if (!fl_FIXTURE); 
.................... //   { 
.................... //      i2c_stop(); 
.................... //      return; 
.................... //   } 
....................     
....................    safei2c_write(0x40); 
03DD8:  MOVLW  40
03DDA:  MOVLB  5
03DDC:  MOVWF  x51
03DDE:  MOVLB  0
03DE0:  RCALL  3CC8
....................    safei2c_write(0x30); 
03DE2:  MOVLW  30
03DE4:  MOVLB  5
03DE6:  MOVWF  x51
03DE8:  MOVLB  0
03DEA:  RCALL  3CC8
....................  
....................    dac_value <<= 4;        // shift 12 bit value so that MS bit is at bit15  
03DEC:  MOVLB  5
03DEE:  RLCF   x48,F
03DF0:  RLCF   x49,F
03DF2:  RLCF   x48,F
03DF4:  RLCF   x49,F
03DF6:  RLCF   x48,F
03DF8:  RLCF   x49,F
03DFA:  RLCF   x48,F
03DFC:  RLCF   x49,F
03DFE:  MOVLW  F0
03E00:  ANDWF  x48,F
....................    safei2c_write (make8(dac_value,1));  
03E02:  MOVFF  549,54A
03E06:  MOVFF  549,551
03E0A:  MOVLB  0
03E0C:  RCALL  3CC8
....................    safei2c_write (make8(dac_value,0)); 
03E0E:  MOVFF  548,54A
03E12:  MOVFF  548,551
03E16:  RCALL  3CC8
....................    i2c_stop(); 
03E18:  BSF    FC5.2
03E1A:  BTFSC  FC5.2
03E1C:  BRA    3E1A
....................     
....................    global_fixture_dac_value = dac_value; 
03E1E:  MOVFF  549,BB
03E22:  MOVFF  548,BA
03E26:  GOTO   3E80 (RETURN)
.................... } 
....................  
.................... void adjust_brake_for_rpm(uint16_t rpm_set_value) 
.................... { 
....................    if (calc_gen_rpm() < rpm_set_value) 
....................    { 
....................       if (global_brake_duty != NO_BRK) 
....................       { 
....................          global_brake_duty--; 
....................       } 
....................       set_brake_duty(global_brake_duty); 
....................    } 
....................    else if (calc_gen_rpm() > rpm_set_value) 
....................    { 
....................       if (global_brake_duty != MAX_BRK) 
....................       { 
....................          global_brake_duty++; 
....................       } 
....................       set_brake_duty(global_brake_duty); 
....................    } 
.................... } 
....................  
.................... void adjust_brake_for_vgen(uint16_t vgen_set_value) 
.................... { 
....................    if (get_vgen(0) < vgen_set_value) 
....................    { 
....................       if (global_brake_duty != NO_BRK) 
....................       { 
....................          global_brake_duty--; 
....................       } 
....................       set_brake_duty(global_brake_duty); 
....................    } 
....................    else if (get_vgen(0) > vgen_set_value) 
....................    { 
....................       if (global_brake_duty != MAX_BRK) 
....................       { 
....................          global_brake_duty++; 
....................       } 
....................       set_brake_duty(global_brake_duty); 
....................    } 
.................... } 
....................  
....................     
.................... void adjust_fixture_for_rpm(uint16_t fixture_set_value) 
.................... { 
....................    if (calc_gen_rpm() < fixture_set_value) 
....................    { 
....................       if (global_fixture_dac_value != NO_FIXTURE) 
....................       { 
....................          global_fixture_dac_value--; 
....................       } 
....................       set_fixture_dac(global_fixture_dac_value); 
....................    } 
....................    else if (calc_gen_rpm() > fixture_set_value) 
....................    { 
....................       if (global_fixture_dac_value != MAX_FIXTURE) 
....................       { 
....................          global_fixture_dac_value++; 
....................       } 
....................       set_fixture_dac(global_fixture_dac_value); 
....................    } 
.................... }       
....................        
.................... void adjust_mppc(void) 
.................... { 
....................    static uint16_t last_vbatt_measurement = 0; 
....................    static uint16_t current_vbatt_measurement = 0; 
....................    static uint8_t last_mppc_value = 0; 
....................    static uint8_t last_last_mppc_value = 0; 
....................     
....................    // if the battery is full, exit 
....................     
....................     current_vbatt_measurement = get_vbatt(0); 
*
09C3C:  MOVLB  5
09C3E:  CLRF   x66
09C40:  MOVLB  0
09C42:  CALL   40A4
09C46:  MOVFF  02,538
09C4A:  MOVFF  01,537
....................      
....................    // first time to initalize values 
....................    if ((last_vbatt_measurement == 0) || (last_mppc_value == 0)) 
09C4E:  MOVLB  5
09C50:  MOVF   x35,F
09C52:  BNZ   9C58
09C54:  MOVF   x36,F
09C56:  BZ    9C5C
09C58:  MOVF   x39,F
09C5A:  BNZ   9C68
....................    { 
....................       last_vbatt_measurement = current_vbatt_measurement; 
09C5C:  MOVFF  538,536
09C60:  MOVFF  537,535
....................       last_mppc_value = global_mppc_value; 
09C64:  MOVFF  B6,539
....................    } 
....................    last_last_mppc_value = last_mppc_value; 
09C68:  MOVFF  539,53A
....................    last_mppc_value = global_mppc_value; 
09C6C:  MOVFF  B6,539
....................        
....................    if (last_vbatt_measurement < current_vbatt_measurement) 
09C70:  MOVF   x36,W
09C72:  SUBWF  x38,W
09C74:  BNC   9CC4
09C76:  BNZ   9C7E
09C78:  MOVF   x37,W
09C7A:  SUBWF  x35,W
09C7C:  BC    9CC4
....................    { 
....................       if (last_last_mppc_value < global_mppc_value) 
09C7E:  MOVLB  0
09C80:  MOVF   xB6,W
09C82:  MOVLB  5
09C84:  SUBWF  x3A,W
09C86:  BC    9C98
....................       { 
....................          if (global_mppc_value != MAX_MPPC) global_mppc_value+=5; 
09C88:  MOVLB  0
09C8A:  INCFSZ xB6,W
09C8C:  BRA    9C90
09C8E:  BRA    9C94
09C90:  MOVLW  05
09C92:  ADDWF  xB6,F
....................       } 
09C94:  BRA    9CC0
09C96:  MOVLB  5
....................       else if (last_last_mppc_value > global_mppc_value) 
09C98:  MOVF   x3A,W
09C9A:  MOVLB  0
09C9C:  SUBWF  xB6,W
09C9E:  BC    9CAC
....................       { 
....................          if (global_mppc_value != NO_MPPC) global_mppc_value-=5; 
09CA0:  MOVF   xB6,W
09CA2:  SUBLW  07
09CA4:  BZ    9CAA
09CA6:  MOVLW  05
09CA8:  SUBWF  xB6,F
....................       } 
09CAA:  BRA    9CC0
....................       else 
....................       { 
....................          if (global_mppc_value == NO_MPPC) global_mppc_value++; 
09CAC:  MOVF   xB6,W
09CAE:  SUBLW  07
09CB0:  BNZ   9CB6
09CB2:  INCF   xB6,F
09CB4:  BRA    9CC0
....................          else if (global_mppc_value == MAX_MPPC) global_mppc_value--; 
09CB6:  INCFSZ xB6,W
09CB8:  BRA    9CBE
09CBA:  DECF   xB6,F
09CBC:  BRA    9CC0
....................          else global_mppc_value++; 
09CBE:  INCF   xB6,F
....................       } 
....................    } 
09CC0:  BRA    9D02
09CC2:  MOVLB  5
....................    else 
....................    { 
....................       if (last_last_mppc_value > global_mppc_value) 
09CC4:  MOVF   x3A,W
09CC6:  MOVLB  0
09CC8:  SUBWF  xB6,W
09CCA:  BC    9CD6
....................       { 
....................          if (global_mppc_value != MAX_MPPC) global_mppc_value++; 
09CCC:  INCFSZ xB6,W
09CCE:  BRA    9CD2
09CD0:  BRA    9CD4
09CD2:  INCF   xB6,F
....................       } 
09CD4:  BRA    9D02
....................       else if (last_last_mppc_value < global_mppc_value) 
09CD6:  MOVF   xB6,W
09CD8:  MOVLB  5
09CDA:  SUBWF  x3A,W
09CDC:  BC    9CEC
....................       { 
....................          if (global_mppc_value != NO_MPPC) global_mppc_value--; 
09CDE:  MOVLB  0
09CE0:  MOVF   xB6,W
09CE2:  SUBLW  07
09CE4:  BZ    9CE8
09CE6:  DECF   xB6,F
....................       } 
09CE8:  BRA    9D02
09CEA:  MOVLB  5
....................       else 
....................       { 
....................          if (global_mppc_value == NO_MPPC) global_mppc_value++; 
09CEC:  MOVLB  0
09CEE:  MOVF   xB6,W
09CF0:  SUBLW  07
09CF2:  BNZ   9CF8
09CF4:  INCF   xB6,F
09CF6:  BRA    9D02
....................          else if (global_mppc_value == MAX_MPPC) global_mppc_value--; 
09CF8:  INCFSZ xB6,W
09CFA:  BRA    9D00
09CFC:  DECF   xB6,F
09CFE:  BRA    9D02
....................          else global_mppc_value++; 
09D00:  INCF   xB6,F
....................       } 
....................    } 
....................     
....................    last_vbatt_measurement = current_vbatt_measurement; 
09D02:  MOVFF  538,536
09D06:  MOVFF  537,535
....................    set_mppc(global_mppc_value); 
09D0A:  MOVFF  B6,550
09D0E:  CALL   3CDC
....................    return; 
09D12:  GOTO   AD90 (RETURN)
.................... } 
....................  
.................... uint8_t calc_mppc_by_vgen(void) 
.................... { 
....................    int16_t mppc; 
....................    mppc = (((get_vgen(0) - 100) * 20)/100); 
*
04E7C:  MOVLB  5
04E7E:  CLRF   x53
04E80:  MOVLB  0
04E82:  CALL   40FE
04E86:  MOVFF  02,553
04E8A:  MOVFF  01,552
04E8E:  MOVLW  64
04E90:  MOVLB  5
04E92:  SUBWF  x52,F
04E94:  MOVLW  00
04E96:  SUBWFB x53,F
04E98:  MOVFF  553,56C
04E9C:  MOVFF  552,56B
04EA0:  CLRF   x6E
04EA2:  MOVLW  14
04EA4:  MOVWF  x6D
04EA6:  MOVLB  0
04EA8:  RCALL  492C
04EAA:  MOVFF  02,553
04EAE:  MOVFF  01,552
04EB2:  MOVFF  02,572
04EB6:  MOVFF  01,571
04EBA:  MOVLB  5
04EBC:  CLRF   x74
04EBE:  MOVLW  64
04EC0:  MOVWF  x73
04EC2:  MOVLB  0
04EC4:  CALL   4174
04EC8:  MOVFF  02,551
04ECC:  MOVLB  5
04ECE:  MOVFF  01,550
....................    if (mppc < NO_MPPC) 
04ED2:  BTFSC  x51.7
04ED4:  BRA    4EE0
04ED6:  MOVF   x51,F
04ED8:  BNZ   4EE8
04EDA:  MOVF   x50,W
04EDC:  SUBLW  06
04EDE:  BNC   4EE8
....................    { 
....................       mppc = NO_MPPC; 
04EE0:  CLRF   x51
04EE2:  MOVLW  07
04EE4:  MOVWF  x50
....................    } 
04EE6:  BRA    4EF6
....................    else if (mppc > MAX_MPPC) 
04EE8:  BTFSC  x51.7
04EEA:  BRA    4EF6
04EEC:  MOVF   x51,W
04EEE:  SUBLW  00
04EF0:  BC    4EF6
....................    { 
....................       mppc = MAX_MPPC; 
04EF2:  CLRF   x51
04EF4:  SETF   x50
....................    } 
....................    return mppc; 
04EF6:  MOVFF  550,01
04EFA:  MOVLB  0
04EFC:  GOTO   53D0 (RETURN)
.................... } 
....................  
.................... void update_control_loop(void) 
.................... { 
.................... // Moves the brake duty and charge duty closer to their respective set points 
.................... // How quickly they move towards their set points depends on how far away they 
.................... //    are from the set points. 
....................  
....................    uint16_t rpm_difference, brake_duty_difference, charge_duty_difference; 
....................    uint8_t  duty_change, brake_duty_change, charge_duty_change; 
....................    static uint8_t  control_loop_cycles_to_next_update = 1; 
....................     
....................    /* 
....................    // if the sprinkler has no current commands, exit the control loop                   
....................    if (global_control_loop_mechanism == NO_SPRINKLER_CONTROL)  
....................    { 
....................       return; 
....................    } 
....................    */ 
....................     
....................    // set mppc to dynamic if in any other mode except test mode no rpm (with mppc hard set) 
....................    if (global_control_loop_mechanism != NO_RPM_CONTROL) 
*
053C8:  MOVF   xBC,W
053CA:  SUBLW  05
053CC:  BZ    53D4
....................    { 
....................       global_mppc_set_value = calc_mppc_by_vgen(); 
053CE:  BRA    4E7C
053D0:  MOVFF  01,B7
....................    } 
....................    // set the mppc value              
....................    set_mppc(global_mppc_set_value);   
053D4:  MOVFF  B7,550
053D8:  CALL   3CDC
....................     
....................    // if it hasn't been enough cycles to update the control loop, exit 
....................    if (--control_loop_cycles_to_next_update > 0) 
053DC:  MOVLB  5
053DE:  DECF   x3B,F
053E0:  BZ    53E8
....................    { 
....................       return; 
053E2:  GOTO   5B96
....................    } 
053E6:  BRA    53EC
....................    // otherwise, set it to the default of 1 
....................    else  
....................    { 
....................       control_loop_cycles_to_next_update = 1; 
053E8:  MOVLW  01
053EA:  MOVWF  x3B
....................    } 
....................     
....................    // grab the current rpm 
....................    global_current_rpm = calc_gen_rpm(); 
053EC:  MOVLB  0
053EE:  BRA    4F00
053F0:  MOVFF  02,A7
053F4:  MOVFF  01,A6
....................     
....................    // decide which regime we are in 
....................    switch (global_control_loop_mechanism) 
053F8:  MOVF   xBC,W
053FA:  ADDLW  F6
053FC:  BTFSC  FD8.0
053FE:  GOTO   5B94
05402:  ADDLW  0A
05404:  GOTO   5B9C
....................    { 
....................    // regular brake + charge rpm control 
....................    case BRAKE_AND_CHARGE: 
....................       // calculate the difference in rpm from set point 
....................       rpm_difference = abs((int16_t)global_current_rpm - (int16_t)global_rpm_set_value); 
05408:  MOVF   xA8,W
0540A:  SUBWF  xA6,W
0540C:  MOVLB  5
0540E:  MOVWF  x50
05410:  MOVLB  0
05412:  MOVF   xA9,W
05414:  SUBWFB xA7,W
05416:  MOVLB  5
05418:  MOVWF  x51
0541A:  MOVWF  03
0541C:  MOVF   x50,W
0541E:  BTFSS  x51.7
05420:  BRA    5432
05422:  MOVLW  00
05424:  BSF    FD8.0
05426:  SUBFWB x50,W
05428:  MOVWF  00
0542A:  MOVLW  00
0542C:  SUBFWB x51,W
0542E:  MOVWF  03
05430:  MOVF   00,W
05432:  MOVWF  x47
05434:  MOVFF  03,548
....................        
....................       // calulate how much to change the parameter (either brake or charge, just 
....................       //    reusing brake duty cycle for both) and how often to update based on  
....................       //    rpm difference from setpoint 
....................       if (rpm_difference >= 50)  
05438:  MOVF   x48,F
0543A:  BNZ   5442
0543C:  MOVF   x47,W
0543E:  SUBLW  31
05440:  BC    544C
....................       { 
....................          duty_change = 10; 
05442:  MOVLW  0A
05444:  MOVWF  x4D
....................          control_loop_cycles_to_next_update = 5;               
05446:  MOVLW  05
05448:  MOVWF  x3B
....................       } 
0544A:  BRA    5490
....................       else if (rpm_difference >= 25)  
0544C:  MOVF   x48,F
0544E:  BNZ   5456
05450:  MOVF   x47,W
05452:  SUBLW  18
05454:  BC    5460
....................       { 
....................          duty_change = 5; 
05456:  MOVLW  05
05458:  MOVWF  x4D
....................          control_loop_cycles_to_next_update = 6; 
0545A:  MOVLW  06
0545C:  MOVWF  x3B
....................       } 
0545E:  BRA    5490
....................       else if (rpm_difference >= 10) 
05460:  MOVF   x48,F
05462:  BNZ   546A
05464:  MOVF   x47,W
05466:  SUBLW  09
05468:  BC    5474
....................       { 
....................          duty_change = 4; 
0546A:  MOVLW  04
0546C:  MOVWF  x4D
....................          control_loop_cycles_to_next_update = 7; 
0546E:  MOVLW  07
05470:  MOVWF  x3B
....................       } 
05472:  BRA    5490
....................       else if (rpm_difference >= 5)  
05474:  MOVF   x48,F
05476:  BNZ   547E
05478:  MOVF   x47,W
0547A:  SUBLW  04
0547C:  BC    5488
....................       { 
....................          duty_change = 2; 
0547E:  MOVLW  02
05480:  MOVWF  x4D
....................          control_loop_cycles_to_next_update = 8; 
05482:  MOVLW  08
05484:  MOVWF  x3B
....................       } 
05486:  BRA    5490
.................... //      else if (rpm_difference >= 0)  
....................       else 
....................       {   
....................          duty_change = 1; 
05488:  MOVLW  01
0548A:  MOVWF  x4D
....................          control_loop_cycles_to_next_update = 10; 
0548C:  MOVLW  0A
0548E:  MOVWF  x3B
....................       } 
....................        
....................       // Set point is lower than current value (increase braking force) 
....................       if (global_current_rpm > global_rpm_set_value)  
05490:  MOVLB  0
05492:  MOVF   xA9,W
05494:  SUBWF  xA7,W
05496:  BTFSS  FD8.0
05498:  BRA    558C
0549A:  BNZ   54A4
0549C:  MOVF   xA6,W
0549E:  SUBWF  xA8,W
054A0:  BTFSC  FD8.0
054A2:  BRA    558C
....................       { 
....................          // if we are at max charge already, move to the braking 
....................          if (global_charge_duty == MAX_CHARGE) 
054A4:  MOVF   xB0,W
054A6:  SUBLW  90
054A8:  BNZ   5534
054AA:  DECFSZ xB1,W
054AC:  BRA    5534
....................          { 
....................             // if we are at max brake (and charge) and detecting a magnetic decoupling condition 
....................             if ((global_brake_duty == MAX_BRK) && (global_current_rpm == 0-1)) 
054AE:  MOVF   xAE,W
054B0:  SUBLW  90
054B2:  BNZ   54C2
054B4:  DECFSZ xAF,W
054B6:  BRA    54C2
054B8:  INCFSZ xA6,W
054BA:  BRA    54C2
054BC:  INCFSZ xA7,W
054BE:  BRA    54C2
....................             { 
.................... #IFNDEF DISABLE_MAG_DECOUPLING_RECOVERY 
....................              
....................                // start magnetic de-coupling fix 
....................                // set an error bit saying magnetic decoupling is detected 
....................                global_error_message_bitfield |= ERR_MSG_MAG_DECOUPLING; 
....................                // send error message 
....................                PUSH_MESSAGE_QUEUE_MACRO(MSG_MOTE_ERROR_MSG); 
....................                // push a MOVE_VALVE_MAG_DECOUPLING_RECOVERY event 
....................                PUSH_PRIORITY_QUEUE_MACRO(MOVE_VALVE_MAG_DECOUPLING_RECOVERY); 
.................... #ENDIF 
....................             } 
054C0:  BRA    5532
....................  
....................             // if we are at max brake (and charge) (no decoupling) send an error message 
....................             else if (global_brake_duty == MAX_BRK) 
054C2:  MOVF   xAE,W
054C4:  SUBLW  90
054C6:  BNZ   54E0
054C8:  DECFSZ xAF,W
054CA:  BRA    54E0
....................             { 
....................                // set an error bit saying rpm was too low to reach 
....................                global_error_message_bitfield |= ERR_MSG_RPM_TOO_LOW_TO_REACH; 
054CC:  MOVLB  4
054CE:  BSF    xF4.5
....................                // send error message 
....................                PUSH_MESSAGE_QUEUE_MACRO(MSG_MOTE_ERROR_MSG); 
054D0:  BCF    F7A.1
054D2:  MOVLW  A0
054D4:  MOVLB  5
054D6:  MOVWF  x50
054D8:  MOVLB  0
054DA:  RCALL  4FE0
054DC:  BSF    F7A.1
....................             } 
054DE:  BRA    5532
....................             // if we can't increase charge anymore, set it to max 
....................             else if ((global_brake_duty + duty_change) > MAX_CHARGE) 
054E0:  MOVLB  5
054E2:  MOVF   x4D,W
054E4:  MOVLB  0
054E6:  ADDWF  xAE,W
054E8:  MOVLB  5
054EA:  MOVWF  x50
054EC:  MOVLW  00
054EE:  MOVLB  0
054F0:  ADDWFC xAF,W
054F2:  MOVLB  5
054F4:  MOVWF  x51
054F6:  SUBLW  00
054F8:  BC    5514
054FA:  XORLW  FF
054FC:  BNZ   5504
054FE:  MOVF   x50,W
05500:  SUBLW  90
05502:  BC    5514
....................             { 
....................                set_brake_duty(MAX_BRK); 
05504:  MOVLW  01
05506:  MOVWF  x53
05508:  MOVLW  90
0550A:  MOVWF  x52
0550C:  MOVLB  0
0550E:  RCALL  52F8
....................             } 
05510:  BRA    5532
05512:  MOVLB  5
....................             // increase braking as per normal 
....................             else 
....................             { 
....................                set_brake_duty(global_brake_duty + duty_change); 
05514:  MOVF   x4D,W
05516:  MOVLB  0
05518:  ADDWF  xAE,W
0551A:  MOVLB  5
0551C:  MOVWF  x50
0551E:  MOVLW  00
05520:  MOVLB  0
05522:  ADDWFC xAF,W
05524:  MOVLB  5
05526:  MOVWF  x51
05528:  MOVWF  x53
0552A:  MOVFF  550,552
0552E:  MOVLB  0
05530:  RCALL  52F8
....................             } 
....................          }   
05532:  BRA    558A
....................          // if we can't increase charge anymore, set it to max 
....................          else if ((global_charge_duty + duty_change) > MAX_CHARGE) 
05534:  MOVLB  5
05536:  MOVF   x4D,W
05538:  MOVLB  0
0553A:  ADDWF  xB0,W
0553C:  MOVLB  5
0553E:  MOVWF  x50
05540:  MOVLW  00
05542:  MOVLB  0
05544:  ADDWFC xB1,W
05546:  MOVLB  5
05548:  MOVWF  x51
0554A:  SUBLW  00
0554C:  BC    556A
0554E:  XORLW  FF
05550:  BNZ   5558
05552:  MOVF   x50,W
05554:  SUBLW  90
05556:  BC    556A
....................          { 
....................             set_charge_duty(MAX_CHARGE); 
05558:  MOVLW  01
0555A:  MOVWF  x53
0555C:  MOVLW  90
0555E:  MOVWF  x52
05560:  MOVLB  0
05562:  CALL   3D68
....................          } 
05566:  BRA    558A
05568:  MOVLB  5
....................         // increase charging as per normal 
....................         else 
....................         { 
....................             set_charge_duty(global_charge_duty + duty_change); 
0556A:  MOVF   x4D,W
0556C:  MOVLB  0
0556E:  ADDWF  xB0,W
05570:  MOVLB  5
05572:  MOVWF  x50
05574:  MOVLW  00
05576:  MOVLB  0
05578:  ADDWFC xB1,W
0557A:  MOVLB  5
0557C:  MOVWF  x51
0557E:  MOVWF  x53
05580:  MOVFF  550,552
05584:  MOVLB  0
05586:  CALL   3D68
....................         } 
....................       } 
0558A:  BRA    5676
....................       // Set point is higher than current value (increase braking force) 
....................       else if (global_current_rpm < global_rpm_set_value)  
0558C:  MOVF   xA7,W
0558E:  SUBWF  xA9,W
05590:  BTFSS  FD8.0
05592:  BRA    5676
05594:  BNZ   559E
05596:  MOVF   xA8,W
05598:  SUBWF  xA6,W
0559A:  BTFSC  FD8.0
0559C:  BRA    5676
....................       { 
....................          // if we are at min braking already, move to the charging 
....................          if (global_brake_duty == NO_BRK) 
0559E:  MOVF   xAE,F
055A0:  BNZ   5628
055A2:  MOVF   xAF,F
055A4:  BNZ   5628
....................          { 
....................             // if we are at min charge (and brake) and the rpms are 0  
....................             // (a not spinning condition) 
....................             if ((global_charge_duty == NO_CHARGE) && (global_current_rpm == 0)) 
055A6:  MOVF   xB0,F
055A8:  BNZ   55B8
055AA:  MOVF   xB1,F
055AC:  BNZ   55B8
055AE:  MOVF   xA6,F
055B0:  BNZ   55B8
055B2:  MOVF   xA7,F
055B4:  BNZ   55B8
....................             { 
.................... #IFNDEF DISABLE_NO_SPIN_RECOVERY             
....................                // start not spinning recovery 
....................                // set an error bit saying there isn't any spinning 
....................                global_error_message_bitfield |= ERR_MSG_NOT_SPINNING; 
....................                // send error message to manager 
....................                PUSH_MESSAGE_QUEUE_MACRO(MSG_MOTE_ERROR_MSG); 
....................                // push a MOVE_VALVE_NO_SPIN_RECOVERY event                
....................                PUSH_PRIORITY_QUEUE_MACRO(MOVE_VALVE_NO_SPIN_RECOVERY); 
.................... #ENDIF 
....................             } 
055B6:  BRA    5626
....................             // if we are at min charge (and brake) send an error message if 
....................             //    the bitfield bit isn't already sent (to avoid sending messages 
....................             //    all the time 
....................             else if (global_charge_duty == NO_CHARGE)  
055B8:  MOVF   xB0,F
055BA:  BNZ   55D4
055BC:  MOVF   xB1,F
055BE:  BNZ   55D4
....................             { 
....................                // set an error bit saying rpm was too high to reach 
....................                global_error_message_bitfield |= ERR_MSG_RPM_TOO_HIGH_TO_REACH; 
055C0:  MOVLB  4
055C2:  BSF    xF4.4
....................                // send error message to manager 
....................                PUSH_MESSAGE_QUEUE_MACRO(MSG_MOTE_ERROR_MSG); 
055C4:  BCF    F7A.1
055C6:  MOVLW  A0
055C8:  MOVLB  5
055CA:  MOVWF  x50
055CC:  MOVLB  0
055CE:  RCALL  4FE0
055D0:  BSF    F7A.1
....................             } 
055D2:  BRA    5626
....................             // if we can't decrease charge anymore, set it to min 
....................             // notice use of unsigned math here  
....................             else if ((global_charge_duty - duty_change) > MAX_CHARGE) 
055D4:  MOVLB  5
055D6:  MOVF   x4D,W
055D8:  MOVLB  0
055DA:  SUBWF  xB0,W
055DC:  MOVLB  5
055DE:  MOVWF  x50
055E0:  MOVLW  00
055E2:  MOVLB  0
055E4:  SUBWFB xB1,W
055E6:  MOVLB  5
055E8:  MOVWF  x51
055EA:  SUBLW  00
055EC:  BC    5606
055EE:  XORLW  FF
055F0:  BNZ   55F8
055F2:  MOVF   x50,W
055F4:  SUBLW  90
055F6:  BC    5606
....................             { 
....................                set_charge_duty(NO_CHARGE); 
055F8:  CLRF   x53
055FA:  CLRF   x52
055FC:  MOVLB  0
055FE:  CALL   3D68
....................             } 
05602:  BRA    5626
05604:  MOVLB  5
....................             // decrease charging as per normal 
....................             else 
....................             { 
....................                set_charge_duty(global_charge_duty - duty_change); 
05606:  MOVF   x4D,W
05608:  MOVLB  0
0560A:  SUBWF  xB0,W
0560C:  MOVLB  5
0560E:  MOVWF  x50
05610:  MOVLW  00
05612:  MOVLB  0
05614:  SUBWFB xB1,W
05616:  MOVLB  5
05618:  MOVWF  x51
0561A:  MOVWF  x53
0561C:  MOVFF  550,552
05620:  MOVLB  0
05622:  CALL   3D68
....................             } 
....................          }   
05626:  BRA    5676
....................          // if we can't decrease brake anymore, set it to min 
....................          // notice use of unsigned math here  
....................          else if ((global_brake_duty - duty_change) > MAX_BRK) 
05628:  MOVLB  5
0562A:  MOVF   x4D,W
0562C:  MOVLB  0
0562E:  SUBWF  xAE,W
05630:  MOVLB  5
05632:  MOVWF  x50
05634:  MOVLW  00
05636:  MOVLB  0
05638:  SUBWFB xAF,W
0563A:  MOVLB  5
0563C:  MOVWF  x51
0563E:  SUBLW  00
05640:  BC    5658
05642:  XORLW  FF
05644:  BNZ   564C
05646:  MOVF   x50,W
05648:  SUBLW  90
0564A:  BC    5658
....................          { 
....................             set_brake_duty(NO_BRK); 
0564C:  CLRF   x53
0564E:  CLRF   x52
05650:  MOVLB  0
05652:  RCALL  52F8
....................          } 
05654:  BRA    5676
05656:  MOVLB  5
....................         // decrease braking as per normal 
....................         else 
....................         { 
....................             set_brake_duty(global_brake_duty - duty_change); 
05658:  MOVF   x4D,W
0565A:  MOVLB  0
0565C:  SUBWF  xAE,W
0565E:  MOVLB  5
05660:  MOVWF  x50
05662:  MOVLW  00
05664:  MOVLB  0
05666:  SUBWFB xAF,W
05668:  MOVLB  5
0566A:  MOVWF  x51
0566C:  MOVWF  x53
0566E:  MOVFF  550,552
05672:  MOVLB  0
05674:  RCALL  52F8
....................         } 
....................       } 
....................       break; 
05676:  BRA    5B94
....................        
....................    // RPM is only controlled by brake (when charger is turned off 
....................    case BRAKE_ONLY: 
....................    case BRAKE_AND_CHARGE_START: 
....................       // calculate the difference in rpm from set point 
....................       rpm_difference = abs((int16_t)global_current_rpm - (int16_t)global_rpm_set_value); 
05678:  MOVF   xA8,W
0567A:  SUBWF  xA6,W
0567C:  MOVLB  5
0567E:  MOVWF  x50
05680:  MOVLB  0
05682:  MOVF   xA9,W
05684:  SUBWFB xA7,W
05686:  MOVLB  5
05688:  MOVWF  x51
0568A:  MOVWF  03
0568C:  MOVF   x50,W
0568E:  BTFSS  x51.7
05690:  BRA    56A2
05692:  MOVLW  00
05694:  BSF    FD8.0
05696:  SUBFWB x50,W
05698:  MOVWF  00
0569A:  MOVLW  00
0569C:  SUBFWB x51,W
0569E:  MOVWF  03
056A0:  MOVF   00,W
056A2:  MOVWF  x47
056A4:  MOVFF  03,548
....................        
....................       // calulate how much to change the parameter (either brake or charge, just 
....................       //    reusing brake duty cycle for both) and how often to update based on  
....................       //    rpm difference from setpoint 
....................       if (rpm_difference >= 50)  
056A8:  MOVF   x48,F
056AA:  BNZ   56B2
056AC:  MOVF   x47,W
056AE:  SUBLW  31
056B0:  BC    56BC
....................       { 
....................          duty_change = 15; 
056B2:  MOVLW  0F
056B4:  MOVWF  x4D
....................          control_loop_cycles_to_next_update = 5; 
056B6:  MOVLW  05
056B8:  MOVWF  x3B
....................       } 
056BA:  BRA    5700
....................       else if (rpm_difference >= 25)  
056BC:  MOVF   x48,F
056BE:  BNZ   56C6
056C0:  MOVF   x47,W
056C2:  SUBLW  18
056C4:  BC    56D0
....................       { 
....................          duty_change = 10; 
056C6:  MOVLW  0A
056C8:  MOVWF  x4D
....................          control_loop_cycles_to_next_update = 5; 
056CA:  MOVLW  05
056CC:  MOVWF  x3B
....................       } 
056CE:  BRA    5700
....................       else if (rpm_difference >= 10) 
056D0:  MOVF   x48,F
056D2:  BNZ   56DA
056D4:  MOVF   x47,W
056D6:  SUBLW  09
056D8:  BC    56E4
....................       { 
....................          duty_change = 5; 
056DA:  MOVLW  05
056DC:  MOVWF  x4D
....................          control_loop_cycles_to_next_update = 7; 
056DE:  MOVLW  07
056E0:  MOVWF  x3B
....................       } 
056E2:  BRA    5700
....................       else if (rpm_difference >= 5)  
056E4:  MOVF   x48,F
056E6:  BNZ   56EE
056E8:  MOVF   x47,W
056EA:  SUBLW  04
056EC:  BC    56F8
....................       { 
....................          duty_change = 2; 
056EE:  MOVLW  02
056F0:  MOVWF  x4D
....................          control_loop_cycles_to_next_update = 8; 
056F2:  MOVLW  08
056F4:  MOVWF  x3B
....................       } 
056F6:  BRA    5700
.................... //      else if (rpm_difference >= 0)  
....................       else 
....................       {   
....................          duty_change = 1; 
056F8:  MOVLW  01
056FA:  MOVWF  x4D
....................          control_loop_cycles_to_next_update = 8; 
056FC:  MOVLW  08
056FE:  MOVWF  x3B
....................       } 
....................        
....................       // Set point is lower than current value (increase braking force) 
....................       if (global_current_rpm > global_rpm_set_value)  
05700:  MOVLB  0
05702:  MOVF   xA9,W
05704:  SUBWF  xA7,W
05706:  BNC   5784
05708:  BNZ   5710
0570A:  MOVF   xA6,W
0570C:  SUBWF  xA8,W
0570E:  BC    5784
....................       { 
....................       // if we are at max brake (and charge) and detecting a magnetic decoupling condition 
....................          if ((global_brake_duty == MAX_BRK) && (global_current_rpm == 0-1)) 
05710:  MOVF   xAE,W
05712:  SUBLW  90
05714:  BNZ   5724
05716:  DECFSZ xAF,W
05718:  BRA    5724
0571A:  INCFSZ xA6,W
0571C:  BRA    5724
0571E:  INCFSZ xA7,W
05720:  BRA    5724
....................          { 
.................... #IFNDEF DISABLE_MAG_DECOUPLING_RECOVERY          
....................             // start magnetic de-coupling fix 
....................             // set an error bit saying magnetic decoupling is detected 
....................             global_error_message_bitfield |= ERR_MSG_MAG_DECOUPLING; 
....................             // send error message 
....................             PUSH_MESSAGE_QUEUE_MACRO(MSG_MOTE_ERROR_MSG); 
....................             // push a MOVE_VALVE_MAG_DECOUPLING_RECOVERY event 
....................             PUSH_PRIORITY_QUEUE_MACRO(MOVE_VALVE_MAG_DECOUPLING_RECOVERY); 
.................... #ENDIF             
....................          } 
05722:  BRA    5782
....................          // if we are at max brake (and charge) send an error message 
....................          else if (global_brake_duty == MAX_BRK) 
05724:  MOVF   xAE,W
05726:  SUBLW  90
05728:  BNZ   5730
0572A:  DECFSZ xAF,W
0572C:  BRA    5730
....................          { 
.................... #IFNDEF DISABLE_MAG_DECOUPLING_RECOVERY          
....................             // set an error bit saying rpm was too low to reach 
....................             global_error_message_bitfield |= ERR_MSG_MAG_DECOUPLING; 
....................             // send error message 
....................             PUSH_MESSAGE_QUEUE_MACRO(MSG_MOTE_ERROR_MSG); 
.................... #ENDIF 
....................          } 
0572E:  BRA    5782
....................          // if we can't increase charge anymore, set it to max 
....................          else if ((global_brake_duty + duty_change) > MAX_CHARGE) 
05730:  MOVLB  5
05732:  MOVF   x4D,W
05734:  MOVLB  0
05736:  ADDWF  xAE,W
05738:  MOVLB  5
0573A:  MOVWF  x50
0573C:  MOVLW  00
0573E:  MOVLB  0
05740:  ADDWFC xAF,W
05742:  MOVLB  5
05744:  MOVWF  x51
05746:  SUBLW  00
05748:  BC    5764
0574A:  XORLW  FF
0574C:  BNZ   5754
0574E:  MOVF   x50,W
05750:  SUBLW  90
05752:  BC    5764
....................          { 
....................             set_brake_duty(MAX_BRK); 
05754:  MOVLW  01
05756:  MOVWF  x53
05758:  MOVLW  90
0575A:  MOVWF  x52
0575C:  MOVLB  0
0575E:  RCALL  52F8
....................          } 
05760:  BRA    5782
05762:  MOVLB  5
....................          // increase braking as per normal 
....................          else 
....................          { 
....................             set_brake_duty(global_brake_duty + duty_change); 
05764:  MOVF   x4D,W
05766:  MOVLB  0
05768:  ADDWF  xAE,W
0576A:  MOVLB  5
0576C:  MOVWF  x50
0576E:  MOVLW  00
05770:  MOVLB  0
05772:  ADDWFC xAF,W
05774:  MOVLB  5
05776:  MOVWF  x51
05778:  MOVWF  x53
0577A:  MOVFF  550,552
0577E:  MOVLB  0
05780:  RCALL  52F8
....................          } 
....................         
....................       } 
05782:  BRA    580E
....................       // Set point is higher than current value (increase braking force) 
....................       else if (global_current_rpm < global_rpm_set_value)  
05784:  MOVF   xA7,W
05786:  SUBWF  xA9,W
05788:  BNC   580E
0578A:  BNZ   5792
0578C:  MOVF   xA8,W
0578E:  SUBWF  xA6,W
05790:  BC    580E
....................       { 
....................           
....................          // if we are at min charge (and brake) and the rpms are 0  
....................          // (a not spinning condition) 
....................          if (global_brake_duty == NO_BRK && (global_current_rpm == 0)) 
05792:  MOVF   xAE,F
05794:  BNZ   57A4
05796:  MOVF   xAF,F
05798:  BNZ   57A4
0579A:  MOVF   xA6,F
0579C:  BNZ   57A4
0579E:  MOVF   xA7,F
057A0:  BNZ   57A4
....................          { 
.................... #IFNDEF DISABLE_NO_SPIN_RECOVERY        
....................             // start not spinning recovery 
....................             // set an error bit saying there isn't any spinning 
....................             global_error_message_bitfield |= ERR_MSG_NOT_SPINNING; 
....................             // send error message to manager 
....................             PUSH_MESSAGE_QUEUE_MACRO(MSG_MOTE_ERROR_MSG); 
....................             // push a MOVE_VALVE_NO_SPIN_RECOVERY event                
....................             PUSH_PRIORITY_QUEUE_MACRO(MOVE_VALVE_NO_SPIN_RECOVERY); 
.................... #ENDIF 
....................          } 
057A2:  BRA    580E
....................          // if we are at min braking already, move to the charging 
....................          else if (global_brake_duty == NO_BRK) 
057A4:  MOVF   xAE,F
057A6:  BNZ   57C0
057A8:  MOVF   xAF,F
057AA:  BNZ   57C0
....................          { 
....................             // if we are at min charge (and brake) send an error message if 
....................             //    the bitfield bit isn't already sent (to avoid sending messages 
....................             //    all the time 
....................     
....................             // set an error bit saying rpm was too high to reach 
....................             global_error_message_bitfield |= ERR_MSG_RPM_TOO_HIGH_TO_REACH; 
057AC:  MOVLB  4
057AE:  BSF    xF4.4
....................             // send error message to manager 
....................             PUSH_MESSAGE_QUEUE_MACRO(MSG_MOTE_ERROR_MSG);   
057B0:  BCF    F7A.1
057B2:  MOVLW  A0
057B4:  MOVLB  5
057B6:  MOVWF  x50
057B8:  MOVLB  0
057BA:  RCALL  4FE0
057BC:  BSF    F7A.1
....................          }   
057BE:  BRA    580E
....................          // if we can't decrease brake anymore, set it to min 
....................          // notice use of unsigned math here  
....................          else if ((global_brake_duty - duty_change) > MAX_BRK) 
057C0:  MOVLB  5
057C2:  MOVF   x4D,W
057C4:  MOVLB  0
057C6:  SUBWF  xAE,W
057C8:  MOVLB  5
057CA:  MOVWF  x50
057CC:  MOVLW  00
057CE:  MOVLB  0
057D0:  SUBWFB xAF,W
057D2:  MOVLB  5
057D4:  MOVWF  x51
057D6:  SUBLW  00
057D8:  BC    57F0
057DA:  XORLW  FF
057DC:  BNZ   57E4
057DE:  MOVF   x50,W
057E0:  SUBLW  90
057E2:  BC    57F0
....................          { 
....................             set_brake_duty(NO_BRK); 
057E4:  CLRF   x53
057E6:  CLRF   x52
057E8:  MOVLB  0
057EA:  RCALL  52F8
....................          } 
057EC:  BRA    580E
057EE:  MOVLB  5
....................         // decrease braking as per normal 
....................         else 
....................         { 
....................             set_brake_duty(global_brake_duty - duty_change); 
057F0:  MOVF   x4D,W
057F2:  MOVLB  0
057F4:  SUBWF  xAE,W
057F6:  MOVLB  5
057F8:  MOVWF  x50
057FA:  MOVLW  00
057FC:  MOVLB  0
057FE:  SUBWFB xAF,W
05800:  MOVLB  5
05802:  MOVWF  x51
05804:  MOVWF  x53
05806:  MOVFF  550,552
0580A:  MOVLB  0
0580C:  RCALL  52F8
....................         } 
....................       } 
....................        
....................       // if we are in the brake only loop and want to turn off charger 
....................       if (global_control_loop_mechanism == BRAKE_ONLY) 
0580E:  MOVF   xBC,W
05810:  SUBLW  02
05812:  BNZ   585E
....................       { 
....................          // turn down charging until it is off (slowly) 
....................          if (global_charge_duty != NO_CHARGE) 
05814:  MOVF   xB0,F
05816:  BNZ   581C
05818:  MOVF   xB1,F
0581A:  BZ    585C
....................          { 
....................             // if gobal_charge_duty is 0-3 (note unsigned int math) 
....................             if ((global_charge_duty - 4) > MAX_CHARGE) 
0581C:  MOVLW  04
0581E:  SUBWF  xB0,W
05820:  MOVLB  5
05822:  MOVWF  x50
05824:  MOVLW  00
05826:  MOVLB  0
05828:  SUBWFB xB1,W
0582A:  MOVLB  5
0582C:  MOVWF  x51
0582E:  SUBLW  00
05830:  BC    5846
05832:  XORLW  FF
05834:  BNZ   583C
05836:  MOVF   x50,W
05838:  SUBLW  90
0583A:  BC    5846
....................             { 
....................                // set it to no charge 
....................                global_charge_duty = NO_CHARGE; 
0583C:  MOVLB  0
0583E:  CLRF   xB1
05840:  CLRF   xB0
....................             } 
05842:  BRA    5850
05844:  MOVLB  5
....................             else 
....................             { 
....................                // otherwise, decrement it by 4 
....................                global_charge_duty -= 4; 
05846:  MOVLW  04
05848:  MOVLB  0
0584A:  SUBWF  xB0,F
0584C:  MOVLW  00
0584E:  SUBWFB xB1,F
....................             } 
....................             // set lower charge amount. 
....................             set_charge_duty(global_charge_duty);  
05850:  MOVFF  B1,553
05854:  MOVFF  B0,552
05858:  CALL   3D68
....................          } 
....................       } 
0585C:  BRA    58B6
....................       // if we are trying to turn the charger back on    
....................       else if (global_control_loop_mechanism == BRAKE_AND_CHARGE_START) 
0585E:  MOVF   xBC,F
05860:  BNZ   58B6
....................       {    
....................          // if gobal_charge_duty is almost completely on 
....................          if ((global_charge_duty + 4) >= MAX_CHARGE) 
05862:  MOVLW  04
05864:  ADDWF  xB0,W
05866:  MOVLB  5
05868:  MOVWF  x50
0586A:  MOVLW  00
0586C:  MOVLB  0
0586E:  ADDWFC xB1,W
05870:  MOVLB  5
05872:  MOVWF  x51
05874:  SUBLW  00
05876:  BC    5892
05878:  XORLW  FF
0587A:  BNZ   5882
0587C:  MOVF   x50,W
0587E:  SUBLW  8F
05880:  BC    5892
....................          { 
....................             // set it to max charge 
....................             global_charge_duty = MAX_CHARGE; 
05882:  MOVLW  01
05884:  MOVLB  0
05886:  MOVWF  xB1
05888:  MOVLW  90
0588A:  MOVWF  xB0
....................             // change control loop mechanism so it changes on next loop 
....................             global_control_loop_mechanism = BRAKE_AND_CHARGE; 
0588C:  MOVLW  01
0588E:  MOVWF  xBC
....................          } 
05890:  BRA    58AA
....................          // if the braking has turned itself all the way off trying to compensate for 
....................          //    the charging turning on, switch over to the main control loop 
....................          else if(global_brake_duty == NO_BRK) 
05892:  MOVLB  0
05894:  MOVF   xAE,F
05896:  BNZ   58A2
05898:  MOVF   xAF,F
0589A:  BNZ   58A2
....................          { 
....................             // change control loop mechanism 
....................             global_control_loop_mechanism = BRAKE_AND_CHARGE; 
0589C:  MOVLW  01
0589E:  MOVWF  xBC
....................          } 
058A0:  BRA    58AA
....................          // otherwise, keep increasing the charge duty cycle. 
....................          else 
....................          { 
....................             // otherwise, decrement it by 4 
....................             global_charge_duty += 4; 
058A2:  MOVLW  04
058A4:  ADDWF  xB0,F
058A6:  MOVLW  00
058A8:  ADDWFC xB1,F
....................          } 
....................          // set higher charge amount. 
....................          set_charge_duty(global_charge_duty); 
058AA:  MOVFF  B1,553
058AE:  MOVFF  B0,552
058B2:  CALL   3D68
....................       } 
....................       break; 
058B6:  BRA    5B94
....................        
....................        
....................    // If in no rpm test mode 
....................    case NO_RPM_CONTROL_DYN_MPPC: 
....................    case NO_RPM_CONTROL: 
....................  
....................       // move things closer to the set values 
....................       // worst case senario 2.3 seconds to move 400 counts 
....................        
....................       // if difference is >= 200, move by 20  
....................       // if difference is >= 100, move by 10 
....................       // if difference is >= 50, move by 5 
....................       // if difference is >= 10, move by 2 
....................       // if difference is < 10, move by 1 
....................        
....................       brake_duty_difference = abs((int16_t)global_brake_duty - (int16_t)global_brake_duty_set_value); 
058B8:  MOVF   xB2,W
058BA:  SUBWF  xAE,W
058BC:  MOVLB  5
058BE:  MOVWF  x50
058C0:  MOVLB  0
058C2:  MOVF   xB3,W
058C4:  SUBWFB xAF,W
058C6:  MOVLB  5
058C8:  MOVWF  x51
058CA:  MOVWF  03
058CC:  MOVF   x50,W
058CE:  BTFSS  x51.7
058D0:  BRA    58E2
058D2:  MOVLW  00
058D4:  BSF    FD8.0
058D6:  SUBFWB x50,W
058D8:  MOVWF  00
058DA:  MOVLW  00
058DC:  SUBFWB x51,W
058DE:  MOVWF  03
058E0:  MOVF   00,W
058E2:  MOVWF  x49
058E4:  MOVFF  03,54A
....................       charge_duty_difference = abs((int16_t)global_charge_duty - (int16_t)global_charge_duty_set_value); 
058E8:  MOVLB  0
058EA:  MOVF   xB4,W
058EC:  SUBWF  xB0,W
058EE:  MOVLB  5
058F0:  MOVWF  x50
058F2:  MOVLB  0
058F4:  MOVF   xB5,W
058F6:  SUBWFB xB1,W
058F8:  MOVLB  5
058FA:  MOVWF  x51
058FC:  MOVWF  03
058FE:  MOVF   x50,W
05900:  BTFSS  x51.7
05902:  BRA    5914
05904:  MOVLW  00
05906:  BSF    FD8.0
05908:  SUBFWB x50,W
0590A:  MOVWF  00
0590C:  MOVLW  00
0590E:  SUBFWB x51,W
05910:  MOVWF  03
05912:  MOVF   00,W
05914:  MOVWF  x4B
05916:  MOVFF  03,54C
....................        
....................       if (brake_duty_difference >= 200) brake_duty_change = 20; 
0591A:  MOVF   x4A,F
0591C:  BNZ   5924
0591E:  MOVF   x49,W
05920:  SUBLW  C7
05922:  BC    592A
05924:  MOVLW  14
05926:  MOVWF  x4E
05928:  BRA    5966
....................       else if (brake_duty_difference >= 100) brake_duty_change = 10; 
0592A:  MOVF   x4A,F
0592C:  BNZ   5934
0592E:  MOVF   x49,W
05930:  SUBLW  63
05932:  BC    593A
05934:  MOVLW  0A
05936:  MOVWF  x4E
05938:  BRA    5966
....................       else if (brake_duty_difference >= 50) brake_duty_change = 5; 
0593A:  MOVF   x4A,F
0593C:  BNZ   5944
0593E:  MOVF   x49,W
05940:  SUBLW  31
05942:  BC    594A
05944:  MOVLW  05
05946:  MOVWF  x4E
05948:  BRA    5966
....................       else if (brake_duty_difference >= 10) brake_duty_change = 2; 
0594A:  MOVF   x4A,F
0594C:  BNZ   5954
0594E:  MOVF   x49,W
05950:  SUBLW  09
05952:  BC    595A
05954:  MOVLW  02
05956:  MOVWF  x4E
05958:  BRA    5966
....................       else if (brake_duty_difference > 0) brake_duty_change = 1; 
0595A:  MOVF   x49,F
0595C:  BNZ   5962
0595E:  MOVF   x4A,F
05960:  BZ    5966
05962:  MOVLW  01
05964:  MOVWF  x4E
....................        
....................       if (global_brake_duty > global_brake_duty_set_value)  
05966:  MOVLB  0
05968:  MOVF   xB3,W
0596A:  SUBWF  xAF,W
0596C:  BNC   598E
0596E:  BNZ   5976
05970:  MOVF   xAE,W
05972:  SUBWF  xB2,W
05974:  BC    598E
....................       { 
....................          global_brake_duty-=brake_duty_change; 
05976:  MOVLB  5
05978:  MOVF   x4E,W
0597A:  MOVLB  0
0597C:  SUBWF  xAE,F
0597E:  MOVLW  00
05980:  SUBWFB xAF,F
....................          set_brake_duty(global_brake_duty); 
05982:  MOVFF  AF,553
05986:  MOVFF  AE,552
0598A:  RCALL  52F8
....................       } 
0598C:  BRA    59B2
....................       else if (global_brake_duty < global_brake_duty_set_value) 
0598E:  MOVF   xAF,W
05990:  SUBWF  xB3,W
05992:  BNC   59B2
05994:  BNZ   599C
05996:  MOVF   xB2,W
05998:  SUBWF  xAE,W
0599A:  BC    59B2
....................       { 
....................          global_brake_duty+=brake_duty_change; 
0599C:  MOVLB  5
0599E:  MOVF   x4E,W
059A0:  MOVLB  0
059A2:  ADDWF  xAE,F
059A4:  MOVLW  00
059A6:  ADDWFC xAF,F
....................          set_brake_duty(global_brake_duty); 
059A8:  MOVFF  AF,553
059AC:  MOVFF  AE,552
059B0:  RCALL  52F8
....................       } 
....................        
....................       if (charge_duty_difference >= 200) charge_duty_change = 20; 
059B2:  MOVLB  5
059B4:  MOVF   x4C,F
059B6:  BNZ   59BE
059B8:  MOVF   x4B,W
059BA:  SUBLW  C7
059BC:  BC    59C4
059BE:  MOVLW  14
059C0:  MOVWF  x4F
059C2:  BRA    5A00
....................       else if (charge_duty_difference >= 100) charge_duty_change = 10; 
059C4:  MOVF   x4C,F
059C6:  BNZ   59CE
059C8:  MOVF   x4B,W
059CA:  SUBLW  63
059CC:  BC    59D4
059CE:  MOVLW  0A
059D0:  MOVWF  x4F
059D2:  BRA    5A00
....................       else if (charge_duty_difference >= 50) charge_duty_change = 5; 
059D4:  MOVF   x4C,F
059D6:  BNZ   59DE
059D8:  MOVF   x4B,W
059DA:  SUBLW  31
059DC:  BC    59E4
059DE:  MOVLW  05
059E0:  MOVWF  x4F
059E2:  BRA    5A00
....................       else if (charge_duty_difference >= 10) charge_duty_change = 2; 
059E4:  MOVF   x4C,F
059E6:  BNZ   59EE
059E8:  MOVF   x4B,W
059EA:  SUBLW  09
059EC:  BC    59F4
059EE:  MOVLW  02
059F0:  MOVWF  x4F
059F2:  BRA    5A00
....................       else if (charge_duty_difference > 0) charge_duty_change = 1; 
059F4:  MOVF   x4B,F
059F6:  BNZ   59FC
059F8:  MOVF   x4C,F
059FA:  BZ    5A00
059FC:  MOVLW  01
059FE:  MOVWF  x4F
....................        
....................       if (global_charge_duty > global_charge_duty_set_value)  
05A00:  MOVLB  0
05A02:  MOVF   xB5,W
05A04:  SUBWF  xB1,W
05A06:  BNC   5A2A
05A08:  BNZ   5A10
05A0A:  MOVF   xB0,W
05A0C:  SUBWF  xB4,W
05A0E:  BC    5A2A
....................       { 
....................          global_charge_duty-=charge_duty_change; 
05A10:  MOVLB  5
05A12:  MOVF   x4F,W
05A14:  MOVLB  0
05A16:  SUBWF  xB0,F
05A18:  MOVLW  00
05A1A:  SUBWFB xB1,F
....................          set_charge_duty(global_charge_duty); 
05A1C:  MOVFF  B1,553
05A20:  MOVFF  B0,552
05A24:  CALL   3D68
....................       } 
05A28:  BRA    5A50
....................       else if (global_charge_duty < global_charge_duty_set_value) 
05A2A:  MOVF   xB1,W
05A2C:  SUBWF  xB5,W
05A2E:  BNC   5A50
05A30:  BNZ   5A38
05A32:  MOVF   xB4,W
05A34:  SUBWF  xB0,W
05A36:  BC    5A50
....................       { 
....................          global_charge_duty+=charge_duty_change; 
05A38:  MOVLB  5
05A3A:  MOVF   x4F,W
05A3C:  MOVLB  0
05A3E:  ADDWF  xB0,F
05A40:  MOVLW  00
05A42:  ADDWFC xB1,F
....................          set_charge_duty(global_charge_duty); 
05A44:  MOVFF  B1,553
05A48:  MOVFF  B0,552
05A4C:  CALL   3D68
....................       } 
....................       control_loop_cycles_to_next_update = 1; 
05A50:  MOVLW  01
05A52:  MOVLB  5
05A54:  MOVWF  x3B
....................       break; 
05A56:  MOVLB  0
05A58:  BRA    5B94
....................    case NO_SPIN_RECOVERY: 
....................       // it's fixed! 
....................       // RPM is above the limit (10), RPM is not MAX (for decoupled condition) and valve is moving. 
....................       if ((global_current_rpm > NOT_SPINNING_MAG_DECOUPLING_RPM_FIXED) && (global_current_rpm !=(0-1)) && (!IS_VLV_COASTING)) 
05A5A:  MOVF   xA7,F
05A5C:  BNZ   5A68
05A5E:  MOVF   xA6,W
05A60:  MOVLB  5
05A62:  SUBWF  x18,W
05A64:  BC    5AA2
05A66:  MOVLB  0
05A68:  INCFSZ xA6,W
05A6A:  BRA    5A76
05A6C:  INCFSZ xA7,W
05A6E:  BRA    5A76
05A70:  MOVLB  5
05A72:  BRA    5AA2
05A74:  MOVLB  0
05A76:  MOVF   F8D,F
05A78:  BTFSS  FD8.2
05A7A:  BRA    5A80
05A7C:  MOVLB  5
05A7E:  BRA    5AA2
....................       { 
....................          //stop the valve movement 
....................          disable_interrupts(INT_CCP3); 
05A80:  BCF    F7A.0
....................          global_valve_position_set_value = global_valve_position; 
05A82:  MOVFF  BE,C0
05A86:  MOVFF  BD,BF
....................          enable_interrupts(INT_CCP3); 
05A8A:  BSF    F7A.0
....................          // change control loop back to a normal mode 
....................          global_control_loop_mechanism = BRAKE_AND_CHARGE_START; 
05A8C:  CLRF   xBC
....................          // send a valve report to let people know of the new position 
....................          PUSH_MESSAGE_QUEUE_MACRO(MSG_MOTE_VALVE_REPORT); 
05A8E:  BCF    F7A.1
05A90:  MOVLW  92
05A92:  MOVLB  5
05A94:  MOVWF  x50
05A96:  MOVLB  0
05A98:  CALL   4FE0
05A9C:  BSF    F7A.1
....................       } 
05A9E:  BRA    5AF0
05AA0:  MOVLB  5
....................       // KINDA MESSY, FIX THIS LATER 
....................       // if the valve is within 5% of valve range (~2 seconds) of the position it's going, 
....................       //    control loop update position is slowed to 100x64ms or 6.4 seconds to give it time to react  
....................       else if ((!IS_VLV_COASTING) && ((global_valve_position_set_value - global_valve_position) < 0x0400)) 
05AA2:  MOVF   F8D,F
05AA4:  BZ    5AC4
05AA6:  MOVLB  0
05AA8:  MOVF   xBD,W
05AAA:  SUBWF  xBF,W
05AAC:  MOVLB  5
05AAE:  MOVWF  x50
05AB0:  MOVLB  0
05AB2:  MOVF   xBE,W
05AB4:  SUBWFB xC0,W
05AB6:  MOVLB  5
05AB8:  MOVWF  x51
05ABA:  SUBLW  03
05ABC:  BNC   5AC4
....................       { 
....................          control_loop_cycles_to_next_update = 100; 
05ABE:  MOVLW  64
05AC0:  MOVWF  x3B
....................       } 
05AC2:  BRA    5AF2
....................       // it tried to move the valve a bunch and it didn't fix it :-/ 
....................       else if (IS_VLV_COASTING) 
05AC4:  MOVF   F8D,F
05AC6:  BNZ   5AF2
....................       { 
....................          // set an error bit saying there isn't any spinning 
....................          global_error_message_bitfield |= ERR_MSG_MAG_NOT_SPIN_RECOVERY_FAILED; 
05AC8:  MOVLB  4
05ACA:  BSF    xF5.5
....................          // send error message to manager 
....................          PUSH_MESSAGE_QUEUE_MACRO(MSG_MOTE_ERROR_MSG); 
05ACC:  BCF    F7A.1
05ACE:  MOVLW  A0
05AD0:  MOVLB  5
05AD2:  MOVWF  x50
05AD4:  MOVLB  0
05AD6:  CALL   4FE0
05ADA:  BSF    F7A.1
....................          // stop the current sprinkler setting (also closes valve) and clear the queue 
....................          stop_current_spinkler_setting(); 
05ADC:  RCALL  5366
....................          clear_sprinkler_queue(); 
05ADE:  RCALL  53A0
....................          // send a valve report to let people know of the new position 
....................          PUSH_MESSAGE_QUEUE_MACRO(MSG_MOTE_VALVE_REPORT); 
05AE0:  BCF    F7A.1
05AE2:  MOVLW  92
05AE4:  MOVLB  5
05AE6:  MOVWF  x50
05AE8:  MOVLB  0
05AEA:  CALL   4FE0
05AEE:  BSF    F7A.1
05AF0:  MOVLB  5
....................       } 
....................       break; 
05AF2:  MOVLB  0
05AF4:  BRA    5B94
....................    case MAG_DECOUPLING_RECOVERY: 
....................       // it's fixed! 
....................       // RPM is above the limit (10), RPM is not MAX (for decoupled condition) and valve is moving. 
....................       if ((global_current_rpm > NOT_SPINNING_MAG_DECOUPLING_RPM_FIXED) && (global_current_rpm !=(0-1)) && (!IS_VLV_COASTING)) 
05AF6:  MOVF   xA7,F
05AF8:  BNZ   5B04
05AFA:  MOVF   xA6,W
05AFC:  MOVLB  5
05AFE:  SUBWF  x18,W
05B00:  BC    5B40
05B02:  MOVLB  0
05B04:  INCFSZ xA6,W
05B06:  BRA    5B12
05B08:  INCFSZ xA7,W
05B0A:  BRA    5B12
05B0C:  MOVLB  5
05B0E:  BRA    5B40
05B10:  MOVLB  0
05B12:  MOVF   F8D,F
05B14:  BTFSS  FD8.2
05B16:  BRA    5B1C
05B18:  MOVLB  5
05B1A:  BRA    5B40
....................       { 
....................          //stop the valve movement 
....................          disable_interrupts(INT_CCP3); 
05B1C:  BCF    F7A.0
....................          global_valve_position_set_value = global_valve_position; 
05B1E:  MOVFF  BE,C0
05B22:  MOVFF  BD,BF
....................          enable_interrupts(INT_CCP3); 
05B26:  BSF    F7A.0
....................          // change control loop back to a normal mode 
....................          global_control_loop_mechanism = BRAKE_AND_CHARGE_START; 
05B28:  CLRF   xBC
....................          // send a valve report to let people know of the new position 
....................          PUSH_MESSAGE_QUEUE_MACRO(MSG_MOTE_VALVE_REPORT); 
05B2A:  BCF    F7A.1
05B2C:  MOVLW  92
05B2E:  MOVLB  5
05B30:  MOVWF  x50
05B32:  MOVLB  0
05B34:  CALL   4FE0
05B38:  BSF    F7A.1
....................          // put the control algorithm into a non-rpm controlled state (sort of an idle state) 
....................          global_control_loop_mechanism = BRAKE_AND_CHARGE_START; 
05B3A:  CLRF   xBC
....................       } 
05B3C:  BRA    5B90
05B3E:  MOVLB  5
....................       // KINDA MESSY, FIX THIS LATER 
....................       // if the valve is within 5% of valve range (~2 seconds) of the position it's going, 
....................       //    control loop update position is slowed to 100x64ms or 6.4 seconds to give it time to react  
....................       else if ((!IS_VLV_COASTING) && ((global_valve_position - global_valve_position_set_value) < 0x0400)) 
05B40:  MOVF   F8D,F
05B42:  BZ    5B62
05B44:  MOVLB  0
05B46:  MOVF   xBF,W
05B48:  SUBWF  xBD,W
05B4A:  MOVLB  5
05B4C:  MOVWF  x50
05B4E:  MOVLB  0
05B50:  MOVF   xC0,W
05B52:  SUBWFB xBE,W
05B54:  MOVLB  5
05B56:  MOVWF  x51
05B58:  SUBLW  03
05B5A:  BNC   5B62
....................       { 
....................          control_loop_cycles_to_next_update = 100; 
05B5C:  MOVLW  64
05B5E:  MOVWF  x3B
....................       } 
05B60:  BRA    5B92
....................       // it tried to move the valve a bunch and it didn't fix it :-/ 
....................       else if (IS_VLV_COASTING) 
05B62:  MOVF   F8D,F
05B64:  BNZ   5B92
....................       { 
....................          // set an error bit saying there isn't any spinning 
....................          global_error_message_bitfield |= ERR_MSG_MAG_NOT_SPIN_RECOVERY_FAILED; 
05B66:  MOVLB  4
05B68:  BSF    xF5.5
....................          // send error message to manager 
....................          PUSH_MESSAGE_QUEUE_MACRO(MSG_MOTE_ERROR_MSG); 
05B6A:  BCF    F7A.1
05B6C:  MOVLW  A0
05B6E:  MOVLB  5
05B70:  MOVWF  x50
05B72:  MOVLB  0
05B74:  CALL   4FE0
05B78:  BSF    F7A.1
....................          // stop the current sprinkler setting (also closes valve) and clear the queue 
....................          stop_current_spinkler_setting(); 
05B7A:  CALL   5366
....................          clear_sprinkler_queue(); 
05B7E:  RCALL  53A0
....................          // send a valve report to let people know of the new position 
....................          PUSH_MESSAGE_QUEUE_MACRO(MSG_MOTE_VALVE_REPORT); 
05B80:  BCF    F7A.1
05B82:  MOVLW  92
05B84:  MOVLB  5
05B86:  MOVWF  x50
05B88:  MOVLB  0
05B8A:  CALL   4FE0
05B8E:  BSF    F7A.1
05B90:  MOVLB  5
....................       } 
....................       break; 
05B92:  MOVLB  0
05B94:  MOVLB  5
....................    }      
....................    return; 
05B96:  MOVLB  0
05B98:  GOTO   A29A (RETURN)
.................... } 
....................  
.................... void stop_current_spinkler_setting(void) 
.................... { 
....................    global_current_sprinkler_settings_end_time = 0-1; 
*
05366:  SETF   00
05368:  SETF   01
0536A:  SETF   02
0536C:  SETF   03
0536E:  MOVFF  03,429
05372:  MOVFF  02,428
05376:  MOVFF  01,427
0537A:  MOVFF  00,426
0537E:  CLRF   19
05380:  BTFSC  FF2.7
05382:  BSF    19.7
05384:  BCF    FF2.7
....................    PUSH_PRIORITY_QUEUE_ISR(OPEN_VALVE_UNKNOWN_STATE); 
05386:  MOVLW  3E
05388:  MOVLB  5
0538A:  MOVWF  x9B
0538C:  MOVLB  0
0538E:  CALL   0808
05392:  BTFSC  19.7
05394:  BSF    FF2.7
....................    global_rpm_set_value = 0; 
05396:  CLRF   xA9
05398:  CLRF   xA8
....................    //global_sprinkler_queue[global_current_sprinkler_queue_location].zone_num; 
....................    global_control_loop_mechanism = NO_RPM_CONTROL; 
0539A:  MOVLW  05
0539C:  MOVWF  xBC
0539E:  RETURN 0
.................... } 
.................... void stop_current_spinkler_setting_ISR(void) 
.................... { 
....................    global_current_sprinkler_settings_end_time = 0-1; 
*
02C7E:  SETF   00
02C80:  SETF   01
02C82:  SETF   02
02C84:  SETF   03
02C86:  MOVFF  03,429
02C8A:  MOVFF  02,428
02C8E:  MOVFF  01,427
02C92:  MOVFF  00,426
....................    PUSH_PRIORITY_QUEUE_ISR_MACRO(OPEN_VALVE_UNKNOWN_STATE);           
02C96:  MOVLW  3E
02C98:  MOVLB  5
02C9A:  MOVWF  x9B
02C9C:  MOVLB  0
02C9E:  CALL   0808
....................    global_rpm_set_value = 0; 
02CA2:  CLRF   xA9
02CA4:  CLRF   xA8
....................    //global_sprinkler_queue[global_current_sprinkler_queue_location].zone_num; 
....................    global_control_loop_mechanism = NO_RPM_CONTROL; 
02CA6:  MOVLW  05
02CA8:  MOVWF  xBC
02CAA:  GOTO   2F50 (RETURN)
.................... }                                                         
....................  
.................... #include "valve.h"        
.................... void  comparator_setup(void) 
.................... { 
.................... // Sets up and enables the comparator for current limit detection when moving 
.................... //    valve 
....................     
....................    // turns off comparator 
....................    setup_comparator(NC_NC_NC_NC); 
*
081EA:  CLRF   F77
081EC:  MOVLW  04
081EE:  MOVWF  F78
081F0:  MOVWF  F79
....................     
....................    // Sets up the DAC for a range of VDD-VSS 
....................    setup_DAC(DAC_VSS_VDD); 
081F2:  MOVLW  80
081F4:  MOVLB  F
081F6:  MOVWF  x41
....................     
....................    // sets up an appropriate dac level depending on movement direction and  
....................    //    valve position 
....................    set_comp_dac_level(); 
081F8:  MOVLB  0
081FA:  BRA    80AC
....................     
....................    // delay for comparator to setup? 
....................    delay_cycles(5); 
081FC:  BRA    81FE
081FE:  BRA    8200
08200:  NOP   
....................     
....................    // CP1 compares VLV_I at its neg input to the DAC output 
....................    // CP2 off at power up and stays off 
....................    setup_comparator(CP1_A1_DAC); 
08202:  CLRF   F77
08204:  CLRF   F78
08206:  MOVLW  85
08208:  MOVWF  F79
0820A:  MOVF   F92,W
0820C:  IORLW  02
0820E:  MOVWF  F92
08210:  MOVF   F93,W
....................                                      
....................    // clear the comparator interrupt and enable it 
....................    clear_interrupt(INT_COMP); 
08212:  BCF    FA1.6
....................    enable_interrupts(INT_COMP); 
08214:  BSF    FA0.6
08216:  RETURN 0
.................... } 
....................  
....................  
.................... uint16_t calc_valve_movement_time(uint16_t current_location, uint16_t destination) 
.................... { 
.................... // calculates the amount of time it takes to make the move from  
.................... //    current location to destination and returns it in seconds (7.9 format) 
....................  
....................    uint32_t temp_u32; 
....................     
....................    // if valve is going to open 
....................    if (current_location < destination) 
....................    { 
....................       temp_u32 = ((uint32_t)(destination - current_location) * (uint32_t)(global_valve_time_to_open_1024th));  
....................    }   
....................    // if valve is going to close or not move at all 
....................    else if (current_location >= destination) 
....................    { 
....................       temp_u32 = ((uint32_t)(current_location - destination) * (uint32_t)(global_valve_time_to_close_1024th));  
....................    }   
....................     
....................    // now 8.24 format; convert to 16 bit 7.9 format (seconds) 
....................    if (bit_test(temp_u32,14)) 
....................    { 
....................       temp_u32 += 0x8000; 
....................    } 
....................    // return the time in 7.9 format (seconds) 
....................    return(uint16_t)(temp_u32 >> 15); 
.................... } 
....................  
.................... void set_comp_dac_level(void) 
.................... { 
.................... // sets the dac level for the comparator for different situations/vlv positions 
....................  
....................    // if valve is just begining to move and outside of the "almost close/opened" 
....................    //    regime.  DAC level is lowered to allow for more current draw. 
....................    if ((global_valve_time_in_motion_1024ths <= VLV_INIT_CURRENT_BOOST_TIME_1024THS)    \ 
....................       && (!(global_valve_position < VLV_NEAR_CLOSED_RANGE_MAX)) &&                     \ 
....................       (!(global_valve_position > VLV_NEAR_OPENED_RANGE_MAX))) 
*
080AC:  MOVF   xC6,W
080AE:  MOVLB  5
080B0:  SUBWF  x13,W
080B2:  BNC   80FC
080B4:  BNZ   80C0
080B6:  MOVLB  0
080B8:  MOVF   xC5,W
080BA:  MOVLB  5
080BC:  SUBWF  x12,W
080BE:  BNC   80FC
080C0:  MOVLB  0
080C2:  MOVF   xBE,W
080C4:  MOVLB  5
080C6:  SUBWF  x03,W
080C8:  BNC   80DC
080CA:  BNZ   80FC
080CC:  MOVF   x02,W
080CE:  MOVLB  0
080D0:  SUBWF  xBD,W
080D2:  BTFSC  FD8.0
080D4:  BRA    80DA
080D6:  MOVLB  5
080D8:  BRA    80FC
080DA:  MOVLB  5
080DC:  MOVF   x05,W
080DE:  MOVLB  0
080E0:  SUBWF  xBE,W
080E2:  BNC   80F6
080E4:  BTFSC  FD8.2
080E6:  BRA    80EC
080E8:  MOVLB  5
080EA:  BRA    80FC
080EC:  MOVF   xBD,W
080EE:  MOVLB  5
080F0:  SUBWF  x04,W
080F2:  BNC   80FC
080F4:  MOVLB  0
....................    { 
....................       dac_write(DAC_LVL_INIT_CURRENT_BOOST); 
080F6:  MOVFF  510,F40
....................    } 
080FA:  BRA    81E2
....................     
....................    // initial valve open (for a few seconds) 
....................    else if (read_system_state() == SYSTEM_CAL_VLV_1) 
080FC:  MOVLB  0
080FE:  CALL   1DC6
08102:  MOVF   01,W
08104:  SUBLW  10
08106:  BNZ   810E
....................    { 
....................       dac_write(DAC_LVL_IN_MIDDLE); 
08108:  MOVFF  50E,F40
....................    } 
0810C:  BRA    81E2
....................     
....................    // inital valve close (don't know where we are exactly) 
....................    else if (read_system_state() == SYSTEM_CAL_VLV_2) 
0810E:  CALL   1DC6
08112:  MOVF   01,W
08114:  SUBLW  11
08116:  BNZ   8140
....................    { 
....................       // normally, during this state, the valve position should be unknown 
....................  
....................       // if the valve is almost (or fully) open after the inital open push aka 
....................       //    it hit the open endstop 
....................       if (global_valve_position > VLV_NEAR_OPENED_RANGE_MAX) 
08118:  MOVLB  5
0811A:  MOVF   x05,W
0811C:  MOVLB  0
0811E:  SUBWF  xBE,W
08120:  BNC   813A
08122:  BNZ   8134
08124:  MOVF   xBD,W
08126:  MOVLB  5
08128:  SUBWF  x04,W
0812A:  BTFSS  FD8.0
0812C:  BRA    8132
0812E:  MOVLB  0
08130:  BRA    813A
08132:  MOVLB  0
....................       { 
....................          dac_write(DAC_LVL_CLOSING_NEAR_OPENED); 
08134:  MOVFF  50A,F40
....................       } 
08138:  BRA    813E
....................       // otherwise, position is unknown and will be assumed to be closing near 
....................       //    the closed endstop.  DAC level will be set as such to get a  
....................       //    consistent calibration 
....................       else 
....................       { 
....................          dac_write(DAC_LVL_CLOSING_NEAR_CLOSED); 
0813A:  MOVFF  50C,F40
....................       } 
....................    } 
0813E:  BRA    81E2
....................     
....................    // valve closing 
....................    else if (IS_VLV_CLOSING) 
08140:  DECFSZ F8D,W
08142:  BRA    818E
....................    { 
....................       // valve is almost closed (or closed) and closing 
....................       if (global_valve_position < VLV_NEAR_CLOSED_RANGE_MAX) 
08144:  MOVF   xBE,W
08146:  MOVLB  5
08148:  SUBWF  x03,W
0814A:  BNC   8164
0814C:  BNZ   815E
0814E:  MOVF   x02,W
08150:  MOVLB  0
08152:  SUBWF  xBD,W
08154:  BTFSS  FD8.0
08156:  BRA    815C
08158:  MOVLB  5
0815A:  BRA    8164
0815C:  MOVLB  5
....................       { 
....................          dac_write(DAC_LVL_CLOSING_NEAR_CLOSED); 
0815E:  MOVFF  50C,F40
....................       } 
08162:  BRA    818A
....................       // valve is almost open (or open) and closing 
....................       else if (global_valve_position > VLV_NEAR_OPENED_RANGE_MAX) 
08164:  MOVF   x05,W
08166:  MOVLB  0
08168:  SUBWF  xBE,W
0816A:  BNC   8184
0816C:  BNZ   817E
0816E:  MOVF   xBD,W
08170:  MOVLB  5
08172:  SUBWF  x04,W
08174:  BTFSS  FD8.0
08176:  BRA    817C
08178:  MOVLB  0
0817A:  BRA    8184
0817C:  MOVLB  0
....................       { 
....................          dac_write(DAC_LVL_CLOSING_NEAR_OPENED); 
0817E:  MOVFF  50A,F40
....................       } 
08182:  BRA    8188
....................       // valve is in the middle somewhere 
....................       else 
....................       { 
....................          dac_write(DAC_LVL_IN_MIDDLE); 
08184:  MOVFF  50E,F40
08188:  MOVLB  5
....................       } 
....................    } 
0818A:  BRA    81E4
0818C:  MOVLB  0
....................     
....................    // valve opening 
....................    else if (IS_VLV_OPENING) 
0818E:  MOVF   F8D,W
08190:  SUBLW  02
08192:  BNZ   81DE
....................    { 
....................       // valve is almost closed (or closed) and opening 
....................       if (global_valve_position < VLV_NEAR_CLOSED_RANGE_MAX) 
08194:  MOVF   xBE,W
08196:  MOVLB  5
08198:  SUBWF  x03,W
0819A:  BNC   81B4
0819C:  BNZ   81AE
0819E:  MOVF   x02,W
081A0:  MOVLB  0
081A2:  SUBWF  xBD,W
081A4:  BTFSS  FD8.0
081A6:  BRA    81AC
081A8:  MOVLB  5
081AA:  BRA    81B4
081AC:  MOVLB  5
....................       { 
....................          dac_write(DAC_LVL_OPENING_NEAR_CLOSED); 
081AE:  MOVFF  508,F40
....................       } 
081B2:  BRA    81DA
....................       // valve is almost open (or open) and opening 
....................       else if (global_valve_position > VLV_NEAR_OPENED_RANGE_MAX) 
081B4:  MOVF   x05,W
081B6:  MOVLB  0
081B8:  SUBWF  xBE,W
081BA:  BNC   81D4
081BC:  BNZ   81CE
081BE:  MOVF   xBD,W
081C0:  MOVLB  5
081C2:  SUBWF  x04,W
081C4:  BTFSS  FD8.0
081C6:  BRA    81CC
081C8:  MOVLB  0
081CA:  BRA    81D4
081CC:  MOVLB  0
....................       { 
....................          dac_write(DAC_LVL_OPENING_NEAR_OPENED); 
081CE:  MOVFF  506,F40
....................       } 
081D2:  BRA    81D8
....................       // valve is in the middle somewhere 
....................       else 
....................       { 
....................          dac_write(DAC_LVL_IN_MIDDLE); 
081D4:  MOVFF  50E,F40
081D8:  MOVLB  5
....................       } 
....................    } 
081DA:  BRA    81E4
081DC:  MOVLB  0
....................     
....................    // other cases (like if this accidentally gets called before valve is 
....................    //    actually moving, although it should get picked up by the initial  
....................    //    boost case 
....................    else 
....................    { 
....................       dac_write(DAC_LVL_IN_MIDDLE); 
081DE:  MOVFF  50E,F40
081E2:  MOVLB  5
....................    } 
081E4:  MOVLB  0
081E6:  GOTO   81FC (RETURN)
.................... } 
....................  
....................  
.................... void set_comp_dac_level_ISR(void) 
.................... { 
.................... // sets the dac level for the comparator for different situations/vlv positions 
....................  
....................    // if valve is just begining to move and outside of the "almost close/opened" 
....................    //    regime.  DAC level is lowered to allow for more current draw. 
....................    if ((global_valve_time_in_motion_1024ths <= VLV_INIT_CURRENT_BOOST_TIME_1024THS) \ 
....................       && (!(global_valve_position < VLV_NEAR_CLOSED_RANGE_MAX)) &&            \ 
....................       (!(global_valve_position > VLV_NEAR_OPENED_RANGE_MAX))) 
*
01DD0:  MOVF   xC6,W
01DD2:  MOVLB  5
01DD4:  SUBWF  x13,W
01DD6:  BNC   1E20
01DD8:  BNZ   1DE4
01DDA:  MOVLB  0
01DDC:  MOVF   xC5,W
01DDE:  MOVLB  5
01DE0:  SUBWF  x12,W
01DE2:  BNC   1E20
01DE4:  MOVLB  0
01DE6:  MOVF   xBE,W
01DE8:  MOVLB  5
01DEA:  SUBWF  x03,W
01DEC:  BNC   1E00
01DEE:  BNZ   1E20
01DF0:  MOVF   x02,W
01DF2:  MOVLB  0
01DF4:  SUBWF  xBD,W
01DF6:  BTFSC  FD8.0
01DF8:  BRA    1DFE
01DFA:  MOVLB  5
01DFC:  BRA    1E20
01DFE:  MOVLB  5
01E00:  MOVF   x05,W
01E02:  MOVLB  0
01E04:  SUBWF  xBE,W
01E06:  BNC   1E1A
01E08:  BTFSC  FD8.2
01E0A:  BRA    1E10
01E0C:  MOVLB  5
01E0E:  BRA    1E20
01E10:  MOVF   xBD,W
01E12:  MOVLB  5
01E14:  SUBWF  x04,W
01E16:  BNC   1E20
01E18:  MOVLB  0
....................    { 
....................       dac_write(DAC_LVL_INIT_CURRENT_BOOST); 
01E1A:  MOVFF  510,F40
....................    } 
01E1E:  BRA    1F02
....................     
....................    // initial valve open (for a few seconds) 
....................    else if (read_system_state() == SYSTEM_CAL_VLV_1) 
01E20:  MOVLB  0
01E22:  RCALL  1DC6
01E24:  MOVF   01,W
01E26:  SUBLW  10
01E28:  BNZ   1E30
....................    { 
....................       dac_write(DAC_LVL_IN_MIDDLE); 
01E2A:  MOVFF  50E,F40
....................    } 
01E2E:  BRA    1F02
....................     
....................    // inital valve close (don't know where we are exactly) 
....................    else if (read_system_state() == SYSTEM_CAL_VLV_2) 
01E30:  RCALL  1DC6
01E32:  MOVF   01,W
01E34:  SUBLW  11
01E36:  BNZ   1E60
....................    { 
....................       // normally, during this state, the valve position should be unknown 
....................  
....................       // if the valve is almost (or fully) open after the inital open push aka 
....................       //    it hit the open endstop 
....................       if (global_valve_position > VLV_NEAR_OPENED_RANGE_MAX) 
01E38:  MOVLB  5
01E3A:  MOVF   x05,W
01E3C:  MOVLB  0
01E3E:  SUBWF  xBE,W
01E40:  BNC   1E5A
01E42:  BNZ   1E54
01E44:  MOVF   xBD,W
01E46:  MOVLB  5
01E48:  SUBWF  x04,W
01E4A:  BTFSS  FD8.0
01E4C:  BRA    1E52
01E4E:  MOVLB  0
01E50:  BRA    1E5A
01E52:  MOVLB  0
....................       { 
....................          dac_write(DAC_LVL_CLOSING_NEAR_OPENED); 
01E54:  MOVFF  50A,F40
....................       } 
01E58:  BRA    1E5E
....................       // otherwise, position is unknown and will be assumed to be closing near 
....................       //    the closed endstop.  DAC level will be set as such to get a  
....................       //    consistent calibration 
....................       else 
....................       { 
....................          dac_write(DAC_LVL_CLOSING_NEAR_CLOSED); 
01E5A:  MOVFF  50C,F40
....................       } 
....................    } 
01E5E:  BRA    1F02
....................     
....................    // valve closing 
....................    else if (IS_VLV_CLOSING) 
01E60:  DECFSZ F8D,W
01E62:  BRA    1EAE
....................    { 
....................       // valve is almost closed (or closed) and closing 
....................       if (global_valve_position < VLV_NEAR_CLOSED_RANGE_MAX) 
01E64:  MOVF   xBE,W
01E66:  MOVLB  5
01E68:  SUBWF  x03,W
01E6A:  BNC   1E84
01E6C:  BNZ   1E7E
01E6E:  MOVF   x02,W
01E70:  MOVLB  0
01E72:  SUBWF  xBD,W
01E74:  BTFSS  FD8.0
01E76:  BRA    1E7C
01E78:  MOVLB  5
01E7A:  BRA    1E84
01E7C:  MOVLB  5
....................       { 
....................          dac_write(DAC_LVL_CLOSING_NEAR_CLOSED); 
01E7E:  MOVFF  50C,F40
....................       } 
01E82:  BRA    1EAA
....................       // valve is almost open (or open) and closing 
....................       else if (global_valve_position > VLV_NEAR_OPENED_RANGE_MAX) 
01E84:  MOVF   x05,W
01E86:  MOVLB  0
01E88:  SUBWF  xBE,W
01E8A:  BNC   1EA4
01E8C:  BNZ   1E9E
01E8E:  MOVF   xBD,W
01E90:  MOVLB  5
01E92:  SUBWF  x04,W
01E94:  BTFSS  FD8.0
01E96:  BRA    1E9C
01E98:  MOVLB  0
01E9A:  BRA    1EA4
01E9C:  MOVLB  0
....................       { 
....................          dac_write(DAC_LVL_CLOSING_NEAR_OPENED); 
01E9E:  MOVFF  50A,F40
....................       } 
01EA2:  BRA    1EA8
....................       // valve is in the middle somewhere 
....................       else 
....................       { 
....................          dac_write(DAC_LVL_IN_MIDDLE); 
01EA4:  MOVFF  50E,F40
01EA8:  MOVLB  5
....................       } 
....................    } 
01EAA:  BRA    1F04
01EAC:  MOVLB  0
....................     
....................    // valve opening 
....................    else if (IS_VLV_OPENING) 
01EAE:  MOVF   F8D,W
01EB0:  SUBLW  02
01EB2:  BNZ   1EFE
....................    { 
....................       // valve is almost closed (or closed) and opening 
....................       if (global_valve_position < VLV_NEAR_CLOSED_RANGE_MAX) 
01EB4:  MOVF   xBE,W
01EB6:  MOVLB  5
01EB8:  SUBWF  x03,W
01EBA:  BNC   1ED4
01EBC:  BNZ   1ECE
01EBE:  MOVF   x02,W
01EC0:  MOVLB  0
01EC2:  SUBWF  xBD,W
01EC4:  BTFSS  FD8.0
01EC6:  BRA    1ECC
01EC8:  MOVLB  5
01ECA:  BRA    1ED4
01ECC:  MOVLB  5
....................       { 
....................          dac_write(DAC_LVL_OPENING_NEAR_CLOSED); 
01ECE:  MOVFF  508,F40
....................       } 
01ED2:  BRA    1EFA
....................       // valve is almost open (or open) and opening 
....................       else if (global_valve_position > VLV_NEAR_OPENED_RANGE_MAX) 
01ED4:  MOVF   x05,W
01ED6:  MOVLB  0
01ED8:  SUBWF  xBE,W
01EDA:  BNC   1EF4
01EDC:  BNZ   1EEE
01EDE:  MOVF   xBD,W
01EE0:  MOVLB  5
01EE2:  SUBWF  x04,W
01EE4:  BTFSS  FD8.0
01EE6:  BRA    1EEC
01EE8:  MOVLB  0
01EEA:  BRA    1EF4
01EEC:  MOVLB  0
....................       { 
....................          dac_write(DAC_LVL_OPENING_NEAR_OPENED); 
01EEE:  MOVFF  506,F40
....................       } 
01EF2:  BRA    1EF8
....................       // valve is in the middle somewhere 
....................       else 
....................       { 
....................          dac_write(DAC_LVL_IN_MIDDLE); 
01EF4:  MOVFF  50E,F40
01EF8:  MOVLB  5
....................       } 
....................    } 
01EFA:  BRA    1F04
01EFC:  MOVLB  0
....................     
....................    // other cases (like if this accidentally gets called before valve is 
....................    //    actually moving, although it should get picked up by the initial  
....................    //    boost case 
....................    else 
....................    { 
....................       dac_write(DAC_LVL_IN_MIDDLE); 
01EFE:  MOVFF  50E,F40
01F02:  MOVLB  5
....................    } 
01F04:  MOVLB  0
01F06:  GOTO   2066 (RETURN)
.................... } 
....................  
.................... int1 is_valve_position_valid(uint16_t value) 
.................... // returns true if valid range for valve 
.................... { 
....................    if (value > VLV_POSITION_OPENED) return FALSE; 
*
06740:  MOVLB  5
06742:  MOVF   x51,W
06744:  SUBLW  7F
06746:  BC    675A
06748:  XORLW  FF
0674A:  BNZ   6752
0674C:  MOVF   x50,W
0674E:  SUBLW  00
06750:  BC    675A
06752:  MOVLW  00
06754:  MOVWF  01
06756:  BRA    675E
06758:  BRA    675E
....................    else if ((value < VLV_POSITION_CLOSED) && (VLV_POSITION_CLOSED != 0)) return FALSE; 
....................    else return TRUE; 
0675A:  MOVLW  01
0675C:  MOVWF  01
0675E:  MOVLB  0
06760:  RETURN 0
.................... } 
....................  
.................... int1 is_valve_value_full_open_or_close(uint16_t value) 
.................... // return true if valve is either full open or vull close 
.................... { 
....................    if ((value == VLV_POSITION_OPENED) || (value == VLV_POSITION_CLOSED))  
*
07098:  MOVLB  5
0709A:  MOVF   x50,F
0709C:  BNZ   70A4
0709E:  MOVF   x51,W
070A0:  SUBLW  80
070A2:  BZ    70AC
070A4:  MOVF   x50,F
070A6:  BNZ   70B4
070A8:  MOVF   x51,F
070AA:  BNZ   70B4
....................       return TRUE; 
070AC:  MOVLW  01
070AE:  MOVWF  01
070B0:  BRA    70B8
070B2:  BRA    70B8
....................    else return FALSE; 
070B4:  MOVLW  00
070B6:  MOVWF  01
070B8:  MOVLB  0
070BA:  RETURN 0
.................... } 
....................  
.................... #include "battery.h"                                                           
.................... // JG 
.................... uint16_t get_vbatt(int1 charge_state) 
*
040A4:  MOVLB  5
040A6:  CLRF   x69
040A8:  CLRF   x68
.................... { 
....................    /* Samples the V_EXT_REF to get the battery voltage 
....................     * and returns a uint16_t of the sum of 4 samples 
....................     * charge_state defines if you want the LTC3105 to be: 
....................     * 0 - original state 
....................     * 1 - not charging 
....................     */ 
....................                                                           
....................    uint8_t nn; 
....................    uint16_t v_batt_value = 0; 
....................    int1     tmp_RB3; 
....................    uint8_t  tmp_ccp2con; 
....................     
....................    // save state of RB3, which includes the LTC3105_CTRL line 
....................    tmp_ccp2con = CCP2CON;        
040AA:  MOVFF  F66,56B
....................     
....................    // save state of CCP2, which controls charging aggressiveness 
....................    // note that CCP2 will have control of the pin unless it is OFF 
....................    tmp_RB3 = LTC3105_CTRL_pinstate;  
040AE:  BCF    x6A.0
040B0:  BTFSC  F8A.3
040B2:  BSF    x6A.0
....................     
....................    // turn on ADC 
....................    ADON = TRUE;          
040B4:  BSF    FC2.0
....................     
....................    // set adc to VREF 
....................    set_adc_channel(V_EXT_REF); 
040B6:  MOVLW  00
040B8:  MOVWF  01
040BA:  MOVF   FC2,W
040BC:  ANDLW  83
040BE:  IORWF  01,W
040C0:  MOVWF  FC2
....................     
....................    // alter the charge state if necessary 
....................    // charge state off 
....................    if (charge_state == 1) 
040C2:  DECFSZ x66,W
040C4:  BRA    40CC
....................    { 
....................       setup_ccp2(CCP_OFF);    
040C6:  MOVLW  F0
040C8:  ANDWF  F66,F
....................       output_low(LTC3105_CTRL); 
040CA:  BCF    F8A.3
....................    } 
....................     
....................    // sum up 4 samples from the adc 
....................    for (nn=0; nn<4; nn++) 
040CC:  CLRF   x67
040CE:  MOVF   x67,W
040D0:  SUBLW  03
040D2:  BNC   40E6
....................    { 
....................       v_batt_value += read_adc(); 
040D4:  BSF    FC2.1
040D6:  BTFSC  FC2.1
040D8:  BRA    40D6
040DA:  MOVF   FC3,W
040DC:  ADDWF  x68,F
040DE:  MOVF   FC4,W
040E0:  ADDWFC x69,F
040E2:  INCF   x67,F
040E4:  BRA    40CE
....................    } 
....................     
....................    // Now return charger to its previous state 
....................    LTC3105_CTRL_pinstate = tmp_RB3; 
040E6:  BCF    F8A.3
040E8:  BTFSC  x6A.0
040EA:  BSF    F8A.3
....................    CCP2CON = tmp_ccp2con; 
040EC:  MOVFF  56B,F66
....................     
....................    // turn off adc 
....................    ADON = FALSE; 
040F0:  BCF    FC2.0
....................     
....................    // return the voltage 
....................    return v_batt_value; 
040F2:  MOVFF  568,01
040F6:  MOVFF  569,02
040FA:  MOVLB  0
040FC:  RETURN 0
.................... } 
....................  
.................... uint16_t get_vbatt_ISR(int1 charge_state) 
*
0228E:  MOVLB  5
02290:  CLRF   x92
02292:  CLRF   x91
.................... { 
....................    /* Samples the V_EXT_REF to get the battery voltage 
....................     * and returns a uint16_t of the sum of 4 samples 
....................     * charge_state defines if you want the LTC3105 to be: 
....................     * 0 - original state 
....................     * 1 - not charging 
....................     */ 
....................      
....................    uint8_t nn; 
....................    uint16_t v_batt_value = 0; 
....................    int1     tmp_RB3; 
....................    uint8_t  tmp_ccp2con; 
....................     
....................    // save state of RB3, which includes the LTC3105_CTRL line 
....................    tmp_ccp2con = CCP2CON; 
02294:  MOVFF  F66,594
....................     
....................    // save state of CCP2, which controls charging aggressiveness 
....................    // note that CCP2 will have control of the pin unless it is OFF 
....................    tmp_RB3 = LTC3105_CTRL_pinstate;  
02298:  BCF    x93.0
0229A:  BTFSC  F8A.3
0229C:  BSF    x93.0
....................     
....................    // turn on ADC 
....................    ADON = TRUE;          
0229E:  BSF    FC2.0
....................     
....................    // set adc to VREF 
....................    set_adc_channel(V_EXT_REF); 
022A0:  MOVLW  00
022A2:  MOVWF  01
022A4:  MOVF   FC2,W
022A6:  ANDLW  83
022A8:  IORWF  01,W
022AA:  MOVWF  FC2
....................     
....................    // alter the charge state if necessary 
....................    // charge state off 
....................    if (charge_state == 1) 
022AC:  DECFSZ x8F,W
022AE:  BRA    22B6
....................    { 
....................       setup_ccp2(CCP_OFF);    
022B0:  MOVLW  F0
022B2:  ANDWF  F66,F
....................       output_low(LTC3105_CTRL); 
022B4:  BCF    F8A.3
....................    } 
....................     
....................    // sum up 4 samples from the adc 
....................    for (nn=0; nn<4; nn++) 
022B6:  CLRF   x90
022B8:  MOVF   x90,W
022BA:  SUBLW  03
022BC:  BNC   22D0
....................    { 
....................       v_batt_value += read_adc(); 
022BE:  BSF    FC2.1
022C0:  BTFSC  FC2.1
022C2:  BRA    22C0
022C4:  MOVF   FC3,W
022C6:  ADDWF  x91,F
022C8:  MOVF   FC4,W
022CA:  ADDWFC x92,F
022CC:  INCF   x90,F
022CE:  BRA    22B8
....................    } 
....................     
....................    // Now return charger to its previous state 
....................    LTC3105_CTRL_pinstate = tmp_RB3; 
022D0:  BCF    F8A.3
022D2:  BTFSC  x93.0
022D4:  BSF    F8A.3
....................    CCP2CON = tmp_ccp2con; 
022D6:  MOVFF  594,F66
....................     
....................    // turn off adc 
....................    ADON = FALSE; 
022DA:  BCF    FC2.0
....................     
....................    // return the voltage 
....................    return v_batt_value; 
022DC:  MOVFF  591,01
022E0:  MOVFF  592,02
022E4:  MOVLB  0
022E6:  RETURN 0
.................... } 
....................  
.................... uint16_t get_vgen(int1 charge_state) 
*
040FE:  MOVLB  5
04100:  CLRF   x56
04102:  CLRF   x55
.................... { 
....................    /* Samples the V_GEN to get the battery voltage 
....................     * and returns a uint16_t of the sum of 4 samples 
....................     * charge_state defines if you want the LTC3105 to be: 
....................     * 0 - original state 
....................     * 1 - not charging 
....................     */ 
....................      
....................    uint8_t nn; 
....................    uint16_t vgen_value = 0; 
....................    int1     tmp_RB3; 
....................    uint8_t  tmp_ccp2con; 
....................     
....................    // save state of RB3, which includes the LTC3105_CTRL line 
....................    tmp_ccp2con = CCP2CON; 
04104:  MOVFF  F66,558
....................     
....................    // save state of CCP2, which controls charging aggressiveness 
....................    // note that CCP2 will have control of the pin unless it is OFF 
....................    tmp_RB3 = LTC3105_CTRL_pinstate;  
04108:  BCF    x57.0
0410A:  BTFSC  F8A.3
0410C:  BSF    x57.0
....................     
....................    // turn on ADC 
....................    ADON = TRUE;          
0410E:  BSF    FC2.0
....................     
....................    // set adc to VREF 
....................    set_adc_channel(V_GEN); 
04110:  MOVLW  30
04112:  MOVWF  01
04114:  MOVF   FC2,W
04116:  ANDLW  83
04118:  IORWF  01,W
0411A:  MOVWF  FC2
....................     
....................    // alter the charge state if necessary 
....................    // charge state off 
....................    if (charge_state == 1) 
0411C:  DECFSZ x53,W
0411E:  BRA    4126
....................    { 
....................       setup_ccp2(CCP_OFF);    
04120:  MOVLW  F0
04122:  ANDWF  F66,F
....................       output_low(LTC3105_CTRL); 
04124:  BCF    F8A.3
....................    } 
....................     
....................    // sum up 3 samples from the adc 
....................    for (nn=0; nn<3; nn++) 
04126:  CLRF   x54
04128:  MOVF   x54,W
0412A:  SUBLW  02
0412C:  BNC   4140
....................    { 
....................       vgen_value += read_adc(); 
0412E:  BSF    FC2.1
04130:  BTFSC  FC2.1
04132:  BRA    4130
04134:  MOVF   FC3,W
04136:  ADDWF  x55,F
04138:  MOVF   FC4,W
0413A:  ADDWFC x56,F
0413C:  INCF   x54,F
0413E:  BRA    4128
....................    } 
....................     
....................    // Now return charger to its previous state 
....................    LTC3105_CTRL_pinstate = tmp_RB3; 
04140:  BCF    F8A.3
04142:  BTFSC  x57.0
04144:  BSF    F8A.3
....................    CCP2CON = tmp_ccp2con; 
04146:  MOVFF  558,F66
....................     
....................    // turn off adc 
....................    ADON = FALSE; 
0414A:  BCF    FC2.0
....................     
....................    // save vgen to global value 
....................    global_vgen = vgen_value; 
0414C:  MOVFF  556,B9
04150:  MOVFF  555,B8
....................     
....................    // return the voltage 
....................    return vgen_value; 
04154:  MOVFF  555,01
04158:  MOVFF  556,02
0415C:  MOVLB  0
0415E:  RETURN 0
.................... } 
....................  
.................... uint16_t calc_vbatt_BCD(uint16_t vref_count) 
.................... { 
....................    /* Takes the voltage count as an input (summed from ADC) 
....................     * and outputs the battery integer and fractional as a single uint32_t 
....................     * It's output is BCD as follows: 
....................     * volts (.) tenths hundredths thousandths 
....................    */ 
....................    uint8_t volts, tenths, hundredths, thousandths; 
....................  
....................    uint32_t tempo_u32, frac_part; 
....................    uint16_t tempo_u16;   
....................     
....................    uint16_t    bat_frac_part;    // in units of mV 
....................     
....................    tempo_u32 = VAL32_FVR_BAT/vref_count;   // = 1 count in volts in 12.20 format 
*
0494E:  MOVFF  558,56A
04952:  MOVFF  557,569
04956:  RCALL  4608
04958:  MOVLW  9A
0495A:  MOVLB  5
0495C:  MOVWF  x6C
0495E:  MOVLW  99
04960:  MOVWF  x6B
04962:  MOVLW  19
04964:  MOVWF  x6A
04966:  MOVLW  95
04968:  MOVWF  x69
0496A:  MOVFF  03,570
0496E:  MOVFF  02,56F
04972:  MOVFF  01,56E
04976:  MOVFF  00,56D
0497A:  MOVLB  0
0497C:  RCALL  463E
0497E:  MOVFF  03,56C
04982:  MOVFF  02,56B
04986:  MOVFF  01,56A
0498A:  MOVFF  00,569
0498E:  RCALL  479C
04990:  MOVFF  03,560
04994:  MOVFF  02,55F
04998:  MOVFF  01,55E
0499C:  MOVFF  00,55D
049A0:  CLRF   19
049A2:  BTFSC  FF2.7
049A4:  BSF    19.7
049A6:  BCF    FF2.7
....................    tempo_u32 *= 1023;                        // bat voltage in 12.20 format 
049A8:  MOVFF  560,58C
049AC:  MOVFF  55F,58B
049B0:  MOVFF  55E,58A
049B4:  MOVFF  55D,589
049B8:  MOVLB  5
049BA:  CLRF   x90
049BC:  CLRF   x8F
049BE:  MOVLW  03
049C0:  MOVWF  x8E
049C2:  SETF   x8D
049C4:  MOVLB  0
049C6:  CALL   1968
049CA:  BTFSC  19.7
049CC:  BSF    FF2.7
049CE:  MOVFF  03,560
049D2:  MOVFF  02,55F
049D6:  MOVFF  01,55E
049DA:  MOVFF  00,55D
....................    tempo_u16 = (uint16_t)(tempo_u32 >> 8); 
049DE:  MOVFF  55F,566
049E2:  MOVFF  55E,565
....................                                              // bat voltage in 4.12 format 
....................    volts = (uint8_t)(tempo_u16 >> 12);       // 2 or 3.....    
049E6:  MOVLB  5
049E8:  SWAPF  x66,W
049EA:  MOVWF  02
049EC:  MOVLW  0F
049EE:  ANDWF  02,F
049F0:  MOVFF  02,559
....................     
....................    frac_part = (uint32_t)(tempo_u16 & 0x0fff); 
049F4:  MOVF   x66,W
049F6:  ANDLW  0F
049F8:  MOVFF  565,561
049FC:  MOVWF  x62
049FE:  CLRF   x63
04A00:  CLRF   x64
04A02:  CLRF   19
04A04:  BTFSC  FF2.7
04A06:  BSF    19.7
04A08:  BCF    FF2.7
....................                                        // one count of frac_part is 1/4096 volt 
....................                                        // no rounding, full resolution 
....................    tempo_u32 = (frac_part * 1000);     // We ignore the mV rounding issue 
04A0A:  MOVFF  564,58C
04A0E:  MOVFF  563,58B
04A12:  MOVFF  562,58A
04A16:  MOVFF  561,589
04A1A:  CLRF   x90
04A1C:  CLRF   x8F
04A1E:  MOVLW  03
04A20:  MOVWF  x8E
04A22:  MOVLW  E8
04A24:  MOVWF  x8D
04A26:  MOVLB  0
04A28:  CALL   1968
04A2C:  BTFSC  19.7
04A2E:  BSF    FF2.7
04A30:  MOVFF  03,560
04A34:  MOVFF  02,55F
04A38:  MOVFF  01,55E
04A3C:  MOVFF  00,55D
....................                                        //  cuz battery measurement doesn't 
....................                                        //  support even mV resolution 
....................    tempo_u32 >>= 12; 
04A40:  MOVLB  5
04A42:  MOVFF  55E,55D
04A46:  MOVFF  55F,55E
04A4A:  MOVFF  560,55F
04A4E:  CLRF   x60
04A50:  RRCF   x60,F
04A52:  RRCF   x5F,F
04A54:  RRCF   x5E,F
04A56:  RRCF   x5D,F
04A58:  RRCF   x60,F
04A5A:  RRCF   x5F,F
04A5C:  RRCF   x5E,F
04A5E:  RRCF   x5D,F
04A60:  RRCF   x60,F
04A62:  RRCF   x5F,F
04A64:  RRCF   x5E,F
04A66:  RRCF   x5D,F
04A68:  RRCF   x60,F
04A6A:  RRCF   x5F,F
04A6C:  RRCF   x5E,F
04A6E:  RRCF   x5D,F
04A70:  MOVLW  0F
04A72:  ANDWF  x60,F
....................    tempo_u16 = (uint16_t)(tempo_u32); 
04A74:  MOVFF  55E,566
04A78:  MOVFF  55D,565
....................    tenths = tempo_u16/100; 
04A7C:  MOVFF  566,572
04A80:  MOVFF  565,571
04A84:  CLRF   x74
04A86:  MOVLW  64
04A88:  MOVWF  x73
04A8A:  MOVLB  0
04A8C:  CALL   4174
04A90:  MOVFF  01,55A
....................    tempo_u16 -= (uint16_t)(tenths)*100; 
04A94:  MOVLB  5
04A96:  CLRF   x6A
04A98:  MOVFF  55A,569
04A9C:  MOVFF  56A,56C
04AA0:  MOVFF  55A,56B
04AA4:  CLRF   x6E
04AA6:  MOVLW  64
04AA8:  MOVWF  x6D
04AAA:  MOVLB  0
04AAC:  RCALL  492C
04AAE:  MOVF   01,W
04AB0:  MOVLB  5
04AB2:  SUBWF  x65,F
04AB4:  MOVF   02,W
04AB6:  SUBWFB x66,F
....................    hundredths = tempo_u16/10; 
04AB8:  MOVFF  566,572
04ABC:  MOVFF  565,571
04AC0:  CLRF   x74
04AC2:  MOVLW  0A
04AC4:  MOVWF  x73
04AC6:  MOVLB  0
04AC8:  CALL   4174
04ACC:  MOVFF  01,55B
....................    thousandths = tempo_u16 % 10; 
04AD0:  MOVFF  566,572
04AD4:  MOVFF  565,571
04AD8:  MOVLB  5
04ADA:  CLRF   x74
04ADC:  MOVLW  0A
04ADE:  MOVWF  x73
04AE0:  MOVLB  0
04AE2:  CALL   4174
04AE6:  MOVFF  00,55C
04AEA:  MOVLB  5
....................  
....................    return ((uint16_t)(volts)*4096 + (uint16_t)(tenths)*256 + (uint16_t)(hundredths)*16 + (uint16_t)(thousandths)); 
04AEC:  CLRF   x6A
04AEE:  SWAPF  x59,W
04AF0:  MOVWF  x6A
04AF2:  CLRF   x69
04AF4:  MOVLW  F0
04AF6:  ANDWF  x6A,F
04AF8:  CLRF   x6C
04AFA:  MOVFF  55A,03
04AFE:  MOVLW  00
04B00:  ADDWF  x69,F
04B02:  MOVF   x5A,W
04B04:  ADDWFC x6A,F
04B06:  CLRF   x6C
04B08:  RLCF   x5B,W
04B0A:  MOVWF  02
04B0C:  RLCF   x6C,W
04B0E:  MOVWF  03
04B10:  RLCF   02,F
04B12:  RLCF   03,F
04B14:  RLCF   02,F
04B16:  RLCF   03,F
04B18:  RLCF   02,F
04B1A:  RLCF   03,F
04B1C:  MOVLW  F0
04B1E:  ANDWF  02,F
04B20:  MOVF   02,W
04B22:  ADDWF  x69,F
04B24:  MOVF   03,W
04B26:  ADDWFC x6A,F
04B28:  CLRF   03
04B2A:  MOVF   x5C,W
04B2C:  ADDWF  x69,W
04B2E:  MOVWF  01
04B30:  MOVF   x6A,W
04B32:  ADDWFC 03,F
04B34:  MOVFF  03,02
04B38:  MOVLB  0
04B3A:  GOTO   4C0A (RETURN)
.................... } 
....................  
.................... uint16_t calc_vgen_BCD(uint16_t vref_count) 
.................... { 
....................    /* Takes the voltage count as an input (summed from ADC) 
....................     * and outputs the vgen integer and fractional as a single uint32_t 
....................     * It's output is BCD as follows: 
....................     * volts (.) tenths hundredths thousandths 
....................    */ 
....................    uint8_t volts, tenths, hundredths, thousandths; 
....................  
....................    uint32_t tempo_u32, frac_part; 
....................    uint16_t tempo_u16;   
....................     
....................    uint16_t    bat_frac_part;    // in units of mV 
....................     
....................    // First calculate a single count of the ADC in volts in 12.20 format? 
....................    tempo_u32 = VAL32_FVR_BAT/get_vbatt(0);   // = 1 count in volts in 12.20 format 
*
082B0:  MOVLB  5
082B2:  CLRF   x66
082B4:  MOVLB  0
082B6:  CALL   40A4
082BA:  MOVFF  02,56A
082BE:  MOVFF  01,569
082C2:  MOVLB  0
082C4:  CALL   4608
082C8:  MOVLW  9A
082CA:  MOVLB  5
082CC:  MOVWF  x6C
082CE:  MOVLW  99
082D0:  MOVWF  x6B
082D2:  MOVLW  19
082D4:  MOVWF  x6A
082D6:  MOVLW  95
082D8:  MOVWF  x69
082DA:  MOVFF  03,570
082DE:  MOVFF  02,56F
082E2:  MOVFF  01,56E
082E6:  MOVFF  00,56D
082EA:  MOVLB  0
082EC:  CALL   463E
082F0:  MOVFF  03,56C
082F4:  MOVFF  02,56B
082F8:  MOVFF  01,56A
082FC:  MOVFF  00,569
08300:  CALL   479C
08304:  MOVFF  03,55D
08308:  MOVFF  02,55C
0830C:  MOVFF  01,55B
08310:  MOVFF  00,55A
08314:  CLRF   19
08316:  BTFSC  FF2.7
08318:  BSF    19.7
0831A:  BCF    FF2.7
....................    tempo_u32 *= vref_count;                  // vgen in 12.20 format 
0831C:  MOVFF  55D,58C
08320:  MOVFF  55C,58B
08324:  MOVFF  55B,58A
08328:  MOVFF  55A,589
0832C:  MOVLB  5
0832E:  CLRF   x90
08330:  CLRF   x8F
08332:  MOVFF  555,58E
08336:  MOVFF  554,58D
0833A:  MOVLB  0
0833C:  CALL   1968
08340:  BTFSC  19.7
08342:  BSF    FF2.7
08344:  MOVFF  03,55D
08348:  MOVFF  02,55C
0834C:  MOVFF  01,55B
08350:  MOVFF  00,55A
....................    tempo_u16 = (uint16_t)(tempo_u32 >> 8); 
08354:  MOVFF  55C,563
08358:  MOVFF  55B,562
....................                                              // bat voltage in 4.12 format 
....................    volts = (uint8_t)(tempo_u16 >> 12);       // 2 or 3.....    
0835C:  MOVLB  5
0835E:  SWAPF  x63,W
08360:  MOVWF  02
08362:  MOVLW  0F
08364:  ANDWF  02,F
08366:  MOVFF  02,556
....................     
....................    frac_part = (uint32_t)(tempo_u16 & 0x0fff); 
0836A:  MOVF   x63,W
0836C:  ANDLW  0F
0836E:  MOVFF  562,55E
08372:  MOVWF  x5F
08374:  CLRF   x60
08376:  CLRF   x61
08378:  CLRF   19
0837A:  BTFSC  FF2.7
0837C:  BSF    19.7
0837E:  BCF    FF2.7
....................                                        // one count of frac_part is 1/4096 volt 
....................                                        // no rounding, full resolution 
....................    tempo_u32 = (frac_part * 1000);     // We ignore the mV rounding issue 
08380:  MOVFF  561,58C
08384:  MOVFF  560,58B
08388:  MOVFF  55F,58A
0838C:  MOVFF  55E,589
08390:  CLRF   x90
08392:  CLRF   x8F
08394:  MOVLW  03
08396:  MOVWF  x8E
08398:  MOVLW  E8
0839A:  MOVWF  x8D
0839C:  MOVLB  0
0839E:  CALL   1968
083A2:  BTFSC  19.7
083A4:  BSF    FF2.7
083A6:  MOVFF  03,55D
083AA:  MOVFF  02,55C
083AE:  MOVFF  01,55B
083B2:  MOVFF  00,55A
....................                                        //  cuz battery measurement doesn't 
....................                                        //  support even mV resolution 
....................    tempo_u32 >>= 12; 
083B6:  MOVLB  5
083B8:  MOVFF  55B,55A
083BC:  MOVFF  55C,55B
083C0:  MOVFF  55D,55C
083C4:  CLRF   x5D
083C6:  RRCF   x5D,F
083C8:  RRCF   x5C,F
083CA:  RRCF   x5B,F
083CC:  RRCF   x5A,F
083CE:  RRCF   x5D,F
083D0:  RRCF   x5C,F
083D2:  RRCF   x5B,F
083D4:  RRCF   x5A,F
083D6:  RRCF   x5D,F
083D8:  RRCF   x5C,F
083DA:  RRCF   x5B,F
083DC:  RRCF   x5A,F
083DE:  RRCF   x5D,F
083E0:  RRCF   x5C,F
083E2:  RRCF   x5B,F
083E4:  RRCF   x5A,F
083E6:  MOVLW  0F
083E8:  ANDWF  x5D,F
....................    tempo_u16 = (uint16_t)(tempo_u32); 
083EA:  MOVFF  55B,563
083EE:  MOVFF  55A,562
....................    tenths = tempo_u16/100; 
083F2:  MOVFF  563,572
083F6:  MOVFF  562,571
083FA:  CLRF   x74
083FC:  MOVLW  64
083FE:  MOVWF  x73
08400:  MOVLB  0
08402:  CALL   4174
08406:  MOVFF  01,557
....................    tempo_u16 -= (uint16_t)(tenths)*100; 
0840A:  MOVLB  5
0840C:  CLRF   x67
0840E:  MOVFF  557,566
08412:  MOVFF  567,56C
08416:  MOVFF  557,56B
0841A:  CLRF   x6E
0841C:  MOVLW  64
0841E:  MOVWF  x6D
08420:  MOVLB  0
08422:  CALL   492C
08426:  MOVF   01,W
08428:  MOVLB  5
0842A:  SUBWF  x62,F
0842C:  MOVF   02,W
0842E:  SUBWFB x63,F
....................    hundredths = tempo_u16/10; 
08430:  MOVFF  563,572
08434:  MOVFF  562,571
08438:  CLRF   x74
0843A:  MOVLW  0A
0843C:  MOVWF  x73
0843E:  MOVLB  0
08440:  CALL   4174
08444:  MOVFF  01,558
....................    thousandths = tempo_u16 % 10; 
08448:  MOVFF  563,572
0844C:  MOVFF  562,571
08450:  MOVLB  5
08452:  CLRF   x74
08454:  MOVLW  0A
08456:  MOVWF  x73
08458:  MOVLB  0
0845A:  CALL   4174
0845E:  MOVFF  00,559
08462:  MOVLB  5
....................  
....................    return ((uint16_t)(volts)*4096 + (uint16_t)(tenths)*256 + (uint16_t)(hundredths)*16 + (uint16_t)(thousandths)); 
08464:  CLRF   x67
08466:  SWAPF  x56,W
08468:  MOVWF  x67
0846A:  CLRF   x66
0846C:  MOVLW  F0
0846E:  ANDWF  x67,F
08470:  CLRF   x69
08472:  MOVFF  557,03
08476:  MOVLW  00
08478:  ADDWF  x66,F
0847A:  MOVF   x57,W
0847C:  ADDWFC x67,F
0847E:  CLRF   x69
08480:  RLCF   x58,W
08482:  MOVWF  02
08484:  RLCF   x69,W
08486:  MOVWF  03
08488:  RLCF   02,F
0848A:  RLCF   03,F
0848C:  RLCF   02,F
0848E:  RLCF   03,F
08490:  RLCF   02,F
08492:  RLCF   03,F
08494:  MOVLW  F0
08496:  ANDWF  02,F
08498:  MOVF   02,W
0849A:  ADDWF  x66,F
0849C:  MOVF   03,W
0849E:  ADDWFC x67,F
084A0:  CLRF   03
084A2:  MOVF   x59,W
084A4:  ADDWF  x66,W
084A6:  MOVWF  01
084A8:  MOVF   x67,W
084AA:  ADDWFC 03,F
084AC:  MOVFF  03,02
084B0:  MOVLB  0
084B2:  GOTO   8514 (RETURN)
.................... } 
....................  
.................... uint32_t calc_vbatt(uint16_t vref_count) 
.................... { 
....................    /* Takes the voltage count as an input (summed from ADC) 
....................     * and outputs the battery integer and fractional as a single uint32_t 
....................     * It's output is (in binary) 00000000IIIIIIIIFFFFFFFFFFFFFFFF 
....................     * Where the first 8 bits are 0, the next 8 represent the integer 
....................     * part of the battery, and the next 16 are the fractional part 
....................     */ 
....................    uint32_t tempo_u32, frac_part; 
....................    uint16_t tempo_u16; 
....................     
....................    uint16_t    bat_frac_part;    // in units of .1mV      
....................    uint8_t     bat_int_part; 
....................     
....................    tempo_u32 = VAL32_FVR_BAT/vref_count;   // = 1 count in volts in 12.20 format 
*
047DE:  MOVFF  54F,56A
047E2:  MOVFF  54E,569
047E6:  RCALL  4608
047E8:  MOVLW  9A
047EA:  MOVLB  5
047EC:  MOVWF  x6C
047EE:  MOVLW  99
047F0:  MOVWF  x6B
047F2:  MOVLW  19
047F4:  MOVWF  x6A
047F6:  MOVLW  95
047F8:  MOVWF  x69
047FA:  MOVFF  03,570
047FE:  MOVFF  02,56F
04802:  MOVFF  01,56E
04806:  MOVFF  00,56D
0480A:  MOVLB  0
0480C:  RCALL  463E
0480E:  MOVFF  03,56C
04812:  MOVFF  02,56B
04816:  MOVFF  01,56A
0481A:  MOVFF  00,569
0481E:  RCALL  479C
04820:  MOVFF  03,553
04824:  MOVFF  02,552
04828:  MOVFF  01,551
0482C:  MOVFF  00,550
04830:  CLRF   19
04832:  BTFSC  FF2.7
04834:  BSF    19.7
04836:  BCF    FF2.7
....................    tempo_u32 *= 1023;                        // bat voltage in 12.20 format 
04838:  MOVFF  553,58C
0483C:  MOVFF  552,58B
04840:  MOVFF  551,58A
04844:  MOVFF  550,589
04848:  MOVLB  5
0484A:  CLRF   x90
0484C:  CLRF   x8F
0484E:  MOVLW  03
04850:  MOVWF  x8E
04852:  SETF   x8D
04854:  MOVLB  0
04856:  CALL   1968
0485A:  BTFSC  19.7
0485C:  BSF    FF2.7
0485E:  MOVFF  03,553
04862:  MOVFF  02,552
04866:  MOVFF  01,551
0486A:  MOVFF  00,550
....................    tempo_u16 = (uint16_t)(tempo_u32 >> 8); 
0486E:  MOVFF  552,559
04872:  MOVFF  551,558
....................                                              // bat voltage in 4.12 format 
....................                                               
....................    //This stores the integer part shifted into the final result                                     
....................    bat_int_part = (uint8_t)(tempo_u16 >> 12);      // 2 or 3..... 
04876:  MOVLB  5
04878:  SWAPF  x59,W
0487A:  MOVWF  02
0487C:  MOVLW  0F
0487E:  ANDWF  02,F
04880:  MOVFF  02,55C
....................    frac_part = (uint32_t)(tempo_u16 & 0x0fff); 
04884:  MOVF   x59,W
04886:  ANDLW  0F
04888:  MOVFF  558,554
0488C:  MOVWF  x55
0488E:  CLRF   x56
04890:  CLRF   x57
04892:  CLRF   19
04894:  BTFSC  FF2.7
04896:  BSF    19.7
04898:  BCF    FF2.7
....................                                        // one count of frac_part is 1/4096 volt 
....................    tempo_u32 = (frac_part * 10000);    // 
0489A:  MOVFF  557,58C
0489E:  MOVFF  556,58B
048A2:  MOVFF  555,58A
048A6:  MOVFF  554,589
048AA:  CLRF   x90
048AC:  CLRF   x8F
048AE:  MOVLW  27
048B0:  MOVWF  x8E
048B2:  MOVLW  10
048B4:  MOVWF  x8D
048B6:  MOVLB  0
048B8:  CALL   1968
048BC:  BTFSC  19.7
048BE:  BSF    FF2.7
048C0:  MOVFF  03,553
048C4:  MOVFF  02,552
048C8:  MOVFF  01,551
048CC:  MOVFF  00,550
....................    tempo_u32 >>= 12; // divide by 4096. temp32 now = frac part (0 to 9999) 
048D0:  MOVLB  5
048D2:  MOVFF  551,550
048D6:  MOVFF  552,551
048DA:  MOVFF  553,552
048DE:  CLRF   x53
048E0:  RRCF   x53,F
048E2:  RRCF   x52,F
048E4:  RRCF   x51,F
048E6:  RRCF   x50,F
048E8:  RRCF   x53,F
048EA:  RRCF   x52,F
048EC:  RRCF   x51,F
048EE:  RRCF   x50,F
048F0:  RRCF   x53,F
048F2:  RRCF   x52,F
048F4:  RRCF   x51,F
048F6:  RRCF   x50,F
048F8:  RRCF   x53,F
048FA:  RRCF   x52,F
048FC:  RRCF   x51,F
048FE:  RRCF   x50,F
04900:  MOVLW  0F
04902:  ANDWF  x53,F
....................    bat_frac_part = (uint16_t)(tempo_u32); 
04904:  MOVFF  551,55B
04908:  MOVFF  550,55A
....................     
....................    return ((((uint32_t)bat_int_part) << 16) | (bat_frac_part)); 
0490C:  CLRF   x5E
0490E:  MOVFF  55E,03
04912:  CLRF   x5D
04914:  CLRF   x5E
04916:  MOVF   x5D,W
04918:  IORWF  x5A,W
0491A:  MOVWF  00
0491C:  MOVF   x5E,W
0491E:  IORWF  x5B,W
04920:  MOVWF  01
04922:  MOVFF  55C,02
04926:  MOVLB  0
04928:  GOTO   4D66 (RETURN)
....................    //return (uint32_t)bat_frac_part; 
.................... } 
....................  
.................... void check_and_deal_with_battery(void) 
.................... // checks the battery voltage (charging and not charging) and decides to turn on 
.................... // charger/off charger send a warning, or send a warning and shutdown. 
.................... { 
....................    uint16_t batt_chrg, batt_no_chrg; 
....................     
....................    // if the valve is not moving (otherwise, abort) 
....................    if (IS_VLV_COASTING) 
*
09164:  MOVF   F8D,F
09166:  BTFSS  FD8.2
09168:  BRA    927A
....................    { 
....................       // grab a fresh battery reading 
....................       batt_chrg = get_vbatt(0); 
0916A:  MOVLB  5
0916C:  CLRF   x66
0916E:  MOVLB  0
09170:  CALL   40A4
09174:  MOVFF  02,548
09178:  MOVFF  01,547
....................       batt_no_chrg = get_vbatt(1); 
0917C:  MOVLW  01
0917E:  MOVLB  5
09180:  MOVWF  x66
09182:  MOVLB  0
09184:  CALL   40A4
09188:  MOVFF  02,54A
0918C:  MOVFF  01,549
....................        
....................       // if the battery is dead and system needs to be shutdown 
....................       if (batt_no_chrg > BATTERY_DEAD) 
09190:  MOVLB  5
09192:  MOVF   x4A,W
09194:  SUBLW  05
09196:  BC    920C
09198:  XORLW  FF
0919A:  BNZ   91A2
0919C:  MOVF   x49,W
0919E:  SUBLW  65
091A0:  BC    920C
....................       { 
....................          global_control_loop_mechanism = BRAKE_AND_CHARGE_START; 
091A2:  MOVLB  0
091A4:  CLRF   xBC
....................          // set the error bitfield and message 
....................          global_error_message_bitfield |= ERR_MSG_BATT_DEAD_SLEEP; 
091A6:  MOVLB  4
091A8:  BSF    xF5.0
....................          PUSH_MESSAGE_QUEUE_MACRO(MSG_MOTE_ERROR_MSG); 
091AA:  BCF    F7A.1
091AC:  MOVLW  A0
091AE:  MOVLB  5
091B0:  MOVWF  x50
091B2:  MOVLB  0
091B4:  CALL   4FE0
091B8:  BSF    F7A.1
....................          // set the shutdown message and schedule a shutdown 
....................          global_shutdown_cause = ERR_BATT_DEAD_SLEEP;  
091BA:  MOVLW  0C
091BC:  MOVWF  4D
....................          PUSH_PRIORITY_QUEUE(OPEN_VALVE_UNKNOWN_STATE);   
091BE:  MOVLW  3E
091C0:  MOVLB  5
091C2:  MOVWF  x4E
091C4:  MOVLB  0
091C6:  CALL   4538
....................          PUSH_TIME_QUEUE(global_rtc_time + 10, SHUTDOWN_SYSTEM);   
091CA:  MOVLW  0A
091CC:  ADDWF  x85,W
091CE:  MOVLB  5
091D0:  MOVWF  x4B
091D2:  MOVLW  00
091D4:  MOVLB  0
091D6:  ADDWFC x86,W
091D8:  MOVLB  5
091DA:  MOVWF  x4C
091DC:  MOVLW  00
091DE:  MOVLB  0
091E0:  ADDWFC x87,W
091E2:  MOVLB  5
091E4:  MOVWF  x4D
091E6:  MOVLW  00
091E8:  MOVLB  0
091EA:  ADDWFC x88,W
091EC:  MOVLB  5
091EE:  MOVWF  x4E
091F0:  MOVWF  x55
091F2:  MOVFF  54D,554
091F6:  MOVFF  54C,553
091FA:  MOVFF  54B,552
091FE:  MOVLW  F1
09200:  MOVWF  x56
09202:  MOVLB  0
09204:  CALL   4290
....................       } 
09208:  BRA    927A
0920A:  MOVLB  5
....................       // if the battery is almost dead and the manager needs a warning 
....................       else if (batt_no_chrg > BATTERY_WARN) 
0920C:  MOVF   x4A,W
0920E:  SUBLW  05
09210:  BC    9238
09212:  XORLW  FF
09214:  BNZ   921C
09216:  MOVF   x49,W
09218:  SUBLW  30
0921A:  BC    9238
....................       { 
....................          global_control_loop_mechanism = BRAKE_AND_CHARGE_START; 
0921C:  MOVLB  0
0921E:  CLRF   xBC
....................          // set the error bitfield and message 
....................          global_error_message_bitfield |= ERR_MSG_BATT_LOW_WARN; 
09220:  MOVLB  4
09222:  BSF    xF4.7
....................          PUSH_MESSAGE_QUEUE_MACRO(MSG_MOTE_ERROR_MSG); 
09224:  BCF    F7A.1
09226:  MOVLW  A0
09228:  MOVLB  5
0922A:  MOVWF  x50
0922C:  MOVLB  0
0922E:  CALL   4FE0
09232:  BSF    F7A.1
....................       } 
09234:  BRA    927A
09236:  MOVLB  5
....................       // if the battery charging needs to be turned off (is in brake + charge control) 
....................       else if ((batt_chrg < BATTERY_STOP_CHARGING) &&                              \ 
....................          (global_control_loop_mechanism == BRAKE_AND_CHARGE)) 
09238:  MOVF   x48,W
0923A:  SUBLW  05
0923C:  BNC   925A
0923E:  BNZ   9246
09240:  MOVF   x47,W
09242:  SUBLW  79
09244:  BNC   925A
09246:  MOVLB  0
09248:  DECFSZ xBC,W
0924A:  BRA    924E
0924C:  BRA    9252
0924E:  MOVLB  5
09250:  BRA    925A
....................       { 
....................          global_control_loop_mechanism = BRAKE_ONLY; 
09252:  MOVLW  02
09254:  MOVWF  xBC
....................       } 
09256:  BRA    927A
09258:  MOVLB  5
....................       // if the battery charging needs to be turned on (is in brake only control) 
....................       else if ((batt_no_chrg > BATTERY_START_CHARGING) &&                     \ 
....................          (global_control_loop_mechanism == BRAKE_ONLY)) 
0925A:  MOVF   x4A,W
0925C:  SUBLW  04
0925E:  BC    927C
09260:  XORLW  FF
09262:  BNZ   926A
09264:  MOVF   x49,W
09266:  SUBLW  D2
09268:  BC    927C
0926A:  MOVLB  0
0926C:  MOVF   xBC,W
0926E:  SUBLW  02
09270:  BTFSC  FD8.2
09272:  BRA    9278
09274:  MOVLB  5
09276:  BRA    927C
....................       { 
....................          global_control_loop_mechanism = BRAKE_AND_CHARGE_START; 
09278:  CLRF   xBC
0927A:  MOVLB  5
....................       } 
....................    } 
0927C:  MOVLB  0
0927E:  GOTO   AD90 (RETURN)
.................... } 
....................           
....................  
....................  
....................  
....................  
.................... #include "stacks_queues.h"   
.................... void clear_priority_queue() 
.................... { 
....................    uint8_t n; 
....................     
....................    for (n = 0; n < MAX_PRIORITY_QUEUE_ITEMS; n++) 
*
03FB0:  MOVLB  5
03FB2:  CLRF   x47
03FB4:  MOVF   x47,W
03FB6:  SUBLW  13
03FB8:  BNC   3FCE
....................    { 
....................       global_priority_queue[n] = EMPTY_PRIORITY_QUEUE; 
03FBA:  CLRF   03
03FBC:  MOVF   x47,W
03FBE:  ADDLW  6A
03FC0:  MOVWF  FE9
03FC2:  MOVLW  03
03FC4:  ADDWFC 03,W
03FC6:  MOVWF  FEA
03FC8:  CLRF   FEF
03FCA:  INCF   x47,F
03FCC:  BRA    3FB4
....................    } 
03FCE:  MOVLB  0
03FD0:  GOTO   A112 (RETURN)
.................... } 
....................  
.................... uint8_t pop_priority_queue() 
.................... // Checks the priority queue and returns the current item to execute 
.................... { 
....................    uint8_t priority_queue_command_to_execute; 
....................     
....................    //no items in the queue (current location is 0-1) 
....................    if (global_current_priority_queue_location == 255) 
*
05BCA:  MOVLB  3
05BCC:  INCFSZ x7E,W
05BCE:  BRA    5BD8
....................    { 
....................       return EMPTY_PRIORITY_QUEUE; 
05BD0:  MOVLW  00
05BD2:  MOVWF  01
05BD4:  BRA    5C02
....................    } 
05BD6:  BRA    5C02
....................    else 
....................    { 
....................       //save the current command to execute 
....................       priority_queue_command_to_execute = global_priority_queue[global_current_priority_queue_location]; 
05BD8:  CLRF   03
05BDA:  MOVF   x7E,W
05BDC:  ADDLW  6A
05BDE:  MOVWF  FE9
05BE0:  MOVLW  03
05BE2:  ADDWFC 03,W
05BE4:  MOVWF  FEA
05BE6:  MOVFF  FEF,547
....................       //erase the current command and decrement the current queue location 
....................       global_priority_queue[global_current_priority_queue_location] = 0; 
05BEA:  CLRF   03
05BEC:  MOVF   x7E,W
05BEE:  ADDLW  6A
05BF0:  MOVWF  FE9
05BF2:  MOVLW  03
05BF4:  ADDWFC 03,W
05BF6:  MOVWF  FEA
05BF8:  CLRF   FEF
....................       global_current_priority_queue_location--; 
05BFA:  DECF   x7E,F
....................       //return the command to execute 
....................       return priority_queue_command_to_execute; 
05BFC:  MOVFF  547,01
05C00:  MOVLB  3
....................    } 
05C02:  MOVLB  0
05C04:  GOTO   A2A2 (RETURN)
.................... } 
....................  
.................... int1 push_priority_queue(uint8_t new_priority_queue_item) 
.................... // pushes a new item into the priority queue and sorts it. 
.................... // returns 1 if everything is good, 0 if queue is full 
.................... { 
....................    uint8_t n; 
....................    
....................    //if queue is full, return 0 
....................    if (global_current_priority_queue_location == (MAX_PRIORITY_QUEUE_ITEMS - 1)) 
*
04538:  MOVLB  3
0453A:  MOVF   x7E,W
0453C:  SUBLW  13
0453E:  BNZ   4546
....................    { 
....................       return 0; 
04540:  MOVLW  00
04542:  MOVWF  01
04544:  BRA    45FA
....................    } 
....................     
....................    //increment the queue location and 
....................    //set the new item at the top of the queue (will be sorted in a sec) 
....................    global_current_priority_queue_location++; 
04546:  INCF   x7E,F
....................    global_priority_queue[global_current_priority_queue_location] = new_priority_queue_item; 
04548:  CLRF   03
0454A:  MOVF   x7E,W
0454C:  ADDLW  6A
0454E:  MOVWF  FE9
04550:  MOVLW  03
04552:  ADDWFC 03,W
04554:  MOVWF  FEA
04556:  MOVFF  54E,FEF
....................     
....................    //starting at the new current queue location, sort through the queue 
....................    //until the new item is in the right place 
....................    for (n = global_current_priority_queue_location; n > 0; n--) 
0455A:  MOVFF  37E,54F
0455E:  MOVLB  5
04560:  MOVF   x4F,F
04562:  BZ    45F4
....................    { 
....................       //if queue items are not sorted properly 
....................       if (global_priority_queue[n] > global_priority_queue[n-1]) 
04564:  CLRF   03
04566:  MOVF   x4F,W
04568:  ADDLW  6A
0456A:  MOVWF  FE9
0456C:  MOVLW  03
0456E:  ADDWFC 03,W
04570:  MOVWF  FEA
04572:  MOVFF  FEF,550
04576:  MOVLW  01
04578:  SUBWF  x4F,W
0457A:  CLRF   03
0457C:  ADDLW  6A
0457E:  MOVWF  FE9
04580:  MOVLW  03
04582:  ADDWFC 03,W
04584:  MOVWF  FEA
04586:  MOVF   FEF,W
04588:  SUBWF  x50,W
0458A:  BZ    45E6
0458C:  BNC   45E6
....................       { 
....................          //do a swap reusing new queue item variable as a temp 
....................          new_priority_queue_item = global_priority_queue[n]; 
0458E:  CLRF   03
04590:  MOVF   x4F,W
04592:  ADDLW  6A
04594:  MOVWF  FE9
04596:  MOVLW  03
04598:  ADDWFC 03,W
0459A:  MOVWF  FEA
0459C:  MOVFF  FEF,54E
....................          global_priority_queue[n] = global_priority_queue[n-1]; 
045A0:  CLRF   03
045A2:  MOVF   x4F,W
045A4:  ADDLW  6A
045A6:  MOVWF  01
045A8:  MOVLW  03
045AA:  ADDWFC 03,F
045AC:  MOVFF  03,551
045B0:  MOVLW  01
045B2:  SUBWF  x4F,W
045B4:  CLRF   03
045B6:  ADDLW  6A
045B8:  MOVWF  FE9
045BA:  MOVLW  03
045BC:  ADDWFC 03,W
045BE:  MOVWF  FEA
045C0:  MOVFF  FEF,552
045C4:  MOVFF  551,FEA
045C8:  MOVFF  01,FE9
045CC:  MOVFF  552,FEF
....................          global_priority_queue[n-1] = new_priority_queue_item; 
045D0:  MOVLW  01
045D2:  SUBWF  x4F,W
045D4:  CLRF   03
045D6:  ADDLW  6A
045D8:  MOVWF  FE9
045DA:  MOVLW  03
045DC:  ADDWFC 03,W
045DE:  MOVWF  FEA
045E0:  MOVFF  54E,FEF
....................       } 
045E4:  BRA    45F0
....................       //item is in the proper place (assuming queue always sorted properly) 
....................       else 
....................       { 
....................          return 1; 
045E6:  MOVLW  01
045E8:  MOVWF  01
045EA:  MOVLB  3
045EC:  BRA    45FA
045EE:  MOVLB  5
....................       } 
045F0:  DECF   x4F,F
045F2:  BRA    4560
....................    } 
....................    return 1; 
045F4:  MOVLW  01
045F6:  MOVWF  01
045F8:  MOVLB  3
045FA:  MOVLB  0
045FC:  RETURN 0
.................... } 
....................  
.................... void push_priority_queue_ISR(uint8_t new_priority_queue_item) 
.................... // pushes a new item into the priority queue and sorts it. 
.................... // returns 1 if everything is good, 0 if queue is full 
.................... { 
....................    uint8_t n; 
....................    
....................    //if queue is full, return 0 
....................    if (global_current_priority_queue_location == (MAX_PRIORITY_QUEUE_ITEMS - 1)) 
*
00808:  MOVLB  3
0080A:  MOVF   x7E,W
0080C:  SUBLW  13
0080E:  BNZ   0812
....................    { 
....................       return; 
00810:  BRA    08B6
....................    } 
....................     
....................    //increment the queue location and 
....................    //set the new item at the top of the queue (will be sorted in a sec) 
....................    global_current_priority_queue_location++; 
00812:  INCF   x7E,F
....................    global_priority_queue[global_current_priority_queue_location] = new_priority_queue_item; 
00814:  CLRF   03
00816:  MOVF   x7E,W
00818:  ADDLW  6A
0081A:  MOVWF  FE9
0081C:  MOVLW  03
0081E:  ADDWFC 03,W
00820:  MOVWF  FEA
00822:  MOVFF  59B,FEF
....................     
....................    //starting at the new current queue location, sort through the queue 
....................    //until the new item is in the right place 
....................    for (n = global_current_priority_queue_location; n > 0; n--) 
00826:  MOVFF  37E,59C
0082A:  MOVLB  5
0082C:  MOVF   x9C,F
0082E:  BZ    08B4
....................    { 
....................       //if queue items are not sorted properly 
....................       if (global_priority_queue[n] > global_priority_queue[n-1]) 
00830:  CLRF   03
00832:  MOVF   x9C,W
00834:  ADDLW  6A
00836:  MOVWF  FE9
00838:  MOVLW  03
0083A:  ADDWFC 03,W
0083C:  MOVWF  FEA
0083E:  MOVFF  FEF,59D
00842:  MOVLW  01
00844:  SUBWF  x9C,W
00846:  CLRF   03
00848:  ADDLW  6A
0084A:  MOVWF  FE9
0084C:  MOVLW  03
0084E:  ADDWFC 03,W
00850:  MOVWF  FEA
00852:  MOVF   FEF,W
00854:  SUBWF  x9D,W
00856:  BZ    08B0
00858:  BNC   08B0
....................       { 
....................          //do a swap reusing new queue item variable as a temp 
....................          new_priority_queue_item = global_priority_queue[n]; 
0085A:  CLRF   03
0085C:  MOVF   x9C,W
0085E:  ADDLW  6A
00860:  MOVWF  FE9
00862:  MOVLW  03
00864:  ADDWFC 03,W
00866:  MOVWF  FEA
00868:  MOVFF  FEF,59B
....................          global_priority_queue[n] = global_priority_queue[n-1]; 
0086C:  CLRF   03
0086E:  MOVF   x9C,W
00870:  ADDLW  6A
00872:  MOVWF  01
00874:  MOVLW  03
00876:  ADDWFC 03,F
00878:  MOVFF  03,59E
0087C:  MOVLW  01
0087E:  SUBWF  x9C,W
00880:  CLRF   03
00882:  ADDLW  6A
00884:  MOVWF  FE9
00886:  MOVLW  03
00888:  ADDWFC 03,W
0088A:  MOVWF  FEA
0088C:  MOVFF  FEF,59F
00890:  MOVFF  59E,FEA
00894:  MOVFF  01,FE9
00898:  MOVFF  59F,FEF
....................          global_priority_queue[n-1] = new_priority_queue_item; 
0089C:  MOVLW  01
0089E:  SUBWF  x9C,W
008A0:  CLRF   03
008A2:  ADDLW  6A
008A4:  MOVWF  FE9
008A6:  MOVLW  03
008A8:  ADDWFC 03,W
008AA:  MOVWF  FEA
008AC:  MOVFF  59B,FEF
....................       } 
008B0:  DECF   x9C,F
008B2:  BRA    082C
008B4:  MOVLB  3
....................    } 
....................    return;  
008B6:  MOVLB  0
008B8:  RETURN 0
.................... } 
....................  
.................... void clear_time_queue() 
.................... { 
....................    uint8_t n; 
....................     
....................    for (n = 0; n < MAX_TIME_QUEUE_ITEMS; n++) 
*
03FD4:  MOVLB  5
03FD6:  CLRF   x47
03FD8:  MOVF   x47,W
03FDA:  SUBLW  04
03FDC:  BNC   402E
....................    { 
....................       global_time_queue[n].pq_priority = 0; 
03FDE:  MOVF   x47,W
03FE0:  MULLW  05
03FE2:  MOVF   FF3,W
03FE4:  CLRF   x49
03FE6:  MOVWF  x48
03FE8:  MOVLW  04
03FEA:  ADDWF  x48,W
03FEC:  MOVWF  01
03FEE:  MOVLW  00
03FF0:  ADDWFC x49,W
03FF2:  MOVWF  03
03FF4:  MOVF   01,W
03FF6:  ADDLW  7F
03FF8:  MOVWF  FE9
03FFA:  MOVLW  03
03FFC:  ADDWFC 03,W
03FFE:  MOVWF  FEA
04000:  CLRF   FEF
....................       global_time_queue[n].time_to_execute = 0; 
04002:  MOVF   x47,W
04004:  MULLW  05
04006:  MOVF   FF3,W
04008:  CLRF   x49
0400A:  MOVWF  x48
0400C:  MOVLW  7F
0400E:  ADDWF  x48,W
04010:  MOVWF  FE9
04012:  MOVLW  03
04014:  ADDWFC x49,W
04016:  MOVWF  FEA
04018:  MOVF   FEE,F
0401A:  MOVF   FEE,F
0401C:  CLRF   FEC
0401E:  MOVF   FED,F
04020:  CLRF   FEF
04022:  MOVF   FED,F
04024:  CLRF   FEF
04026:  MOVF   FED,F
04028:  CLRF   FEF
0402A:  INCF   x47,F
0402C:  BRA    3FD8
....................    } 
0402E:  MOVLB  0
04030:  GOTO   A116 (RETURN)
.................... } 
....................  
.................... int1 pop_time_queue() 
.................... // Checks the time queue and sends the item to execute to the priority queue 
.................... { 
....................    struct TimeQueueItem time_queue_command_to_execute; 
....................     
....................    //no items in the queue (current location is 0-1) 
....................    if (global_current_time_queue_location == (0-1)) 
....................    { 
....................       return EMPTY_TIME_QUEUE; 
....................    } 
....................    else 
....................    { 
....................       //save the current command to execute 
....................       time_queue_command_to_execute.pq_priority = global_time_queue[global_current_time_queue_location].pq_priority; 
....................        
....................       //erase the current command and decrement the current queue location 
....................       global_time_queue[global_current_time_queue_location].pq_priority = 0; 
....................       global_time_queue[global_current_time_queue_location].time_to_execute = 0; 
....................       global_current_time_queue_location--; 
....................        
....................       //send queue item to the priority queue and return the result from adding it to the PQ 
....................       return push_priority_queue(time_queue_command_to_execute.pq_priority); 
....................    } 
.................... } 
....................  
.................... void pop_time_queue_ISR() 
.................... // Checks the time queue and sends the item to execute to the priority queue 
.................... { 
....................    uint8_t priority; 
....................     
....................    //no items in the queue (current location is 0-1) 
....................    if (global_current_time_queue_location == 255) 
*
02072:  MOVLB  3
02074:  INCFSZ x98,W
02076:  BRA    207C
....................    { 
....................       return; 
02078:  BRA    2108
....................    } 
0207A:  BRA    2108
....................    else 
....................    { 
....................       //save the current command to execute 
....................       priority = global_time_queue[global_current_time_queue_location].pq_priority; 
0207C:  MOVF   x98,W
0207E:  MULLW  05
02080:  MOVF   FF3,W
02082:  MOVLB  5
02084:  CLRF   x81
02086:  MOVWF  x80
02088:  MOVLW  04
0208A:  ADDWF  x80,W
0208C:  MOVWF  01
0208E:  MOVLW  00
02090:  ADDWFC x81,W
02092:  MOVWF  03
02094:  MOVF   01,W
02096:  ADDLW  7F
02098:  MOVWF  FE9
0209A:  MOVLW  03
0209C:  ADDWFC 03,W
0209E:  MOVWF  FEA
020A0:  MOVFF  FEF,57F
....................        
....................       //erase the current command and decrement the current queue location 
....................       global_time_queue[global_current_time_queue_location].pq_priority = 0; 
020A4:  MOVLB  3
020A6:  MOVF   x98,W
020A8:  MULLW  05
020AA:  MOVF   FF3,W
020AC:  MOVLB  5
020AE:  CLRF   x81
020B0:  MOVWF  x80
020B2:  MOVLW  04
020B4:  ADDWF  x80,W
020B6:  MOVWF  01
020B8:  MOVLW  00
020BA:  ADDWFC x81,W
020BC:  MOVWF  03
020BE:  MOVF   01,W
020C0:  ADDLW  7F
020C2:  MOVWF  FE9
020C4:  MOVLW  03
020C6:  ADDWFC 03,W
020C8:  MOVWF  FEA
020CA:  CLRF   FEF
....................       global_time_queue[global_current_time_queue_location].time_to_execute = 0; 
020CC:  MOVLB  3
020CE:  MOVF   x98,W
020D0:  MULLW  05
020D2:  MOVF   FF3,W
020D4:  MOVLB  5
020D6:  CLRF   x81
020D8:  MOVWF  x80
020DA:  MOVLW  7F
020DC:  ADDWF  x80,W
020DE:  MOVWF  FE9
020E0:  MOVLW  03
020E2:  ADDWFC x81,W
020E4:  MOVWF  FEA
020E6:  MOVF   FEE,F
020E8:  MOVF   FEE,F
020EA:  CLRF   FEC
020EC:  MOVF   FED,F
020EE:  CLRF   FEF
020F0:  MOVF   FED,F
020F2:  CLRF   FEF
020F4:  MOVF   FED,F
020F6:  CLRF   FEF
....................       global_current_time_queue_location--; 
020F8:  MOVLB  3
020FA:  DECF   x98,F
....................        
....................       //send queue item to the priority queue and return the result from adding it to the PQ 
....................       push_priority_queue_ISR(priority); 
020FC:  MOVFF  57F,59B
02100:  MOVLB  0
02102:  CALL   0808
....................       return; 
02106:  MOVLB  3
....................    } 
02108:  MOVLB  0
0210A:  GOTO   2D50 (RETURN)
.................... } 
....................  
.................... int1 push_time_queue(uint32_t time_to_execute, uint8_t priority) 
.................... // pushes a new item into the time queue and sorts it (by time). 
.................... // returns 1 if everything is good, 0 if queue is full 
.................... { 
....................    uint8_t n; 
....................       
....................    //if queue is full, return 0 
....................    if (global_current_time_queue_location == (MAX_TIME_QUEUE_ITEMS - 1)) 
*
04290:  MOVLB  3
04292:  MOVF   x98,W
04294:  SUBLW  04
04296:  BNZ   429E
....................    { 
....................       return 0; 
04298:  MOVLW  00
0429A:  MOVWF  01
0429C:  BRA    44DA
....................    } 
....................     
....................    // increment the time queue location and 
....................    // set the new item at the top of the queue (will be sorted in a sec) 
....................    global_current_time_queue_location++; 
0429E:  INCF   x98,F
....................    global_time_queue[global_current_time_queue_location].pq_priority = priority; 
042A0:  MOVF   x98,W
042A2:  MULLW  05
042A4:  MOVF   FF3,W
042A6:  MOVLB  5
042A8:  CLRF   x59
042AA:  MOVWF  x58
042AC:  MOVLW  04
042AE:  ADDWF  x58,W
042B0:  MOVWF  01
042B2:  MOVLW  00
042B4:  ADDWFC x59,W
042B6:  MOVWF  03
042B8:  MOVF   01,W
042BA:  ADDLW  7F
042BC:  MOVWF  FE9
042BE:  MOVLW  03
042C0:  ADDWFC 03,W
042C2:  MOVWF  FEA
042C4:  MOVFF  556,FEF
....................    global_time_queue[global_current_time_queue_location].time_to_execute = time_to_execute; 
042C8:  MOVLB  3
042CA:  MOVF   x98,W
042CC:  MULLW  05
042CE:  MOVF   FF3,W
042D0:  MOVLB  5
042D2:  CLRF   x59
042D4:  MOVWF  x58
042D6:  MOVLW  7F
042D8:  ADDWF  x58,W
042DA:  MOVWF  FE9
042DC:  MOVLW  03
042DE:  ADDWFC x59,W
042E0:  MOVWF  FEA
042E2:  MOVFF  552,FEF
042E6:  MOVFF  553,FEC
042EA:  MOVFF  554,FEC
042EE:  MOVFF  555,FEC
....................     
....................    //starting at the new current queue location, sort through the queue 
....................    //until the new item is in the right place 
....................    for (n = global_current_time_queue_location; n > 0; n--) 
042F2:  MOVFF  398,557
042F6:  MOVF   x57,F
042F8:  BTFSC  FD8.2
042FA:  BRA    44D4
....................    { 
....................       //if queue items are not sorted properly 
....................       if (global_time_queue[n].time_to_execute > global_time_queue[n-1].time_to_execute) 
042FC:  MOVF   x57,W
042FE:  MULLW  05
04300:  MOVF   FF3,W
04302:  CLRF   x59
04304:  MOVWF  x58
04306:  MOVLW  7F
04308:  ADDWF  x58,W
0430A:  MOVWF  FE9
0430C:  MOVLW  03
0430E:  ADDWFC x59,W
04310:  MOVWF  FEA
04312:  MOVFF  FEF,55A
04316:  MOVFF  FEC,55B
0431A:  MOVFF  FEC,55C
0431E:  MOVFF  FEC,55D
04322:  MOVLW  01
04324:  SUBWF  x57,W
04326:  MULLW  05
04328:  MOVF   FF3,W
0432A:  CLRF   x5F
0432C:  MOVWF  x5E
0432E:  MOVLW  7F
04330:  ADDWF  x5E,W
04332:  MOVWF  FE9
04334:  MOVLW  03
04336:  ADDWFC x5F,W
04338:  MOVWF  FEA
0433A:  MOVFF  FEF,00
0433E:  MOVFF  FEC,01
04342:  MOVFF  FEC,02
04346:  MOVFF  FEC,03
0434A:  MOVF   03,W
0434C:  SUBWF  x5D,W
0434E:  BTFSS  FD8.0
04350:  BRA    44C6
04352:  BNZ   4370
04354:  MOVF   02,W
04356:  SUBWF  x5C,W
04358:  BTFSS  FD8.0
0435A:  BRA    44C6
0435C:  BNZ   4370
0435E:  MOVF   01,W
04360:  SUBWF  x5B,W
04362:  BTFSS  FD8.0
04364:  BRA    44C6
04366:  BNZ   4370
04368:  MOVF   x5A,W
0436A:  SUBWF  00,W
0436C:  BTFSC  FD8.0
0436E:  BRA    44C6
....................       { 
....................          //do a swap reusing new queue item variable as a temp 
....................          priority = global_time_queue[n].pq_priority; 
04370:  MOVF   x57,W
04372:  MULLW  05
04374:  MOVF   FF3,W
04376:  CLRF   x59
04378:  MOVWF  x58
0437A:  MOVLW  04
0437C:  ADDWF  x58,W
0437E:  MOVWF  01
04380:  MOVLW  00
04382:  ADDWFC x59,W
04384:  MOVWF  03
04386:  MOVF   01,W
04388:  ADDLW  7F
0438A:  MOVWF  FE9
0438C:  MOVLW  03
0438E:  ADDWFC 03,W
04390:  MOVWF  FEA
04392:  MOVFF  FEF,556
....................          global_time_queue[n].pq_priority = global_time_queue[n-1].pq_priority; 
04396:  MOVF   x57,W
04398:  MULLW  05
0439A:  MOVF   FF3,W
0439C:  CLRF   x59
0439E:  MOVWF  x58
043A0:  MOVLW  04
043A2:  ADDWF  x58,W
043A4:  MOVWF  01
043A6:  MOVLW  00
043A8:  ADDWFC x59,W
043AA:  MOVWF  03
043AC:  MOVF   01,W
043AE:  ADDLW  7F
043B0:  MOVWF  01
043B2:  MOVLW  03
043B4:  ADDWFC 03,F
043B6:  MOVFF  01,558
043BA:  MOVFF  03,559
043BE:  MOVLW  01
043C0:  SUBWF  x57,W
043C2:  MULLW  05
043C4:  MOVF   FF3,W
043C6:  CLRF   x5B
043C8:  MOVWF  x5A
043CA:  MOVLW  04
043CC:  ADDWF  x5A,W
043CE:  MOVWF  01
043D0:  MOVLW  00
043D2:  ADDWFC x5B,W
043D4:  MOVWF  03
043D6:  MOVF   01,W
043D8:  ADDLW  7F
043DA:  MOVWF  FE9
043DC:  MOVLW  03
043DE:  ADDWFC 03,W
043E0:  MOVWF  FEA
043E2:  MOVFF  FEF,55A
043E6:  MOVFF  559,FEA
043EA:  MOVFF  558,FE9
043EE:  MOVFF  55A,FEF
....................          global_time_queue[n-1].pq_priority = priority; 
043F2:  MOVLW  01
043F4:  SUBWF  x57,W
043F6:  MULLW  05
043F8:  MOVF   FF3,W
043FA:  CLRF   x59
043FC:  MOVWF  x58
043FE:  MOVLW  04
04400:  ADDWF  x58,W
04402:  MOVWF  01
04404:  MOVLW  00
04406:  ADDWFC x59,W
04408:  MOVWF  03
0440A:  MOVF   01,W
0440C:  ADDLW  7F
0440E:  MOVWF  FE9
04410:  MOVLW  03
04412:  ADDWFC 03,W
04414:  MOVWF  FEA
04416:  MOVFF  556,FEF
....................          time_to_execute = global_time_queue[n].time_to_execute; 
0441A:  MOVF   x57,W
0441C:  MULLW  05
0441E:  MOVF   FF3,W
04420:  CLRF   x59
04422:  MOVWF  x58
04424:  MOVLW  7F
04426:  ADDWF  x58,W
04428:  MOVWF  FE9
0442A:  MOVLW  03
0442C:  ADDWFC x59,W
0442E:  MOVWF  FEA
04430:  MOVFF  FEF,552
04434:  MOVFF  FEC,553
04438:  MOVFF  FEC,554
0443C:  MOVFF  FEC,555
....................          global_time_queue[n].time_to_execute = global_time_queue[n-1].time_to_execute; 
04440:  MOVF   x57,W
04442:  MULLW  05
04444:  MOVF   FF3,W
04446:  CLRF   x59
04448:  MOVWF  x58
0444A:  MOVLW  7F
0444C:  ADDWF  x58,W
0444E:  MOVWF  01
04450:  MOVLW  03
04452:  ADDWFC x59,W
04454:  MOVWF  03
04456:  MOVFF  01,55A
0445A:  MOVWF  x5B
0445C:  MOVLW  01
0445E:  SUBWF  x57,W
04460:  MULLW  05
04462:  MOVF   FF3,W
04464:  CLRF   x5D
04466:  MOVWF  x5C
04468:  MOVLW  7F
0446A:  ADDWF  x5C,W
0446C:  MOVWF  FE9
0446E:  MOVLW  03
04470:  ADDWFC x5D,W
04472:  MOVWF  FEA
04474:  MOVFF  FEF,00
04478:  MOVFF  FEC,01
0447C:  MOVFF  FEC,02
04480:  MOVFF  FEC,03
04484:  MOVFF  55B,FEA
04488:  MOVFF  55A,FE9
0448C:  MOVFF  00,FEF
04490:  MOVFF  01,FEC
04494:  MOVFF  02,FEC
04498:  MOVFF  03,FEC
....................          global_time_queue[n-1].time_to_execute = time_to_execute; 
0449C:  MOVLW  01
0449E:  SUBWF  x57,W
044A0:  MULLW  05
044A2:  MOVF   FF3,W
044A4:  CLRF   x59
044A6:  MOVWF  x58
044A8:  MOVLW  7F
044AA:  ADDWF  x58,W
044AC:  MOVWF  FE9
044AE:  MOVLW  03
044B0:  ADDWFC x59,W
044B2:  MOVWF  FEA
044B4:  MOVFF  552,FEF
044B8:  MOVFF  553,FEC
044BC:  MOVFF  554,FEC
044C0:  MOVFF  555,FEC
....................           
....................       } 
044C4:  BRA    44D0
....................       //item is in the proper place (assuming queue always sorted properly) 
....................       else 
....................       { 
....................          return 1; 
044C6:  MOVLW  01
044C8:  MOVWF  01
044CA:  MOVLB  3
044CC:  BRA    44DA
044CE:  MOVLB  5
....................       } 
044D0:  DECF   x57,F
044D2:  BRA    42F6
....................    } 
....................    return 1; 
044D4:  MOVLW  01
044D6:  MOVWF  01
044D8:  MOVLB  3
044DA:  MOVLB  0
044DC:  RETURN 0
.................... } 
....................  
.................... void push_time_queue_ISR(uint32_t time_to_execute, uint8_t priority) 
.................... // pushes a new item into the time queue and sorts it (by time). 
.................... // returns 1 if everything is good, 0 if queue is full 
.................... { 
....................    uint8_t n; 
....................       
....................    //if queue is full, return 0 
....................    if (global_current_time_queue_location == (MAX_TIME_QUEUE_ITEMS - 1)) 
*
0172E:  MOVLB  3
01730:  MOVF   x98,W
01732:  SUBLW  04
01734:  BNZ   1738
....................    { 
....................       return; 
01736:  BRA    1964
....................    } 
....................     
....................    // increment the time queue location and 
....................    // set the new item at the top of the queue (will be sorted in a sec) 
....................    global_current_time_queue_location++; 
01738:  INCF   x98,F
....................    global_time_queue[global_current_time_queue_location].pq_priority = priority; 
0173A:  MOVF   x98,W
0173C:  MULLW  05
0173E:  MOVF   FF3,W
01740:  MOVLB  5
01742:  CLRF   xBE
01744:  MOVWF  xBD
01746:  MOVLW  04
01748:  ADDWF  xBD,W
0174A:  MOVWF  01
0174C:  MOVLW  00
0174E:  ADDWFC xBE,W
01750:  MOVWF  03
01752:  MOVF   01,W
01754:  ADDLW  7F
01756:  MOVWF  FE9
01758:  MOVLW  03
0175A:  ADDWFC 03,W
0175C:  MOVWF  FEA
0175E:  MOVFF  5BB,FEF
....................    global_time_queue[global_current_time_queue_location].time_to_execute = time_to_execute; 
01762:  MOVLB  3
01764:  MOVF   x98,W
01766:  MULLW  05
01768:  MOVF   FF3,W
0176A:  MOVLB  5
0176C:  CLRF   xBE
0176E:  MOVWF  xBD
01770:  MOVLW  7F
01772:  ADDWF  xBD,W
01774:  MOVWF  FE9
01776:  MOVLW  03
01778:  ADDWFC xBE,W
0177A:  MOVWF  FEA
0177C:  MOVFF  5B7,FEF
01780:  MOVFF  5B8,FEC
01784:  MOVFF  5B9,FEC
01788:  MOVFF  5BA,FEC
....................        
....................    //starting at the new current queue location, sort through the queue 
....................    //until the new item is in the right place 
....................    for (n = global_current_time_queue_location; n > 0; n--) 
0178C:  MOVFF  398,5BC
01790:  MOVF   xBC,F
01792:  BTFSC  FD8.2
01794:  BRA    1962
....................    { 
....................       //if queue items are not sorted properly 
....................       if (global_time_queue[n].time_to_execute > global_time_queue[n-1].time_to_execute) 
01796:  MOVF   xBC,W
01798:  MULLW  05
0179A:  MOVF   FF3,W
0179C:  CLRF   xBE
0179E:  MOVWF  xBD
017A0:  MOVLW  7F
017A2:  ADDWF  xBD,W
017A4:  MOVWF  FE9
017A6:  MOVLW  03
017A8:  ADDWFC xBE,W
017AA:  MOVWF  FEA
017AC:  MOVFF  FEF,5BF
017B0:  MOVFF  FEC,5C0
017B4:  MOVFF  FEC,5C1
017B8:  MOVFF  FEC,5C2
017BC:  MOVLW  01
017BE:  SUBWF  xBC,W
017C0:  MULLW  05
017C2:  MOVF   FF3,W
017C4:  CLRF   xC4
017C6:  MOVWF  xC3
017C8:  MOVLW  7F
017CA:  ADDWF  xC3,W
017CC:  MOVWF  FE9
017CE:  MOVLW  03
017D0:  ADDWFC xC4,W
017D2:  MOVWF  FEA
017D4:  MOVFF  FEF,00
017D8:  MOVFF  FEC,01
017DC:  MOVFF  FEC,02
017E0:  MOVFF  FEC,03
017E4:  MOVF   03,W
017E6:  SUBWF  xC2,W
017E8:  BTFSS  FD8.0
017EA:  BRA    195E
017EC:  BNZ   180A
017EE:  MOVF   02,W
017F0:  SUBWF  xC1,W
017F2:  BTFSS  FD8.0
017F4:  BRA    195E
017F6:  BNZ   180A
017F8:  MOVF   01,W
017FA:  SUBWF  xC0,W
017FC:  BTFSS  FD8.0
017FE:  BRA    195E
01800:  BNZ   180A
01802:  MOVF   xBF,W
01804:  SUBWF  00,W
01806:  BTFSC  FD8.0
01808:  BRA    195E
....................       { 
....................          //do a swap reusing new queue item variable as a temp 
....................          priority = global_time_queue[n].pq_priority; 
0180A:  MOVF   xBC,W
0180C:  MULLW  05
0180E:  MOVF   FF3,W
01810:  CLRF   xBE
01812:  MOVWF  xBD
01814:  MOVLW  04
01816:  ADDWF  xBD,W
01818:  MOVWF  01
0181A:  MOVLW  00
0181C:  ADDWFC xBE,W
0181E:  MOVWF  03
01820:  MOVF   01,W
01822:  ADDLW  7F
01824:  MOVWF  FE9
01826:  MOVLW  03
01828:  ADDWFC 03,W
0182A:  MOVWF  FEA
0182C:  MOVFF  FEF,5BB
....................          global_time_queue[n].pq_priority = global_time_queue[n-1].pq_priority; 
01830:  MOVF   xBC,W
01832:  MULLW  05
01834:  MOVF   FF3,W
01836:  CLRF   xBE
01838:  MOVWF  xBD
0183A:  MOVLW  04
0183C:  ADDWF  xBD,W
0183E:  MOVWF  01
01840:  MOVLW  00
01842:  ADDWFC xBE,W
01844:  MOVWF  03
01846:  MOVF   01,W
01848:  ADDLW  7F
0184A:  MOVWF  01
0184C:  MOVLW  03
0184E:  ADDWFC 03,F
01850:  MOVFF  01,5BD
01854:  MOVFF  03,5BE
01858:  MOVLW  01
0185A:  SUBWF  xBC,W
0185C:  MULLW  05
0185E:  MOVF   FF3,W
01860:  CLRF   xC0
01862:  MOVWF  xBF
01864:  MOVLW  04
01866:  ADDWF  xBF,W
01868:  MOVWF  01
0186A:  MOVLW  00
0186C:  ADDWFC xC0,W
0186E:  MOVWF  03
01870:  MOVF   01,W
01872:  ADDLW  7F
01874:  MOVWF  FE9
01876:  MOVLW  03
01878:  ADDWFC 03,W
0187A:  MOVWF  FEA
0187C:  MOVFF  FEF,5BF
01880:  MOVFF  5BE,FEA
01884:  MOVFF  5BD,FE9
01888:  MOVFF  5BF,FEF
....................          global_time_queue[n-1].pq_priority = priority; 
0188C:  MOVLW  01
0188E:  SUBWF  xBC,W
01890:  MULLW  05
01892:  MOVF   FF3,W
01894:  CLRF   xBE
01896:  MOVWF  xBD
01898:  MOVLW  04
0189A:  ADDWF  xBD,W
0189C:  MOVWF  01
0189E:  MOVLW  00
018A0:  ADDWFC xBE,W
018A2:  MOVWF  03
018A4:  MOVF   01,W
018A6:  ADDLW  7F
018A8:  MOVWF  FE9
018AA:  MOVLW  03
018AC:  ADDWFC 03,W
018AE:  MOVWF  FEA
018B0:  MOVFF  5BB,FEF
....................          time_to_execute = global_time_queue[n].time_to_execute; 
018B4:  MOVF   xBC,W
018B6:  MULLW  05
018B8:  MOVF   FF3,W
018BA:  CLRF   xBE
018BC:  MOVWF  xBD
018BE:  MOVLW  7F
018C0:  ADDWF  xBD,W
018C2:  MOVWF  FE9
018C4:  MOVLW  03
018C6:  ADDWFC xBE,W
018C8:  MOVWF  FEA
018CA:  MOVFF  FEF,5B7
018CE:  MOVFF  FEC,5B8
018D2:  MOVFF  FEC,5B9
018D6:  MOVFF  FEC,5BA
....................          global_time_queue[n].time_to_execute = global_time_queue[n-1].time_to_execute; 
018DA:  MOVF   xBC,W
018DC:  MULLW  05
018DE:  MOVF   FF3,W
018E0:  CLRF   xBE
018E2:  MOVWF  xBD
018E4:  MOVLW  7F
018E6:  ADDWF  xBD,W
018E8:  MOVWF  01
018EA:  MOVLW  03
018EC:  ADDWFC xBE,W
018EE:  MOVWF  03
018F0:  MOVFF  01,5BF
018F4:  MOVWF  xC0
018F6:  MOVLW  01
018F8:  SUBWF  xBC,W
018FA:  MULLW  05
018FC:  MOVF   FF3,W
018FE:  CLRF   xC2
01900:  MOVWF  xC1
01902:  MOVLW  7F
01904:  ADDWF  xC1,W
01906:  MOVWF  FE9
01908:  MOVLW  03
0190A:  ADDWFC xC2,W
0190C:  MOVWF  FEA
0190E:  MOVFF  FEF,00
01912:  MOVFF  FEC,01
01916:  MOVFF  FEC,02
0191A:  MOVFF  FEC,03
0191E:  MOVFF  5C0,FEA
01922:  MOVFF  5BF,FE9
01926:  MOVFF  00,FEF
0192A:  MOVFF  01,FEC
0192E:  MOVFF  02,FEC
01932:  MOVFF  03,FEC
....................          global_time_queue[n-1].time_to_execute = time_to_execute; 
01936:  MOVLW  01
01938:  SUBWF  xBC,W
0193A:  MULLW  05
0193C:  MOVF   FF3,W
0193E:  CLRF   xBE
01940:  MOVWF  xBD
01942:  MOVLW  7F
01944:  ADDWF  xBD,W
01946:  MOVWF  FE9
01948:  MOVLW  03
0194A:  ADDWFC xBE,W
0194C:  MOVWF  FEA
0194E:  MOVFF  5B7,FEF
01952:  MOVFF  5B8,FEC
01956:  MOVFF  5B9,FEC
0195A:  MOVFF  5BA,FEC
....................           
....................       } 
0195E:  DECF   xBC,F
01960:  BRA    1790
01962:  MOVLB  3
....................    } 
....................    return; 
01964:  MOVLB  0
01966:  RETURN 0
.................... } 
....................  
.................... void allocate_command_queue(void) 
.................... { 
....................    // allocate the memory for the command queue sprinkler zone settings (can't 
....................    //    easily make a struct array inside a struct in c.) 
....................  
....................    uint8_t n; 
....................     
....................    for (n = 0; n < MAX_COMMAND_QUEUE_ITEMS; n++) 
....................    { 
....................       global_command_queue[n].sprinkler_settings =                            \ 
....................       (struct SprinklerZoneSettingsItem*)                                     \ 
....................       malloc(sizeof (struct SprinklerZoneSettingsItem) * MAX_NUM_SPRINKLER_ZONES); 
....................    } 
.................... } 
....................  
.................... void clear_command_queue(void) 
.................... { 
....................    // clears out the command queue and sets the start times to 0-1 
....................    uint8_t n; 
....................     
....................    // clear the queue compeleted and fill with zeros 
....................    memset(global_command_queue, 0, sizeof global_command_queue); 
....................     
....................    // sets start times to 0-1 (for unsigned int) 
....................    for (n = 0; n < MAX_COMMAND_QUEUE_ITEMS; n++) 
....................    { 
....................       global_command_queue[n].start_time = 0-1; 
....................    } 
....................     
....................    // set the queue location to 0-1 which signifies that there isn't anything 
....................    //    in the queue 
....................    global_current_command_queue_location = 0-1; 
.................... } 
....................  
.................... int1 push_command_queue(struct CommandQueueItem new_command_queue_item) 
.................... // pushes a new item into the command queue and sorts it (by time). 
.................... // returns 1 if everything is good, 0 if queue is full 
.................... { 
....................    uint8_t n; 
....................     
....................    //if queue is full, return 0 
....................    if (global_current_command_queue_location == (MAX_COMMAND_QUEUE_ITEMS - 1)) 
....................    { 
....................       return 0; 
....................    } 
....................     
....................    // increment the command queue location and 
....................    // set the new item at the top of the queue (will be sorted in a sec) 
....................    global_current_command_queue_location++; 
....................    global_command_queue[global_current_command_queue_location] = new_command_queue_item; 
....................     
....................    //starting at the new current queue location, sort through the queue 
....................    //until the new item is in the right place 
....................    for (n = global_current_command_queue_location; n > 0; n--) 
....................    { 
....................       //if queue items are not sorted properly 
....................       if (global_command_queue[n].start_time > global_command_queue[n-1].start_time) 
....................       { 
....................          //do a swap reusing new queue item variable as a temp 
....................          new_command_queue_item = global_time_queue[n]; 
....................          global_time_queue[n] = global_time_queue[n-1]; 
....................          global_time_queue[n-1] = new_command_queue_item; 
....................       } 
....................       //item is in the proper place (assuming queue always sorted properly) 
....................       else 
....................       { 
....................          return 1; 
....................       } 
....................    } 
....................    return 1; 
.................... } 
....................  
.................... void pop_command_queue_ISR() 
.................... // pops a new item off the command queue and sorts it (by time). 
.................... // returns 1 if everything is good, 0 if queue is full 
.................... { 
....................    uint8_t n; 
....................    struct commandQueueItem new_command_queue_item; 
....................     
....................    //if queue is empty, return 0 
....................    if (global_current_command_queue_location == 255) 
....................    { 
....................       return; 
....................    } 
....................     
....................     
....................    // increment the command queue location and 
....................    // set the new item at the top of the queue (will be sorted in a sec) 
....................    global_current_command_queue_location++; 
....................    global_command_queue[global_current_command_queue_location] = new_command_queue_item; 
....................     
....................    //starting at the new current queue location, sort through the queue 
....................    //until the new item is in the right place 
....................    for (n = global_current_command_queue_location; n > 0; n--) 
....................    { 
....................       //if queue items are not sorted properly 
....................       if (global_command_queue[n].start_time > global_command_queue[n-1].start_time) 
....................       { 
....................          //do a swap reusing new queue item variable as a temp 
....................          new_command_queue_item = global_time_queue[n]; 
....................          global_time_queue[n] = global_time_queue[n-1]; 
....................          global_time_queue[n-1] = new_command_queue_item; 
....................       } 
....................       //item is in the proper place (assuming queue always sorted properly) 
....................       else 
....................       { 
....................          return; 
....................       } 
....................    } 
....................    return; 
.................... } 
.................... void clear_sprinkler_queue() 
.................... { 
....................    disable_interrupts(INT_CCP4); 
*
053A0:  BCF    F7A.1
....................    memset(&global_sprinkler_queue, EMPTY_SPINKLER_QUEUE, sizeof(global_sprinkler_queue)); 
053A2:  MOVLW  03
053A4:  MOVWF  FEA
053A6:  MOVLW  99
053A8:  MOVWF  FE9
053AA:  CLRF   00
053AC:  CLRF   02
053AE:  MOVLW  8C
053B0:  MOVWF  01
053B2:  CALL   210E
....................    global_current_sprinkler_queue_location = 0-1; 
053B6:  MOVLB  4
053B8:  SETF   x25
....................    global_rpm_set_value = 0; 
053BA:  MOVLB  0
053BC:  CLRF   xA9
053BE:  CLRF   xA8
....................    global_control_loop_mechanism = NO_RPM_CONTROL; 
053C0:  MOVLW  05
053C2:  MOVWF  xBC
....................    enable_interrupts(INT_CCP4); 
053C4:  BSF    F7A.1
053C6:  RETURN 0
.................... } 
....................  
.................... void push_sprinkler_queue(uint32_t start_time,uint32_t end_time,uint16_t vlv_open_amount,uint16_t spin_rate,uint8_t zone_num, uint8_t control_loop_mechanism) 
.................... // pushes a new item into the sprinkler queue and sorts it (by start time). 
.................... // returns 1 if everything is good, 0 if queue is full 
.................... { 
....................    uint8_t n; 
....................    struct SprinklerQueueItem temp_sprinkler_queue_item; 
....................     
....................    // disable CCP4 interrupt (RTC timer) 
....................    disable_interrupts(INT_CCP4); 
*
06C44:  BCF    F7A.1
....................           
....................    //if queue is full, return 0 
....................    if (global_current_sprinkler_queue_location == (MAX_SPRINKLER_QUEUE_ITEMS - 1)) 
06C46:  MOVLB  4
06C48:  MOVF   x25,W
06C4A:  SUBLW  09
06C4C:  BNZ   6C52
....................    { 
....................       enable_interrupts(INT_CCP4); 
06C4E:  BSF    F7A.1
....................       return; 
06C50:  BRA    6E7E
....................    } 
....................     
....................    // increment the sprinkler queue location and 
....................    // set the new item at the top of the queue (will be sorted in a sec) 
....................    global_current_sprinkler_queue_location++; 
06C52:  INCF   x25,F
....................    global_sprinkler_queue[global_current_sprinkler_queue_location].start_time = start_time; 
06C54:  MOVF   x25,W
06C56:  MULLW  0E
06C58:  MOVF   FF3,W
06C5A:  MOVLB  5
06C5C:  CLRF   x78
06C5E:  MOVWF  x77
06C60:  MOVLW  99
06C62:  ADDWF  x77,W
06C64:  MOVWF  FE9
06C66:  MOVLW  03
06C68:  ADDWFC x78,W
06C6A:  MOVWF  FEA
06C6C:  MOVFF  55A,FEF
06C70:  MOVFF  55B,FEC
06C74:  MOVFF  55C,FEC
06C78:  MOVFF  55D,FEC
....................    global_sprinkler_queue[global_current_sprinkler_queue_location].end_time = end_time; 
06C7C:  MOVLB  4
06C7E:  MOVF   x25,W
06C80:  MULLW  0E
06C82:  MOVF   FF3,W
06C84:  MOVLB  5
06C86:  CLRF   x78
06C88:  MOVWF  x77
06C8A:  MOVLW  04
06C8C:  ADDWF  x77,W
06C8E:  MOVWF  01
06C90:  MOVLW  00
06C92:  ADDWFC x78,W
06C94:  MOVWF  03
06C96:  MOVF   01,W
06C98:  ADDLW  99
06C9A:  MOVWF  FE9
06C9C:  MOVLW  03
06C9E:  ADDWFC 03,W
06CA0:  MOVWF  FEA
06CA2:  MOVFF  55E,FEF
06CA6:  MOVFF  55F,FEC
06CAA:  MOVFF  560,FEC
06CAE:  MOVFF  561,FEC
....................    global_sprinkler_queue[global_current_sprinkler_queue_location].vlv_open_amount = vlv_open_amount; 
06CB2:  MOVLB  4
06CB4:  MOVF   x25,W
06CB6:  MULLW  0E
06CB8:  MOVF   FF3,W
06CBA:  MOVLB  5
06CBC:  CLRF   x78
06CBE:  MOVWF  x77
06CC0:  MOVLW  08
06CC2:  ADDWF  x77,W
06CC4:  MOVWF  01
06CC6:  MOVLW  00
06CC8:  ADDWFC x78,W
06CCA:  MOVWF  03
06CCC:  MOVF   01,W
06CCE:  ADDLW  99
06CD0:  MOVWF  FE9
06CD2:  MOVLW  03
06CD4:  ADDWFC 03,W
06CD6:  MOVWF  FEA
06CD8:  MOVFF  563,FEC
06CDC:  MOVF   FED,F
06CDE:  MOVFF  562,FEF
....................    global_sprinkler_queue[global_current_sprinkler_queue_location].spin_rate = spin_rate; 
06CE2:  MOVLB  4
06CE4:  MOVF   x25,W
06CE6:  MULLW  0E
06CE8:  MOVF   FF3,W
06CEA:  MOVLB  5
06CEC:  CLRF   x78
06CEE:  MOVWF  x77
06CF0:  MOVLW  0A
06CF2:  ADDWF  x77,W
06CF4:  MOVWF  01
06CF6:  MOVLW  00
06CF8:  ADDWFC x78,W
06CFA:  MOVWF  03
06CFC:  MOVF   01,W
06CFE:  ADDLW  99
06D00:  MOVWF  FE9
06D02:  MOVLW  03
06D04:  ADDWFC 03,W
06D06:  MOVWF  FEA
06D08:  MOVFF  565,FEC
06D0C:  MOVF   FED,F
06D0E:  MOVFF  564,FEF
....................    global_sprinkler_queue[global_current_sprinkler_queue_location].zone_num = zone_num; 
06D12:  MOVLB  4
06D14:  MOVF   x25,W
06D16:  MULLW  0E
06D18:  MOVF   FF3,W
06D1A:  MOVLB  5
06D1C:  CLRF   x78
06D1E:  MOVWF  x77
06D20:  MOVLW  0C
06D22:  ADDWF  x77,W
06D24:  MOVWF  01
06D26:  MOVLW  00
06D28:  ADDWFC x78,W
06D2A:  MOVWF  03
06D2C:  MOVF   01,W
06D2E:  ADDLW  99
06D30:  MOVWF  FE9
06D32:  MOVLW  03
06D34:  ADDWFC 03,W
06D36:  MOVWF  FEA
06D38:  MOVFF  566,FEF
....................    global_sprinkler_queue[global_current_sprinkler_queue_location].control_loop_mechanism = control_loop_mechanism; 
06D3C:  MOVLB  4
06D3E:  MOVF   x25,W
06D40:  MULLW  0E
06D42:  MOVF   FF3,W
06D44:  MOVLB  5
06D46:  CLRF   x78
06D48:  MOVWF  x77
06D4A:  MOVLW  0D
06D4C:  ADDWF  x77,W
06D4E:  MOVWF  01
06D50:  MOVLW  00
06D52:  ADDWFC x78,W
06D54:  MOVWF  03
06D56:  MOVF   01,W
06D58:  ADDLW  99
06D5A:  MOVWF  FE9
06D5C:  MOVLW  03
06D5E:  ADDWFC 03,W
06D60:  MOVWF  FEA
06D62:  MOVFF  567,FEF
....................     
....................     
....................    //starting at the new current queue location, sort through the queue 
....................    //until the new item is in the right place 
....................    for (n = global_current_sprinkler_queue_location; n > 0; n--) 
06D66:  MOVFF  425,568
06D6A:  MOVF   x68,F
06D6C:  BTFSC  FD8.2
06D6E:  BRA    6E7A
....................    { 
....................       //if queue items are not sorted properly 
....................       if (global_sprinkler_queue[n].start_time > global_sprinkler_queue[n-1].start_time) 
06D70:  MOVF   x68,W
06D72:  MULLW  0E
06D74:  MOVF   FF3,W
06D76:  CLRF   x78
06D78:  MOVWF  x77
06D7A:  MOVLW  99
06D7C:  ADDWF  x77,W
06D7E:  MOVWF  FE9
06D80:  MOVLW  03
06D82:  ADDWFC x78,W
06D84:  MOVWF  FEA
06D86:  MOVFF  FEF,579
06D8A:  MOVFF  FEC,57A
06D8E:  MOVFF  FEC,57B
06D92:  MOVFF  FEC,57C
06D96:  MOVLW  01
06D98:  SUBWF  x68,W
06D9A:  MULLW  0E
06D9C:  MOVF   FF3,W
06D9E:  CLRF   x7E
06DA0:  MOVWF  x7D
06DA2:  MOVLW  99
06DA4:  ADDWF  x7D,W
06DA6:  MOVWF  FE9
06DA8:  MOVLW  03
06DAA:  ADDWFC x7E,W
06DAC:  MOVWF  FEA
06DAE:  MOVFF  FEF,00
06DB2:  MOVFF  FEC,01
06DB6:  MOVFF  FEC,02
06DBA:  MOVFF  FEC,03
06DBE:  MOVF   03,W
06DC0:  SUBWF  x7C,W
06DC2:  BNC   6E6E
06DC4:  BNZ   6DDC
06DC6:  MOVF   02,W
06DC8:  SUBWF  x7B,W
06DCA:  BNC   6E6E
06DCC:  BNZ   6DDC
06DCE:  MOVF   01,W
06DD0:  SUBWF  x7A,W
06DD2:  BNC   6E6E
06DD4:  BNZ   6DDC
06DD6:  MOVF   x79,W
06DD8:  SUBWF  00,W
06DDA:  BC    6E6E
....................       { 
....................          //do a swap reusing new queue item variable as a temp 
....................          memcpy(&temp_sprinkler_queue_item, &global_sprinkler_queue[n], sizeof(&temp_sprinkler_queue_item)); 
06DDC:  MOVF   x68,W
06DDE:  MULLW  0E
06DE0:  MOVF   FF3,W
06DE2:  CLRF   03
06DE4:  ADDLW  99
06DE6:  MOVWF  01
06DE8:  MOVLW  03
06DEA:  ADDWFC 03,F
06DEC:  MOVFF  03,FE2
06DF0:  MOVFF  01,FE1
06DF4:  MOVFF  FE6,569
06DF8:  MOVFF  FE6,56A
....................          memcpy(&global_sprinkler_queue[n], &global_sprinkler_queue[n-1], sizeof(&global_sprinkler_queue[n])); 
06DFC:  MOVF   x68,W
06DFE:  MULLW  0E
06E00:  MOVF   FF3,W
06E02:  CLRF   03
06E04:  ADDLW  99
06E06:  MOVWF  01
06E08:  MOVLW  03
06E0A:  ADDWFC 03,F
06E0C:  MOVFF  01,577
06E10:  MOVFF  03,578
06E14:  MOVLW  01
06E16:  SUBWF  x68,W
06E18:  MULLW  0E
06E1A:  MOVF   FF3,W
06E1C:  CLRF   03
06E1E:  ADDLW  99
06E20:  MOVWF  01
06E22:  MOVLW  03
06E24:  ADDWFC 03,F
06E26:  MOVFF  01,579
06E2A:  MOVFF  03,57A
06E2E:  MOVFF  578,FEA
06E32:  MOVFF  577,FE9
06E36:  MOVFF  03,FE2
06E3A:  MOVFF  01,FE1
06E3E:  MOVLW  02
06E40:  MOVWF  01
06E42:  MOVFF  FE6,FEE
06E46:  DECFSZ 01,F
06E48:  BRA    6E42
....................          memcpy(&global_sprinkler_queue[n-1], &temp_sprinkler_queue_item, sizeof(&global_sprinkler_queue[n-1])); 
06E4A:  MOVLW  01
06E4C:  SUBWF  x68,W
06E4E:  MULLW  0E
06E50:  MOVF   FF3,W
06E52:  CLRF   03
06E54:  ADDLW  99
06E56:  MOVWF  01
06E58:  MOVLW  03
06E5A:  ADDWFC 03,F
06E5C:  MOVFF  03,FEA
06E60:  MOVFF  01,FE9
06E64:  MOVFF  569,FEE
06E68:  MOVFF  56A,FEE
....................           
....................       } 
06E6C:  BRA    6E76
....................       //item is in the proper place (assuming queue always sorted properly) 
....................       else 
....................       { 
....................          enable_interrupts(INT_CCP4); 
06E6E:  BSF    F7A.1
....................          return; 
06E70:  MOVLB  4
06E72:  BRA    6E7E
06E74:  MOVLB  5
....................       } 
06E76:  DECF   x68,F
06E78:  BRA    6D6A
....................    } 
....................    enable_interrupts(INT_CCP4); 
06E7A:  BSF    F7A.1
06E7C:  MOVLB  4
....................    return; 
06E7E:  MOVLB  0
06E80:  RETURN 0
.................... } 
....................  
.................... void pop_sprinkler_queue_ISR(void) 
.................... // Checks the sprinkler queue and sets the sprinkler settings of the item on the top of the queue 
.................... { 
....................    //no items in the queue (current location is 0-1) 
....................    if (global_current_sprinkler_queue_location == 255) 
*
02A74:  MOVLB  4
02A76:  INCFSZ x25,W
02A78:  BRA    2A7E
....................    { 
....................       return; 
02A7A:  BRA    2C78
....................    } 
02A7C:  BRA    2C78
....................    // pop top item off queue and onto actual settings 
....................    else 
....................    { 
....................       //erase the current command start time (only important thing) and decrement the current queue location 
....................       global_sprinkler_queue[global_current_sprinkler_queue_location].start_time = 0-1; 
02A7E:  MOVF   x25,W
02A80:  MULLW  0E
02A82:  MOVF   FF3,W
02A84:  MOVLB  5
02A86:  CLRF   x80
02A88:  MOVWF  x7F
02A8A:  MOVLW  99
02A8C:  ADDWF  x7F,W
02A8E:  MOVWF  FE9
02A90:  MOVLW  03
02A92:  ADDWFC x80,W
02A94:  MOVWF  FEA
02A96:  SETF   00
02A98:  SETF   01
02A9A:  SETF   02
02A9C:  SETF   03
02A9E:  MOVFF  00,FEF
02AA2:  MOVFF  01,FEC
02AA6:  MOVFF  02,FEC
02AAA:  MOVFF  03,FEC
....................       global_current_sprinkler_settings_end_time = global_sprinkler_queue[global_current_sprinkler_queue_location].end_time; 
02AAE:  MOVLB  4
02AB0:  MOVF   x25,W
02AB2:  MULLW  0E
02AB4:  MOVF   FF3,W
02AB6:  MOVLB  5
02AB8:  CLRF   x80
02ABA:  MOVWF  x7F
02ABC:  MOVLW  04
02ABE:  ADDWF  x7F,W
02AC0:  MOVWF  01
02AC2:  MOVLW  00
02AC4:  ADDWFC x80,W
02AC6:  MOVWF  03
02AC8:  MOVF   01,W
02ACA:  ADDLW  99
02ACC:  MOVWF  FE9
02ACE:  MOVLW  03
02AD0:  ADDWFC 03,W
02AD2:  MOVWF  FEA
02AD4:  MOVFF  FEF,426
02AD8:  MOVFF  FEC,427
02ADC:  MOVFF  FEC,428
02AE0:  MOVFF  FEC,429
....................       global_sprinkler_queue[global_current_sprinkler_queue_location].end_time = 0; 
02AE4:  MOVLB  4
02AE6:  MOVF   x25,W
02AE8:  MULLW  0E
02AEA:  MOVF   FF3,W
02AEC:  MOVLB  5
02AEE:  CLRF   x80
02AF0:  MOVWF  x7F
02AF2:  MOVLW  04
02AF4:  ADDWF  x7F,W
02AF6:  MOVWF  01
02AF8:  MOVLW  00
02AFA:  ADDWFC x80,W
02AFC:  MOVWF  03
02AFE:  MOVF   01,W
02B00:  ADDLW  99
02B02:  MOVWF  FE9
02B04:  MOVLW  03
02B06:  ADDWFC 03,W
02B08:  MOVWF  FEA
02B0A:  MOVF   FEE,F
02B0C:  MOVF   FEE,F
02B0E:  CLRF   FEC
02B10:  MOVF   FED,F
02B12:  CLRF   FEF
02B14:  MOVF   FED,F
02B16:  CLRF   FEF
02B18:  MOVF   FED,F
02B1A:  CLRF   FEF
....................       global_valve_position_set_value = global_sprinkler_queue[global_current_sprinkler_queue_location].vlv_open_amount; 
02B1C:  MOVLB  4
02B1E:  MOVF   x25,W
02B20:  MULLW  0E
02B22:  MOVF   FF3,W
02B24:  MOVLB  5
02B26:  CLRF   x80
02B28:  MOVWF  x7F
02B2A:  MOVLW  08
02B2C:  ADDWF  x7F,W
02B2E:  MOVWF  01
02B30:  MOVLW  00
02B32:  ADDWFC x80,W
02B34:  MOVWF  03
02B36:  MOVF   01,W
02B38:  ADDLW  99
02B3A:  MOVWF  FE9
02B3C:  MOVLW  03
02B3E:  ADDWFC 03,W
02B40:  MOVWF  FEA
02B42:  MOVFF  FEC,C0
02B46:  MOVF   FED,F
02B48:  MOVFF  FEF,BF
....................       global_sprinkler_queue[global_current_sprinkler_queue_location].vlv_open_amount = 0; 
02B4C:  MOVLB  4
02B4E:  MOVF   x25,W
02B50:  MULLW  0E
02B52:  MOVF   FF3,W
02B54:  MOVLB  5
02B56:  CLRF   x80
02B58:  MOVWF  x7F
02B5A:  MOVLW  08
02B5C:  ADDWF  x7F,W
02B5E:  MOVWF  01
02B60:  MOVLW  00
02B62:  ADDWFC x80,W
02B64:  MOVWF  03
02B66:  MOVF   01,W
02B68:  ADDLW  99
02B6A:  MOVWF  FE9
02B6C:  MOVLW  03
02B6E:  ADDWFC 03,W
02B70:  MOVWF  FEA
02B72:  CLRF   FEC
02B74:  MOVF   FED,F
02B76:  CLRF   FEF
....................       push_time_queue_ISR(global_rtc_time + 3, MOVE_VALVE); 
02B78:  MOVLW  03
02B7A:  MOVLB  0
02B7C:  ADDWF  x85,W
02B7E:  MOVLB  5
02B80:  MOVWF  x7F
02B82:  MOVLW  00
02B84:  MOVLB  0
02B86:  ADDWFC x86,W
02B88:  MOVLB  5
02B8A:  MOVWF  x80
02B8C:  MOVLW  00
02B8E:  MOVLB  0
02B90:  ADDWFC x87,W
02B92:  MOVLB  5
02B94:  MOVWF  x81
02B96:  MOVLW  00
02B98:  MOVLB  0
02B9A:  ADDWFC x88,W
02B9C:  MOVLB  5
02B9E:  MOVWF  x82
02BA0:  CLRF   19
02BA2:  BTFSC  FF2.7
02BA4:  BSF    19.7
02BA6:  BCF    FF2.7
02BA8:  MOVWF  xBA
02BAA:  MOVFF  581,5B9
02BAE:  MOVFF  580,5B8
02BB2:  MOVFF  57F,5B7
02BB6:  MOVLW  40
02BB8:  MOVWF  xBB
02BBA:  MOVLB  0
02BBC:  CALL   172E
02BC0:  BTFSC  19.7
02BC2:  BSF    FF2.7
....................       global_rpm_set_value = global_sprinkler_queue[global_current_sprinkler_queue_location].spin_rate; 
02BC4:  MOVLB  4
02BC6:  MOVF   x25,W
02BC8:  MULLW  0E
02BCA:  MOVF   FF3,W
02BCC:  MOVLB  5
02BCE:  CLRF   x80
02BD0:  MOVWF  x7F
02BD2:  MOVLW  0A
02BD4:  ADDWF  x7F,W
02BD6:  MOVWF  01
02BD8:  MOVLW  00
02BDA:  ADDWFC x80,W
02BDC:  MOVWF  03
02BDE:  MOVF   01,W
02BE0:  ADDLW  99
02BE2:  MOVWF  FE9
02BE4:  MOVLW  03
02BE6:  ADDWFC 03,W
02BE8:  MOVWF  FEA
02BEA:  MOVFF  FEC,A9
02BEE:  MOVF   FED,F
02BF0:  MOVFF  FEF,A8
....................       global_sprinkler_queue[global_current_sprinkler_queue_location].spin_rate = 0; 
02BF4:  MOVLB  4
02BF6:  MOVF   x25,W
02BF8:  MULLW  0E
02BFA:  MOVF   FF3,W
02BFC:  MOVLB  5
02BFE:  CLRF   x80
02C00:  MOVWF  x7F
02C02:  MOVLW  0A
02C04:  ADDWF  x7F,W
02C06:  MOVWF  01
02C08:  MOVLW  00
02C0A:  ADDWFC x80,W
02C0C:  MOVWF  03
02C0E:  MOVF   01,W
02C10:  ADDLW  99
02C12:  MOVWF  FE9
02C14:  MOVLW  03
02C16:  ADDWFC 03,W
02C18:  MOVWF  FEA
02C1A:  CLRF   FEC
02C1C:  MOVF   FED,F
02C1E:  CLRF   FEF
....................       //global_sprinkler_queue[global_current_sprinkler_queue_location].zone_num; 
....................       global_control_loop_mechanism = global_sprinkler_queue[global_current_sprinkler_queue_location].control_loop_mechanism; 
02C20:  MOVLB  4
02C22:  MOVF   x25,W
02C24:  MULLW  0E
02C26:  MOVF   FF3,W
02C28:  MOVLB  5
02C2A:  CLRF   x80
02C2C:  MOVWF  x7F
02C2E:  MOVLW  0D
02C30:  ADDWF  x7F,W
02C32:  MOVWF  01
02C34:  MOVLW  00
02C36:  ADDWFC x80,W
02C38:  MOVWF  03
02C3A:  MOVF   01,W
02C3C:  ADDLW  99
02C3E:  MOVWF  FE9
02C40:  MOVLW  03
02C42:  ADDWFC 03,W
02C44:  MOVWF  FEA
02C46:  MOVFF  FEF,BC
....................       global_sprinkler_queue[global_current_sprinkler_queue_location].control_loop_mechanism = NO_RPM_CONTROL_DYN_MPPC; 
02C4A:  MOVLB  4
02C4C:  MOVF   x25,W
02C4E:  MULLW  0E
02C50:  MOVF   FF3,W
02C52:  MOVLB  5
02C54:  CLRF   x80
02C56:  MOVWF  x7F
02C58:  MOVLW  0D
02C5A:  ADDWF  x7F,W
02C5C:  MOVWF  01
02C5E:  MOVLW  00
02C60:  ADDWFC x80,W
02C62:  MOVWF  03
02C64:  MOVF   01,W
02C66:  ADDLW  99
02C68:  MOVWF  FE9
02C6A:  MOVLW  03
02C6C:  ADDWFC 03,W
02C6E:  MOVWF  FEA
02C70:  MOVLW  06
02C72:  MOVWF  FEF
....................       global_current_sprinkler_queue_location--; 
02C74:  MOVLB  4
02C76:  DECF   x25,F
....................        
....................       return; 
....................    } 
02C78:  MOVLB  0
02C7A:  GOTO   2EB2 (RETURN)
.................... } 
....................  
.................... void clear_message_queue(void) 
.................... { 
....................    // disable conflicting interrupts 
....................    disable_interrupts(INT_CCP4);     
*
04034:  BCF    F7A.1
....................    memset(&global_message_queue, EMPTY_MESSAGE_QUEUE, sizeof(global_message_queue)); 
04036:  MOVLW  04
04038:  MOVWF  FEA
0403A:  MOVLW  A3
0403C:  MOVWF  FE9
0403E:  CLRF   00
04040:  CLRF   02
04042:  MOVLW  50
04044:  MOVWF  01
04046:  CALL   210E
....................    // disable conflicting interrupts 
....................    disable_interrupts(INT_CCP4); 
0404A:  BCF    F7A.1
0404C:  GOTO   A11A (RETURN)
.................... } 
....................  
.................... void pop_message_queue_and_send_ISR(void)  
.................... // Sends the top of the message queue out, re-adds it to the message stack with a 
.................... //    later send time (and attempt number) and sorts it properly.  Since this is 
.................... //    only called out of CCP4, all functions are ISR functions 
.................... {                       
....................     
....................    uint8_t n;                                                    
....................    struct MessageQueueItem temp_message_queue_item;        
....................  
....................    // no items in the queue (current location is 0-1) 
....................    if (global_current_message_queue_location == 255) 
*
02702:  MOVLB  4
02704:  INCFSZ xF3,W
02706:  BRA    270C
....................    { 
....................       return;   
02708:  BRA    2A6E
....................    } 
0270A:  BRA    2A6E
....................    else 
....................    {              
....................       // If it has met or exceeded the maximum number of attempts, delete it off the queue, 
....................       //    set an error bit, and queue an error message. Attempt num is counted from 0 
....................       if (global_message_queue[global_current_message_queue_location].attempt_num >= (MAX_UNSOLICITED_MESSAGE_ATTEMPTS)) 
0270C:  MOVF   xF3,W
0270E:  MULLW  08
02710:  MOVF   FF3,W
02712:  MOVLB  5
02714:  CLRF   x89
02716:  MOVWF  x88
02718:  MOVLW  07
0271A:  ADDWF  x88,W
0271C:  MOVWF  01
0271E:  MOVLW  00
02720:  ADDWFC x89,W
02722:  MOVWF  03
02724:  MOVF   01,W
02726:  ADDLW  A3
02728:  MOVWF  FE9
0272A:  MOVLW  04
0272C:  ADDWFC 03,W
0272E:  MOVWF  FEA
02730:  MOVF   FEF,W
02732:  SUBLW  02
02734:  BC    2756
....................       { 
....................          remove_message_queue_item_ISR(mote_msgSEQ); 
02736:  MOVFF  362,589
0273A:  MOVFF  361,588
0273E:  MOVLB  0
02740:  BRA    2128
....................          // set an error bit saying a message was missed 
....................          global_error_message_bitfield |= ERR_MSG_UNSOLICITED_MESSAGE_NOT_ACKD; 
02742:  MOVLB  4
02744:  BSF    xF4.0
....................          push_message_queue_ISR(MSG_MOTE_ERROR_MSG); 
02746:  MOVLW  A0
02748:  MOVLB  5
0274A:  MOVWF  x9B
0274C:  MOVLB  0
0274E:  CALL   0BF8
....................       } 
02752:  BRA    2A6C
02754:  MOVLB  5
....................       // regular message (not @ max attempts)    
....................       else 
....................       {                
....................          // what message type?  
....................          // resend with unsolicited (0x00 identifier) and it's current message seq 
....................          switch(global_message_queue[global_current_message_queue_location].message_type) 
02756:  MOVLB  4
02758:  MOVF   xF3,W
0275A:  MULLW  08
0275C:  MOVF   FF3,W
0275E:  MOVLB  5
02760:  CLRF   x89
02762:  MOVWF  x88
02764:  MOVLW  04
02766:  ADDWF  x88,W
02768:  MOVWF  01
0276A:  MOVLW  00
0276C:  ADDWFC x89,W
0276E:  MOVWF  03
02770:  MOVF   01,W
02772:  ADDLW  A3
02774:  MOVWF  FE9
02776:  MOVLW  04
02778:  ADDWFC 03,W
0277A:  MOVWF  FEA
0277C:  MOVF   FEF,W
0277E:  XORLW  91
02780:  MOVLB  0
02782:  BZ    279E
02784:  XORLW  03
02786:  BZ    27D6
02788:  XORLW  06
0278A:  BZ    280E
0278C:  XORLW  02
0278E:  BZ    2846
02790:  XORLW  0E
02792:  BTFSC  FD8.2
02794:  BRA    287E
02796:  XORLW  38
02798:  BTFSC  FD8.2
0279A:  BRA    28B6
0279C:  BRA    28EC
....................          { 
....................             case MSG_MOTE_HEALTH_REPORT: 
....................                send_health_report_ISR(MSG_MOTE_UNSOLICITED, global_message_queue[global_current_message_queue_location].msg_seq); 
0279E:  MOVLB  4
027A0:  MOVF   xF3,W
027A2:  MULLW  08
027A4:  MOVF   FF3,W
027A6:  MOVLB  5
027A8:  CLRF   x89
027AA:  MOVWF  x88
027AC:  MOVLW  05
027AE:  ADDWF  x88,W
027B0:  MOVWF  01
027B2:  MOVLW  00
027B4:  ADDWFC x89,W
027B6:  MOVWF  03
027B8:  MOVF   01,W
027BA:  ADDLW  A3
027BC:  MOVWF  FE9
027BE:  MOVLW  04
027C0:  ADDWFC 03,W
027C2:  MOVWF  FEA
027C4:  MOVFF  FEC,58C
027C8:  MOVF   FED,F
027CA:  MOVFF  FEF,58B
027CE:  CLRF   x8A
027D0:  MOVLB  0
027D2:  BRA    2344
....................                break;                                                                           
027D4:  BRA    28EC
....................             case MSG_MOTE_VALVE_REPORT:    
....................                send_valve_report_ISR(MSG_MOTE_UNSOLICITED,global_message_queue[global_current_message_queue_location].msg_seq); 
027D6:  MOVLB  4
027D8:  MOVF   xF3,W
027DA:  MULLW  08
027DC:  MOVF   FF3,W
027DE:  MOVLB  5
027E0:  CLRF   x89
027E2:  MOVWF  x88
027E4:  MOVLW  05
027E6:  ADDWF  x88,W
027E8:  MOVWF  01
027EA:  MOVLW  00
027EC:  ADDWFC x89,W
027EE:  MOVWF  03
027F0:  MOVF   01,W
027F2:  ADDLW  A3
027F4:  MOVWF  FE9
027F6:  MOVLW  04
027F8:  ADDWFC 03,W
027FA:  MOVWF  FEA
027FC:  MOVFF  FEC,58C
02800:  MOVF   FED,F
02802:  MOVFF  FEF,58B
02806:  CLRF   x8A
02808:  MOVLB  0
0280A:  BRA    24BE
....................                break; 
0280C:  BRA    28EC
....................             case MSG_MOTE_JOIN_MSG: 
....................                send_join_msg_ISR(MSG_MOTE_UNSOLICITED,global_message_queue[global_current_message_queue_location].msg_seq); 
0280E:  MOVLB  4
02810:  MOVF   xF3,W
02812:  MULLW  08
02814:  MOVF   FF3,W
02816:  MOVLB  5
02818:  CLRF   x89
0281A:  MOVWF  x88
0281C:  MOVLW  05
0281E:  ADDWF  x88,W
02820:  MOVWF  01
02822:  MOVLW  00
02824:  ADDWFC x89,W
02826:  MOVWF  03
02828:  MOVF   01,W
0282A:  ADDLW  A3
0282C:  MOVWF  FE9
0282E:  MOVLW  04
02830:  ADDWFC 03,W
02832:  MOVWF  FEA
02834:  MOVFF  FEC,58C
02838:  MOVF   FED,F
0283A:  MOVFF  FEF,58B
0283E:  CLRF   x8A
02840:  MOVLB  0
02842:  BRA    25F0
....................                break; 
02844:  BRA    28EC
....................             case MSG_MOTE_GPS_POINT_MSG: 
....................                send_gps_point_msg_ISR(MSG_MOTE_UNSOLICITED,global_message_queue[global_current_message_queue_location].msg_seq); 
02846:  MOVLB  4
02848:  MOVF   xF3,W
0284A:  MULLW  08
0284C:  MOVF   FF3,W
0284E:  MOVLB  5
02850:  CLRF   x89
02852:  MOVWF  x88
02854:  MOVLW  05
02856:  ADDWF  x88,W
02858:  MOVWF  01
0285A:  MOVLW  00
0285C:  ADDWFC x89,W
0285E:  MOVWF  03
02860:  MOVF   01,W
02862:  ADDLW  A3
02864:  MOVWF  FE9
02866:  MOVLW  04
02868:  ADDWFC 03,W
0286A:  MOVWF  FEA
0286C:  MOVFF  FEC,58C
02870:  MOVF   FED,F
02872:  MOVFF  FEF,58B
02876:  CLRF   x8A
02878:  MOVLB  0
0287A:  BRA    264C
....................                break;                                         
0287C:  BRA    28EC
....................             case MSG_MOTE_XDCR_READ_MSG:                                                    
....................                send_pressure_xdcr_msg_ISR(MSG_MOTE_UNSOLICITED,global_message_queue[global_current_message_queue_location].msg_seq); 
0287E:  MOVLB  4
02880:  MOVF   xF3,W
02882:  MULLW  08
02884:  MOVF   FF3,W
02886:  MOVLB  5
02888:  CLRF   x89
0288A:  MOVWF  x88
0288C:  MOVLW  05
0288E:  ADDWF  x88,W
02890:  MOVWF  01
02892:  MOVLW  00
02894:  ADDWFC x89,W
02896:  MOVWF  03
02898:  MOVF   01,W
0289A:  ADDLW  A3
0289C:  MOVWF  FE9
0289E:  MOVLW  04
028A0:  ADDWFC 03,W
028A2:  MOVWF  FEA
028A4:  MOVFF  FEC,58C
028A8:  MOVF   FED,F
028AA:  MOVFF  FEF,58B
028AE:  CLRF   x8A
028B0:  MOVLB  0
028B2:  BRA    267E
....................                break; 
028B4:  BRA    28EC
....................             case MSG_MOTE_ERROR_MSG:       
....................                send_error_msg_ISR(MSG_MOTE_UNSOLICITED,global_message_queue[global_current_message_queue_location].msg_seq); 
028B6:  MOVLB  4
028B8:  MOVF   xF3,W
028BA:  MULLW  08
028BC:  MOVF   FF3,W
028BE:  MOVLB  5
028C0:  CLRF   x89
028C2:  MOVWF  x88
028C4:  MOVLW  05
028C6:  ADDWF  x88,W
028C8:  MOVWF  01
028CA:  MOVLW  00
028CC:  ADDWFC x89,W
028CE:  MOVWF  03
028D0:  MOVF   01,W
028D2:  ADDLW  A3
028D4:  MOVWF  FE9
028D6:  MOVLW  04
028D8:  ADDWFC 03,W
028DA:  MOVWF  FEA
028DC:  MOVFF  FEC,58C
028E0:  MOVF   FED,F
028E2:  MOVFF  FEF,58B
028E6:  CLRF   x8A
028E8:  MOVLB  0
028EA:  BRA    26B8
....................                break; 
....................          } 
....................          // increment attempt number and reschedule it to send at a later time (if not ack'd) 
....................          global_message_queue[global_current_message_queue_location].attempt_num++; 
028EC:  MOVLB  4
028EE:  MOVF   xF3,W
028F0:  MULLW  08
028F2:  MOVF   FF3,W
028F4:  MOVLB  5
028F6:  CLRF   x89
028F8:  MOVWF  x88
028FA:  MOVLW  07
028FC:  ADDWF  x88,W
028FE:  MOVWF  01
02900:  MOVLW  00
02902:  ADDWFC x89,W
02904:  MOVWF  03
02906:  MOVF   01,W
02908:  ADDLW  A3
0290A:  MOVWF  FE9
0290C:  MOVLW  04
0290E:  ADDWFC 03,W
02910:  MOVWF  FEA
02912:  INCF   FEF,F
....................          global_message_queue[global_current_message_queue_location].time_to_send+=MESSAGE_RESEND_WAIT_PERIOD; 
02914:  MOVLB  4
02916:  MOVF   xF3,W
02918:  MULLW  08
0291A:  MOVF   FF3,W
0291C:  MOVLB  5
0291E:  CLRF   x89
02920:  MOVWF  x88
02922:  MOVLW  A3
02924:  ADDWF  x88,W
02926:  MOVWF  FE9
02928:  MOVLW  04
0292A:  ADDWFC x89,W
0292C:  MOVWF  FEA
0292E:  MOVLW  3C
02930:  ADDWF  FEF,W
02932:  MOVWF  00
02934:  MOVLW  00
02936:  ADDWFC FEC,W
02938:  MOVWF  01
0293A:  MOVLW  00
0293C:  ADDWFC FEC,W
0293E:  MOVWF  02
02940:  MOVLW  00
02942:  ADDWFC FEC,W
02944:  MOVF   FED,F
02946:  MOVF   FED,F
02948:  MOVF   FED,F
0294A:  MOVFF  00,FEF
0294E:  MOVFF  01,FEC
02952:  MOVFF  02,FEC
02956:  MOVWF  FEC
....................           
....................          // starting at the current queue location, sort through the queue 
....................          //    until the item is in the right place 
....................          for (n = global_current_message_queue_location; n > 0; n--)                  
02958:  MOVFF  4F3,57F
0295C:  MOVF   x7F,F
0295E:  BTFSC  FD8.2
02960:  BRA    2A6A
....................          { 
....................             //if queue items are not sorted properly 
....................             if (global_message_queue[n].time_to_send > global_message_queue[n-1].time_to_send) 
02962:  MOVF   x7F,W
02964:  MULLW  08
02966:  MOVF   FF3,W
02968:  CLRF   x89
0296A:  MOVWF  x88
0296C:  MOVLW  A3
0296E:  ADDWF  x88,W
02970:  MOVWF  FE9
02972:  MOVLW  04
02974:  ADDWFC x89,W
02976:  MOVWF  FEA
02978:  MOVFF  FEF,58A
0297C:  MOVFF  FEC,58B
02980:  MOVFF  FEC,58C
02984:  MOVFF  FEC,58D
02988:  MOVLW  01
0298A:  SUBWF  x7F,W
0298C:  MULLW  08
0298E:  MOVF   FF3,W
02990:  CLRF   x8F
02992:  MOVWF  x8E
02994:  MOVLW  A3
02996:  ADDWF  x8E,W
02998:  MOVWF  FE9
0299A:  MOVLW  04
0299C:  ADDWFC x8F,W
0299E:  MOVWF  FEA
029A0:  MOVFF  FEF,00
029A4:  MOVFF  FEC,01
029A8:  MOVFF  FEC,02
029AC:  MOVFF  FEC,03
029B0:  MOVF   03,W
029B2:  SUBWF  x8D,W
029B4:  BNC   2A60
029B6:  BNZ   29CE
029B8:  MOVF   02,W
029BA:  SUBWF  x8C,W
029BC:  BNC   2A60
029BE:  BNZ   29CE
029C0:  MOVF   01,W
029C2:  SUBWF  x8B,W
029C4:  BNC   2A60
029C6:  BNZ   29CE
029C8:  MOVF   x8A,W
029CA:  SUBWF  00,W
029CC:  BC    2A60
....................             { 
....................                //do a swap 
....................                memcpy(&temp_message_queue_item, &global_message_queue[n], sizeof(&temp_message_queue_item)); 
029CE:  MOVF   x7F,W
029D0:  MULLW  08
029D2:  MOVF   FF3,W
029D4:  CLRF   03
029D6:  ADDLW  A3
029D8:  MOVWF  01
029DA:  MOVLW  04
029DC:  ADDWFC 03,F
029DE:  MOVFF  03,FE2
029E2:  MOVFF  01,FE1
029E6:  MOVFF  FE6,580
029EA:  MOVFF  FE6,581
....................                memcpy(&global_message_queue[n], &global_message_queue[n-1], sizeof(&global_message_queue[n])); 
029EE:  MOVF   x7F,W
029F0:  MULLW  08
029F2:  MOVF   FF3,W
029F4:  CLRF   03
029F6:  ADDLW  A3
029F8:  MOVWF  01
029FA:  MOVLW  04
029FC:  ADDWFC 03,F
029FE:  MOVFF  01,588
02A02:  MOVFF  03,589
02A06:  MOVLW  01
02A08:  SUBWF  x7F,W
02A0A:  MULLW  08
02A0C:  MOVF   FF3,W
02A0E:  CLRF   03
02A10:  ADDLW  A3
02A12:  MOVWF  01
02A14:  MOVLW  04
02A16:  ADDWFC 03,F
02A18:  MOVFF  01,58A
02A1C:  MOVFF  03,58B
02A20:  MOVFF  589,FEA
02A24:  MOVFF  588,FE9
02A28:  MOVFF  03,FE2
02A2C:  MOVFF  01,FE1
02A30:  MOVLW  02
02A32:  MOVWF  01
02A34:  MOVFF  FE6,FEE
02A38:  DECFSZ 01,F
02A3A:  BRA    2A34
....................                memcpy(&global_message_queue[n-1], &temp_message_queue_item, sizeof(&global_message_queue[n-1])); 
02A3C:  MOVLW  01
02A3E:  SUBWF  x7F,W
02A40:  MULLW  08
02A42:  MOVF   FF3,W
02A44:  CLRF   03
02A46:  ADDLW  A3
02A48:  MOVWF  01
02A4A:  MOVLW  04
02A4C:  ADDWFC 03,F
02A4E:  MOVFF  03,FEA
02A52:  MOVFF  01,FE9
02A56:  MOVFF  580,FEE
02A5A:  MOVFF  581,FEE
....................             } 
02A5E:  BRA    2A66
....................             //item is in the proper place (assuming queue always sorted properly) 
....................             else 
....................             { 
....................                return; 
02A60:  MOVLB  4
02A62:  BRA    2A6E
02A64:  MOVLB  5
....................             } 
02A66:  DECF   x7F,F
02A68:  BRA    295C
02A6A:  MOVLB  0
02A6C:  MOVLB  4
....................          } 
....................       } 
....................    } 
02A6E:  MOVLB  0
02A70:  GOTO   2DCC (RETURN)
.................... } 
....................                                        
.................... void push_message_queue(uint8_t message_type) 
.................... // pushes a new item (attempt 0) into the message queue and sorts it. 
.................... // returns 1 if everything is good, 0 if queue is full 
.................... {                 
....................    uint8_t n; 
....................    struct MessageQueueItem temp_message_queue_item;                             
....................     
....................    //if queue is full, return 0                                                      
....................    if (global_current_message_queue_location == (MAX_MESSAGE_QUEUE_ITEMS - 1)) 
*
04FE0:  MOVLB  4
04FE2:  MOVF   xF3,W
04FE4:  SUBLW  09
04FE6:  BNZ   4FEA
....................    {                                             
....................       return;    
04FE8:  BRA    52F4
....................    } 
....................                  
....................                                                                                                  
....................    // if you're trying to add an error message...                    
....................    if (message_type == MSG_MOTE_ERROR_MSG) 
04FEA:  MOVLB  5
04FEC:  MOVF   x50,W
04FEE:  SUBLW  A0
04FF0:  BTFSS  FD8.2
04FF2:  BRA    5128
....................    { 
....................       // check to see if it is the same as the last error message added and if it has happened too recently to resend 
....................       if ((global_error_message_bitfield == last_error_message_sent_bitfield) && ((global_rtc_time - last_error_message_sent_rtc_time) < ERR_MESSAGE_WAIT_PERIOD)) 
04FF4:  MOVLB  4
04FF6:  MOVF   xF8,W
04FF8:  SUBWF  xF4,W
04FFA:  BNZ   506C
04FFC:  MOVF   xF9,W
04FFE:  SUBWF  xF5,W
05000:  BNZ   506C
05002:  MOVF   xFA,W
05004:  SUBWF  xF6,W
05006:  BNZ   506C
05008:  MOVF   xFB,W
0500A:  SUBWF  xF7,W
0500C:  BNZ   506C
0500E:  MOVF   xFC,W
05010:  MOVLB  0
05012:  SUBWF  x85,W
05014:  MOVLB  5
05016:  MOVWF  x5A
05018:  MOVLB  4
0501A:  MOVF   xFD,W
0501C:  MOVLB  0
0501E:  SUBWFB x86,W
05020:  MOVLB  5
05022:  MOVWF  x5B
05024:  MOVLB  4
05026:  MOVF   xFE,W
05028:  MOVLB  0
0502A:  SUBWFB x87,W
0502C:  MOVLB  5
0502E:  MOVWF  x5C
05030:  MOVLB  4
05032:  MOVF   xFF,W
05034:  MOVLB  0
05036:  SUBWFB x88,W
05038:  MOVLB  5
0503A:  MOVWF  x5D
0503C:  MOVF   x5D,F
0503E:  BTFSC  FD8.2
05040:  BRA    5046
05042:  MOVLB  4
05044:  BRA    506C
05046:  MOVF   x5C,F
05048:  BTFSC  FD8.2
0504A:  BRA    5050
0504C:  MOVLB  4
0504E:  BRA    506C
05050:  MOVF   x5B,F
05052:  BTFSC  FD8.2
05054:  BRA    505A
05056:  MOVLB  4
05058:  BRA    506C
0505A:  MOVF   x5A,W
0505C:  SUBLW  3B
0505E:  BTFSC  FD8.0
05060:  BRA    5066
05062:  MOVLB  4
05064:  BRA    506C
....................       {         
....................          return; 
05066:  MOVLB  4
05068:  BRA    52F4
....................       } 
0506A:  BRA    508C
....................       else 
....................       { 
....................          // save the error message bitfield and send time for future comparing and rejecting of duplicate messages 
....................          last_error_message_sent_bitfield = global_error_message_bitfield; 
0506C:  MOVFF  4F7,4FB
05070:  MOVFF  4F6,4FA
05074:  MOVFF  4F5,4F9
05078:  MOVFF  4F4,4F8
....................          last_error_message_sent_rtc_time = global_rtc_time; 
0507C:  MOVFF  88,4FF
05080:  MOVFF  87,4FE
05084:  MOVFF  86,4FD
05088:  MOVFF  85,4FC
....................       }                              
....................       // look through the current queue 
....................       for (n = global_current_message_queue_location; ((n > 0) && (n != 255)); n--) 
0508C:  MOVFF  4F3,551
05090:  MOVLB  5
05092:  MOVF   x51,F
05094:  BZ    5128
05096:  INCFSZ x51,W
05098:  BRA    509C
0509A:  BRA    5128
....................       { 
....................          // if there is already another error message on the queue, replace it 
....................          if (global_message_queue[n].message_type == MSG_MOTE_ERROR_MSG) 
0509C:  MOVF   x51,W
0509E:  MULLW  08
050A0:  MOVF   FF3,W
050A2:  CLRF   x5B
050A4:  MOVWF  x5A
050A6:  MOVLW  04
050A8:  ADDWF  x5A,W
050AA:  MOVWF  01
050AC:  MOVLW  00
050AE:  ADDWFC x5B,W
050B0:  MOVWF  03
050B2:  MOVF   01,W
050B4:  ADDLW  A3
050B6:  MOVWF  FE9
050B8:  MOVLW  04
050BA:  ADDWFC 03,W
050BC:  MOVWF  FEA
050BE:  MOVF   FEF,W
050C0:  SUBLW  A0
050C2:  BNZ   5124
....................          { 
....................             // increase the mote sequence number (new message) 
....................             // the ack from the previous one will basically get ignored 
....................             global_message_queue[n].msg_seq = ++mote_msgSEQ; 
050C4:  MOVF   x51,W
050C6:  MULLW  08
050C8:  MOVF   FF3,W
050CA:  CLRF   x5B
050CC:  MOVWF  x5A
050CE:  MOVLW  05
050D0:  ADDWF  x5A,W
050D2:  MOVWF  01
050D4:  MOVLW  00
050D6:  ADDWFC x5B,W
050D8:  MOVWF  03
050DA:  MOVF   01,W
050DC:  ADDLW  A3
050DE:  MOVWF  FE9
050E0:  MOVLW  04
050E2:  ADDWFC 03,W
050E4:  MOVWF  FEA
050E6:  MOVLB  3
050E8:  INCF   x61,F
050EA:  BTFSC  FD8.2
050EC:  INCF   x62,F
050EE:  MOVFF  362,FEC
050F2:  MOVF   FED,F
050F4:  MOVFF  361,FEF
....................             // reset the attempts to 0 (new message) 
....................             global_message_queue[n].attempt_num = 0;      
050F8:  MOVLB  5
050FA:  MOVF   x51,W
050FC:  MULLW  08
050FE:  MOVF   FF3,W
05100:  CLRF   x5B
05102:  MOVWF  x5A
05104:  MOVLW  07
05106:  ADDWF  x5A,W
05108:  MOVWF  01
0510A:  MOVLW  00
0510C:  ADDWFC x5B,W
0510E:  MOVWF  03
05110:  MOVF   01,W
05112:  ADDLW  A3
05114:  MOVWF  FE9
05116:  MOVLW  04
05118:  ADDWFC 03,W
0511A:  MOVWF  FEA
0511C:  CLRF   FEF
....................             return; 
0511E:  MOVLB  4
05120:  BRA    52F4
05122:  MOVLB  5
....................          } 
05124:  DECF   x51,F
05126:  BRA    5092
....................       } 
....................    } 
....................       
....................    // increment the queue location and mote message sequence (always first attempt 
....................    //    at a message in this routine 
....................    global_current_message_queue_location++; 
05128:  MOVLB  4
0512A:  INCF   xF3,F
....................    mote_msgSEQ++; 
0512C:  MOVLB  3
0512E:  INCF   x61,F
05130:  BTFSC  FD8.2
05132:  INCF   x62,F
....................     
....................    //set the new item at the top of the queue (will be sorted in a sec) 
....................    global_message_queue[global_current_message_queue_location].time_to_send = global_rtc_time; 
05134:  MOVLB  4
05136:  MOVF   xF3,W
05138:  MULLW  08
0513A:  MOVF   FF3,W
0513C:  MOVLB  5
0513E:  CLRF   x5B
05140:  MOVWF  x5A
05142:  MOVLW  A3
05144:  ADDWF  x5A,W
05146:  MOVWF  FE9
05148:  MOVLW  04
0514A:  ADDWFC x5B,W
0514C:  MOVWF  FEA
0514E:  MOVFF  85,FEF
05152:  MOVFF  86,FEC
05156:  MOVFF  87,FEC
0515A:  MOVFF  88,FEC
....................    global_message_queue[global_current_message_queue_location].message_type = message_type; 
0515E:  MOVLB  4
05160:  MOVF   xF3,W
05162:  MULLW  08
05164:  MOVF   FF3,W
05166:  MOVLB  5
05168:  CLRF   x5B
0516A:  MOVWF  x5A
0516C:  MOVLW  04
0516E:  ADDWF  x5A,W
05170:  MOVWF  01
05172:  MOVLW  00
05174:  ADDWFC x5B,W
05176:  MOVWF  03
05178:  MOVF   01,W
0517A:  ADDLW  A3
0517C:  MOVWF  FE9
0517E:  MOVLW  04
05180:  ADDWFC 03,W
05182:  MOVWF  FEA
05184:  MOVFF  550,FEF
....................    global_message_queue[global_current_message_queue_location].msg_seq = mote_msgSEQ; 
05188:  MOVLB  4
0518A:  MOVF   xF3,W
0518C:  MULLW  08
0518E:  MOVF   FF3,W
05190:  MOVLB  5
05192:  CLRF   x5B
05194:  MOVWF  x5A
05196:  MOVLW  05
05198:  ADDWF  x5A,W
0519A:  MOVWF  01
0519C:  MOVLW  00
0519E:  ADDWFC x5B,W
051A0:  MOVWF  03
051A2:  MOVF   01,W
051A4:  ADDLW  A3
051A6:  MOVWF  FE9
051A8:  MOVLW  04
051AA:  ADDWFC 03,W
051AC:  MOVWF  FEA
051AE:  MOVFF  362,FEC
051B2:  MOVF   FED,F
051B4:  MOVFF  361,FEF
....................    global_message_queue[global_current_message_queue_location].attempt_num = 0;    
051B8:  MOVLB  4
051BA:  MOVF   xF3,W
051BC:  MULLW  08
051BE:  MOVF   FF3,W
051C0:  MOVLB  5
051C2:  CLRF   x5B
051C4:  MOVWF  x5A
051C6:  MOVLW  07
051C8:  ADDWF  x5A,W
051CA:  MOVWF  01
051CC:  MOVLW  00
051CE:  ADDWFC x5B,W
051D0:  MOVWF  03
051D2:  MOVF   01,W
051D4:  ADDLW  A3
051D6:  MOVWF  FE9
051D8:  MOVLW  04
051DA:  ADDWFC 03,W
051DC:  MOVWF  FEA
051DE:  CLRF   FEF
....................           
....................    //starting at the new current queue location, sort through the queue 
....................    //until the new item is in the right place 
....................    for (n = global_current_message_queue_location; n > 0; n--)                    
051E0:  MOVFF  4F3,551
051E4:  MOVF   x51,F
051E6:  BTFSC  FD8.2
051E8:  BRA    52F2
....................    {                                                
....................       //if queue items are not sorted properly 
....................       if (global_message_queue[n].time_to_send > global_message_queue[n-1].time_to_send) 
051EA:  MOVF   x51,W
051EC:  MULLW  08
051EE:  MOVF   FF3,W
051F0:  CLRF   x5B
051F2:  MOVWF  x5A
051F4:  MOVLW  A3
051F6:  ADDWF  x5A,W
051F8:  MOVWF  FE9
051FA:  MOVLW  04
051FC:  ADDWFC x5B,W
051FE:  MOVWF  FEA
05200:  MOVFF  FEF,55C
05204:  MOVFF  FEC,55D
05208:  MOVFF  FEC,55E
0520C:  MOVFF  FEC,55F
05210:  MOVLW  01
05212:  SUBWF  x51,W
05214:  MULLW  08
05216:  MOVF   FF3,W
05218:  CLRF   x61
0521A:  MOVWF  x60
0521C:  MOVLW  A3
0521E:  ADDWF  x60,W
05220:  MOVWF  FE9
05222:  MOVLW  04
05224:  ADDWFC x61,W
05226:  MOVWF  FEA
05228:  MOVFF  FEF,00
0522C:  MOVFF  FEC,01
05230:  MOVFF  FEC,02
05234:  MOVFF  FEC,03
05238:  MOVF   03,W
0523A:  SUBWF  x5F,W
0523C:  BNC   52E8
0523E:  BNZ   5256
05240:  MOVF   02,W
05242:  SUBWF  x5E,W
05244:  BNC   52E8
05246:  BNZ   5256
05248:  MOVF   01,W
0524A:  SUBWF  x5D,W
0524C:  BNC   52E8
0524E:  BNZ   5256
05250:  MOVF   x5C,W
05252:  SUBWF  00,W
05254:  BC    52E8
....................       { 
....................          //do a swap 
....................          memcpy(&temp_message_queue_item, &global_message_queue[n], sizeof(&temp_message_queue_item)); 
05256:  MOVF   x51,W
05258:  MULLW  08
0525A:  MOVF   FF3,W
0525C:  CLRF   03
0525E:  ADDLW  A3
05260:  MOVWF  01
05262:  MOVLW  04
05264:  ADDWFC 03,F
05266:  MOVFF  03,FE2
0526A:  MOVFF  01,FE1
0526E:  MOVFF  FE6,552
05272:  MOVFF  FE6,553
....................          memcpy(&global_message_queue[n], &global_message_queue[n-1], sizeof(&global_message_queue[n])); 
05276:  MOVF   x51,W
05278:  MULLW  08
0527A:  MOVF   FF3,W
0527C:  CLRF   03
0527E:  ADDLW  A3
05280:  MOVWF  01
05282:  MOVLW  04
05284:  ADDWFC 03,F
05286:  MOVFF  01,55A
0528A:  MOVFF  03,55B
0528E:  MOVLW  01
05290:  SUBWF  x51,W
05292:  MULLW  08
05294:  MOVF   FF3,W
05296:  CLRF   03
05298:  ADDLW  A3
0529A:  MOVWF  01
0529C:  MOVLW  04
0529E:  ADDWFC 03,F
052A0:  MOVFF  01,55C
052A4:  MOVFF  03,55D
052A8:  MOVFF  55B,FEA
052AC:  MOVFF  55A,FE9
052B0:  MOVFF  03,FE2
052B4:  MOVFF  01,FE1
052B8:  MOVLW  02
052BA:  MOVWF  01
052BC:  MOVFF  FE6,FEE
052C0:  DECFSZ 01,F
052C2:  BRA    52BC
....................          memcpy(&global_message_queue[n-1], &temp_message_queue_item, sizeof(&global_message_queue[n-1])); 
052C4:  MOVLW  01
052C6:  SUBWF  x51,W
052C8:  MULLW  08
052CA:  MOVF   FF3,W
052CC:  CLRF   03
052CE:  ADDLW  A3
052D0:  MOVWF  01
052D2:  MOVLW  04
052D4:  ADDWFC 03,F
052D6:  MOVFF  03,FEA
052DA:  MOVFF  01,FE9
052DE:  MOVFF  552,FEE
052E2:  MOVFF  553,FEE
....................       } 
052E6:  BRA    52EE
....................       //item is in the proper place (assuming queue always sorted properly) 
....................       else    
....................       {    
....................          return; 
052E8:  MOVLB  4
052EA:  BRA    52F4
052EC:  MOVLB  5
....................       } 
052EE:  DECF   x51,F
052F0:  BRA    51E4
052F2:  MOVLB  4
....................    }     
....................    return; 
052F4:  MOVLB  0
052F6:  RETURN 0
.................... }                        
....................  
.................... void push_message_queue_ISR(uint8_t message_type) 
.................... // pushes a new item (attempt 0) into the message queue and sorts it. 
.................... // returns 1 if everything is good, 0 if queue is full 
.................... // message queue ISR only gets called in the pop message queue ISR so it's only resends of messages 
.................... //    (don't have to worry about error messages getting screwed up because of duplicate rejection logic) 
.................... { 
....................    uint8_t n; 
....................    struct MessageQueueItem temp_message_queue_item; 
....................    
....................    //if queue is full, return 0 
....................    if (global_current_message_queue_location == (MAX_MESSAGE_QUEUE_ITEMS - 1)) 
*
00BF8:  MOVLB  4
00BFA:  MOVF   xF3,W
00BFC:  SUBLW  09
00BFE:  BNZ   0C02
....................    { 
....................       return; 
00C00:  BRA    0E70
....................    } 
....................     
....................    // if you're trying to add an error message... 
....................    if (message_type == MSG_MOTE_ERROR_MSG) 
00C02:  MOVLB  5
00C04:  MOVF   x9B,W
00C06:  SUBLW  A0
00C08:  BNZ   0CA4
....................    { 
....................       // look through the current queue 
....................       for (n = global_current_message_queue_location; ((n > 0) && (n != 255)); n--) 
00C0A:  MOVFF  4F3,59C
00C0E:  MOVF   x9C,F
00C10:  BZ    0CA4
00C12:  INCFSZ x9C,W
00C14:  BRA    0C18
00C16:  BRA    0CA4
....................       { 
....................          // if there is already another error message on the queue, replace it 
....................          if (global_message_queue[n].message_type == MSG_MOTE_ERROR_MSG) 
00C18:  MOVF   x9C,W
00C1A:  MULLW  08
00C1C:  MOVF   FF3,W
00C1E:  CLRF   xA6
00C20:  MOVWF  xA5
00C22:  MOVLW  04
00C24:  ADDWF  xA5,W
00C26:  MOVWF  01
00C28:  MOVLW  00
00C2A:  ADDWFC xA6,W
00C2C:  MOVWF  03
00C2E:  MOVF   01,W
00C30:  ADDLW  A3
00C32:  MOVWF  FE9
00C34:  MOVLW  04
00C36:  ADDWFC 03,W
00C38:  MOVWF  FEA
00C3A:  MOVF   FEF,W
00C3C:  SUBLW  A0
00C3E:  BNZ   0CA0
....................          { 
....................             // increase the mote sequence number (new message) 
....................             // the ack from the previous one will basically get ignored 
....................             global_message_queue[n].msg_seq = ++mote_msgSEQ; 
00C40:  MOVF   x9C,W
00C42:  MULLW  08
00C44:  MOVF   FF3,W
00C46:  CLRF   xA6
00C48:  MOVWF  xA5
00C4A:  MOVLW  05
00C4C:  ADDWF  xA5,W
00C4E:  MOVWF  01
00C50:  MOVLW  00
00C52:  ADDWFC xA6,W
00C54:  MOVWF  03
00C56:  MOVF   01,W
00C58:  ADDLW  A3
00C5A:  MOVWF  FE9
00C5C:  MOVLW  04
00C5E:  ADDWFC 03,W
00C60:  MOVWF  FEA
00C62:  MOVLB  3
00C64:  INCF   x61,F
00C66:  BTFSC  FD8.2
00C68:  INCF   x62,F
00C6A:  MOVFF  362,FEC
00C6E:  MOVF   FED,F
00C70:  MOVFF  361,FEF
....................             // reset the attempts to 0 (new message) 
....................             global_message_queue[n].attempt_num = 0; 
00C74:  MOVLB  5
00C76:  MOVF   x9C,W
00C78:  MULLW  08
00C7A:  MOVF   FF3,W
00C7C:  CLRF   xA6
00C7E:  MOVWF  xA5
00C80:  MOVLW  07
00C82:  ADDWF  xA5,W
00C84:  MOVWF  01
00C86:  MOVLW  00
00C88:  ADDWFC xA6,W
00C8A:  MOVWF  03
00C8C:  MOVF   01,W
00C8E:  ADDLW  A3
00C90:  MOVWF  FE9
00C92:  MOVLW  04
00C94:  ADDWFC 03,W
00C96:  MOVWF  FEA
00C98:  CLRF   FEF
....................             return; 
00C9A:  MOVLB  4
00C9C:  BRA    0E70
00C9E:  MOVLB  5
....................          } 
00CA0:  DECF   x9C,F
00CA2:  BRA    0C0E
....................       } 
....................    } 
....................     
....................    // increment the queue location and mote message sequence (always first attempt 
....................    //    at a message in this routine 
....................    global_current_message_queue_location++; 
00CA4:  MOVLB  4
00CA6:  INCF   xF3,F
....................    mote_msgSEQ++; 
00CA8:  MOVLB  3
00CAA:  INCF   x61,F
00CAC:  BTFSC  FD8.2
00CAE:  INCF   x62,F
....................     
....................    //set the new item at the top of the queue (will be sorted in a sec) 
....................    global_message_queue[global_current_message_queue_location].time_to_send = global_rtc_time; 
00CB0:  MOVLB  4
00CB2:  MOVF   xF3,W
00CB4:  MULLW  08
00CB6:  MOVF   FF3,W
00CB8:  MOVLB  5
00CBA:  CLRF   xA6
00CBC:  MOVWF  xA5
00CBE:  MOVLW  A3
00CC0:  ADDWF  xA5,W
00CC2:  MOVWF  FE9
00CC4:  MOVLW  04
00CC6:  ADDWFC xA6,W
00CC8:  MOVWF  FEA
00CCA:  MOVFF  85,FEF
00CCE:  MOVFF  86,FEC
00CD2:  MOVFF  87,FEC
00CD6:  MOVFF  88,FEC
....................    global_message_queue[global_current_message_queue_location].message_type = message_type; 
00CDA:  MOVLB  4
00CDC:  MOVF   xF3,W
00CDE:  MULLW  08
00CE0:  MOVF   FF3,W
00CE2:  MOVLB  5
00CE4:  CLRF   xA6
00CE6:  MOVWF  xA5
00CE8:  MOVLW  04
00CEA:  ADDWF  xA5,W
00CEC:  MOVWF  01
00CEE:  MOVLW  00
00CF0:  ADDWFC xA6,W
00CF2:  MOVWF  03
00CF4:  MOVF   01,W
00CF6:  ADDLW  A3
00CF8:  MOVWF  FE9
00CFA:  MOVLW  04
00CFC:  ADDWFC 03,W
00CFE:  MOVWF  FEA
00D00:  MOVFF  59B,FEF
....................    global_message_queue[global_current_message_queue_location].msg_seq = mote_msgSEQ; 
00D04:  MOVLB  4
00D06:  MOVF   xF3,W
00D08:  MULLW  08
00D0A:  MOVF   FF3,W
00D0C:  MOVLB  5
00D0E:  CLRF   xA6
00D10:  MOVWF  xA5
00D12:  MOVLW  05
00D14:  ADDWF  xA5,W
00D16:  MOVWF  01
00D18:  MOVLW  00
00D1A:  ADDWFC xA6,W
00D1C:  MOVWF  03
00D1E:  MOVF   01,W
00D20:  ADDLW  A3
00D22:  MOVWF  FE9
00D24:  MOVLW  04
00D26:  ADDWFC 03,W
00D28:  MOVWF  FEA
00D2A:  MOVFF  362,FEC
00D2E:  MOVF   FED,F
00D30:  MOVFF  361,FEF
....................    global_message_queue[global_current_message_queue_location].attempt_num = 0; 
00D34:  MOVLB  4
00D36:  MOVF   xF3,W
00D38:  MULLW  08
00D3A:  MOVF   FF3,W
00D3C:  MOVLB  5
00D3E:  CLRF   xA6
00D40:  MOVWF  xA5
00D42:  MOVLW  07
00D44:  ADDWF  xA5,W
00D46:  MOVWF  01
00D48:  MOVLW  00
00D4A:  ADDWFC xA6,W
00D4C:  MOVWF  03
00D4E:  MOVF   01,W
00D50:  ADDLW  A3
00D52:  MOVWF  FE9
00D54:  MOVLW  04
00D56:  ADDWFC 03,W
00D58:  MOVWF  FEA
00D5A:  CLRF   FEF
....................     
....................    //starting at the new current queue location, sort through the queue 
....................    //until the new item is in the right place 
....................    for (n = global_current_message_queue_location; n > 0; n--) 
00D5C:  MOVFF  4F3,59C
00D60:  MOVF   x9C,F
00D62:  BTFSC  FD8.2
00D64:  BRA    0E6E
....................    { 
....................       //if queue items are not sorted properly 
....................       if (global_message_queue[n].time_to_send > global_message_queue[n-1].time_to_send) 
00D66:  MOVF   x9C,W
00D68:  MULLW  08
00D6A:  MOVF   FF3,W
00D6C:  CLRF   xA6
00D6E:  MOVWF  xA5
00D70:  MOVLW  A3
00D72:  ADDWF  xA5,W
00D74:  MOVWF  FE9
00D76:  MOVLW  04
00D78:  ADDWFC xA6,W
00D7A:  MOVWF  FEA
00D7C:  MOVFF  FEF,5A7
00D80:  MOVFF  FEC,5A8
00D84:  MOVFF  FEC,5A9
00D88:  MOVFF  FEC,5AA
00D8C:  MOVLW  01
00D8E:  SUBWF  x9C,W
00D90:  MULLW  08
00D92:  MOVF   FF3,W
00D94:  CLRF   xAC
00D96:  MOVWF  xAB
00D98:  MOVLW  A3
00D9A:  ADDWF  xAB,W
00D9C:  MOVWF  FE9
00D9E:  MOVLW  04
00DA0:  ADDWFC xAC,W
00DA2:  MOVWF  FEA
00DA4:  MOVFF  FEF,00
00DA8:  MOVFF  FEC,01
00DAC:  MOVFF  FEC,02
00DB0:  MOVFF  FEC,03
00DB4:  MOVF   03,W
00DB6:  SUBWF  xAA,W
00DB8:  BNC   0E64
00DBA:  BNZ   0DD2
00DBC:  MOVF   02,W
00DBE:  SUBWF  xA9,W
00DC0:  BNC   0E64
00DC2:  BNZ   0DD2
00DC4:  MOVF   01,W
00DC6:  SUBWF  xA8,W
00DC8:  BNC   0E64
00DCA:  BNZ   0DD2
00DCC:  MOVF   xA7,W
00DCE:  SUBWF  00,W
00DD0:  BC    0E64
....................       { 
....................          //do a swap 
....................          memcpy(&temp_message_queue_item, &global_message_queue[n], sizeof(&temp_message_queue_item)); 
00DD2:  MOVF   x9C,W
00DD4:  MULLW  08
00DD6:  MOVF   FF3,W
00DD8:  CLRF   03
00DDA:  ADDLW  A3
00DDC:  MOVWF  01
00DDE:  MOVLW  04
00DE0:  ADDWFC 03,F
00DE2:  MOVFF  03,FE2
00DE6:  MOVFF  01,FE1
00DEA:  MOVFF  FE6,59D
00DEE:  MOVFF  FE6,59E
....................          memcpy(&global_message_queue[n], &global_message_queue[n-1], sizeof(&global_message_queue[n])); 
00DF2:  MOVF   x9C,W
00DF4:  MULLW  08
00DF6:  MOVF   FF3,W
00DF8:  CLRF   03
00DFA:  ADDLW  A3
00DFC:  MOVWF  01
00DFE:  MOVLW  04
00E00:  ADDWFC 03,F
00E02:  MOVFF  01,5A5
00E06:  MOVFF  03,5A6
00E0A:  MOVLW  01
00E0C:  SUBWF  x9C,W
00E0E:  MULLW  08
00E10:  MOVF   FF3,W
00E12:  CLRF   03
00E14:  ADDLW  A3
00E16:  MOVWF  01
00E18:  MOVLW  04
00E1A:  ADDWFC 03,F
00E1C:  MOVFF  01,5A7
00E20:  MOVFF  03,5A8
00E24:  MOVFF  5A6,FEA
00E28:  MOVFF  5A5,FE9
00E2C:  MOVFF  03,FE2
00E30:  MOVFF  01,FE1
00E34:  MOVLW  02
00E36:  MOVWF  01
00E38:  MOVFF  FE6,FEE
00E3C:  DECFSZ 01,F
00E3E:  BRA    0E38
....................          memcpy(&global_message_queue[n-1], &temp_message_queue_item, sizeof(&global_message_queue[n-1])); 
00E40:  MOVLW  01
00E42:  SUBWF  x9C,W
00E44:  MULLW  08
00E46:  MOVF   FF3,W
00E48:  CLRF   03
00E4A:  ADDLW  A3
00E4C:  MOVWF  01
00E4E:  MOVLW  04
00E50:  ADDWFC 03,F
00E52:  MOVFF  03,FEA
00E56:  MOVFF  01,FE9
00E5A:  MOVFF  59D,FEE
00E5E:  MOVFF  59E,FEE
....................       } 
00E62:  BRA    0E6A
....................       //item is in the proper place (assuming queue always sorted properly) 
....................       else 
....................       { 
....................          return; 
00E64:  MOVLB  4
00E66:  BRA    0E70
00E68:  MOVLB  5
....................       } 
00E6A:  DECF   x9C,F
00E6C:  BRA    0D60
00E6E:  MOVLB  4
....................    } 
....................    return; 
00E70:  MOVLB  0
00E72:  RETURN 0
.................... } 
....................  
.................... void remove_message_queue_item(uint16_t msg_seq) 
.................... { 
.................... // Finds the message with the passed msg_seq and removes it from the queue, 
.................... //    shifting all other messages in the queue up 
.................... // Returns 1 if message removed, 0 if not found 
.................... // This function is ONLY run as a result of an ack'd unsolicted message                      
....................  
....................    uint8_t n, m; 
....................     
....................    // no items in the queue (current location is 0-1) 
....................    if (global_current_message_queue_location == 255) 
*
05C42:  MOVLB  4
05C44:  INCFSZ xF3,W
05C46:  BRA    5C4A
....................    {   
....................  
....................       return;   
05C48:  BRA    5D9A
....................    } 
....................     
....................    // search through the message queue from 0 to the current top of queue 
....................    for (n = 0; n <= global_current_message_queue_location; n++) 
05C4A:  MOVLB  5
05C4C:  CLRF   x50
05C4E:  MOVF   x50,W
05C50:  MOVLB  4
05C52:  SUBWF  xF3,W
05C54:  BTFSS  FD8.0
05C56:  BRA    5D9A
....................    { 
....................       // if you find the matching message 
....................       if (global_message_queue[n].msg_seq == msg_seq) 
05C58:  MOVLB  5
05C5A:  MOVF   x50,W
05C5C:  MULLW  08
05C5E:  MOVF   FF3,W
05C60:  CLRF   x53
05C62:  MOVWF  x52
05C64:  MOVLW  05
05C66:  ADDWF  x52,W
05C68:  MOVWF  01
05C6A:  MOVLW  00
05C6C:  ADDWFC x53,W
05C6E:  MOVWF  03
05C70:  MOVF   01,W
05C72:  ADDLW  A3
05C74:  MOVWF  FE9
05C76:  MOVLW  04
05C78:  ADDWFC 03,W
05C7A:  MOVWF  FEA
05C7C:  MOVFF  FEC,553
05C80:  MOVF   FED,F
05C82:  MOVFF  FEF,552
05C86:  MOVF   x4E,W
05C88:  SUBWF  x52,W
05C8A:  BTFSS  FD8.2
05C8C:  BRA    5D94
05C8E:  MOVF   x4F,W
05C90:  SUBWF  x53,W
05C92:  BTFSS  FD8.2
05C94:  BRA    5D94
....................       { 
....................          // since this is only run from ack'd messages, we can assume this 
....................          //    means the error message was recieved and we can clear the error 
....................          //    bitfield 
....................          if (global_message_queue[n].message_type == MSG_MOTE_ERROR_MSG) 
05C96:  MOVF   x50,W
05C98:  MULLW  08
05C9A:  MOVF   FF3,W
05C9C:  CLRF   x53
05C9E:  MOVWF  x52
05CA0:  MOVLW  04
05CA2:  ADDWF  x52,W
05CA4:  MOVWF  01
05CA6:  MOVLW  00
05CA8:  ADDWFC x53,W
05CAA:  MOVWF  03
05CAC:  MOVF   01,W
05CAE:  ADDLW  A3
05CB0:  MOVWF  FE9
05CB2:  MOVLW  04
05CB4:  ADDWFC 03,W
05CB6:  MOVWF  FEA
05CB8:  MOVF   FEF,W
05CBA:  SUBLW  A0
05CBC:  BNZ   5CCA
....................          { 
....................             global_error_message_bitfield = 0; 
05CBE:  MOVLB  4
05CC0:  CLRF   xF7
05CC2:  CLRF   xF6
05CC4:  CLRF   xF5
05CC6:  CLRF   xF4
05CC8:  MOVLB  5
....................          } 
....................          // shift everything over 1 place starting by overwriting the item 
....................          //    to remove and ending by copying the top of the queue to the next item 
....................          for (m = n; m < (MAX_MESSAGE_QUEUE_ITEMS - 1); m++) 
05CCA:  MOVFF  550,551
05CCE:  MOVF   x51,W
05CD0:  SUBLW  08
05CD2:  BNC   5D5A
....................          { 
....................             memcpy(&global_message_queue[n], global_message_queue[n+1], sizeof(&global_message_queue[n])); 
05CD4:  MOVF   x50,W
05CD6:  MULLW  08
05CD8:  MOVF   FF3,W
05CDA:  CLRF   03
05CDC:  ADDLW  A3
05CDE:  MOVWF  01
05CE0:  MOVLW  04
05CE2:  ADDWFC 03,F
05CE4:  MOVFF  01,552
05CE8:  MOVFF  03,553
05CEC:  MOVLW  01
05CEE:  ADDWF  x50,W
05CF0:  MULLW  08
05CF2:  MOVF   FF3,W
05CF4:  CLRF   03
05CF6:  ADDLW  A3
05CF8:  MOVWF  FE9
05CFA:  MOVLW  04
05CFC:  ADDWFC 03,W
05CFE:  MOVWF  FEA
05D00:  MOVF   FEE,F
05D02:  MOVF   FEE,F
05D04:  MOVF   FEE,F
05D06:  MOVF   FEE,F
05D08:  MOVF   FEE,F
05D0A:  MOVF   FEE,F
05D0C:  MOVFF  FEC,55B
05D10:  MOVF   FED,F
05D12:  MOVFF  FEF,55A
05D16:  MOVF   FED,F
05D18:  MOVFF  FEF,559
05D1C:  MOVF   FED,F
05D1E:  MOVFF  FEF,558
05D22:  MOVF   FED,F
05D24:  MOVFF  FEF,557
05D28:  MOVF   FED,F
05D2A:  MOVFF  FEF,556
05D2E:  MOVF   FED,F
05D30:  MOVFF  FEF,555
05D34:  MOVF   FED,F
05D36:  MOVFF  FEF,554
05D3A:  MOVFF  553,FEA
05D3E:  MOVFF  01,FE9
05D42:  MOVFF  555,FE2
05D46:  MOVFF  554,FE1
05D4A:  MOVLW  02
05D4C:  MOVWF  01
05D4E:  MOVFF  FE6,FEE
05D52:  DECFSZ 01,F
05D54:  BRA    5D4E
05D56:  INCF   x51,F
05D58:  BRA    5CCE
....................          } 
....................          // clear out the last item 
....................          memset(&global_message_queue[global_current_message_queue_location],EMPTY_MESSAGE_QUEUE,sizeof(&global_message_queue[global_current_message_queue_location])); 
05D5A:  MOVLB  4
05D5C:  MOVF   xF3,W
05D5E:  MULLW  08
05D60:  MOVF   FF3,W
05D62:  CLRF   03
05D64:  ADDLW  A3
05D66:  MOVWF  01
05D68:  MOVLW  04
05D6A:  ADDWFC 03,F
05D6C:  MOVFF  01,552
05D70:  MOVLB  5
05D72:  MOVFF  03,553
05D76:  MOVFF  03,FEA
05D7A:  MOVFF  01,FE9
05D7E:  CLRF   00
05D80:  CLRF   02
05D82:  MOVLW  02
05D84:  MOVWF  01
05D86:  MOVLB  0
05D88:  CALL   210E
....................          // decrement the message queue current position 
....................          global_current_message_queue_location--;  
05D8C:  MOVLB  4
05D8E:  DECF   xF3,F
....................          return; 
05D90:  BRA    5D9A
05D92:  MOVLB  5
....................       } 
05D94:  INCF   x50,F
05D96:  BRA    5C4E
05D98:  MOVLB  4
....................    } 
....................    return;                      
05D9A:  MOVLB  0
05D9C:  GOTO   717E (RETURN)
.................... } 
....................  
.................... void remove_message_queue_item_ISR(uint16_t msg_seq) 
.................... { 
.................... // Finds the message with the passed msg_seq and removes it from the queue, 
.................... //    shifting all other messages in the queue up 
.................... // Returns 1 if message removed, 0 if not found 
.................... // This function is ONLY run as a result of a message not getting ack'd after 
.................... //    being resent numerous times 
....................  
....................    uint8_t n, m; 
....................  
....................    // no items in the queue (current location is 0-1) 
....................    if (global_current_message_queue_location == 255) 
*
02128:  MOVLB  4
0212A:  INCFSZ xF3,W
0212C:  BRA    2130
....................    { 
....................       return;   
0212E:  BRA    2246
....................    } 
....................     
....................    // search through the message queue from 0 to the current top of queue 
....................    for (n = 0; n <= global_current_message_queue_location; n++) 
02130:  MOVLB  5
02132:  CLRF   x8A
02134:  MOVF   x8A,W
02136:  MOVLB  4
02138:  SUBWF  xF3,W
0213A:  BTFSS  FD8.0
0213C:  BRA    2246
....................    { 
....................       // if you find the matching message 
....................       if (global_message_queue[n].msg_seq == msg_seq) 
0213E:  MOVLB  5
02140:  MOVF   x8A,W
02142:  MULLW  08
02144:  MOVF   FF3,W
02146:  CLRF   x8D
02148:  MOVWF  x8C
0214A:  MOVLW  05
0214C:  ADDWF  x8C,W
0214E:  MOVWF  01
02150:  MOVLW  00
02152:  ADDWFC x8D,W
02154:  MOVWF  03
02156:  MOVF   01,W
02158:  ADDLW  A3
0215A:  MOVWF  FE9
0215C:  MOVLW  04
0215E:  ADDWFC 03,W
02160:  MOVWF  FEA
02162:  MOVFF  FEC,58D
02166:  MOVF   FED,F
02168:  MOVFF  FEF,58C
0216C:  MOVF   x88,W
0216E:  SUBWF  x8C,W
02170:  BNZ   2240
02172:  MOVF   x89,W
02174:  SUBWF  x8D,W
02176:  BNZ   2240
....................       { 
....................          // shift everything over 1 place starting by overwriting the item 
....................          //    to remove and ending by copying the top of the queue to the next item 
....................          for (m = n; m < (MAX_MESSAGE_QUEUE_ITEMS - 1); m++) 
02178:  MOVFF  58A,58B
0217C:  MOVF   x8B,W
0217E:  SUBLW  08
02180:  BNC   2208
....................          { 
....................             memcpy(&global_message_queue[n], global_message_queue[n+1], sizeof(&global_message_queue[n])); 
02182:  MOVF   x8A,W
02184:  MULLW  08
02186:  MOVF   FF3,W
02188:  CLRF   03
0218A:  ADDLW  A3
0218C:  MOVWF  01
0218E:  MOVLW  04
02190:  ADDWFC 03,F
02192:  MOVFF  01,58C
02196:  MOVFF  03,58D
0219A:  MOVLW  01
0219C:  ADDWF  x8A,W
0219E:  MULLW  08
021A0:  MOVF   FF3,W
021A2:  CLRF   03
021A4:  ADDLW  A3
021A6:  MOVWF  FE9
021A8:  MOVLW  04
021AA:  ADDWFC 03,W
021AC:  MOVWF  FEA
021AE:  MOVF   FEE,F
021B0:  MOVF   FEE,F
021B2:  MOVF   FEE,F
021B4:  MOVF   FEE,F
021B6:  MOVF   FEE,F
021B8:  MOVF   FEE,F
021BA:  MOVFF  FEC,595
021BE:  MOVF   FED,F
021C0:  MOVFF  FEF,594
021C4:  MOVF   FED,F
021C6:  MOVFF  FEF,593
021CA:  MOVF   FED,F
021CC:  MOVFF  FEF,592
021D0:  MOVF   FED,F
021D2:  MOVFF  FEF,591
021D6:  MOVF   FED,F
021D8:  MOVFF  FEF,590
021DC:  MOVF   FED,F
021DE:  MOVFF  FEF,58F
021E2:  MOVF   FED,F
021E4:  MOVFF  FEF,58E
021E8:  MOVFF  58D,FEA
021EC:  MOVFF  01,FE9
021F0:  MOVFF  58F,FE2
021F4:  MOVFF  58E,FE1
021F8:  MOVLW  02
021FA:  MOVWF  01
021FC:  MOVFF  FE6,FEE
02200:  DECFSZ 01,F
02202:  BRA    21FC
02204:  INCF   x8B,F
02206:  BRA    217C
....................          } 
....................          // clear out the last item 
....................          memset(&global_message_queue[global_current_message_queue_location],EMPTY_MESSAGE_QUEUE,sizeof(&global_message_queue[global_current_message_queue_location])); 
02208:  MOVLB  4
0220A:  MOVF   xF3,W
0220C:  MULLW  08
0220E:  MOVF   FF3,W
02210:  CLRF   03
02212:  ADDLW  A3
02214:  MOVWF  01
02216:  MOVLW  04
02218:  ADDWFC 03,F
0221A:  MOVFF  01,58C
0221E:  MOVLB  5
02220:  MOVFF  03,58D
02224:  MOVFF  03,FEA
02228:  MOVFF  01,FE9
0222C:  CLRF   00
0222E:  CLRF   02
02230:  MOVLW  02
02232:  MOVWF  01
02234:  MOVLB  0
02236:  RCALL  210E
....................          // decrement the message queue current position 
....................          global_current_message_queue_location--; 
02238:  MOVLB  4
0223A:  DECF   xF3,F
....................          return; 
0223C:  BRA    2246
0223E:  MOVLB  5
....................       } 
02240:  INCF   x8A,F
02242:  BRA    2134
02244:  MOVLB  4
....................    } 
....................    return; 
02246:  MOVLB  0
02248:  GOTO   2742 (RETURN)
.................... } 
....................     
....................  
.................... #include "util.h" 
.................... /* This file contains all functions related to PIC functions 
....................  * 
....................  * 
....................  * 
....................  * 
....................  * 
....................  */ 
....................  
.................... /****************************************/ 
.................... void flash_leds(uint8_t num_of_flashes)                           
.................... { 
....................    uint8_t  n; 
....................     
....................    for (n = 0; n < num_of_flashes; n++) 
....................    { 
....................       LED1_ON 
....................       LED2_ON 
....................       setup_T0_int(T0_50MS); 
....................       while (!TMR0IF); 
....................        
....................       LED1_OFF    
....................       LED2_OFF                       
....................       if (n == (num_of_flashes - 1)) 
....................       { 
....................          return; 
....................       } 
....................       setup_T0_int(T0_50MS); 
....................       while (!TMR0IF);  
....................    }       
.................... } 
.................... void flash_leds_ISR(uint8_t num_of_flashes) 
.................... { 
....................    uint8_t  n; 
....................     
....................    for (n = 0; n < num_of_flashes; n++) 
....................    { 
....................       LED1_ON 
....................       LED2_ON 
....................       setup_T4_int(T4_64MS); 
....................       while (!TMR4IF); 
....................       LED1_OFF 
....................       LED2_OFF 
....................       setup_T4_int(T4_64MS); 
....................       while (!TMR4IF); 
....................    }       
.................... } 
....................  
....................  
.................... void flash_led_1(uint8_t num_of_flashes) 
.................... { 
....................    uint8_t  n; 
....................     
....................    for (n = 0; n < num_of_flashes; n++) 
....................    { 
....................       LED1_ON 
....................       setup_T0_int(T0_100MS); 
....................       while (!TMR0IF); 
....................        
....................       LED1_OFF 
....................       setup_T0_int(T0_100MS); 
....................       while (!TMR0IF);  
....................    }       
.................... } 
....................  
.................... void flash_led_2(uint8_t num_of_flashes) 
.................... { 
....................    uint8_t  n; 
....................     
....................    for (n = 0; n < num_of_flashes; n++) 
*
08270:  MOVLB  5
08272:  CLRF   x48
08274:  MOVF   x47,W
08276:  SUBWF  x48,W
08278:  BC    82AA
....................    { 
....................       LED2_ON 
0827A:  BCF    F89.2
....................       setup_T0_int(T0_100MS); 
0827C:  MOVLW  FE
0827E:  MOVWF  x65
08280:  MOVLW  7A
08282:  MOVWF  x64
08284:  MOVLB  0
08286:  CALL   36B2
....................       while (!TMR0IF); 
0828A:  BTFSS  FF2.2
0828C:  BRA    828A
....................        
....................       LED2_OFF 
0828E:  BSF    F89.2
....................       setup_T0_int(T0_100MS); 
08290:  MOVLW  FE
08292:  MOVLB  5
08294:  MOVWF  x65
08296:  MOVLW  7A
08298:  MOVWF  x64
0829A:  MOVLB  0
0829C:  CALL   36B2
....................       while (!TMR0IF);  
082A0:  BTFSS  FF2.2
082A2:  BRA    82A0
082A4:  MOVLB  5
082A6:  INCF   x48,F
082A8:  BRA    8274
....................    }       
082AA:  MOVLB  0
082AC:  GOTO   A9A4 (RETURN)
.................... } 
....................  
.................... void happy_lites(void) 
.................... { 
.................... // blink the two leds in a fashion to let the operator know, e.g., 
.................... // that the SW1-initiated search process was successful 
....................    uint8_t  n; 
....................     
....................    for (n=0; n<4; n++) 
*
04E20:  MOVLB  5
04E22:  CLRF   x5F
04E24:  MOVF   x5F,W
04E26:  SUBLW  03
04E28:  BNC   4E6A
....................    { 
....................       LED1_ON 
04E2A:  BCF    F62.4
04E2C:  MOVLW  E7
04E2E:  MOVWF  F93
04E30:  BCF    F8A.4
....................        
....................       setup_T0_int(T0_250MS); 
04E32:  MOVLW  FC
04E34:  MOVWF  x65
04E36:  MOVLW  30
04E38:  MOVWF  x64
04E3A:  MOVLB  0
04E3C:  CALL   36B2
....................       while (!TMR0IF); 
04E40:  BTFSS  FF2.2
04E42:  BRA    4E40
....................        
....................       LED1_OFF 
04E44:  MOVLW  F7
04E46:  MOVWF  F93
04E48:  BSF    FF2.3
04E4A:  BSF    F62.4
....................       LED2_ON 
04E4C:  BCF    F89.2
....................        
....................       setup_T0_int(T0_250MS); 
04E4E:  MOVLW  FC
04E50:  MOVLB  5
04E52:  MOVWF  x65
04E54:  MOVLW  30
04E56:  MOVWF  x64
04E58:  MOVLB  0
04E5A:  CALL   36B2
....................       while (!TMR0IF); 
04E5E:  BTFSS  FF2.2
04E60:  BRA    4E5E
....................        
....................       LED2_OFF 
04E62:  BSF    F89.2
04E64:  MOVLB  5
04E66:  INCF   x5F,F
04E68:  BRA    4E24
....................    } 
04E6A:  MOVLB  0
04E6C:  RETURN 0
.................... } 
....................  
.................... char *word_to_4dig_new (uint16_t xword) 
.................... { 
....................    /* Takes a uint16 and converts it to a 4 digit result 
....................     * that is stored in a static char pointer 
....................     */ 
....................      
....................    uint16_t temp_u16; 
....................    static char result[4]; 
....................    ldiv_t      lidiv_temp; 
....................    div_t       idiv_temp; 
....................     
....................    if (xword > 9999) 
....................       return 0; 
....................    else 
....................    {    
....................       lidiv_temp=ldiv(xword,1000); 
....................       result[3] = '0' + lidiv_temp.quot; 
....................       temp_u16 = lidiv_temp.rem; 
....................       lidiv_temp=ldiv(temp_u16,(uint16_t)(100)); 
....................       result[2] = '0' + lidiv_temp.quot; 
....................       idiv_temp = div((uint8_t)(lidiv_temp.rem),10); 
....................       result[1] = '0' + idiv_temp.quot; 
....................       result[0] = '0' + idiv_temp.rem; 
....................       return result; 
....................    } 
.................... } 
....................  
.................... // this routine ain't done yet 
.................... uint16_t convert_rpm_to_period(uint16_t rpm) 
.................... { 
....................    uint16_t period; 
....................    return period; 
.................... } 
.................... uint16_t convert_period_to_rpm(uint16_t period) 
.................... { 
....................    uint32_t rpm_32; 
....................    uint16_t rpm_16; 
....................     
....................    rpm_32 = CCP_PER_RPM/(make32(0,0,make8(period,1), make8(period,0))); 
*
05DE2:  MOVFF  554,55B
05DE6:  MOVFF  553,55C
05DEA:  MOVLB  5
05DEC:  CLRF   x60
05DEE:  CLRF   x5F
05DF0:  MOVFF  554,55E
05DF4:  MOVFF  553,55D
05DF8:  BCF    FD8.1
05DFA:  CLRF   19
05DFC:  BTFSC  FF2.7
05DFE:  BSF    19.7
05E00:  BCF    FF2.7
05E02:  MOVLW  99
05E04:  MOVWF  xA0
05E06:  MOVWF  x9F
05E08:  MOVWF  x9E
05E0A:  MOVLW  9A
05E0C:  MOVWF  x9D
05E0E:  MOVFF  560,5A4
05E12:  MOVFF  55F,5A3
05E16:  MOVFF  554,5A2
05E1A:  MOVFF  553,5A1
05E1E:  MOVLB  0
05E20:  CALL   23C0
05E24:  BTFSC  19.7
05E26:  BSF    FF2.7
05E28:  MOVFF  03,558
05E2C:  MOVFF  02,557
05E30:  MOVFF  01,556
05E34:  MOVFF  00,555
....................    rpm_16 = make16(make8(rpm_32,3), make8(rpm_32,2)); 
05E38:  MOVFF  558,55A
05E3C:  MOVFF  557,559
....................    if (bit_test(rpm_32, 15)) rpm_16++;  
05E40:  MOVLB  5
05E42:  BTFSS  x56.7
05E44:  BRA    5E4C
05E46:  INCF   x59,F
05E48:  BTFSC  FD8.2
05E4A:  INCF   x5A,F
....................    return rpm_16; 
05E4C:  MOVFF  559,01
05E50:  MOVFF  55A,02
05E54:  MOVLB  0
05E56:  RETURN 0
.................... } 
.................... uint16_t convert_period_to_rpm_ISR(uint16_t period) 
.................... { 
....................    uint32_t rpm_32; 
....................    uint16_t rpm_16; 
....................     
....................    rpm_32 = CCP_PER_RPM/(make32(0,0,make8(period,1), make8(period,0))); 
*
02454:  MOVFF  590,597
02458:  MOVFF  58F,598
0245C:  MOVLB  5
0245E:  CLRF   x9C
02460:  CLRF   x9B
02462:  MOVFF  590,59A
02466:  MOVFF  58F,599
0246A:  BCF    FD8.1
0246C:  MOVLW  99
0246E:  MOVWF  xA0
02470:  MOVWF  x9F
02472:  MOVWF  x9E
02474:  MOVLW  9A
02476:  MOVWF  x9D
02478:  MOVFF  59C,5A4
0247C:  MOVFF  59B,5A3
02480:  MOVFF  590,5A2
02484:  MOVFF  58F,5A1
02488:  MOVLB  0
0248A:  RCALL  23C0
0248C:  MOVFF  03,594
02490:  MOVFF  02,593
02494:  MOVFF  01,592
02498:  MOVFF  00,591
....................    rpm_16 = make16(make8(rpm_32,3), make8(rpm_32,2)); 
0249C:  MOVFF  594,596
024A0:  MOVFF  593,595
....................    if (bit_test(rpm_32, 15)) rpm_16++;  
024A4:  MOVLB  5
024A6:  BTFSS  x92.7
024A8:  BRA    24B0
024AA:  INCF   x95,F
024AC:  BTFSC  FD8.2
024AE:  INCF   x96,F
....................    return rpm_16; 
024B0:  MOVFF  595,01
024B4:  MOVFF  596,02
024B8:  MOVLB  0
024BA:  GOTO   25BC (RETURN)
.................... } 
.................... uint8_t  hi2asc(uint8_t xbyte) 
.................... { 
....................    xbyte >>= 4; 
*
03158:  MOVLB  5
0315A:  SWAPF  x60,F
0315C:  MOVLW  0F
0315E:  ANDWF  x60,F
....................    if (xbyte < 0x0A) 
03160:  MOVF   x60,W
03162:  SUBLW  09
03164:  BNC   316C
....................       xbyte += 0x30; 
03166:  MOVLW  30
03168:  ADDWF  x60,F
0316A:  BRA    3170
....................    else 
....................       xbyte += 0x37; 
0316C:  MOVLW  37
0316E:  ADDWF  x60,F
....................    return xbyte; 
03170:  MOVFF  560,01
03174:  MOVLB  0
03176:  RETURN 0
.................... } 
....................  
....................  
.................... uint8_t  lo2asc(uint8_t xbyte) 
.................... { 
....................    xbyte &= 0x0F; 
03178:  MOVLW  0F
0317A:  MOVLB  5
0317C:  ANDWF  x60,F
....................    if (xbyte < 0x0A) 
0317E:  MOVF   x60,W
03180:  SUBLW  09
03182:  BNC   318A
....................       xbyte += 0x30; 
03184:  MOVLW  30
03186:  ADDWF  x60,F
03188:  BRA    318E
....................    else 
....................       xbyte += 0x37; 
0318A:  MOVLW  37
0318C:  ADDWF  x60,F
....................    return xbyte; 
0318E:  MOVFF  560,01
03192:  MOVLB  0
03194:  RETURN 0
.................... } 
....................  
....................  
.................... void main() 
*
09E00:  CLRF   FF8
09E02:  BCF    FF0.7
09E04:  BCF    FF1.0
09E06:  BCF    FA2.3
09E08:  BCF    FA2.6
09E0A:  BSF    F7C.0
09E0C:  BCF    F7C.1
09E0E:  BSF    F7C.2
09E10:  BSF    FD0.7
09E12:  BSF    07.7
09E14:  BCF    FB8.3
09E16:  MOVLW  01
09E18:  MOVWF  FAF
09E1A:  MOVLW  A6
09E1C:  MOVWF  FAC
09E1E:  MOVLW  90
09E20:  MOVWF  FAB
09E22:  CLRF   4A
09E24:  CLRF   49
09E26:  CLRF   48
09E28:  CLRF   47
09E2A:  CLRF   4C
09E2C:  CLRF   4B
09E2E:  CLRF   4D
09E30:  CLRF   4E
09E32:  CLRF   54
09E34:  CLRF   55
09E36:  CLRF   59
09E38:  CLRF   58
09E3A:  CLRF   57
09E3C:  CLRF   56
09E3E:  CLRF   5D
09E40:  CLRF   5C
09E42:  CLRF   5B
09E44:  CLRF   5A
09E46:  CLRF   5F
09E48:  CLRF   5E
09E4A:  CLRF   x61
09E4C:  CLRF   x60
09E4E:  CLRF   x63
09E50:  CLRF   x62
09E52:  CLRF   x65
09E54:  CLRF   x64
09E56:  CLRF   x67
09E58:  CLRF   x66
09E5A:  CLRF   x69
09E5C:  CLRF   x68
09E5E:  CLRF   x6B
09E60:  CLRF   x6A
09E62:  CLRF   x6D
09E64:  CLRF   x6C
09E66:  CLRF   x6F
09E68:  CLRF   x6E
09E6A:  CLRF   x83
09E6C:  MOVLW  01
09E6E:  MOVWF  x84
09E70:  CLRF   x88
09E72:  CLRF   x87
09E74:  CLRF   x86
09E76:  CLRF   x85
09E78:  CLRF   x8C
09E7A:  CLRF   x8B
09E7C:  CLRF   x8A
09E7E:  CLRF   x89
09E80:  CLRF   x90
09E82:  CLRF   x8F
09E84:  CLRF   x8E
09E86:  CLRF   x8D
09E88:  CLRF   x92
09E8A:  CLRF   x91
09E8C:  CLRF   xA3
09E8E:  CLRF   xA5
09E90:  CLRF   xA4
09E92:  CLRF   xA9
09E94:  MOVLW  64
09E96:  MOVWF  xA8
09E98:  CLRF   xAD
09E9A:  CLRF   xAC
09E9C:  CLRF   xAB
09E9E:  CLRF   xAA
09EA0:  CLRF   xAF
09EA2:  CLRF   xAE
09EA4:  MOVLW  01
09EA6:  MOVWF  xB1
09EA8:  MOVLW  90
09EAA:  MOVWF  xB0
09EAC:  CLRF   xB3
09EAE:  CLRF   xB2
09EB0:  MOVLW  01
09EB2:  MOVWF  xB5
09EB4:  MOVLW  90
09EB6:  MOVWF  xB4
09EB8:  MOVLW  64
09EBA:  MOVWF  xB6
09EBC:  MOVWF  xB7
09EBE:  CLRF   xB9
09EC0:  CLRF   xB8
09EC2:  CLRF   xBB
09EC4:  CLRF   xBA
09EC6:  MOVLW  06
09EC8:  MOVWF  xBC
09ECA:  MOVLW  40
09ECC:  MOVWF  xBE
09ECE:  CLRF   xBD
09ED0:  MOVWF  xC0
09ED2:  CLRF   xBF
09ED4:  MOVLW  05
09ED6:  MOVWF  xC2
09ED8:  CLRF   xC1
09EDA:  MOVWF  xC4
09EDC:  CLRF   xC3
09EDE:  CLRF   xC6
09EE0:  CLRF   xC5
09EE2:  CLRF   xCA
09EE4:  CLRF   xC9
09EE6:  CLRF   xC8
09EE8:  CLRF   xC7
09EEA:  CLRF   xCB
09EEC:  MOVLW  20
09EEE:  MOVWF  xCD
09EF0:  CLRF   xCC
09EF2:  SETF   xCF
09EF4:  SETF   xCE
09EF6:  CLRF   xD3
09EF8:  CLRF   xD2
09EFA:  CLRF   xD1
09EFC:  CLRF   xD0
09EFE:  MOVLB  3
09F00:  CLRF   x4D
09F02:  CLRF   x4E
09F04:  CLRF   x5B
09F06:  CLRF   x5E
09F08:  CLRF   x5F
09F0A:  CLRF   x60
09F0C:  CLRF   x62
09F0E:  CLRF   x61
09F10:  MOVLW  04
09F12:  MOVWF  x64
09F14:  MOVLW  CD
09F16:  MOVWF  x63
09F18:  CLRF   x66
09F1A:  CLRF   x65
09F1C:  CLRF   x67
09F1E:  CLRF   x68
09F20:  CLRF   x69
09F22:  SETF   x7E
09F24:  SETF   x98
09F26:  MOVLB  4
09F28:  SETF   x25
09F2A:  SETF   00
09F2C:  SETF   01
09F2E:  SETF   02
09F30:  SETF   03
09F32:  MOVFF  03,429
09F36:  MOVFF  02,428
09F3A:  MOVFF  01,427
09F3E:  MOVFF  00,426
09F42:  SETF   xA2
09F44:  SETF   xF3
09F46:  CLRF   xF7
09F48:  CLRF   xF6
09F4A:  CLRF   xF5
09F4C:  CLRF   xF4
09F4E:  CLRF   xFB
09F50:  CLRF   xFA
09F52:  CLRF   xF9
09F54:  CLRF   xF8
09F56:  CLRF   xFF
09F58:  CLRF   xFE
09F5A:  CLRF   xFD
09F5C:  CLRF   xFC
09F5E:  MOVLB  5
09F60:  SETF   x00
09F62:  SETF   x01
09F64:  MOVLW  10
09F66:  MOVWF  x03
09F68:  CLRF   x02
09F6A:  MOVLW  70
09F6C:  MOVWF  x05
09F6E:  CLRF   x04
09F70:  CLRF   x07
09F72:  MOVLW  18
09F74:  MOVWF  x06
09F76:  CLRF   x09
09F78:  MOVLW  14
09F7A:  MOVWF  x08
09F7C:  CLRF   x0B
09F7E:  MOVWF  x0A
09F80:  CLRF   x0D
09F82:  MOVLW  18
09F84:  MOVWF  x0C
09F86:  CLRF   x0F
09F88:  MOVLW  13
09F8A:  MOVWF  x0E
09F8C:  CLRF   x11
09F8E:  MOVWF  x10
09F90:  CLRF   x13
09F92:  MOVLW  1E
09F94:  MOVWF  x12
09F96:  MOVLW  40
09F98:  MOVWF  x15
09F9A:  CLRF   x14
09F9C:  MOVLW  70
09F9E:  MOVWF  x17
09FA0:  CLRF   x16
09FA2:  MOVLW  08
09FA4:  MOVWF  x18
09FA6:  MOVLW  50
09FA8:  MOVWF  x1A
09FAA:  CLRF   x19
09FAC:  MOVLW  10
09FAE:  MOVWF  x1C
09FB0:  CLRF   x1B
09FB2:  CLRF   x1E
09FB4:  MOVLW  02
09FB6:  MOVWF  x1D
09FB8:  CLRF   x20
09FBA:  MOVLW  78
09FBC:  MOVWF  x1F
09FBE:  MOVLW  04
09FC0:  MOVWF  x22
09FC2:  MOVLW  B0
09FC4:  MOVWF  x21
09FC6:  CLRF   x23
09FC8:  BCF    FB8.3
09FCA:  MOVLW  01
09FCC:  MOVWF  FAF
09FCE:  MOVLW  A6
09FD0:  MOVWF  FAC
09FD2:  MOVLW  90
09FD4:  MOVWF  FAB
09FD6:  BCF    FCB.0
09FD8:  BCF    FCB.1
09FDA:  BCF    FCB.3
09FDC:  MOVLW  06
09FDE:  MOVWF  FC8
09FE0:  MOVLW  28
09FE2:  MOVWF  FC6
09FE4:  BSF    FC7.7
09FE6:  BCF    FC7.6
09FE8:  CLRF   x36
09FEA:  CLRF   x35
09FEC:  CLRF   x38
09FEE:  CLRF   x37
09FF0:  CLRF   x39
09FF2:  CLRF   x3A
09FF4:  MOVLW  01
09FF6:  MOVWF  x3B
09FF8:  CLRF   x41
09FFA:  CLRF   x40
09FFC:  CLRF   x43
09FFE:  CLRF   x42
0A000:  MOVLB  F
0A002:  CLRF   x38
0A004:  CLRF   x39
0A006:  CLRF   x3A
0A008:  CLRF   x3B
0A00A:  CLRF   x3C
0A00C:  MOVLB  1
0A00E:  CLRF   x88
0A010:  CLRF   F77
0A012:  CLRF   F78
0A014:  CLRF   F79
0A016:  MOVLW  05
0A018:  MOVWF  36
0A01A:  MOVLW  C7
0A01C:  MOVWF  35
0A01E:  MOVLW  09
0A020:  MOVLB  5
0A022:  MOVWF  xC8
0A024:  MOVLW  6D
0A026:  MOVWF  xC7
0A028:  CLRF   xCA
0A02A:  CLRF   xC9
0A02C:  MOVLB  0
0A02E:  BRA    A074
0A030:  DATA 02,00
0A032:  DATA 2F,00
0A034:  DATA 00,10
0A036:  DATA 00,37
0A038:  DATA 44,55
0A03A:  DATA 53,54
0A03C:  DATA 4E,45
0A03E:  DATA 54,57
0A040:  DATA 4F,52
0A042:  DATA 4B,53
0A044:  DATA 52,4F
0A046:  DATA 43,4B
0A048:  DATA 05,00
0A04A:  DATA 4F,41
0A04C:  DATA 30,30
0A04E:  DATA 30,00
0A050:  DATA 10,40
0A052:  DATA 93,00
0A054:  DATA 14,43
0A056:  DATA 6A,00
0A058:  DATA 19,43
0A05A:  DATA 7F,00
0A05C:  DATA 8C,43
0A05E:  DATA 99,00
0A060:  DATA 78,44
0A062:  DATA 2A,00
0A064:  DATA 50,44
0A066:  DATA A3,00
0A068:  DATA 11,45
0A06A:  DATA 24,00
0A06C:  DATA 04,05
0A06E:  DATA 3C,00
0A070:  DATA 00,00
0A072:  DATA 00,00
0A074:  MOVLW  00
0A076:  MOVWF  FF8
0A078:  MOVLW  A0
0A07A:  MOVWF  FF7
0A07C:  MOVLW  30
0A07E:  MOVWF  FF6
0A080:  TBLRD*+
0A082:  MOVF   FF5,W
0A084:  MOVWF  00
0A086:  XORLW  00
0A088:  BZ    A0B0
0A08A:  TBLRD*+
0A08C:  MOVF   FF5,W
0A08E:  MOVWF  01
0A090:  BTFSC  FE8.7
0A092:  BRA    A09E
0A094:  ANDLW  0F
0A096:  MOVWF  FEA
0A098:  TBLRD*+
0A09A:  MOVF   FF5,W
0A09C:  MOVWF  FE9
0A09E:  BTFSC  01.6
0A0A0:  TBLRD*+
0A0A2:  BTFSS  01.6
0A0A4:  TBLRD*+
0A0A6:  MOVF   FF5,W
0A0A8:  MOVWF  FEE
0A0AA:  DCFSNZ 00,F
0A0AC:  BRA    A080
0A0AE:  BRA    A0A2
0A0B0:  CLRF   FF8
0A0B2:  MOVLB  5
0A0B4:  CLRF   x44
.................... {                                                          
....................    // priority queue item that is to be executed  
....................    uint8_t     priority_queue_item_to_execute = EMPTY_PRIORITY_QUEUE;     
....................    // valve setting that is stored when free spin rate is performed (so you can return to it afterwards) 
....................    uint16_t    pre_fsr_valve_setting;                                          
....................                                         
....................    // set system state to init 
....................    write_system_state(SYSTEM_INIT);               
0A0B6:  CLRF   x47
0A0B8:  MOVLB  0
0A0BA:  CALL   30EA
....................                 
....................    // initalize oscillator and timing of rs232, i2c, delay 
....................    osc_init();          
0A0BE:  GOTO   314C
....................  
....................    // initalize all variables (not really needed as they are initalized properly when CPU is rebooted)                                                         
....................    //vars_init();                   
....................     
....................    // store string version of firmware version in global_firmware_version_string                                                            
....................    global_firmware_version_string[0] = hi2asc(make8(FIRMWARE_VERSION,1)); 
0A0C2:  MOVLW  E3
0A0C4:  MOVLB  5
0A0C6:  MOVWF  x60
0A0C8:  MOVLB  0
0A0CA:  CALL   3158
0A0CE:  MOVFF  01,4F
....................    global_firmware_version_string[1] = lo2asc(make8(FIRMWARE_VERSION,1)); 
0A0D2:  MOVLW  E3
0A0D4:  MOVLB  5
0A0D6:  MOVWF  x60
0A0D8:  MOVLB  0
0A0DA:  CALL   3178
0A0DE:  MOVFF  01,50
....................    global_firmware_version_string[2] = hi2asc(make8(FIRMWARE_VERSION,0));       
0A0E2:  MOVLW  12
0A0E4:  MOVLB  5
0A0E6:  MOVWF  x60
0A0E8:  MOVLB  0
0A0EA:  CALL   3158
0A0EE:  MOVFF  01,51
....................    global_firmware_version_string[3] = lo2asc(make8(FIRMWARE_VERSION,0));    
0A0F2:  MOVLW  12
0A0F4:  MOVLB  5
0A0F6:  MOVWF  x60
0A0F8:  MOVLB  0
0A0FA:  CALL   3178
0A0FE:  MOVFF  01,52
....................  
....................    // grab all eeprom values (e.g. vlv cal, sprinkler number, vlv position) 
....................    read_all_eeprom_values();    
0A102:  GOTO   3364
....................     
....................    // load all changeable eeprom variables  
....................    read_all_eeprom_variables();         
0A106:  GOTO   3428
....................                                 
....................    // initalize all periphs, timers, ccps, ints    
....................    periph_init(); 
0A10A:  GOTO   3E84
....................                                      
....................    // clear queues     
....................    clear_priority_queue();                                  
0A10E:  GOTO   3FB0
....................    clear_time_queue(); 
0A112:  GOTO   3FD4
....................    clear_message_queue();       
0A116:  GOTO   4034
....................     
....................    // command queue is not needed/used yet as it is used in conjunction with the "modulation" scheme 
....................    //allocate_command_queue(); 
....................    //clear_command_queue(); 
....................     
....................    // startup rtc, turn on gen_rpm, enable dust chip (check for communication) 
....................    start_rtc();    
0A11A:  GOTO   4050
....................    setup_gen_rpm();         
0A11E:  GOTO   4082
....................    mote_init(); 
0A122:  GOTO   4284
....................                           
....................    // if cold start was done, reset mote    
....................    if (global_previous_shutdown_cause == COLD_RESTART_REQUEST) 
0A126:  MOVF   4E,W
0A128:  SUBLW  0A
0A12A:  BNZ   A130
....................    { 
....................       mote_reset();           
0A12C:  CALL   44DE
....................    }          
....................                           
....................    // DELETE?                              
....................    enable_interrupts(GLOBAL);                      
0A130:  MOVLW  C0
0A132:  IORWF  FF2,F
....................                                        
....................    // if SW1 is asserted during boot, trigger searching alogrithm                
....................    if (!input(SW1n))              
0A134:  BTFSC  F81.4
0A136:  BRA    A1AA
....................    {                                             
....................       // set the system state up for searching for a network (not run) 
....................       write_system_state(SYSTEM_SEARCHING_FOR_NETWORK); 
0A138:  MOVLW  20
0A13A:  MOVLB  5
0A13C:  MOVWF  x47
0A13E:  MOVLB  0
0A140:  CALL   30EA
....................       strcpy (global_temp_line_buff, "Setup Manager..."); 
0A144:  CLRF   FEA
0A146:  MOVLW  70
0A148:  MOVWF  FE9
0A14A:  MOVLW  00
0A14C:  CALL   0632
0A150:  TBLRD*-
0A152:  TBLRD*+
0A154:  MOVF   FF5,W
0A156:  MOVWF  FEE
0A158:  IORLW  00
0A15A:  BNZ   A152
....................       LCD_line1(global_temp_line_buff); 
0A15C:  MOVLB  5
0A15E:  CLRF   x60
0A160:  MOVLW  70
0A162:  MOVWF  x5F
0A164:  MOVLB  0
0A166:  CALL   37A0
....................       strcpy (global_temp_line_buff, "  Release SW1   "); 
0A16A:  CLRF   FEA
0A16C:  MOVLW  70
0A16E:  MOVWF  FE9
0A170:  MOVLW  00
0A172:  CALL   0654
0A176:  TBLRD*-
0A178:  TBLRD*+
0A17A:  MOVF   FF5,W
0A17C:  MOVWF  FEE
0A17E:  IORLW  00
0A180:  BNZ   A178
....................       LCD_line2(global_temp_line_buff);      
0A182:  MOVLB  5
0A184:  CLRF   x60
0A186:  MOVLW  70
0A188:  MOVWF  x5F
0A18A:  MOVLB  0
0A18C:  CALL   37FA
....................       // wait for switch release  
....................       while (!input(SW1n));       
0A190:  BTFSS  F81.4
0A192:  BRA    A190
....................       // delay lcd update for a tiny bit                                                                                                                              
....................       global_skip_lcd_update_count = 1; 
0A194:  MOVLW  01
0A196:  MOVWF  x83
....................       // first part of search alorithm sequence                                                                                       
....................       PUSH_PRIORITY_QUEUE_MACRO(SEARCH_FOR_STRONGEST_1);                  
0A198:  BCF    F7A.1
0A19A:  MOVLW  B1
0A19C:  MOVLB  5
0A19E:  MOVWF  x4E
0A1A0:  MOVLB  0
0A1A2:  CALL   4538
0A1A6:  BSF    F7A.1
....................    }                                  
0A1A8:  BRA    A25C
....................     
....................    // normal behavior, check mote status.  Join network if necessary.                                                                                                       
....................    else  
....................    {                                  
....................       // Fun startup splash screen (and clear startup screen) 
....................       //LCD_startup_splash();        
....................       //LCD_clear();                   
....................        
....................       // enable RB4 button press functionality       
....................       setup_rb4_int();         
0A1AA:  GOTO   45FE
....................                                                                                     
....................       // dispaly battery voltage (line 0) and restart/shutdown cause (line 1) on screen for a second  
....................       LCD_display_battery_voltage(0);     
0A1AE:  MOVLB  5
0A1B0:  CLRF   x47
0A1B2:  MOVLB  0
0A1B4:  GOTO   4D44
....................       LCD_display_shutdown_cause(1);             
0A1B8:  MOVLW  01
0A1BA:  MOVLB  5
0A1BC:  MOVWF  x47
0A1BE:  MOVLB  0
0A1C0:  GOTO   4DC6
....................         
....................       // global_skip_lcd_update_count is our way of letting things stay on the lcd for a moment 
....................       //    You set it to the number of times to skip an LCD update + 1 
....................       //    e.g. setting it to 2 means things stay on the screen for 1-2 seconds and then they are cleared 
....................       //    e.g. setting it to 1 means things are cleared right away 
....................       //    e.g. setting it to 0 (or not setting it) means the LCD screen is just overwritten by LCD update 
....................       global_skip_lcd_update_count = 2;         
0A1C4:  MOVLW  02
0A1C6:  MOVWF  x83
....................        
....................       // all periphs should be initalized (except mote), so system should be ready to run         
....................       write_system_state(SYSTEM_RUN); 
0A1C8:  MOVLB  5
0A1CA:  MOVWF  x47
0A1CC:  MOVLB  0
0A1CE:  CALL   30EA
....................                                        
....................       // flash the leds to help identify motes    
....................       happy_lites(); 
0A1D2:  CALL   4E20
....................        
....................       // check mote state. If it needs to connect, it will react as it should            
....................       PUSH_TIME_QUEUE_MACRO(global_rtc_time + 5, CHECK_MOTE_STATE);   
0A1D6:  BCF    F7A.1
0A1D8:  MOVLW  05
0A1DA:  ADDWF  x85,W
0A1DC:  MOVLB  5
0A1DE:  MOVWF  x47
0A1E0:  MOVLW  00
0A1E2:  MOVLB  0
0A1E4:  ADDWFC x86,W
0A1E6:  MOVLB  5
0A1E8:  MOVWF  x48
0A1EA:  MOVLW  00
0A1EC:  MOVLB  0
0A1EE:  ADDWFC x87,W
0A1F0:  MOVLB  5
0A1F2:  MOVWF  x49
0A1F4:  MOVLW  00
0A1F6:  MOVLB  0
0A1F8:  ADDWFC x88,W
0A1FA:  MOVLB  5
0A1FC:  MOVWF  x4A
0A1FE:  MOVWF  x55
0A200:  MOVFF  549,554
0A204:  MOVFF  548,553
0A208:  MOVFF  547,552
0A20C:  MOVLW  B4
0A20E:  MOVWF  x56
0A210:  MOVLB  0
0A212:  CALL   4290
0A216:  BSF    F7A.1
....................        
....................       // check mote info 
....................       PUSH_TIME_QUEUE_MACRO(global_rtc_time + 10, UPDATE_MOTE_NETWORK_INFO); 
0A218:  BCF    F7A.1
0A21A:  MOVLW  0A
0A21C:  ADDWF  x85,W
0A21E:  MOVLB  5
0A220:  MOVWF  x47
0A222:  MOVLW  00
0A224:  MOVLB  0
0A226:  ADDWFC x86,W
0A228:  MOVLB  5
0A22A:  MOVWF  x48
0A22C:  MOVLW  00
0A22E:  MOVLB  0
0A230:  ADDWFC x87,W
0A232:  MOVLB  5
0A234:  MOVWF  x49
0A236:  MOVLW  00
0A238:  MOVLB  0
0A23A:  ADDWFC x88,W
0A23C:  MOVLB  5
0A23E:  MOVWF  x4A
0A240:  MOVWF  x55
0A242:  MOVFF  549,554
0A246:  MOVFF  548,553
0A24A:  MOVFF  547,552
0A24E:  MOVLW  A4
0A250:  MOVWF  x56
0A252:  MOVLB  0
0A254:  CALL   4290
0A258:  BSF    F7A.1
....................              
....................       // setup WDT for 1 second (plenty long for the control loop (~64ms) to    
....................       setup_wdt(WDT_1S);      
0A25A:  BSF    FD1.0
....................    }                                                                  
....................                                                               
....................    // start the queue/control loop timer 
....................    setup_T2_int(T2_64MS);     
0A25C:  MOVLB  5
0A25E:  SETF   x47
0A260:  MOVLB  0
0A262:  CALL   4E6E
....................         
....................      
....................    // HACKY LAB STUFF TO REMOVE LATER 
....................    global_valve_position = VLV_PRECALIBRAION_POSITION;  
0A266:  MOVLW  40
0A268:  MOVWF  xBE
0A26A:  CLRF   xBD
....................    global_valve_position_set_value = VLV_PRECALIBRAION_POSITION;                         
0A26C:  MOVWF  xC0
0A26E:  CLRF   xBF
....................    global_valve_time_to_close_1024th = DEFAULT_VLV_TIME_TO_CLOSE;                         
0A270:  MOVLW  05
0A272:  MOVWF  xC2
0A274:  CLRF   xC1
....................    global_valve_time_to_open_1024th = DEFAULT_VLV_TIME_TO_OPEN;                         
0A276:  MOVWF  xC4
0A278:  CLRF   xC3
....................                             
....................    while(1)                    
....................    {                
....................       // restart the watchdog timer     
....................       restart_wdt();     
0A27A:  CLRWDT
....................    
....................                  
.................... ////////////////////Start of Priority Queue Handling/////////////////////////// 
....................                                                                        
....................       // Timer 2 is used to signal the priority queue to check for another item 
....................       //    to execute. This is only done once every 64ms to NOT keep the  
....................       //    system in a state with the interrupts disabled all the time. 
....................       // Timer 2 is also used to time the control loop.  How often the set point 
....................       //    is re-evaluated and adjustments are made to the actual values is 
....................       //    controlled by control_loop_delay_cycles_left within update_control_loop() 
....................        
....................       // if it is time to check priority queue/control loop 
....................       if (TMR2IF)  
0A27C:  BTFSS  F9E.1
0A27E:  GOTO   AD90
....................       {   
....................          // reset the timer 2 queue loop interrupt 
....................          setup_T2_int(T2_64MS);       
0A282:  MOVLB  5
0A284:  SETF   x47
0A286:  MOVLB  0
0A288:  CALL   4E6E
....................                              
....................          // update the control loop if the system isn't in the system wait (low-power) state 
....................          if (read_system_state() != SYSTEM_IDLE) update_control_loop();            
0A28C:  CALL   1DC6
0A290:  MOVF   01,W
0A292:  SUBLW  03
0A294:  BTFSS  FD8.2
0A296:  GOTO   53C8
....................  
....................          // Safely grab the next item in the priority queue to execute                 
....................          // All interrupts that can modify the queue need to be disabled to                             
....................          //    ensure memory is not corrupted.       
....................          disable_interrupts(INT_CCP4); 
0A29A:  BCF    F7A.1
....................          disable_interrupts(INT_EXT2);        
0A29C:  BCF    FF0.4
....................          priority_queue_item_to_execute = pop_priority_queue();    
0A29E:  GOTO   5BCA
0A2A2:  MOVFF  01,544
....................          enable_interrupts(INT_EXT2);    
0A2A6:  BSF    FF0.4
....................          enable_interrupts(INT_CCP4);              
0A2A8:  BSF    F7A.1
....................                                                        
....................          // execute the priority queue item     
....................          switch (priority_queue_item_to_execute)                                
0A2AA:  MOVLB  5
0A2AC:  MOVF   x44,W
0A2AE:  XORLW  20
0A2B0:  MOVLB  0
0A2B2:  BTFSC  FD8.2
0A2B4:  BRA    A3A6
0A2B6:  XORLW  11
0A2B8:  BTFSC  FD8.2
0A2BA:  BRA    A3E6
0A2BC:  XORLW  03
0A2BE:  BTFSC  FD8.2
0A2C0:  BRA    A484
0A2C2:  XORLW  01
0A2C4:  BTFSC  FD8.2
0A2C6:  BRA    A4A8
0A2C8:  XORLW  07
0A2CA:  BTFSC  FD8.2
0A2CC:  BRA    A4CE
0A2CE:  XORLW  01
0A2D0:  BTFSC  FD8.2
0A2D2:  BRA    A4EE
0A2D4:  XORLW  03
0A2D6:  BTFSC  FD8.2
0A2D8:  BRA    A512
0A2DA:  XORLW  01
0A2DC:  BTFSC  FD8.2
0A2DE:  BRA    A61C
0A2E0:  XORLW  0F
0A2E2:  BTFSC  FD8.2
0A2E4:  BRA    A64C
0A2E6:  XORLW  01
0A2E8:  BTFSC  FD8.2
0A2EA:  BRA    A6AA
0A2EC:  XORLW  05
0A2EE:  BTFSC  FD8.2
0A2F0:  BRA    A6B8
0A2F2:  XORLW  01
0A2F4:  BTFSC  FD8.2
0A2F6:  BRA    A6D6
0A2F8:  XORLW  03
0A2FA:  BTFSC  FD8.2
0A2FC:  BRA    A6F4
0A2FE:  XORLW  01
0A300:  BTFSC  FD8.2
0A302:  BRA    A744
0A304:  XORLW  7F
0A306:  BTFSC  FD8.2
0A308:  BRA    A792
0A30A:  XORLW  10
0A30C:  BTFSC  FD8.2
0A30E:  BRA    A8EC
0A310:  XORLW  01
0A312:  BTFSC  FD8.2
0A314:  BRA    A8EE
0A316:  XORLW  04
0A318:  BTFSC  FD8.2
0A31A:  BRA    A8F0
0A31C:  XORLW  03
0A31E:  BTFSC  FD8.2
0A320:  BRA    A936
0A322:  XORLW  82
0A324:  BTFSC  FD8.2
0A326:  BRA    A94C
0A328:  XORLW  14
0A32A:  BTFSC  FD8.2
0A32C:  BRA    A9BE
0A32E:  XORLW  D1
0A330:  BTFSC  FD8.2
0A332:  BRA    A9E0
0A334:  XORLW  01
0A336:  BTFSC  FD8.2
0A338:  BRA    AA16
0A33A:  XORLW  A4
0A33C:  BTFSC  FD8.2
0A33E:  GOTO   AA66
0A342:  XORLW  01
0A344:  BTFSC  FD8.2
0A346:  GOTO   AA6C
0A34A:  XORLW  16
0A34C:  BTFSC  FD8.2
0A34E:  GOTO   AA72
0A352:  XORLW  07
0A354:  BTFSC  FD8.2
0A356:  GOTO   AA78
0A35A:  XORLW  05
0A35C:  BTFSC  FD8.2
0A35E:  GOTO   AA7E
0A362:  XORLW  03
0A364:  BTFSC  FD8.2
0A366:  GOTO   AA84
0A36A:  XORLW  13
0A36C:  BTFSC  FD8.2
0A36E:  GOTO   AA8A
0A372:  XORLW  03
0A374:  BTFSC  FD8.2
0A376:  GOTO   AB10
0A37A:  XORLW  01
0A37C:  BTFSC  FD8.2
0A37E:  GOTO   AB44
0A382:  XORLW  13
0A384:  BTFSC  FD8.2
0A386:  GOTO   AB78
0A38A:  XORLW  50
0A38C:  BTFSC  FD8.2
0A38E:  GOTO   AB7E
0A392:  XORLW  01
0A394:  BTFSC  FD8.2
0A396:  GOTO   AC24
0A39A:  XORLW  F1
0A39C:  BTFSC  FD8.2
0A39E:  GOTO   AD90
0A3A2:  GOTO   AD90
....................          { 
....................             // Decode a new packet and react/respond appropriately 
....................             case DEAL_WITH_NEW_PACKET:             
....................                // Display that you're dealing with a new packet 
....................                LCD_clear();                                  
0A3A6:  CALL   5C08
....................                strcpy (global_temp_line_buff, "Deal With Packet"); 
0A3AA:  CLRF   FEA
0A3AC:  MOVLW  70
0A3AE:  MOVWF  FE9
0A3B0:  MOVLW  00
0A3B2:  CALL   0676
0A3B6:  TBLRD*-
0A3B8:  TBLRD*+
0A3BA:  MOVF   FF5,W
0A3BC:  MOVWF  FEE
0A3BE:  IORLW  00
0A3C0:  BNZ   A3B8
....................                LCD_line1(global_temp_line_buff); 
0A3C2:  MOVLB  5
0A3C4:  CLRF   x60
0A3C6:  MOVLW  70
0A3C8:  MOVWF  x5F
0A3CA:  MOVLB  0
0A3CC:  CALL   37A0
....................                global_skip_lcd_update_count = 2;      
0A3D0:  MOVLW  02
0A3D2:  MOVWF  x83
....................                                                   
....................                // disable ccp4 and mote interrupt so we don't overwrite payload_buff 
....................                //    or have colliding unsolicited messages 
....................                disable_interrupts(INT_CCP4); 
0A3D4:  BCF    F7A.1
....................                disable_interrupts(INT_EXT2_H2L); 
0A3D6:  BCF    FF0.4
....................                deal_with_packet();  
0A3D8:  GOTO   711E
....................                enable_interrupts(INT_EXT2_H2L);                        
0A3DC:  BSF    FF0.4
0A3DE:  BCF    FF1.4
....................                enable_interrupts(INT_CCP4); 
0A3E0:  BSF    F7A.1
....................                break; 
0A3E2:  GOTO   AD90
....................                 
....................             // Start the somewhat convoluted calibrate valve routine 
....................             // 1. Open valve VLV_CAL_1_MOVEMENT w/ "starting current" 
....................             // 2. Close valve fully w/ current being "normal closing current" 
....................             // 3. Open valve fully w/ normal current regimes 
....................             // 4. Do free spin rate (not done in here at the moment, just skipped).  
....................             // 5. Close valve fully w/ normal current regimes 
....................             // 6. Send valve calibration response to mote    
....................             // steps and system states are handled in COMP and CCP3 ISR as well  
....................             //    as setting the calibration values       
....................                          
....................             case CALIBRATE_VALVE_1: 
....................                // Change system state: initial open for calibrate valve routine 
....................                write_system_state(SYSTEM_CAL_VLV_1);     
0A3E6:  MOVLW  10
0A3E8:  MOVLB  5
0A3EA:  MOVWF  x47
0A3EC:  MOVLB  0
0A3EE:  CALL   30EA
....................                // display calibration routine on screen      
....................                LCD_clear();                          
0A3F2:  CALL   5C08
....................                strcpy (global_temp_line_buff, "VLV Calibration "); 
0A3F6:  CLRF   FEA
0A3F8:  MOVLW  70
0A3FA:  MOVWF  FE9
0A3FC:  MOVLW  00
0A3FE:  CALL   0698
0A402:  TBLRD*-
0A404:  TBLRD*+
0A406:  MOVF   FF5,W
0A408:  MOVWF  FEE
0A40A:  IORLW  00
0A40C:  BNZ   A404
....................                LCD_line1(global_temp_line_buff); 
0A40E:  MOVLB  5
0A410:  CLRF   x60
0A412:  MOVLW  70
0A414:  MOVWF  x5F
0A416:  MOVLB  0
0A418:  CALL   37A0
....................                strcpy (global_temp_line_buff, "Begining........"); 
0A41C:  CLRF   FEA
0A41E:  MOVLW  70
0A420:  MOVWF  FE9
0A422:  MOVLW  00
0A424:  CALL   06BA
0A428:  TBLRD*-
0A42A:  TBLRD*+
0A42C:  MOVF   FF5,W
0A42E:  MOVWF  FEE
0A430:  IORLW  00
0A432:  BNZ   A42A
....................                LCD_line2(global_temp_line_buff); 
0A434:  MOVLB  5
0A436:  CLRF   x60
0A438:  MOVLW  70
0A43A:  MOVWF  x5F
0A43C:  MOVLB  0
0A43E:  CALL   37FA
....................                global_skip_lcd_update_count = 2;   
0A442:  MOVLW  02
0A444:  MOVWF  x83
....................                // setup brakes and charging for valve calibration 
....................                // (maximum resistance with no RPM Control) 
....................                global_control_loop_mechanism = NO_RPM_CONTROL_DYN_MPPC; 
0A446:  MOVLW  06
0A448:  MOVWF  xBC
....................                global_charge_duty_set_value = MAX_CHARGE; 
0A44A:  MOVLW  01
0A44C:  MOVWF  xB5
0A44E:  MOVLW  90
0A450:  MOVWF  xB4
....................                global_brake_duty_set_value = MAX_BRK; 
0A452:  MOVLW  01
0A454:  MOVWF  xB3
0A456:  MOVLW  90
0A458:  MOVWF  xB2
....................                // put values to default values (45 seconds open/close)                                
....................                global_valve_time_to_close_1024th = DEFAULT_VLV_TIME_TO_CLOSE;  
0A45A:  MOVLW  05
0A45C:  MOVWF  xC2
0A45E:  CLRF   xC1
....................                global_valve_time_to_open_1024th = DEFAULT_VLV_TIME_TO_OPEN;               
0A460:  MOVWF  xC4
0A462:  CLRF   xC3
....................                // Set the global valve position to the default value (middle)                  
....................                // this gives the valve a reference point to open a little from 
....................                global_valve_position = VLV_PRECALIBRAION_POSITION; 
0A464:  MOVLW  40
0A466:  MOVWF  xBE
0A468:  CLRF   xBD
....................                // Set valve position slightly more open than it is and move valve 
....................                global_valve_position_set_value = (VLV_PRECALIBRAION_POSITION +                        \ 
....................                VLV_CAL_1_MOVEMENT); 
0A46A:  MOVLW  60
0A46C:  MOVWF  xC0
0A46E:  CLRF   xBF
....................                PUSH_PRIORITY_QUEUE_MACRO(MOVE_VALVE); 
0A470:  BCF    F7A.1
0A472:  MOVLW  40
0A474:  MOVLB  5
0A476:  MOVWF  x4E
0A478:  MOVLB  0
0A47A:  CALL   4538
0A47E:  BSF    F7A.1
....................                break;                                                       
0A480:  GOTO   AD90
....................                 
....................             case CALIBRATE_VALVE_2:                                                                                                        
....................                // Change system state: fully closed 
....................                write_system_state(SYSTEM_CAL_VLV_2); 
0A484:  MOVLW  11
0A486:  MOVLB  5
0A488:  MOVWF  x47
0A48A:  MOVLB  0
0A48C:  CALL   30EA
....................                // set valve position target to fully closed and move valve 
....................                global_valve_position_set_value = VLV_POSITION_CLOSED; 
0A490:  CLRF   xC0
0A492:  CLRF   xBF
....................                PUSH_PRIORITY_QUEUE_MACRO(MOVE_VALVE);                                  
0A494:  BCF    F7A.1
0A496:  MOVLW  40
0A498:  MOVLB  5
0A49A:  MOVWF  x4E
0A49C:  MOVLB  0
0A49E:  CALL   4538
0A4A2:  BSF    F7A.1
....................                break;    
0A4A4:  GOTO   AD90
....................                 
....................             case CALIBRATE_VALVE_3: 
....................                // Change system state: fully closed to fully opened 
....................                write_system_state(SYSTEM_CAL_VLV_3); 
0A4A8:  MOVLW  12
0A4AA:  MOVLB  5
0A4AC:  MOVWF  x47
0A4AE:  MOVLB  0
0A4B0:  CALL   30EA
....................                // set valve position target to fully open and move valve 
....................                global_valve_position_set_value = VLV_POSITION_OPENED; 
0A4B4:  MOVLW  80
0A4B6:  MOVWF  xC0
0A4B8:  CLRF   xBF
....................                PUSH_PRIORITY_QUEUE_MACRO(MOVE_VALVE); 
0A4BA:  BCF    F7A.1
0A4BC:  MOVLW  40
0A4BE:  MOVLB  5
0A4C0:  MOVWF  x4E
0A4C2:  MOVLB  0
0A4C4:  CALL   4538
0A4C8:  BSF    F7A.1
....................                break;      
0A4CA:  GOTO   AD90
....................              
....................            case CALIBRATE_VALVE_4:  
....................                // Change system state: FSR (not used at the moment) 
....................                write_system_state(SYSTEM_CAL_VLV_4);  
0A4CE:  MOVLW  13
0A4D0:  MOVLB  5
0A4D2:  MOVWF  x47
0A4D4:  MOVLB  0
0A4D6:  CALL   30EA
....................                // move to the next calibration stage 
....................                PUSH_PRIORITY_QUEUE_MACRO(CALIBRATE_VALVE_5); 
0A4DA:  BCF    F7A.1
0A4DC:  MOVLW  35
0A4DE:  MOVLB  5
0A4E0:  MOVWF  x4E
0A4E2:  MOVLB  0
0A4E4:  CALL   4538
0A4E8:  BSF    F7A.1
....................                break;       
0A4EA:  GOTO   AD90
....................                 
....................             case CALIBRATE_VALVE_5: 
....................                // Change system state: fully opened to fully closed 
....................                write_system_state(SYSTEM_CAL_VLV_5); 
0A4EE:  MOVLW  14
0A4F0:  MOVLB  5
0A4F2:  MOVWF  x47
0A4F4:  MOVLB  0
0A4F6:  CALL   30EA
....................                // set valve position target to fully closed and move valve 
....................                global_valve_position_set_value = VLV_POSITION_CLOSED; 
0A4FA:  CLRF   xC0
0A4FC:  CLRF   xBF
....................                PUSH_PRIORITY_QUEUE_MACRO(MOVE_VALVE); 
0A4FE:  BCF    F7A.1
0A500:  MOVLW  40
0A502:  MOVLB  5
0A504:  MOVWF  x4E
0A506:  MOVLB  0
0A508:  CALL   4538
0A50C:  BSF    F7A.1
....................                break;      
0A50E:  GOTO   AD90
....................              
....................             case CALIBRATE_VALVE_6: 
....................                // Change system state: display calibration and send to manager 
....................                write_system_state(SYSTEM_CAL_VLV_6); 
0A512:  MOVLW  15
0A514:  MOVLB  5
0A516:  MOVWF  x47
0A518:  MOVLB  0
0A51A:  CALL   30EA
....................                // display calibraion on screen 
....................                LCD_clear(); 
0A51E:  CALL   5C08
....................                strcpy (global_temp_line_buff, "Close CCP=      "); 
0A522:  CLRF   FEA
0A524:  MOVLW  70
0A526:  MOVWF  FE9
0A528:  MOVLW  00
0A52A:  CALL   06DC
0A52E:  TBLRD*-
0A530:  TBLRD*+
0A532:  MOVF   FF5,W
0A534:  MOVWF  FEE
0A536:  IORLW  00
0A538:  BNZ   A530
....................                LCD_line1(global_temp_line_buff); 
0A53A:  MOVLB  5
0A53C:  CLRF   x60
0A53E:  MOVLW  70
0A540:  MOVWF  x5F
0A542:  MOVLB  0
0A544:  CALL   37A0
....................                strcpy (global_temp_line_buff, "Open CCP =      "); 
0A548:  CLRF   FEA
0A54A:  MOVLW  70
0A54C:  MOVWF  FE9
0A54E:  MOVLW  00
0A550:  CALL   06FE
0A554:  TBLRD*-
0A556:  TBLRD*+
0A558:  MOVF   FF5,W
0A55A:  MOVWF  FEE
0A55C:  IORLW  00
0A55E:  BNZ   A556
....................                LCD_line2(global_temp_line_buff); 
0A560:  MOVLB  5
0A562:  CLRF   x60
0A564:  MOVLW  70
0A566:  MOVWF  x5F
0A568:  MOVLB  0
0A56A:  CALL   37FA
....................                LCD_place_uint16(global_valve_time_to_close_1024th,0,11,5); 
0A56E:  MOVFF  C2,560
0A572:  MOVFF  C1,55F
0A576:  MOVLB  5
0A578:  CLRF   x61
0A57A:  MOVLW  0B
0A57C:  MOVWF  x62
0A57E:  MOVLW  05
0A580:  MOVWF  x63
0A582:  MOVLB  0
0A584:  CALL   6828
....................                LCD_place_uint16(global_valve_time_to_open_1024th,1,11,5); 
0A588:  MOVFF  C4,560
0A58C:  MOVFF  C3,55F
0A590:  MOVLW  01
0A592:  MOVLB  5
0A594:  MOVWF  x61
0A596:  MOVLW  0B
0A598:  MOVWF  x62
0A59A:  MOVLW  05
0A59C:  MOVWF  x63
0A59E:  MOVLB  0
0A5A0:  CALL   6828
....................                // put calibration stuff on screen for 4 seconds 
....................                global_skip_lcd_update_count = 5;      
0A5A4:  MOVLW  05
0A5A6:  MOVWF  x83
....................                // if valve calibration time is below the limit, it triggers an error 
....................                //    and throws away the calibration, returning it to the run state. 
....................                if ((global_valve_time_to_close_1024th < ERROR_VLV_CAL_TIME) || \ 
....................                   (global_valve_time_to_open_1024th < ERROR_VLV_CAL_TIME)) 
0A5A8:  MOVF   xC2,W
0A5AA:  SUBLW  02
0A5AC:  BNC   A5B6
0A5AE:  BNZ   A5C4
0A5B0:  MOVF   xC1,W
0A5B2:  SUBLW  ED
0A5B4:  BC    A5C4
0A5B6:  MOVF   xC4,W
0A5B8:  SUBLW  02
0A5BA:  BNC   A5E8
0A5BC:  BNZ   A5C4
0A5BE:  MOVF   xC3,W
0A5C0:  SUBLW  ED
0A5C2:  BNC   A5E8
....................                { 
....................                   // reset valve calibration times to the defaults 
....................                   global_valve_time_to_open_1024th = DEFAULT_VLV_TIME_TO_OPEN; 
0A5C4:  MOVLW  05
0A5C6:  MOVWF  xC4
0A5C8:  CLRF   xC3
....................                   global_valve_time_to_close_1024th = DEFAULT_VLV_TIME_TO_CLOSE; 
0A5CA:  MOVWF  xC2
0A5CC:  CLRF   xC1
....................                   // change valve position to unknown 
....................                   global_valve_position = VLV_POSITION_UNKNOWN; 
0A5CE:  SETF   xBE
0A5D0:  SETF   xBD
....................                   // set the error bitfield and send an error 
....................                   global_error_message_bitfield |= ERR_MSG_VLV_CAL_FAIL; 
0A5D2:  MOVLB  4
0A5D4:  BSF    xF5.1
....................                   PUSH_MESSAGE_QUEUE_MACRO(MSG_MOTE_ERROR_MSG); 
0A5D6:  BCF    F7A.1
0A5D8:  MOVLW  A0
0A5DA:  MOVLB  5
0A5DC:  MOVWF  x50
0A5DE:  MOVLB  0
0A5E0:  CALL   4FE0
0A5E4:  BSF    F7A.1
....................                } 
0A5E6:  BRA    A60C
....................                // successful/valid calibration time 
....................                else 
....................                { 
....................                   // update the calibration time 
....................                   global_valve_calibration_utc_time = global_utc_time; 
0A5E8:  MOVFF  8C,CA
0A5EC:  MOVFF  8B,C9
0A5F0:  MOVFF  8A,C8
0A5F4:  MOVFF  89,C7
....................                   // store calibrations in eeprom 
....................                   store_vcal_eeprom_values(); 
0A5F8:  GOTO   805E
....................                   // send an unsolicited valve report to the manager 
....................                   PUSH_MESSAGE_QUEUE_MACRO(MSG_MOTE_VALVE_REPORT); 
0A5FC:  BCF    F7A.1
0A5FE:  MOVLW  92
0A600:  MOVLB  5
0A602:  MOVWF  x50
0A604:  MOVLB  0
0A606:  CALL   4FE0
0A60A:  BSF    F7A.1
....................                } 
....................                // put system in run state 
....................                write_system_state(SYSTEM_RUN); 
0A60C:  MOVLW  02
0A60E:  MOVLB  5
0A610:  MOVWF  x47
0A612:  MOVLB  0
0A614:  CALL   30EA
....................                break;      
0A618:  GOTO   AD90
....................                             
....................             // FSR IS LARGELY UNTESTED EVEN THOUGH IT'S BASICALLY ALL WRITTEN!                
....................             // move valve to position specified by calibrate FSR routine    
....................             case CALIBRATE_FSR_1: 
....................                // set system state                       
....................                write_system_state(SYSTEM_CAL_FSR_1);                                          
0A61C:  MOVLW  18
0A61E:  MOVLB  5
0A620:  MOVWF  x47
0A622:  MOVLB  0
0A624:  CALL   30EA
....................                // save the current valve, so we can return to it later 
....................                pre_fsr_valve_setting = global_valve_position;      
0A628:  MOVFF  BE,546
0A62C:  MOVFF  BD,545
....................                // move valve to the FSR position                          
....................                global_valve_position_set_value = global_calibrate_fsr_valve_position;  
0A630:  MOVFF  CD,C0
0A634:  MOVFF  CC,BF
....................                PUSH_PRIORITY_QUEUE_MACRO(MOVE_VALVE);                             
0A638:  BCF    F7A.1
0A63A:  MOVLW  40
0A63C:  MOVLB  5
0A63E:  MOVWF  x4E
0A640:  MOVLB  0
0A642:  CALL   4538
0A646:  BSF    F7A.1
....................                break;          
0A648:  GOTO   AD90
....................                                                                                          
....................             case CALIBRATE_FSR_2: 
....................                // set system state 
....................                write_system_state(SYSTEM_CAL_FSR_2);    
0A64C:  MOVLW  19
0A64E:  MOVLB  5
0A650:  MOVWF  x47
0A652:  MOVLB  0
0A654:  CALL   30EA
....................                // disable ccp5 for a quick second 
....................                disable_interrupts(INT_CCP5); 
0A658:  BCF    F7A.2
....................                // actually measure the FSR and store it  
....................                global_calibrate_fsr_period = global_current_period;    
0A65A:  MOVFF  A5,CF
0A65E:  MOVFF  A4,CE
....................                // restore ccp5 
....................                enable_interrupts(INT_CCP5);      
0A662:  BSF    F7A.2
....................                // store the fsr calibration time 
....................                global_calibrate_fsr_utc_time = global_utc_time;    
0A664:  MOVFF  8C,D3
0A668:  MOVFF  8B,D2
0A66C:  MOVFF  8A,D1
0A670:  MOVFF  89,D0
....................                                      
....................                // move valve to the FSR position 
....................                global_valve_position_set_value = pre_fsr_valve_setting;   
0A674:  MOVFF  546,C0
0A678:  MOVFF  545,BF
....................                PUSH_PRIORITY_QUEUE_MACRO(MOVE_VALVE);     
0A67C:  BCF    F7A.1
0A67E:  MOVLW  40
0A680:  MOVLB  5
0A682:  MOVWF  x4E
0A684:  MOVLB  0
0A686:  CALL   4538
0A68A:  BSF    F7A.1
....................                                                   
....................                PUSH_MESSAGE_QUEUE_MACRO(MSG_MOTE_VALVE_REPORT); 
0A68C:  BCF    F7A.1
0A68E:  MOVLW  92
0A690:  MOVLB  5
0A692:  MOVWF  x50
0A694:  MOVLB  0
0A696:  CALL   4FE0
0A69A:  BSF    F7A.1
....................                write_system_state(SYSTEM_RUN); 
0A69C:  MOVLW  02
0A69E:  MOVLB  5
0A6A0:  MOVWF  x47
0A6A2:  MOVLB  0
0A6A4:  CALL   30EA
....................                break;                                   
0A6A8:  BRA    AD90
....................                 
....................             case CALIBRATE_FSR_3: 
....................                write_system_state(SYSTEM_CAL_FSR_3); 
0A6AA:  MOVLW  1A
0A6AC:  MOVLB  5
0A6AE:  MOVWF  x47
0A6B0:  MOVLB  0
0A6B2:  CALL   30EA
....................                break;         
0A6B6:  BRA    AD90
....................             /*    
....................             case CALIBRATE_FSR_4: 
....................                write_system_state(SYSTEM_CAL_FSR_4); 
....................                LCD_clear(); 
....................                LCD_place_uint16(global_valve_position,0,0,5); 
....................                LCD_place_uint16(global_valve_time_to_close_1024th,0,6,5); 
....................                LCD_place_uint16(global_valve_time_to_open_1024th,0,11,5); 
....................                LCD_place_uint16(global_valve_position,1,0,5); 
....................                LCD_place_uint16(global_valve_position,1,11,5); 
....................                LCD_place_uint16(global_valve_position,1,11,5); 
....................                // put calibration stuff on screen for 4 seconds 
....................                global_skip_lcd_update_count = 5; 
....................                global_calibrate_fsr_utc_time 
....................                 
....................                write_system_state(SYSTEM_RUN); 
....................                break;          
....................                */             
....................                 
....................                 
....................             case MOVE_VALVE_MAG_DECOUPLING_RECOVERY: 
....................                // move the valve to VLV_MAGNETIC_COUPLING_FIX 
....................                global_valve_position_set_value = VLV_MAGNETIC_COUPLING_FIX; 
0A6B8:  MOVFF  51C,C0
0A6BC:  MOVFF  51B,BF
....................                PUSH_PRIORITY_QUEUE_MACRO(MOVE_VALVE); 
0A6C0:  BCF    F7A.1
0A6C2:  MOVLW  40
0A6C4:  MOVLB  5
0A6C6:  MOVWF  x4E
0A6C8:  MOVLB  0
0A6CA:  CALL   4538
0A6CE:  BSF    F7A.1
....................                // change control loop scheme  
....................                global_control_loop_mechanism = MAG_DECOUPLING_RECOVERY; 
0A6D0:  MOVLW  09
0A6D2:  MOVWF  xBC
....................                break; 
0A6D4:  BRA    AD90
....................                 
....................             case MOVE_VALVE_NO_SPIN_RECOVERY: 
....................                // move the valve to VLV_NOT_SPIN_FIX 
....................                global_valve_position_set_value = VLV_NOT_SPIN_FIX; 
0A6D6:  MOVFF  517,C0
0A6DA:  MOVFF  516,BF
....................                PUSH_PRIORITY_QUEUE_MACRO(MOVE_VALVE); 
0A6DE:  BCF    F7A.1
0A6E0:  MOVLW  40
0A6E2:  MOVLB  5
0A6E4:  MOVWF  x4E
0A6E6:  MOVLB  0
0A6E8:  CALL   4538
0A6EC:  BSF    F7A.1
....................                // change control loop scheme 
....................                global_control_loop_mechanism = NO_SPIN_RECOVERY; 
0A6EE:  MOVLW  08
0A6F0:  MOVWF  xBC
....................                break; 
0A6F2:  BRA    AD90
....................                                                
....................             // Opens valve irrespective of the position. Used for shutting down the system (and leaving 
....................             //    the valve open) and for test purposes.  Added very quickly in Nebraska.                  
....................             case OPEN_VALVE_UNKNOWN_STATE:                             
....................                // clear out the time in motion 
....................                global_valve_time_in_motion_1024ths = 0;      
0A6F4:  CLRF   xC6
0A6F6:  CLRF   xC5
....................                 
....................                global_valve_position_set_value = VLV_POSITION_OPENED; 
0A6F8:  MOVLW  80
0A6FA:  MOVWF  xC0
0A6FC:  CLRF   xBF
....................                CCP_3 = global_valve_time_to_open_1024th;  
0A6FE:  MOVFF  C4,F5F
0A702:  MOVFF  C3,F5E
....................                // start the valve opening 
....................                mV_OPENm;          
0A706:  MOVLW  02
0A708:  MOVWF  F8D
....................                // setup/turn on the comparator interrupt (also sets up DAC) 
....................                comparator_setup(); 
0A70A:  CALL   81EA
....................                 
....................                // setup and enable CCP3 as well as it's respective timer 
....................                setup_ccp3(CCP_USE_TIMER1_AND_TIMER2 | CCP_COMPARE_RESET_TIMER); 
0A70E:  MOVLW  0B
0A710:  MOVLB  F
0A712:  MOVWF  x5D
0A714:  CLRF   x5C
0A716:  CLRF   x5B
0A718:  MOVLW  01
0A71A:  MOVWF  x5A
0A71C:  MOVLW  3F
0A71E:  ANDWF  x49,F
0A720:  MOVLW  00
0A722:  IORWF  x49,F
....................                setup_timer_1(T1_ENABLE_SOSC | T1_EXTERNAL_SYNC | T1_DIV_BY_1); 
0A724:  MOVLW  8B
0A726:  MOVWF  FCD
0A728:  CLRF   FCC
....................                set_timer1(0); 
0A72A:  CLRF   FCF
0A72C:  CLRF   FCE
....................                                                                           
....................                // clear any ccp3 interrupt and enable ccp3 interrupt 
....................                clear_interrupt(INT_CCP3);                
0A72E:  BCF    F7B.0
....................                enable_interrupts(INT_CCP3);  
0A730:  BSF    F7A.0
....................                 
....................                // JG: previously there was no "break;" here.  Rather the 
....................                // following case was MOVE_VALVE. I believe this accomplishes 
....................                // the same thing. 
....................                PUSH_PRIORITY_QUEUE_MACRO(MOVE_VALVE); 
0A732:  BCF    F7A.1
0A734:  MOVLW  40
0A736:  MOVLB  5
0A738:  MOVWF  x4E
0A73A:  MOVLB  0
0A73C:  CALL   4538
0A740:  BSF    F7A.1
....................                break; 
0A742:  BRA    AD90
....................  
....................              
....................             // Closes valve irrespective of the position. Used for shutting down the system (and leaving 
....................             //    the valve closed) and for test purposes. 
....................             case CLOSE_VALVE_UNKNOWN_STATE:                             
....................                // clear out the time in motion 
....................                global_valve_time_in_motion_1024ths = 0;      
0A744:  CLRF   xC6
0A746:  CLRF   xC5
....................                 
....................                global_valve_position_set_value = VLV_POSITION_CLOSED; 
0A748:  CLRF   xC0
0A74A:  CLRF   xBF
....................                CCP_3 = global_valve_time_to_open_1024th;  
0A74C:  MOVFF  C4,F5F
0A750:  MOVFF  C3,F5E
....................                // start the valve opening 
....................                mV_CLOSEm;          
0A754:  MOVLW  01
0A756:  MOVWF  F8D
....................                // setup/turn on the comparator interrupt (also sets up DAC) 
....................                comparator_setup(); 
0A758:  CALL   81EA
....................                 
....................                // setup and enable CCP3 as well as it's respective timer 
....................                setup_ccp3(CCP_USE_TIMER1_AND_TIMER2 | CCP_COMPARE_RESET_TIMER); 
0A75C:  MOVLW  0B
0A75E:  MOVLB  F
0A760:  MOVWF  x5D
0A762:  CLRF   x5C
0A764:  CLRF   x5B
0A766:  MOVLW  01
0A768:  MOVWF  x5A
0A76A:  MOVLW  3F
0A76C:  ANDWF  x49,F
0A76E:  MOVLW  00
0A770:  IORWF  x49,F
....................                setup_timer_1(T1_ENABLE_SOSC | T1_EXTERNAL_SYNC | T1_DIV_BY_1); 
0A772:  MOVLW  8B
0A774:  MOVWF  FCD
0A776:  CLRF   FCC
....................                set_timer1(0); 
0A778:  CLRF   FCF
0A77A:  CLRF   FCE
....................                                                                           
....................                // clear any ccp3 interrupt and enable ccp3 interrupt 
....................                clear_interrupt(INT_CCP3);                
0A77C:  BCF    F7B.0
....................                enable_interrupts(INT_CCP3);    
0A77E:  BSF    F7A.0
....................                PUSH_PRIORITY_QUEUE_MACRO(MOVE_VALVE); 
0A780:  BCF    F7A.1
0A782:  MOVLW  40
0A784:  MOVLB  5
0A786:  MOVWF  x4E
0A788:  MOVLB  0
0A78A:  CALL   4538
0A78E:  BSF    F7A.1
....................                break;                                     
0A790:  BRA    AD90
....................                                             
....................                                             
....................             case MOVE_VALVE:               
....................                // if the system is in the SYSTEM_IDLE state, bump it into the SYSTEM_RUN state. 
....................                if (read_system_state() == SYSTEM_IDLE) write_system_state(SYSTEM_RUN);      
0A792:  CALL   1DC6
0A796:  MOVF   01,W
0A798:  SUBLW  03
0A79A:  BNZ   A7A8
0A79C:  MOVLW  02
0A79E:  MOVLB  5
0A7A0:  MOVWF  x47
0A7A2:  MOVLB  0
0A7A4:  CALL   30EA
....................                                                       
....................                // if system is in an undesireable state, don't move the valve 
....................                //    and send an error message                                   
....................                // Undesirable states such as unkown or init 
....................                if ((read_system_state() == SYSTEM_STATE_UNKNOWN)||            \ 
....................                   (read_system_state() == SYSTEM_INIT)) 
0A7A8:  CALL   1DC6
0A7AC:  INCFSZ 01,W
0A7AE:  BRA    A7B2
0A7B0:  BRA    A7BA
0A7B2:  CALL   1DC6
0A7B6:  MOVF   01,F
0A7B8:  BNZ   A7D2
....................                {                                    
....................                   global_error_message_bitfield |= ERR_MSG_INCOMPATIBLE_STATE; 
0A7BA:  MOVLB  4
0A7BC:  BSF    xF4.1
....................                   PUSH_MESSAGE_QUEUE_MACRO(MSG_MOTE_ERROR_MSG); 
0A7BE:  BCF    F7A.1
0A7C0:  MOVLW  A0
0A7C2:  MOVLB  5
0A7C4:  MOVWF  x50
0A7C6:  MOVLB  0
0A7C8:  CALL   4FE0
0A7CC:  BSF    F7A.1
....................                   break;                                  
0A7CE:  BRA    AD90
....................                } 
0A7D0:  BRA    A7FA
....................                // or if you're in the run state and the valve is uncalibrated 
....................                else if ((read_system_state() == SYSTEM_RUN) &&                \ 
....................                   (global_valve_position == VLV_POSITION_UNKNOWN)) 
0A7D2:  CALL   1DC6
0A7D6:  MOVF   01,W
0A7D8:  SUBLW  02
0A7DA:  BNZ   A7FA
0A7DC:  INCFSZ xBD,W
0A7DE:  BRA    A7FA
0A7E0:  INCFSZ xBE,W
0A7E2:  BRA    A7FA
....................                { 
....................                   global_error_message_bitfield |= ERR_MSG_VLV_NOT_CALIBRATED; 
0A7E4:  MOVLB  4
0A7E6:  BSF    xF4.2
....................                   PUSH_MESSAGE_QUEUE_MACRO(MSG_MOTE_ERROR_MSG); 
0A7E8:  BCF    F7A.1
0A7EA:  MOVLW  A0
0A7EC:  MOVLB  5
0A7EE:  MOVWF  x50
0A7F0:  MOVLB  0
0A7F2:  CALL   4FE0
0A7F6:  BSF    F7A.1
....................                   break; 
0A7F8:  BRA    AD90
....................                } 
....................                                             
....................                // if valve movement is not needed (less than one millispan away 
....................                //    and in run state), break out of switch case 
....................                if ((read_system_state() == SYSTEM_RUN) &&                     \ 
....................                (((global_valve_position_set_value - global_valve_position) < 0x20) || \ 
....................                ((global_valve_position - global_valve_position_set_value) < 0x20))) 
0A7FA:  CALL   1DC6
0A7FE:  MOVF   01,W
0A800:  SUBLW  02
0A802:  BNZ   A84E
0A804:  MOVF   xBD,W
0A806:  SUBWF  xBF,W
0A808:  MOVLB  5
0A80A:  MOVWF  x47
0A80C:  MOVLB  0
0A80E:  MOVF   xBE,W
0A810:  SUBWFB xC0,W
0A812:  MOVLB  5
0A814:  MOVWF  x48
0A816:  MOVF   x48,F
0A818:  BNZ   A820
0A81A:  MOVF   x47,W
0A81C:  SUBLW  1F
0A81E:  BC    A84A
0A820:  MOVLB  0
0A822:  MOVF   xBF,W
0A824:  SUBWF  xBD,W
0A826:  MOVLB  5
0A828:  MOVWF  x47
0A82A:  MOVLB  0
0A82C:  MOVF   xC0,W
0A82E:  SUBWFB xBE,W
0A830:  MOVLB  5
0A832:  MOVWF  x48
0A834:  MOVF   x48,F
0A836:  BTFSC  FD8.2
0A838:  BRA    A83E
0A83A:  MOVLB  0
0A83C:  BRA    A84E
0A83E:  MOVF   x47,W
0A840:  SUBLW  1F
0A842:  BTFSC  FD8.0
0A844:  BRA    A84A
0A846:  MOVLB  0
0A848:  BRA    A84E
....................                {                
....................                   break;    
0A84A:  MOVLB  0
0A84C:  BRA    AD90
....................                }              
....................                                        
....................                // clear out the time in motion 
....................                global_valve_time_in_motion_1024ths = 0;   
0A84E:  CLRF   xC6
0A850:  CLRF   xC5
....................                 
....................                // increment the movements since hitting an endstop. Also, check if 
....................                // enough valve movements have happened to warrant a recalibration of 
....................                //    the position of the valve by going towards an endstop 
....................                if ((global_valve_movements_since_endstop++) > VLV_MOVES_BEFORE_RECAL) 
0A852:  MOVF   xCB,W
0A854:  INCF   xCB,F
0A856:  SUBLW  19
0A858:  BC    A85C
....................                { 
.................... #IFNDEF  DISABLE_RECAL_VLV                        
....................                   write_system_state(SYSTEM_RECAL_VLV_MOVES);                         
....................                   // quicker to go to the closed endstop. Start motion. 
....................                   if ((global_valve_position_set_value + global_valve_position) >\ 
....................                      VLV_POSITION_OPENED) 
....................                   { 
....................                      CCP_3 = global_valve_time_to_close_1024th; 
....................                      mV_CLOSEm;                                                                    
....................                   } 
....................                   // quicker to go to the open endstop. Start motion. 
....................                   else    
....................                   { 
....................                      CCP_3 = global_valve_time_to_open_1024th; 
....................                      // don't go to the open endstop to avoid magnetic decoupling 
....................                      //mV_OPENm; 
....................                      mV_CLOSEm; 
....................                   } 
....................  #ENDIF 
....................                } 
0A85A:  BRA    A8C0
....................                 
....................                // regular valve move (without recalibration) 
....................                else 
....................                { 
....................                   // setup CCP3 and put the valve into motion based on target value 
....................                   if (global_valve_position_set_value > global_valve_position) 
0A85C:  MOVF   xBE,W
0A85E:  SUBWF  xC0,W
0A860:  BNC   A878
0A862:  BNZ   A86A
0A864:  MOVF   xBF,W
0A866:  SUBWF  xBD,W
0A868:  BC    A878
....................                   { 
....................                      CCP_3 = global_valve_time_to_open_1024th; 
0A86A:  MOVFF  C4,F5F
0A86E:  MOVFF  C3,F5E
....................                      mV_OPENm;  
0A872:  MOVLW  02
0A874:  MOVWF  F8D
....................                   } 
0A876:  BRA    A8C0
....................                   else if (global_valve_position_set_value < global_valve_position) 
0A878:  MOVF   xC0,W
0A87A:  SUBWF  xBE,W
0A87C:  BNC   A894
0A87E:  BNZ   A886
0A880:  MOVF   xBD,W
0A882:  SUBWF  xBF,W
0A884:  BC    A894
....................                   { 
....................                      CCP_3 = global_valve_time_to_close_1024th; 
0A886:  MOVFF  C2,F5F
0A88A:  MOVFF  C1,F5E
....................                      mV_CLOSEm; 
0A88E:  MOVLW  01
0A890:  MOVWF  F8D
....................                   } 
0A892:  BRA    A8C0
....................                   else if (global_valve_position_set_value == VLV_POSITION_OPENED) 
0A894:  MOVF   xBF,F
0A896:  BNZ   A8AC
0A898:  MOVF   xC0,W
0A89A:  SUBLW  80
0A89C:  BNZ   A8AC
....................                   { 
....................                      CCP_3 = global_valve_time_to_open_1024th; 
0A89E:  MOVFF  C4,F5F
0A8A2:  MOVFF  C3,F5E
....................                      mV_OPENm;   
0A8A6:  MOVLW  02
0A8A8:  MOVWF  F8D
....................                   } 
0A8AA:  BRA    A8C0
....................                   else if (global_valve_position_set_value == VLV_POSITION_CLOSED) 
0A8AC:  MOVF   xBF,F
0A8AE:  BNZ   A8C0
0A8B0:  MOVF   xC0,F
0A8B2:  BNZ   A8C0
....................                   { 
....................                      CCP_3 = global_valve_time_to_close_1024th; 
0A8B4:  MOVFF  C2,F5F
0A8B8:  MOVFF  C1,F5E
....................                      mV_CLOSEm; 
0A8BC:  MOVLW  01
0A8BE:  MOVWF  F8D
....................                   }                  
....................                }    
....................                 
....................                // setup/turn on the comparator interrupt (also sets up DAC) 
....................                comparator_setup();                                          
0A8C0:  CALL   81EA
....................                 
....................                // setup and enable CCP3 as well as it's respective timer 
....................                setup_ccp3(CCP_USE_TIMER1_AND_TIMER2 | CCP_COMPARE_RESET_TIMER); 
0A8C4:  MOVLW  0B
0A8C6:  MOVLB  F
0A8C8:  MOVWF  x5D
0A8CA:  CLRF   x5C
0A8CC:  CLRF   x5B
0A8CE:  MOVLW  01
0A8D0:  MOVWF  x5A
0A8D2:  MOVLW  3F
0A8D4:  ANDWF  x49,F
0A8D6:  MOVLW  00
0A8D8:  IORWF  x49,F
....................                setup_timer_1(T1_ENABLE_SOSC | T1_EXTERNAL_SYNC | T1_DIV_BY_1); 
0A8DA:  MOVLW  8B
0A8DC:  MOVWF  FCD
0A8DE:  CLRF   FCC
....................                set_timer1(0); 
0A8E0:  CLRF   FCF
0A8E2:  CLRF   FCE
....................                 
....................                // clear any ccp3 interrupt and enable ccp3 interrupt 
....................                clear_interrupt(INT_CCP3); 
0A8E4:  BCF    F7B.0
....................                enable_interrupts(INT_CCP3);            
0A8E6:  BSF    F7A.0
....................                break; 
0A8E8:  MOVLB  0
0A8EA:  BRA    AD90
....................                 
....................             // Start GPS aquisition 
....................             case START_GPS_AQUISITION: 
....................                break; 
0A8EC:  BRA    AD90
....................                                                      
....................             // Check GPS for lock 
....................             case CHECK_GPS_FOR_LOCK:     
....................                break;                    
0A8EE:  BRA    AD90
....................                             
....................             case TAKE_XCDR_MESUREMENT_1: 
....................                // turn on XDCR power (must give ~50ms to settle) 
....................                output_high(XDCR_PWR);                     
0A8F0:  BSF    F8B.5
....................                // queue up the actual meaurement a second later.                    
....................                PUSH_TIME_QUEUE_MACRO(global_rtc_time + 1, TAKE_XCDR_MESUREMENT_2); 
0A8F2:  BCF    F7A.1
0A8F4:  MOVLW  01
0A8F6:  ADDWF  x85,W
0A8F8:  MOVLB  5
0A8FA:  MOVWF  x47
0A8FC:  MOVLW  00
0A8FE:  MOVLB  0
0A900:  ADDWFC x86,W
0A902:  MOVLB  5
0A904:  MOVWF  x48
0A906:  MOVLW  00
0A908:  MOVLB  0
0A90A:  ADDWFC x87,W
0A90C:  MOVLB  5
0A90E:  MOVWF  x49
0A910:  MOVLW  00
0A912:  MOVLB  0
0A914:  ADDWFC x88,W
0A916:  MOVLB  5
0A918:  MOVWF  x4A
0A91A:  MOVWF  x55
0A91C:  MOVFF  549,554
0A920:  MOVFF  548,553
0A924:  MOVFF  547,552
0A928:  MOVLW  56
0A92A:  MOVWF  x56
0A92C:  MOVLB  0
0A92E:  CALL   4290
0A932:  BSF    F7A.1
....................                break; 
0A934:  BRA    AD90
....................                                                                                      
....................             case TAKE_XCDR_MESUREMENT_2:    
....................                // take the actual xdcr measurement via the adc (stores the result in global_xdcr_output)     
....................                adc_XDCR_measure();     
0A936:  GOTO   8218
....................                // add xdcr message to queue                       
....................                PUSH_MESSAGE_QUEUE_MACRO(MSG_MOTE_XDCR_READ_MSG);  
0A93A:  BCF    F7A.1
0A93C:  MOVLW  98
0A93E:  MOVLB  5
0A940:  MOVWF  x50
0A942:  MOVLB  0
0A944:  CALL   4FE0
0A948:  BSF    F7A.1
....................                break;                                             
0A94A:  BRA    AD90
....................                                         
....................             // Update the LCD 
....................             // In the future, we're going to have "pages" controlled by the switch. 
....................             case LCD_UPDATE:           
....................                // instructed to skip this update (to show other things on screen)          
....................                 
....................                // disable button press interrupt while accessing shared global lcd variables 
.................... //               disable_interrupts(INT_RB);    
....................                 
....................                // check if long press has exceeded time limit and indicate 
....................                //  to user if so 
....................                 
....................                if (sw1_start_time && ((global_rtc_time - sw1_start_time) > SW1_ISR_LONG_PRESS_TIME)) 
0A94C:  MOVF   x8D,F
0A94E:  BNZ   A95C
0A950:  MOVF   x8E,F
0A952:  BNZ   A95C
0A954:  MOVF   x8F,F
0A956:  BNZ   A95C
0A958:  MOVF   x90,F
0A95A:  BZ    A9AE
0A95C:  MOVF   x8D,W
0A95E:  SUBWF  x85,W
0A960:  MOVLB  5
0A962:  MOVWF  x47
0A964:  MOVLB  0
0A966:  MOVF   x8E,W
0A968:  SUBWFB x86,W
0A96A:  MOVLB  5
0A96C:  MOVWF  x48
0A96E:  MOVLB  0
0A970:  MOVF   x8F,W
0A972:  SUBWFB x87,W
0A974:  MOVLB  5
0A976:  MOVWF  x49
0A978:  MOVLB  0
0A97A:  MOVF   x90,W
0A97C:  SUBWFB x88,W
0A97E:  MOVLB  5
0A980:  MOVWF  x4A
0A982:  MOVF   x4A,F
0A984:  BNZ   A99A
0A986:  MOVF   x49,F
0A988:  BNZ   A99A
0A98A:  MOVF   x48,F
0A98C:  BNZ   A99A
0A98E:  MOVF   x47,W
0A990:  SUBLW  05
0A992:  BTFSS  FD8.0
0A994:  BRA    A99A
0A996:  MOVLB  0
0A998:  BRA    A9AE
....................                { 
....................                   flash_led_2(4); 
0A99A:  MOVLW  04
0A99C:  MOVWF  x47
0A99E:  MOVLB  0
0A9A0:  GOTO   8270
....................                   sw1_start_time = 0; 
0A9A4:  CLRF   x90
0A9A6:  CLRF   x8F
0A9A8:  CLRF   x8E
0A9AA:  CLRF   x8D
....................                } 
0A9AC:  BRA    A9BC
....................  
....................                else if (global_skip_lcd_update_count > 1)   
0A9AE:  MOVF   x83,W
0A9B0:  SUBLW  01
0A9B2:  BC    A9B8
....................                {                   
....................                   global_skip_lcd_update_count--;     
0A9B4:  DECF   x83,F
....................                } 
0A9B6:  BRA    A9BC
....................                // either normal update or screen clear and update via function call (for multiple pages)     
....................                else                  
....................                {        
....................                   LCD_update_diplay();             
0A9B8:  GOTO   86AA
....................                } 
....................                 
....................                // disable button press interrupt while accessing shared global lcd variables 
.................... //               enable_interrupts(INT_RB);  
....................                  
....................                break;                                          
0A9BC:  BRA    AD90
....................                 
....................             // recovers from an i2c bus collision interrupt 
....................             case BUSCOL_RESET:                    
....................                BCL1IF = FALSE; 
0A9BE:  BCF    FA1.3
....................                SSP1IF = TRUE; 
0A9C0:  BSF    F9E.3
....................                i2c_init(TRUE);             
0A9C2:  BCF    FCB.0
0A9C4:  BCF    FCB.1
0A9C6:  BCF    FCB.3
0A9C8:  MOVLW  06
0A9CA:  MOVWF  FC8
0A9CC:  MOVLW  28
0A9CE:  MOVWF  FC6
0A9D0:  BSF    FC7.7
0A9D2:  BCF    FC7.6
....................                if (global_lcd_enabled) LCD_init();   
0A9D4:  BTFSC  xA3.0
0A9D6:  CALL   3856
....................                enable_interrupts(GLOBAL);          
0A9DA:  MOVLW  C0
0A9DC:  IORWF  FF2,F
....................                break;                                                    
0A9DE:  BRA    AD90
....................                 
....................             // Reset the mote (triggers a wait for boot event) 
....................             case RESET_MOTE:      
....................                // display on screen what is happening 
....................                LCD_clear();             
0A9E0:  CALL   5C08
....................                strcpy (global_temp_line_buff, "Resetting Mote!!"); 
0A9E4:  CLRF   FEA
0A9E6:  MOVLW  70
0A9E8:  MOVWF  FE9
0A9EA:  MOVLW  00
0A9EC:  CALL   0720
0A9F0:  TBLRD*-
0A9F2:  TBLRD*+
0A9F4:  MOVF   FF5,W
0A9F6:  MOVWF  FEE
0A9F8:  IORLW  00
0A9FA:  BNZ   A9F2
....................                LCD_line1(global_temp_line_buff); 
0A9FC:  MOVLB  5
0A9FE:  CLRF   x60
0AA00:  MOVLW  70
0AA02:  MOVWF  x5F
0AA04:  MOVLB  0
0AA06:  CALL   37A0
....................                global_skip_lcd_update_count = 2;    
0AA0A:  MOVLW  02
0AA0C:  MOVWF  x83
....................                // disable mote enabled flag 
....................                global_dust_enabled = 0;      
0AA0E:  BCF    xA3.6
....................                // reset the mote    
....................                mote_reset();  
0AA10:  CALL   44DE
....................                break;                            
0AA14:  BRA    AD90
....................              
....................             // Make sure the mote is responding to a boot or shutdown 
....................             case WAIT_FOR_BOOT_EVENT:     
....................                // if the mote didn't respond, set error, open valve, shutdown 
....................                if (global_dust_enabled == 0) 
0AA16:  BTFSC  xA3.6
0AA18:  BRA    AA64
....................                {         
....................                   //  
....................                   LCD_clear();    
0AA1A:  CALL   5C08
....................                   strcpy (global_temp_line_buff, "Mote is Dead    ");   
0AA1E:  CLRF   FEA
0AA20:  MOVLW  70
0AA22:  MOVWF  FE9
0AA24:  MOVLW  00
0AA26:  CALL   0742
0AA2A:  TBLRD*-
0AA2C:  TBLRD*+
0AA2E:  MOVF   FF5,W
0AA30:  MOVWF  FEE
0AA32:  IORLW  00
0AA34:  BNZ   AA2C
....................                   LCD_line1(global_temp_line_buff);                   
0AA36:  MOVLB  5
0AA38:  CLRF   x60
0AA3A:  MOVLW  70
0AA3C:  MOVWF  x5F
0AA3E:  MOVLB  0
0AA40:  CALL   37A0
....................                   global_skip_lcd_update_count = 2;   
0AA44:  MOVLW  02
0AA46:  MOVWF  x83
....................                   // save shutdown cause and queue shutdown 
....................                   global_shutdown_cause = ERR_FAIL_ON_MOTE_RESET; 
0AA48:  MOVLW  01
0AA4A:  MOVWF  4D
....................  
....................                   PUSH_PRIORITY_QUEUE(OPEN_VALVE_UNKNOWN_STATE);   
0AA4C:  MOVLW  3E
0AA4E:  MOVLB  5
0AA50:  MOVWF  x4E
0AA52:  MOVLB  0
0AA54:  CALL   4538
....................                   PUSH_PRIORITY_QUEUE(SHUTDOWN_SYSTEM); 
0AA58:  MOVLW  F1
0AA5A:  MOVLB  5
0AA5C:  MOVWF  x4E
0AA5E:  MOVLB  0
0AA60:  CALL   4538
....................                }            
....................                break; 
0AA64:  BRA    AD90
....................                 
....................             // Check the mote status and react appropriately 
....................             case CHECK_MOTE_STATE: 
....................                mote_state_check(); 
0AA66:  GOTO   8C50
....................                break; 
0AA6A:  BRA    AD90
....................                 
....................             case CHECK_MOTE_INFO: 
....................                mote_info_check(); 
0AA6C:  GOTO   8FBA
....................                break; 
0AA70:  BRA    AD90
....................                
....................             case UPDATE_MOTE_TIME: 
....................                mote_time_update(); 
0AA72:  GOTO   9048
....................                break;    
0AA76:  BRA    AD90
....................                 
....................             case UPDATE_MOTE_NETWORK_INFO: 
....................                get_mote_net_info(); 
0AA78:  GOTO   90D6
....................                break; 
0AA7C:  BRA    AD90
....................                 
....................             // Check's battery voltage, decides to charge, not charge, tell manager 
....................             // about a low voltage state, or to go to deep sleep 
....................             case CHECK_BATTERY_STATE: 
....................                /* 
....................                LCD_clear(); 
....................                LCD_display_battery_voltage(0); 
....................                LCD_place_uint16(get_vbatt(0),1,0,5); 
....................                global_skip_lcd_update_count = 2; 
....................                */         
....................                check_and_deal_with_battery(); 
0AA7E:  GOTO   9164
....................                break; 
0AA82:  BRA    AD90
....................              
....................             // Query the mote for the temp and store it 
....................             case CHECK_MOTE_TEMP: 
....................                mote_temp_check(); 
0AA84:  GOTO   9282
....................                /* 
....................                LCD_clear(); 
....................                strcpy (global_temp_line_buff, "Temp =         C"); 
....................                LCD_line1(global_temp_line_buff); 
....................                LCD_place_uint8(global_mote_temperature,0,7,3); 
....................                global_skip_lcd_update_count = 2; 
....................                */ 
....................                break; 
0AA88:  BRA    AD90
....................                 
....................             // First part of the search for strongest algorithm 
....................             case SEARCH_FOR_STRONGEST_1: 
....................                LCD_clear(); 
0AA8A:  CALL   5C08
....................                strcpy (global_temp_line_buff, "Search Strong 1 "); 
0AA8E:  CLRF   FEA
0AA90:  MOVLW  70
0AA92:  MOVWF  FE9
0AA94:  MOVLW  00
0AA96:  CALL   0764
0AA9A:  TBLRD*-
0AA9C:  TBLRD*+
0AA9E:  MOVF   FF5,W
0AAA0:  MOVWF  FEE
0AAA2:  IORLW  00
0AAA4:  BNZ   AA9C
....................                LCD_line1(global_temp_line_buff); 
0AAA6:  MOVLB  5
0AAA8:  CLRF   x60
0AAAA:  MOVLW  70
0AAAC:  MOVWF  x5F
0AAAE:  MOVLB  0
0AAB0:  CALL   37A0
....................                global_skip_lcd_update_count = 2; 
0AAB4:  MOVLW  02
0AAB6:  MOVWF  x83
....................                // set the state of the system appropriately 
....................                global_system_state = SYSTEM_SEARCHING_FOR_NETWORK; 
0AAB8:  MOVLW  20
0AABA:  MOVLB  5
0AABC:  MOVWF  x01
....................                PUSH_PRIORITY_QUEUE_MACRO(RESET_MOTE); 
0AABE:  BCF    F7A.1
0AAC0:  MOVLW  11
0AAC2:  MOVWF  x4E
0AAC4:  MOVLB  0
0AAC6:  CALL   4538
0AACA:  BSF    F7A.1
....................                PUSH_TIME_QUEUE_MACRO((global_rtc_time + 10), SEARCH_FOR_STRONGEST_2); 
0AACC:  BCF    F7A.1
0AACE:  MOVLW  0A
0AAD0:  ADDWF  x85,W
0AAD2:  MOVLB  5
0AAD4:  MOVWF  x47
0AAD6:  MOVLW  00
0AAD8:  MOVLB  0
0AADA:  ADDWFC x86,W
0AADC:  MOVLB  5
0AADE:  MOVWF  x48
0AAE0:  MOVLW  00
0AAE2:  MOVLB  0
0AAE4:  ADDWFC x87,W
0AAE6:  MOVLB  5
0AAE8:  MOVWF  x49
0AAEA:  MOVLW  00
0AAEC:  MOVLB  0
0AAEE:  ADDWFC x88,W
0AAF0:  MOVLB  5
0AAF2:  MOVWF  x4A
0AAF4:  MOVWF  x55
0AAF6:  MOVFF  549,554
0AAFA:  MOVFF  548,553
0AAFE:  MOVFF  547,552
0AB02:  MOVLW  B2
0AB04:  MOVWF  x56
0AB06:  MOVLB  0
0AB08:  CALL   4290
0AB0C:  BSF    F7A.1
....................                break; 
0AB0E:  BRA    AD90
....................                 
....................             // Second part of the search for strongest algorithm    
....................             case SEARCH_FOR_STRONGEST_2: 
....................                LCD_clear(); 
0AB10:  CALL   5C08
....................                strcpy (global_temp_line_buff, "Search Strong 2 "); 
0AB14:  CLRF   FEA
0AB16:  MOVLW  70
0AB18:  MOVWF  FE9
0AB1A:  MOVLW  00
0AB1C:  CALL   0786
0AB20:  TBLRD*-
0AB22:  TBLRD*+
0AB24:  MOVF   FF5,W
0AB26:  MOVWF  FEE
0AB28:  IORLW  00
0AB2A:  BNZ   AB22
....................                LCD_line1(global_temp_line_buff); 
0AB2C:  MOVLB  5
0AB2E:  CLRF   x60
0AB30:  MOVLW  70
0AB32:  MOVWF  x5F
0AB34:  MOVLB  0
0AB36:  CALL   37A0
....................                global_skip_lcd_update_count = 2; 
0AB3A:  MOVLW  02
0AB3C:  MOVWF  x83
....................                search_for_strongest(); 
0AB3E:  GOTO   969A
....................                break; 
0AB42:  BRA    AD90
....................              
....................             // Initalizes a mote join 
....................             case INIT_JOIN: 
....................                LCD_clear(); 
0AB44:  CALL   5C08
....................                strcpy (global_temp_line_buff, "  Init Join     "); 
0AB48:  CLRF   FEA
0AB4A:  MOVLW  70
0AB4C:  MOVWF  FE9
0AB4E:  MOVLW  00
0AB50:  CALL   07A8
0AB54:  TBLRD*-
0AB56:  TBLRD*+
0AB58:  MOVF   FF5,W
0AB5A:  MOVWF  FEE
0AB5C:  IORLW  00
0AB5E:  BNZ   AB56
....................                LCD_line1(global_temp_line_buff); 
0AB60:  MOVLB  5
0AB62:  CLRF   x60
0AB64:  MOVLW  70
0AB66:  MOVWF  x5F
0AB68:  MOVLB  0
0AB6A:  CALL   37A0
....................                global_skip_lcd_update_count = 2;   
0AB6E:  MOVLW  02
0AB70:  MOVWF  x83
....................                initiate_join();                                      
0AB72:  GOTO   9AC2
....................                break; 
0AB76:  BRA    AD90
....................              
....................             // not used anymore 
....................             case OPTIMIZE_MPPC: 
....................                adjust_mppc();   
0AB78:  GOTO   9C3C
....................                break;             
0AB7C:  BRA    AD90
....................                 
....................             // resets the cpu (if all pending messages are sent)    
....................             case CPU_RESET: 
....................                // if the dust network is operational and the message queue is not empty (location at 255) 
....................                //    wait for the message to be ack'd/resent and reschedule the shutdown.  
....................                if ((global_dust_operational == TRUE) && (global_current_message_queue_location != 255)) 
0AB7E:  BTFSS  xA3.7
0AB80:  BRA    ABD4
0AB82:  MOVLB  4
0AB84:  INCFSZ xF3,W
0AB86:  BRA    AB8E
0AB88:  MOVLB  0
0AB8A:  BRA    ABD4
0AB8C:  MOVLB  4
....................                { 
....................                   PUSH_TIME_QUEUE_MACRO((global_rtc_time + 10), CPU_RESET); 
0AB8E:  BCF    F7A.1
0AB90:  MOVLW  0A
0AB92:  MOVLB  0
0AB94:  ADDWF  x85,W
0AB96:  MOVLB  5
0AB98:  MOVWF  x47
0AB9A:  MOVLW  00
0AB9C:  MOVLB  0
0AB9E:  ADDWFC x86,W
0ABA0:  MOVLB  5
0ABA2:  MOVWF  x48
0ABA4:  MOVLW  00
0ABA6:  MOVLB  0
0ABA8:  ADDWFC x87,W
0ABAA:  MOVLB  5
0ABAC:  MOVWF  x49
0ABAE:  MOVLW  00
0ABB0:  MOVLB  0
0ABB2:  ADDWFC x88,W
0ABB4:  MOVLB  5
0ABB6:  MOVWF  x4A
0ABB8:  MOVWF  x55
0ABBA:  MOVFF  549,554
0ABBE:  MOVFF  548,553
0ABC2:  MOVFF  547,552
0ABC6:  MOVLW  F0
0ABC8:  MOVWF  x56
0ABCA:  MOVLB  0
0ABCC:  CALL   4290
0ABD0:  BSF    F7A.1
....................                } 
0ABD2:  BRA    AC22
....................                // if the valve is moving, check again later 
....................                else if (!IS_VLV_COASTING) 
0ABD4:  MOVF   F8D,F
0ABD6:  BZ    AC1C
....................                {                       
....................                   PUSH_TIME_QUEUE_MACRO((global_rtc_time + 10), CPU_RESET); 
0ABD8:  BCF    F7A.1
0ABDA:  MOVLW  0A
0ABDC:  ADDWF  x85,W
0ABDE:  MOVLB  5
0ABE0:  MOVWF  x47
0ABE2:  MOVLW  00
0ABE4:  MOVLB  0
0ABE6:  ADDWFC x86,W
0ABE8:  MOVLB  5
0ABEA:  MOVWF  x48
0ABEC:  MOVLW  00
0ABEE:  MOVLB  0
0ABF0:  ADDWFC x87,W
0ABF2:  MOVLB  5
0ABF4:  MOVWF  x49
0ABF6:  MOVLW  00
0ABF8:  MOVLB  0
0ABFA:  ADDWFC x88,W
0ABFC:  MOVLB  5
0ABFE:  MOVWF  x4A
0AC00:  MOVWF  x55
0AC02:  MOVFF  549,554
0AC06:  MOVFF  548,553
0AC0A:  MOVFF  547,552
0AC0E:  MOVLW  F0
0AC10:  MOVWF  x56
0AC12:  MOVLB  0
0AC14:  CALL   4290
0AC18:  BSF    F7A.1
....................                } 
0AC1A:  BRA    AC22
....................                // All messages are sent 
....................                else 
....................                { 
....................                   // if it does, restart the entire system 
....................                   store_all_eeprom_values(); 
0AC1C:  CALL   9D16
....................                   reset_cpu(); 
0AC20:  RESET
....................                } 
....................                break; 
0AC22:  BRA    AD90
....................                 
....................             // Shuts down the pic for a variety of reasons 
....................             case SHUTDOWN_SYSTEM:                
....................                // if the dust network is operational and the message queue is not empty (location at 255) 
....................                //    wait for the message to be ack'd/resent and reschedule the shutdown. 
....................                // I suppose this has potential to be problamatic, but the network should eventually show 
....................                //    up as non-operational in mote-check or get ack'd at some point, I would hope. 
....................                                                               
....................                global_brake_duty_set_value = NO_BRK; 
0AC24:  CLRF   xB3
0AC26:  CLRF   xB2
....................                global_charge_duty_set_value = NO_CHARGE; 
0AC28:  CLRF   xB5
0AC2A:  CLRF   xB4
....................                global_control_loop_mechanism = NO_RPM_CONTROL_DYN_MPPC; 
0AC2C:  MOVLW  06
0AC2E:  MOVWF  xBC
....................                 
....................                // if the system hasn't moved the brake and charge settings to 0, wait 
....................                if ((global_brake_duty != NO_BRK) || (global_charge_duty != NO_CHARGE)) 
0AC30:  MOVF   xAE,F
0AC32:  BNZ   AC40
0AC34:  MOVF   xAF,F
0AC36:  BNZ   AC40
0AC38:  MOVF   xB0,F
0AC3A:  BNZ   AC40
0AC3C:  MOVF   xB1,F
0AC3E:  BZ    AC44
....................                { 
....................                   break; 
0AC40:  BRA    AD90
....................                }                
0AC42:  BRA    AD8E
....................                // if there are still messages to be sent and the mote is working, wait 
....................                else if ((global_dust_operational == TRUE) && (global_current_message_queue_location != 255)) 
0AC44:  BTFSS  xA3.7
0AC46:  BRA    AC9A
0AC48:  MOVLB  4
0AC4A:  INCFSZ xF3,W
0AC4C:  BRA    AC54
0AC4E:  MOVLB  0
0AC50:  BRA    AC9A
0AC52:  MOVLB  4
....................                {                                                 
....................                   PUSH_TIME_QUEUE_MACRO((global_rtc_time + 10), SHUTDOWN_SYSTEM); 
0AC54:  BCF    F7A.1
0AC56:  MOVLW  0A
0AC58:  MOVLB  0
0AC5A:  ADDWF  x85,W
0AC5C:  MOVLB  5
0AC5E:  MOVWF  x47
0AC60:  MOVLW  00
0AC62:  MOVLB  0
0AC64:  ADDWFC x86,W
0AC66:  MOVLB  5
0AC68:  MOVWF  x48
0AC6A:  MOVLW  00
0AC6C:  MOVLB  0
0AC6E:  ADDWFC x87,W
0AC70:  MOVLB  5
0AC72:  MOVWF  x49
0AC74:  MOVLW  00
0AC76:  MOVLB  0
0AC78:  ADDWFC x88,W
0AC7A:  MOVLB  5
0AC7C:  MOVWF  x4A
0AC7E:  MOVWF  x55
0AC80:  MOVFF  549,554
0AC84:  MOVFF  548,553
0AC88:  MOVFF  547,552
0AC8C:  MOVLW  F1
0AC8E:  MOVWF  x56
0AC90:  MOVLB  0
0AC92:  CALL   4290
0AC96:  BSF    F7A.1
....................                } 
0AC98:  BRA    AD8E
....................                // if the valve is moving, wait                           
....................                else if (!IS_VLV_COASTING) 
0AC9A:  MOVF   F8D,F
0AC9C:  BZ    ACE2
....................                { 
....................                   PUSH_TIME_QUEUE_MACRO((global_rtc_time + 10), SHUTDOWN_SYSTEM); 
0AC9E:  BCF    F7A.1
0ACA0:  MOVLW  0A
0ACA2:  ADDWF  x85,W
0ACA4:  MOVLB  5
0ACA6:  MOVWF  x47
0ACA8:  MOVLW  00
0ACAA:  MOVLB  0
0ACAC:  ADDWFC x86,W
0ACAE:  MOVLB  5
0ACB0:  MOVWF  x48
0ACB2:  MOVLW  00
0ACB4:  MOVLB  0
0ACB6:  ADDWFC x87,W
0ACB8:  MOVLB  5
0ACBA:  MOVWF  x49
0ACBC:  MOVLW  00
0ACBE:  MOVLB  0
0ACC0:  ADDWFC x88,W
0ACC2:  MOVLB  5
0ACC4:  MOVWF  x4A
0ACC6:  MOVWF  x55
0ACC8:  MOVFF  549,554
0ACCC:  MOVFF  548,553
0ACD0:  MOVFF  547,552
0ACD4:  MOVLW  F1
0ACD6:  MOVWF  x56
0ACD8:  MOVLB  0
0ACDA:  CALL   4290
0ACDE:  BSF    F7A.1
....................                }                                 
0ACE0:  BRA    AD8E
....................                // All messages are sent or system is shutting down due to no network connection  
....................                //    and system is in SYSTEM_RUN or SYSTEM_IDLE state  
....................                else if ((read_system_state() == SYSTEM_RUN) || ((read_system_state() == SYSTEM_IDLE))) 
0ACE2:  CALL   1DC6
0ACE6:  MOVF   01,W
0ACE8:  SUBLW  02
0ACEA:  BZ    ACF6
0ACEC:  CALL   1DC6
0ACF0:  MOVF   01,W
0ACF2:  SUBLW  03
0ACF4:  BNZ   AD4C
....................                { 
....................                   // try to put the mote to sleep 
....................                   if (mote_sleep() == NO_ERR)          
0ACF6:  GOTO   9D8A
0ACFA:  MOVF   01,F
0ACFC:  BNZ   AD08
....................                   { 
....................                      // if it does, put the entire system to sleep 
....................                      store_all_eeprom_values(); 
0ACFE:  CALL   9D16
....................                      deep_sleep(); 
0AD02:  CALL   942C
....................                   } 
0AD06:  BRA    AD4A
....................                   // otherwise, try again in 10 seconds    
....................                   else 
....................                   { 
....................                      PUSH_TIME_QUEUE_MACRO((global_rtc_time + 10), SHUTDOWN_SYSTEM); 
0AD08:  BCF    F7A.1
0AD0A:  MOVLW  0A
0AD0C:  ADDWF  x85,W
0AD0E:  MOVLB  5
0AD10:  MOVWF  x47
0AD12:  MOVLW  00
0AD14:  MOVLB  0
0AD16:  ADDWFC x86,W
0AD18:  MOVLB  5
0AD1A:  MOVWF  x48
0AD1C:  MOVLW  00
0AD1E:  MOVLB  0
0AD20:  ADDWFC x87,W
0AD22:  MOVLB  5
0AD24:  MOVWF  x49
0AD26:  MOVLW  00
0AD28:  MOVLB  0
0AD2A:  ADDWFC x88,W
0AD2C:  MOVLB  5
0AD2E:  MOVWF  x4A
0AD30:  MOVWF  x55
0AD32:  MOVFF  549,554
0AD36:  MOVFF  548,553
0AD3A:  MOVFF  547,552
0AD3E:  MOVLW  F1
0AD40:  MOVWF  x56
0AD42:  MOVLB  0
0AD44:  CALL   4290
0AD48:  BSF    F7A.1
....................                   } 
....................                } 
0AD4A:  BRA    AD8E
....................                // Anything else, just wait 
....................                else 
....................                { 
....................                   PUSH_TIME_QUEUE_MACRO((global_rtc_time + 10), SHUTDOWN_SYSTEM); 
0AD4C:  BCF    F7A.1
0AD4E:  MOVLW  0A
0AD50:  ADDWF  x85,W
0AD52:  MOVLB  5
0AD54:  MOVWF  x47
0AD56:  MOVLW  00
0AD58:  MOVLB  0
0AD5A:  ADDWFC x86,W
0AD5C:  MOVLB  5
0AD5E:  MOVWF  x48
0AD60:  MOVLW  00
0AD62:  MOVLB  0
0AD64:  ADDWFC x87,W
0AD66:  MOVLB  5
0AD68:  MOVWF  x49
0AD6A:  MOVLW  00
0AD6C:  MOVLB  0
0AD6E:  ADDWFC x88,W
0AD70:  MOVLB  5
0AD72:  MOVWF  x4A
0AD74:  MOVWF  x55
0AD76:  MOVFF  549,554
0AD7A:  MOVFF  548,553
0AD7E:  MOVFF  547,552
0AD82:  MOVLW  F1
0AD84:  MOVWF  x56
0AD86:  MOVLB  0
0AD88:  CALL   4290
0AD8C:  BSF    F7A.1
....................                } 
....................                break; 
0AD8E:  BRA    AD90
....................                 
....................             // updates  
....................             // Default case (nothing to do)                
....................             case EMPTY_PRIORITY_QUEUE: 
....................                //LCD_place_uint32(global_rtc_time, 1, 0, 10); 
....................                break; 
....................          } 
....................           
....................       } 
0AD90:  GOTO   A27A
.................... ////////////////////End of Priority Queue Handling///////////////////////////// 
....................    // end of inifinite while loop 
....................    }    
.................... } 
....................  
....................  
.................... //#PRIORITY COMP, CCP5, EXT2, CCP3, CCP4, BUSCOL 
.................... #PRIORITY CCP5, COMP, CCP3, EXT2, TIMER0, CCP4, BUSCOL, INT_RB, EXT           
....................                                                                      
.................... #INT_RB          
.................... void RB_ISR(void)                                
0AD94:  SLEEP 
.................... {                           
....................    // Setup in periph init to be called only when RB4 has changed state 
....................    // RB4 is connected to SW1n  
....................     
....................    // keeps track of when the switch was pressed so we can enable the long press functionality      
....................  
....................    if (!input(SW1n)) 
*
007CA:  BTFSC  F81.4
007CC:  BRA    07E0
....................    { 
....................       sw1_start_time = global_rtc_time; 
007CE:  MOVFF  88,90
007D2:  MOVFF  87,8F
007D6:  MOVFF  86,8E
007DA:  MOVFF  85,8D
....................       return; 
007DE:  BRA    07FA
....................    }            
....................     
....................    sw1_start_time = 0; 
007E0:  CLRF   x90
007E2:  CLRF   x8F
007E4:  CLRF   x8E
007E6:  CLRF   x8D
....................    // if you're incrementing past the last page, reset to the first page   
....................    if (global_lcd_page_number == TOTAL_LCD_PAGES) 
007E8:  MOVF   x84,W
007EA:  SUBLW  04
007EC:  BNZ   07F4
....................    {                                             
....................       global_lcd_page_number = 1;    
007EE:  MOVLW  01
007F0:  MOVWF  x84
....................    }      
007F2:  BRA    07F6
....................    // otherwise, just increment the page number 
....................    else     
....................    { 
....................       global_lcd_page_number++; 
007F4:  INCF   x84,F
....................    }  
....................     
....................    // trigger a full LCD update (including the contstant parts of the lcd) 
....................    global_skip_lcd_update_count = 1;       
007F6:  MOVLW  01
007F8:  MOVWF  x83
....................           
....................    return; 
....................     
....................     
....................        
....................    // not quite ready for prime time long press code (causes boot-looping, but is probably close) 
....................    // if SW1 is depressed (active), take note of the time  
....................     
.................... /*   
....................    if (!input(SW1n)) 
....................    { 
....................       sw1_start_time = global_rtc_time;   
....................    }                                  
....................    // when SW1 is coming back up  
....................    else                   
....................    {                                         
....................       // if the button has been pressed more than SW1_ISR_LONG_PRESS_TIME     
....................       //    do the long-press action 
....................       if ((global_rtc_time - sw1_start_time) > SW1_ISR_LONG_PRESS_TIME) 
....................       {                   
....................          // long-press action 
....................          flash_leds_ISR(2);  
....................       }         
....................                                            
....................       // if the button had been pressed less than SW1_ISR_LONG_PRESS_TIME, increment the page    
....................       else 
....................       {         
....................          // if you're incrementing past the last page, reset to the first page   
....................          if (global_lcd_page_number == TOTAL_LCD_PAGES) 
....................          {                                             
....................             global_lcd_page_number = 1;    
....................          }      
....................          // otherwie, just increment the page number 
....................          else     
....................          { 
....................             global_lcd_page_number++; 
....................          }  
....................                                             
....................          // trigger a full LCD update (including the contstant parts of the lcd) 
....................          global_skip_lcd_update_count = 1;                  
....................       } 
....................       return; 
....................    } 
....................  */ 
....................   
.................... } 
....................  
....................  
007FA:  BCF    FF2.0
007FC:  GOTO   00A0
.................... #INT_EXT 
.................... void vgen_wakeup_ISR(void) 
.................... { 
.................... // runs on wakeup from vgen int 
....................    reset_cpu();                  
00800:  RESET
.................... }                 
....................  
00802:  BCF    FF2.1
00804:  GOTO   015E
.................... #INT_BUSCOL 
.................... void BUSCOL_ISR(void) 
.................... {   
.................... // Catches and recovers from an i2c bus collision  
....................  
....................    // are reenabled in MAIN        
....................    disable_interrupts(GLOBAL); 
*
008BA:  BCF    FF2.6
008BC:  BCF    FF2.7
008BE:  BTFSC  FF2.7
008C0:  BRA    08BC
....................     
....................    // clear bus collision interrupt flag 
....................    BCL1IF = FALSE; 
008C2:  BCF    FA1.3
....................     
....................    // schedule a bus collision reset 
....................    PUSH_PRIORITY_QUEUE_ISR_MACRO(BUSCOL_RESET); 
008C4:  MOVLW  C0
008C6:  MOVLB  5
008C8:  MOVWF  x9B
008CA:  MOVLB  0
008CC:  RCALL  0808
....................  
....................    // if the lcd is connected, reset it 
....................    if (global_lcd_enabled) 
008CE:  BTFSS  xA3.0
008D0:  BRA    08DE
....................    {   
....................       output_low(LCD_RESETn); 
008D2:  BCF    F8C.2
....................       delay_cycles(64);       // about 1 millisecond 
008D4:  MOVLW  15
008D6:  MOVWF  00
008D8:  DECFSZ 00,F
008DA:  BRA    08D8
....................       output_high(LCD_RESETn); 
008DC:  BSF    F8C.2
....................    }    
....................     
....................    // send the stack pointer to position 1 (perhaps sort of dangerous) 
....................    STKPTR = 1; 
008DE:  MOVLW  01
008E0:  MOVWF  FFC
.................... } 
....................  
008E2:  BCF    FA1.3
008E4:  GOTO   00A0
.................... #INT_EXT2  
.................... void mote_interrupt(void) 
.................... {    
.................... // interrupt called when mote rts line gets asserted    
....................    uint8_t     tmp_oscccon, tmp_t2con, tmp_pr2, tmp_t0con; 
....................     
....................    // save the current oscillator setup 
....................    tmp_oscccon = OSCCON; 
*
016FE:  MOVFF  FD3,57F
....................    tmp_t2con = T2CON; 
01702:  MOVFF  FBA,580
....................    tmp_pr2 = PR2; 
01706:  MOVFF  FBB,581
....................    tmp_t0con = T0CON; 
0170A:  MOVFF  FD5,582
....................     
....................    // start primary (3.8Mhz) crystal for UART communication 
....................    fosc_pri_ISR(); 
0170E:  GOTO   08E8
....................     
....................    // disable int_ccp4 as (unsolicited) message queue can overwrite payload_buff 
....................    disable_interrupts(INT_CCP4); 
01712:  BCF    F7A.1
....................                                    
....................    // recieve serial data, respond, and schedule deal with packet if necessary 
....................    deal_with_mote_ISR(); 
01714:  BRA    121A
....................     
....................    // renable int_ccp4 as we're done touching payload_buff       
....................    enable_interrupts(INT_CCP4);   
01716:  BSF    F7A.1
....................                                      
....................    // restore the current oscillator 
....................    OSCCON = tmp_oscccon; 
01718:  MOVFF  57F,FD3
....................    T2CON = tmp_t2con; 
0171C:  MOVFF  580,FBA
....................    T0CON = tmp_t0con; 
01720:  MOVFF  582,FD5
....................    PR2 = tmp_PR2; 
01724:  MOVFF  581,FBB
.................... } 
....................  
....................  
01728:  BCF    FF0.1
0172A:  GOTO   00A0
.................... #INT_COMP 
.................... void comp1_ISR(void) 
.................... { 
.................... // ISR routine that is called when the comparator current limit is reached 
....................    uint16_t    temp16_frac; 
....................     
....................     // if comarator 1 is tripped (INT_COMP is triggered by comp 1 or 2) 
....................    if (C1OUT) 
*
019C4:  BTFSS  F79.6
019C6:  BRA    1DC0
....................    {      
....................       // grab the extra time/2ndary osc ticks since the last 1024th interrupt   
....................       temp16_frac = get_timer1(); 
019C8:  MOVF   FCE,W
019CA:  MOVLB  5
019CC:  MOVWF  x7F
019CE:  MOVFF  FCF,580
....................        
....................       // if statements for different calibration routines 
....................       // valve opening a little bit to ensure we dont jam into close endstop 
....................       if (global_system_state ==  SYSTEM_CAL_VLV_1) 
019D2:  MOVF   x01,W
019D4:  SUBLW  10
019D6:  BNZ   1A2C
....................       { 
....................          global_valve_position = VLV_POSITION_OPENED; 
019D8:  MOVLW  80
019DA:  MOVLB  0
019DC:  MOVWF  xBE
019DE:  CLRF   xBD
....................          // queue up the next stage of the calibration 
....................          push_time_queue_ISR(global_rtc_time + 3, CALIBRATE_VALVE_2); 
019E0:  MOVLW  03
019E2:  ADDWF  x85,W
019E4:  MOVLB  5
019E6:  MOVWF  x81
019E8:  MOVLW  00
019EA:  MOVLB  0
019EC:  ADDWFC x86,W
019EE:  MOVLB  5
019F0:  MOVWF  x82
019F2:  MOVLW  00
019F4:  MOVLB  0
019F6:  ADDWFC x87,W
019F8:  MOVLB  5
019FA:  MOVWF  x83
019FC:  MOVLW  00
019FE:  MOVLB  0
01A00:  ADDWFC x88,W
01A02:  MOVLB  5
01A04:  MOVWF  x84
01A06:  CLRF   19
01A08:  BTFSC  FF2.7
01A0A:  BSF    19.7
01A0C:  BCF    FF2.7
01A0E:  MOVWF  xBA
01A10:  MOVFF  583,5B9
01A14:  MOVFF  582,5B8
01A18:  MOVFF  581,5B7
01A1C:  MOVLW  32
01A1E:  MOVWF  xBB
01A20:  MOVLB  0
01A22:  RCALL  172E
01A24:  BTFSC  19.7
01A26:  BSF    FF2.7
....................       } 
01A28:  BRA    1DA8
01A2A:  MOVLB  5
....................       // valve closing towards closing endstop pre-calibration 
....................       else if (global_system_state == SYSTEM_CAL_VLV_2) 
01A2C:  MOVF   x01,W
01A2E:  SUBLW  11
01A30:  BNZ   1A84
....................       { 
....................          global_valve_position = VLV_POSITION_CLOSED;  
01A32:  MOVLB  0
01A34:  CLRF   xBE
01A36:  CLRF   xBD
....................          // queue up the next stage of the calibration 
....................          push_time_queue_ISR(global_rtc_time + 3, CALIBRATE_VALVE_3); 
01A38:  MOVLW  03
01A3A:  ADDWF  x85,W
01A3C:  MOVLB  5
01A3E:  MOVWF  x81
01A40:  MOVLW  00
01A42:  MOVLB  0
01A44:  ADDWFC x86,W
01A46:  MOVLB  5
01A48:  MOVWF  x82
01A4A:  MOVLW  00
01A4C:  MOVLB  0
01A4E:  ADDWFC x87,W
01A50:  MOVLB  5
01A52:  MOVWF  x83
01A54:  MOVLW  00
01A56:  MOVLB  0
01A58:  ADDWFC x88,W
01A5A:  MOVLB  5
01A5C:  MOVWF  x84
01A5E:  CLRF   19
01A60:  BTFSC  FF2.7
01A62:  BSF    19.7
01A64:  BCF    FF2.7
01A66:  MOVWF  xBA
01A68:  MOVFF  583,5B9
01A6C:  MOVFF  582,5B8
01A70:  MOVFF  581,5B7
01A74:  MOVLW  33
01A76:  MOVWF  xBB
01A78:  MOVLB  0
01A7A:  RCALL  172E
01A7C:  BTFSC  19.7
01A7E:  BSF    FF2.7
....................       } 
01A80:  BRA    1DA8
01A82:  MOVLB  5
....................       // valve opening fully from fully closed for calibration 
....................       else if (global_system_state == SYSTEM_CAL_VLV_3) 
01A84:  MOVF   x01,W
01A86:  SUBLW  12
01A88:  BNZ   1B68
....................       { 
....................          // set the valve position to open 
....................          global_valve_position = VLV_POSITION_OPENED;  
01A8A:  MOVLW  80
01A8C:  MOVLB  0
01A8E:  MOVWF  xBE
01A90:  CLRF   xBD
....................          // recalculate the valve opening time for each 1024th 
....................          //    (valve movements (1024th) * the time it takes for each 1024th 
....................          //    + the extra time) divided by 1024 
....................          global_valve_time_to_open_1024th =                                   \ 
....................          ((((uint32_t) global_valve_time_in_motion_1024ths * (uint32_t) global_valve_time_to_open_1024th) \ 
....................          + temp16_frac) >> 10); 
01A92:  MOVLB  5
01A94:  CLRF   x84
01A96:  CLRF   x83
01A98:  MOVFF  C6,582
01A9C:  MOVFF  C5,581
01AA0:  MOVFF  C3,00
01AA4:  MOVFF  C4,01
01AA8:  CLRF   02
01AAA:  CLRF   03
01AAC:  MOVFF  03,588
01AB0:  MOVFF  02,587
01AB4:  MOVFF  C4,586
01AB8:  MOVFF  C3,585
01ABC:  MOVFF  584,58C
01AC0:  MOVFF  583,58B
01AC4:  MOVFF  C6,58A
01AC8:  MOVFF  C5,589
01ACC:  MOVFF  03,590
01AD0:  MOVFF  02,58F
01AD4:  MOVFF  C4,58E
01AD8:  MOVFF  C3,58D
01ADC:  MOVLB  0
01ADE:  RCALL  1968
01AE0:  MOVFF  03,584
01AE4:  MOVFF  02,583
01AE8:  MOVFF  01,582
01AEC:  MOVFF  00,581
01AF0:  MOVLB  5
01AF2:  MOVF   x7F,W
01AF4:  ADDWF  x81,F
01AF6:  MOVF   x80,W
01AF8:  ADDWFC x82,F
01AFA:  MOVLW  00
01AFC:  ADDWFC x83,F
01AFE:  ADDWFC x84,F
01B00:  RRCF   x84,W
01B02:  MOVWF  02
01B04:  RRCF   x83,W
01B06:  MOVWF  01
01B08:  RRCF   x82,W
01B0A:  MOVWF  00
01B0C:  RRCF   02,F
01B0E:  RRCF   01,F
01B10:  RRCF   00,F
01B12:  MOVFF  00,C3
01B16:  MOVLB  0
01B18:  MOVFF  01,C4
....................          // queue up the next stage of the calibration 
....................          push_time_queue_ISR(global_rtc_time + 3, CALIBRATE_VALVE_5); 
01B1C:  MOVLW  03
01B1E:  ADDWF  x85,W
01B20:  MOVLB  5
01B22:  MOVWF  x81
01B24:  MOVLW  00
01B26:  MOVLB  0
01B28:  ADDWFC x86,W
01B2A:  MOVLB  5
01B2C:  MOVWF  x82
01B2E:  MOVLW  00
01B30:  MOVLB  0
01B32:  ADDWFC x87,W
01B34:  MOVLB  5
01B36:  MOVWF  x83
01B38:  MOVLW  00
01B3A:  MOVLB  0
01B3C:  ADDWFC x88,W
01B3E:  MOVLB  5
01B40:  MOVWF  x84
01B42:  CLRF   19
01B44:  BTFSC  FF2.7
01B46:  BSF    19.7
01B48:  BCF    FF2.7
01B4A:  MOVWF  xBA
01B4C:  MOVFF  583,5B9
01B50:  MOVFF  582,5B8
01B54:  MOVFF  581,5B7
01B58:  MOVLW  35
01B5A:  MOVWF  xBB
01B5C:  MOVLB  0
01B5E:  RCALL  172E
01B60:  BTFSC  19.7
01B62:  BSF    FF2.7
....................       } 
01B64:  BRA    1DA8
01B66:  MOVLB  5
....................       // valve closing fully from fully open for calibration 
....................       else if (global_system_state == SYSTEM_CAL_VLV_5) 
01B68:  MOVF   x01,W
01B6A:  SUBLW  14
01B6C:  BNZ   1C4A
....................       { 
....................          global_valve_position = VLV_POSITION_CLOSED;  
01B6E:  MOVLB  0
01B70:  CLRF   xBE
01B72:  CLRF   xBD
....................          // recalculate the valve closing time for each 1024th 
....................          //    (valve movements (1024th) * the time it takes for each 1024th 
....................          //    + the extra time) divided by 1024 
....................          global_valve_time_to_close_1024th =                                   \ 
....................          ((((uint32_t) global_valve_time_in_motion_1024ths * (uint32_t) global_valve_time_to_close_1024th) \ 
....................          + temp16_frac) >> 10); 
01B74:  MOVLB  5
01B76:  CLRF   x84
01B78:  CLRF   x83
01B7A:  MOVFF  C6,582
01B7E:  MOVFF  C5,581
01B82:  MOVFF  C1,00
01B86:  MOVFF  C2,01
01B8A:  CLRF   02
01B8C:  CLRF   03
01B8E:  MOVFF  03,588
01B92:  MOVFF  02,587
01B96:  MOVFF  C2,586
01B9A:  MOVFF  C1,585
01B9E:  MOVFF  584,58C
01BA2:  MOVFF  583,58B
01BA6:  MOVFF  C6,58A
01BAA:  MOVFF  C5,589
01BAE:  MOVFF  03,590
01BB2:  MOVFF  02,58F
01BB6:  MOVFF  C2,58E
01BBA:  MOVFF  C1,58D
01BBE:  MOVLB  0
01BC0:  RCALL  1968
01BC2:  MOVFF  03,584
01BC6:  MOVFF  02,583
01BCA:  MOVFF  01,582
01BCE:  MOVFF  00,581
01BD2:  MOVLB  5
01BD4:  MOVF   x7F,W
01BD6:  ADDWF  x81,F
01BD8:  MOVF   x80,W
01BDA:  ADDWFC x82,F
01BDC:  MOVLW  00
01BDE:  ADDWFC x83,F
01BE0:  ADDWFC x84,F
01BE2:  RRCF   x84,W
01BE4:  MOVWF  02
01BE6:  RRCF   x83,W
01BE8:  MOVWF  01
01BEA:  RRCF   x82,W
01BEC:  MOVWF  00
01BEE:  RRCF   02,F
01BF0:  RRCF   01,F
01BF2:  RRCF   00,F
01BF4:  MOVFF  00,C1
01BF8:  MOVLB  0
01BFA:  MOVFF  01,C2
....................          // queue up the next stage of the calibration 
....................          push_time_queue_ISR(global_rtc_time + 3, CALIBRATE_VALVE_6); 
01BFE:  MOVLW  03
01C00:  ADDWF  x85,W
01C02:  MOVLB  5
01C04:  MOVWF  x81
01C06:  MOVLW  00
01C08:  MOVLB  0
01C0A:  ADDWFC x86,W
01C0C:  MOVLB  5
01C0E:  MOVWF  x82
01C10:  MOVLW  00
01C12:  MOVLB  0
01C14:  ADDWFC x87,W
01C16:  MOVLB  5
01C18:  MOVWF  x83
01C1A:  MOVLW  00
01C1C:  MOVLB  0
01C1E:  ADDWFC x88,W
01C20:  MOVLB  5
01C22:  MOVWF  x84
01C24:  CLRF   19
01C26:  BTFSC  FF2.7
01C28:  BSF    19.7
01C2A:  BCF    FF2.7
01C2C:  MOVWF  xBA
01C2E:  MOVFF  583,5B9
01C32:  MOVFF  582,5B8
01C36:  MOVFF  581,5B7
01C3A:  MOVLW  36
01C3C:  MOVWF  xBB
01C3E:  MOVLB  0
01C40:  RCALL  172E
01C42:  BTFSC  19.7
01C44:  BSF    FF2.7
....................       } 
01C46:  BRA    1DA8
01C48:  MOVLB  5
....................       // we are doing a valve endstop detect that we have a known calibration for. 
....................       // We want to check the positional error (if we are too far away from the 
....................       // endstop in position when the endstop is detected).  This applies to  
....................       // normal moves as well as re-calibration moves. 
....................       else 
....................       { 
....................          // valve has closed/opened fully in preparation of a recalibration of  
....................          //    valve position.  Trigger a move valve to move to the pending valve 
....................          //    set position and set system status to run 
....................          if (global_system_state == SYSTEM_RECAL_VLV_MOVES) 
01C4A:  MOVF   x01,W
01C4C:  SUBLW  16
01C4E:  BNZ   1CA0
....................          { 
....................             push_time_queue_ISR(global_rtc_time + 3, MOVE_VALVE); 
01C50:  MOVLW  03
01C52:  MOVLB  0
01C54:  ADDWF  x85,W
01C56:  MOVLB  5
01C58:  MOVWF  x81
01C5A:  MOVLW  00
01C5C:  MOVLB  0
01C5E:  ADDWFC x86,W
01C60:  MOVLB  5
01C62:  MOVWF  x82
01C64:  MOVLW  00
01C66:  MOVLB  0
01C68:  ADDWFC x87,W
01C6A:  MOVLB  5
01C6C:  MOVWF  x83
01C6E:  MOVLW  00
01C70:  MOVLB  0
01C72:  ADDWFC x88,W
01C74:  MOVLB  5
01C76:  MOVWF  x84
01C78:  CLRF   19
01C7A:  BTFSC  FF2.7
01C7C:  BSF    19.7
01C7E:  BCF    FF2.7
01C80:  MOVWF  xBA
01C82:  MOVFF  583,5B9
01C86:  MOVFF  582,5B8
01C8A:  MOVFF  581,5B7
01C8E:  MOVLW  40
01C90:  MOVWF  xBB
01C92:  MOVLB  0
01C94:  RCALL  172E
01C96:  BTFSC  19.7
01C98:  BSF    FF2.7
....................             global_system_state = SYSTEM_RUN; 
01C9A:  MOVLW  02
01C9C:  MOVLB  5
01C9E:  MOVWF  x01
....................          } 
....................          // valve is closing 
....................          if (IS_VLV_CLOSING) 
01CA0:  DECFSZ F8D,W
01CA2:  BRA    1D22
....................          { 
....................             // error checking if valve movement was longer or shorter than expected 
....................             // We accomplish this by seeing if the valve hit an endstop while it was 
....................             //    outside the VLV_NEAR_CLOSED_RANGE_MAX/VLV_NEAR_OPENED_RANGE_MAX 
....................             if (global_valve_position > VLV_NEAR_CLOSED_RANGE_MAX) 
01CA4:  MOVF   x03,W
01CA6:  MOVLB  0
01CA8:  SUBWF  xBE,W
01CAA:  BNC   1D1A
01CAC:  BNZ   1CBE
01CAE:  MOVF   xBD,W
01CB0:  MOVLB  5
01CB2:  SUBWF  x02,W
01CB4:  BTFSS  FD8.0
01CB6:  BRA    1CBC
01CB8:  MOVLB  0
01CBA:  BRA    1D1A
01CBC:  MOVLB  0
....................             { 
....................                // put system into run mode (in case it's in valve cal routine) 
....................                global_system_state = SYSTEM_RUN; 
01CBE:  MOVLW  02
01CC0:  MOVLB  5
01CC2:  MOVWF  x01
....................                // set valve to unknown position (uncalibrated) 
....................                global_valve_position = VLV_POSITION_UNKNOWN; 
01CC4:  MOVLB  0
01CC6:  SETF   xBE
01CC8:  SETF   xBD
....................                // set the error bitfield and send an error 
....................                global_error_message_bitfield |= ERR_MSG_VLV_MOVE_FAIL; 
01CCA:  MOVLB  4
01CCC:  BSF    xF5.2
....................                push_time_queue_ISR(global_rtc_time + 1, MSG_MOTE_ERROR_MSG); 
01CCE:  MOVLW  01
01CD0:  MOVLB  0
01CD2:  ADDWF  x85,W
01CD4:  MOVLB  5
01CD6:  MOVWF  x81
01CD8:  MOVLW  00
01CDA:  MOVLB  0
01CDC:  ADDWFC x86,W
01CDE:  MOVLB  5
01CE0:  MOVWF  x82
01CE2:  MOVLW  00
01CE4:  MOVLB  0
01CE6:  ADDWFC x87,W
01CE8:  MOVLB  5
01CEA:  MOVWF  x83
01CEC:  MOVLW  00
01CEE:  MOVLB  0
01CF0:  ADDWFC x88,W
01CF2:  MOVLB  5
01CF4:  MOVWF  x84
01CF6:  CLRF   19
01CF8:  BTFSC  FF2.7
01CFA:  BSF    19.7
01CFC:  BCF    FF2.7
01CFE:  MOVWF  xBA
01D00:  MOVFF  583,5B9
01D04:  MOVFF  582,5B8
01D08:  MOVFF  581,5B7
01D0C:  MOVLW  A0
01D0E:  MOVWF  xBB
01D10:  MOVLB  0
01D12:  RCALL  172E
01D14:  BTFSC  19.7
01D16:  BSF    FF2.7
....................             } 
01D18:  BRA    1D1E
....................             // was an expected endstop, proceed as usual 
....................             else 
....................             { 
....................                global_valve_position = VLV_POSITION_CLOSED;  
01D1A:  CLRF   xBE
01D1C:  CLRF   xBD
....................             } 
....................          } 
01D1E:  BRA    1DA8
01D20:  MOVLB  5
....................          // valve is opening 
....................          else if (IS_VLV_OPENING) 
01D22:  MOVF   F8D,W
01D24:  SUBLW  02
01D26:  BNZ   1DAA
....................          { 
....................             // error checking if valve movement was longer or shorter than expected 
....................             // We accomplish this by seeing if the valve hit an endstop while it was 
....................             //    outside the VLV_NEAR_CLOSED_RANGE_MAX/VLV_NEAR_OPENED_RANGE_MAX 
....................             if (global_valve_position < VLV_NEAR_OPENED_RANGE_MAX) 
01D28:  MOVLB  0
01D2A:  MOVF   xBE,W
01D2C:  MOVLB  5
01D2E:  SUBWF  x05,W
01D30:  BNC   1DA0
01D32:  BNZ   1D44
01D34:  MOVF   x04,W
01D36:  MOVLB  0
01D38:  SUBWF  xBD,W
01D3A:  BTFSS  FD8.0
01D3C:  BRA    1D42
01D3E:  MOVLB  5
01D40:  BRA    1DA0
01D42:  MOVLB  5
....................             { 
....................                // put system into run mode (in case it's in valve cal routine) 
....................                global_system_state = SYSTEM_RUN; 
01D44:  MOVLW  02
01D46:  MOVWF  x01
....................                // set valve to unknown position (uncalibrated) 
....................                global_valve_position = VLV_POSITION_UNKNOWN; 
01D48:  MOVLB  0
01D4A:  SETF   xBE
01D4C:  SETF   xBD
....................                // set the error bitfield and send an error 
....................                global_error_message_bitfield |= ERR_MSG_VLV_MOVE_FAIL; 
01D4E:  MOVLB  4
01D50:  BSF    xF5.2
....................                push_time_queue_ISR(global_rtc_time + 1, MSG_MOTE_ERROR_MSG); 
01D52:  MOVLW  01
01D54:  MOVLB  0
01D56:  ADDWF  x85,W
01D58:  MOVLB  5
01D5A:  MOVWF  x81
01D5C:  MOVLW  00
01D5E:  MOVLB  0
01D60:  ADDWFC x86,W
01D62:  MOVLB  5
01D64:  MOVWF  x82
01D66:  MOVLW  00
01D68:  MOVLB  0
01D6A:  ADDWFC x87,W
01D6C:  MOVLB  5
01D6E:  MOVWF  x83
01D70:  MOVLW  00
01D72:  MOVLB  0
01D74:  ADDWFC x88,W
01D76:  MOVLB  5
01D78:  MOVWF  x84
01D7A:  CLRF   19
01D7C:  BTFSC  FF2.7
01D7E:  BSF    19.7
01D80:  BCF    FF2.7
01D82:  MOVWF  xBA
01D84:  MOVFF  583,5B9
01D88:  MOVFF  582,5B8
01D8C:  MOVFF  581,5B7
01D90:  MOVLW  A0
01D92:  MOVWF  xBB
01D94:  MOVLB  0
01D96:  RCALL  172E
01D98:  BTFSC  19.7
01D9A:  BSF    FF2.7
....................             } 
01D9C:  BRA    1DA8
01D9E:  MOVLB  5
....................             // was an expected endstop, proceed as usual 
....................             else 
....................             { 
....................                global_valve_position = VLV_POSITION_OPENED;  
01DA0:  MOVLW  80
01DA2:  MOVLB  0
01DA4:  MOVWF  xBE
01DA6:  CLRF   xBD
01DA8:  MOVLB  5
....................             } 
....................          } 
....................       } 
....................        
....................       // Update fixture setting 
....................  
....................                   
....................       // Turn off comparator and dac 
....................       setup_DAC(DAC_OFF); 
01DAA:  MOVLB  F
01DAC:  CLRF   x41
....................       setup_comparator(NC_NC_NC_NC); 
01DAE:  CLRF   F77
01DB0:  MOVLW  04
01DB2:  MOVWF  F78
01DB4:  MOVWF  F79
....................        
....................       // Turn off CCP3 interrupt      
....................       disable_interrupts(INT_CCP3); 
01DB6:  BCF    F7A.0
....................        
....................       // reset valve movements counter 
....................       global_valve_movements_since_endstop = 0; 
01DB8:  MOVLB  0
01DBA:  CLRF   xCB
....................        
....................       // turn off the motor 
....................       mV_COASTm; 
01DBC:  CLRF   F8D
....................  
....................       // put clock speed down to 250khz again 
....................       //fosc_250k_ISR();    
....................        
....................       // turn off comparator interrupt so it isn't triggered on stop 
....................       clear_interrupt(INT_COMP);      
01DBE:  BCF    FA1.6
....................    } 
.................... } 
....................  
....................  
.................... /* 
.................... #INT_TIMER0 
.................... void tmr0_ISR(void) 
.................... { 
.................... // may not be enabled during normal operation. 
.................... // Need only for IDLING situation (long winters...) wherein every 35minutes 
.................... //  we wake up and check the battery and set a flag if there is a very low 
.................... //  battery, which then tells the idle_sleep routine to go into deep_sleep. 
.................... // this needs work. 
.................... // 
.................... // We can know if we were idling by simply checking the OSCCON for 31250Hz 
.................... //  operation, which occurs ONLY during the long winter.... 
.................... // 
....................    if (cur_state == DEV_IDLE) 
....................    { 
....................    uint8_t  nn; 
....................    // this interrupt occurred during the sleep_idle state 
....................    // check the battery, if it is so low that we need to turn off the radio, 
....................    //  then be sure to set a flag to make that happen... 
....................    // Deep_Sleep may be the result 
....................       output_high(AUX_PWR); 
....................       ADON = TRUE;         // turn on ADC 
....................       delay_cycles(50);    // insurance 
....................       set_adc_channel(V_MEAS_REF);   
....................       VfvrAD = 0;   
....................       for (nn=0; nn<4; nn++) 
....................          VfvrAD += read_adc(); 
....................       ADON = FALSE; 
....................       output_low(AUX_PWR); 
....................       if (VfvrAD > FVR_NODUST) 
....................          fl_batNODUST = TRUE; 
....................    } 
....................    else 
....................    { 
....................    // any other TIMER0 activities we may want 
....................    } 
.................... } 
.................... */ 
....................  
....................                                                           
01DC0:  BCF    FA1.6
01DC2:  GOTO   00A0
.................... #INT_CCP3 HIGH 
.................... void ccp3_ISR(void) 
.................... { 
.................... // For use in timing valve motion 
.................... //    -Updates realtime position of valve 
.................... //    -Keeps track of valve movement time (in 1024th of full scale) 
.................... //    -Turns off valve movement when position is reached 
.................... //    -updates DAC level according to position and direction of movement 
.................... // May be used for other functionality if valve is not moving 
.................... // TMR1 dedicated to CCP3 
....................     
....................    //set_timer1(TIMER1_VLV_MOVE_INIT + get_timer1()); 
....................    //temp16_frac = get_timer1();             
....................           
....................    // If the valve is in motion (not in the braked or coast mode)  
....................    if (IS_VLV_CLOSING || IS_VLV_OPENING) 
*
01F0A:  DECFSZ F8D,W
01F0C:  BRA    1F10
01F0E:  BRA    1F18
01F10:  MOVF   F8D,W
01F12:  SUBLW  02
01F14:  BTFSS  FD8.2
01F16:  BRA    206C
....................    { 
....................       // add to the time in motion variable 
....................       global_valve_time_in_motion_1024ths++; 
01F18:  INCF   xC5,F
01F1A:  BTFSC  FD8.2
01F1C:  INCF   xC6,F
....................        
....................       //check for valve movement timeout 
....................       if (global_valve_time_in_motion_1024ths > VALVE_TIMEOUT) 
01F1E:  MOVF   xC6,W
01F20:  SUBLW  04
01F22:  BC    1F84
01F24:  XORLW  FF
01F26:  BNZ   1F2E
01F28:  MOVF   xC5,W
01F2A:  SUBLW  DC
01F2C:  BC    1F84
....................       { 
....................          // turn off comparator interrupt so it isn't triggered on stop 
....................          disable_interrupts(INT_COMP); 
01F2E:  BCF    FA0.6
....................                 
....................          // turn off valve movement 
....................          mV_COASTm; 
01F30:  CLRF   F8D
....................           
....................          // Error handling for valve motion timeout 
....................          // put system into run mode (in case it's in valve cal routine) 
....................          global_system_state = SYSTEM_RUN; 
01F32:  MOVLW  02
01F34:  MOVLB  5
01F36:  MOVWF  x01
....................          // set valve to unknown position (uncalibrated) 
....................          global_valve_position = VLV_POSITION_UNKNOWN; 
01F38:  MOVLB  0
01F3A:  SETF   xBE
01F3C:  SETF   xBD
....................          // set the error bitfield and send an error 
....................          global_error_message_bitfield |= ERR_MSG_VLV_MOVE_FAIL; 
01F3E:  MOVLB  4
01F40:  BSF    xF5.2
....................          push_time_queue_ISR(global_rtc_time + 1, MSG_MOTE_ERROR_MSG); 
01F42:  MOVLW  01
01F44:  MOVLB  0
01F46:  ADDWF  x85,W
01F48:  MOVLB  5
01F4A:  MOVWF  xB3
01F4C:  MOVLW  00
01F4E:  MOVLB  0
01F50:  ADDWFC x86,W
01F52:  MOVLB  5
01F54:  MOVWF  xB4
01F56:  MOVLW  00
01F58:  MOVLB  0
01F5A:  ADDWFC x87,W
01F5C:  MOVLB  5
01F5E:  MOVWF  xB5
01F60:  MOVLW  00
01F62:  MOVLB  0
01F64:  ADDWFC x88,W
01F66:  MOVLB  5
01F68:  MOVWF  xB6
01F6A:  MOVWF  xBA
01F6C:  MOVFF  5B5,5B9
01F70:  MOVFF  5B4,5B8
01F74:  MOVFF  5B3,5B7
01F78:  MOVLW  A0
01F7A:  MOVWF  xBB
01F7C:  MOVLB  0
01F7E:  CALL   172E
....................       } 
01F82:  BRA    2060
....................        
....................       else if (IS_VLV_CLOSING) 
01F84:  DECFSZ F8D,W
01F86:  BRA    1FCC
....................       {   
....................          //set_timer1(TIMER1_VLV_MOVE_INIT); 
....................          // 0x20 is equal to one 'millispan' 
....................          if (global_valve_position >= 0x20) 
01F88:  MOVF   xBE,F
01F8A:  BNZ   1F92
01F8C:  MOVF   xBD,W
01F8E:  SUBLW  1F
01F90:  BC    1F9C
....................          { 
....................             global_valve_position -= 0x20;     
01F92:  MOVLW  20
01F94:  SUBWF  xBD,F
01F96:  MOVLW  00
01F98:  SUBWFB xBE,F
....................          } 
01F9A:  BRA    1FA0
....................          // valve is closed, unsigned int thing 
....................          else  
....................          { 
....................             global_valve_position = VLV_POSITION_CLOSED; 
01F9C:  CLRF   xBE
01F9E:  CLRF   xBD
....................          } 
....................           
....................          // if system is doing a valve recalibration, ignore valve set position 
....................          //    as it is storing the next valve position to move to 
....................          if (global_system_state == SYSTEM_RECAL_VLV_MOVES) 
01FA0:  MOVLB  5
01FA2:  MOVF   x01,W
01FA4:  SUBLW  16
01FA6:  BNZ   1FAA
....................          { 
....................             break; 
....................          }                        
01FA8:  BRA    1FC8
....................          // we have reached or exceeded the set value/target position and 
....................          //    we aren't trying to reach the endstop 
....................          else if ((global_valve_position <= global_valve_position_set_value)&&\ 
....................          (global_valve_position_set_value != VLV_POSITION_CLOSED)) 
01FAA:  MOVLB  0
01FAC:  MOVF   xBE,W
01FAE:  SUBWF  xC0,W
01FB0:  BNC   1FC6
01FB2:  BNZ   1FBA
01FB4:  MOVF   xBD,W
01FB6:  SUBWF  xBF,W
01FB8:  BNC   1FC6
01FBA:  MOVF   xBF,F
01FBC:  BNZ   1FC2
01FBE:  MOVF   xC0,F
01FC0:  BZ    1FC6
....................          { 
....................             // turn off comparator interrupt so it isn't triggered on stop 
....................             disable_interrupts(INT_COMP); 
01FC2:  BCF    FA0.6
....................              
....................             // turn off valve movement 
....................             mV_COASTm; 
01FC4:  CLRF   F8D
01FC6:  MOVLB  5
....................          } 
....................       } 
01FC8:  BRA    2062
01FCA:  MOVLB  0
....................       else if (IS_VLV_OPENING) 
01FCC:  MOVF   F8D,W
01FCE:  SUBLW  02
01FD0:  BNZ   2060
....................       {                   
....................          //0x20 is equal to one 'millispan' 
....................          global_valve_position += 0x20;       
01FD2:  MOVLW  20
01FD4:  ADDWF  xBD,F
01FD6:  MOVLW  00
01FD8:  ADDWFC xBE,F
....................        
....................          if (global_valve_position > VLV_POSITION_OPENED) 
01FDA:  MOVF   xBE,W
01FDC:  SUBLW  7F
01FDE:  BC    1FF0
01FE0:  XORLW  FF
01FE2:  BNZ   1FEA
01FE4:  MOVF   xBD,W
01FE6:  SUBLW  00
01FE8:  BC    1FF0
....................          { 
....................             global_valve_position = VLV_POSITION_OPENED;    
01FEA:  MOVLW  80
01FEC:  MOVWF  xBE
01FEE:  CLRF   xBD
....................          } 
....................           
....................          // if system is doing a valve recalibration, ignore valve set position 
....................          //    as it is storing the next valve position to move to 
....................          if (global_system_state == SYSTEM_RECAL_VLV_MOVES) 
01FF0:  MOVLB  5
01FF2:  MOVF   x01,W
01FF4:  SUBLW  16
01FF6:  BNZ   1FFA
....................          { 
....................             break; 
....................          } 
01FF8:  BRA    2062
....................          // we have reached or exceeded the set value/target position and 
....................          //    we aren't trying to reach the endstop 
....................          else if ((global_valve_position >= global_valve_position_set_value)&&\ 
....................          (global_valve_position_set_value != VLV_POSITION_OPENED)) 
01FFA:  MOVLB  0
01FFC:  MOVF   xC0,W
01FFE:  SUBWF  xBE,W
02000:  BNC   2060
02002:  BNZ   200A
02004:  MOVF   xBF,W
02006:  SUBWF  xBD,W
02008:  BNC   2060
0200A:  MOVF   xBF,F
0200C:  BNZ   2014
0200E:  MOVF   xC0,W
02010:  SUBLW  80
02012:  BZ    2060
....................          { 
....................             // turn off comparator interrupt so it isn't triggered on stop 
....................             disable_interrupts(INT_COMP); 
02014:  BCF    FA0.6
....................              
....................             // turn off valve movement 
....................             mV_COASTm; 
02016:  CLRF   F8D
....................              
....................             // Special case: if we are opening during CALIBRATE_VALVE_1 and 
....................             //    have reached our position, start the next calibration  
....................             //    sequence  
....................             if (global_system_state == SYSTEM_CAL_VLV_1) 
02018:  MOVLB  5
0201A:  MOVF   x01,W
0201C:  SUBLW  10
0201E:  BNZ   2062
....................             { 
....................                push_time_queue_ISR(global_rtc_time + 3, CALIBRATE_VALVE_2); 
02020:  MOVLW  03
02022:  MOVLB  0
02024:  ADDWF  x85,W
02026:  MOVLB  5
02028:  MOVWF  xB3
0202A:  MOVLW  00
0202C:  MOVLB  0
0202E:  ADDWFC x86,W
02030:  MOVLB  5
02032:  MOVWF  xB4
02034:  MOVLW  00
02036:  MOVLB  0
02038:  ADDWFC x87,W
0203A:  MOVLB  5
0203C:  MOVWF  xB5
0203E:  MOVLW  00
02040:  MOVLB  0
02042:  ADDWFC x88,W
02044:  MOVLB  5
02046:  MOVWF  xB6
02048:  MOVWF  xBA
0204A:  MOVFF  5B5,5B9
0204E:  MOVFF  5B4,5B8
02052:  MOVFF  5B3,5B7
02056:  MOVLW  32
02058:  MOVWF  xBB
0205A:  MOVLB  0
0205C:  CALL   172E
02060:  MOVLB  5
....................             } 
....................          } 
....................       }    
....................       // update the dac setting 
....................       set_comp_dac_level_isr(); 
02062:  MOVLB  0
02064:  BRA    1DD0
....................        
....................       // update the fixture setting 
....................        
....................       // if the valve is not moving anymore 
....................       if (IS_VLV_COASTING) 
02066:  MOVF   F8D,F
02068:  BNZ   206C
....................       { 
....................          // switch back to lower clock, turn off CCP3 interrupt 
....................             //fosc_250k_ISR(); 
....................             //#use delay(clock=250KHZ) 
....................          disable_interrupts(INT_CCP3); 
0206A:  BCF    F7A.0
....................                                                                                                         
....................       } 
....................    } 
.................... } 
....................  
....................  
0206C:  BCF    F7B.0
0206E:  GOTO   015E
.................... #INT_CCP4 
.................... void ccp4_isr(void)                     
.................... { 
....................    // real time clock interrupts      
....................    // TMR3 dedicated to CCP4      
....................                                                                                       
....................    // increment global system uptime 
....................    global_rtc_time++; 
*
02CAE:  MOVLW  01
02CB0:  ADDWF  x85,F
02CB2:  BTFSC  FD8.0
02CB4:  INCF   x86,F
02CB6:  BTFSC  FD8.2
02CB8:  INCF   x87,F
02CBA:  BTFSC  FD8.2
02CBC:  INCF   x88,F
....................    // increment utc time if mote is connected 
....................    if (global_dust_enabled) global_utc_time++; 
02CBE:  BTFSS  xA3.6
02CC0:  BRA    2CD2
02CC2:  MOVLW  01
02CC4:  ADDWF  x89,F
02CC6:  BTFSC  FD8.0
02CC8:  INCF   x8A,F
02CCA:  BTFSC  FD8.2
02CCC:  INCF   x8B,F
02CCE:  BTFSC  FD8.2
02CD0:  INCF   x8C,F
....................  
....................    // check if a time queue item needs to be run 
....................    // make sure it isn't polling an empty queue 
....................    while((global_current_time_queue_location != 255) &&                       \ 
....................    (global_current_priority_queue_location != (MAX_PRIORITY_QUEUE_ITEMS - 1)) \ 
....................    && (global_time_queue[global_current_time_queue_location].time_to_execute  \ 
....................    <= global_rtc_time)) 
02CD2:  MOVLB  3
02CD4:  INCFSZ x98,W
02CD6:  BRA    2CDA
02CD8:  BRA    2D54
02CDA:  MOVF   x7E,W
02CDC:  SUBLW  13
02CDE:  BZ    2D54
02CE0:  MOVF   x98,W
02CE2:  MULLW  05
02CE4:  MOVF   FF3,W
02CE6:  MOVLB  5
02CE8:  CLRF   x80
02CEA:  MOVWF  x7F
02CEC:  MOVLW  7F
02CEE:  ADDWF  x7F,W
02CF0:  MOVWF  FE9
02CF2:  MOVLW  03
02CF4:  ADDWFC x80,W
02CF6:  MOVWF  FEA
02CF8:  MOVFF  FEF,581
02CFC:  MOVFF  FEC,582
02D00:  MOVFF  FEC,583
02D04:  MOVFF  FEC,584
02D08:  MOVF   x84,W
02D0A:  MOVLB  0
02D0C:  SUBWF  x88,W
02D0E:  BTFSC  FD8.0
02D10:  BRA    2D16
02D12:  MOVLB  3
02D14:  BRA    2D54
02D16:  BNZ   2D4C
02D18:  MOVLB  5
02D1A:  MOVF   x83,W
02D1C:  MOVLB  0
02D1E:  SUBWF  x87,W
02D20:  BTFSC  FD8.0
02D22:  BRA    2D28
02D24:  MOVLB  3
02D26:  BRA    2D54
02D28:  BNZ   2D4C
02D2A:  MOVLB  5
02D2C:  MOVF   x82,W
02D2E:  MOVLB  0
02D30:  SUBWF  x86,W
02D32:  BTFSC  FD8.0
02D34:  BRA    2D3A
02D36:  MOVLB  3
02D38:  BRA    2D54
02D3A:  BNZ   2D4C
02D3C:  MOVLB  5
02D3E:  MOVF   x81,W
02D40:  MOVLB  0
02D42:  SUBWF  x85,W
02D44:  BTFSC  FD8.0
02D46:  BRA    2D4C
02D48:  MOVLB  3
02D4A:  BRA    2D54
....................    {                               
....................       // pop an item off the time queue and push it into the priority queue 
....................       pop_time_queue_ISR();                      
02D4C:  GOTO   2072
02D50:  BRA    2CD2
02D52:  MOVLB  3
....................    }                         
....................     
....................    // check if a message queue item needs to be run 
....................    // make sure it isn't polling an empty queue 
....................    while((global_current_message_queue_location != 255) &&                      \ 
....................       (global_message_queue[global_current_message_queue_location].time_to_send \ 
....................       <= global_rtc_time))    
02D54:  MOVLB  4
02D56:  INCFSZ xF3,W
02D58:  BRA    2D5C
02D5A:  BRA    2DD6
02D5C:  MOVF   xF3,W
02D5E:  MULLW  08
02D60:  MOVF   FF3,W
02D62:  MOVLB  5
02D64:  CLRF   x80
02D66:  MOVWF  x7F
02D68:  MOVLW  A3
02D6A:  ADDWF  x7F,W
02D6C:  MOVWF  FE9
02D6E:  MOVLW  04
02D70:  ADDWFC x80,W
02D72:  MOVWF  FEA
02D74:  MOVFF  FEF,581
02D78:  MOVFF  FEC,582
02D7C:  MOVFF  FEC,583
02D80:  MOVFF  FEC,584
02D84:  MOVF   x84,W
02D86:  MOVLB  0
02D88:  SUBWF  x88,W
02D8A:  BTFSC  FD8.0
02D8C:  BRA    2D92
02D8E:  MOVLB  4
02D90:  BRA    2DD6
02D92:  BNZ   2DC8
02D94:  MOVLB  5
02D96:  MOVF   x83,W
02D98:  MOVLB  0
02D9A:  SUBWF  x87,W
02D9C:  BTFSC  FD8.0
02D9E:  BRA    2DA4
02DA0:  MOVLB  4
02DA2:  BRA    2DD6
02DA4:  BNZ   2DC8
02DA6:  MOVLB  5
02DA8:  MOVF   x82,W
02DAA:  MOVLB  0
02DAC:  SUBWF  x86,W
02DAE:  BTFSC  FD8.0
02DB0:  BRA    2DB6
02DB2:  MOVLB  4
02DB4:  BRA    2DD6
02DB6:  BNZ   2DC8
02DB8:  MOVLB  5
02DBA:  MOVF   x81,W
02DBC:  MOVLB  0
02DBE:  SUBWF  x85,W
02DC0:  BTFSC  FD8.0
02DC2:  BRA    2DC8
02DC4:  MOVLB  4
02DC6:  BRA    2DD6
....................    {                     
....................       // disable mote interrupt so payload_buf doesn't get overwritten 
....................       disable_interrupts(INT_EXT2_H2L);   
02DC8:  BCF    FF0.4
....................       // send message and requeue it at a later date if not ack'd 
....................       pop_message_queue_and_send_ISR(); 
02DCA:  BRA    2702
....................       // re-enable mote interrupt                     
....................       enable_interrupts(INT_EXT2_H2L);     
02DCC:  BSF    FF0.4
02DCE:  BCF    FF1.4
02DD0:  MOVLB  3
02DD2:  BRA    2D54
02DD4:  MOVLB  4
....................    }                                   
....................     
....................     
....................    // check if a sprinkler queue item needs to be run and make sure it isn't polling an empty queue        
....................    // Note: The queue contains things that are to be run, not the current item running.             
....................    while((global_current_sprinkler_queue_location != 255) &&                      \ 
....................       (global_sprinkler_queue[global_current_sprinkler_queue_location].start_time \ 
....................       <= global_utc_time)) 
02DD6:  INCFSZ x25,W
02DD8:  BRA    2DDC
02DDA:  BRA    2EB6
02DDC:  MOVF   x25,W
02DDE:  MULLW  0E
02DE0:  MOVF   FF3,W
02DE2:  MOVLB  5
02DE4:  CLRF   x80
02DE6:  MOVWF  x7F
02DE8:  MOVLW  99
02DEA:  ADDWF  x7F,W
02DEC:  MOVWF  FE9
02DEE:  MOVLW  03
02DF0:  ADDWFC x80,W
02DF2:  MOVWF  FEA
02DF4:  MOVFF  FEF,581
02DF8:  MOVFF  FEC,582
02DFC:  MOVFF  FEC,583
02E00:  MOVFF  FEC,584
02E04:  MOVF   x84,W
02E06:  MOVLB  0
02E08:  SUBWF  x8C,W
02E0A:  BTFSC  FD8.0
02E0C:  BRA    2E12
02E0E:  MOVLB  4
02E10:  BRA    2EB6
02E12:  BNZ   2E48
02E14:  MOVLB  5
02E16:  MOVF   x83,W
02E18:  MOVLB  0
02E1A:  SUBWF  x8B,W
02E1C:  BTFSC  FD8.0
02E1E:  BRA    2E24
02E20:  MOVLB  4
02E22:  BRA    2EB6
02E24:  BNZ   2E48
02E26:  MOVLB  5
02E28:  MOVF   x82,W
02E2A:  MOVLB  0
02E2C:  SUBWF  x8A,W
02E2E:  BTFSC  FD8.0
02E30:  BRA    2E36
02E32:  MOVLB  4
02E34:  BRA    2EB6
02E36:  BNZ   2E48
02E38:  MOVLB  5
02E3A:  MOVF   x81,W
02E3C:  MOVLB  0
02E3E:  SUBWF  x89,W
02E40:  BTFSC  FD8.0
02E42:  BRA    2E48
02E44:  MOVLB  4
02E46:  BRA    2EB6
....................    {   
....................       // if the system is in the SYSTEM_IDLE state, bump it into the SYSTEM_RUN state. 
....................       if (global_system_state == SYSTEM_IDLE) global_system_state = SYSTEM_RUN;       
02E48:  MOVLB  5
02E4A:  MOVF   x01,W
02E4C:  SUBLW  03
02E4E:  BNZ   2E54
02E50:  MOVLW  02
02E52:  MOVWF  x01
....................                                    
....................       // if system is not in run state, do not stop the item.  Send an error  
....................       //    stating that the stop time is delayed 
....................       if (global_system_state != SYSTEM_RUN)                        
02E54:  MOVF   x01,W
02E56:  SUBLW  02
02E58:  BZ    2EAE
....................       {                       
....................          global_error_message_bitfield |= ERR_MSG_SPINKLER_CMD_DELAYED_INVALID_STATE; 
02E5A:  MOVLB  4
02E5C:  BSF    xF5.6
....................          push_time_queue_ISR(global_rtc_time + 1, MSG_MOTE_ERROR_MSG); 
02E5E:  MOVLW  01
02E60:  MOVLB  0
02E62:  ADDWF  x85,W
02E64:  MOVLB  5
02E66:  MOVWF  x7F
02E68:  MOVLW  00
02E6A:  MOVLB  0
02E6C:  ADDWFC x86,W
02E6E:  MOVLB  5
02E70:  MOVWF  x80
02E72:  MOVLW  00
02E74:  MOVLB  0
02E76:  ADDWFC x87,W
02E78:  MOVLB  5
02E7A:  MOVWF  x81
02E7C:  MOVLW  00
02E7E:  MOVLB  0
02E80:  ADDWFC x88,W
02E82:  MOVLB  5
02E84:  MOVWF  x82
02E86:  CLRF   19
02E88:  BTFSC  FF2.7
02E8A:  BSF    19.7
02E8C:  BCF    FF2.7
02E8E:  MOVWF  xBA
02E90:  MOVFF  581,5B9
02E94:  MOVFF  580,5B8
02E98:  MOVFF  57F,5B7
02E9C:  MOVLW  A0
02E9E:  MOVWF  xBB
02EA0:  MOVLB  0
02EA2:  CALL   172E
02EA6:  BTFSC  19.7
02EA8:  BSF    FF2.7
....................       } 
02EAA:  BRA    2EB2
02EAC:  MOVLB  5
....................       else 
....................       { 
....................          // pop an item off the time queue and push it into the priority queue 
....................          pop_sprinkler_queue_ISR(); 
02EAE:  MOVLB  0
02EB0:  BRA    2A74
....................       } 
02EB2:  MOVLB  4
02EB4:  BRA    2DD6
....................    }            
....................                                                                  
....................    // check if a sprinkler queue item needs to be stopped 
....................    if (global_current_sprinkler_settings_end_time <= global_utc_time) 
02EB6:  MOVF   x29,W
02EB8:  MOVLB  0
02EBA:  SUBWF  x8C,W
02EBC:  BNC   2F50
02EBE:  BNZ   2EE2
02EC0:  MOVLB  4
02EC2:  MOVF   x28,W
02EC4:  MOVLB  0
02EC6:  SUBWF  x8B,W
02EC8:  BNC   2F50
02ECA:  BNZ   2EE2
02ECC:  MOVLB  4
02ECE:  MOVF   x27,W
02ED0:  MOVLB  0
02ED2:  SUBWF  x8A,W
02ED4:  BNC   2F50
02ED6:  BNZ   2EE2
02ED8:  MOVLB  4
02EDA:  MOVF   x26,W
02EDC:  MOVLB  0
02EDE:  SUBWF  x89,W
02EE0:  BNC   2F50
....................    {                         
....................       // if the system is in the SYSTEM_IDLE state, bump it into the SYSTEM_RUN state. 
....................       if (global_system_state == SYSTEM_IDLE) global_system_state == SYSTEM_RUN;   
02EE2:  MOVLB  5
02EE4:  MOVF   x01,W
02EE6:  SUBLW  03
02EE8:  BNZ   2EF2
02EEA:  MOVF   x01,W
02EEC:  SUBLW  02
02EEE:  BZ    2EF2
02EF0:  MOVLW  00
....................                                                                                            
....................       // if system is not in run state, do not stop the item.  Send an error 
....................       //    stating that the stop time is delayed 
....................       if (global_system_state != SYSTEM_RUN) 
02EF2:  MOVF   x01,W
02EF4:  SUBLW  02
02EF6:  BZ    2F4C
....................       { 
....................          global_error_message_bitfield |= ERR_MSG_SPINKLER_CMD_DELAYED_INVALID_STATE; 
02EF8:  MOVLB  4
02EFA:  BSF    xF5.6
....................          push_time_queue_ISR(global_rtc_time + 1, MSG_MOTE_ERROR_MSG); 
02EFC:  MOVLW  01
02EFE:  MOVLB  0
02F00:  ADDWF  x85,W
02F02:  MOVLB  5
02F04:  MOVWF  x7F
02F06:  MOVLW  00
02F08:  MOVLB  0
02F0A:  ADDWFC x86,W
02F0C:  MOVLB  5
02F0E:  MOVWF  x80
02F10:  MOVLW  00
02F12:  MOVLB  0
02F14:  ADDWFC x87,W
02F16:  MOVLB  5
02F18:  MOVWF  x81
02F1A:  MOVLW  00
02F1C:  MOVLB  0
02F1E:  ADDWFC x88,W
02F20:  MOVLB  5
02F22:  MOVWF  x82
02F24:  CLRF   19
02F26:  BTFSC  FF2.7
02F28:  BSF    19.7
02F2A:  BCF    FF2.7
02F2C:  MOVWF  xBA
02F2E:  MOVFF  581,5B9
02F32:  MOVFF  580,5B8
02F36:  MOVFF  57F,5B7
02F3A:  MOVLW  A0
02F3C:  MOVWF  xBB
02F3E:  MOVLB  0
02F40:  CALL   172E
02F44:  BTFSC  19.7
02F46:  BSF    FF2.7
....................       }              
02F48:  BRA    2F50
02F4A:  MOVLB  5
....................                                                     
....................       /*  
....................       // if you're stopping the current item and there are no more in the queue, turn off the control 
....................       //    loop.                             
....................       else if (global_current_sprinkler_queue_location == 255) 
....................       {   
....................          global_control_loop_mechanism = NO_SPRINKLER_CONTROL; 
....................       }        
....................       */                                          
....................                               
....................       else 
....................       {                   
....................          // stop the current sprinkler setting 
....................          stop_current_spinkler_setting_ISR(); 
02F4C:  MOVLB  0
02F4E:  BRA    2C7E
....................       }              
....................    } 
....................      
....................      
....................      
....................     
....................    // check to see if system should enter SYSTEM_IDLE (low-power) state 
....................    // 
....................    // First condition for SYSTEM_IDLE: 
....................    //    system already in SYSTEM_RUN    
....................    //    Closed valve (or unknown)        
....................    //    no valve movement 
....................    //    rpm = 0     
....................    if (((global_valve_position == VLV_POSITION_CLOSED) ||                                              \      
....................       (global_valve_position == VLV_POSITION_UNKNOWN)) && (IS_VLV_COASTING) &&                         \ 
....................       ((global_rtc_time - global_last_rpm_value_time) > RPM_TIMEOUT))            
02F50:  MOVF   xBD,F
02F52:  BNZ   2F58
02F54:  MOVF   xBE,F
02F56:  BZ    2F60
02F58:  INCFSZ xBD,W
02F5A:  BRA    2FBA
02F5C:  INCFSZ xBE,W
02F5E:  BRA    2FBA
02F60:  MOVF   F8D,F
02F62:  BNZ   2FBA
02F64:  MOVF   xAA,W
02F66:  SUBWF  x85,W
02F68:  MOVLB  5
02F6A:  MOVWF  x7F
02F6C:  MOVLB  0
02F6E:  MOVF   xAB,W
02F70:  SUBWFB x86,W
02F72:  MOVLB  5
02F74:  MOVWF  x80
02F76:  MOVLB  0
02F78:  MOVF   xAC,W
02F7A:  SUBWFB x87,W
02F7C:  MOVLB  5
02F7E:  MOVWF  x81
02F80:  MOVLB  0
02F82:  MOVF   xAD,W
02F84:  SUBWFB x88,W
02F86:  MOVLB  5
02F88:  MOVWF  x82
02F8A:  MOVF   x82,F
02F8C:  BNZ   2FAC
02F8E:  MOVF   x81,F
02F90:  BNZ   2FAC
02F92:  MOVF   x1E,W
02F94:  SUBWF  x80,W
02F96:  BTFSC  FD8.0
02F98:  BRA    2F9E
02F9A:  MOVLB  0
02F9C:  BRA    2FBA
02F9E:  BNZ   2FAC
02FA0:  MOVF   x7F,W
02FA2:  SUBWF  x1D,W
02FA4:  BTFSS  FD8.0
02FA6:  BRA    2FAC
02FA8:  MOVLB  0
02FAA:  BRA    2FBA
....................    {                                   
....................       // change processor speed?      
....................       // change state to idle        
....................        if (global_system_state == SYSTEM_RUN)  
02FAC:  MOVF   x01,W
02FAE:  SUBLW  02
02FB0:  BNZ   2FB6
....................        { 
....................          global_system_state = SYSTEM_IDLE; 
02FB2:  MOVLW  03
02FB4:  MOVWF  x01
....................          //fosc_31250_ISR();  
....................        } 
....................    }                                         
02FB6:  BRA    3000
02FB8:  MOVLB  0
....................    // Second condition for SYSTEM_IDLE:                
....................    //    system already in SYSTEM_RUN    
....................    //    global_control_loop_mechanism is in either NO_RPM_CONTROL (test command) or NO_SPRINKLER_CONTROL        
....................    //    no valve movement         
....................    //    brake, charge, and mppc values are at their set points 
....................    else if (((global_control_loop_mechanism == NO_RPM_CONTROL)||                                      \ 
....................       (global_control_loop_mechanism == NO_SPRINKLER_CONTROL)) && (IS_VLV_COASTING) &&                \ 
....................       (global_brake_duty == global_brake_duty_set_value) &&                                           \ 
....................       (global_charge_duty == global_charge_duty_set_value) &&                                         \ 
....................       (global_mppc_value == global_mppc_set_value)) 
02FBA:  MOVF   xBC,W
02FBC:  SUBLW  05
02FBE:  BZ    2FC4
02FC0:  INCFSZ xBC,W
02FC2:  BRA    2FF4
02FC4:  MOVF   F8D,F
02FC6:  BNZ   2FF4
02FC8:  MOVF   xB2,W
02FCA:  SUBWF  xAE,W
02FCC:  BNZ   2FF4
02FCE:  MOVF   xB3,W
02FD0:  SUBWF  xAF,W
02FD2:  BNZ   2FF4
02FD4:  MOVF   xB4,W
02FD6:  SUBWF  xB0,W
02FD8:  BNZ   2FF4
02FDA:  MOVF   xB5,W
02FDC:  SUBWF  xB1,W
02FDE:  BNZ   2FF4
02FE0:  MOVF   xB7,W
02FE2:  SUBWF  xB6,W
02FE4:  BNZ   2FF4
....................    {                                               
....................       // change processor speed?  
....................       // change state to idle 
....................       if (global_system_state == SYSTEM_RUN)    
02FE6:  MOVLB  5
02FE8:  MOVF   x01,W
02FEA:  SUBLW  02
02FEC:  BNZ   2FF2
....................       { 
....................          global_system_state = SYSTEM_IDLE; 
02FEE:  MOVLW  03
02FF0:  MOVWF  x01
....................          //fosc_31250_ISR();  
....................       }                
....................    }                       
02FF2:  BRA    3000
....................    // if above conditions are not met and system is in idle mode, put it into run mode 
....................    else if (global_system_state == SYSTEM_IDLE)          
02FF4:  MOVLB  5
02FF6:  MOVF   x01,W
02FF8:  SUBLW  03
02FFA:  BNZ   3000
....................    {                                  
....................       // change processor speed?    
....................       // change state to run state       
....................        global_system_state = SYSTEM_RUN;  
02FFC:  MOVLW  02
02FFE:  MOVWF  x01
....................        //fosc_250k_ISR();  
....................    }                            
....................                                                           
....................      
....................    // update lcd every second                                 
....................    PUSH_PRIORITY_QUEUE_ISR_MACRO(LCD_UPDATE);    
03000:  MOVLW  D4
03002:  MOVWF  x9B
03004:  MOVLB  0
03006:  CALL   0808
....................  
....................    // periodic system checkups (all in one to minimize divides) 
....................    // - mote state (reacts as necessary)    
....................    // - battery state (turns off/on charging, sends warnings, etc.) 
....................    // - mote temp (logs data, sends warnings, etc.) 
....................    // - mote utc time (updates utc time if valid) 
....................    if ((global_rtc_time % PERIODIC_CHECKS_TIME) == 0)      
0300A:  MOVF   x85,W
0300C:  ANDLW  1F
0300E:  MOVLB  5
03010:  MOVWF  x7F
03012:  CLRF   x80
03014:  CLRF   x81
03016:  CLRF   x82
03018:  MOVF   x7F,F
0301A:  BNZ   3058
0301C:  MOVF   x80,F
0301E:  BNZ   3058
03020:  MOVF   x81,F
03022:  BNZ   3058
03024:  MOVF   x82,F
03026:  BNZ   3058
....................    {                                                  
....................       PUSH_PRIORITY_QUEUE_ISR_MACRO(CHECK_MOTE_STATE);  
03028:  MOVLW  B4
0302A:  MOVWF  x9B
0302C:  MOVLB  0
0302E:  CALL   0808
....................       PUSH_PRIORITY_QUEUE_ISR_MACRO(CHECK_BATTERY_STATE);    
03032:  MOVLW  A1
03034:  MOVLB  5
03036:  MOVWF  x9B
03038:  MOVLB  0
0303A:  CALL   0808
....................       PUSH_PRIORITY_QUEUE_ISR_MACRO(CHECK_MOTE_TEMP); 
0303E:  MOVLW  A2
03040:  MOVLB  5
03042:  MOVWF  x9B
03044:  MOVLB  0
03046:  CALL   0808
....................       PUSH_PRIORITY_QUEUE_ISR_MACRO(UPDATE_MOTE_TIME); 
0304A:  MOVLW  A3
0304C:  MOVLB  5
0304E:  MOVWF  x9B
03050:  MOVLB  0
03052:  CALL   0808
03056:  MOVLB  5
....................    }                                                                                                                           
.................... } 
....................  
03058:  BCF    F7B.1
0305A:  MOVLB  0
0305C:  GOTO   00A0
.................... #INT_CCP5 FAST 
.................... void CCP5_ISR(void) 
.................... { 
.................... // GEN_RPM event capture for determining speed of rotation 
.................... // We need the CCP5 interrupt routine to be very fast because  
.................... //  the sprinkler can be spinning fast enough to generate 500 pulses per sec! 
.................... // With a 250KHz system clock, 2ms may be trouble with the full normal interrupt 
.................... //  overhead.... 
.................... // TMR5 dedicated to CCP5 
....................     
....................    static uint16_t ccp5_value = 0, ccp5_value_prev = 0; 
....................     
....................    // save previous sample  
....................    ccp5_value_prev = ccp5_value; 
03060:  MOVFF  541,543
03064:  MOVFF  540,542
....................     
....................    // get current sample      
....................    ccp5_value = CCP_5;          
03068:  MOVFF  F56,541
0306C:  MOVFF  F55,540
....................                                    
....................    // disable INT_CCP4 to ensure safe grabbing of global_rtc_time                        
....................    disable_interrupts(INT_CCP4);              
03070:  BCF    F7A.1
....................    // check if a current period measurement is even valid 
....................    if ((global_rtc_time - global_last_rpm_value_time) > RPM_TIMEOUT)   
03072:  MOVF   xAA,W
03074:  SUBWF  x85,W
03076:  MOVLB  5
03078:  MOVWF  xB3
0307A:  MOVLB  0
0307C:  MOVF   xAB,W
0307E:  SUBWFB x86,W
03080:  MOVLB  5
03082:  MOVWF  xB4
03084:  MOVLB  0
03086:  MOVF   xAC,W
03088:  SUBWFB x87,W
0308A:  MOVLB  5
0308C:  MOVWF  xB5
0308E:  MOVLB  0
03090:  MOVF   xAD,W
03092:  SUBWFB x88,W
03094:  MOVLB  5
03096:  MOVWF  xB6
03098:  MOVF   xB6,F
0309A:  BNZ   30AE
0309C:  MOVF   xB5,F
0309E:  BNZ   30AE
030A0:  MOVF   x1E,W
030A2:  SUBWF  xB4,W
030A4:  BNC   30C0
030A6:  BNZ   30AE
030A8:  MOVF   xB3,W
030AA:  SUBWF  x1D,W
030AC:  BC    30C0
....................    { 
....................       // save the last time a measurement was take to figure out if system is spinning outside of this routine.     
....................       global_last_rpm_value_time = global_rtc_time;      
030AE:  MOVFF  88,AD
030B2:  MOVFF  87,AC
030B6:  MOVFF  86,AB
030BA:  MOVFF  85,AA
....................       break;                                          
....................    }                              
030BE:  BRA    30D4
....................    else            
....................    {                                                                
....................       // calc current difference/global period     
....................       global_current_period = ccp5_value - ccp5_value_prev;       
030C0:  MOVF   x42,W
030C2:  SUBWF  x40,W
030C4:  MOVLB  0
030C6:  MOVWF  xA4
030C8:  MOVLB  5
030CA:  MOVF   x43,W
030CC:  SUBWFB x41,W
030CE:  MOVLB  0
030D0:  MOVWF  xA5
030D2:  MOVLB  5
....................    }                                           
....................    // save the last time a measurement was take to figure out if system is spinning outside of this routine.     
....................    global_last_rpm_value_time = global_rtc_time;   
030D4:  MOVFF  88,AD
030D8:  MOVFF  87,AC
030DC:  MOVFF  86,AB
030E0:  MOVFF  85,AA
....................    // re-enable INT_CCP4 after grabbing global rtc time        
....................    enable_interrupts(INT_CCP4);  
030E4:  BSF    F7A.1
030E6:  BCF    F7B.2
030E8:  RETFIE 1
.................... } 
....................                                     

Configuration Fuses:
   Word  1: 8200   HSH NOPLLEN PRIMARY_SW NOFCMEN IESO
   Word  2: 2218   PUT NOBROWNOUT BORV19 WDT_SW WDT256
   Word  3: A800   CCP2B3 NOPBADEN CCP3E0 HFOFST TIMER3B5 CCP2D2 MCLR
   Word  4: 0081   STVREN NOLVP NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
