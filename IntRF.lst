CCS PCH C Compiler, Version 5.051, 21086               16-Feb-17 15:18

               Filename:   C:\Users\Brian\Dropbox\Metrionix\Firmware\2017-02-14 - E314\IntRF.lst

               ROM used:   45010 bytes (69%)
                           Largest free fragment is 20522
               RAM used:   1359 (35%) at main() level
                           1483 (38%) worst case
               Stack used: 10 locations (5 in main + 5 for interrupts)
               Stack size: 31

*
00000:  GOTO   9F0C
*
00008:  GOTO   00EE
0000C:  NOP   
0000E:  NOP   
00010:  NOP   
00012:  NOP   
00014:  NOP   
00016:  NOP   
00018:  MOVWF  04
0001A:  MOVFF  FD8,05
0001E:  MOVFF  FE0,06
00022:  MOVLB  0
00024:  MOVFF  FE9,0C
00028:  MOVFF  FEA,07
0002C:  MOVFF  FE1,08
00030:  MOVFF  FE2,09
00034:  MOVFF  FD9,0A
00038:  MOVFF  FDA,0B
0003C:  MOVFF  FF3,12
00040:  MOVFF  FF4,13
00044:  MOVFF  FFA,14
00048:  MOVFF  FF5,15
0004C:  MOVFF  FF6,16
00050:  MOVFF  FF7,17
00054:  MOVFF  00,0E
00058:  MOVFF  01,0F
0005C:  MOVFF  02,10
00060:  MOVFF  03,11
00064:  BTFSS  FA0.6
00066:  GOTO   0070
0006A:  BTFSC  FA1.6
0006C:  GOTO   1A6E
00070:  BTFSS  FF0.4
00072:  GOTO   007C
00076:  BTFSC  FF0.1
00078:  GOTO   17A8
0007C:  BTFSS  F7A.1
0007E:  GOTO   0088
00082:  BTFSC  F7B.1
00084:  GOTO   2E1E
00088:  BTFSS  FA0.3
0008A:  GOTO   0094
0008E:  BTFSC  FA1.3
00090:  GOTO   08DC
00094:  BTFSS  FF2.3
00096:  GOTO   00A0
0009A:  BTFSC  FF2.0
0009C:  GOTO   07EC
000A0:  MOVFF  0E,00
000A4:  MOVFF  0F,01
000A8:  MOVFF  10,02
000AC:  MOVFF  11,03
000B0:  MOVFF  0C,FE9
000B4:  MOVFF  07,FEA
000B8:  BSF    07.7
000BA:  MOVFF  08,FE1
000BE:  MOVFF  09,FE2
000C2:  MOVFF  0A,FD9
000C6:  MOVFF  0B,FDA
000CA:  MOVFF  12,FF3
000CE:  MOVFF  13,FF4
000D2:  MOVFF  14,FFA
000D6:  MOVFF  15,FF5
000DA:  MOVFF  16,FF6
000DE:  MOVFF  17,FF7
000E2:  MOVF   04,W
000E4:  MOVFF  06,FE0
000E8:  MOVFF  05,FD8
000EC:  RETFIE 0
000EE:  MOVWF  1A
000F0:  MOVFF  FD8,1B
000F4:  MOVFF  FE0,1C
000F8:  MOVLB  0
000FA:  MOVFF  FE9,22
000FE:  MOVFF  FEA,1D
00102:  MOVFF  FE1,1E
00106:  MOVFF  FE2,1F
0010A:  MOVFF  FD9,20
0010E:  MOVFF  FDA,21
00112:  MOVFF  FF3,28
00116:  MOVFF  FF4,29
0011A:  MOVFF  FFA,2A
0011E:  MOVFF  FF5,2B
00122:  MOVFF  FF6,2C
00126:  MOVFF  FF7,2D
0012A:  MOVFF  00,24
0012E:  MOVFF  01,25
00132:  MOVFF  02,26
00136:  MOVFF  03,27
0013A:  BTFSS  F7A.2
0013C:  GOTO   0146
00140:  BTFSC  F7B.2
00142:  GOTO   317A
00146:  BTFSS  F7A.0
00148:  GOTO   0152
0014C:  BTFSC  F7B.0
0014E:  GOTO   2046
00152:  BTFSS  FF2.4
00154:  GOTO   015E
00158:  BTFSC  FF2.1
0015A:  GOTO   0822
0015E:  MOVFF  24,00
00162:  MOVFF  25,01
00166:  MOVFF  26,02
0016A:  MOVFF  27,03
0016E:  MOVFF  22,FE9
00172:  MOVFF  1D,FEA
00176:  BSF    1D.7
00178:  MOVFF  1E,FE1
0017C:  MOVFF  1F,FE2
00180:  MOVFF  20,FD9
00184:  MOVFF  21,FDA
00188:  MOVFF  28,FF3
0018C:  MOVFF  29,FF4
00190:  MOVFF  2A,FFA
00194:  MOVFF  2B,FF5
00198:  MOVFF  2C,FF6
0019C:  MOVFF  2D,FF7
001A0:  MOVF   1A,W
001A2:  MOVFF  1C,FE0
001A6:  MOVFF  1B,FD8
001AA:  RETFIE 0
.................... // required device includes/settings 
.................... #include <18F46K22.h> 
.................... //////////// Standard Header file for the PIC18F46K22 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F46K22 
001AC:  ADDLW  BA
001AE:  MOVWF  FF6
001B0:  MOVLW  01
001B2:  ADDWFC FF7,F
001B4:  TBLRD*+
001B6:  MOVF   FF5,W
001B8:  RETURN 0
001BA:  DATA 00,00
001BC:  DATA 89,11
001BE:  DATA 12,23
001C0:  DATA 9B,32
001C2:  DATA 24,46
001C4:  DATA AD,57
001C6:  DATA 36,65
001C8:  DATA BF,74
001CA:  DATA 48,8C
001CC:  DATA C1,9D
001CE:  DATA 5A,AF
001D0:  DATA D3,BE
001D2:  DATA 6C,CA
001D4:  DATA E5,DB
001D6:  DATA 7E,E9
001D8:  DATA F7,F8
001DA:  DATA 81,10
001DC:  DATA 08,01
001DE:  DATA 93,33
001E0:  DATA 1A,22
001E2:  DATA A5,56
001E4:  DATA 2C,47
001E6:  DATA B7,75
001E8:  DATA 3E,64
001EA:  DATA C9,9C
001EC:  DATA 40,8D
001EE:  DATA DB,BF
001F0:  DATA 52,AE
001F2:  DATA ED,DA
001F4:  DATA 64,CB
001F6:  DATA FF,F9
001F8:  DATA 76,E8
001FA:  DATA 02,21
001FC:  DATA 8B,30
001FE:  DATA 10,02
00200:  DATA 99,13
00202:  DATA 26,67
00204:  DATA AF,76
00206:  DATA 34,44
00208:  DATA BD,55
0020A:  DATA 4A,AD
0020C:  DATA C3,BC
0020E:  DATA 58,8E
00210:  DATA D1,9F
00212:  DATA 6E,EB
00214:  DATA E7,FA
00216:  DATA 7C,C8
00218:  DATA F5,D9
0021A:  DATA 83,31
0021C:  DATA 0A,20
0021E:  DATA 91,12
00220:  DATA 18,03
00222:  DATA A7,77
00224:  DATA 2E,66
00226:  DATA B5,54
00228:  DATA 3C,45
0022A:  DATA CB,BD
0022C:  DATA 42,AC
0022E:  DATA D9,9E
00230:  DATA 50,8F
00232:  DATA EF,FB
00234:  DATA 66,EA
00236:  DATA FD,D8
00238:  DATA 74,C9
0023A:  DATA 04,42
0023C:  DATA 8D,53
0023E:  DATA 16,61
00240:  DATA 9F,70
00242:  DATA 20,04
00244:  DATA A9,15
00246:  DATA 32,27
00248:  DATA BB,36
0024A:  DATA 4C,CE
0024C:  DATA C5,DF
0024E:  DATA 5E,ED
00250:  DATA D7,FC
00252:  DATA 68,88
00254:  DATA E1,99
00256:  DATA 7A,AB
00258:  DATA F3,BA
0025A:  DATA 85,52
0025C:  DATA 0C,43
0025E:  DATA 97,71
00260:  DATA 1E,60
00262:  DATA A1,14
00264:  DATA 28,05
00266:  DATA B3,37
00268:  DATA 3A,26
0026A:  DATA CD,DE
0026C:  DATA 44,CF
0026E:  DATA DF,FD
00270:  DATA 56,EC
00272:  DATA E9,98
00274:  DATA 60,89
00276:  DATA FB,BB
00278:  DATA 72,AA
0027A:  DATA 06,63
0027C:  DATA 8F,72
0027E:  DATA 14,40
00280:  DATA 9D,51
00282:  DATA 22,25
00284:  DATA AB,34
00286:  DATA 30,06
00288:  DATA B9,17
0028A:  DATA 4E,EF
0028C:  DATA C7,FE
0028E:  DATA 5C,CC
00290:  DATA D5,DD
00292:  DATA 6A,A9
00294:  DATA E3,B8
00296:  DATA 78,8A
00298:  DATA F1,9B
0029A:  DATA 87,73
0029C:  DATA 0E,62
0029E:  DATA 95,50
002A0:  DATA 1C,41
002A2:  DATA A3,35
002A4:  DATA 2A,24
002A6:  DATA B1,16
002A8:  DATA 38,07
002AA:  DATA CF,FF
002AC:  DATA 46,EE
002AE:  DATA DD,DC
002B0:  DATA 54,CD
002B2:  DATA EB,B9
002B4:  DATA 62,A8
002B6:  DATA F9,9A
002B8:  DATA 70,8B
002BA:  DATA 08,84
002BC:  DATA 81,95
002BE:  DATA 1A,A7
002C0:  DATA 93,B6
002C2:  DATA 2C,C2
002C4:  DATA A5,D3
002C6:  DATA 3E,E1
002C8:  DATA B7,F0
002CA:  DATA 40,08
002CC:  DATA C9,19
002CE:  DATA 52,2B
002D0:  DATA DB,3A
002D2:  DATA 64,4E
002D4:  DATA ED,5F
002D6:  DATA 76,6D
002D8:  DATA FF,7C
002DA:  DATA 89,94
002DC:  DATA 00,85
002DE:  DATA 9B,B7
002E0:  DATA 12,A6
002E2:  DATA AD,D2
002E4:  DATA 24,C3
002E6:  DATA BF,F1
002E8:  DATA 36,E0
002EA:  DATA C1,18
002EC:  DATA 48,09
002EE:  DATA D3,3B
002F0:  DATA 5A,2A
002F2:  DATA E5,5E
002F4:  DATA 6C,4F
002F6:  DATA F7,7D
002F8:  DATA 7E,6C
002FA:  DATA 0A,A5
002FC:  DATA 83,B4
002FE:  DATA 18,86
00300:  DATA 91,97
00302:  DATA 2E,E3
00304:  DATA A7,F2
00306:  DATA 3C,C0
00308:  DATA B5,D1
0030A:  DATA 42,29
0030C:  DATA CB,38
0030E:  DATA 50,0A
00310:  DATA D9,1B
00312:  DATA 66,6F
00314:  DATA EF,7E
00316:  DATA 74,4C
00318:  DATA FD,5D
0031A:  DATA 8B,B5
0031C:  DATA 02,A4
0031E:  DATA 99,96
00320:  DATA 10,87
00322:  DATA AF,F3
00324:  DATA 26,E2
00326:  DATA BD,D0
00328:  DATA 34,C1
0032A:  DATA C3,39
0032C:  DATA 4A,28
0032E:  DATA D1,1A
00330:  DATA 58,0B
00332:  DATA E7,7F
00334:  DATA 6E,6E
00336:  DATA F5,5C
00338:  DATA 7C,4D
0033A:  DATA 0C,C6
0033C:  DATA 85,D7
0033E:  DATA 1E,E5
00340:  DATA 97,F4
00342:  DATA 28,80
00344:  DATA A1,91
00346:  DATA 3A,A3
00348:  DATA B3,B2
0034A:  DATA 44,4A
0034C:  DATA CD,5B
0034E:  DATA 56,69
00350:  DATA DF,78
00352:  DATA 60,0C
00354:  DATA E9,1D
00356:  DATA 72,2F
00358:  DATA FB,3E
0035A:  DATA 8D,D6
0035C:  DATA 04,C7
0035E:  DATA 9F,F5
00360:  DATA 16,E4
00362:  DATA A9,90
00364:  DATA 20,81
00366:  DATA BB,B3
00368:  DATA 32,A2
0036A:  DATA C5,5A
0036C:  DATA 4C,4B
0036E:  DATA D7,79
00370:  DATA 5E,68
00372:  DATA E1,1C
00374:  DATA 68,0D
00376:  DATA F3,3F
00378:  DATA 7A,2E
0037A:  DATA 0E,E7
0037C:  DATA 87,F6
0037E:  DATA 1C,C4
00380:  DATA 95,D5
00382:  DATA 2A,A1
00384:  DATA A3,B0
00386:  DATA 38,82
00388:  DATA B1,93
0038A:  DATA 46,6B
0038C:  DATA CF,7A
0038E:  DATA 54,48
00390:  DATA DD,59
00392:  DATA 62,2D
00394:  DATA EB,3C
00396:  DATA 70,0E
00398:  DATA F9,1F
0039A:  DATA 8F,F7
0039C:  DATA 06,E6
0039E:  DATA 9D,D4
003A0:  DATA 14,C5
003A2:  DATA AB,B1
003A4:  DATA 22,A0
003A6:  DATA B9,92
003A8:  DATA 30,83
003AA:  DATA C7,7B
003AC:  DATA 4E,6A
003AE:  DATA D5,58
003B0:  DATA 5C,49
003B2:  DATA E3,3D
003B4:  DATA 6A,2C
003B6:  DATA F1,1E
003B8:  DATA 78,0F
003BA:  CLRF   FF7
003BC:  ADDLW  CA
003BE:  MOVWF  FF6
003C0:  MOVLW  03
003C2:  ADDWFC FF7,F
003C4:  TBLRD*+
003C6:  MOVF   FF5,W
003C8:  RETURN 0
003CA:  DATA 45,6E
003CC:  DATA 74,65
003CE:  DATA 72,20
003D0:  DATA 44,65
003D2:  DATA 65,70
003D4:  DATA 20,53
003D6:  DATA 6C,65
003D8:  DATA 65,70
003DA:  DATA 00,00
003DC:  CLRF   FF7
003DE:  ADDLW  EC
003E0:  MOVWF  FF6
003E2:  MOVLW  03
003E4:  ADDWFC FF7,F
003E6:  TBLRD*+
003E8:  MOVF   FF5,W
003EA:  RETURN 0
003EC:  DATA 52,65
003EE:  DATA 61,73
003F0:  DATA 6F,6E
003F2:  DATA 3A,20
003F4:  DATA 20,20
003F6:  DATA 20,20
003F8:  DATA 20,20
003FA:  DATA 20,20
003FC:  DATA 00,00
003FE:  CLRF   FF7
00400:  ADDLW  0E
00402:  MOVWF  FF6
00404:  MOVLW  04
00406:  ADDWFC FF7,F
00408:  TBLRD*+
0040A:  MOVF   FF5,W
0040C:  RETURN 0
0040E:  DATA 20,53
00410:  DATA 65,61
00412:  DATA 72,63
00414:  DATA 68,69
00416:  DATA 6E,67
00418:  DATA 20,3F
0041A:  DATA 3F,3F
0041C:  DATA 3F,20
0041E:  DATA 00,00
00420:  CLRF   FF7
00422:  ADDLW  30
00424:  MOVWF  FF6
00426:  MOVLW  04
00428:  ADDWFC FF7,F
0042A:  TBLRD*+
0042C:  MOVF   FF5,W
0042E:  RETURN 0
00430:  DATA 6E,6E
00432:  DATA 6E,6E
00434:  DATA 20,69
00436:  DATA 69,69
00438:  DATA 20,73
0043A:  DATA 73,73
0043C:  DATA 20,64
0043E:  DATA 64,64
00440:  DATA 00,00
00442:  CLRF   FF7
00444:  ADDLW  52
00446:  MOVWF  FF6
00448:  MOVLW  04
0044A:  ADDWFC FF7,F
0044C:  TBLRD*+
0044E:  MOVF   FF5,W
00450:  RETURN 0
00452:  DATA 53,57
00454:  DATA 31,20
00456:  DATA 74,6F
00458:  DATA 20,4A
0045A:  DATA 6F,69
0045C:  DATA 6E,20
0045E:  DATA 20,20
00460:  DATA 20,20
00462:  DATA 00,00
00464:  CLRF   FF7
00466:  ADDLW  74
00468:  MOVWF  FF6
0046A:  MOVLW  04
0046C:  ADDWFC FF7,F
0046E:  TBLRD*+
00470:  MOVF   FF5,W
00472:  RETURN 0
00474:  DATA 53,74
00476:  DATA 72,6F
00478:  DATA 6E,67
0047A:  DATA 65,73
0047C:  DATA 74,3A
0047E:  DATA 20,20
00480:  DATA 20,20
00482:  DATA 20,20
00484:  DATA 00,00
00486:  CLRF   FF7
00488:  ADDLW  96
0048A:  MOVWF  FF6
0048C:  MOVLW  04
0048E:  ADDWFC FF7,F
00490:  TBLRD*+
00492:  MOVF   FF5,W
00494:  RETURN 0
00496:  DATA 20,53
00498:  DATA 65,61
0049A:  DATA 72,63
0049C:  DATA 68,20
0049E:  DATA 53,75
004A0:  DATA 63,63
004A2:  DATA 65,73
004A4:  DATA 73,20
004A6:  DATA 00,00
004A8:  CLRF   FF7
004AA:  ADDLW  B8
004AC:  MOVWF  FF6
004AE:  MOVLW  04
004B0:  ADDWFC FF7,F
004B2:  TBLRD*+
004B4:  MOVF   FF5,W
004B6:  RETURN 0
004B8:  DATA 4E,65
004BA:  DATA 78,74
004BC:  DATA 20,6A
004BE:  DATA 6F,69
004C0:  DATA 6E,3A
004C2:  DATA 20,20
004C4:  DATA 20,20
004C6:  DATA 20,20
004C8:  DATA 00,00
004CA:  CLRF   FF7
004CC:  ADDLW  DA
004CE:  MOVWF  FF6
004D0:  MOVLW  04
004D2:  ADDWFC FF7,F
004D4:  TBLRD*+
004D6:  MOVF   FF5,W
004D8:  RETURN 0
004DA:  DATA 20,20
004DC:  DATA 20,20
004DE:  DATA 20,20
004E0:  DATA 20,20
004E2:  DATA 20,20
004E4:  DATA 20,20
004E6:  DATA 20,20
004E8:  DATA 20,20
004EA:  DATA 00,00
004EC:  CLRF   FF7
004EE:  ADDLW  FC
004F0:  MOVWF  FF6
004F2:  MOVLW  04
004F4:  ADDWFC FF7,F
004F6:  TBLRD*+
004F8:  MOVF   FF5,W
004FA:  RETURN 0
004FC:  DATA 56,62
004FE:  DATA 61,74
00500:  DATA 74,20
00502:  DATA 3D,20
00504:  DATA 20,20
00506:  DATA 20,20
00508:  DATA 20,56
0050A:  DATA 20,20
0050C:  DATA 00,00
0050E:  CLRF   FF7
00510:  ADDLW  1E
00512:  MOVWF  FF6
00514:  MOVLW  05
00516:  ADDWFC FF7,F
00518:  TBLRD*+
0051A:  MOVF   FF5,W
0051C:  RETURN 0
0051E:  DATA 53,68
00520:  DATA 74,64
00522:  DATA 77,6E
00524:  DATA 20,43
00526:  DATA 61,75
00528:  DATA 73,65
0052A:  DATA 3A,20
0052C:  DATA 20,20
0052E:  DATA 00,00
00530:  CLRF   FF7
00532:  ADDLW  40
00534:  MOVWF  FF6
00536:  MOVLW  05
00538:  ADDWFC FF7,F
0053A:  TBLRD*+
0053C:  MOVF   FF5,W
0053E:  RETURN 0
00540:  DATA 76,20
00542:  DATA 20,20
00544:  DATA 20,20
00546:  DATA 20,72
00548:  DATA 20,20
0054A:  DATA 20,20
0054C:  DATA 74,20
0054E:  DATA 20,20
00550:  DATA 00,00
00552:  CLRF   FF7
00554:  ADDLW  62
00556:  MOVWF  FF6
00558:  MOVLW  05
0055A:  ADDWFC FF7,F
0055C:  TBLRD*+
0055E:  MOVF   FF5,W
00560:  RETURN 0
00562:  DATA 63,20
00564:  DATA 20,20
00566:  DATA 20,20
00568:  DATA 20,71
0056A:  DATA 20,20
0056C:  DATA 20,20
0056E:  DATA 61,20
00570:  DATA 20,20
00572:  DATA 00,00
00574:  CLRF   FF7
00576:  ADDLW  84
00578:  MOVWF  FF6
0057A:  MOVLW  05
0057C:  ADDWFC FF7,F
0057E:  TBLRD*+
00580:  MOVF   FF5,W
00582:  RETURN 0
00584:  DATA 6D,20
00586:  DATA 20,20
00588:  DATA 20,20
0058A:  DATA 20,20
0058C:  DATA 6E,20
0058E:  DATA 20,20
00590:  DATA 20,20
00592:  DATA 2A,20
00594:  DATA 00,00
00596:  CLRF   FF7
00598:  ADDLW  A6
0059A:  MOVWF  FF6
0059C:  MOVLW  05
0059E:  ADDWFC FF7,F
005A0:  TBLRD*+
005A2:  MOVF   FF5,W
005A4:  RETURN 0
005A6:  DATA 70,20
005A8:  DATA 20,20
005AA:  DATA 20,20
005AC:  DATA 20,20
005AE:  DATA 2E,20
005B0:  DATA 20,20
005B2:  DATA 20,20
005B4:  DATA 20,20
005B6:  DATA 00,00
005B8:  CLRF   FF7
005BA:  ADDLW  C8
005BC:  MOVWF  FF6
005BE:  MOVLW  05
005C0:  ADDWFC FF7,F
005C2:  TBLRD*+
005C4:  MOVF   FF5,W
005C6:  RETURN 0
005C8:  DATA 2A,2A
005CA:  DATA 2A,00
005CC:  CLRF   FF7
005CE:  ADDLW  DC
005D0:  MOVWF  FF6
005D2:  MOVLW  05
005D4:  ADDWFC FF7,F
005D6:  TBLRD*+
005D8:  MOVF   FF5,W
005DA:  RETURN 0
005DC:  DATA 62,72
005DE:  DATA 20,20
005E0:  DATA 20,20
005E2:  DATA 63,68
005E4:  DATA 20,20
005E6:  DATA 20,20
005E8:  DATA 6D,70
005EA:  DATA 20,20
005EC:  DATA 00,00
005EE:  CLRF   FF7
005F0:  ADDLW  FE
005F2:  MOVWF  FF6
005F4:  MOVLW  05
005F6:  ADDWFC FF7,F
005F8:  TBLRD*+
005FA:  MOVF   FF5,W
005FC:  RETURN 0
005FE:  DATA 72,20
00600:  DATA 20,20
00602:  DATA 2F,20
00604:  DATA 20,20
00606:  DATA 20,76
00608:  DATA 67,20
0060A:  DATA 20,2E
0060C:  DATA 20,20
0060E:  DATA 00,00
00610:  CLRF   FF7
00612:  ADDLW  20
00614:  MOVWF  FF6
00616:  MOVLW  06
00618:  ADDWFC FF7,F
0061A:  TBLRD*+
0061C:  MOVF   FF5,W
0061E:  RETURN 0
00620:  DATA 73,79
00622:  DATA 73,74
00624:  DATA 65,6D
00626:  DATA 20,73
00628:  DATA 74,61
0062A:  DATA 74,65
0062C:  DATA 20,20
0062E:  DATA 20,20
00630:  DATA 00,00
00632:  CLRF   FF7
00634:  ADDLW  42
00636:  MOVWF  FF6
00638:  MOVLW  06
0063A:  ADDWFC FF7,F
0063C:  TBLRD*+
0063E:  MOVF   FF5,W
00640:  RETURN 0
00642:  DATA 53,65
00644:  DATA 74,75
00646:  DATA 70,20
00648:  DATA 4D,61
0064A:  DATA 6E,61
0064C:  DATA 67,65
0064E:  DATA 72,2E
00650:  DATA 2E,2E
00652:  DATA 00,00
00654:  CLRF   FF7
00656:  ADDLW  64
00658:  MOVWF  FF6
0065A:  MOVLW  06
0065C:  ADDWFC FF7,F
0065E:  TBLRD*+
00660:  MOVF   FF5,W
00662:  RETURN 0
00664:  DATA 20,20
00666:  DATA 52,65
00668:  DATA 6C,65
0066A:  DATA 61,73
0066C:  DATA 65,20
0066E:  DATA 53,57
00670:  DATA 31,20
00672:  DATA 20,20
00674:  DATA 00,00
00676:  CLRF   FF7
00678:  ADDLW  86
0067A:  MOVWF  FF6
0067C:  MOVLW  06
0067E:  ADDWFC FF7,F
00680:  TBLRD*+
00682:  MOVF   FF5,W
00684:  RETURN 0
00686:  DATA 44,65
00688:  DATA 61,6C
0068A:  DATA 20,57
0068C:  DATA 69,74
0068E:  DATA 68,20
00690:  DATA 50,61
00692:  DATA 63,6B
00694:  DATA 65,74
00696:  DATA 00,00
00698:  CLRF   FF7
0069A:  ADDLW  A8
0069C:  MOVWF  FF6
0069E:  MOVLW  06
006A0:  ADDWFC FF7,F
006A2:  TBLRD*+
006A4:  MOVF   FF5,W
006A6:  RETURN 0
006A8:  DATA 56,4C
006AA:  DATA 56,20
006AC:  DATA 49,6E
006AE:  DATA 69,74
006B0:  DATA 20,40
006B2:  DATA 20,73
006B4:  DATA 74,61
006B6:  DATA 72,74
006B8:  DATA 00,00
006BA:  CLRF   FF7
006BC:  ADDLW  CA
006BE:  MOVWF  FF6
006C0:  MOVLW  06
006C2:  ADDWFC FF7,F
006C4:  TBLRD*+
006C6:  MOVF   FF5,W
006C8:  RETURN 0
006CA:  DATA 56,4C
006CC:  DATA 56,20
006CE:  DATA 43,61
006D0:  DATA 6C,69
006D2:  DATA 62,72
006D4:  DATA 61,74
006D6:  DATA 69,6F
006D8:  DATA 6E,20
006DA:  DATA 00,00
006DC:  CLRF   FF7
006DE:  ADDLW  EC
006E0:  MOVWF  FF6
006E2:  MOVLW  06
006E4:  ADDWFC FF7,F
006E6:  TBLRD*+
006E8:  MOVF   FF5,W
006EA:  RETURN 0
006EC:  DATA 42,65
006EE:  DATA 67,69
006F0:  DATA 6E,69
006F2:  DATA 6E,67
006F4:  DATA 2E,2E
006F6:  DATA 2E,2E
006F8:  DATA 2E,2E
006FA:  DATA 2E,2E
006FC:  DATA 00,00
006FE:  CLRF   FF7
00700:  ADDLW  0E
00702:  MOVWF  FF6
00704:  MOVLW  07
00706:  ADDWFC FF7,F
00708:  TBLRD*+
0070A:  MOVF   FF5,W
0070C:  RETURN 0
0070E:  DATA 43,6C
00710:  DATA 6F,73
00712:  DATA 65,20
00714:  DATA 43,43
00716:  DATA 50,3D
00718:  DATA 20,20
0071A:  DATA 20,20
0071C:  DATA 20,20
0071E:  DATA 00,00
00720:  CLRF   FF7
00722:  ADDLW  30
00724:  MOVWF  FF6
00726:  MOVLW  07
00728:  ADDWFC FF7,F
0072A:  TBLRD*+
0072C:  MOVF   FF5,W
0072E:  RETURN 0
00730:  DATA 4F,70
00732:  DATA 65,6E
00734:  DATA 20,43
00736:  DATA 43,50
00738:  DATA 20,3D
0073A:  DATA 20,20
0073C:  DATA 20,20
0073E:  DATA 20,20
00740:  DATA 00,00
00742:  CLRF   FF7
00744:  ADDLW  52
00746:  MOVWF  FF6
00748:  MOVLW  07
0074A:  ADDWFC FF7,F
0074C:  TBLRD*+
0074E:  MOVF   FF5,W
00750:  RETURN 0
00752:  DATA 52,65
00754:  DATA 73,65
00756:  DATA 74,74
00758:  DATA 69,6E
0075A:  DATA 67,20
0075C:  DATA 4D,6F
0075E:  DATA 74,65
00760:  DATA 21,21
00762:  DATA 00,00
00764:  CLRF   FF7
00766:  ADDLW  74
00768:  MOVWF  FF6
0076A:  MOVLW  07
0076C:  ADDWFC FF7,F
0076E:  TBLRD*+
00770:  MOVF   FF5,W
00772:  RETURN 0
00774:  DATA 4D,6F
00776:  DATA 74,65
00778:  DATA 20,69
0077A:  DATA 73,20
0077C:  DATA 44,65
0077E:  DATA 61,64
00780:  DATA 20,20
00782:  DATA 20,20
00784:  DATA 00,00
00786:  CLRF   FF7
00788:  ADDLW  96
0078A:  MOVWF  FF6
0078C:  MOVLW  07
0078E:  ADDWFC FF7,F
00790:  TBLRD*+
00792:  MOVF   FF5,W
00794:  RETURN 0
00796:  DATA 53,65
00798:  DATA 61,72
0079A:  DATA 63,68
0079C:  DATA 20,53
0079E:  DATA 74,72
007A0:  DATA 6F,6E
007A2:  DATA 67,20
007A4:  DATA 31,20
007A6:  DATA 00,00
007A8:  CLRF   FF7
007AA:  ADDLW  B8
007AC:  MOVWF  FF6
007AE:  MOVLW  07
007B0:  ADDWFC FF7,F
007B2:  TBLRD*+
007B4:  MOVF   FF5,W
007B6:  RETURN 0
007B8:  DATA 53,65
007BA:  DATA 61,72
007BC:  DATA 63,68
007BE:  DATA 20,53
007C0:  DATA 74,72
007C2:  DATA 6F,6E
007C4:  DATA 67,20
007C6:  DATA 32,20
007C8:  DATA 00,00
007CA:  CLRF   FF7
007CC:  ADDLW  DA
007CE:  MOVWF  FF6
007D0:  MOVLW  07
007D2:  ADDWFC FF7,F
007D4:  TBLRD*+
007D6:  MOVF   FF5,W
007D8:  RETURN 0
007DA:  DATA 20,20
007DC:  DATA 49,6E
007DE:  DATA 69,74
007E0:  DATA 20,4A
007E2:  DATA 6F,69
007E4:  DATA 6E,20
007E6:  DATA 20,20
007E8:  DATA 20,20
007EA:  DATA 00,00
*
01A12:  MOVLB  5
01A14:  CLRF   x95
01A16:  CLRF   x96
01A18:  MOVLW  01
01A1A:  MOVWF  x97
01A1C:  CLRF   FDA
01A1E:  CLRF   FD9
01A20:  MOVLW  05
01A22:  MOVWF  x9A
01A24:  MOVLW  8D
01A26:  MOVWF  x99
01A28:  MOVLW  05
01A2A:  MOVWF  FEA
01A2C:  MOVLW  91
01A2E:  MOVWF  FE9
01A30:  MOVFF  59A,FE2
01A34:  MOVFF  599,FE1
01A38:  MOVFF  597,598
01A3C:  BCF    FD8.0
01A3E:  MOVF   FE5,W
01A40:  MULWF  FEE
01A42:  MOVF   FF3,W
01A44:  ADDWFC x95,F
01A46:  MOVF   FF4,W
01A48:  ADDWFC x96,F
01A4A:  DECFSZ x98,F
01A4C:  BRA    1A3C
01A4E:  MOVFF  595,FDE
01A52:  MOVFF  596,595
01A56:  CLRF   x96
01A58:  BTFSC  FD8.0
01A5A:  INCF   x96,F
01A5C:  INCF   x99,F
01A5E:  BTFSC  FD8.2
01A60:  INCF   x9A,F
01A62:  INCF   x97,F
01A64:  MOVF   x97,W
01A66:  SUBLW  05
01A68:  BNZ   1A28
01A6A:  MOVLB  0
01A6C:  RETURN 0
*
02274:  TSTFSZ 01
02276:  BRA    227E
02278:  TSTFSZ 02
0227A:  BRA    2280
0227C:  BRA    228C
0227E:  INCF   02,F
02280:  MOVFF  00,FEE
02284:  DECFSZ 01,F
02286:  BRA    2280
02288:  DECFSZ 02,F
0228A:  BRA    2280
0228C:  RETURN 0
*
02526:  BTFSC  FD8.1
02528:  BRA    2532
0252A:  MOVLW  05
0252C:  MOVWF  FEA
0252E:  MOVLW  A9
02530:  MOVWF  FE9
02532:  CLRF   00
02534:  CLRF   01
02536:  CLRF   02
02538:  CLRF   03
0253A:  MOVLB  5
0253C:  CLRF   xA9
0253E:  CLRF   xAA
02540:  CLRF   xAB
02542:  CLRF   xAC
02544:  MOVF   xA8,W
02546:  IORWF  xA7,W
02548:  IORWF  xA6,W
0254A:  IORWF  xA5,W
0254C:  BZ    25A6
0254E:  MOVLW  20
02550:  MOVWF  xAD
02552:  BCF    FD8.0
02554:  RLCF   xA1,F
02556:  RLCF   xA2,F
02558:  RLCF   xA3,F
0255A:  RLCF   xA4,F
0255C:  RLCF   xA9,F
0255E:  RLCF   xAA,F
02560:  RLCF   xAB,F
02562:  RLCF   xAC,F
02564:  MOVF   xA8,W
02566:  SUBWF  xAC,W
02568:  BNZ   257A
0256A:  MOVF   xA7,W
0256C:  SUBWF  xAB,W
0256E:  BNZ   257A
02570:  MOVF   xA6,W
02572:  SUBWF  xAA,W
02574:  BNZ   257A
02576:  MOVF   xA5,W
02578:  SUBWF  xA9,W
0257A:  BNC   259A
0257C:  MOVF   xA5,W
0257E:  SUBWF  xA9,F
02580:  MOVF   xA6,W
02582:  BTFSS  FD8.0
02584:  INCFSZ xA6,W
02586:  SUBWF  xAA,F
02588:  MOVF   xA7,W
0258A:  BTFSS  FD8.0
0258C:  INCFSZ xA7,W
0258E:  SUBWF  xAB,F
02590:  MOVF   xA8,W
02592:  BTFSS  FD8.0
02594:  INCFSZ xA8,W
02596:  SUBWF  xAC,F
02598:  BSF    FD8.0
0259A:  RLCF   00,F
0259C:  RLCF   01,F
0259E:  RLCF   02,F
025A0:  RLCF   03,F
025A2:  DECFSZ xAD,F
025A4:  BRA    2552
025A6:  MOVFF  5A9,FEF
025AA:  MOVFF  5AA,FEC
025AE:  MOVFF  5AB,FEC
025B2:  MOVFF  5AC,FEC
025B6:  MOVLB  0
025B8:  RETURN 0
*
04306:  CLRF   01
04308:  CLRF   02
0430A:  CLRF   00
0430C:  CLRF   03
0430E:  MOVLB  5
04310:  MOVF   x78,W
04312:  BNZ   4318
04314:  MOVF   x77,W
04316:  BZ    4348
04318:  MOVLW  10
0431A:  MOVWF  x79
0431C:  BCF    FD8.0
0431E:  RLCF   x75,F
04320:  RLCF   x76,F
04322:  RLCF   00,F
04324:  RLCF   03,F
04326:  MOVF   x78,W
04328:  SUBWF  03,W
0432A:  BNZ   4330
0432C:  MOVF   x77,W
0432E:  SUBWF  00,W
04330:  BNC   4340
04332:  MOVF   x77,W
04334:  SUBWF  00,F
04336:  BTFSS  FD8.0
04338:  DECF   03,F
0433A:  MOVF   x78,W
0433C:  SUBWF  03,F
0433E:  BSF    FD8.0
04340:  RLCF   01,F
04342:  RLCF   02,F
04344:  DECFSZ x79,F
04346:  BRA    431C
04348:  MOVLB  0
0434A:  RETURN 0
*
0479A:  MOVLW  8E
0479C:  MOVWF  00
0479E:  MOVFF  569,01
047A2:  MOVFF  568,02
047A6:  CLRF   03
047A8:  MOVF   01,F
047AA:  BNZ   47BE
047AC:  MOVFF  02,01
047B0:  CLRF   02
047B2:  MOVLW  08
047B4:  SUBWF  00,F
047B6:  MOVF   01,F
047B8:  BNZ   47BE
047BA:  CLRF   00
047BC:  BRA    47CE
047BE:  BCF    FD8.0
047C0:  BTFSC  01.7
047C2:  BRA    47CC
047C4:  RLCF   02,F
047C6:  RLCF   01,F
047C8:  DECF   00,F
047CA:  BRA    47BE
047CC:  BCF    01.7
047CE:  RETURN 0
047D0:  MOVLB  5
047D2:  MOVF   x68,W
047D4:  BTFSC  FD8.2
047D6:  BRA    4922
047D8:  MOVWF  x74
047DA:  MOVF   x6C,W
047DC:  BTFSC  FD8.2
047DE:  BRA    4922
047E0:  SUBWF  x74,F
047E2:  BNC   47EE
047E4:  MOVLW  7F
047E6:  ADDWF  x74,F
047E8:  BTFSC  FD8.0
047EA:  BRA    4922
047EC:  BRA    47FA
047EE:  MOVLW  81
047F0:  SUBWF  x74,F
047F2:  BTFSS  FD8.0
047F4:  BRA    4922
047F6:  BTFSC  FD8.2
047F8:  BRA    4922
047FA:  MOVFF  574,00
047FE:  CLRF   01
04800:  CLRF   02
04802:  CLRF   03
04804:  CLRF   x73
04806:  MOVFF  569,572
0480A:  BSF    x72.7
0480C:  MOVFF  56A,571
04810:  MOVFF  56B,570
04814:  MOVLW  19
04816:  MOVWF  x74
04818:  MOVF   x6F,W
0481A:  SUBWF  x70,F
0481C:  BC    4838
0481E:  MOVLW  01
04820:  SUBWF  x71,F
04822:  BC    4838
04824:  SUBWF  x72,F
04826:  BC    4838
04828:  SUBWF  x73,F
0482A:  BC    4838
0482C:  INCF   x73,F
0482E:  INCF   x72,F
04830:  INCF   x71,F
04832:  MOVF   x6F,W
04834:  ADDWF  x70,F
04836:  BRA    4888
04838:  MOVF   x6E,W
0483A:  SUBWF  x71,F
0483C:  BC    4862
0483E:  MOVLW  01
04840:  SUBWF  x72,F
04842:  BC    4862
04844:  SUBWF  x73,F
04846:  BC    4862
04848:  INCF   x73,F
0484A:  INCF   x72,F
0484C:  MOVF   x6E,W
0484E:  ADDWF  x71,F
04850:  MOVF   x6F,W
04852:  ADDWF  x70,F
04854:  BNC   4888
04856:  INCF   x71,F
04858:  BNZ   4888
0485A:  INCF   x72,F
0485C:  BNZ   4888
0485E:  INCF   x73,F
04860:  BRA    4888
04862:  MOVF   x6D,W
04864:  IORLW  80
04866:  SUBWF  x72,F
04868:  BC    4886
0486A:  MOVLW  01
0486C:  SUBWF  x73,F
0486E:  BC    4886
04870:  INCF   x73,F
04872:  MOVF   x6D,W
04874:  IORLW  80
04876:  ADDWF  x72,F
04878:  MOVF   x6E,W
0487A:  ADDWF  x71,F
0487C:  BNC   4850
0487E:  INCF   x72,F
04880:  BNZ   4850
04882:  INCF   x73,F
04884:  BRA    4850
04886:  BSF    03.0
04888:  DECFSZ x74,F
0488A:  BRA    488E
0488C:  BRA    48A4
0488E:  BCF    FD8.0
04890:  RLCF   x70,F
04892:  RLCF   x71,F
04894:  RLCF   x72,F
04896:  RLCF   x73,F
04898:  BCF    FD8.0
0489A:  RLCF   03,F
0489C:  RLCF   02,F
0489E:  RLCF   01,F
048A0:  RLCF   x75,F
048A2:  BRA    4818
048A4:  BTFSS  x75.0
048A6:  BRA    48B4
048A8:  BCF    FD8.0
048AA:  RRCF   01,F
048AC:  RRCF   02,F
048AE:  RRCF   03,F
048B0:  RRCF   x75,F
048B2:  BRA    48B8
048B4:  DECF   00,F
048B6:  BZ    4922
048B8:  BTFSC  x75.7
048BA:  BRA    48F8
048BC:  BCF    FD8.0
048BE:  RLCF   x70,F
048C0:  RLCF   x71,F
048C2:  RLCF   x72,F
048C4:  RLCF   x73,F
048C6:  MOVF   x6F,W
048C8:  SUBWF  x70,F
048CA:  BC    48DA
048CC:  MOVLW  01
048CE:  SUBWF  x71,F
048D0:  BC    48DA
048D2:  SUBWF  x72,F
048D4:  BC    48DA
048D6:  SUBWF  x73,F
048D8:  BNC   490E
048DA:  MOVF   x6E,W
048DC:  SUBWF  x71,F
048DE:  BC    48EA
048E0:  MOVLW  01
048E2:  SUBWF  x72,F
048E4:  BC    48EA
048E6:  SUBWF  x73,F
048E8:  BNC   490E
048EA:  MOVF   x6D,W
048EC:  IORLW  80
048EE:  SUBWF  x72,F
048F0:  BC    48F8
048F2:  MOVLW  01
048F4:  SUBWF  x73,F
048F6:  BNC   490E
048F8:  INCF   03,F
048FA:  BNZ   490E
048FC:  INCF   02,F
048FE:  BNZ   490E
04900:  INCF   01,F
04902:  BNZ   490E
04904:  INCF   00,F
04906:  BZ    4922
04908:  RRCF   01,F
0490A:  RRCF   02,F
0490C:  RRCF   03,F
0490E:  MOVFF  569,574
04912:  MOVF   x6D,W
04914:  XORWF  x74,F
04916:  BTFSS  x74.7
04918:  BRA    491E
0491A:  BSF    01.7
0491C:  BRA    492A
0491E:  BCF    01.7
04920:  BRA    492A
04922:  CLRF   00
04924:  CLRF   01
04926:  CLRF   02
04928:  CLRF   03
0492A:  MOVLB  0
0492C:  RETURN 0
0492E:  MOVLB  5
04930:  MOVF   x68,W
04932:  SUBLW  B6
04934:  MOVWF  x68
04936:  CLRF   03
04938:  MOVFF  569,56C
0493C:  BSF    x69.7
0493E:  BCF    FD8.0
04940:  RRCF   x69,F
04942:  RRCF   x6A,F
04944:  RRCF   x6B,F
04946:  RRCF   03,F
04948:  RRCF   02,F
0494A:  RRCF   01,F
0494C:  RRCF   00,F
0494E:  DECFSZ x68,F
04950:  BRA    493E
04952:  BTFSS  x6C.7
04954:  BRA    496C
04956:  COMF   00,F
04958:  COMF   01,F
0495A:  COMF   02,F
0495C:  COMF   03,F
0495E:  INCF   00,F
04960:  BTFSC  FD8.2
04962:  INCF   01,F
04964:  BTFSC  FD8.2
04966:  INCF   02,F
04968:  BTFSC  FD8.2
0496A:  INCF   03,F
0496C:  MOVLB  0
0496E:  RETURN 0
04970:  MOVLB  5
04972:  MOVF   x6A,W
04974:  MULWF  x6C
04976:  MOVFF  FF3,01
0497A:  MOVFF  FF4,00
0497E:  MULWF  x6D
04980:  MOVF   FF3,W
04982:  ADDWF  00,F
04984:  MOVF   x6B,W
04986:  MULWF  x6C
04988:  MOVF   FF3,W
0498A:  ADDWFC 00,W
0498C:  MOVWF  02
0498E:  MOVLB  0
04990:  RETURN 0
*
05BAC:  ADDWF  FE8,W
05BAE:  CLRF   FF7
05BB0:  RLCF   FF7,F
05BB2:  ADDLW  C7
05BB4:  MOVWF  FF6
05BB6:  MOVLW  5B
05BB8:  ADDWFC FF7,F
05BBA:  TBLRD*-
05BBC:  MOVF   FF5,W
05BBE:  MOVWF  FFA
05BC0:  TBLRD*
05BC2:  MOVF   FF5,W
05BC4:  MOVWF  FF9
05BC6:  DATA 88,56
05BC8:  DATA 18,54
05BCA:  DATA 88,56
05BCC:  DATA A4,5B
05BCE:  DATA A4,5B
05BD0:  DATA C8,58
05BD2:  DATA C8,58
05BD4:  DATA A4,5B
05BD6:  DATA 6A,5A
05BD8:  DATA 06,5B
*
068E6:  MOVLB  5
068E8:  MOVF   x6C,W
068EA:  CLRF   01
068EC:  SUBWF  x6B,W
068EE:  BC    68F6
068F0:  MOVFF  56B,00
068F4:  BRA    690E
068F6:  CLRF   00
068F8:  MOVLW  08
068FA:  MOVWF  x6D
068FC:  RLCF   x6B,F
068FE:  RLCF   00,F
06900:  MOVF   x6C,W
06902:  SUBWF  00,W
06904:  BTFSC  FD8.0
06906:  MOVWF  00
06908:  RLCF   01,F
0690A:  DECFSZ x6D,F
0690C:  BRA    68FC
0690E:  MOVLB  0
06910:  RETURN 0
*
07FF2:  ADDWF  FE8,W
07FF4:  CLRF   FF7
07FF6:  RLCF   FF7,F
07FF8:  ADDLW  0D
07FFA:  MOVWF  FF6
07FFC:  MOVLW  80
07FFE:  ADDWFC FF7,F
08000:  TBLRD*-
08002:  MOVF   FF5,W
08004:  MOVWF  FFA
08006:  TBLRD*
08008:  MOVF   FF5,W
0800A:  MOVWF  FF9
0800C:  DATA 80,71
0800E:  DATA 96,71
08010:  DATA E8,7F
08012:  DATA E8,7F
08014:  DATA E8,7F
08016:  DATA E8,7F
08018:  DATA E8,7F
0801A:  DATA E8,7F
0801C:  DATA E8,7F
0801E:  DATA E8,7F
08020:  DATA E8,7F
08022:  DATA E8,7F
08024:  DATA E8,7F
08026:  DATA E8,7F
08028:  DATA E8,7F
0802A:  DATA 9C,71
0802C:  DATA B2,71
0802E:  DATA C8,71
08030:  DATA E8,7F
08032:  DATA E8,7F
08034:  DATA E8,7F
08036:  DATA E8,7F
08038:  DATA E8,7F
0803A:  DATA E8,7F
0803C:  DATA E8,7F
0803E:  DATA E8,7F
08040:  DATA E8,7F
08042:  DATA E8,7F
08044:  DATA E8,7F
08046:  DATA E8,7F
08048:  DATA E8,7F
0804A:  DATA DE,71
0804C:  DATA 4C,72
0804E:  DATA BA,72
08050:  DATA 12,73
08052:  DATA E8,7F
08054:  DATA E8,7F
08056:  DATA E8,7F
08058:  DATA E8,7F
0805A:  DATA E8,7F
0805C:  DATA E8,7F
0805E:  DATA E8,7F
08060:  DATA E8,7F
08062:  DATA E8,7F
08064:  DATA E8,7F
08066:  DATA E8,7F
08068:  DATA E8,7F
0806A:  DATA 02,74
0806C:  DATA 34,74
0806E:  DATA 5A,74
08070:  DATA F6,74
08072:  DATA 1C,75
08074:  DATA 8E,76
08076:  DATA A6,77
08078:  DATA E8,7F
0807A:  DATA E8,7F
0807C:  DATA E8,7F
0807E:  DATA E8,7F
08080:  DATA E8,7F
08082:  DATA E8,7F
08084:  DATA E8,7F
08086:  DATA E8,7F
08088:  DATA E8,7F
0808A:  DATA F8,77
0808C:  DATA 08,79
0808E:  DATA 32,79
08090:  DATA 44,7B
08092:  DATA 18,7D
08094:  DATA 20,7F
08096:  DATA 38,7F
....................  
.................... #list 
....................  
.................... #device adc=10  
.................... #device high_ints=TRUE 
....................                   
.................... // standard libraries 
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #include <stdint.h>          
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... ////                           stdint.h                                //// 
.................... ////                                                                   //// 
.................... //// Standard integer definitions.                                     //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDINT 
....................  
.................... #define _STDINT 
....................  
.................... //////////// exact width 
....................  
.................... typedef signed int8 int8_t; 
.................... typedef unsigned int8 uint8_t; 
.................... typedef signed int16 int16_t; 
.................... typedef unsigned int16 uint16_t; 
.................... typedef signed int32 int32_t; 
.................... typedef unsigned int32 uint32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int24_t; 
.................... //typedef unsigned int24 uint24_t; 
.................... typedef signed int64 int64_t; 
.................... typedef unsigned int64 uint64_t; 
.................... #endif 
....................  
.................... #define INT8_MAX  (127) 
.................... #define INT8_MIN  (-128) 
.................... #define UINT8_MAX (255) 
....................  
.................... #define INT16_MAX  (32767) 
.................... #define INT16_MIN  (-32768) 
.................... #define UINT16_MAX (65535) 
....................  
.................... #define INT32_MAX  (2147483647) 
.................... #define INT32_MIN  (-2147483648) 
.................... #define UINT32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT24_MAX  (8388607) 
.................... //#define INT24_MIN  (-8388608) 
.................... //#define UINT24_MAX (16777215) 
....................  
.................... #define INT64_MAX  (9223372036854775807) 
.................... #define INT64_MIN  (-9223372036854775808) 
.................... #define UINT64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// minimum width 
....................  
.................... typedef signed int8 int_least8_t; 
.................... typedef unsigned int8 uint_least8_t; 
.................... typedef signed int16 int_least16_t; 
.................... typedef unsigned int16 uint_least16_t; 
.................... typedef signed int32 int_least32_t; 
.................... typedef unsigned int32 uint_least32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int_least24_t; 
.................... //typedef unsigned int24 uint_least24_t; 
.................... typedef signed int64 int_least64_t; 
.................... typedef unsigned int64 uint_least64_t; 
.................... #endif 
....................  
.................... #define INT_LEAST8_MAX  (127) 
.................... #define INT_LEAST8_MIN  (-128) 
.................... #define UINT_LEAST8_MAX (255) 
....................  
.................... #define INT_LEAST16_MAX  (32767) 
.................... #define INT_LEAST16_MIN  (-32768) 
.................... #define UINT_LEAST16_MAX (65535) 
....................  
.................... #define INT_LEAST32_MAX  (2147483647) 
.................... #define INT_LEAST32_MIN  (-2147483648) 
.................... #define UINT_LEAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_LEAST24_MAX  (8388607) 
.................... //#define INT_LEAST24_MIN  (-8388608) 
.................... //#define UINT_LEAST24_MAX (16777215) 
....................  
.................... #define INT_LEAST64_MAX  (9223372036854775807) 
.................... #define INT_LEAST64_MIN  (-9223372036854775808) 
.................... #define UINT_LEAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// fastest width 
....................  
.................... #if defined(__PCD__) 
.................... typedef signed int16 int_fast8_t; 
.................... typedef unsigned int16 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (32767) 
.................... #define INT_FAST8_MIN  (-32768) 
.................... #define UINT_FAST8_MAX (65535) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... //typedef signed int24 int_fast24_t; 
.................... //typedef unsigned int24 uint_fast24_t; 
.................... typedef signed int64 int_fast64_t; 
.................... typedef unsigned int64 uint_fast64_t; 
.................... #else 
.................... typedef signed int8 int_fast8_t; 
.................... typedef unsigned int8 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (127) 
.................... #define INT_FAST8_MIN  (-128) 
.................... #define UINT_FAST8_MAX (255) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... #endif 
....................  
.................... typedef signed int32 int_fast32_t; 
.................... typedef unsigned int32 uint_fast32_t; 
....................  
.................... #define INT_FAST16_MAX  (32767) 
.................... #define INT_FAST16_MIN  (-32768) 
.................... #define UINT_FAST16_MAX (65535) 
....................  
.................... #define INT_FAST32_MAX  (2147483647) 
.................... #define INT_FAST32_MIN  (-2147483648) 
.................... #define UINT_FAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_FAST24_MAX  (8388607) 
.................... //#define INT_FAST24_MIN  (-8388608) 
.................... //#define UINT_FAST24_MAX (16777215) 
....................  
.................... #define INT_FAST64_MAX  (9223372036854775807) 
.................... #define INT_FAST64_MIN  (-9223372036854775808) 
.................... #define UINT_FAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... //////////// big enough to hold pointers (OPTIONAL) 
....................  
.................... /// TODO 
....................  
.................... /// intptr_t uintptr_t 
....................  
.................... /// INTPTRN_MIN INTPTRN_MAX UINTPTRN_MAX 
....................  
....................  
.................... /////////// greatest width (OPTIONAL) 
....................  
.................... /// TODO 
....................  
.................... /// intmax_t uintmax_t 
....................  
.................... /// INTMAXN_MIN INTMAXN_MAX UINTMAXN_MAX 
....................  
.................... /// INTMAX_C(value) UINTMAX_C(value) 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... size_t mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
*
0434C:  CLRF   19
0434E:  BTFSC  FF2.7
04350:  BSF    19.7
04352:  BCF    FF2.7
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
04354:  MOVFF  34,590
04358:  MOVFF  33,58F
0435C:  MOVFF  32,58E
04360:  MOVFF  31,58D
04364:  MOVLW  41
04366:  MOVLB  5
04368:  MOVWF  x94
0436A:  MOVLW  C6
0436C:  MOVWF  x93
0436E:  MOVLW  4E
04370:  MOVWF  x92
04372:  MOVLW  6D
04374:  MOVWF  x91
04376:  MOVLB  0
04378:  CALL   1A12
0437C:  BTFSC  19.7
0437E:  BSF    FF2.7
04380:  MOVLW  39
04382:  MOVLB  5
04384:  ADDWF  00,W
04386:  MOVWF  31
04388:  MOVLW  30
0438A:  ADDWFC 01,W
0438C:  MOVWF  32
0438E:  MOVLW  00
04390:  ADDWFC 02,W
04392:  MOVWF  33
04394:  MOVLW  00
04396:  ADDWFC 03,W
04398:  MOVWF  34
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
0439A:  MOVFF  33,00
0439E:  MOVFF  34,01
043A2:  CLRF   02
043A4:  CLRF   03
043A6:  MOVFF  34,54D
043AA:  MOVFF  33,54C
043AE:  MOVFF  34,576
043B2:  MOVFF  33,575
043B6:  MOVLW  7F
043B8:  MOVWF  x78
043BA:  SETF   x77
043BC:  MOVLB  0
043BE:  RCALL  4306
043C0:  MOVFF  00,01
043C4:  MOVFF  03,02
043C8:  GOTO   440A (RETURN)
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
*
042F2:  MOVFF  54F,34
042F6:  MOVFF  54E,33
042FA:  MOVFF  54D,32
042FE:  MOVFF  54C,31
04302:  GOTO   4408 (RETURN)
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdlibm.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... /*********************************************************************/ 
.................... #ifndef _STDLIBM 
.................... #define _STDLIBM 
....................  
.................... /* Memory Management Functions*/ 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... typedef struct nodet { 
....................    unsigned int8 size; 
....................    unsigned int8 next; }node_t; 
.................... #elif defined(__PCM__) 
.................... typedef struct nodet { 
....................    unsigned int8 size; 
....................    unsigned int16 next; }node_t; 
.................... #elif defined(__PCH__) 
.................... typedef struct nodet { 
....................    unsigned int16 size; 
....................    unsigned int16 next; }node_t; 
.................... #elif defined(__PCD__) 
.................... typedef struct nodet { 
....................    unsigned int16 size; 
....................    unsigned int16 next; }node_t; 
.................... #endif 
....................  
.................... #if !defined(STDLIBM_MANUAL_DYNAMIC_MEMORY) 
....................    #USE DYNAMIC_MEMORY 
.................... #endif 
....................  
.................... #ifndef debug_stdlibm 
....................    #define debug_stdlibm(s) 
.................... #else 
....................    #define __DO_DEBUG_STDLIBM 
....................     
....................    char g_DebugStdlibmStr[50]; 
....................     
....................    #if defined(__PCD__) 
....................       #if (defined(__PIC24E__)||defined(__dsPIC33E__)) 
....................          #define INVALID_MEMORY_LOCATION(x) ((x >= (getenv("RAM")+0x800)) || bit_test(x, 0)) 
....................       #else 
....................          #define INVALID_MEMORY_LOCATION(x) ((x >= (getenv("RAM")+0x1000)) || bit_test(x, 0)) 
....................       #endif 
....................    #else 
....................       #define INVALID_MEMORY_LOCATION(x) (x >= getenv("RAM")) 
....................    #endif 
.................... #endif 
....................  
.................... #include <memmgmt.c> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #if defined(__PCH__) 
....................  #define _MEMMGMT_CSIZE 32768 
....................  #define _MEMMGMT_POS 15 
.................... #elif defined(__PCD__) 
....................    #define _MEMMGMT_CSIZE 32768 
....................    #define _MEMMGMT_POS 15 
.................... #else 
....................    #define _MEMMGMT_CSIZE 127 
....................    #define _MEMMGMT_POS 7 
.................... #endif 
....................  
.................... node_t * create_node(unsigned int16 size, node_t *ptr) // create node at given location 
.................... { 
....................    node_t *result; 
....................    result =ptr; 
....................    result->size=size; 
....................    result->next = NULL; 
....................    return result; 
.................... } 
.................... void update_node(node_t *node, unsigned int16 size) // update the size of given node 
.................... { 
....................    node->size=size; 
.................... } 
....................  
.................... /* Insert node immediately after place */ //old,new 
.................... void insert_node_after(node_t *place, node_t *node)// place the node after another given node 
.................... { 
....................     if (place->next==NULL) 
....................        node->next= NULL; 
....................     else 
....................        node->next=place->next; 
....................     place->next=node; 
.................... } 
....................  
.................... ///////////////////////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... void remove_node(node_t *node) {// remove the given node from the memlist 
....................    node_t *ptr; 
....................    for(ptr=__DYNAMIC_HEAD;ptr->next!=node;ptr=ptr->next); 
....................    ptr->next=node->next; 
....................    node=NULL; 
.................... } 
....................  
.................... ///////////////////////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... #if defined(__DO_DEBUG_STDLIBM) 
.................... void print_list() { // print the current memlist 
....................     node_t *node; 
....................     debug_stdlibm("\r\nThe list is \n\r"); 
....................     for(node = __DYNAMIC_HEAD; node != NULL; node = node->next) 
....................     { 
....................         sprintf(g_DebugStdlibmStr, "H:0x%lx S:0x%lx N:0x%lx\n\r", node, node->size, node->next); 
....................         debug_stdlibm(g_DebugStdlibmStr); 
....................         if (INVALID_MEMORY_LOCATION(node->next)) 
....................         { 
....................            debug_stdlibm("Breaking because of invalid next node\r\n"); 
....................            break; 
....................         }    
....................     } 
....................     sprintf(g_DebugStdlibmStr, "size of node_t %u\r\n",sizeof(node_t)); 
....................     debug_stdlibm(g_DebugStdlibmStr); 
.................... } 
.................... #endif 
....................  
....................  
....................  
....................  
.................... void traverse() 
.................... { 
....................    node_t *node,*temp; 
....................    unsigned int16 nsize,nextsize; 
....................    node=__DYNAMIC_HEAD; 
....................    while(node!=NULL) 
....................    { 
....................      #if defined(__DO_DEBUG_STDLIBM) 
....................       if (INVALID_MEMORY_LOCATION(node)) 
....................       { 
....................          sprintf(g_DebugStdlibmStr, "traverse() invalid node (0x%LX)\r\n", node); 
....................          debug_stdlibm(g_DebugStdlibmStr); 
....................          break; 
....................       }    
....................      #endif 
....................      if(!bit_test(node->size,_MEMMGMT_POS))// node free 
....................       { 
....................          nsize=node->size; 
....................          temp=(unsigned int16)node->next; 
....................         #if defined(__DO_DEBUG_STDLIBM) 
....................          if (INVALID_MEMORY_LOCATION(temp)) 
....................          { 
....................             sprintf(g_DebugStdlibmStr, "traverse() invalid temp (0x%LX)\r\n", node); 
....................             debug_stdlibm(g_DebugStdlibmStr); 
....................             break; 
....................          } 
....................         #endif 
....................          if(!bit_test(temp->size,_MEMMGMT_POS)&& (temp==((unsigned int16)node+nsize+sizeof(node_t))))//next node free and consecutive, so combine 
....................          { 
....................             nextsize=temp->size; 
....................             nsize+=nextsize+sizeof(node_t); 
....................             remove_node(temp); 
....................             update_node(node,nsize); 
....................          } 
....................          else 
....................          node=node->next; 
....................       } 
....................       else 
....................       node=node->next; 
....................    } 
.................... } 
....................  
.................... char *malloc(size_t size) 
.................... { 
....................    node_t *node,*new; 
....................    unsigned int16 nsize; 
....................    #if defined(__PCD__) 
....................    if (size % 2) 
....................       size++; 
....................    #endif 
....................    node=__DYNAMIC_HEAD; 
....................     
....................   #if defined(__DO_DEBUG_STDLIBM) 
....................    sprintf(g_DebugStdlibmStr, "malloc() size=%lu ", size); 
....................    debug_stdlibm(g_DebugStdlibmStr); 
....................   #endif 
....................          
....................    while(node!=NULL) // chk until end of memlist 
....................    { 
....................      #if defined(__DO_DEBUG_STDLIBM) 
....................       if (INVALID_MEMORY_LOCATION(node)) 
....................       { 
....................          sprintf(g_DebugStdlibmStr, " invalid node (0x%LX)\r\n", node); 
....................          debug_stdlibm(g_DebugStdlibmStr); 
....................          print_list(); 
....................          return(0); 
....................       } 
....................      #endif 
....................       if(!bit_test(node->size,_MEMMGMT_POS) && node->size >=size) // node is free and > = req size 
....................       { 
....................          nsize=node->size;    //nsize = size of the node that "node" being pointed at 
....................          if(nsize>size +sizeof(node_t)) //node > req size, so split and add new node to memlist 
....................          { 
....................             new=create_node(nsize-size-sizeof(node_t),(unsigned int16)node+sizeof(node_t)+size); 
....................             insert_node_after(node,new); 
....................             update_node(node,size+_MEMMGMT_CSIZE); 
....................          } 
....................          else//not enough space for new node so use original size 
....................          update_node(node,nsize+_MEMMGMT_CSIZE); 
....................          //end if 
....................          break; 
....................       }//end if 
....................       node=node->next; 
....................    }//end while 
....................    if(node==NULL)// reached end without finding an appropriate node 
....................    { 
....................       debug_stdlibm("Not enough memory for mallocation\r\n"); 
....................       return NULL; 
....................    } 
....................    else 
....................    { 
....................      #if defined(__DO_DEBUG_STDLIBM) 
....................       sprintf(g_DebugStdlibmStr, "%LX\r\n", (char *)node+sizeof(node_t)); 
....................       debug_stdlibm(g_DebugStdlibmStr); 
....................      #endif 
....................       return (char *)node+sizeof(node_t); // return pounsigned int8er to allocated space 
....................    } 
.................... } 
....................  
.................... char *calloc(size_t nmemb,size_t size) 
.................... { 
....................    node_t *node,*new; 
....................    unsigned int16 nsize,resize; 
....................    node=__DYNAMIC_HEAD; 
....................    resize=nmemb*size; 
....................    #if defined(__PCD__) 
....................    if(resize%2) 
....................       resize++; 
....................    #endif 
....................    while(node!=NULL) // chk until end of memlist 
....................    { 
....................      #if defined(__DO_DEBUG_STDLIBM) 
....................       if (INVALID_MEMORY_LOCATION(node)) 
....................       { 
....................          sprintf(g_DebugStdlibmStr, "malloc() invalid node (0x%LX)\r\n", node); 
....................          debug_stdlibm(g_DebugStdlibmStr); 
....................          print_list(); 
....................          return(0); 
....................       } 
....................      #endif 
....................       if(!bit_test(node->size,_MEMMGMT_POS) && node->size >=resize)// node is free and > = req size 
....................       { 
....................          nsize=node->size; 
....................          if(nsize>resize+sizeof(node_t))//node > req size, so split and add new node to memlist 
....................          { 
....................             new=create_node(nsize-resize-sizeof(node_t),(unsigned int16)node+sizeof(node_t)+resize); 
....................             insert_node_after(node,new); 
....................             update_node(node,resize+_MEMMGMT_CSIZE); 
....................          } 
....................          else//not enough space for new node so use original size 
....................          update_node(node,nsize+_MEMMGMT_CSIZE); 
....................          //end if 
....................          break; 
....................       }//end if 
....................       node=node->next; 
....................    }//end while 
....................    if(node==NULL)// reached end without finding an appropriate node 
....................    { 
....................       debug_stdlibm("Not enough memory for callocation\r\n"); 
....................       return NULL; 
....................    } 
....................    else 
....................    { 
....................       memset((unsigned int16)node+sizeof(node_t),0,resize);// initialize to 0 
....................       return (char *)(unsigned int16)node+sizeof(node_t);// return pounsigned int8er to allocated space 
....................    } 
.................... } 
.................... void free( void * ptr) 
.................... { 
....................    node_t *node; 
....................    unsigned int16 nsize; 
....................  
....................   #if defined(__DO_DEBUG_STDLIBM) 
....................    sprintf(g_DebugStdlibmStr, "free() 0x%LX\r\n", ptr); 
....................    debug_stdlibm(g_DebugStdlibmStr); 
....................   #endif 
....................  
....................    if(ptr==NULL) // not a valid pounsigned int8er 
....................       return; 
....................    else 
....................    { 
....................       node=ptr-sizeof(node_t); 
....................       if(bit_test(node->size,_MEMMGMT_POS))// node occupied 
....................       { 
....................          nsize=node->size-_MEMMGMT_CSIZE; 
....................          update_node(node,nsize); 
....................          ptr=NULL; 
....................  
....................       } 
....................       else // wrong input, return 
....................       { 
....................          ptr=NULL; 
....................          return; 
....................       } 
....................    } 
....................    traverse(); 
.................... } 
....................  
.................... char *realloc(void *ptr,size_t size) 
.................... { 
....................    node_t *node,*new,*temp; 
....................    unsigned int16 nsize,nextsize; 
....................    char *newptr; 
....................    #if defined(__PCD__) 
....................    if(size %2) 
....................       size++; 
....................    #endif 
....................    if(ptr==NULL)// null pounsigned int8er, so malloc the req memory 
....................       return(malloc(size)); 
....................    else if(size==0) 
....................    { 
....................       free(ptr); 
....................       return(NULL); 
....................    } 
....................    else 
....................    { 
....................       node=ptr-sizeof(node_t); 
....................       if(bit_test(node->size,_MEMMGMT_POS))// chk if valid pounsigned int8er 
....................       { 
....................          nsize=node->size-_MEMMGMT_CSIZE; 
....................          temp=(unsigned int16)node->next; 
....................          if(nsize>size)// block > req size 
....................          { 
....................         
....................                if(!bit_test(temp->size,_MEMMGMT_POS) && (temp==((unsigned int16)node+nsize+sizeof(node_t))))// next block free and consecutive 
....................                { 
....................                   update_node(node,size+_MEMMGMT_CSIZE); // update block 
....................                   nextsize=temp->size; 
....................                   remove_node(temp); 
....................                   new=create_node(nextsize+(nsize-size),(unsigned int16)node+size+sizeof(node_t)); 
....................                   insert_node_after(node,new); 
....................                    
....................  
....................                } 
....................                else if (nsize>size +sizeof(node_t))//node > req size, so split and add new node to memlist 
....................                { 
....................                   update_node(node,size+_MEMMGMT_CSIZE); // update block 
....................                   new=create_node(nsize-size-sizeof(node_t),(unsigned int16)node+sizeof(node_t)+size); 
....................                   insert_node_after(node,new); 
....................                } 
....................                else//not enough space for new node so use original size 
....................                update_node(node,nsize+_MEMMGMT_CSIZE); // update block 
....................  
....................          } 
....................          else // block < req size 
....................          { 
....................             if(!bit_test(temp->size,_MEMMGMT_POS) && (temp==((unsigned int16)node+nsize+sizeof(node_t))))// next block free and consecutive 
....................             { 
....................                nextsize=temp->size; 
....................                if(nextsize>=size-nsize) // next block >=difference 
....................                { 
....................                   if(nextsize>size-nsize+sizeof(node_t))//next node > req size, so split and add new node to memlist 
....................                   { 
....................                       update_node(node,size+_MEMMGMT_CSIZE);// update block 
....................                       remove_node(temp); 
....................                       new=create_node(nextsize-(size-nsize),(unsigned int16)node+size+sizeof(node_t)); 
....................                       insert_node_after(node,new); 
....................                   } 
....................                   else//not enough space for new node in next node, so use original size 
....................                   { 
....................                       update_node(node,nsize+nextsize+_MEMMGMT_CSIZE);// update block 
....................                       remove_node(temp); 
....................                   } 
....................                } 
....................                else  //next block free but too small for new size 
....................                { 
....................                   newptr = malloc(size);  //use malloc to find new block 
....................                   if(newptr == NULL) 
....................                      return(NULL);        //return NULL if malloc was unable to find new block 
....................                     
....................                   memcpy(newptr, ptr, nsize);   //copy original data to new block 
....................                   free(ptr);                    //free original block 
....................                   return(newptr);               //return new pointer 
....................                } 
....................             } 
....................             else  //next block not free 
....................             { 
....................                newptr = malloc(size);  //use malloc to find new block 
....................                if(newptr == NULL)       
....................                   return(NULL);        //return NULL if malloc was unable to find new block 
....................                 
....................                memcpy(newptr, ptr, nsize);   //copy original data to new block 
....................                free(ptr);                    //free original block 
....................                return(newptr);               //return new pointer 
....................             } 
....................          } 
....................          return (char *)node+sizeof(node_t); // return pounsigned int8er to the reallocated block 
....................       } 
....................       else // not allocated use malloc 
....................       { 
....................          return(malloc(size)); 
....................       } 
....................    } 
....................  } 
.................... #ENDIF 
....................  
....................  
.................... // configuration files   
.................... #include "pic_config.h" 
.................... //IF NO primary oscillator is used, no need for FCMEN or PRIMARY_SW 
.................... // or IESO; also for debug purposes place INTRC at IO pin RA6 
.................... // THINK ABOUT PUT config setting! and transitions out of sleep that require 
.................... // accurate timing for UART 
....................  
.................... /////////////////////Fuses Start/////////////////////////////////////////////// 
.................... #FUSES CCP2B3 //CCP2 input/output multiplexed with RB3 
.................... #FUSES CCP2D2 //CCP2 input/output multiplexed with RD2 
.................... #FUSES CCP3E0 //CCP3 input/output multiplexed with RE0 
.................... #FUSES HFOFST //High Frequency INTRC starts clocking CPU immediately  
.................... #FUSES HSH //High speed Osc, high power 16MHz-25MHz 
.................... #FUSES IESO //Internal External Switch Over mode enabled  
.................... #FUSES MCLR //Master Clear pin enabled  
.................... #FUSES NOBROWNOUT //No brownout reset  
.................... #FUSES NOCPB //No Boot Block code protection  
.................... #FUSES NOCPD //No EE protection  
.................... #FUSES NODEBUG //No Debug mode for ICD 
.................... #FUSES NOEBTR //Memory not protected from table reads  
.................... #FUSES NOEBTRB //Boot block not protected from table reads  
.................... #FUSES NOFCMEN //Fail-safe clock monitor disabled  
.................... #FUSES NOLVP //No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O  
.................... #FUSES NOPBADEN //PORTB pins are configured as digital I/O on RESET 
.................... #FUSES NOPLLEN //4X HW PLL disabled, 4X PLL enabled in software   
.................... #FUSES NOPROTECT //Code not protected from reading  
.................... #FUSES NOWRT //Program memory not write protected  
.................... #FUSES NOWRTB //Boot block not write protected  
.................... #FUSES NOWRTC //configuration not registers write protected  
.................... #FUSES NOWRTD //Data EEPROM not write protected  
.................... #FUSES NOXINST //Extended set extension and Indexed Addressing mode disabled (Legacy mode)  
.................... #FUSES PRIMARY_SW //Primary clock can be disabled in software  
.................... #FUSES PUT //Power Up Timer 
.................... #FUSES STVREN //Stack full/underflow will cause reset 
.................... #FUSES TIMER3B5 //Timer3 Clock In is on pin B5  
.................... #FUSES WDT32768 //Watch Dog Timer uses 1:32768 Postscale  
.................... #FUSES WDT_SW //No Watch Dog Timer, enabled in Software  
.................... //#FUSES WDT //Watch Dog Timer enabled.  
.................... /////////////////////Fuses End///////////////////////////////////////////////// 
....................                                            
.................... /////////////////////Serial and I2C Timing Setup Start///////////////////////// 
.................... #use delay(clock=3,686,400)  
.................... #use RS232 (uart1, baud=115200)        
.................... #use delay(clock=250KHZ) 
.................... // setup i2c for use on 250khz main clock 
.................... #use i2c(master, I2C1, NOINIT, FORCE_HW, SLOW) 
.................... #use  fast_io(all) 
.................... /////////////////////Serial and I2C Timing Setup End/////////////////////////// 
....................  
.................... /////////////////////Special Function Registers Start////////////////////////// 
....................  
.................... #byte    WREG     =  0x0FE8 
.................... #byte    STATUS   =  0x0FD8 
.................... #BIT     CARRY       =  STATUS.0 
....................  
.................... #byte    STKPTR   =  0x0FFC 
.................... #BIT     STKUNF      = STKPTR.6 
.................... #BIT     STKFUL      = STKPTR.7 
....................  
.................... #byte    RCON     =  0x0FD0 
.................... #BIT     IPEN        = RCON.7 
....................  
.................... #byte    INTCON   =  0x0FF2 
.................... #BIT     RBIF        = INTCON.0 
.................... #BIT     INT0IF      = INTCON.1 
.................... #BIT     TMR0IF      = INTCON.2                                                                                                           
.................... #BIT     RBIE        = INTCON.3 
.................... #BIT     INT0IE      = INTCON.4 
.................... #BIT     TMR0IE      = INTCON.5                                                                                                    
.................... #byte    INTCON2  =  0x0FF1 
.................... #BIT     RBPU        = INTCON2.7   
.................... // RBPU lo to allow individual PORTB pullups 
.................... #byte    INTCON3  =  0x0FF0   
.................... #BIT     INT1IF      =  INTCON3.0 
.................... #BIT     INT2IF      =  INTCON3.1 
....................  
.................... #byte    T0CON    =  0x0FD5 
.................... #BIT     TMR0ON      = T0CON.7 
....................  
.................... #byte    OSCCON   =  0x0FD3 
.................... #BIT     SCS0        = OSCCON.0 
.................... #BIT     SCS1        = OSCCON.1 
.................... #BIT     HFIOFS      = OSCCON.2 
.................... #BIT     OSTS        = OSCCON.3 
.................... #BIT     IDLEN       = OSCCON.7 
.................... #byte    OSCCON2  =  0x0FD2 
.................... #BIT     LFIOFS      = OSCCON2.0 
.................... #BIT     MFIOFS      = OSCCON2.1 
.................... #BIT     PRISD       = OSCCON2.2 
.................... #BIT     SOSCGO      = OSCCON2.3 
.................... #BIT     MFIOSEL     = OSCCON2.4 
.................... #BIT     SOSCRUN     = OSCCON2.6 
.................... #BIT     PLLRDY      = OSCCON2.7 
.................... #byte    OSCTUNE  =  0x0F9B 
.................... #BIT     PLLEN       = OSCTUNE.6 
.................... #BIT     INTSRC      = OSCTUNE.7 
....................  
.................... // Timer registers 
.................... #byte    TMR1H    =  0x0FCF 
.................... #byte    TMR1L    =  0x0FCE 
.................... #byte    T1CON    =  0x0FCD 
.................... #BIT     TMR1ON      = T1CON.0 
.................... #byte    T1GCON   =  0x0FCC 
.................... #BIT     T1GGO       = T1GCON.3 
....................  
.................... #byte    T2CON    =  0x0FBA 
.................... #BIT     TMR2ON      = T2CON.2 
.................... #BIT     T2CKPS0     = T2CON.0 
.................... #BIT     T2CKPS1     = T2CON.1 
.................... #byte    PR2      =  0x0FBB 
....................  
.................... #byte    TMR3H    =  0x0FB3 
.................... #byte    TMR3L    =  0x0FB2 
.................... #byte    T3CON    =  0x0FB1 
.................... #BIT     TMR3ON      =  T3CON.0 
.................... #byte    T3GCON   =  0x0FB4 
.................... #BIT     T3GGO       = T3GCON.3 
....................  
.................... #byte    T4CON    =  0x0F51 
.................... #BIT     TMR4ON      = T4CON.2 
.................... #byte    PR4      =  0x0F52 
....................  
....................  
.................... #byte    TMR5H    =  0x0F50 
.................... #byte    TMR5L    =  0x0F4F      
.................... #byte    T5CON    =  0x0F4E 
.................... #BIT     TMR5ON      = T5CON.0 
.................... #byte    T5GCON   =  0x0F4D 
.................... #BIT     T5GGO       = T5GCON.3 
....................  
.................... #byte    T6CON    =  0x0F4A 
.................... #BIT     TMR6ON      = T6CON.2 
.................... #byte    PR6      =  0x0F4B 
....................  
.................... // ADC registers 
.................... #word    ADRES    =  0x0FC3 
.................... #byte    ADCON0   =  0x0FC2 
.................... #BIT     ADON        =  ADCON0.0 
.................... #BIT     ADGO        =  ADCON0.1 
.................... #byte    ADCON2   =  0x0FC0 
.................... #define  ADC_SETUP_DEF  0xFF   // right justified read, 20TAD acquisition time (insurance), FRC 
....................  
.................... // CCP registers       
.................... #byte    CCPR1H   =  0x0FBF 
.................... #byte    CCPR1L   =  0x0FBE 
.................... #byte    CCP1CON  =  0x0FBD 
.................... #byte    CCPR2H   =  0x0F68 
.................... #byte    CCPR2L   =  0x0F67 
.................... #byte    CCP2CON  =  0x0F66 
.................... #byte    CCPR3H   =  0x0F5F 
.................... #byte    CCPR3L   =  0x0F5E 
.................... #byte    CCP3CON  =  0x0F5D 
.................... #byte    CCPR4H   =  0x0F59 
.................... #byte    CCPR4L   =  0x0F58 
.................... #byte    CCP4CON  =  0x0F57 
.................... #byte    CCPR5H   =  0x0F56 
.................... #byte    CCPR5L   =  0x0F55 
.................... #byte    CCP5CON  =  0x0F54 
....................  
.................... #byte    CCPTMRS0 =  0x0F49 
.................... #byte    CCPTMRS1 =  0x0F48 
.................... #byte    PSTR1CON =  0x0FB9 
.................... #byte    BAUDCON1 =  0x0FB8 
....................  
.................... #byte    SPBRGH1  =  0x0FB0 
.................... #byte    SPBRG1   =  0x0FAF 
.................... #byte    RCREG1   =  0x0FAE 
.................... #byte    TXREG1   =  0x0FAD 
.................... #byte    TXSTA1   =  0x0FAC 
.................... #BIT     TRMT1       = TXSTA1.1     // 1: empty xmit reg, 0: xmit in progress 
.................... #byte    RCSTA1   =  0x0FAB 
.................... #BIT     FERR1       = RCSTA1.2 
....................  
.................... #byte    PIR1     =  0x0F9E 
.................... #BIT     TMR1IF      = PIR1.0 
.................... #BIT     TMR2IF      = PIR1.1 
.................... #BIT     SSP1IF      = PIR1.3 
.................... #BIT     ADIF        = PIR1.6 
.................... #byte    PIR2     =  0x0FA1 
.................... #BIT     CCP2IF      = PIR2.0 
.................... #BIT     TMR3IF      = PIR2.1 
.................... #BIT     BCL1IF      = PIR2.3 
.................... #BIT     C1IF        = PIR2.6 
.................... #BIT     OSCFIF      = PIR2.7 
.................... #byte    PIR3     =  0x0FA4 
.................... #BIT     TMR5GIF     = PIR3.2 
.................... #BIT     TMR3GIF     = PIR3.1 
.................... #BIT     TMR1GIF     = PIR3.0 
.................... #byte    PIR4     =  0x0F7B 
.................... #BIT     CCP3IF      = PIR4.0 
.................... #BIT     CCP4IF      = PIR4.1 
.................... #BIT     CCP5IF      = PIR4.2 
.................... #byte    PIR5     =  0x0F7E 
.................... #BIT     TMR4IF      = PIR5.0 
.................... #BIT     TMR5IF      = PIR5.1 
.................... #BIT     TMR6IF      = PIR5.2 
....................  
.................... #byte    PIE1     =  0x0F9D 
.................... #BIT     TMR2IE      =  PIE1.1 
.................... #byte    PIE2     =  0x0FA0 
.................... #BIT     CCP2IE      =  PIE2.0 
.................... #byte    PIE3     =  0x0FA3 
.................... #byte    PIE4     =  0x0F7A 
.................... #byte    PIE5     =  0x0F7D 
....................  
.................... #byte    IPR1     = 0x0F9F 
.................... #byte    IPR2     = 0x0FA2 
.................... #byte    IPR3     = 0x0FA5 
.................... #byte    IPR4     = 0x0F7C 
.................... #byte    IPR5     = 0x0F7F 
....................  
.................... #byte    LATA     =  0x0F89 
.................... #byte    PORTA    =  0x0F80 
.................... #byte    TRISA    =  0x0F92 
.................... #byte    LATB     =  0x0F8A 
.................... #byte    PORTB    =  0x0F81 
.................... #byte    TRISB    =  0x0F93 
.................... #byte    LATC     =  0x0F8B 
.................... #byte    PORTC    =  0x0F82 
.................... #byte    TRISC    =  0x0F94 
.................... #byte    LATD     =  0x0F8C 
.................... #byte    PORTD    =  0x0F83 
.................... #byte    TRISD    =  0x0F95 
.................... #byte    LATE     =  0x0F8D 
.................... #byte    PORTE    =  0x0F84 
.................... #byte    TRISE    =  0x0F96 
....................  
.................... #byte    PSTR2CON =  0x0F63 
.................... #byte    IOCB     =  0x0F62 
.................... #byte    WPUB     =  0x0F61 
.................... #byte    PSTR3CON =  0x0F5A 
....................  
.................... #byte    CM1CON0  =  0x0F79 
.................... #bit     C1ON        = CM1CON0.7 
.................... #bit     C1POL       = CM1CON0.4 
.................... #byte    CM2CON0  =  0x0F78 
.................... #byte    CM2CON1  =  0x0F79 
....................  
.................... #byte    VREFCON0 =  0x0F42 
.................... #bit     FVREN    =  VREFCON0.7     //fixed voltage ref enable 
.................... #bit     FVRST    =  VREFCON0.6     //fixed voltage ref stable 
.................... #bit     FVRS1    =  VREFCON0.5     //fixed voltage select 1 
.................... #bit     FVRS0    =  VREFCON0.4     //fixed voltage select 0 
.................... #byte    VREFCON1 =  0x0F41 
.................... #byte    VREFCON2 =  0x0F40 
....................  
.................... #byte    PMD0     =  0x0F3F 
.................... #byte    PMD1     =  0x0F3E 
.................... #byte    PMD2     =  0x0F3D 
.................... #byte    CTMUICON =  0x0F43 
.................... #byte    CTMUCONL =  0x0F44 
.................... #byte    CTMUCONH =  0x0F45 
.................... #byte    SRCON1   =  0x0F46 
.................... #byte    SRCON0   =  0x0F47 
....................  
.................... #byte    SSP1CON2 =  0x0FC5 
.................... #BIT     SEN         = SSP1CON2.0 
.................... #BIT     PEN         = SSP1CON2.2 
.................... #byte    SSP1CON1 =  0x0FC6 
.................... #BIT     WCOL        = SSP1CON1.7 
.................... #byte    SSP1STAT =  0x0FC7 
.................... #BIT     I2CBUSY     = SSP1STAT.0 
....................  
.................... #define  RCON_INIT    0b00010011 
.................... // OR with RCON to SET BORn, PORn and RIn bits 
....................  
.................... /////////////////////Special Function Registers End//////////////////////////// 
....................  
.................... /////////////////////I/0 Lines and Initialization Start//////////////////////// 
....................   
.................... //  PORTA/B/C _ COLD and TRISA/B/C _ NORM are fine for lowest_pwr() I/O setup 
....................  
.................... ////////////////////ADC channel choices 
.................... #define V_EXT_REF    0        // AN0 = RA0, 1.2V accurate reference 
....................                               // use 1.2V accurate ref for measurements 
.................... #define V_VLVI       1        // AN1 = RA1 
.................... #define V_GEN        12       // AN12 = RB0 (INT0) 
.................... #define V_XDC        13       // Extra IO 1, now used for XDCR measurements 
....................       
.................... #define V_DAC        30       // DAC output may be read by ADC 
.................... #define V_FIXED      31       // 1.024/2.048/4.096V Fixed Reference (internal) 
....................  
....................  
.................... ////////////////////PORT A///////////////////// 
....................  
.................... //    V_EXT_REF    PIN_A0      // external reference, analog AN0 
.................... //    V_VLVI       PIN_A1      // sense line, valve motor current, analog AN1 
.................... #define LED2n        PIN_A2      // RA2 output, active lo 
.................... #define MOTE_RX_CTSn PIN_A3      // RA3 input active lo 
....................                                  //  mote asserts to tell micro it is 
....................                                  //  clear to rcv data from micro; 
....................                                  //  was _DUST_MTCTS 
....................                                  //  set as output, init hi 
.................... #define GPS_PWRn     PIN_A4      // RA4 output, active lo 
.................... #define MOTE_TX_CTSn PIN_A5      // RA5 output, active lo,  
....................                                  //  assert to initiate rcv data from MOTE, 
....................                                  //  byte level handshake; 
....................                                  //  was _DUST_SPCTS                                
.................... //      OSC2         PIN_A6      // xtal osc output connection 
.................... //      OSC1         PIN_A7      // xtal osc input connection 
....................  
.................... #define TRISA_NORM   0b10001011 
....................                                  // A0 analog 
....................                                  // A1 analog 
....................                                  // A2 output 
....................                                  // A3 input 
....................                                  // A4 output 
....................                                  // A5 output 
....................                                  // A6 output 
....................                                  // A7 input 
.................... #define PORTA_INIT   0b01110100 
....................                                  // A0 analog (0) 
....................                                  // A1 analog (0)  
....................                                  // A2 output active lo (1) 
....................                                  // A3 input (0) 
....................                                  // A4 output active lo (1) 
....................                                  // A5 output active lo (1) 
....................                                  // A6 output (1) 
....................                                  // A7 input (0) 
.................... #define PORTA_IDLE   PORTA_INIT 
.................... #define PORTA_DEEP   PORTA_INIT 
....................  
....................  
.................... ////////////////////PORT B//////////////////// 
....................  
.................... #define V_GEN_INT    PIN_B0      // RB0 input, high for significant v_gen; 
....................                                  //  generally analog, but may be input; 
....................                                  //  INT0 
....................                                   
.................... #define GPS_TXRDY    PIN_B1      // RB1 input, high indicates GPS has data 
....................                                  //  ready to transmit to micro 
....................                                   
.................... #define MOTE_TX_RTSn PIN_B2      // RB2 input, active lo 
....................                                  //  mote asserts to tell micro it is 
....................                                  //   ready to send data to micro; 
....................                                  //  was _DUST_MTRTS; INT2    
....................                                   
.................... #define LTC3105_CTRL PIN_B3      // output, active hi, P2A-pwm, 
....................                                  //  shdn/enab input of 3105 
....................                                  //  hi for max chg aggressiveness (lower RPM) 
....................  
.................... #BIT    LTC3105_CTRL_pinstate   = LATB.3 
....................  
....................  
.................... #define SW1n         PIN_B4      // usually an input, active lo 
....................                                  //  note can be IOC 
.................... #define LED1n        PIN_B4      // may become an output, active lo 
....................  
.................... #define ADC_XDCR     PIN_B5      // wired as input (ADC) to analog XDCR signal 
....................                                                                  
.................... #define SPARE2       PIN_B6      // consider as an input (PGC); 
....................                                  //  wired to VLV_XDCR header     
.................... #define SPARE3       PIN_B7      // consider as an input (PGD) 
....................  
.................... #define TRISB_NORM   0b11110111 
....................                                  // B0 input (INT0) 
....................                                  // B1 input (INT1) 
....................                                  // B2 input (INT2) 
....................                                  // B3 output 
....................                                  // B4 input (usually, may become an output) 
....................                                  // B5 input (spare) 
....................                                  // B6 input (PGC) 
....................                                  // B7 input (PGD)                                             
.................... #define TRISB_LED    0b11100111 
....................                                  // same as TRISB_NORM, but PIN_B4 is output 
....................                                                                                 
.................... #define PORTB_INIT   0b00011000 
....................                                  // B0 input (0) 
....................                                  // B1 input (0) 
....................                                  // B2 input (0) 
....................                                  // B3 output (LTC3105_CTRL) hi=fully charge (1) 
....................                                  // B4 usually an input,  
....................                                  //   may be output active lo (1) 
....................                                  // B5 input unused (0) 
....................                                  // B6 may be spare I/O (PGC)  
....................                                  // B7 may be spare I/O (PGD) 
.................... #define PORTB_IDLE   0b00010000  // only difference here is that LTC3105 is 
....................                                  //  shut down              
.................... #define PORTB_DEEP   PORTB_IDLE 
....................  
....................                                    
.................... #define PORTB_PULLUPS            0b00010010 
.................... #define PORTB_PULLUPS_WITH_XDCR  0b00110010             
....................                                  // only MOTE_TX_RTSn (pin B2)  
....................                                  // and SW1/LED1 are pulled up by defualt. 
....................                                  // ADC_XDCR (pin B5) is turned on for a second to detect  
....................                                  //    if the XDCR is plugged in or not during XDCR_init()   
....................                                                                         
....................                                 
....................                                                                                             
.................... ////////////////////PORT C//////////////////// 
....................  
.................... //      SOSCO        PIN_C0      // xtal osc output connection 
.................... //      SOCSI        PIN_C1      // for debug, we can look at frequency here 
.................... #define BRK_CTRLn    PIN_C2      // P1A-pwm, to gates of FETs -- 
....................                                  //  lo for max braking force, hi for no brake 
....................  
.................... #BIT     BRK_pinstate   = LATC.2                               
....................  
.................... //      SCL1         PIN_C3      // I2C clock 
.................... //      SDA1         PIN_C4      // I2C data 
.................... #define XDCR_PWR     PIN_C5      // output, active hi 
.................... //      MOTE_RX      PIN_C6      // UART1 TX output 
.................... //      MOTE_TX      PIN_C7      // UART1 RX input 
....................  
.................... #define TRISC_NORM   0b10011010 
....................                                  // C0 output 
....................                                  // C1 input 
....................                                  // C2 output 
....................                                  // C3/C4 inputs (I2C) 
....................                                  // C5 output 
....................                                  // C6 output (UART TX / MOTE_RX) 
....................                                  // C7 input  (UART RX / MOTE_TX) 
....................  
.................... #define PORTC_INIT   0b01000101 
....................                                  // C0 output (1) 
....................                                  // C1 input (0) 
....................                                  // C2 output (SPD_CTRL hi=no braking) (1) 
....................                                  // C3/4 I2C, init as inputs (0) 
....................                                  // C5 output active hi (0) 
....................                                  // C6 output (1) 
....................                                  // C7 input (0) 
.................... #define PORTC_IDLE   PORTC_INIT 
.................... #define PORTC_DEEP   PORTC_INIT 
....................  
.................... ////////////////////PORT D//////////////////// 
.................... #define GPS_ON       PIN_D0      // output, active hi 
.................... #define MOTE_TIMEn   PIN_D1      // output, active lo, gets time from mote 
.................... #define LCD_RESETn   PIN_D2      // output, active lo 
.................... #define AUX_PWR      PIN_D3      // output, active hi, turns on AUX pwr 
.................... #define MOTE_RESETn  PIN_D4      // output, active lo 
.................... #define MOTE_RX_RTSn PIN_D5      // output, active lo 
....................                                  //  micro asserts to tell mote it is  
....................                                  //   ready to send data to mote 
.................... #define GPS_RX       PIN_D6      // UART2 TX output 
.................... #define GPS_TX       PIN_D7      // UART2 RX input 
....................  
.................... #define TRISD_NORM   0b10000000 
....................                                  // D0 output 
....................                                  // D1 output 
....................                                  // D2 output (spare) 
....................                                  // D3 output 
....................                                  // D4 output 
....................                                  // D5 output 
....................                                  // D6 output 
....................                                  // D7 input 
....................  
.................... #define PORTD_INIT   0b01110110 
....................                                  // D0 output active hi (0) 
....................                                  // D1 output active lo (1) 
....................                                  // D2 output active lo (1) 
....................                                  // D3 output active hi (0) 
....................                                  // D4 output active lo (1) 
....................                                  // D5 output active lo (1) 
....................                                  // D6 output (1) 
....................                                  // D7 input (0) 
.................... #define PORTD_IDLE   PORTD_INIT 
.................... #define PORTD_DEEP   PORTD_INIT 
....................  
.................... ////////////////////PORT E//////////////////// 
.................... #define VLV_CTRL1    PIN_E0      // P3A-pwm, to H-bridge re valve  
.................... #define VLV_CTRL2    PIN_E1      // P3B-pwm, to H-bridge re valve 
.................... #define GEN_RPM      PIN_E2      // CCP5 input 
.................... //       MCLRn       PIN_E3 
....................  
.................... #define TRISE_NORM   0b00001100 
....................                                  // E0 output 
....................                                  // E1 output 
....................                                  // E2 input 
....................                                  // E3 master clear input 
....................  
.................... #define PORTE_INIT   0b00000000 
....................                                  // E0 output (E0,E1 = 00 for coast state) 
....................                                  // E1 output 
....................                                  // E2 input (0) 
....................                                  // E3 input (0) 
.................... #define PORTE_IDLE   PORTE_INIT  // TURNS off the power supply to  
....................                                  //  the valve motor 
.................... #define PORTE_DEEP   PORTE_INIT 
....................  
.................... /////////////////////I/0 Lines and Initialization End////////////////////////// 
....................  
....................  
.................... /////////////////////Timer 0 Start///////////////////////////////////////////// 
....................  
.................... // THESE VALUES ARE DEPENDENT UPON CRYSTAL FREQUENCY 
.................... // Modify with care 
.................... #define  T0_OSC    4340 
.................... // After calibration of 1MHz HFINTOSC timebase to 921.6KHz: 4/Fosc = 4340 nsec 
....................  
.................... // Assume 16 bit timer0 input is FOSC div 128 (timer 0 prescaler) 
.................... // Thus one count every 128*T0_OSC nanoseconds                      
.................... #define T0_SETUP(MS) {  setup_timer_0(T0_DIV_128); \ 
....................                         set_timer0(65536 - (1000000*MS + 64*T0_OSC)/(128*T0_OSC)); } 
.................... // Note roundoff fix                     
.................... // For use with the routine setup_T0_int(*) 
....................  
.................... //Timer 0 options 
.................... #define  T0_500US    65534 
.................... #define  T0_1MS      65536 - 1000/256 
.................... #define  T0_10MS     65536 - 10000/256 
.................... #define  T0_20MS     65536 - 20000/256 
.................... #define  T0_50MS     65536 - 50000/256 
.................... #define  T0_100MS    65536 - 100000/256 
.................... #define  T0_175MS    65536 - 175000/256 
.................... #define  T0_250MS    65536 - 250000/256 
.................... #define  T0_500MS    65536 - 500000/256 
.................... #define  T0_1S       65536 - 1000000/256 
.................... #define  T0_2S       65536 - 2000000/256 
.................... #define  T0_3S       65536 - 3000000/256 
.................... #define  T0_4S       65536 - 4000000/256 
.................... #define  T0_6S       65536 - 6000000/256 
.................... #define  T0_16S      65536 - 16000000/256 
.................... // the max is actually 16.7 seconds 
....................  
.................... /////////////////////Timer 0 End/////////////////////////////////////////////// 
....................  
.................... /////////////////////Timer 2 Start///////////////////////////////////////////// 
....................  
.................... // For use with the routine setup_T2_int(*) 
.................... // The equivalent tick duration for timer2 is 
.................... //  adjusted depending on Fosc to be approx 256usec 
.................... // Timer2 counts up from 0 to match PR2 in order to set int flag 
.................... #define T2_1MS       3 
.................... #define T2_2MS       7 
.................... #define T2_3MS       11 
.................... #define T2_4MS       15 
.................... #define T2_5MS       19 
.................... #define T2_6MS       23 
.................... #define T2_7MS       27 
.................... #define T2_8MS       31 
.................... #define T2_9MS       35 
.................... #define T2_10MS      39 
.................... #define T2_15MS      59 
.................... #define T2_20MS      79 
.................... #define T2_25MS      99 
.................... #define T2_30MS      119 
.................... #define T2_40MS      159 
.................... #define T2_50MS      199 
.................... #define T2_60MS      239 
.................... #define T2_64MS      255 
.................... // cannot set to higher than 64 milliseconds  
....................  
.................... ////////////////////Timer 2 End//////////////////////////////////////////////// 
....................  
.................... /////////////////////Timer 4 Start///////////////////////////////////////////// 
....................  
.................... // For use with the routine setup_T4_int(*) 
.................... // The equivalent tick duration for timer4 is 
.................... //  adjusted depending on Fosc to be approx 256usec 
.................... // Timer4 counts up from 0 to match PR4 in order to set int flag 
.................... #define T4_500US     1 
.................... #define T4_1MS       3 
.................... #define T4_2MS       7 
.................... #define T4_3MS       11 
.................... #define T4_4MS       15 
.................... #define T4_5MS       19 
.................... #define T4_6MS       23 
.................... #define T4_7MS       27 
.................... #define T4_8MS       31 
.................... #define T4_9MS       35 
.................... #define T4_10MS      39 
.................... #define T4_15MS      59 
.................... #define T4_20MS      79 
.................... #define T4_25MS      99 
.................... #define T4_30MS      119 
.................... #define T4_40MS      159 
.................... #define T4_50MS      199 
.................... #define T4_60MS      239 
.................... #define T4_64MS      255 
.................... // cannot set to higher than 64 milliseconds  
....................  
.................... ////////////////////Timer 4 End//////////////////////////////////////////////// 
....................  
....................  
.................... ////////////////////Battery-Voltage Start////////////////////////////////////// 
.................... // magic number based upon 4 samples averages with 1.2V reference! 
.................... // 12.20 format (4.8V) 
.................... #define VAL32_FVR_BAT      4.8 * 1048576 // 5033164.8 = 4CCCCD 
....................  
.................... ////////////////////Battery-Voltage End//////////////////////////////////////// 
....................  
....................  
....................  
.................... ////////////////////Restart Causes Start/////////////////////////////////////// 
.................... /* 
.................... // reset_cause is set to one of these values before any reset_cpu instruction 
....................  
.................... #define WARM_RESTART          0x00  // commanded: joins if needed 
.................... #define SPIN_RESTART          0x10  // generator wakeup from Deep sleep  
....................                                     //  or idle sleep 
....................                                     //  like WARM_RESTART                                         
.................... #define FRC_RJOIN_RESTART     0x20  // commanded to duplicate behavior of 
....................                                     //  unexpected mote state change during 
....................                                     //  RUN; like WARM_RESTART; mote rejoins 
....................                                     //  and informs manager 
.................... #define RJOIN_RESTART         0x30  // unexpected mote state change during 
....................                                     //  RUN; like WARM_RESTART; mote rejoins 
....................                                     //  and informs manager   
.................... #define COLD_RESTART          0x50  // commanded: force join 
.................... */ 
.................... ////////////////////Restart Causes End///////////////////////////////////////// 
....................  
.................... ////////////////////Extra LCD Start//////////////////////////////////////////// 
.................... /* 
.................... // New Haven display part number NHD-C0216CIZ-FSW-FBW-3V3 special characters 
.................... #define  CROSS_CHAR        0xF7 
.................... // small cross 
.................... #define  BOX_CHAR          0xDB 
.................... // rectangle 
.................... #define  TOPLINE_CHAR      0xFF 
.................... // top line designates battery full, no charging needed 
.................... #define  NOTEQU_CHAR       0xFD 
.................... // equ with slash 
.................... #define  NOCHG_CHAR        0xE4 
.................... // c with slash, cent symbol, indicates charger circuit OFF 
.................... #define  MAXCHG_CHAR       'C' 
.................... #define  MINBRAKE_CHAR     'b' 
.................... #define  MAXBRAKE_CHAR     'B' 
.................... // PFHI character, indicates maximum braking force 
.................... #define  NOVLV_CHAR        'v' 
.................... // a PERIOD indicates valve PWM set for NO MOTION 
.................... #define  MAXVLV_CHAR       'V' 
.................... // ! indicates valve PWM set for MAX speed 
....................  
.................... #define  APPOS_CHAR        0x27 
.................... // appostrophe character: ' 
....................  
....................  
.................... //#define  APPROX_CHAR       0x00 
.................... // custom approx equal character loaded at LCD_INIT 
....................  
.................... // custom characters loaded during LCD_INIT 
.................... #define  LEV1_CHAR         0x00 
.................... #define  LEV2_CHAR         0x01 
.................... #define  LEV3_CHAR         '_' 
.................... #define  LEV4_CHAR         0x02 
.................... #define  LEV5_CHAR         0x03 
.................... #define  LEV6_CHAR         '-' 
.................... #define  LEV7_CHAR         0x04 
.................... #define  LEV8_CHAR         0x05 
.................... #define  LEV9_CHAR         0x06 
.................... #define  LEV10_CHAR        0xFF 
....................  
.................... #define  BIGBOX_CHAR       0x07 
.................... #define  WAYLOW_CHAR       0xFB 
.................... // << 
.................... #define  WAYHI_CHAR        0xFC 
.................... // >> 
.................... #define  CIRCLE_CHAR       0xF2 
.................... // small circle 
....................  
.................... */ 
.................... ////////////////////Extra LCD End////////////////////////////////////////////// 
.................... ////////////////////EEPROM Locations Start///////////////////////////////////// 
....................  
.................... // EEPROM LOCATIONS 
.................... #define EE_ADDCHG_DUR      0x0002 
....................    // Configures add-charging time in seconds 
....................    // 2 bytes, low byte at 0x0002 
.................... #define ADDCHG_DUR_DEF     4 
....................    // 4 minutes? 
.................... #define EE_PRECHG_DUR      0x0004 
....................    // Configures precharging time in seconds 
....................    // 2 bytes, low byte at 0x0004 
.................... #define PRECHG_DUR_DEF     10 
....................    // 1.5 minutes?  
.................... #define CHGLOOPS_PER_MIN   110 
....................    // determined experimentally, each loop is about 545 msec 
....................    //  which is a bit longer than I would prefer (!), but oh well. 
....................    //  JG 2015 Jun16 
....................     
.................... // 0x00A thru 0x00F        reserved 
.................... #define EE_NETW_ID         0x0010 
....................    // 2 bytes, low byte at 0x0010; for now, network ID defaults to 0x04CD. 
.................... #define EE_PRENETW_ID      0x0012 
....................    // 2 bytes, low byte at 0x0012; for now, network ID defaults to 0x04CD. 
....................  
....................  
.................... // 0013 reserved 
.................... #define EE_LOCATION     0x0014 
....................    // 2 bytes, low byte at 0x0014; associates sprinkler with particular 
....................    //  physical location on CP 
.................... #define EE_PRELOCATION  0x0016 
....................    // 2 bytes, low byte at 0x0016, previous association of sprinkler with 
....................    //  particular physical location on CP 
....................  
....................    // 0x018 thru 0x01F     reserved 
....................  
.................... // IDLE behavior specified at 0x0020 thru 0x0033 
.................... #define EE_IDLE_OPT        0x0020 
....................    // Configures IDLE behavior.  Applies if battery low during operational 
....................    //  state 
....................    //  0x00  send out Panic Message once when panic level is reached according 
....................    //         to voltage-based algorithm 
....................    //  0x01  send out Panic Message once when panic level is reached according 
....................    //         to charge-based algorithm 
.................... #define MAX_IDLE_OPT       1 
....................    // If manager tries to write any idle_opt value larger than this to EEPROM 
....................    //  a NACK occurs; see above for idle option choices 
.................... #define LEN_IDLE_BLOCK     15 
....................    // There are 15 bytes in the idle block 
....................  
.................... #define EE_IDLE_PROFILE    0x0021 
....................    // Saved only upon entering IDLE state; 
....................    //  profile number which was running or had last been run. 
....................    // 0 for default profile, 1, 2, 3 for controller-specified profile choices 
....................    //  other numbers, use 0 
.................... #define EE_IDLE_STEP       0x0022 
....................    // Saved only upon entering IDLE state; 
....................    //  step number of profile which was running or had last been run. 
....................    //  Step 0xFF indicates that we were not within a profile 
....................    //  Step 0x10 thru 0xFE invalid. 
.................... #define EE_IDLE_STIME      0x0023 
....................    // 2 bytes, low byte at 0x0023, high byte at 0x0024 
....................    // Saved only upon entering IDLE state; 
....................    //  amount of time in seconds that rate was controlled according 
....................    //  to EE_IDLE_STEP at time when IDLE state entered; 
....................    //  set to 0x0000 if EE_IDLE_STEP=0xFF. 
.................... #define EE_IDLE_LOOP       0x0025 
....................    // 2 bytes, low byte at 0x0025, high byte at 0x0026 
....................    // Saved only upon entering IDLE state; 
....................    //  for looping profiles, loop number at time when IDLE state entered; 
....................    //  set to 0x0000 for non-looping profiles, set to 
....................    //  0x0000 if EE_IDLE_STEP=0xFF. (looping beyond 0xFFFF is recorded as 
....................    //  0xFFFF) 
.................... #define EE_IDLE_CHG        0x0027 
....................    // 2 bytes, low byte at 0x0027, high byte at 0x0028 
....................    // Configures used charge in millicoulombs for 
....................    //  charge-based shutdown method (TBD); applies if EE_IDLE.1 is set 
.................... #define EE_IDLE_SHDN_DLY   0x0029 
....................    // 2 bytes, low byte at 0x0029, high byte at 0x002A 
....................    // Configures time in units of 67 secs (TMR0 ints during IDLE) 
....................    //  between sensing of low battery and self-shutdown 
....................  
.................... ////////////////////EEPROM Locations End/////////////////////////////////////// 
.................... //*************************************************************** 
.................... /* 
.................... #define DAY_SECS           24*3600 
....................  
.................... #define VAL32_FVR_BAT      4.8 * 1048576 // 5033164.8 = 4CCCCD 
.................... // magic number based upon 4 samples averages with 1.2V reference! 
.................... // 12.20 format (4.8V) 
....................  
.................... #define NETWORK_ID_DEF  0x04CD 
.................... // 04CD flipped bytes to match received network ID (JG!~?) 
.................... // this is the net_id for BlueBox#0 
.................... #define NETWORK_ID_MAX  NETWORK_ID_DEF + 250 
.................... // We could actually go from 0 (0x04CD) to 254, with 255 being illegal 
.................... //  as what would be read from cleared EEPROM 
....................  
.................... #define MAX_SP_NUM      499 
.................... // based on maximum number of motes that can be supported by Blue Box 
.................... #define MAX_SP_CP       200 
.................... // highest sprinkler number which uses the WARNER VALVE parameters 
.................... //  otherwise uses the BENCH VALVE SIMULATOR parameters 
....................  
.................... // state of charge levels 
....................  
.................... #define R2T             23040 
....................    // 0x00005A00 
....................    // Divide this number by RPM to get the target CCP2 capture value 
....................    //  representative of speed. 
....................    // 23040 RPM/(CCP2-prev_count) = 19200Hz * 6/5, where 19.2KHz is fosc/4, 
....................    //  (1 rising edge occurs per capture event) and 6/5 RPM/Hz is the 
....................    //  generator-dependent relationship between its output frequency and its 
....................    //  RPM. 
....................    // For example, 10RPM results in 2304 counts in the capture register 
.................... #define R2Tx4      R2T*4 
....................  
.................... #define VMOTION_TIMEOUT    60 
.................... // if valve travels longer than this time, a timeout error occurs 
....................  
.................... #define RPM_MIN            4 
.................... #define RPM_MAX            400 
.................... // when target_RPM = 0, we are in a braking mode 
....................  
.................... #define PERIOD_5RPM        4608 
....................  
.................... #define SHUT_DEL_DEF       30 
.................... // default shutdown delay to ensure that all motes get broadcast msg: 30 sec 
.................... // also used to ensure that manager acknowledges errors and first_msg in a  
.................... //  timely manner (else there will be a repeat 
.................... #define REPEAT_LIMIT       4 
.................... // number of times that an unsolicited msg will repeat waiting for an 
.................... //  ACK from the manager. 
....................  
.................... #define STARTUP_DELAY      4 
.................... // delay in units of 1/4 sec at startup before opening valve for 
.................... //  first time 
....................  
.................... #define RSSI_MIN           -64 
.................... // -64 dBm; minimum rssi of an advertising message required 
.................... //   for that network to be a viable net to join 
.................... // BRIAN, this value may be TOO SENSITIVE 
.................... #define LISTEN_TIME        20 
.................... // number of seconds to dwell in promiscuous hi-power listen mode 
.................... //  in search of networks to join when mote has been cold-booted 
.................... // MUST be 1-27 -- 15s is occassionally too short a time 
.................... #define LISTEN_T1          65536 - LISTEN_TIME*2400 
.................... // 76.8KHz clock (19.2KHz counting up at timer1 div8.... 
....................  
....................  
.................... #define TIMER2_SETUP_XTAL        T2_DIV_BY_4, 199, 8 
.................... // for 3.6864MHz xtal, this is the value used in setup_timer_2  
.................... // to achieve 1152Hz PWM frequency (for braking purposes) 
.................... // AND interrupt rate (used for valve algorithms) of 144Hz 
.................... //  (check valve current approx once every 7msec) 
.................... // Increments "RTC" by 7 when keeping track of time (about 0.8% fast!) 
.................... #define FAST_CLK  0 
.................... #define FAST_MS   7 
....................  
.................... #define TIMER2_SETUP_250K        T2_DIV_BY_1, 199, 16 
.................... // for 250KHz internal clock, this is the value used in setup_timer_2  
.................... // to achieve 312.5KHz PWM frequency (for braking purposes) 
.................... // AND interrupt rate of ~104Hz 
.................... // Increments "RTC" by 51 when keeping track of time (about 0.4% slow if  
.................... //    250KHZ internal clock is accurate, which it is not) 
.................... #define MED_CLK   1 
.................... #define MED_MS    51 
....................  
.................... #define TIMER2_SETUP_31K         T1_DIV_BY_1, 199, 4 
.................... // for 31KHz LFINTOSC (inaccurate), this is value used in setup_timner_2 
.................... // to achieve interrupt rate of 9.7Hz (103msec) 
.................... // Not meant to be accurate, no need for variable braking when running at 31KHz 
.................... #define SLOW_CLK  2 
.................... #define SLOW_MS   103 
....................  
.................... //#define TIMER3_CCP2_SETUP       T3_DIV_BY_8 | T3_CCP2 | T3_INTERNAL 
.................... #define TIMER3_CCP2_SETUP       T3_DIV_BY_8 | T3_INTERNAL 
.................... //  This is the value used by setup_timer_3 in order to monitor real time 
.................... //   and to provide a time reference (CCP_2) for measurement of sprinkler RPM. 
.................... // 3.6864MHz div4 div8 = 57.6KHz 
.................... //*****NOTE THIS IS AN ISSUE WITH 3.6864MHz clock 
....................  
.................... #define TIMER3_AD_SETUP           
.................... //  This is the value used by setup_timer_3 in order to automatically 
.................... //   have the ADC monitor the valve current during the initial closure 
.................... //   of the valve. 
.................... //  1.832MHz clock here.  Checks ADC  
....................  
.................... #define CCP1_BRK  CCP_PWM_H_H | CCP_PULSE_STEERING_A | CCP_PULSE_STEERING_SYNC 
.................... //  This is the value used by setup_ccp1 in order to enable PWM-controlled  
.................... //   braking 
.................... #define CCP1_CHG  CCP_PWM_H_H | CCP_PULSE_STEERING_D | CCP_PULSE_STEERING_SYNC 
.................... //  This is value used by setup_cc1 in order to enable PWM-controlled 
.................... //   charging level 
.................... #define CCP1_BOTHn (CCP_PWM_H_H | CCP_PULSE_STEERING_A | CCP_PULSE_STEERING_D | CCP_PULSE_STEERING_SYNC) 
.................... //  This value is sued during transitions to/from full battery situation 
.................... //   CCP_BOTHn provides for charge enable pulse and braking pulsing IN PHASE 
.................... #define CCP1_BOTHi (CCP_PWM_H_L | CCP_PULSE_STEERING_A | CCP_PULSE_STEERING_D | CCP_PULSE_STEERING_SYNC) 
.................... //  CCP_BOTHi provides for charge enable pulse and braking pulsing OUT OF PHASE 
....................  
.................... #define IDLE_LOOP_31       T2_DIV_BY_16,160,1 
.................... // setup for timer2 determines length of lo-power sleeping between 
.................... //  mote message checks -- basically and roughly times the idle loop 
.................... // 31KHz clock, T2 div 16, 160 counts -> 3Hz 
.................... //  thus overflow in about 330 msec 
.................... // For calculating battery check and time check and rejoin timeout, 
.................... //  we assume that each idle loop takes ~400msec.  Longer than 330 because 
.................... //  because of the execution of the steps after timer2 
.................... //  wakes us up and before we go back into idle_sleep.  [150 loops per minute] 
.................... // And note that LFINTOSC is a +/-10% (or so) oscillator, so idle timing 
.................... //  is rough. 
....................  
.................... /* 
.................... #define IDLE_LOOP_76       T2_DIV_BY_16,197,2 
.................... // setup for timer 2 determines length of sleeping between mote 
.................... //  message checks while idling 
.................... // With 76.8KHz clock, timer increments every 833.3usec;  
.................... //  overflows every 198*.833msec = 165msec; interrupts every 330msec 
.................... // (see idle_sleep routine) 
.................... #define IDLE_LOOPS_PERMIN   182 
.................... // This number based on discussion above; change IDLE_LOOP_76 and 
.................... //  IDLE_LOOPS_PERMIN together 
.................... //#define TIMECHK_IDLELOOPS  25 
....................  
.................... #define TIMECHK_IDLEMINS   300 
.................... // DEBUG SETTING FOR TEST: 5 hours.... 
.................... #define TIMECHK_IDLELOOPS  TIMECHK_IDLEMINS*IDLE_LOOPS_PERMIN 
.................... // This amounts to checking network time once every 10 mins. 
....................  
.................... #define TIMCHK_INTERVAL    3600 
.................... // number of seconds between timechecks when knowtime_fl = TRUE 
.................... #define BATCHK_INTERVAL    900 
.................... // number of seconds between battery checks! 
.................... #define BATCHK_MARCH       840 
.................... // what this means is that when there is a marching order change 
.................... //  we preset the batchk_timer to this value... 
.................... // Thus 60 seconds after the valve has been adjusted, we THEN 
.................... //  check battery health (which could lead to a charging on or off  
.................... //  transition..... 
....................  
.................... #define MAX_JOINTIME       1800 
.................... // SHOULD BE ABOUT 1/2 hour or 1800 secs!!!!!! 
.................... // seconds to wait for a join to happen 
.................... ///  even at 1/2 hr, MAY BE TOO SHORT for a full 500 count mesh! 
....................  
.................... #define JOIN_MINSMAX       30 
.................... // Number of minutes that we wait for mote to become operational after  
.................... //  the first join; then we say goodnight 
....................  
.................... #define FIRSTDANCE_INTERVAL   120 
.................... // retry the MSG_IDENTIFIER if no acknowledge within this interval 
....................  
.................... #define REJOIN_INTERVAL       1800 
.................... // number of seconds after which we give up on rejoining! 
.................... */ 
.................... /* 
.................... #define RUN_LOOPS_PERMIN   120 
.................... // assume we are consistently at 500msec per loop 
....................  
.................... #define REJOIN_TIMEOUT     1800 
.................... // number of seconds at which we decide to GIVE up on rejoining! 
.................... #define TIMECHK_RUNSECS    3600 
.................... // check net time every hour 
.................... #define BATCHK_RUNSECS     3600 
.................... // check battery at least every hour 
.................... #define REJOIN_RUNSECS     1800 
.................... // cannot join if have attempted for more than 1/2 hour 
.................... #define REJOIN_DISP_LIM    REJOIN_RUNSECS - 3 
.................... // display REJOIN message during run for 3 seconds after rejoin is 
.................... //  initiated 
....................  
....................  
.................... #define  _ACTIVE_MIN   102 
.................... // if Vdd is 3.3V, this represents .33 volt at the generator 
....................  
.................... #define OPER_BCHK_INTVL    36600 
....................    // check the battery level every OPER_BCHK_INTVL tmr2 interrupts 
....................    //  during operation; 36600 for once every 10 minutes 
....................  
.................... #define FSLEEP_DEL   2 
....................    // wait this number of seconds after receipt of force_warm or force_sleep 
....................    //  manager commands before acting... allows time for ACK 
.................... */ 
....................  
.................... /* 
....................  
.................... #define NO_BRK             0 
.................... #define MAX_BRK            400 
.................... // MAX_BRK for absolute minimum speed 
....................     
.................... // min and max charging aggressiveness values (PWM)    
.................... #define MIN_CHGAGGR        0 
.................... #define MAX_CHGAGGR        400 
....................  
.................... #DEFINE MAX_CHGDUTY        0x320 
....................  
.................... #define MIN_PWM            0 
.................... #define MAX_PWM            400 
....................   
....................  
.................... #define FLAGS1_BNOCH       0x00 
.................... // no charge during BRK control as requested by operator 
....................  
.................... #define FLAGS1_NOFLO       0x01 
....................  
.................... #define FLAGS1_MANRPM      0x02 
.................... // manual set of MPPC (0x0 00-0x1FF), RPM CONTROL 
.................... #define FLAGS1_RPMOLD      0x03 
.................... // old table lookup for RPM control 
....................  
.................... // new adaptive algorith 
.................... #define FLAGS1_DYNLO       0x04 
.................... // most aggressive charging, PWM control of brake 
.................... #define FLAGS1_DYNMID      0x05 
.................... // variable MPPC 0-FF, no brake 
.................... #define FLAGS1_DYNHI       0x06 
.................... // variable PWM control of EN_3105, MPPC = 0xFF, no  brake 
....................  
.................... #define FLAGS1_RNOCH       0x07 
.................... // no charge during RPM control as requested by operator 
....................  
.................... #define FLAGS1_TRANS2F     0x08 
.................... #define FLAGS1_TRANS2N     0x09 
.................... // 08:09 for transitioning states to smooth out battery full situations while 
.................... //  dynamically charging  
....................  
.................... #define FLAGS1_MANBRK      0x0A 
.................... // manual set of MPPC (0x000-0x1FF), NO RPM CONTROL 
.................... #define FLAGS1_BRKOLD      0x0B 
.................... // old formula calc for BRK control 
....................  
.................... #define FLAGS1_MAXCHG      0x0C 
.................... // defined max charging state 
....................  
.................... #define FLAGS1_FREE        0x0D 
.................... // defined state for free spin 
....................  
.................... #define FLAGS1_MANPWM      0x0E 
.................... // manual setting of MPPC and PWM control of 3105 enable 
....................  
.................... #define FLAGS1_DYNFULL     0x0F 
.................... // no charge during BRK control as requested by operator 
....................  
....................    
.................... //#define FLAGS_READY        0x00 
....................  
.................... #define VOPEN_FULL         0x8000 
.................... // Valve to max open 
.................... #define VCLOSE_FULL        0 
.................... #define VUNKNOWN           0xFFFF 
....................  
.................... // RPM increases as cur_MPPC goes from 0 to FF 
.................... #define MPPC_MAX           0x01FF 
.................... #define MPPC_DYNMAX        0xFF 
.................... // value of MPPC during dynamic control mode at which we shift into 
.................... //  hi speed mode wherein we duty cycle modulate the charging circuit! 
.................... #define MPPC_MIN           0x00a 
.................... #define MPPC_ADDCHG        0x0D1 
.................... // This may need to be adjusted if we change the manner in which MPPC is set 
.................... //  during braking. See prep_4_brake reoutine 
....................  
.................... #define MPPC_DUTYLIM       0x320 
....................    // 0x320 = 800 
....................    // maximum duty cycle for charger (special modes) 
....................     
.................... //#define MPPC_CHGOFF        0x1FF 
.................... // What should MPPC be set to when charging is NOT happening?  Does it matter? 
....................  
.................... #define MPPC_DYNCHG    0x0FF 
.................... // This is the default STARTING POINT for the MPPC setpt during dynamic 
.................... //  charging control 
.................... #define MPPC_STEP2F     1 
.................... // This is the MPPC value step change which takes place during transitions 
.................... // from _DYNMID to full battery situation 
.................... #define MPPC_STEP2N     1 
.................... // This is the MPPC value step change which takes place during transitions 
.................... // from full battery situation to Dynamic charging situation 
....................  
.................... #define TRANS_PERSTEP   1 
.................... // This is the target period value step change which takes place during  
.................... // transitions from _DYNMID to full battery situation 
.................... #define TRANS_PWMSTEP   8 
.................... // This is the step change for the PWM when routed to the charger and while 
.................... //  transitioning from _DYNHI to full battery situation 
....................  
.................... #define CHRGING_THRESH     0x0011 
....................    // A/D counts difference between UNLOADED and LOADED Vchg measurement 
....................    // indicates whether or not we are (significantly) charging the battery now. 
....................    // We compare this value to (VchgU-VchgL) where this is in units of ADC 
....................    //  counts -- at 3mV per count, 50mv would be a CHRGING_THRESH of ~17. 
....................  
.................... #define NOSPIN_LIMIT       16 
....................    // Number of ~half-seconds of low or no rotation that must occur in order to 
....................    //  show the nospin display and alert the manager 
....................  
.................... #define NUM_4_STAT         64 
....................    // This is number of rpm measurements to process prior to determination of 
....................    //  AveRPM and Max/Min (~30sec interval) 
....................    // Also signals reporting to the manager 
.................... #define SHIFT_4_STAT       5 
....................    // This is intead of dividing by NUM_4_STAT; change these two values 
....................    //  together 
....................  
.................... #define TEN_MIN            600 
....................    // This is the number of seconds in ten minutes; used to time mandatory 
....................    //  battery checks 
....................  
.................... // defines for prechg_opt 
.................... // TIME or Alternative (voltage-based?) Algorithm utiling regulated RPM 
.................... #define PRECHG_TIME_RPM    0x00 
....................  
....................  
.................... // defines for msg_id (Manager->Mote Payload message ID to Micro) 
.................... #define MSG_FULL              0x01 
.................... #define MSG_WATER_ON          0x02 
.................... #define MSG_WATER_OFF         0x03 
....................    
.................... #define MSG_FORCE_WARM        0x06 
....................  
.................... #define MSG_SHUT_DEL_RD       0x0E 
.................... #define MSG_SHUT_DEL_WR       0x0F 
....................  
.................... #define MSG_FIRMWARE_RD       0x24 
....................  
.................... #define MSG_FORCE_TIME        0x29 
....................  
.................... #define MSG_FORCE_COLD_DEL    0x2B 
.................... #define MSG_FORCE_COLD        0x2C 
....................  
.................... #define MSG_FORCE_REJOIN_DEL  0x2E 
.................... #define MSG_FORCE_REJOIN      0x2F 
....................  
.................... #define MSG_MGR_ACK           0x30 
.................... #define MSG_MGR_NACK          0x31 
....................  
.................... #define MSG_SP_NUM_WR         0x44 
....................  
.................... #define MSG_DEFINE_TEST       0x49 
.................... #define MSG_MARCH1            0x50 
.................... // for IMMEDIATE or future MARCHING ORDER, closed loop RPM, timed valve 
.................... #define MSG_MARCH2            0x51 
.................... // for IMMEDIATE or future MARCHING ORDER, closed RPM and FLOW 
.................... #define MSG_READY             0x52 
.................... #define MSG_TEST              0x53 
.................... #define MSG_DEMO              0x54 
.................... // for immediate open loop setting of valve, brake, charger, etc. 
....................  
.................... #define MSG_REPORT_VALVE      0x59 
....................  
.................... #define MSG_SLEEPNOW          0x5B 
.................... #define MSG_SHUTDOWNC_DEL     0x5C 
.................... #define MSG_SHUTDOWNC         0x5D 
.................... #define MSG_SHUTDOWNO_DEL     0x5E 
.................... #define MSG_SHUTDOWNO         0x5F 
....................  
.................... #define MSG_HEALTH            0x60 
.................... #define MSG_CAL_VALVE         0x61 
.................... // short form of MSG_STD solicited by manager to get LOCATION, STATE, ERRORS 
....................  
.................... // defines for msg_id (Micro to Mote) 
.................... #define MSG_ACK            0x80 
.................... #define MSG_NACK           0x81 
.................... #define MSG_ERROR          0x82 
.................... #define MSG_MICRO_RESPONSE 0x83 
.................... #define MSG_FIRST          0x84 
.................... #define MSG_VCAL           0x85 
....................  
.................... // defines for various unsolicited messages 
.................... #define BATTERRb           7 
.................... //Indicates to LV program that the startup was 
.................... //  rocky due to a DEAD BATTERY! (bit7 set) 
.................... #define LOSPINb            6 
.................... // Indicates to LV program that the freespin speed measured during the  
.................... //  opening dance was less than FREESPIN_MIN (bit6 set) 
.................... #define OCDIFFb            5 
.................... // Indicates to LV program that the 1st open time and the 1st close 
.................... //  time differ by greater than 25% (bit5 set) 
.................... #define REJOINEDb          4 
.................... // Indicates that a rejoin occurred 
....................  
.................... // Note 3:2 carry information about 1st valve open 
.................... // and  1:0 carry information about 1st valve close 
.................... // as follows: 0b00   OK 
.................... //             0b01   timeout 
.................... //             0b10   TOO SHORT of a duration for valve motion 
.................... #define OPENSHORTb         3 
.................... #define OPENLONGb          2 
.................... #define CLOSESHORTb        1 
.................... #define CLOSELONGb         0 
....................  
.................... // defines for error codes as communicated to manager 
.................... #define NO_ERRCODE         0x00 
.................... #define BATOK_ERRCODE      0x03 
....................  
.................... #define FRC_SLEEP_ERRCODE  0x05 
.................... // manager forces system into a sleep state and decommissions the mote 
....................  
.................... #define LOC_ERRCODE        0x21 
.................... #define CPASSOC_ERRCODE    0x22 
.................... #define LOC_CP_ERRCODE     0x23 
....................  
.................... #define ADDCHG_WARNCODE    0x80 
.................... //#define LOWBAT_ERRCODE     0x80 
.................... #define PS_ERRCODE         0x81 
....................          // Vdd too high 
.................... #define WEAKBAT_WARNCODE   0x82 
.................... #define DEADBAT_ERRCODE    0x83 
....................  
.................... // defines for state variable 
.................... #define  DEV_INIT          0x00 
.................... #define  DEV_JOINING       0x01 
.................... #define  DEV_1STEXCH       0x02 
.................... #define  DEV_READY         0x03 
.................... #define  DEV_RUN           0x04 
.................... #define  DEV_PAUSED        0x05 
.................... #define  DEV_IDLE          0x06 
.................... #define  DEV_SLEEP         0x07 
.................... #define  DEV_TEST          0x08 
.................... #define  DEV_DEMO          0x09 
....................  
.................... // defines for vlv_state variable 
.................... #define  VLV_COASTING   0x00 
.................... #define  VLV_CLOSING    0x01 
.................... #define  VLV_OPENING    0x02 
.................... #define  VLV_BRAKING    0x03 
....................  
.................... #define  TYPE_NOXDCR    0x01 
.................... #define  TYPE_XDCR      0x02 
....................  
.................... // defines for sys_state variable 
.................... // F009+ 
.................... // 7:4 - major state indicator 
.................... // 3:0 - minor state indicator 
.................... //       .3 = joining_fl (also set if rejoining fails) 
.................... //       .2 = rejoining_fl 
.................... //       .1 = chgenab_fl 
.................... //       .0 = ctrlRPM_fl 
.................... #define INIT_STATE               0x00 
....................    // OR with joining_fl when established 
....................    // always leads to OPEN1_STATE; 
....................    // NEVER accepts packets (NACK), even if joined 
.................... #define LSTATE_INIT              0x00 
....................  
.................... #define OPEN1_STATE              0x10 
....................    // OR with joining_fl when established 
....................    // always leads to PRECHG_STATE; 
....................    // always from INIT_STATE; 
....................    // May process report commands. 
....................    // [Vmmmm:ss OPENING] countup display 
.................... #define LSTATE_OPEN1   0x01 
....................  
.................... #define PRECHG_STATE             0x22 
....................    // OR with joining_fl when established 
....................    // always leads to CLOSE_STATE; may be in and out quickly if no 
....................    //  precharging is necessary; 
....................    // always from OPEN1_STATE; 
....................    // May process report commands.. 
....................    // [Pmmmm:ss        ] countdown display 
.................... #define LSTATE_PRECHG   0x02 
....................  
.................... #define CLOSE1_STATE             0x32 
....................    // OR with joining_fl when established 
....................    // always leads to JOINING_STATE or READY_STATE; 
....................    // always from PRECHG_STATE; 
....................    // May process report commands. 
....................    // [Vmmmm:ss CLOSING] countup display 
.................... #define LSTATE_CLOSE1   0x03 
....................  
.................... #define JOINING_STATE            0x44 
....................    // always leads to READY_STATE 
....................    // always from CLOSE1_STATE 
....................    // Bypassed if warm start 
....................    // Cannot hear commands. 
....................    // [Jmmmm:ss  moteid] display 
.................... #define LSTATE_JOIN     0x04 
....................  
.................... #define REJOINING_STATE          0x48 
....................    // Leads to READY_ if rejoin is successful 
....................    //  or JFAIL_ if rejoin is unsuccessful 
....................    //  or ADDCHG_ if needed. 
....................    // Drops into this state when we are rejoining 
....................    //  AND there is no pending marching order 
....................    //  Preceeding state READY_ or  
....................    //   short-lived READY_ after completion of marching orders. 
....................    // [Rmmmm:ss  moteid] countup display 
....................    // Cannot hear commands. 
....................    // THINK ABOUT THIS 
....................  
.................... #define DISRUPT1_STATE           0x50 
.................... #define LSTATE_DIS1     0x05 
.................... #define DISRUPT2_STATE           0x60 
.................... #define LSTATE_DIS2     0x06 
.................... #define DISRUPT3_STATE           0x70 
.................... #define LSTATE_DIS3     0x07 
....................  
.................... #define READY_STATE              0x80 
....................    // leads to OPENING_STATE or VADJ_STATE 
....................    //  or to DISRUPT STATE; 
....................    // valve is closed in READY_STATE; 
....................    // from CLOSE1_STATE or or CLOSING_STATE 
....................    // Processes all commands 
....................    // ['yy:ddd:hh:mm:ss] display 
.................... #define LSTATE_READY    0x08 
....................  
.................... #define JFAIL_STATE              0x8C 
....................    // Eventually leads to shutdown of sprinkler 
....................    // Indicates cannot join and we have given up AND all marching orders 
....................    //  have completed 
....................    // Drops into this state from REJOINING_STATE 
....................    // Cannot hear commands. 
....................    // ['yy:ddd:hh:mm:ss] display 
.................... #define LSTATE_JFAIL    0x10 
.................... // band-aid 
....................     
.................... #define OPENING_STATE            0x90 
....................    // OR with rejoining_fl (and joining_fl if failure to join) 
....................    // May be brief if at open-valve end-stop; 
....................    // Leads to either BRK_ or RPM_ or ADDCHG_; 
....................    // From BRK_STATE or RPM_STATE or READY_STATE or PAUSE_STATE or REJOINING_ 
....................    // May process report, param and march commands. 
....................    // [Vmmmm:ss OPENING] countup display 
.................... #define LSTATE_OPENING  0x09 
....................  
.................... #define CLOSING_STATE            0xB2 
....................    // OR with rejoining_fl (and joining_fl if failure to join) 
....................    // May be brief if at close-valve end-stop; 
....................    // Leads to either READY_, PAUSE_. 
....................    // From BRK_STATE or RPM_STATE. 
....................    // May process report, param and march commands. 
....................    // [Vmmmm:ss CLOSING] countup display 
.................... #define LSTATE_CLOSING  0x0B 
....................  
.................... #define VADJ_STATE               0xC0 
....................    // OR with rejoining_fl (and joining_fl if failure to join) 
....................    // May be brief if valve DOES NOT NEED adjustment; 
....................    // Leads to either BRK_STATE or RPM_STATE; 
....................    // From BRK_STATE or RPM_STATE or READY_STATE or PAUSE_STATE 
....................    // May process report, param and march commands. 
....................    // [Vmmmm:ss rrr!RRR] countup display shows current rpm ! desired RPM 
.................... #define LSTATE_VADJ     0x0C 
....................  
.................... #define PAUSE_STATE              0xD0 
....................    // OR with rejoining_fl (and joining_fl if failure to join) 
....................    // Leads to READY_ or OPENING_ or VADJ_ 
....................    // From READY_ or CLOSING_ 
....................    //  (CLOSING_ may have followed BRK_ or RPM_) 
....................    // May process report, param and march commands. 
....................    // either [ mmmm:ss  NOFLOW] countup display  
....................    //     or [Xmmmm:ss  NOFLOW] countdown display if pending order  
.................... #define LSTATE_PAUSE    0x0D 
....................  
.................... #define BRK_STATE                0xE0 
....................    // OR with rejoining_fl (and joining_fl if failure to join) 
....................    //  and OR with chgenab_fl 
....................    // Leads to CLOSING_ or OPENING_ or VADJ_ or READY_; 
....................    // From VADJ_ or OPENING_ 
....................    // May process report, param and march commands. 
....................    // either [ mmmm:ss rrrBbbb] countup display (current RPM B brake force) 
....................    //     or [Xmmmm:ss rrrBbbb] countdown display if pending order   
.................... #define LSTATE_BRK      0x0E 
....................  
.................... #define RPM_STATE       0xF1 
....................    // OR with rejoining_fl (and joining_fl if failure to join) 
....................    //  and OR with chgenab_fl 
....................    // leads to CLOSING_ or OPENING_ or VADJ_ or READY_; 
....................    // from VADJ_STATE or OPENING_STATE 
....................    // May process report, param and march commands. 
....................    // either [ mmmm:ss rrr*RRR] countup display (current RPM / desired RPM) 
....................    //     or [Xmmmm:ss rrr*RRR] countdown display if pending order  
.................... #define LSTATE_RPM      0x0F 
....................  
.................... #define JOIN_MASK       0x0C 
.................... // AND with sys_state to extract both fl_joining and fl_rejoining bits 
.................... #define STATE_MASK      0xF3 
.................... // AND with sys_state to clear both fl_joining and fl_rejoining bits 
.................... #define RPM_CH_MASK     0x03 
.................... // AND with sys_state to extract RPM control bit (0) and charging bit (1) 
....................  
....................  
.................... #define FREESPIN_MIN       60 
.................... // If freespin measured at startup is less than FREESPIN_MIN, then  
.................... //  manager will be informed when UNSOLICITED message is sent 
.................... // See above regarding MSG_UNSOLICITED defines. 
....................  
.................... #define START_BRK          600 
....................    // Some intermediate braking at cold start perior to beginning of precharge 
.................... #define IDLE_BRK           200 
....................    // This is the braking force we apply during idling.... mostly important 
....................    //  for debugging purposes 
....................  
....................  
.................... // IFDEF WARNER we are using Eric's valve 
.................... // otherwise we are using Jake's test fixture 
.................... //#IFDEF   WARNER 
.................... //#define VALVE_STOP         990 
.................... //#ELSE 
.................... //#define VALVE_STOP         960 
.................... //#ENDIF 
....................  
.................... #define VCURLIM            900 
.................... // guess during new board debug Feb 18 2016 
....................  
.................... #define VALVE_STOP_W       990 
.................... #define VALVE_STOP_J       960 
....................    // This is the number of ADC counts below which we assume 
....................    //  the valve motor has hit a stop.  NOTE hardware has a .25 ohm  
....................    //  resistor to Vbat 
....................    // This value will depend on valve drive motor characteristics 
....................    //  *J for test bench; *W for Warner valve 
.................... */ 
.................... //************************************************************************** 
.................... /*    
....................    Experimentation with prototype valves during March/April 2015 brought up 
....................    problems with valve becoming STUCK at an endstop. 
....................    Solutions include:  
....................       1. DO NOT CHECK for excessive current during first few 
....................       nudges when COMING off an endstop 
....................       2. Once valve is moving along (past the initial nudge which overcomes 
....................       inertia) we can check for excessive current sooner in the nudge cycle 
....................    Care must be taken to accomodate various situations which could interfere 
....................       with this approach, such as when nudging is interrupted by the need to 
....................       acknowledge activity at the mote.    
....................   
....................   VALVE_CHKDEL0 is the time in ms to wait after the drive motor is 
....................   turned on before checking if we have excessive current as part of the 
....................   very first nudge which specifically overcomes the startup current 
....................   transient due to inertia 
....................  
....................  VALVE_CHKDEL0 will be dependent upon whether we are using the "WARNER" 
....................   valves or the in-house test fixture   
....................   
....................  VALVE_CHKDEL1 is the normal time in ms to wait after the drive motor is 
....................   turned on before checking if we have excessive current.  The assumption 
....................   for the choice of this value is that we have already overcome the startup 
....................   current transient due to inertia 
....................  
....................  VALVE_CHKNO is the number of nudges during which we DO NOT check for 
....................   excessive current in the case where the valve is specially coming off 
....................   of either the closed or open end stop 
....................  
....................  
....................  Flags specify the situation at hand: 
....................  atstop_fl     TRUE if we are currently at an endstop, this flag 
....................                ensures that the algorithm utilizes VALVE_CHKNO 
....................                 
....................  firstnudge_fl TRUE if we are starting the valve from rest and we are NOT 
....................                at an endstop; ensures that the algorithm utilizes VALVE_CHKDEL1 
....................                 
.................... EXCEPTION and possible issue in the future is the first nudge after  
.................... system startup.  We may or MAY NOT be at an endstop.  So we assume a 
.................... atstop_fl = TRUE.   
....................  
.................... If we are actually FULL OPEN, and get stuck (!) we can 
.................... detect this because the number of steps during initial open will be too few 
.................... (less than 2 or 3) and then we can try again with the atstop_fl set. 
....................  
.................... If we are actually at FULL CLOSED, and get stuck, again the first opening will 
.................... be too few steps and we must then try again with the atstop_fl set..... 
....................  
.................... Thus if after the startup dance, either close_time or open_time are  
.................... "unreasonable", we must simply do it again (although perhaps we could skip 
.................... the precharge if we have a good free-spin value).  This will be optimized 
.................... in a later version of the firmware.  
....................  
.................... condx                      atstop_fl      firstnudge_fl 
.................... ---------------------------------------------------- 
.................... 1st nudge after startup    TRUE           TRUE 
.................... (valve position unknown) 
.................... 1st nudge from endstop     TRUE           FALSE 
.................... 1st nudge norm             FALSE          TRUE 
.................... (or immediately after motion is interrupted by activity from mote) 
.................... subsequence nudges         FALSE          FALSE 
.................... */ 
.................... //*************************************************************************** 
....................  
.................... /* 
....................  
.................... //#define  VALVE_CHKNO       3 
.................... #define VALVE_NOCHK_W     3 
.................... #define VALVE_NOCHK_J     1 
....................  
.................... //#IFDEF   WARNER 
.................... //#define VALVE_ONTIME       150 
.................... //#define VALVE_CHKDEL0      100 
.................... //#ELSE 
.................... //#define VALVE_ONTIME       100 
.................... //#define VALVE_CHKDEL0      50 
.................... //#ENDIF 
....................  
.................... // These values are in milliseconds 
.................... #define VALVE_ONTIME_W     150 
.................... #define VALVE_CHK0_W       100 
.................... #define VALVE_ONTIME_J     100 
.................... #define VALVE_CHK0_J       50 
....................  
.................... // assume 16 bit counter triggered by FOSC div 64 (timer 0 prescaler) 
.................... // Thus one count every 64*T0_OSC nanoseconds 
.................... // Setup timer 0 for div64 and load with the value below for it to time out                         
....................  
.................... #define VALVE_TMR0SET0_W     (65536 - (1000000*(VALVE_ONTIME_W - VALVE_CHK0_W)+32*T0_OSC)/(64*T0_OSC)) 
.................... #define VALVE_TMR0SET0_J     (65536 - (1000000*(VALVE_ONTIME_J - VALVE_CHK0_J)+32*T0_OSC)/(64*T0_OSC)) 
.................... // THUS: if we delay CHK_DEL0 milliseconds, and then set a timer to timeout 
.................... //  according to VALVE_TMR0SET0, we have taken up a full CHUNK's worth of time 
....................  
.................... // once valve is in motion, only wait 20 msec before testing for endstop! 
.................... //  This is arbitrary and conservative. 
.................... #define VALVE_CHKDEL1      20 
.................... #define VALVE_TMR0SET1_W   (65536 - (1000000*(VALVE_ONTIME_W - VALVE_CHKDEL1)+32*T0_OSC)/(64*T0_OSC)) 
.................... #define VALVE_TMR0SET1_J   (65536 - (1000000*(VALVE_ONTIME_J - VALVE_CHKDEL1)+32*T0_OSC)/(64*T0_OSC)) 
.................... // THUS: if we delay CHK_DEL1 milliseconds, and then set a timer to timeout 
.................... //  according to VALVE_TMR0SET1, we have taken up a full CHUNK's worth of time 
....................  
....................    // VALVE_ONTIME is the number of milliseconds that the motor runs between 
....................    //  activity on mote checks 
....................    // VALVE_CHKDEL0 is the number of milliseconds we wait when motor is 
....................    //  first turned on to check for an endstop.  This accounts for the 
....................    //  inertial transient at first turn-on. 
....................     
.................... #define VALVE_ATSTOPDEL    50 
....................  
....................  
.................... #define VALVE_TIM0         (VALVE_ONTIME-VALVE_CHKDEL0) 
.................... // Set TMR0 to overflow after this number of millisecondes 
.................... //  Note that each tick of TMR0 during the move_valve routine is 
.................... //  32/19200 or 1.666 msec or 1667 microseconds 
.................... //  This convenient number is represented by the fraction 3/5 in the  
.................... //   define below 
.................... #define VALVE_TMR0SET0     256 - ((VALVE_TIM0*3)/5)  
.................... // THUS: if we delay CHK_DEL0 milliseconds, and then set a timer to timeout 
.................... //  according to VALVE_TMR0SET0, we have taken up a full CHUNK's worth of time 
....................   
....................  
....................  
....................  
.................... //#IFDEF   WARNER 
.................... //#define VCTR_LIMIT         200 
.................... //#ELSE 
.................... //#define VCTR_LIMIT         175 
.................... //#ENDIF 
....................  
.................... #define VALVE_CTRLIM_W       200 
.................... #define VALVE_CTRLIM_J       175 
.................... // little motions of valve motor should definitely get it to a stop 
.................... //  or to its destination;  if not we time out.  This number is somewhat 
.................... //  arbitrary 
....................  
.................... #define VCLASS2_LIM        38      
.................... // relative to 0 (full close) and 255 (full open) at what limit for  
.................... //  valve desired do we force bouncing off the nearest enstop? 
.................... // 15% would be 38 
.................... #define BOUNCE_OPEN        256-VCLASS2_LIM 
.................... #define BOUNCE_CLOSE       VCLASS2_LIM 
.................... #define V_ENDCTR_LIM       5 
.................... // force an endstop at least every 5 excursions 
....................  
....................  
.................... //#IFDEF   WARNER 
.................... //#define V_SINCEEND_LIM     400  
.................... //#ELSE 
.................... //#define V_SINCEEND_LIM     350 
.................... //#ENDIF 
.................... // force an endstop if cumulative motion has exceeded about 2 full paths 
.................... //  from open to closed 
.................... #define VALVE_SINCELIM_W   400 
.................... #define VALVE_SINCELIM_J   350 
....................  
....................  
.................... #define VFULL_TIM_LIM      7200 
.................... // if this number of seconds has passed since the full open2close or the 
.................... //  full close2open time has been remeasured, then force it. 
....................  
.................... // defines for vset_class variable 
.................... #define BOUNCE0_CL         0x01 
.................... #define BOUNCE0_OP         0x81 
.................... #define BOUNCE1_CL         0x02 
.................... #define BOUNCE1_OP         0x82 
.................... #define BOUNCE2_CL         0x03 
.................... #define BOUNCE2_OP         0x83 
.................... #define BOUNCE3_CL         0x04 
.................... #define BOUNCE3_OP         0x84 
....................  
.................... #define VTOOSHORT          60 
.................... // This is the minimum number of nudges for open to close or close to open 
.................... //  which is acceptable during startup dance.  If not VTOOSHORT, then 
.................... //  no problem is reported during first message after join 
.................... #define FREESPIN_LIM       120 
.................... // This is the minimum RPM which is 'acceptable' for free spin result! 
.................... // If not too slow, then no problem is reported during 
.................... //  first message after join 
....................  
.................... // EEPROM LOCATIONS 
.................... #define EE_ADDCHG_DUR      0x0002 
....................    // Configures add-charging time in seconds 
....................    // 2 bytes, low byte at 0x0002 
.................... #define ADDCHG_DUR_DEF     4 
....................    // 4 minutes? 
.................... #define EE_PRECHG_DUR      0x0004 
....................    // Configures precharging time in seconds 
....................    // 2 bytes, low byte at 0x0004 
.................... #define PRECHG_DUR_DEF     10 
....................    // 1.5 minutes?  
.................... #define CHGLOOPS_PER_MIN   110 
....................    // determined experimentally, each loop is about 545 msec 
....................    //  which is a bit longer than I would prefer (!), but oh well. 
....................    //  JG 2015 Jun16 
....................     
.................... // 0x00A thru 0x00F        reserved 
.................... #define EE_NETW_ID         0x0010 
....................    // 2 bytes, low byte at 0x0010; for now, network ID defaults to 0x04CD. 
.................... #define EE_PRENETW_ID      0x0012 
....................    // 2 bytes, low byte at 0x0012; for now, network ID defaults to 0x04CD. 
....................  
....................  
.................... // 0013 reserved 
.................... #define EE_LOCATION     0x0014 
....................    // 2 bytes, low byte at 0x0014; associates sprinkler with particular 
....................    //  physical location on CP 
.................... #define EE_PRELOCATION  0x0016 
....................    // 2 bytes, low byte at 0x0016, previous association of sprinkler with 
....................    //  particular physical location on CP 
....................  
....................    // 0x018 thru 0x01F     reserved 
....................  
.................... // IDLE behavior specified at 0x0020 thru 0x0033 
.................... #define EE_IDLE_OPT        0x0020 
....................    // Configures IDLE behavior.  Applies if battery low during operational 
....................    //  state 
....................    //  0x00  send out Panic Message once when panic level is reached according 
....................    //         to voltage-based algorithm 
....................    //  0x01  send out Panic Message once when panic level is reached according 
....................    //         to charge-based algorithm 
.................... #define MAX_IDLE_OPT       1 
....................    // If manager tries to write any idle_opt value larger than this to EEPROM 
....................    //  a NACK occurs; see above for idle option choices 
.................... #define LEN_IDLE_BLOCK     15 
....................    // There are 15 bytes in the idle block 
....................  
.................... #define EE_IDLE_PROFILE    0x0021 
....................    // Saved only upon entering IDLE state; 
....................    //  profile number which was running or had last been run. 
....................    // 0 for default profile, 1, 2, 3 for controller-specified profile choices 
....................    //  other numbers, use 0 
.................... #define EE_IDLE_STEP       0x0022 
....................    // Saved only upon entering IDLE state; 
....................    //  step number of profile which was running or had last been run. 
....................    //  Step 0xFF indicates that we were not within a profile 
....................    //  Step 0x10 thru 0xFE invalid. 
.................... #define EE_IDLE_STIME      0x0023 
....................    // 2 bytes, low byte at 0x0023, high byte at 0x0024 
....................    // Saved only upon entering IDLE state; 
....................    //  amount of time in seconds that rate was controlled according 
....................    //  to EE_IDLE_STEP at time when IDLE state entered; 
....................    //  set to 0x0000 if EE_IDLE_STEP=0xFF. 
.................... #define EE_IDLE_LOOP       0x0025 
....................    // 2 bytes, low byte at 0x0025, high byte at 0x0026 
....................    // Saved only upon entering IDLE state; 
....................    //  for looping profiles, loop number at time when IDLE state entered; 
....................    //  set to 0x0000 for non-looping profiles, set to 
....................    //  0x0000 if EE_IDLE_STEP=0xFF. (looping beyond 0xFFFF is recorded as 
....................    //  0xFFFF) 
.................... #define EE_IDLE_CHG        0x0027 
....................    // 2 bytes, low byte at 0x0027, high byte at 0x0028 
....................    // Configures used charge in millicoulombs for 
....................    //  charge-based shutdown method (TBD); applies if EE_IDLE.1 is set 
.................... #define EE_IDLE_SHDN_DLY   0x0029 
....................    // 2 bytes, low byte at 0x0029, high byte at 0x002A 
....................    // Configures time in units of 67 secs (TMR0 ints during IDLE) 
....................    //  between sensing of low battery and self-shutdown 
....................  
....................  
.................... // 0x02F thru 0x033        reserved 
....................  
.................... // PROFILE behavior specified at 0x0034 thru 0x003E 
.................... #define EE_PROFILE_OPT     0x0034 
....................    // Configures PROFILE behavior. 
....................    //  0x00 start profile0 (0x0050-0x007F) from the beginning 
....................    //  0x01 start profile1 (0x0090-0x00BF) from the beginning 
....................    //  0x02 start profile2 (0x00D0-0x00FF) from the beginning 
....................    //  0x03 start profile3 (0x0110-0x013F) from the beginning 
....................    //  0x04 start last used profile (EE_IDLE_PROFILE) from the beginning 
....................    //  0x05 start last used profile (EE_IDLE_PROFILE) from where it stopped 
.................... #define MAX_PROFILE_OPT    0x05 
....................    // profile option value cannot exceed this value 
....................  
....................  
.................... #define EE_SHUT_DEL        0x003E 
....................    // 2 bytes, low byte at 0x003E, high byte at 0x003F 
....................    // number of seconds between MSG_FORCE_COLD_DEL or MSG_SHUTDOWNx_DEL 
....................    //  and actual restart or shutdown 
....................    // For broadcast messages, ensures that all of the motes get the 
....................    //  message before they 'go away' 
....................  
.................... // GENERAL behavior specified at 0x0040 thru 0x004F 
.................... #define EE_GENERAL_OPT     0x0040 
....................    // Configures GENERAL behavior. 
....................    //  0x00 normal operation 
....................    //  0x01 test mode A (debug) 
....................    //  0x02 test mode B (time messages to DUST controller) 
....................    //  0x03 test mode C (debug and time messages) 
.................... #define MAX_GENERAL_OPT    0x03 
....................    // general option value cannot exceed this value 
....................  
.................... // 0x041 thru 0x04F        reserved 
....................  
.................... #define EE_REINFO          0x0050 
....................    // hold last known restart_cause 
....................  
.................... // 0x051 thru 0x05F        reserved 
....................  
.................... #define EE_DEADPROFILE     0x0060 
....................    // If death occurs during profiling, place profile number here (0,1,2,3) 
....................    //  else set to 0xFF 
.................... #define EE_DEADSTEP        0x0061 
....................    // Set to profile step number during which death occurred. 
.................... #define EE_DEADTIME        0x0062 
....................    // 2 bytes indicates how far along we were into the profile step when 
....................    //  dead battery was detected. 
.................... #define EE_DEADSTATE       0x0064 
....................    // system state during which dead battery was detected 
....................  
.................... // 0x065 thru 0x07F        reserved 
....................  
.................... #define EE_ERRORID         0x0080 
....................    // 2 bytes, low byte is the error_id and 
....................    //  high byte is errors1 -- saves last reason for a deep event error 
....................  
.................... #define EE_VSET_CLASS      0x0082 
.................... #define EE_V_ENDCTR        0x0083 
.................... #define EE_V_SINCEEND      0x0084 
.................... #define EE_O_C             0x0086 
.................... #define EE_C_O             0x0088 
....................  
.................... #define EE_RESTART_INFO    0x00A0 
.................... // 0x090 thru 0x0EF        reserved 
....................  
.................... #define EE_PROFILE0        0x00F0 
....................    // This is address of first byte of profile0 (default). 
....................    // May extend to 0x011F. 
....................    // 3 bytes per step, 16 steps.  Each step has 1 byte for RPM and 2 bytes 
....................    //  for duration in seconds.  If duration = 0x0000, then this means 
....................    //  "forever." 
....................    //  If 0x00 <= RPM <= RPM_MIN, then interpret RPM as RPM_MIN. 
....................    //  If RPM_MAX <= RPM <= 0xFF, then interpret RPM as RPM_MAX. 
....................    //  thus RPM = 0x00 and duration = 0xFFFF means single step rpm_min speed forever. 
....................    //  All bytes following duration = 0xFFFF in a profile are ignored. 
....................    //   RPM = 0xFF and duration = 0xFFFF is the end of profile marker for 
....................    //   "repeating" profiles".  0xFF / 0xFFFF cannot be the first step. 
....................    //  for steps preceeding duration = 0xFFFF, duration cannot = 0x0000! 
....................    //  Note that default profile is loaded into EEPROM by firmware 
....................    //   at start if none is present.  Controller can read or write 
....................    //   profiles. 
....................  
.................... // 0x120 thru 0x1EF        reserved 
....................  
.................... #define EE_VDD             0x1F0 
....................    // Two bytes; ADC-based estimate of Vdd (4.12 fixed pt format) 
.................... #define EE_VBATT           0x1F2 
....................    // Two bytes, ADC-based estimate of Vbatt 
.................... #define EE_VGEN            0x1F4 
....................    // Two bytes, ADC-based estimate of Vgen 
.................... #define EE_VSOLAR          0x1F6 
....................    // Two bytes, ADC-based estimate of Vsol 
....................  
....................  
.................... // SCRATCHPAD EEPROM 
....................  
.................... #define EE_DEBUG_1st       0x0200 
.................... #define EE_DEBUG_LAST      0x03F0 
....................  
.................... #define EE_FREE_1st        0x0200 
.................... #define EE_FREE_LAST       0x03BF      // free space never cleared 
.................... #define EE_SCRATCH_1ST     0x03F0 
.................... #define EE_SCRATCH_LAST    0x03F8      // scratch space cleared at start 
....................                                        //  (warm, cold, or xcold) 
....................    // This is the start and end of scrathpad memory in EEPROM.  To be used for 
....................    //  for debug purposes or TBD. 
....................  
.................... #define EE_BOOT_RECORD     0x0200      // new events and time 
.................... #define EE_NETID_TIME      0x0208 
.................... #define EE_MOTEOPER_TIME   0x020C 
.................... #define EE_MOTEIDLE_TIME   0x0210 
.................... #define EE_MSG_RECORD_0    0x0220 
.................... #define EE_MSG_RECORD_END  0x03BF 
....................  
.................... #define EE_SYS_STATE       0x03C0 
....................    // Address of state flags (echoes read only status) 
....................    // Written to EEPROM at significant state transitions 
.................... #define EE_INT_CTR         0x03E8 
....................    // Address of error/alarm flags (as many as 16 bytes) 
....................    // Written to EEPROM at significant state transitions 
.................... #define EE_CUR_PROFILE     0x03F0 
.................... #define EE_MSGBYTES_DBG    0x03F8 
.................... #define EE_PORTB_BIT       0x03F9 
.................... #define EE_PORTB_DIR       0x03FA 
....................  
....................  
....................     
....................  
....................    // for debug only 
....................  
.................... #define DUTYCYCLE_SET      0x40 
.................... // set join duty cycle for mote to this value at startup; approx 15% 
.................... #define SPECIALNV1_00      0x0000 
....................    // for rapid join time during debug, use with pkgen_setnv_special1(**) 
.................... #define SPECIALNV2_00      0x0005 
....................    // for rapid join time during debug, use with pkgen_setnv_special2(**) 
....................    // RAPID: 5 seconds to 0 seconds is a timing range having to do with 
....................    //  looking for advertisements during join 
....................    // NORMAL: 90 to 60 seconds..... 
.................... #define SPECIALNV1_01      0x003C 
....................    // for normal join time during debug, use with pkgen_setnv_special1(**) 
.................... #define SPECIALNV2_01      0x005A 
....................    // for normal join time during debug, use with pkgen_setnv_special2(**) 
....................  
.................... */ 
....................  
....................  
....................       /* signed int properties */ 
.................... #define INT_MAX 32767         /* signed integer minimum*/ 
.................... #define INT_MIN (-32768)      /*signed integer maximum*/ 
....................  
....................       /* signed long properties */ 
.................... #define LONG_MAX 2147483647        /* signed long maximum*/ 
.................... #define LONG_MIN (-2147483648) /* signed long minimum*/ 
....................  
.................... /* 
....................  
.................... // BELOW are constants and defines used in battery check routines 
....................  
.................... #define FVR_NOEE        2455 
.................... // approx 2V, any lower, don't attempt to run the micro or write to EE 
.................... //    fl_bat_NOEE 
.................... //    (BOX_CHAR here and below) 
....................  
.................... #define FVR_NODUST      2332 
.................... // 2.2 V; any lower, don't use the dust module; fl_batNODUST 
.................... //    ('D' here down to FVR_NOEE) 
....................  
.................... #define FVR_TEST        1819        
.................... // 2.7V threshold for testing purposes, display still visible 
....................  
.................... #define FVR_DEAD        1638 
.................... // 3.0V; dead battery, any lower, do not move valve; fl_batDEAD 
.................... //    ('d' here down to FVR_NODUST) 
....................  
.................... #define FVR_WEAK        1534 
.................... // 3.2V; below this point, battery dangerously weak  
.................... //  but can add charge, shout out; fl_batSHOUT, fl_addchg  
.................... //    ('-' here down to FVR_DEAD)) 
....................  
.................... #define FVR_ADDCHG      1511 
.................... // 3.25V; battery weak... below this point add charge, shout out 
.................... //    (! here down to FVR_WEAK); fl_batSHOUT, fl_addchg 
.................... // above this point, battery OK; fl_batOK 
.................... //    ('+' here up to FVR_ADEQUATE) 
....................  
.................... #define FVR_ADEQUATE    1488 
.................... // 3.30V; adequately charged if at or above this point; fl_batOK  
.................... //    ('f' here up to FVR_FULL) 
....................  
.................... #define FVR_FULL        1444 
.................... // 3.40V; battery full at or above this point; fl_batFULL 
.................... //    ('F' here up to FVR_TOOFULL) 
....................  
.................... #define FVR_TOOFULL     1327 
.................... // >=3.7 do not precharge, error condition?; fl_batTOOFULL 
.................... //    (TOPLINE_CHAR here and above) 
....................  
.................... // QCHK_FULL value is compared to 4x 1.2Vref as measured when sprinkler 
.................... //  is running and battery may be charging  (VfvrCAD) 
.................... // If the battery voltage measured during qchk_batt 
.................... //  is such that VfvrCAD < QCHK_FUL [indicates battery fully charged] 
.................... //  then charging will stop, hopefully in a smooth and controlled manner 
.................... //  before the charger hardware cannot charge due to its configuration. 
.................... // After this occurs, charging will not take place until the next marching 
.................... //  order, at which point a chk_batt happens and a different criterion applies. 
.................... // Note that qchk_batt() measures during running and charging! 
.................... // The flag fl_qbatFULL is set and not cleared until the next marching order 
.................... //  is processed. 
.................... #define QCHK_FULL       1391 
.................... // 1023/1391 * 4.8V = 3.53V 
.................... // charging never enabled (fl_qbatFULL set) when VfvrCAD < QCHK_FULL 
.................... //    (chargemark set to TOPLINE_CHAR whenever fl_qbatFULL is set) 
.................... //    (chargemark set to 'c' if !fl_qbatFULL and significant difference 
.................... //     between generator voltage while charging as compared to not charing) 
....................  
.................... #define BATT_HYST       12 
.................... // If the difference between the battery voltage at the start of a new 
.................... //  marching order as compared to the VfvrAD which was measured when 
.................... //  a bat full situation was last determined is greater than this amount, 
.................... //  then we turn charging back on; in other words, if the battery voltage 
.................... //  has dropped during the previous marching order to a great enough extent 
.................... //  AFTER we had already determined that the battery was full, then we turn 
.................... //  charging back on (Rev 030+) 
.................... // Approx a 30mV drop [somewhat arbitrary, but provides a form of hysteresis] 
....................  
.................... #define TM_BATCHK       7200 
....................    // number of seconds maximum between chk_batt() calls; 
....................  
....................  
.................... #define TM_SPINRPT      0xA1 
....................    // arbitrary 8 bit number which, when compared to low byte of seconds ctr 
....................    //  initiates the possible reporting of a spin error (should be greater than 
....................    //  32 seconds because that is the amount of time it takes for the variance 
....................    //  determination to take place (sizeof periods[]) 
....................    // Possible error states include: NOSPIN_ERRCODE, SPEEDLO_ERRCODE, 
....................    //  SPEEDHI_ERRCODE, SPEEDREG_ERRCODE 
....................    // NOSPIN: manager has told us that water is flowing, but 
....................    //  speed is too slow to detect (<~3RPM) 
....................    // SPEEDLO/SPEEDHI: average speed over previous 64 measurements is beyond 
....................    //  limit established (e.g., +/-3%) 
....................    // SPEEDREG: max speed (or min speed) over previous 64 measurements 
....................    //  exceeds limit establihsed (e.g. target+/-6%) 
....................    // In this code, spin checks occur once every 256 seconds, or whenever 
....................    //  requested by the manager (MSG_STATUS_RDONLY). 
....................    // If a problem is detected, an error message immediately goes out one time. 
....................    //  THUS spin errors will be sent at least every 256 seconds 
....................    //  (change later?) 
....................  
.................... #define ONE_WEEK     2235 
....................    // number of 4.51 minute intervals in a week (for DEAD BATT HANDLER) 
....................  
.................... #define DEAD_BATTERY    0xFF 
....................    // indicates that restart event was due to dead battery detection 
....................  
.................... #define GET_A_CHAR(value)   { TMR1L = 0x78;  \ 
....................                               TMR1IF = FALSE;  \ 
....................                               output_low(_DUST_SPCTS);  \ 
....................                               while (!(kbhit() || TMR1IF));  \ 
....................                               errors1 |= RCSTA; \ 
....................                               dust_recive_buffer[value] = RCREG; \ 
....................                               output_high(_DUST_SPCTS); \ 
....................                             } 
.................... #define GET_1_CHAR      { set_timer1(0); \ 
....................                           output_low(_DUST_SPCTS);  \ 
....................                           while (!kbhit() && bit_test(TMR1H,7));  \                          
....................                           *mm = RCREG; \ 
....................                           output_high(_DUST_SPCTS); \  
....................                           mm++; \ 
....................                         } 
....................                          
.................... #define GET_blah_CHAR      { output_low(_DUST_SPCTS);  \ 
....................                           while (!kbhit());  \                          
....................                           *mm = RCREG; \ 
....................                           output_high(_DUST_SPCTS); \  
....................                           mm++; \ 
....................                         } 
....................  
.................... #define GET_32CHARS  {  GET_A_CHAR(0) \ 
....................                         GET_A_CHAR(1) \ 
....................                         GET_A_CHAR(2) \ 
....................                         GET_A_CHAR(3) \ 
....................                         GET_A_CHAR(4) \ 
....................                         GET_A_CHAR(5) \ 
....................                         GET_A_CHAR(6) \ 
....................                         GET_A_CHAR(7) \ 
....................                         GET_A_CHAR(8) \ 
....................                         GET_A_CHAR(9) \ 
....................                         GET_A_CHAR(10) \ 
....................                         GET_A_CHAR(11) \ 
....................                         GET_A_CHAR(12) \ 
....................                         GET_A_CHAR(13) \ 
....................                         GET_A_CHAR(14) \ 
....................                         GET_A_CHAR(15) \ 
....................                         GET_A_CHAR(16) \ 
....................                         GET_A_CHAR(17) \ 
....................                         GET_A_CHAR(18) \ 
....................                         GET_A_CHAR(19) \ 
....................                         GET_A_CHAR(20) \ 
....................                         GET_A_CHAR(21) \ 
....................                         GET_A_CHAR(22) \ 
....................                         GET_A_CHAR(23) \ 
....................                         GET_A_CHAR(24) \ 
....................                         GET_A_CHAR(25) \ 
....................                         GET_A_CHAR(26) \ 
....................                         GET_A_CHAR(27) \ 
....................                         GET_A_CHAR(28) \ 
....................                         GET_A_CHAR(29) \ 
....................                         GET_A_CHAR(30) \ 
....................                         GET_A_CHAR(31) } 
....................                          
.................... #define GET_REST_OF_CHARS  {  GET_1_CHAR \ 
....................                               GET_1_CHAR \ 
....................                               GET_1_CHAR \ 
....................                               GET_1_CHAR \ 
....................                               GET_1_CHAR \ 
....................                               GET_1_CHAR \ 
....................                               GET_1_CHAR \ 
....................                               GET_1_CHAR \ 
....................                               GET_1_CHAR \ 
....................                               GET_1_CHAR \ 
....................                               GET_1_CHAR \ 
....................                               GET_1_CHAR \ 
....................                               GET_1_CHAR \ 
....................                               GET_1_CHAR \ 
....................                               GET_1_CHAR \ 
....................                               GET_1_CHAR \ 
....................                               GET_1_CHAR \ 
....................                               GET_1_CHAR \ 
....................                               GET_1_CHAR \ 
....................                               GET_1_CHAR \ 
....................                               GET_1_CHAR \ 
....................                               GET_1_CHAR \ 
....................                               GET_1_CHAR \ 
....................                               GET_1_CHAR \ 
....................                               GET_1_CHAR \ 
....................                               GET_1_CHAR \ 
....................                               GET_1_CHAR \ 
....................                               GET_1_CHAR \ 
....................                               GET_1_CHAR \ 
....................                               GET_1_CHAR \ 
....................                               GET_1_CHAR \ } 
....................  
....................  
.................... // see MOTETIME.xlsx 
.................... // 1/1/2013 midnight .... 1/1/2062 midnight 
.................... UNSIGNED INT32 CONST YRLUKUP [50] = { 
....................    0x50E22700,0x52C35A80,0x54A48E00,0x5685C180,0x58684680, 
....................    0x5A497A00,0x5C2AAD80,0x5E0BE100,0x5FEE6600,0x61CF9980, 
....................    0x63B0CD00,0x65920080,0x67748580,0x6955B900,0x6B36EC80, 
....................    0x6D182000,0x6EFAA500,0x70DBD880,0x72BD0C00,0x749E3F80, 
....................    0x7680C480,0x7861F800,0x7A432B80,0x7C245F00,0x7E06E400, 
....................    0x7FE81780,0x81C94B00,0x83AA7E80,0x858D0380,0x876E3700, 
....................    0x894F6A80,0x8B309E00,0x8D132300,0x8EF45680,0x90D58A00, 
....................    0x92B6BD80,0x94994280,0x967A7600,0x985BA980,0x9A3CDD00, 
....................    0x9C1F6200,0x9E009580,0x9FE1C900,0xA1C2FC80,0xA3A58180, 
....................    0xA586B500,0xA767E880,0xA9491C00,0xAB2BA100,0xAD0CD480}; 
....................     
....................  
.................... UNSIGNED INT8 CONST BYTE_2_PCT [256] = { 
....................     0, 0, 1, 1, 2, 2, 2, 3, 3, 4, 4, 4, 5, 5, 5, 6,  
....................     6, 7, 7, 7, 8, 8, 9, 9, 9,10,10,11,11,11,12,12, 
....................    13,13,13,14,14,15,15,15,16,16,16,17,17,18,18,18, 
....................    19,19,20,20,20,21,21,22,22,22,23,23,24,24,24,25, 
....................    25,25,26,26,27,27,27,28,28,29,29,29,30,30,31,31, 
....................    31,32,32,33,33,33,34,34,35,35,35,36,36,36,37,37, 
....................    38,38,38,39,39,40,40,40,41,41,42,42,42,43,43,44, 
....................    44,44,45,45,45,46,46,47,47,47,48,48,49,49,49,50, 
....................    50,51,51,51,52,52,53,53,53,54,54,55,55,55,56,56, 
....................    56,57,57,58,58,58,59,59,60,60,60,61,61,62,62,62, 
....................    63,63,64,64,64,65,65,65,66,66,67,67,67,68,68,69, 
....................    69,69,70,70,71,71,71,72,72,73,73,73,74,74,75,75, 
....................    75,76,76,76,77,77,78,78,78,79,79,80,80,80,81,81, 
....................    82,82,82,83,83,84,84,84,85,85,85,86,86,87,87,87, 
....................    88,88,89,89,89,90,90,91,91,91,92,92,93,93,93,94, 
....................    94,95,95,95,96,96,96,97,97,98,98,98,99,99,100,100 }; 
....................     
.................... UNSIGNED INT8 CONST BYTE99_2_10S [100] = { 
....................    '0', '0', '0', '0', '0', '0', '0', '0', '0', '0',  
....................    '1', '1', '1', '1', '1', '1', '1', '1', '1', '1',  
....................    '2', '2', '2', '2', '2', '2', '2', '2', '2', '2',  
....................    '3', '3', '3', '3', '3', '3', '3', '3', '3', '3',  
....................    '4', '4', '4', '4', '4', '4', '4', '4', '4', '4',  
....................    '5', '5', '5', '5', '5', '5', '5', '5', '5', '5',  
....................    '6', '6', '6', '6', '6', '6', '6', '6', '6', '6',  
....................    '7', '7', '7', '7', '7', '7', '7', '7', '7', '7',  
....................    '8', '8', '8', '8', '8', '8', '8', '8', '8', '8',  
....................    '9', '9', '9', '9', '9', '9', '9', '9', '9', '9' }; 
....................  
.................... UNSIGNED INT8 CONST BYTE99_2_1S [100] = { 
....................    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 
....................    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 
....................    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 
....................    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 
....................    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 
....................    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 
....................    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 
....................    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 
....................    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 
....................    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9' }; 
....................     
.................... */ 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... #include "defines.h" 
.................... // defines.h                                                                
.................... // 
.................... // contains all non-pic (and non-dn2500.h) related defines and macros 
....................  
.................... ////////////////////Defines Table of Contents////////////////////////////////// 
.................... //Version 
.................... //Priority Queue 
.................... //Time Queue 
.................... //Command Stack 
.................... //Sprinkler Stack 
.................... //Gen RPM                               
.................... //Control Algorithm 
.................... //Valve                
.................... //XDCR           
.................... //RB ISR         
.................... //I2C Addresses  
.................... //LCD         
.................... //DUST    
.................... //Errors   
....................              
.................... ////////////////////Version//////////////////////////////////////////////////// 
.................... #define FIRMWARE_VERSION 0xE314           
....................  
....................                             
.................... // Defines designed to simplify debugging and program development process         
.................... #DEFINE DISABLE_NO_SPIN_RECOVERY          1 
.................... #DEFINE DISABLE_MAG_DECOUPLING_RECOVERY   1               
.................... #DEFINE DISABLE_RECAL_VLV                 1 
.................... #DEFINE ALLOW_VALVE_SET_WITH_STALE_CAL    1 
.................... #DEFINE OPEN_VALVE_TO_SETPT_AT_BOOT       1 
....................                                     
.................... ////////////////////Priority Queue///////////////////////////////////////////// 
.................... // Maximum number of items in priority queue. Each item is 1 byte and in RAM 
.................... // Actual number of items is max - 1 as item 0 is reserved for sorting use 
.................... #define MAX_PRIORITY_QUEUE_ITEMS   20 
....................  
.................... // Priority Queue items (identified by their priority) (1-255) 
.................... // lower number is higher priority 
.................... #define EMPTY_PRIORITY_QUEUE           0x00 
....................  
.................... #define WAIT_FOR_BOOT_EVENT            0x10 
.................... #define RESET_MOTE                     0x11 
....................  
.................... #define DEAL_WITH_NEW_PACKET           0x20 
....................  
.................... #define VALVE_MOVE_ERROR               0x30 
.................... #define CALIBRATE_VALVE_1              0x31 
.................... #define CALIBRATE_VALVE_2              0x32                   
.................... #define CALIBRATE_VALVE_3              0x33 
.................... #define CALIBRATE_VALVE_4              0x34 
.................... #define CALIBRATE_VALVE_5              0x35 
.................... #define CALIBRATE_VALVE_6              0x36 
.................... #define CALIBRATE_FSR_1                0x37 
.................... #define CALIBRATE_FSR_2                0x38            
.................... #define CALIBRATE_FSR_3                0x39 
.................... #define CALIBRATE_FSR_4                0X3A 
.................... #define MOVE_VALVE_MAG_DECOUPLING_RECOVERY 0x3C              
.................... #define MOVE_VALVE_NO_SPIN_RECOVERY        0x3D  
.................... #define OPEN_VALVE_UNKNOWN_STATE       0x3E 
.................... #define CLOSE_VALVE_UNKNOWN_STATE      0x3F 
.................... #define MOVE_VALVE                     0x40 
.................... #define MOVE_VALVE_AT_BOOT             0x41 
....................  
.................... #define START_GPS_AQUISITION           0x50 
.................... #define CHECK_GPS_FOR_LOCK             0x51  
.................... #define TAKE_XCDR_MESUREMENT_1         0x55 
.................... #define TAKE_XCDR_MESUREMENT_2         0x56   
.................... #define OPTIMIZE_MPPC                  0xA0 
....................  
.................... #define CHECK_BATTERY_STATE            0xA1 
.................... #define CHECK_MOTE_TEMP                0xA2 
.................... #define UPDATE_MOTE_TIME               0xA3 
.................... #define UPDATE_MOTE_NETWORK_INFO       0xA4 
.................... // below added by JG 2017 Feb13 
.................... #define SEND_UNSOLICITED_FULL_REPORT   0xA5 
....................  
.................... #define SEARCH_FOR_STRONGEST_1         0xB1 
.................... #define SEARCH_FOR_STRONGEST_2         0xB2 
.................... #define INIT_JOIN                      0xB3 
.................... #define CHECK_MOTE_STATE               0xB4 
.................... #define CHECK_MOTE_INFO                0xB5 
....................  
.................... #define BUSCOL_RESET                   0xC0 
....................  
.................... #define LCD_DISPLAY_RUN_MODULATION     0xD1 
.................... #define LCD_DISPLAY_RUN_NO_MODULATION  0xD2 
.................... #define LCD_DISPLAY_RBUF               0xD3 
.................... #define LCD_UPDATE                     0xD4 
....................  
.................... #define CPU_RESET                      0xF0 
.................... #define SHUTDOWN_SYSTEM                0xF1 
....................  
.................... // Macros used to push things to priority queue 
.................... #define PUSH_PRIORITY_QUEUE_MACRO(x)   \ 
.................... {disable_interrupts(INT_CCP4);         \ 
.................... push_priority_queue(x);                \ 
.................... enable_interrupts(INT_CCP4);} 
....................                                   
.................... #define PUSH_PRIORITY_QUEUE_ISR_MACRO(x) {push_priority_queue_ISR(x);}  
....................                                   
.................... ////////////////////Time Queue///////////////////////////////////////////////// 
.................... // Maximum number of items in time queue. Each item is 5 bytes and in RAM 
.................... // Actual number of items is max - 1 as item 0 is reserved for sorting use 
.................... #define MAX_TIME_QUEUE_ITEMS   5 
....................  
.................... // empty spot in the time queue, used as return item to signify empty top spot 
.................... #define EMPTY_TIME_QUEUE 0 
....................  
.................... // struct of individual time queue item 
.................... struct TimeQueueItem  
.................... { 
....................    uint32_t time_to_execute; 
....................    uint8_t pq_priority; 
.................... }; 
....................  
.................... // Macro for pushing items onto the time queue 
.................... #define PUSH_TIME_QUEUE_MACRO(x,y)  {disable_interrupts(INT_CCP4);            \ 
....................                                     push_time_queue(x,y);                     \ 
....................                                     enable_interrupts(INT_CCP4);}   
....................                                  
.................... ////////////////////Periodic checks/updates done in the time queue 
.................... // How often "long-term" checks are done within ccp4 (timer interrupt) in seconds 
....................    // - mote state (reacts as necessary) 
....................    // - battery state (turns off/on charging, sends warnings, etc.) 
....................    // - mote temp (logs data, sends warnings, etc.) 
....................    // - mote utc time (updates utc time if valid) 
.................... #define PERIODIC_CHECKS_TIME      32 
....................  
.................... ////////////////////Command Queue////////////////////////////////////////////// 
.................... // depth of command queue 
.................... #define MAX_COMMAND_QUEUE_ITEMS 10 
....................  
.................... // maximum number of sprinkler zones in each command coming from manager 
.................... #define MAX_NUM_SPRINKLER_ZONES 4 
....................  
.................... // struct for individual sprinkler zone settings 
.................... struct SprinklerZoneSettingsItem 
.................... { 
....................    uint16_t vlv_open_amount; 
....................    uint16_t spin_rate; 
....................    uint8_t duty_cycle; 
.................... }; 
....................  
.................... // struct for a single command (coming from manager) and item in the command 
.................... // queue 
.................... struct CommandQueueItem 
.................... { 
....................    uint32_t start_time; 
....................    uint32_t end_time; 
....................    struct SprinklerZoneSettingsItem* sprinkler_settings; 
....................    uint8_t num_of_zones; 
....................    uint8_t control_loop_mechanism; 
.................... }; 
....................  
.................... ////////////////////Sprinkler Queue//////////////////////////////////////////// 
.................... // depth of sprinkler queue (ONLY SETUP FOR 2 AT THE MOMENT) 
.................... //#define MAX_SPRINKLER_QUEUE_ITEMS 2 
.................... #define MAX_SPRINKLER_QUEUE_ITEMS 10 
....................  
.................... // struct for single sprinkler queue item 
.................... struct SprinklerQueueItem 
.................... { 
....................    uint32_t start_time; 
....................    uint32_t end_time; 
....................    uint16_t vlv_open_amount; 
....................    uint16_t spin_rate; 
....................    uint8_t zone_num; 
....................    uint8_t control_loop_mechanism; 
.................... }; 
....................  
.................... #define EMPTY_SPINKLER_QUEUE 0 
.................... /////////////////////Message Queue///////////////////////////////////////////// 
.................... // depth of message queue 
.................... #define MAX_MESSAGE_QUEUE_ITEMS 10  
....................  
.................... // empty spot in the message queue, used as return item to signify empty top spot 
.................... #define EMPTY_MESSAGE_QUEUE 0 
....................  
.................... // how many times will messages be attempted before an error message/bit is sent/set 
.................... #define MAX_UNSOLICITED_MESSAGE_ATTEMPTS 3 
....................                                                                      
.................... // how long to wait between message reattempts in seconds 
.................... #define MESSAGE_RESEND_WAIT_PERIOD 60 
....................  
.................... // how often identical error messages are able to be resent  
.................... // (if there haven't been any other types of error messages) in seconds 
.................... #define ERR_MESSAGE_WAIT_PERIOD 60                                                             
....................                                                                                             
.................... // struct for single message queue item 
.................... struct MessageQueueItem 
.................... {                                            
....................    uint32_t time_to_send; 
....................    uint8_t message_type; 
....................    uint16_t msg_seq; 
....................    uint8_t attempt_num; 
.................... }; 
....................  
.................... // Macro for pushing items onto the message queue 
.................... #define PUSH_MESSAGE_QUEUE_MACRO(x)  {disable_interrupts(INT_CCP4);           \ 
....................                                        push_message_queue(x);                 \ 
....................                                        enable_interrupts(INT_CCP4);}    
....................                                         
.................... #define PUSH_MESSAGE_QUEUE_ISR_MACRO(x)  {disable_interrupts(INT_CCP4);       \ 
....................                                           push_message_queue_isr(x);          \ 
....................                                           enable_interrupts(INT_CCP4);}                                           
....................                                         
.................... // Macro for deleting items off the message queue 
.................... #define REMOVE_MESSAGE_QUEUE_MACRO(x)  {disable_interrupts(INT_CCP4);         \ 
....................                                        remove_message_queue_item(x);          \ 
....................                                        enable_interrupts(INT_CCP4);}                                        
....................  
.................... /////////////////////Gen RPM/////////////////////////////////////////////////// 
.................... #define CCP_PER_RPM     2576980378L                                      
.................... // 39322 shifted 16 places left 
.................... // The timer used for the RPM measurement (CCP5) is 32.768KHz clock 
.................... // Stepper has 50 poles.... 
.................... // stepper output frequency = 50 * revs/sec = 50/60 * RPM                    
.................... // stepper output period = 1.2 / RPM 
.................... // CCP counter period = 1/32768 
.................... // CCP counts = (1.2/RPM) / (1/32768) = 39321.6 / RPM 
.................... // RPM = 39322/(CCP counts)  
....................                                                            
.................... ////////////////////Control Algorithm Defines////////////////////////////////// 
.................... // Min/Max Value of braking 
.................... #define NO_BRK    0 
.................... #define MAX_BRK   400 
....................  
.................... // Min/Max Value of charging 
.................... #define NO_CHARGE    0 
.................... #define MAX_CHARGE   400 
....................  
.................... // Min/Max Value of MPPC 
.................... #define NO_MPPC    0x07 
.................... #define MAX_MPPC   0xFF 
....................  
.................... // Min/Max setting of rpm 
.................... #define MIN_RPM_SETTING    10  
.................... #define MAX_RPM_SETTING    250 
....................  
.................... // Min/Max Value of fixture dac setting 
.................... // Set DAC on lab fixture to 0xC00 to sink ALL the current from the power 
.................... // source...  750mA (Test fixture setup:  full scale (0x1000) draws 1A 
.................... #define NO_FIXTURE    0x000 
.................... #define MAX_FIXTURE   0xC00 
....................  
.................... // Battery Charging cutoffs (in adc counts summed over 4 samples) 
.................... // When to stop charging the battery (3.5V while charging) 
.................... #define BATTERY_STOP_CHARGING    1402 
.................... // Hysteresis to start charging the battery again (3.3V while NOT charging) 
.................... #define BATTERY_START_CHARGING   1490 
.................... // When to warn the manager that the battery is dying (3.1V while NOT charging) 
.................... #define BATTERY_WARN             1584      
.................... // When to put the mote to sleep (3.0V while NOT charging) 
.................... #define BATTERY_DEAD             1637   
....................  
.................... // defines for global_control_loop_mechanism 
.................... // Shows what is being used to control rpm in control loop 
.................... // No rpm control is generally used for test modes                                   
.................... // No rpm control fsr will set braking and charging to 0 for FSR Calibration      
....................                                     
.................... // where to "jump into" the control loop. 
.................... //    basically, regular mode with both engaged, but it will evaluate if it should go into 
.................... //    BRAKE_AND_CHARGE or BRAKE_ONLY         
.................... #define BRAKE_AND_CHARGE_START      0x00 
.................... // regular mode with charging turned on        
.................... #define BRAKE_AND_CHARGE            0x01 
.................... // regular mode with charging turned off (due to full battery most likely) 
.................... #define BRAKE_ONLY                  0x02 
.................... // test mode where charging is force off 
.................... #define FORCE_BRAKE_ONLY            0x03 
.................... // test mode where braking is forced off 
.................... #define FORCE_CHARGE_ONLY           0x04 
.................... // test mode where brake and charge are set 
.................... #define NO_RPM_CONTROL              0x05 
.................... // test mode where brake and charge are set and dynamic mppc is used 
.................... #define NO_RPM_CONTROL_DYN_MPPC     0x06 
.................... // FSR calibration (no brake/charge/rpm control) 
.................... #define NO_RPM_CONTROL_FSR          0x07 
.................... // magnetic decoupling recovery 
.................... #define NO_SPIN_RECOVERY            0x08 
.................... // magnetic decoupling recovery             
.................... #define MAG_DECOUPLING_RECOVERY     0x09   
.................... // idle (nothing in the queue). Disable control loop    
.................... #define NO_SPRINKLER_CONTROL        0xFF                    
....................                                                          
.................... ////////////////////Valve////////////////////////////////////////////////////// 
.................... // Starting position of the DAC (also works as the eeprom stored inital value) 
.................... #define VLV_POSITION_UNKNOWN         0xFFFF 
.................... // Fully closed valve position                                                 
.................... #define VLV_POSITION_CLOSED          0x0000 
.................... // Fully open valve position      
.................... #define VLV_POSITION_OPENED          0x8000 
....................  
.................... // moved to eeprom stuff 
.................... /* 
.................... // Maximum value of "near closed" range 
.................... #define VLV_NEAR_CLOSED_RANGE_MAX    0x1000 
.................... // Maximum value of "near opened" range 
.................... #define VLV_NEAR_OPENED_RANGE_MAX    0x7000 
.................... */ 
.................... // default valve position for pre-calibration                     
.................... #define VLV_PRECALIBRATION_POSITION   0x4000 
.................... // Amount to move open in calibration routine 1 in units of valve position 
.................... #define VLV_CAL_1_MOVEMENT           0x2000     
....................  
.................... // approximate position to move valve at boot time 
.................... // if OPEN_VALVE_TO_SETPT_AT_BOOT is defined.... 
.................... // 0x2000 is 25% 
.................... #define VLV_BOOT_SETPT  0x2000 
....................  
.................... // determines when a VLV_CAL_STALE error message may occur 
.................... // 0x15180 is 24 hours 
.................... #define VLV_SECS_TO_STALE_CAL       0x00015180 
....................  
.................... //moved to eeprom stuff 
.................... /* 
.................... // DAC level while opening near the fully open end 
.................... #define DAC_LVL_OPENING_NEAR_OPENED       22        
.................... // DAC level while opening near the fully closed end 
.................... #define DAC_LVL_OPENING_NEAR_CLOSED       15    
.................... // DAC level while closing near the fully open end 
.................... #define DAC_LVL_CLOSING_NEAR_OPENED       15 
.................... // DAC level while closing near the fully closed end 
.................... #define DAC_LVL_CLOSING_NEAR_CLOSED       21 
.................... // DAC level while moving in the middle of the valve range and it's default 
.................... #define DAC_LVL_IN_MIDDLE                 18 
.................... // DAC level for the inital current boost/lowered current limit   
.................... #define DAC_LVL_INIT_CURRENT_BOOST        15             
.................... */ 
....................  
.................... // Valve timeout in millispans (maximum number of millispans that it can move  
.................... //    without error).  1024 is the full range. 
.................... #define VALVE_TIMEOUT                     1500 
....................  
.................... // Number of movements since an endstop before triggering a re-calibration of 
.................... //    endstop position (done before/triggered by a pending move) 
.................... #define VLV_MOVES_BEFORE_RECAL            25          
....................                                               
.................... // moved to eeprom stuff 
.................... /* 
.................... // Amount of millispans that a current boost/lovered dac level is implemented. 
.................... //    This is done outside of the (NEAR_CLOSED/OPEN_RANGE) 
.................... //    @ 45 seconds to close, 30 = 1.3 seconds 
.................... #define VLV_INIT_CURRENT_BOOST_TIME_1024THS   30      
.................... */                                     
....................  
.................... // default time_to_open/close.  This is the number of 2ndary Osccilator ticks 
.................... //    for 1/1024th of the span if the entire open-close takes 45 seconds. 
.................... #define DEFAULT_VLV_TIME_TO_OPEN          1280   
.................... #define DEFAULT_VLV_TIME_TO_CLOSE         1280        
....................     
.................... // if vlv_time_to_close/open is below this number, errors are thrown and calibration  
.................... //     is thrown away.  750 = 23.4375 seconds 
.................... #define ERROR_VLV_CAL_TIME_LO             750    
.................... // if vlv_time_to_close/open is above this number, errors are thrown and calibration  
.................... //     is thrown away.  750 = 78.125 seconds 
.................... #define ERROR_VLV_CAL_TIME_HI             2500   
....................  
.................... // moved to eeprom stuff 
.................... /* 
.................... // valve not-spinning and magnetic de-coupling defines                                                     
.................... // below this number is the regime where we watch for the vgen not spinning case 
.................... #define VLV_NOT_SPIN_LIMIT                0x6000 
.................... // where we send the valve when we want to fix it.  If it gets fixed before reaching this valve position 
.................... //    it stops. If it does not get fixed by the time it reaches this position, it sends an error and stops. 
.................... #define VLV_NOT_SPIN_FIX                  0x7000 
....................                                             
.................... // above this rpm, consider magnetic coupling or not-spinning fixed 
.................... #define NOT_SPINNING_MAG_DECOUPLING_RPM_FIXED   8        
....................                                                    
.................... // above this number is the regime where we watch for the vgen not spinning case 
.................... #define VLV_MAGNETIC_COUPLING_LIMIT       0x6000        
.................... // where to move the valve at a time when trying to recover  
.................... #define VLV_MAGNETIC_COUPLING_FIX         0x2000          
.................... // amount to move the valve at a time when trying to recover 
....................                                                   
.................... // how many seconds it takes to consider the rpm to be zero (or infinite for higher valve settings)  
.................... // 8 = 7.5 RPM (8 may be max of what ccp5 can handle without overflow)             
.................... #define RPM_TIMEOUT                      8        
.................... */                                                         
....................  
.................... // defines for testing valve state 
.................... #define  IS_VLV_COASTING   (LATE == 0) 
.................... #define  IS_VLV_CLOSING    (LATE == 0x01) 
.................... #define  IS_VLV_OPENING    (LATE == 0x02) 
.................... #define  IS_VLV_BRAKING    (LATE == 0x03) 
....................  
.................... // macros for making the valve move 
.................... #define  mV_COASTm   {LATE=0;} 
.................... #define  mV_CLOSEm   {LATE=0x01;} 
.................... #define  mV_OPENm    {LATE=0x02;} 
.................... #define  mV_BRAKEm   {LATE=0x03;}                                                                                                                      
....................  
.................... ////////////////////XDCR///////////////////////////////////////////////////////  
.................... // limit for detecting if the XDCR is plugged in or not.   
.................... // there is a ~5.6M resistor pulling the line up to vcc. 
.................... // It sums 8 measurements and with the weak pullups is usually around 6200 
.................... // To account for variation, we will set 5000 (around 75 psi on the 100 psi sensor) 
.................... // as the limit to detect it.         
.................... #define XDCR_ADC_OFF_LIMIT 5000      
....................                                                      
.................... ////////////////////RB ISR/////////////////////////////////////////////////////   
.................... // seconds you have to press SW1 until it activate the long press function 
.................... #define SW1_ISR_LONG_PRESS_TIME 5  
....................                                              
.................... ////////////////////I2C Addresses////////////////////////////////////////////// 
.................... #define LCD_ADDRESS 0x7C 
.................... #define XDCR_ADDRESS 0x48         
.................... #define FIXTURE_DAC_ADDRESS 0x40     
....................                                     
.................... ////////////////////LCD Defines////////////////////////////////////////////////     
.................... // total number of lcd pages defined in switch-case in LCD_update_diplay() 
.................... // JG: Actually there are 4 defined in the switch-case, but only 
.................... //  want to see 3 at this time 
.................... #define TOTAL_LCD_PAGES 4                              
....................  
.................... ////////////////////LED Defines Start//////////////////////////////////////////    
.................... // make sure to disable INT_RB4 to not have the led trigger an IOC int 
.................... #define LED1_ON       disable_interrupts(INT_RB4); set_tris_b(TRISB_LED); output_low(LED1n); 
.................... #define LED1_OFF      set_tris_b(TRISB_NORM); enable_interrupts(INT_RB4); 
....................  
.................... #define LED2_ON       output_low(LED2n); 
.................... #define LED2_OFF      output_high(LED2n); 
....................  
.................... ////////////////////LED Defines End//////////////////////////////////////////// 
....................  
.................... ////////////////////DUST Defines/////////////////////////////////////////////// 
.................... // moved to eeprom stuff      
.................... /*                                             
.................... // amount of seconds for mote to stay searching for advertisements                     
.................... #define MOTE_SEARCH_TIME 120        
.................... // amount of time the mote will stay disconnected from the network before shutting down (900 = 15 min)    
.................... #define MOTE_NETWORK_SHUTDOWN_TIMEOUT 900            
.................... */ 
....................  
.................... // Min temperature before sending a warning/shutdown 
.................... #define MOTE_MIN_TEMP_WARNING   -35 
.................... #define MOTE_MAX_TEMP_WARNING    80                                       
.................... #define MOTE_MIN_TEMP_SHUTDOWN   -40 
.................... #define MOTE_MAX_TEMP_SHUTDOWN   85                                                             
....................  
.................... //Crazy macro for finding control escape 
.................... #define STUFF_BYTE(x, y, z)  { \ 
....................     if ((x==CONTROL_ESCAPE)||(x==FLAG_SEQUENCE)) { \ 
....................         y[z++] = CONTROL_ESCAPE; \ 
....................         y[z++] = x ^ XOR_BYTE; \ 
....................     } else { \ 
....................         y[z++] = x;     \ 
....................     } \ 
.................... } 
....................  
.................... #define STUFF_BYTE_ISR(x, y, z)  { \ 
....................     if ((x==CONTROL_ESCAPE)||(x==FLAG_SEQUENCE)) { \ 
....................         y[z++] = CONTROL_ESCAPE; \ 
....................         y[z++] = x ^ XOR_BYTE; \ 
....................     } else { \ 
....................         y[z++] = x;     \ 
....................     } \ 
.................... }       
....................  
.................... // Default newtork ID of bluebox  
.................... // Somewhat arbitrary, but we will refer to 04cd blue box as center pivot number 0 
.................... //    ...which is the default listed below 
.................... #define NETWORK_ID_DEF  0x04cd                                 
....................                                                         
.................... // defines for msg_id (Manager->Mote Payload message ID to Micro) 
.................... #define MSG_MGR_ACK                       0x01 
.................... #define MSG_MGR_NACK                      0x02 
....................                                                           
.................... #define MSG_MGR_FULL_REPORT               0x10 
.................... #define MSG_MGR_HEALTH_REPORT             0x11 
.................... #define MSG_MGR_VALVE_REPORT              0x12 
....................  
.................... #define MSG_MGR_WARM_RESTART              0x20 
.................... #define MSG_MGR_COLD_RESTART              0x21 
.................... #define MSG_MGR_FORCE_REJOIN              0x22 
.................... #define MSG_MGR_SHUTDOWN                  0x23 
....................  
.................... #define MSG_MGR_UPDATE_SP_NUM             0x30 
.................... #define MSG_MGR_CAL_VALVE                 0x31 
.................... #define MSG_MGR_CAL_FSR                   0x32 
.................... #define MSG_MGR_AQUIRE_GPS                0x33 
.................... #define MSG_MGR_UPDATE_EEPROM             0x34  
.................... #define MSG_MGR_READ_EEPROM               0x35  
.................... #define MSG_MGR_READ_XDCR                 0x36 
....................  
.................... #define MSG_MGR_RUN_CMD_NO_MOD            0x40 
.................... #define MSG_MGR_RUN_CMD_MOD               0x41 
.................... #define MSG_MGR_TEST_NO_RPM_CTRL          0x42 
.................... #define MSG_MGR_TEST_RPM_CTRL             0x43 
.................... #define MSG_MGR_DEMO                      0x44 
.................... #define MSG_MGR_CLEAR_SPINKLER_CMD_QUEUE  0x45 
.................... #define MSG_MGR_FORCE_VALVE_MOVEMENT      0x46 
....................  
.................... // defines for msg_id (Micro to Mote) 
.................... #define MSG_MOTE_UNSOLICITED              0x00 
.................... #define MSG_MOTE_ACK                      0x80 
.................... #define MSG_MOTE_NACK                     0x81          
....................  
.................... #define MSG_MOTE_FULL_REPORT              0x90 
.................... #define MSG_MOTE_HEALTH_REPORT            0x91 
.................... #define MSG_MOTE_VALVE_REPORT             0x92                  
.................... #define MSG_MOTE_SPINKLER_CMD_RESPONSE    0x93 
.................... #define MSG_MOTE_JOIN_MSG                 0x94       
.................... #define MSG_MOTE_UPDATE_SP_NUM_RESPONSE   0x95 
.................... #define MSG_MOTE_GPS_POINT_MSG            0x96    
.................... #define MSG_MOTE_EEPROM_READ_RESPONSE     0x97 
.................... #define MSG_MOTE_XDCR_READ_MSG            0x98    
.................... #define MSG_MOTE_ERROR_MSG                0xA0 
....................  
....................  
.................... ////////////////////Status Defines///////////////////////////////////////////// 
.................... ////////////////////Mote Statuses (for global_mote_status) 
.................... /* From jack_dn2500.h 
.................... // Mote Status values 
.................... #define MOTESTATE_INIT           0x00     // Mote is booting. 
.................... #define MOTESTATE_IDLE           0x01     // Mote is accepting config cmds.   
....................                                           //  Upon receiving a join cmd, mote  
....................                                           //  moves into the Searching state. 
....................                                           //  Idle state is low power state. 
.................... #define MOTESTATE_SEARCHING      0x02     // Mote's rcvr is on with a  
....................                                           //  configurable duty cycle while 
....................                                           //  mote is actively searching for net.  
.................... #define MOTESTATE_NEGOTIATING    0x03     // Mote has detected a network  
....................                                           //  and is attempting to connect. 
.................... #define MOTESTATE_CONNECTED      0x04     // Mote has joined the net 
.................... #define MOTESTATE_OPERATIONAL    0x05     // Mote has links to both net mgr and 
....................                                           //  gateway; ready to send data. 
.................... #define MOTESTATE_DISCONNECTED   0x06     // Mote is disconnected. 
.................... #define MOTESTATE_RADIOTEST      0x07 
.................... #define MOTESTATE_PROMISCUOUS    0x08 
.................... #define MOTESTATE_UNKNOWN        0xFF 
.................... */ 
....................  
.................... ////////////////////System States (for global_system_state)       
.................... // system is initalizing, but not ready to run yet      
.................... #define SYSTEM_INIT                       0x00        
.................... // system is paused while sprinkling (for something like going over a waterway, for example) 
.................... //    Not sure if this needs to be used. 
.................... #define SYSTEM_PAUSE                      0x01   
.................... // system is running (sprinkling and control loop running) 
.................... #define SYSTEM_RUN                        0x02  
.................... // system is on and ready for commands, but not in the control loop (lower power)           
.................... #define SYSTEM_IDLE                       0x03        
.................... // system is sleeping (powered down?). Not sure if this needs to be used 
.................... #define SYSTEM_SLEEP                      0x04 
.................... // valve opening a little bit to ensure we dont jam into close endstop 
.................... #define SYSTEM_CAL_VLV_1                  0x10 
.................... // valve closing towards closing endstop pre-calibration 
.................... #define SYSTEM_CAL_VLV_2                  0x11 
.................... // valve opening fully from fully closed for calibration                         
.................... #define SYSTEM_CAL_VLV_3                  0x12 
.................... // doing FSR w/ valve fully open 
.................... #define SYSTEM_CAL_VLV_4                  0x13 
.................... // valve closing fully from fully open for calibration 
.................... #define SYSTEM_CAL_VLV_5                  0x14 
.................... // calibration routine is done, send message to manager and prepare system for 
.................... //    idle/run mode 
.................... #define SYSTEM_CAL_VLV_6                  0x15 
.................... // valve is moving towards one of the endstops trying to recalibrate it's position 
.................... #define SYSTEM_RECAL_VLV_MOVES            0x16 
.................... // valve is moving (outside of calibrate valve routine) 
.................... #define SYSTEM_MOVE_VALVE                 0x17 
.................... // Move valve to desired setting 
.................... #define SYSTEM_CAL_FSR_1                  0x18 
.................... // do fsr calibration 
.................... #define SYSTEM_CAL_FSR_2                  0x19 
.................... // move valve back to original position 
.................... #define SYSTEM_CAL_FSR_3                  0x1A 
.................... // fsr is done, send message to manager and restore previous state/run mode 
.................... #define SYSTEM_CAL_FSR_4 
....................  
.................... // system is searching for a network 
.................... #define SYSTEM_SEARCHING_FOR_NETWORK      0x20 
.................... // system is connecting to a network 
.................... #define SYSTEM_CONNECTING_TO_NETWORK      0x21 
.................... // ????? 
.................... #define SYSTEM_STATE_UNKNOWN              0xFF     
....................  
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////////////////////Error Defines////////////////////////////////////////////// 
.................... /////////////////////////////////////////////////////////////////////////////// 
....................  
.................... ////////////////////Deep sleep/shutdown/restart reasons/errors 
.................... // stored in global_shutdown_errors_bitfield and EEPROM and shown on screen before deep sleep 
.................... // no error 
.................... #define NO_ERR                            0x00 
.................... // mote doesn't respond after a reset 
.................... #define ERR_FAIL_ON_MOTE_RESET            0x01 
.................... // mote receives no advertisement from managers 
.................... #define ERR_NO_ADV_WHILE_SEARCHING        0x02 
.................... // mote has set it's network manager id during search succesfully 
.................... #define NEW_NETWORK_ID_SET                0x03 
.................... // mote does not respond properly to a request 
.................... #define ERR_MOTE_UNRESPONSIVE             0x04 
.................... // mote is outside of operating range (defined under dust) 
.................... #define ERR_MOTE_OUT_OF_TEMP_RANGE        0x05 
.................... // network was unable to join properly 
.................... #define ERR_NETWORK_JOIN_FAIL             0x06 
.................... // unable to set join duty on mote properly 
.................... #define ERR_MTJOINDUTY                    0x07 
.................... // unable to join network with joinkey 
.................... #define ERR_MTJOINKEY                     0x08 
.................... // warm restart requested by manager 
.................... #define WARM_RESTART_REQUEST              0x09 
.................... // cold restart requested by manager 
.................... #define COLD_RESTART_REQUEST              0x0A 
.................... // shutdown requested by manager           
.................... #define MANAGER_SHUTDOWN_REQUEST          0x0B 
.................... // battery is dead 
.................... #define ERR_BATT_DEAD_SLEEP               0x0C 
.................... // network timeout 
.................... #define ERR_NO_NETWORK_TIMEOUT            0x0D 
....................  
.................... // freshly programmed (EEPROM defaults to all F,F,F...F) 
.................... #define NEWLY_PROGRAMMED                  0xFF 
....................  
....................  
.................... ////////////////////global error bitfield errors for sending to manager 
.................... // unsolicited message not ack'd after max attempts 
.................... #define ERR_MSG_UNSOLICITED_MESSAGE_NOT_ACKD       0x00000001 
.................... // state incompatible with requested action 
.................... #define ERR_MSG_INCOMPATIBLE_STATE                 0x00000002 
.................... // valve calibration stale (activity depends on defines) 
.................... #define ERR_MSG_VLV_CAL_STALE                      0x00000004 
.................... //#define ERR_MSG_VLV_NOT_CALIBRATED                 0x00000004 
.................... // mote was unresponsive in system (busy likely) 
.................... #define ERR_MSG_MOTE_UNRESPONSIVE                  0x00000008 
.................... // rpm set point is too high to reach (no charging or braking and still no go) 
.................... #define ERR_MSG_RPM_TOO_HIGH_TO_REACH              0x00000010 
.................... // rpm is too low to reach (full charging, braking and still no go) 
.................... #define ERR_MSG_RPM_TOO_LOW_TO_REACH               0x00000020 
.................... // mote temperature is out of range (sleep) 
.................... #define ERR_MSG_MOTE_TEMP_OUT_OF_RANGE             0x00000040 
.................... // battery is low (warning) 
.................... #define ERR_MSG_BATT_LOW_WARN                      0x00000080 
.................... // battery is dead (going to sleep) 
.................... #define ERR_MSG_BATT_DEAD_SLEEP                    0x00000100 
.................... // valve calibration was invalid (too short) 
.................... #define ERR_MSG_VLV_CAL_FAIL                       0x00000200 
.................... // valve hit an endstop outside of the "closing when opened" etc. areas (close to the endstops) 
.................... #define ERR_MSG_VLV_MOVE_FAIL                      0x00000400 
.................... // not spinning condition detected, recovery attempt proceeding 
.................... #define ERR_MSG_NOT_SPINNING                       0x00000800 
.................... // magnetic decoupling condition detected, recovery attempt proceeding 
.................... #define ERR_MSG_MAG_DECOUPLING                     0x00001000                      
.................... // not spinning condition or magnetic decoupling condition recovery failed (going to sleep (another message afterwards)) 
.................... #define ERR_MSG_MAG_NOT_SPIN_RECOVERY_FAILED       0x00002000 
.................... // signal that system is in invalid state to do run command (e.g. cal vlv, recal vlv, fsr) 
.................... #define ERR_MSG_SPINKLER_CMD_DELAYED_INVALID_STATE 0x00004000    
.................... // signal that the mote is going to shutdown/sleep (or with another reason) 
.................... #define ERR_MSG_MOTE_GOING_TO_DEEP_SLEEP           0x80000000 
....................  
.................... /* 
.................... // message needs to be sent now! Disregard message waiting time. 
.................... #define ERR_MSG_HIGH_PRIORITY                    0x80000000 
.................... */ 
....................  
.................... ////////////////////NACK Bitfield Errors 
....................  
.................... // valve position not calibrated 
.................... #define NACK_BITFIELD_VLV_POSITION_UNKNOWN         0x00000001 
.................... // invalid valve setting requested 
.................... #define NACK_BITFIELD_INVALID_VLV_SETTING          0x00000002 
.................... // invalid rpm setting requested 
.................... #define NACK_BITFIELD_INVALID_RPM_SETTING          0x00000004 
.................... // invalid brake pwm setting requested 
.................... #define NACK_BITFIELD_INVALID_BRAKE_SETTING        0x00000008 
.................... // invalid charge pwm setting requested 
.................... #define NACK_BITFIELD_INVALID_CHARGE_SETTING       0x00000010 
.................... // state incompatible with requested action 
.................... #define NACK_BITFIELD_INCOMPATIBLE_STATE           0x00000020 
.................... // battery is too low for requested action 
.................... #define NACK_BITFIELD_BATT_TOO_LOW                 0x00000040 
.................... // don't have the required hardware for requested operation (e.g. gps, xdcr) 
.................... #define NACK_BITFIELD_INVALID_HARDWARE             0x00000080 
.................... // info recived during eeprom update is invalid (invalid range, number of bytes) 
.................... #define NACK_BITFIELD_INVALID_EEPROM_SETTINGS      0x00000100 
.................... // invalid mppc setting requested 
.................... #define NACK_BITFIELD_INVALID_MPPC_SETTING         0x00000200 
....................  
.................... ////////////////////get and send dustmsg_ISR Errors and pkdecode errors 
.................... // Where the errors start (for checking return values in deal_with_mote) 
.................... #define ERR_BAD_PAYLOAD                   249 
.................... #define ERR_DUSTMSG_START_OF_ERRORS       250 
.................... // CRC errors in pkdecode 
.................... #define ERR_DUSTMSG_CRC                   251 
.................... // Timeout on first byte 
.................... #define ERR_DUSTMSG_TIMEOUT               252 
.................... // RS232 errors from getc() 
.................... #define ERR_DUSTMSG_RS232                 253 
.................... // Framing Error 
.................... #define ERR_DUSTMSG_FRAMING_ERROR         254 
.................... // Message < 6 bytes (too short) 
.................... #define ERR_DUSTMSG_MESSAGE_LENGTH        255 
....................  
....................  
.................... #include "function_headers.h"                   
.................... //pic.h 
.................... void fosc_pri(void); 
.................... void fosc_pri_ISR(void); 
.................... void fosc_4m(void); 
.................... void fosc_1m(void); 
.................... void fosc_250k(void); 
.................... void fosc_250k_ISR(void); 
.................... void fosc_31250(void);  
.................... void fosc_31250_ISR(void);  
.................... void fosc_sec(void); 
.................... void osc_init(void); 
.................... void setup_T0_int(uint16_t value); 
.................... void setup_T2_int(uint8_t value); 
.................... void setup_T4_int(uint8_t value); 
.................... void periph_init(void); 
.................... void vars_init(void);      
.................... void deep_sleep(); 
.................... void start_rtc(void); 
.................... void safeI2C_start(void); 
.................... void safeI2C_write(uint8_t value);  
.................... void setup_rb4_int(void);                                   
.................... void write_system_state(uint8_t system_state_to_change_to);  
.................... uint8_t read_system_state(void);  
....................                                                               
.................... //eeprom.h 
.................... uint8_t read_ee1(uint16_t source); 
.................... uint16_t read_ee2(uint16_t source); 
.................... uint32_t read_ee4(uint16_t source); 
.................... void write_ee1(uint16_t dest, uint8_t dat8); 
.................... void write_ee2(uint16_t dest, uint16_t dat16); 
.................... void write_ee4(uint16_t dest, uint32_t dat32); 
.................... void store_all_eeprom_values(void);   
.................... void read_all_eeprom_values(void);                   
.................... void store_vcal_eeprom_values(void);   
.................... void read_all_eeprom_variables(void);                               
....................  
.................... //periph.h (LCD + XDCR)     
.................... //LCD declerations        
.................... void LCD_init(void); 
.................... void LCD_line1(unsigned char *text); 
.................... void LCD_line2(unsigned char *text); 
.................... void LCD_place_text(unsigned char *text, int1 row, uint8_t col, uint8_t length); 
.................... void LCD_place_char(char ascii, int1 row, uint8_t col); 
.................... void LCD_place_uint8(uint8_t num, int1 row, uint8_t col, uint8_t length); 
.................... void LCD_place_uint16(uint16_t num, int1 row, uint8_t col, uint8_t length); 
.................... void LCD_place_uint32(uint32_t num, int1 row, uint8_t col, uint8_t length); 
.................... void LCD_clear(void); 
.................... void LCD_clear_line1(void); 
.................... void LCD_clear_line2(void); 
.................... void LCD_position(int position); 
.................... void LCD_char(char ascii); 
.................... void LCD_shutdown(void); 
.................... void LCD_startup_splash(void); 
.................... void LCD_display_priority_time_stacks(void); 
.................... void LCD_display_priority_time_stacks_2(void); 
.................... void LCD_display_priority_queue(void);    
.................... void LCD_display_message_queue(void);  
.................... void LCD_display_battery_voltage(int1 lcd_line); 
.................... void LCD_display_batt_voltage(int1 lcd_line, uint8_t col, uint8_t precision); 
.................... void LCD_display_vgen(int1 lcd_line, uint8_t col, uint8_t precision); 
.................... void LCD_display_shutdown_cause(int1 lcd_line);    
.................... void LCD_update_diplay(void); 
.................... void XDCR_init(void);   
.................... void adc_XDCR_init(void); 
.................... uint16_t XDCR_measure(void);  
.................... uint16_t adc_XDCR_measure(void);     
.................... void fixture_init(void); 
....................  
.................... //dust.h 
.................... void mote_init(void); 
.................... void mote_reset(void); 
.................... uint8_t mote_sleep(void); 
.................... void search_for_strongest(void); 
.................... void process_advert(void); 
.................... uint8_t initiate_join(void); 
.................... void mote_state_check(void);   
.................... void mote_info_check(void); 
.................... void mote_temp_check(void); 
.................... void mote_time_update(void);   
.................... void get_mote_net_info(void); 
.................... void init_msgSEQ(void); 
.................... void deal_with_mote_ISR(void); 
.................... uint8_t get_dustmsg_ISR(void); 
.................... void  dust_hdlc_pkgen(uint8_t* prefix, uint8_t size, uint8_t* buf, uint8_t size_buf); 
.................... void  dust_hdlc_pkgen_ISR(uint8_t* prefix, uint8_t size, uint8_t* buf, uint8_t size_buf); 
.................... uint8_t dust_hdlc_pksend(); 
.................... uint8_t dust_hdlc_pksend_ISR(); 
.................... uint8_t dust_hdlc_pkdecode_ISR(uint8_t bytes_to_decode); 
.................... uint16_t fcs_fcs16(uint16_t fcs, uint8_t data); 
.................... uint16_t fcs_fcs16_ISR(uint16_t fcs, uint8_t data); 
.................... static uint16_t fcs_calc(uint8_t* p, uint16_t size); 
.................... static uint16_t fcs_calc_ISR(uint8_t* p, uint16_t size); 
.................... uint8_t deal_with_packet(void); 
.................... void prepare_prefix_and_payload(uint8_t payload_buf_length); 
.................... void prepare_prefix_and_payload_ISR(uint8_t payload_buf_length); 
.................... void generate_message_and_send(); 
.................... void generate_message_and_send_ISR(); 
.................... void send_full_report(uint8_t command_id_in_response_to, uint16_t msg_seq); 
.................... void send_health_report(uint8_t command_id_in_response_to, uint16_t msg_seq); 
.................... void send_valve_report(uint8_t command_id_in_response_to, uint16_t msg_seq); 
.................... void send_sprinkler_cmd_response(uint8_t command_id_in_response_to, uint16_t msg_seq); 
.................... void send_update_sp_num_response(uint8_t command_id_in_response_to, uint16_t msg_seq); 
.................... void send_read_eeprom_response(uint8_t command_id_in_response_to, uint16_t msg_seq, uint16_t eeprom_location, uint32_t eeprom_data);  
.................... void send_pressure_xdcr_msg(uint8_t command_id_in_response_to, uint16_t msg_seq);  
.................... void send_ack(uint8_t command_id_in_response_to, uint16_t msg_seq); 
.................... void send_nack(uint8_t command_id_in_response_to, uint16_t msg_seq, uint32_t nack_bitfield); 
.................... void send_full_report_ISR(uint8_t command_id_in_response_to, uint16_t msg_seq); 
.................... void send_health_report_ISR(uint8_t command_id_in_response_to, uint16_t msg_seq); 
.................... void send_valve_report_ISR(uint8_t command_id_in_response_to, uint16_t msg_seq); 
.................... void send_join_msg_ISR(uint8_t command_id_in_response_to, uint16_t msg_seq); 
.................... void send_gps_point_msg_ISR(uint8_t command_id_in_response_to, uint16_t msg_seq); 
.................... void send_pressure_xdcr_msg_ISR(uint8_t command_id_in_response_to, uint16_t msg_seq);  
.................... void send_error_msg_ISR(uint8_t command_id_in_response_to, uint16_t msg_seq); 
....................  
.................... //util.h 
.................... void flash_leds(uint8_t num_of_flashes); 
.................... void flash_leds_ISR(uint8_t num_of_flashes);    
.................... void flash_led_1(uint8_t num_of_flashes);     
.................... void flash_led_2(uint8_t num_of_flashes); 
.................... void happy_lites(void); 
.................... char *word_to_4dig_new (uint16_t xword); 
.................... uint16_t convert_rpm_to_period(uint16_t rpm); 
.................... uint16_t convert_period_to_rpm(uint16_t period); 
.................... uint16_t convert_period_to_rpm_ISR(uint16_t period); 
.................... uint8_t  hi2asc(uint8_t xbyte); 
.................... uint8_t  lo2asc(uint8_t xbyte); 
....................  
.................... //stacks_queues.h 
.................... void clear_priority_queue();       
.................... uint8_t pop_priority_queue(); 
.................... int1 push_priority_queue(uint8_t new_priority_queue_item); 
.................... void push_priority_queue_ISR(uint8_t new_priority_queue_item); 
.................... void clear_time_queue(); 
.................... int1 pop_time_queue();  
.................... void pop_time_queue_ISR(); 
.................... int1 push_time_queue(uint32_t time_to_execute, uint8_t priority); 
.................... void push_time_queue_ISR(uint32_t time_to_execute, uint8_t priority); 
.................... void allocate_command_queue(void); 
.................... void clear_command_queue(void); 
.................... int1 push_command_queue(struct CommandQueueItem new_command_queue_item); 
.................... void pop_command_queue_ISR();   
.................... void clear_sprinkler_queue(void); 
.................... void push_sprinkler_queue(uint32_t start_time,uint32_t end_time,uint16_t vlv_open_amount,uint16_t spin_rate,uint8_t zone_num, uint8_t control_loop_mechanism); 
.................... void pop_sprinkler_queue_ISR(void);     
.................... void clear_message_queue(void);   
.................... void pop_message_queue_and_send_ISR(void); 
.................... void push_message_queue(uint8_t message_type); 
.................... void push_message_queue_ISR(uint8_t message_type); 
.................... void remove_message_queue_item(uint16_t msg_seq); 
.................... void remove_message_queue_item_ISR(uint16_t msg_seq); 
....................                                              
.................... //control.h 
.................... void setup_gen_rpm(void); 
.................... uint16_t calc_gen_rpm(void);                           
.................... int1  is_brake_duty_valid(uint16_t value); 
.................... int1  is_charge_duty_valid(uint16_t value); 
.................... int1  is_mppc_valid(uint8_t value); 
.................... int1  is_rpm_setting_valid(uint16_t value); 
.................... void set_brake_duty(uint16_t value); 
.................... void set_charge_duty(uint16_t value);                                  
.................... void set_mppc(uint8_t value); 
.................... void set_fixture_dac(uint16_t dac_value); 
.................... void adjust_brake_for_rpm(uint16_t rpm_set_value); 
.................... void adjust_brake_for_vgen(uint16_t vgen_set_value); 
.................... void adjust_fixture_for_rpm(uint16_t fixture_set_value); 
.................... void adjust_mppc(void);      
.................... uint8_t calc_mppc_by_vgen(void); 
.................... void update_control_loop(void); 
.................... void stop_current_spinkler_setting(void); 
.................... void stop_current_spinkler_setting_ISR(void); 
....................  
.................... //battery.h      
.................... uint16_t get_vbatt(int1 charge_state); 
.................... uint16_t get_vbatt_ISR(int1 charge_state); 
.................... uint16_t get_vgen(int1 charge_state); 
.................... uint16_t get_vgen_ISR(int1 charge_state); 
.................... uint16_t calc_vbatt_BCD(uint16_t vref_count); 
.................... uint16_t calc_vgen_BCD(uint16_t vref_count); 
.................... void check_and_deal_with_battery(void);        
....................  
.................... //valve.h 
.................... void  comparator_setup(void); 
.................... uint16_t calc_valve_movement_time(uint16_t current_location, uint16_t destination); 
.................... void  set_comp_dac_level(void); 
.................... void  set_comp_dac_level_ISR(void); 
.................... int1  is_valve_position_valid(uint16_t value); 
.................... int1  is_valve_value_full_open_or_close(uint16_t value); 
.................... int1 is_valve_value_full_open_or_close(uint16_t value); 
....................  
.................... #include "jack_dn2500.h" 
.................... /* 
....................  * $HeadURL: https://svn/appeng/trunk/dev/src/api/dust_dn2500.h $ 
....................  * $Id: dust_dn2500.h 261 2010-02-19 23:34:29Z kottaway $ 
....................  * 
....................  * Copyright (c) 2006, Dust Networks, Inc 
....................  * All rights reserved. 
....................  * Redistribution and use in source and binary forms, with or without 
....................  * modification, are permitted provided that the following conditions are met: 
....................  * 
....................  *     * Redistributions of source code must retain the above copyright 
....................  *       notice, this list of conditions and the following disclaimer. 
....................  *     * Redistributions in binary form must reproduce the above copyright 
....................  *       notice, this list of conditions and the following disclaimer in the 
....................  *       documentation and/or other materials provided with the distribution. 
....................  *     * Neither the name of Dust Networks, Inc nor the 
....................  *       names of its contributors may be used to endorse or promote products 
....................  *       derived from this software without specific prior written permission. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED BY DUST NETWORKS, INC AND CONTRIBUTORS "AS IS" AND ANY 
....................  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
....................  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
....................  * DISCLAIMED. IN NO EVENT SHALL DUST NETWORKS, INC AND CONTRIBUTORS BE LIABLE FOR ANY 
....................  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
....................  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
....................  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND 
....................  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
....................  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
....................  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  
....................  * 
....................  * This documentation might include technical inaccuracies or other errors.  
....................  * Corrections and improvements might be incorporated in new versions of the  
....................  * documentation. Dust Networks does not assume any liability arising out of  
....................  * the application or use of any products or services and specifically disclaims  
....................  * any and all liability, including without limitation consequential or incidental damages. 
....................  * 
....................  *  
....................  * 
....................  * Dust Networks reserves the right to make corrections, modifications, enhancements, 
....................  * improvements, and other changes to its products or services at any time and to  
....................  * discontinue any product or service without notice. Customers should obtain the  
....................  * latest relevant information before usage and should verify that such information  
....................  * is current and complete. 
....................  */ 
....................   
....................  // NOTE THAT THIS FILE WAS UPDATED TO INCLUDE THE SEARCH capability 
....................  //  now included in the Eterna parts (JG June 2013) 
....................  
.................... /* Max user data size.  This limit is specific to the  
....................  * amount of data that can be sent via radio to/from the Manager. 
....................  * This is not an HDLC limit which might include byte stuffing. 
....................  */ 
.................... #define MAX_USER_DATA_SIZE       94 
....................  
.................... // prior to encoding for transmission 
.................... // cmd(1), len_pkt(1), flags(1), destaddr(2), svc_index(1), appdomain(1), 
.................... // priority(1), reserved(2), sequence_num(1), len_data(1), MAX_USER_DATA_SIZE 
.................... #define MAX_SEND_REQUEST         MAX_USER_DATA_SIZE + 12 
....................  
.................... // include now the delimiters (2), the FCS (w/ byte stuffing could be 4), 
.................... //  of the 12 bytes added above, there may be an extra 2 due to byte stuffing 
.................... //  and the message can be MAX_USER_DATA_SIZE*2 worst case! 
.................... #define MAX_SEND_BUFFER          MAX_USER_DATA_SIZE*2 + 2 + 4 + 12 + 2 
.................... // This adds up to 208! 
....................  
.................... // after decoding the received message 
.................... // cmd(1), len_pkt(1), flags(1), sourceaddr(2), sequence_num(1), len_data(1),  
.................... // MAX_USER_DATA_SIZE 
.................... #define MAX_DATA_RCVD            MAX_USER_DATA_SIZE + 7 
....................  
.................... // prior to decoding, raw rcv data 
.................... // include delimiters (2), the FCS (4 max), of the 7 bytes above there may be 
.................... //  an extra stuffed byte, and the message can be MAX_USER_DATA_SIZE*2! 
.................... #define MAX_RCV_BUFFER           MAX_USER_DATA_SIZE*2 + 2 + 4 + 7 + 1 
.................... // This adds up to 202 
....................   
.................... #define MAX_JOINKEY_SIZE         16 
....................  
.................... #define MAX_BURST_MESSAGE        3 
....................  
.................... #define DESTADDR_GATEWAY         0xF981 
.................... #define DESTADDR_SWAPPED         0x81F9 
.................... #define DESTADDR_HI              0xF9 
.................... #define DESTADDR_LO              0x81 
....................  
.................... // Microprocessor to Mote Commands 
.................... #define CMD_SET            0x01     // Sets param on the mote. 
.................... #define CMD_GET            0x02     // Gets param from mote 
.................... #define CMD_SETNV          0x03     // Stores param in the motes NV 
.................... #define CMD_GETNV          0x04     // Retrieves param from the motes NV 
.................... #define CMD_SEND           0x05     // Packet destined for the network. 
.................... #define CMD_JOIN           0x06     // Requests that mote attempt to join 
.................... #define CMD_DISCONNECT     0x07     // Requests that mote disconnect 
.................... #define CMD_RESET          0x08     // Resets mote. 
.................... #define CMD_SLEEP          0x09     // Shuts down periphs & puts mote to sleep 
.................... #define CMD_TESTRADIOTX    0x0B     // Initiate a series of packet transmissions. 
.................... #define CMD_TESTRADIORX    0x0C     // Test radio reception for a specified chan. 
.................... #define CMD_CLEARNV        0x10     // Resets the motes NV to factory default.. 
.................... #define CMD_SEARCH         0x11     // new Search for networks capability 
....................                                     // (Eterna parts) 
....................  
.................... // Mote to Microprocessor Commands 
.................... #define CMD_TIME           0x0D     // Time and mote state information. 
.................... #define CMD_SERVICE        0x0E     // Notifies micro of changes in service stat. 
.................... #define CMD_EVENT          0x0F     // Notifies micro of new has occurred. 
.................... #define CMD_ADVERT         0x12     // Notifies micro that an adv has been rcvd. 
.................... #define CMD_DATA           0x81     // Packet from the network to the micro. 
....................  
....................  
.................... // Result Codes 
.................... #define RC_OK              0x00     // Operation was successfully completed. 
.................... #define RC_EXE_ERR         0x01     // Reserved. 
.................... #define RC_PARAM_ERR       0x02     // Reserved. 
.................... #define RC_BUSY            0x03     // Operation on this service is in progress. 
.................... #define RC_INVALID_LEN     0x04     // Invalid packet length. 
.................... #define RC_INV_STATE       0x05     // Invalid mote state for command. 
.................... #define RC_UNSUPPORTED     0x06     // Command not supported for hardware. 
.................... #define RC_UNKNOWN_PARAM   0x07     // Unknown parameter value. 
.................... #define RC_UNKNOWN_CMD     0x08     // Unknown command. 
.................... #define RC_WRITE_FAIL      0x09     // Write failure. 
.................... #define RC_READ_FAIL       0x0A     // Read failure. 
.................... #define RC_LOW_VOLTAGE     0x0B     // Voltage check failed. 
.................... #define RC_NO_RESOURCES    0x0C     // No resources (max # services active) 
.................... #define RC_INCOMPLETE_JOIN 0x0D     // Incomplete join information. 
.................... #define RC_NOT_FOUND       0x0E     // Parameter not found. 
.................... #define RC_INVALID_VALUE   0x0F     // Invalid value. 
....................  
....................  
.................... // Parameter Types 
.................... #define PARAM_MACADDR      0x01     // setNV, getNV 
.................... #define PARAM_JOINKEY      0x02     // setNV 
.................... #define PARAM_NETWORKID    0x03     // setNV, getNV 
.................... #define PARAM_TXPOWER      0x04     // set, setNV, getNV 
.................... #define PARAM_POWERINFO    0x05     // setNV, getNV 
.................... #define PARAM_JOINDUTY     0x06     // set 
....................                                     // Allows micro to control  ratio of listen 
....................                                     //  to sleep time during network search 
.................... #define PARAM_BATTLIFE     0x07     // set 
....................                                     // Allows micro to update the remaining  
....................                                     //  battery life that mote reports to mgr 
.................... #define PARAM_SERVICE      0x08     // set. get  
....................                                     // Allows device to initiate service request 
....................                                     //  or update an existing svc 
.................... #define PARAM_SPECIAL1     0x08     // setnv for special join timing, 1st param 
.................... #define PARAM_SPECIAL2     0x09     // setnv for special join timing, 2nd param 
.................... #define PARAM_EVENTMASK    0x0B     // set 
....................                                     // Allows micro to disable events that may  
....................                                     //  be sent in the mote's event notification 
.................... #define PARAM_MOTEINFO     0x0C     // get 
....................                                     // Gets static info about mote hw and sw 
.................... #define PARAM_NETWORKINFO  0x0D     // get 
....................                                     // Gets mote's current net-related params 
.................... #define PARAM_MOTESTATUS   0x0E     // get 
....................                                     // Gets  mote's state and  
....................                                     //  frequently changing information. 
.................... #define PARAM_TIME         0x0F     // get 
.................... #define PARAM_CHARGE       0x10     // get 
....................                                     // Gets  mote's charge consumption. 
.................... #define PARAM_RADIOSTATSRX 0x11     // get 
....................                                     // Gets results of the mote radio rx test 
.................... #define PARAM_TTL          0x13     // get 
....................                                     // Gets "time to live" 
.................... #define PARAM_OTAPLOCK     0x15     // setNV, getNV 
....................                                     // Over-the-air-programming lockout control 
....................  
....................  
.................... // re get service: Service State - note Bit7=0 for no service pending 
.................... //                                          Bit7=1 for service pending 
.................... #define SVCSTATE_INACTIVE        0x00 
.................... #define SVCSTATE_ACTIVE          0x01 
.................... #define SVCSTATE_REQUESTED       0x02 
....................  
.................... // re get/set service: Service Request Flags Bitmask Values 
.................... #define SVCFLAGS_SOURCE          0x01     // Mote is source of data generated. 
.................... #define SVCFLAGS_SINK            0x02     // Mote is receiver of data. 
.................... #define SVCFLAGS_INTERMITTENT    0x04     // Intermittent traffic  
....................                                           //  (as opposed to regular reporting). 
....................  
.................... // Application domain values 
.................... #define APPDOMAIN_PUBLISH        0x00 
.................... #define APPDOMAIN_EVENT          0x01  
.................... #define APPDOMAIN_MAINTENANCE    0x02  
.................... #define APPDOMAIN_BLOCKXFER      0x03 
....................  
.................... // Mote Status values 
.................... #define MOTESTATE_INIT           0x00     // Mote is  booting. 
.................... #define MOTESTATE_IDLE           0x01     // Mote is accepting config cmds.   
....................                                           //  Upon receiving a join cmd, mote  
....................                                           //  moves into the Searching state. 
....................                                           //  Idle state is low power state. 
.................... #define MOTESTATE_SEARCHING      0x02     // Motes rcvr is on with a  
....................                                           //  configurable duty cycle while 
....................                                           //  mote is actively searching for net.  
.................... #define MOTESTATE_NEGOTIATING    0x03     // Mote has detected a network  
....................                                           //  and is attempting to connect. 
.................... #define MOTESTATE_CONNECTED      0x04     // Mote has joined the net 
.................... #define MOTESTATE_OPERATIONAL    0x05     // Mote has links to both net mgr and 
....................                                           //  gateway; ready to send data. 
.................... #define MOTESTATE_DISCONNECTED   0x06     // Mote is disconnected. 
.................... #define MOTESTATE_RADIOTEST      0x07 
.................... #define MOTESTATE_PROMISCUOUS    0x08 
.................... #define MOTESTATE_UNKNOWN        0xFF 
....................  
.................... // mote alarms bit masks 
.................... #define ALARMS_NVERROR           0x01        // Non-volatile error. 
.................... #define ALARMS_LOW_VOLTAGE       0x02        // Mote voltage too low. 
.................... #define ALARMS_OTP               0x04        // One time programmable error 
....................  
....................  
.................... // re get POWERINFO: power source values 
.................... #define PWRSOURCE_LINE           0x00 
.................... #define PWRSOURCE_BATTERY        0x01 
.................... #define PWRSOURCE_SCAVENGE       0x02 
....................  
.................... // re set/get txpower 
.................... #define TXPOWER_MIN              -2       // minimum power; PA off*/ 
.................... #define TXPOWER_MAX              +8       // maximum power; PA on 
....................  
.................... // serviceIndication event codes 
.................... #define SVC_CREATED_UPDATED      0x00 
.................... #define SVC_DELETED              0x01 
.................... #define SVC_REJECTED             0x02 
.................... #define SVC_DELAYED_RESP         0x03 
....................  
.................... // serviceIndication Network Manager Codes 
.................... #define MGRCODE_SUCCESS             0     // no errors 
.................... #define MGRCODE_PARAM_TOOSMALL      4     // ERR: passed param too small 
.................... #define MGRCODE_BYTES_TOOFEW        5     // ERR: too few data bytes rcvd 
.................... #define MGRCODE_DEVICE_ERR          6     // ERR: device-specific cmd error 
.................... #define MGRCODE_SETNEAREST          8     // WARN: set to nearest possible val 
.................... #define MGRCODE_RESTRICTED          16    // ERR: access restricted 
.................... #define MGRCODE_BUSY                32    // ERR: network manager is busy  
.................... #define MGRCODE_DELAYED_ATTEMPT     33    // ERR: delayed response initiated 
....................                                           //      mgr will attempt to add links 
.................... #define MGRCODE_DENIED              65    // ERR: service request denied 
.................... #define MGRCODE_UNKNOWN_SVC         66    // ERR: unknown service flag 
.................... #define MGRCODE_UNKNOWN_APPDOMAIN   67    // ERR: unknown application domain 
.................... #define MGRCODE_UNKNOWN_NICKNAME    68    // ERR: unknown nickname 
....................  
.................... // re set batteryLife 
.................... #define PWRSTAT_NOMINAL             0x00 
.................... #define PWRSTAT_LOW                 0x01 
.................... #define PWRSTAT_CRIT_LOW            0x02 
.................... #define PWRSTAT_RECHARG_LOW         0x03 
.................... #define PWRSTAT_RECHARG_HIGH        0x04 
....................  
.................... #define BOOT_EVENT               0x01010101  // & with new_events_rcvd to 
....................                                              //  determine if boot event 
....................                                              //  occurred 
.................... #define ALARMS_EVENT             0x02020202 
.................... #define TIME_EVENT               0x04040404  // & with new_events_rcvd to 
....................                                              //  determine if UTC time ref 
....................                                              //  from mote has changed 
.................... #define JOIN_FAIL_EVENT          0x08080808 
.................... #define DISCONNECTED_EVENT       0x10101010 
.................... #define OPERATIONAL_EVENT        0x20202020  // mote has gateway to send data 
.................... #define CONFIG_EVENT             0x40404040 
....................  
....................  
.................... // EVENTMASK bit definitions 
.................... #define EVENTMASK_BOOT           0x01        // Mote booted up. 
.................... #define EVENTMASK_ALARMS         0x02        // Value of alarms field changed. 
.................... #define EVENTMASK_TIMECHANGE     0x04        // UTC time reference changed.     
.................... #define EVENTMASK_JOINFAIL       0x08        // Join operation failed. 
.................... #define EVENTMASK_DISCONNECT     0x10        // Mote has disconnected. 
.................... #define EVENTMASK_OPERATIONAL    0x20        // Mote has gateway to send data. 
.................... #define EVENTMASK_CONFIG         0x40        // Write has changed mote config. 
....................  
.................... //  
.................... // #define WRITEPROTECT_DISABLED    0x0         // bit 0 only 
.................... // #define WRITEPROTECT_ENABLED     0x1         // bit 0 only 
.................... // #define WRITEPROTECT_MASK        0x1 
....................  
.................... // FLAG bit masks & defines 
.................... //#define FLAG_TYPE_MASK          0x01 
.................... #define FLAG_TYPE_REQUEST           0x04     // from micro to mote re get/set 
....................                                              //  and re join, reset, etc 
.................... #define FLAG_TYPE_REQUEST2          0x05 
.................... #define FLAG_SEND_REQUEST           0x04     // from micro to mote with send 
....................                                              //  request only 
.................... #define FLAG_TYPE_TEST              0x00     // from micro to mote re 
....................                                              //  testradiorx and testradiotx 
.................... #define FLAG_MOTE_INDICATION        0x00     // from mote to micro re 
....................                                              //  indications: event, service, 
....................                                              //  time 
.................... #define FLAG_TYPE_RESPONSE          0x01 
.................... #define FLAG_MOTECMD_RESPONSE       0x05     // from mote to micro after 
....................                                              //  micro-initiated command 
....................                                              //  e.g. join, reset, send 
.................... #define FLAG_MICROIND_RESPONSE      0x05     // from micro to mote after 
....................                                              //  mote indication to micro 
....................                                              //  time/service/event/data 
.................... #define FLAG_SET_RESPONSE           0x05     // from mote to micro after set 
.................... #define FLAG_GET_RESPONSE           0x05     // from mote to micro after get 
....................                                              //  TEST THIS 
....................  
.................... #define FLAG_ID                     0x02 
.................... #define FLAG_ID_IGNORE              0x04 
.................... #define FLAG_END2END_RESPONSE       0x80 
.................... #define FLAG_TRANSPORT_TYPE_MASK    0x40 
....................  
....................  
.................... #define FLAG_NV_ONLY                   ~0x80 
.................... #define FLAG_NV_RAM                    0x80 
....................  
....................  
.................... // #define WRITE_PROTECT_MODE_OFF     0x00 // write allowed 
.................... // #define WRITE_PROTECT_MODE_ON      0x01 // write not allowed 
....................  
.................... // packet priorities 
.................... #define PRIORITY_LOW    0x00 
.................... #define PRIORITY_MED    0x01 
.................... #define PRIORITY_HI     0x02 
....................  
.................... // Pack on one byte boundaries because we "type cast" the data structures 
.................... //  to a destination buffer (array of bytes). 
....................  
.................... /*  
.................... //Structure Declarations 
.................... #define DUST_DN2500_HEADER  \ 
....................     uint8_t cmd;     \ 
....................     uint8_t len_pkt; \ 
....................     uint8_t flags; 
....................  
....................  
.................... // A structure defined like this represents the first 4 bytes of  
.................... //  send, join, disconnect, reset, sleep, testradioTX/RX, clearNV  
.................... //  (cmd types 5,6,7,8,9,B,C,10) 
.................... #define DUST_DN2500_HEADER_RESPONSE    \ 
....................     uint8_t cmd;     \ 
....................     uint8_t len_pkt; \ 
....................     uint8_t flags;   \ 
....................     uint8_t result; 
....................      
.................... // A structure defined like this represents the first 4 bytes of all  
.................... //  set, get, setNV, getNV responses (cmd types 1,2,3,4) 
.................... #define DUST_DN2500_PARAM_RESPONSE  \ 
....................     uint8_t cmd;     \ 
....................     uint8_t len_pkt; \ 
....................     uint8_t flags;   \ 
....................     uint8_t result;  \ 
....................     uint8_t parameter_type;        /* DUST_DN2500_CMD_[SET|GET]_PARAM_*  
.................... */ 
....................  
.................... typedef union _mote_to_micro 
.................... // cmd types 1,2,3,4;  5,6,7,8,9,B,C,10;  D,E,F,81 
.................... // get/set; send/join/discon/reset/sleep/testradio/clrNV;  time/svc/event/data  
.................... { 
....................    char      dust_rcvd[MAX_DATA_RCVD];    // THIS is the buffer for unstuffed 
....................                                           //  stripped received data 
....................    struct _set_param_response 
....................    // for set txPower, joinDutyCycle, batteryLife, eventMask 
....................    // for setNV macAddress, networkID, txPower, joinKey, powerInfo, OTAPlockout 
....................    //  and special1 and special2 
....................    // Mote response to micro after most set and setNV commands 
....................    { 
....................       uint8_t     cmd;                 // CMD_SET or CMD_SETNV 
....................       uint8_t     len_pkt;             // always 0x01   
....................       uint8_t     flags;               // expect FLAG_SET_RESPONSE 
....................       uint8_t     result;              // RC_* 
....................       uint8_t     param_type;          // PARAM_TXPOWER, PARAM_JOINTDUY, (set) 
....................                                        // PARAM_BATTLIFE, PARAM_EVENTMASK (set) 
....................                                        // PARAM_MACADDR, PARAM_NETWORKID, (setNV) 
....................                                        // PARAM_TXPOWER, PARAM_JOINKEY, (setNV)  
....................                                        // PARAM_POWERINFO, PARAM_OTAPLOCK (setNV) 
....................                                        // PARAM_SPECIAL1, PARAM_SPECIAL2 
....................    }  set_param_response; 
....................     
....................    struct _set_service_response 
....................    // Mote respnse to micro after set service ONLY 
....................    { 
....................       uint8_t     cmd;                 // CMD_SET 
....................       uint8_t     len_pkt;             // always 0x02 
....................       uint8_t     flags;               // expect FLAG_SET_RESPONSE 
....................       uint8_t     result;              // RC_* 
....................       uint8_t     param_type;          // PARAM_SERVICE 
....................       uint8_t     rem_svc_entries; 
....................    }  set_service_response; 
....................     
....................     struct _get_service_response  
....................    { 
....................       uint8_t     cmd;                 // CMD_GET 
....................       uint8_t     len_pkt;             // always 0x0B 
....................       uint8_t     flags;               // expect FLAG_GET_RESPONSE 
....................       uint8_t     result;              // RC_* 
....................       uint8_t     param_type;          // PARAM_SERVICE 
....................       uint8_t     svc_index; 
....................       uint8_t     svc_state;           // SVCSTATE_* 
....................       uint8_t     svc_flags;           // SVCRQST_* 
....................       uint8_t     app_domain;          // APPDOMAIN_* 
....................       uint16_t    destaddr;            // always 0xF981 
....................       uint32_t    time;                // Period/latency: intermittent flag set 
....................    } get_service_response; 
....................     
....................    struct _get_moteinfo_response  
....................    { 
....................       uint8_t     cmd;                 // CMD_GET 
....................       uint8_t     len_pkt;             // always 0x11 
....................       uint8_t     flags;               // expect FLAG_GET_RESPONSE 
....................       uint8_t     result;              // RC_* 
....................       uint8_t     param_type;          // PARAM_MOTEINFO 
....................       uint8_t     api_version; 
....................       uint8_t     serial_number[8]; 
....................       uint8_t     hw_model; 
....................       uint8_t     hw_version; 
....................       uint8_t     sw_major_ver; 
....................       uint8_t     sw_minor_ver; 
....................       uint8_t     sw_patch; 
....................       uint16_t    sw_build; 
....................    }  get_moteinfo_response; 
....................  
....................    struct _get_networkinfo_response 
....................    { 
....................       uint8_t     cmd;                 // CMD_GET 
....................       uint8_t     len_pkt;             // always 0x0D 
....................       uint8_t     flags;               // expect FLAG_GET_RESPONSE 
....................       uint8_t     result;              // RC_* 
....................       uint8_t     param_type;          // PARAM_NETWORKINFO 
....................       uint8_t     macaddr[8]; 
....................       uint16_t    mote_id; 
....................       uint16_t    network_id; 
....................    }  get_networkinfo_response; 
....................  
....................    struct _get_motestatus_response 
....................    { 
....................       uint8_t     cmd;                 // CMD_GET 
....................       uint8_t     len_pkt;             // always 0x0B 
....................       uint8_t     flags;               // expect FLAG_GET_RESPONSE 
....................       uint8_t     result;              // RC_* 
....................       uint8_t     param_type;          // PARAM_MOTESTATUS 
....................       uint8_t     mote_state;          // MOTESTATE_* 
....................       uint8_t     mote_state_reason;   // Reserved -- ignore 
....................       uint16_t    change_counter; 
....................       uint8_t     number_of_parents; 
....................       uint32_t    mote_alarms;         // ALARMS_* 
....................       uint8_t     reserved; 
....................    }  get_motestatus_response; 
....................  
....................    struct _get_time_response 
....................    { 
....................       uint8_t     cmd;                 // CMD_GET 
....................       uint8_t     len_pkt;             // always 0x10 
....................       uint8_t     flags;               // expect FLAG_GET_RESPONSE 
....................       uint8_t     result;              // RC_* 
....................       uint8_t     param_type;          // PARAM_TIME 
....................       uint32_t    utc_sec; 
....................       uint32_t    utc_usec; 
....................       uint8_t     asn[5];              // Absolute Slot No. (10msec slots since 
....................                                        //  boot). 
....................       uint16_t    asn_offset;          // usec into current slot number  
....................    }  get_time_response; 
....................     
....................    struct _get_charge_response 
....................    { 
....................       uint8_t     cmd;                 // CMD_GET 
....................       uint8_t     len_pkt;             // always 0x0B 
....................       uint8_t     flags;               // expect FLAG_GET_RESPONSE 
....................       uint8_t     result;              // RC_* 
....................       uint8_t     param_type;          // PARAM_CHARGE 
....................       uint32_t    charge_mC;           // charge since last reset 
....................       uint32_t    uptime_sec;          // uptime since last reset 
....................       int8_t      temp_celsius; 
....................       uint8_t     temp_frac_celsius;   // Temperature in 1/255 of Celsius 
....................    }  get_charge_response; 
....................     
....................    struct _get_testrx_response 
....................    { 
....................       uint8_t     cmd;                 // CMD_GET 
....................       uint8_t     len_pkt;             // always 0x05 
....................       uint8_t     flags;               // expect FLAG_GET_RESPONSE 
....................       uint8_t     result;              // RC_* 
....................       uint8_t     param_type;          // PARAM_RADIOSTATSRX 
....................       uint16_t    num_of_received_packets; 
....................       uint16_t    num_of_recep_failures; 
....................    }  get_testrx_response; 
....................   
....................    struct _getNV_macaddr_response 
....................    { 
....................       uint8_t     cmd;                 // CMD_GETNV 
....................       uint8_t     len_pkt;             // always 0x09 
....................       uint8_t     flags;               // expect FLAG_GET_RESPONSE 
....................       uint8_t     result;              // RC_* 
....................       uint8_t     param_type;          // PARAM_MACADDR 
....................       uint8_t     macaddr[8]; 
....................    }  getNV_macaddr_response; 
....................     
....................    struct _getNV_networkid_response 
....................    { 
....................       uint8_t     cmd;                 // CMD_GETNV 
....................       uint8_t     len_pkt;             // always 0x03 
....................       uint8_t     flags;               // expect FLAG_GET_RESPONSE 
....................       uint8_t     result;              // RC_NETWORKID 
....................       uint8_t     param_type;          // PARAM_NETWORKID 
....................       uint16_t    network_id; 
....................    }  getNV_networkid_response; 
....................     
....................    struct _getNV_txpower_response 
....................    { 
....................       uint8_t     cmd;                 // CMD_GETNV 
....................       uint8_t     len_pkt;             // always 0x02 
....................       uint8_t     flags;               // expect FLAG_GET_RESPONSE 
....................       uint8_t     result;              // RC_* 
....................       uint8_t     param_type;          // PARAM_TXPOWER 
....................       uint8_t     txpower; 
....................    }  getNV_txpower_response; 
....................     
....................    struct _getNV_powerinfo_response 
....................    { 
....................       uint8_t     cmd;                 // CMD_GETNV 
....................       uint8_t     len_pkt;             // always 0x0C 
....................       uint8_t     flags;               // expect FLAG_GET_RESPONSE 
....................       uint8_t     result;              // RC_* 
....................       uint8_t     param_type;          // PARAM_POWERINFO 
....................       uint8_t     power_source;        // PWRSOURCE_* 
....................       uint16_t    discharge_current_uA; 
....................       uint32_t    discharge_time_sec; 
....................       uint32_t    recharge_time_sec;     
....................    }  getNV_powerinfo_response; 
....................  
....................    struct _getnv_otaplock_response 
....................    { 
....................       uint8_t     cmd;                 // CMD_GETNV 
....................       uint8_t     len_pkt;             // always 0x02 
....................       uint8_t     flags;               // expect FLAG_GET_RESPONSE 
....................       uint8_t     result;              // RC_* 
....................       uint8_t     param_type;          // PARAM_OTAPLOCK 
....................       uint8_t     otaplock; 
....................    }  getnv_otaplock_response; 
....................     
....................    struct _cmd_response 
....................    { 
....................       uint8_t     cmd;                 // CMD_SEND, CMD_JOIN, 
....................                                        // CMD_DISCONNECT, CMD_RESET 
....................                                        // CMD_SLEEP, CMD_TESTRADIOTX, 
....................                                        // CMD_TESTRADIORX, CMD_CLEARNV 
....................       uint8_t     len_pkt;             // always 0x00 
....................       uint8_t     flags;               // always FLAG_MOTECMD_RESPONSE 
....................       uint8_t     result;              // RC_* 
....................    }  cmd_response; 
....................     
....................    struct _time_indication 
....................    // this is what you get from mote when you toggle _DUST_TIME 
....................    { 
....................       uint8_t     cmd;                 // CMD_TIME 
....................       uint8_t     len_pkt;             // always 0x0F 
....................       uint8_t     flags;               // See tables 98 and 1***************** 
....................       uint32_t    utc_sec; 
....................       uint32_t    utc_usec; 
....................       uint8_t     asn[5];              // Absolute Slot No. (10msec slots since 
....................                                        //  boot. 
....................       uint16_t    asn_offset;          // usec into current slot number 
....................    }  time_indication; 
....................     
....................    struct _service_indication 
....................    { 
....................       uint8_t     cmd;                 // CMD_SERVICE 
....................       uint8_t     len_pkt;             // always 0x0C 
....................       uint8_t     flags;               // See tables 98 and 1***************** 
....................       uint8_t     event_code;          // SVC_* 
....................       uint8_t     mgr_code;            // MGRCODE_* 
....................       uint8_t     svc_index; 
....................       uint8_t     svc_state;           // SVCSTATE_* 
....................       uint8_t     svc_flags;           // SVCRQST_* 
....................       uint8_t     app_domain;          // APPDOMAIN_* 
....................       uint16_t    destaddr;            // always 0xF981 
....................       uint32_t    time;                // Period/latency: intermittent flag set 
....................    }  service_indication; 
....................  
....................    struct _events_indication 
....................    { 
....................       uint8_t     cmd;                 // CMD_EVENT 
....................       uint8_t     len_pkt;             // always 0x09 
....................       uint8_t     flags;               // See tables 98 and 1***************** 
....................       uint32_t    new_events;          // EVENTMASK_* (?) 
....................       uint8_t     mote_state;          // MOTESTATE_* 
....................       uint32_t    mote_alarms;         // ALARMS_* 
....................    }  events_indication; 
....................     
....................    struct _advert_indication 
....................    { 
....................       uint8_t     cmd;                 // CMD_EVENT 
....................       uint8_t     len_pkt;             // always 0x09 
....................       uint8_t     flags; 
....................       uint16_t    network_id; 
....................       uint16_t    mote_id; 
....................       uint8_t     rssi;                // rcvd signal strength 
....................       uint8_t     hop_depth;           // (join priority) 
....................    }  advert_indication; 
....................     
....................    struct _data_from_net 
....................    { 
....................       uint8_t     cmd;                 // CMD_DATA 
....................       uint8_t     len_pkt;             // always len_data + 4 
....................       uint8_t     flags;               // See tables 98 and 1***************** 
....................       uint16_t    sourceaddr;          // always 0xF981 
....................       uint8_t     sequence_num;        // sequence number 
....................       uint8_t     len_data;            // packet data length (<=MAX_USER_DATA_SIZE) 
....................       uint8_t     data[MAX_USER_DATA_SIZE]; 
....................                                        // actual received data 
....................    }  data_from_net; 
.................... }  mote_to_micro;  
....................  
.................... /* 
.................... #define dust_dn2500_response_t                              dust_dn2500_param_response_t 
.................... #define dust_dn2500_set_param_tx_power_response_t           dust_dn2500_param_response_t 
.................... #define dust_dn2500_set_param_join_duty_cycle_response_t    dust_dn2500_param_response_t 
.................... #define dust_dn2500_set_param_battery_life_response_t       dust_dn2500_param_response_t 
.................... #define dust_dn2500_set_param_event_mask_response_t         dust_dn2500_param_response_t 
.................... #define dust_dn2500_set_param_write_protect_response_t      dust_dn2500_param_response_t 
.................... #define dust_dn2500_setnv_mac_address_response_t            dust_dn2500_param_response_t 
.................... #define dust_dn2500_setnv_network_id_response_t             dust_dn2500_param_response_t 
.................... #define dust_dn2500_setnv_tx_power_response_t               dust_dn2500_param_response_t 
.................... #define dust_dn2500_setnv_joinkey_response_t                dust_dn2500_param_response_t 
.................... #define dust_dn2500_setnv_otap_lockout_response_t           dust_dn2500_param_response_t 
.................... #define dust_dn2500_setnv_powerinfo_response_t              dust_dn2500_param_response_t 
.................... #define dust_dn2500_setnv_ttl_response_t                    dust_dn2500_param_response_t 
.................... #define dust_dn2500_send_response_t                         dust_dn2500_cmd_response_t 
.................... #define dust_dn2500_join_response_t                         dust_dn2500_cmd_response_t 
.................... #define dust_dn2500_search_response_t                       dust_dn2500_cmd_response_t 
.................... #define dust_dn2500_disconnect_response_t                   dust_dn2500_cmd_response_t 
.................... #define dust_dn2500_reset_response_t                        dust_dn2500_cmd_response_t 
.................... #define dust_dn2500_lowPowerSleep_response_t                dust_dn2500_cmd_response_t 
.................... #define dust_dn2500_testRadioTx_response_t                  dust_dn2500_cmd_response_t 
.................... #define dust_dn2500_testRadioRx_response_t                  dust_dn2500_cmd_response_t 
.................... #define dust_dn2500_clearnv_response_t                      dust_dn2500_cmd_response_t 
.................... #define dust_dn2500_set_param_hart_device_status_response_t dust_dn2500_param_response_t 
.................... #define dust_dn2500_set_param_hart_device_info_response_t   dust_dn2500_param_response_t 
.................... #define dust_dn2500_setnv_hart_antenna_gain_response_t      dust_dn2500_param_response_t 
....................  
.................... // MICRO TO MOTE RESPONSES AFTER TIME/SERVICE/EVENTS INDICATION OR DATA_FROM_NET 
.................... #define dust_dn2500_time_response_t    dust_dn2500_cmd_response_t 
.................... #define dust_dn2500_service_response_t dust_dn2500_cmd_response_t 
.................... #define dust_dn2500_events_response_t  dust_dn2500_cmd_response_t 
.................... #define dust_dn2500_data_response_t    dust_dn2500_cmd_response_t 
....................  
....................  
.................... struct dust_dn2500_cmd_response_t { 
....................     DUST_DN2500_HEADER_RESPONSE 
.................... }; 
.................... struct dust_dn2500_header_t { 
....................     DUST_DN2500_HEADER 
.................... }; 
....................  
.................... // WHAT UP WITH THIS....  hw/sw incompatibilities insurance?? -- ignore for now 
.................... // points to any extra bytes received that are not identified as a "dust" packet  
.................... struct dust_dn2500_unknown_data_t { 
....................    uint8_t*    data; 
....................    uint8_t     len; 
.................... }; 
.................... */ 
....................  
.................... // uint8_t     macaddr[8]; 
.................... uint8_t     joinkey[MAX_JOINKEY_SIZE]={0x44,0x55,0x53,0x54,0x4E,0x45,0x54,0x57,0x4F,0x52,0x4B,0x53,0x52,0x4F,0x43,0x4B}; 
.................... // need these declaration for pkgen_setnv_macaddr 
....................  
.................... /* 
.................... // The following structures exist in RAM as 'global'.  No need to pass 
.................... //  the structure to the packet generation routines defined below 
.................... struct _set_battlife_struct 
.................... // setup up battlife_days and pwrstat prior to pkgen_set_battlife() call 
.................... { 
....................    uint16_t    battlife_days; 
....................    uint8_t     pwrstat;                // PWRSTAT_* 
.................... }  set_battlife_struct; 
....................  
.................... struct _setnv_powerinfo_struct  
.................... // setup pwrsource, discharge_current_uA, discharge_time_sec, 
.................... //  and recharge_time_sec prior to pkgen_setnv_powerinfo() 
.................... { 
....................    uint8_t     pwrsource;              // PWRSOURCE_* 
....................    uint16_t    discharge_current_uA; 
....................    uint32_t    discharge_time_sec; 
....................    uint32_t    recharge_time_sec;     
.................... }  setnv_powerinfo_struct; 
....................  
.................... struct _set_svc_struct 
.................... // setup  svc_index; request_flags, app_domain and time  
.................... //  pwrstat prior to pkgen_set_battlife() call.  No need to setup dest_address 
.................... { 
....................    uint8_t     svc_index; 
....................    uint8_t     request_flags;          // SVCRQST_* 
....................    uint8_t     app_domain;             // APPDOMAIN_* 
....................    uint16_t    destaddr;               // always 0xF981 
....................                                        //  set properly in pkgen_set_service() 
....................    uint32_t    time;                   // Period/latency: intermittent flag set 
.................... }  set_svc_struct; 
....................  
.................... struct testradiotx_struct 
.................... // setup channel and num_packets prior to pkgen_testradiotx() call 
.................... { 
....................    uint8_t     channel;                // 0-15 
....................    uint16_t    num_packets; 
.................... }  testradiotx_struct; 
....................  
.................... struct testradiorx_struct 
.................... // setup channel and time_sec prior to pkgen_testradiorx() call 
.................... { 
....................    uint8_t     channel;                // 0-15  
....................    uint16_t    time_sec;               // rcv packets for this many secs 
.................... }  testradiorx_struct; 
.................... */ 
....................  
....................  
.................... /* ------------------------------------------------------------------------- */ 
.................... #define __swap32(src) (((uint32_t)src<<24)|(((uint32_t)src&0xff00)<<8)| \ 
....................                            (((uint32_t)src>>8)&0xff00)|((uint32_t)src>>24)) 
.................... #define __swap16(src) (((uint16_t)src<<8)|((uint16_t)src>>8)) 
.................... /* ------------------------------------------------------------------------- */ 
....................  
....................  
.................... /* ----------------------  Packet Generation Macros ------------------------ */ 
....................  
.................... /* setParameter<txPower> Request */ 
.................... #define pkgen_set_txpower(power) { \ 
....................     uint8_t prefix[] = {CMD_SET,0x02/*length*/,FLAG_TYPE_REQUEST,PARAM_TXPOWER}; \ 
....................     uint8_t pw       = power; \ 
....................     dust_hdlc_pkgen(prefix, 4, (uint8_t*)&pw, 1); \ 
.................... } 
....................  
.................... /* setParameter<joinDutyCycle> Request */ 
.................... #define pkgen_set_joinduty(cycle) { \ 
....................     uint8_t prefix[] = {CMD_SET,0x02/*length*/,FLAG_TYPE_REQUEST,PARAM_JOINDUTY}; \ 
....................     uint8_t cy       = cycle; \ 
....................     dust_hdlc_pkgen(prefix, 4, (uint8_t*)&cy, 1); \ 
.................... } 
....................  
.................... /* setParameter<batteryLife> Request */ 
.................... // structure is a declared global 
.................... #define pkgen_set_battlife() { \ 
....................     uint8_t  prefix[] = {CMD_SET,0x04/*length*/,FLAG_TYPE_REQUEST,PARAM_BATTLIFE}; \ 
....................     set_battlife_struct.battlife_days = __swap16(set_battlife_struct.battlife_days); \ 
....................     dust_hdlc_pkgen(prefix, 4, (uint8_t*)&set_battlife_struct, 3); \ 
.................... } 
....................  
.................... /* setParameter<service> Request */ 
.................... // structure is a declared global 
.................... #define pkgen_set_service() { \ 
....................     uint8_t  prefix[] = {CMD_SET,0x0A/*length*/,FLAG_TYPE_REQUEST,PARAM_SERVICE}; \ 
....................     set_svc_struct.destaddr = DESTADDR_SWAPPED; \ 
....................     set_svc_struct.time         = __swap32(set_svc_struct.time); \ 
....................     dust_hdlc_pkgen(prefix, 4, (uint8_t*)&set_svc_struct, 9); \ 
.................... } 
....................  
.................... /* setParameter<eventMask> Request */ 
.................... // eventmask is one of EVENTMASK_* 
.................... #define pkgen_set_eventmask(eventmask) { \ 
....................     uint8_t  prefix[] = {CMD_SET,0x05/*length*/,FLAG_TYPE_REQUEST,PARAM_EVENTMASK}; \ 
....................     uint32_t dstem    = __swap32(eventmask); \ 
....................     dust_hdlc_pkgen(prefix, 4, (uint8_t*)&dstem, 4); \ 
.................... } 
....................  
.................... /* getParameter<moteInfo> Request */ 
.................... #define pkgen_get_moteinfo() { \ 
....................     uint8_t cmd[] = {CMD_GET,0x01/*length*/,FLAG_TYPE_REQUEST,PARAM_MOTEINFO}; \ 
....................     dust_hdlc_pkgen((char*)(NULL), 0, cmd, 4); \ 
.................... } 
....................   
.................... /* getParameter<networkInfo> Request */ 
.................... #define pkgen_get_networkinfo() { \ 
....................     uint8_t cmd[] = {CMD_GET,0x01/*length*/,FLAG_TYPE_REQUEST,PARAM_NETWORKINFO}; \ 
....................     dust_hdlc_pkgen((char*)(NULL), 0, cmd, 4); \ 
.................... } 
....................  
.................... /* getParameter<moteStatus> Request */ 
.................... #define pkgen_get_motestatus() { \ 
....................     uint8_t cmd[] = {CMD_GET,0x01/*length*/,FLAG_TYPE_REQUEST,PARAM_MOTESTATUS}; \ 
....................     dust_hdlc_pkgen((char*)(NULL), 0, cmd, 4); \ 
.................... } 
....................  
.................... /* getParameter<time> Request */ 
.................... #define pkgen_get_time() { \ 
....................     uint8_t cmd[] = {CMD_GET,0x01/*length*/,FLAG_TYPE_REQUEST,PARAM_TIME}; \ 
....................     dust_hdlc_pkgen((char*)(NULL), 0, cmd, 4); \ 
.................... } 
....................  
.................... /* getParameter<charge> Request */ 
.................... #define pkgen_get_charge() { \ 
....................     uint8_t cmd[] = {CMD_GET,0x01/*length*/,FLAG_TYPE_REQUEST,PARAM_CHARGE}; \ 
....................     dust_hdlc_pkgen((char*)(NULL), 0, cmd, 4); \ 
.................... } 
....................  
.................... /* getParameter<testRadioRxStats> Request */ 
.................... #define pkgen_get_radiostatsrx() { \ 
....................     uint8_t cmd[] = {CMD_GET,0x01/*length*/,FLAG_TYPE_REQUEST,PARAM_RADIOSTATSRX}; \ 
....................     dust_hdlc_pkgen((char*)(NULL), 0, cmd, 4); \ 
.................... } 
....................  
.................... /* getParameter<service> Request */ 
.................... #define pkgen_get_service(service_idx) { \ 
....................     uint8_t prefix[] = {CMD_GET,0x02/*length*/,FLAG_TYPE_REQUEST,PARAM_SERVICE}; \ 
....................     uint8_t idx      = svc_index; \ 
....................     dust_hdlc_pkgen(prefix, 4, (uint8_t*)&idx, 1); \ 
.................... } 
....................  
.................... /* setNVParameter<macAddress> Request */ 
.................... // macaddr array is declared 
.................... #define pkgen_setnv_macaddr() { \ 
....................     uint8_t prefix[]   = {CMD_SETNV,0x0D/*length*/,FLAG_TYPE_REQUEST, 0x00, 0x00, 0x00, 0x00, PARAM_MACADDR}; \ 
....................     dust_hdlc_pkgen(prefix, 8, macaddr, 8); \ 
.................... } 
....................  
.................... /* setNVParameter<networkID> Request */ 
.................... #define pkgen_setnv_networkid(networkid) { \ 
....................     uint8_t prefix[] = {CMD_SETNV,0x07/*length*/,FLAG_TYPE_REQUEST, 0x00, 0x00, 0x00, 0x00, PARAM_NETWORKID}; \ 
....................     uint16_t net_id  = networkid; \ 
....................     dust_hdlc_pkgen(prefix, 8, (uint8_t*)&net_id, 2); \ 
.................... } 
....................  
.................... /* setNVParameter<txPower> Request */ 
.................... #define pkgen_setnv_txpower(txpower) { \ 
....................     uint8_t prefix[] = {CMD_SETNV,0x06/*length*/,FLAG_TYPE_REQUEST, 0x00, 0x00, 0x00, 0x00, PARAM_TXPOWER}; \ 
....................     uint8_t dst_power  = txpower; \ 
....................     dust_hdlc_pkgen(prefix, 8, (uint8_t*)&dst_power, 1); \ 
.................... } 
....................  
.................... /* setNVParameter<joinKey> Request */ 
.................... // joinkey array is declared 
....................  
.................... #define pkgen_setnv_joinkey(joinkey) { \ 
....................     uint8_t prefix[]   = {CMD_SETNV,0x15/*length*/,FLAG_TYPE_REQUEST, 0x00, 0x00, 0x00, 0x00, PARAM_JOINKEY}; \ 
....................     dust_hdlc_pkgen(prefix, 8, joinkey, 16); \ 
.................... } 
....................  
.................... //#define pkgen_setnv_joinkey(joinkey) { \ 
.................... //      uint8_t prefix[]   = {CMD_SETNV,0x15/*length*/,FLAG_TYPE_REQUEST, 0x00, 0x00, 0x00, 0x00, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}; \ 
.................... //      dust_hdlc_pkgen(prefix, 8,,16); \ 
.................... //} 
....................  
....................  
.................... /* setNVParameter<powerInfo> Request */ 
.................... // structure is a declared global 
.................... #define pkgen_setnv_powerinfo() { \ 
....................     uint8_t prefix[] = {CMD_SETNV,0x10/*length*/,FLAG_TYPE_REQUEST, 0x00, 0x00, 0x00, 0x00, PARAM_POWERINFO}; \ 
....................     setnv_powerinfo_struct.discharge_current_uA     = __swap16(setnv_powerinfo_struct.discharge_current_uA); \ 
....................     setnv_powerinfo_struct.discharge_time_sec       = __swap32(setnv_powerinfo_struct.discharge_time_sec); \ 
....................     setnv_powerinfo_struct.recharge_time_sec        = __swap32(setnv_powerinfo_struct.recharge_time_sec); \ 
....................     dust_hdlc_pkgen(prefix, 8, (uint8_t*)&setnv_powerinfo_struct, 11); \ 
.................... }  
....................  
.................... /* setNVParameter<OTAPlockout> Request */ 
.................... #define pkgen_setnv_otaplock(lockout) { \ 
....................    uint8_t prefix[] = {CMD_SETNV,0x06/*length*/,FLAG_TYPE_REQUEST, 0x00, 0x00, 0x00, 0x00, PARAM_OTAPLOCK}; \ 
....................    uint8_t otaplock = lockout; \ 
....................    dust_hdlc_pkgen(prefix, 8, (uint8_t*)&otaplock, 1); \ 
.................... } 
....................  
.................... /* setNVParameter<SpecialJoinTimingParams> Request */ 
.................... #define pkgen_setnv_special1(special1) { \ 
....................    uint8_t prefix[] = {CMD_SETNV,0x07/*length*/,0x02, 0x67, 0x12, 0x04, 0x04, PARAM_SPECIAL1}; \ 
....................    uint16_t spec_param1  = special1; \ 
....................    dust_hdlc_pkgen(prefix, 8, (uint8_t*)&spec_param1, 2); \ 
.................... } 
....................  
.................... /* setNVParameter<SpecialJoinTimingParams> Request */ 
.................... #define pkgen_setnv_special2(special2) { \ 
....................    uint8_t prefix[] = {CMD_SETNV,0x07/*length*/,0x00, 0x67, 0x12, 0x04, 0x04, PARAM_SPECIAL2}; \ 
....................    uint16_t spec_param2 = special2; \ 
....................    dust_hdlc_pkgen(prefix, 8, (uint8_t*)&spec_param2, 2); \ 
.................... } 
....................  
.................... /* getNVParameter<macAddress> Request */ 
.................... #define pkgen_getnv_macaddr() { \ 
....................     uint8_t cmd[] = {CMD_GETNV,0x05/*length*/,FLAG_TYPE_REQUEST, 0x00, 0x00, 0x00, 0x00, PARAM_MACADDR}; \ 
....................     dust_hdlc_pkgen((char*)(NULL), 0, cmd, 8); \ 
.................... } 
....................  
.................... /* getNVParameter<networkID> Request */ 
.................... #define pkgen_getnv_networkid() { \ 
....................     uint8_t cmd[] = {CMD_GETNV,0x05/*length*/,FLAG_TYPE_REQUEST, 0x00, 0x00, 0x00, 0x00, PARAM_NETWORKID}; \ 
....................     dust_hdlc_pkgen((char*)(NULL), 0, cmd, 8); \ 
.................... } 
....................  
.................... /* getNVParameter<txPower> Request */ 
.................... #define pkgen_getnv_txpower() { \ 
....................     uint8_t cmd[] = {CMD_GETNV,0x05/*length*/,FLAG_TYPE_REQUEST, 0x00, 0x00, 0x00, 0x00, PARAM_TXPOWER}; \ 
....................     dust_hdlc_pkgen((char*)(NULL), 0, cmd, 8); \ 
.................... } 
....................  
.................... /* getNVParameter<powerInfo> Request */ 
.................... #define pkgen_getnv_powerinfo() { \ 
....................     uint8_t cmd[] = {CMD_GETNV,0x05/*length*/,FLAG_TYPE_REQUEST, 0x00, 0x00, 0x00, 0x00, PARAM_POWERINFO}; \ 
....................     dust_hdlc_pkgen((char*)(NULL), 0, cmd, 8); \ 
.................... } 
....................  
.................... /* getNVParameter<OTAPlockout> Request */ 
.................... #define pkgen_getnv_otaplock() { \ 
....................     uint8_t cmd[]   = {CMD_GETNV,0x05/*length*/,FLAG_TYPE_REQUEST, 0x00, 0x00, 0x00, 0x00, PARAM_OTAPLOCK}; \ 
....................     dust_hdlc_pkgen((char*)(NULL), 0, cmd, 8); \ 
.................... } 
....................  
.................... // command to mote to test the radio transmitter 
.................... // structure is a declared global 
.................... #define pkgen_testradiotx() { \ 
....................     uint8_t  prefix[] = {CMD_TESTRADIOTX, 3 /*payload length*/, FLAG_TYPE_TEST}; \ 
....................     testradiotx_struct.num_packets = __swap16(testradiotx_struct.num_packets); \ 
....................     dust_hdlc_pkgen(prefix, 3, (uint8_t*)&testradiotx_struct, 3); \ 
.................... } 
....................  
.................... #define pkgen_testradiorx() { \ 
....................     uint8_t  prefix[] = {CMD_TESTRADIORX, 3 /*payload length*/, FLAG_TYPE_TEST}; \ 
....................     testradiorx_struct.time_sec = __swap16(testradiorx_struct.time_sec); \ 
....................     dust_hdlc_pkgen(prefix, 3, (uint8_t*)&testradiorx_struct, 3); \ 
.................... } 
....................  
.................... /* Join Request */ 
.................... #define pkgen_join() { \ 
....................     uint8_t cmd[]   = {CMD_JOIN,0x00/*payload length*/,FLAG_TYPE_REQUEST}; \ 
....................     dust_hdlc_pkgen((char*)(NULL), 0, cmd, 3); \ 
.................... } 
....................  
.................... /* Disconnect Request */ 
.................... #define pkgen_disconnect() { \ 
....................     uint8_t cmd[]   = {CMD_DISCONNECT,0x00/*payload length*/,FLAG_TYPE_REQUEST}; \ 
....................     dust_hdlc_pkgen((char*)(NULL), 0, cmd, 3); \ 
.................... } 
....................  
.................... /* Reset Request */ 
.................... #define pkgen_reset() { \ 
....................     uint8_t cmd[]   = {CMD_RESET,0x00/*payload length*/,FLAG_TYPE_REQUEST}; \ 
....................     dust_hdlc_pkgen((char*)(NULL), 0, cmd, 3); \ 
.................... } 
....................  
.................... /* lowPowerSleep Request */ 
.................... #define pkgen_sleep() { \ 
....................     uint8_t cmd[]   = {CMD_SLEEP,0x00/*payload length*/,FLAG_TYPE_REQUEST}; \ 
....................     dust_hdlc_pkgen((char*)(NULL), 0, cmd, 3); \ 
.................... } 
....................  
.................... /* ClearNV Request */ 
.................... #define pkgen_clearnv() { \ 
....................     uint8_t cmd[]   = {CMD_CLEARNV,0x00/*payload length*/,FLAG_TYPE_REQUEST}; \ 
....................     ((char*)(NULL), 0, cmd, 3); \ 
.................... } 
....................  
.................... /* Search Request */ 
.................... #define pkgen_search() { \ 
....................     uint8_t cmd[]   = {CMD_SEARCH,0x00/*payload length*/,FLAG_TYPE_REQUEST}; \ 
....................     dust_hdlc_pkgen((char*)(NULL), 0, cmd, 3); \ 
.................... } 
....................  
.................... // MOTE command responses.  The micro sends a response to mote  
.................... //  after having received an indication or a data packet 
....................  
.................... #define pkgen_time_ind_response(result_fl) { \ 
....................     uint8_t prefix[] = {CMD_TIME,0x00};   \ 
....................     uint16_t r        = result_fl; \ 
....................     dust_hdlc_pkgen(prefix, 2, (uint8_t*)&r, 2); \ 
.................... } 
....................  
.................... #define pkgen_service_ind_response(result_fl) { \ 
....................     uint8_t prefix[] = {CMD_SERVICE,0x00}; \ 
....................     uint16_t r       = result_fl; \ 
....................     dust_hdlc_pkgen(prefix, 2, (uint8_t*)&r, 2);  \ 
.................... } 
....................  
.................... #define pkgen_event_ind_response(result_fl) { \ 
....................     uint8_t prefix[] = {CMD_EVENT,0x00};  \ 
....................     uint16_t r        = result_fl; \ 
....................     dust_hdlc_pkgen(prefix, 2, (uint8_t*)&r, 2); \ 
.................... } 
....................  
.................... #define pkgen_advert_ind_response(result_fl) { \ 
....................     uint8_t prefix[] = {CMD_ADVERT,0x00}; \ 
....................     uint16_t r       = result_fl; \ 
....................     dust_hdlc_pkgen(prefix, 2, (uint8_t*)&r, 2); \ 
.................... } 
....................  
.................... #define pkgen_data_rcvd_response(result_fl) { \ 
....................     uint8_t prefix[] = {CMD_DATA,0x00};  \ 
....................     uint16_t r       = result_fl; \ 
....................     dust_hdlc_pkgen(prefix, 2, (uint8_t*)&r, 2); \ 
.................... } 
....................  
.................... // Added by brian 
.................... #define pkgen_mote_ack() { \ 
....................  uint8_t cmd[]   = {(flags_rcvd+1),response_type}; \ 
....................  dust_hdlc_pkgen((cmd_rcvd << 8), 2, cmd, 2); \ 
.................... } 
....................     
.................... //  
.................... /* 
.................... struct dust_dn2500_t { 
....................  
....................     // SET Parameters Responses 
....................     int8_t (*set_param_tx_power_response)(void* handle, struct dust_dn2500_set_param_tx_power_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................     int8_t (*set_param_join_duty_cycle_response)(void* handle, struct dust_dn2500_set_param_join_duty_cycle_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................     int8_t (*set_param_battery_life_response)(void* handle, struct dust_dn2500_set_param_battery_life_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................     int8_t (*set_param_service_response)(void* handle, struct dust_dn2500_set_param_service_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................     int8_t (*set_param_hart_device_status_response)(void* handle, struct dust_dn2500_set_param_hart_device_status_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................     int8_t (*set_param_hart_device_info_response)(void* handle, struct dust_dn2500_set_param_hart_device_info_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................     int8_t (*set_param_event_mask_response)(void* handle, struct dust_dn2500_set_param_event_mask_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................     int8_t (*set_param_write_protect_response)(void* handle, struct dust_dn2500_set_param_write_protect_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................  
....................     int8_t (*get_param_mote_info_response)(void* handle, struct dust_dn2500_get_param_mote_info_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................     int8_t (*get_param_network_info_response)(void* handle, struct dust_dn2500_get_param_network_info_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................     int8_t (*get_param_mote_status_response)(void* handle, struct dust_dn2500_get_param_mote_status_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................     int8_t (*get_param_time_response)(void* handle, struct dust_dn2500_get_param_time_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................     int8_t (*get_param_charge_response)(void* handle, struct dust_dn2500_get_param_charge_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................     int8_t (*get_param_test_radio_rxstats_response)(void* handle, struct dust_dn2500_get_param_test_radio_rxstats_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................     int8_t (*get_param_service_response)(void* handle, struct dust_dn2500_get_param_service_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................  
....................     // Non-Volatile Parameter Responses 
....................     int8_t (*setnv_mac_address_response)(void* handle, struct dust_dn2500_setnv_mac_address_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................     int8_t (*setnv_network_id_response)(void* handle, struct dust_dn2500_setnv_network_id_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................     int8_t (*setnv_tx_power_response)(void* handle, struct dust_dn2500_setnv_tx_power_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................     int8_t (*setnv_joinkey_response)(void* handle, struct dust_dn2500_setnv_joinkey_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................     int8_t (*setnv_powerinfo_response)(void* handle, struct dust_dn2500_setnv_powerinfo_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................     int8_t (*setnv_ttl_response)(void* handle, struct dust_dn2500_setnv_ttl_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................     int8_t (*setnv_hart_antenna_gain)(void* handle, struct dust_dn2500_setnv_hart_antenna_gain_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................     int8_t (*setnv_otap_lockout)(void* handle, struct dust_dn2500_setnv_otap_lockout_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................  
....................     int8_t (*getnv_mac_address_response)(void* handle, struct dust_dn2500_getnv_mac_address_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................     int8_t (*getnv_network_id_response)(void* handle, struct dust_dn2500_getnv_network_id_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................     int8_t (*getnv_tx_power_response)(void* handle, struct dust_dn2500_getnv_tx_power_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................     int8_t (*getnv_powerinfo_response)(void* handle, struct dust_dn2500_getnv_powerinfo_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................     int8_t (*getnv_ttl_response)(void* handle, struct dust_dn2500_getnv_ttl_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................     int8_t (*getnv_hart_antenna_gain)(void* handle, struct dust_dn2500_getnv_hart_antenna_gain_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................     int8_t (*getnv_otap_lockout)(void* handle, struct dust_dn2500_getnv_otap_lockout_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................  
....................     // Command Responses 
....................     int8_t (*send_response)(void* handle, struct dust_dn2500_send_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................     int8_t (*join_response)(void* handle, struct dust_dn2500_join_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................     int8_t (*disconnect_response)(void* handle, struct dust_dn2500_disconnect_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................     int8_t (*search_response)(void* handle, struct dust_dn2500_search_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................     int8_t (*reset_response)(void* handle, struct dust_dn2500_reset_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................     int8_t (*lowPowerSleep_response)(void* handle, struct dust_dn2500_lowPowerSleep_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................     int8_t (*hartPayload_response)(void* handle, struct dust_dn2500_hartPayload_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................     int8_t (*testRadioTx_response)(void* handle, struct dust_dn2500_testRadioTx_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................     int8_t (*testRadioRx_response)(void* handle, struct dust_dn2500_testRadioRx_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................     int8_t (*clearnv_response)(void* handle, struct dust_dn2500_clearnv_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................  
....................     // MOTE commands sent to sensor processor 
....................     int8_t (*time_request)(void* handle, struct dust_dn2500_time_request_t* p, struct dust_dn2500_unknown_data_t* un); 
....................     int8_t (*service_indication)(void* handle, struct dust_dn2500_service_indication_t* p, struct dust_dn2500_unknown_data_t* un); 
....................     int8_t (*events_request)(void* handle, struct dust_dn2500_events_request_t* p, struct dust_dn2500_unknown_data_t* un); 
....................     int8_t (*data_request)(void* handle, struct dust_dn2500_data_request_t* p, struct dust_dn2500_unknown_data_t* un); 
....................  
....................     // Unknown command 
....................     int8_t (*unknown_command)(void* handle, uint8_t* data, uint8_t len); 
....................  
....................     // source buffer 
....................     uint8_t     bf_src[MAX_ENCODED_PACKET_SIZE]; 
....................     uint8_t     len_src; 
....................  
....................     // destination buffer 
....................     uint8_t     bf_dest[MAX_DEST_BUF_SIZE]; 
....................     uint8_t     len_dest; 
....................  
....................     uint8_t     idx; 
....................      
....................  
....................     // Used in case SW version isn't in sync with HW firmware version 
....................    struct dust_dn2500_unknown_data_t unknown; 
.................... }; 
....................  
.................... // Utility commands to queue and clear packet data 
.................... int8_t dust_dn2500_q_clear(struct dust_dn2500_t* ia); 
.................... int8_t dust_dn2500_q_byte(struct dust_dn2500_t* ia, uint8_t byte); 
....................  
.................... // Routine to dispatch incoming packets to callbacks 
.................... int8_t dust_dn2500_dispatcher(struct pappy_t* md, struct dust_dn2500_t* ia, void* handle); 
.................... //user defined 
....................  
.................... */ 
....................  
.................... // HERE ARE ITEMS FROM DUST_HDLC.H 
.................... #define CONTROL_ESCAPE 0x7d 
.................... #define FLAG_SEQUENCE  0x7e 
.................... #define XOR_BYTE       0x20 
....................  
.................... /* Low level routine return values */ 
.................... #define DUST_HDLC_RTN_SUCCESS                     0 
.................... #define DUST_HDLC_RTN_NOT_ENOUGH_BUFFER_SPACE    -1 
.................... #define DUST_HDLC_RTN_BAD_CRC                    -2 
.................... #define DUST_HDLC_RTN_INVALID_PK_DELIMITERS      -3 
....................  
....................  
.................... // HERE ARE ITEMS FROM DUST_HDLC.C 
.................... #define FCS_INITIAL_FCS16 ((uint16_t) 0xffff) 
.................... #define FCS_GOOD_FCS16    ((uint16_t) 0xf0b8) 
....................  
.................... // We will use the routine that takes LESS PROCESSING TIME at the expense 
.................... //  or greater memory usage. 
....................  
.................... // lookup table for calculation of checksum 
.................... UNSIGNED INT16 CONST fcstab[256] =  { 
....................    0x0000, 0x1189, 0x2312, 0x329b, 0x4624, 0x57ad, 0x6536, 0x74bf, 
....................    0x8c48, 0x9dc1, 0xaf5a, 0xbed3, 0xca6c, 0xdbe5, 0xe97e, 0xf8f7, 
....................    0x1081, 0x0108, 0x3393, 0x221a, 0x56a5, 0x472c, 0x75b7, 0x643e, 
....................    0x9cc9, 0x8d40, 0xbfdb, 0xae52, 0xdaed, 0xcb64, 0xf9ff, 0xe876, 
....................    0x2102, 0x308b, 0x0210, 0x1399, 0x6726, 0x76af, 0x4434, 0x55bd, 
....................    0xad4a, 0xbcc3, 0x8e58, 0x9fd1, 0xeb6e, 0xfae7, 0xc87c, 0xd9f5, 
....................    0x3183, 0x200a, 0x1291, 0x0318, 0x77a7, 0x662e, 0x54b5, 0x453c, 
....................    0xbdcb, 0xac42, 0x9ed9, 0x8f50, 0xfbef, 0xea66, 0xd8fd, 0xc974, 
....................    0x4204, 0x538d, 0x6116, 0x709f, 0x0420, 0x15a9, 0x2732, 0x36bb, 
....................    0xce4c, 0xdfc5, 0xed5e, 0xfcd7, 0x8868, 0x99e1, 0xab7a, 0xbaf3, 
....................    0x5285, 0x430c, 0x7197, 0x601e, 0x14a1, 0x0528, 0x37b3, 0x263a, 
....................    0xdecd, 0xcf44, 0xfddf, 0xec56, 0x98e9, 0x8960, 0xbbfb, 0xaa72, 
....................    0x6306, 0x728f, 0x4014, 0x519d, 0x2522, 0x34ab, 0x0630, 0x17b9, 
....................    0xef4e, 0xfec7, 0xcc5c, 0xddd5, 0xa96a, 0xb8e3, 0x8a78, 0x9bf1, 
....................    0x7387, 0x620e, 0x5095, 0x411c, 0x35a3, 0x242a, 0x16b1, 0x0738, 
....................    0xffcf, 0xee46, 0xdcdd, 0xcd54, 0xb9eb, 0xa862, 0x9af9, 0x8b70, 
....................    0x8408, 0x9581, 0xa71a, 0xb693, 0xc22c, 0xd3a5, 0xe13e, 0xf0b7, 
....................    0x0840, 0x19c9, 0x2b52, 0x3adb, 0x4e64, 0x5fed, 0x6d76, 0x7cff, 
....................    0x9489, 0x8500, 0xb79b, 0xa612, 0xd2ad, 0xc324, 0xf1bf, 0xe036, 
....................    0x18c1, 0x0948, 0x3bd3, 0x2a5a, 0x5ee5, 0x4f6c, 0x7df7, 0x6c7e, 
....................    0xa50a, 0xb483, 0x8618, 0x9791, 0xe32e, 0xf2a7, 0xc03c, 0xd1b5, 
....................    0x2942, 0x38cb, 0x0a50, 0x1bd9, 0x6f66, 0x7eef, 0x4c74, 0x5dfd, 
....................    0xb58b, 0xa402, 0x9699, 0x8710, 0xf3af, 0xe226, 0xd0bd, 0xc134, 
....................    0x39c3, 0x284a, 0x1ad1, 0x0b58, 0x7fe7, 0x6e6e, 0x5cf5, 0x4d7c, 
....................    0xc60c, 0xd785, 0xe51e, 0xf497, 0x8028, 0x91a1, 0xa33a, 0xb2b3, 
....................    0x4a44, 0x5bcd, 0x6956, 0x78df, 0x0c60, 0x1de9, 0x2f72, 0x3efb, 
....................    0xd68d, 0xc704, 0xf59f, 0xe416, 0x90a9, 0x8120, 0xb3bb, 0xa232, 
....................    0x5ac5, 0x4b4c, 0x79d7, 0x685e, 0x1ce1, 0x0d68, 0x3ff3, 0x2e7a, 
....................    0xe70e, 0xf687, 0xc41c, 0xd595, 0xa12a, 0xb0a3, 0x8238, 0x93b1, 
....................    0x6b46, 0x7acf, 0x4854, 0x59dd, 0x2d62, 0x3ceb, 0x0e70, 0x1ff9, 
....................    0xf78f, 0xe606, 0xd49d, 0xc514, 0xb1ab, 0xa022, 0x92b9, 0x8330, 
....................    0x7bc7, 0x6a4e, 0x58d5, 0x495c, 0x3de3, 0x2c6a, 0x1ef1, 0x0f78 
.................... }; 
....................  
.................... /* 
.................... // EVEN MORE STUFF NOT RELEVANT TO JACK IMPLEMENTATION 
.................... // ITEMS FROM DUST_DN2500_HANDLER.H 
.................... // I THINK THESE ARE FUNCTION PROTOTYPES! 
.................... // set_parameter response packets received by sensor processor 
.................... int8_t dust_dn2500_set_param_tx_power_response(void* handle, struct dust_dn2500_set_param_tx_power_response_t* p, struct dust_dn2500_unknown_data_t* un); 
.................... int8_t dust_dn2500_set_param_join_duty_cycle_response(void* handle, struct dust_dn2500_set_param_join_duty_cycle_response_t* p, struct dust_dn2500_unknown_data_t* un); 
.................... int8_t dust_dn2500_set_param_battery_life_response(void* handle, struct dust_dn2500_set_param_battery_life_response_t* p, struct dust_dn2500_unknown_data_t* un); 
.................... int8_t dust_dn2500_set_param_service_response(void* handle, struct dust_dn2500_set_param_service_response_t* p, struct dust_dn2500_unknown_data_t* un); 
.................... int8_t dust_dn2500_set_param_event_mask_response(void* handle, struct dust_dn2500_set_param_event_mask_response_t* p, struct dust_dn2500_unknown_data_t* un); 
.................... int8_t dust_dn2500_set_param_hart_device_status_response(void* handle, struct dust_dn2500_set_param_hart_device_status_response_t* p, struct dust_dn2500_unknown_data_t* un); 
.................... int8_t dust_dn2500_set_param_hart_device_info_response(void* handle, struct dust_dn2500_set_param_hart_device_info_response_t* p, struct dust_dn2500_unknown_data_t* un); 
.................... int8_t dust_dn2500_set_param_write_protect_response(void* handle, struct dust_dn2500_set_param_write_protect_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................  
.................... // get_parameter response packets received by sensor processor 
.................... int8_t dust_dn2500_get_param_mote_info_response(void* handle, struct dust_dn2500_get_param_mote_info_response_t* p, struct dust_dn2500_unknown_data_t* un); 
.................... int8_t dust_dn2500_get_param_network_info_response(void* handle, struct dust_dn2500_get_param_network_info_response_t* p, struct dust_dn2500_unknown_data_t* un); 
.................... int8_t dust_dn2500_get_param_mote_status_response(void* handle, struct dust_dn2500_get_param_mote_status_response_t* p, struct dust_dn2500_unknown_data_t* un); 
.................... int8_t dust_dn2500_get_param_service_response(void* handle, struct dust_dn2500_get_param_service_response_t* p, struct dust_dn2500_unknown_data_t* un); 
.................... int8_t dust_dn2500_get_param_time_response(void* handle, struct dust_dn2500_get_param_time_response_t* p, struct dust_dn2500_unknown_data_t* un); 
.................... int8_t dust_dn2500_get_param_charge_response(void* handle, struct dust_dn2500_get_param_charge_response_t* p, struct dust_dn2500_unknown_data_t* un); 
.................... int8_t dust_dn2500_get_param_test_radio_rxstats_response(void* handle, struct dust_dn2500_get_param_test_radio_rxstats_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................  
.................... // get non-volatile response packets received by sensor processor 
.................... int8_t dust_dn2500_getnv_mac_address_response(void* handle, struct dust_dn2500_getnv_mac_address_response_t* p, struct dust_dn2500_unknown_data_t* un); 
.................... int8_t dust_dn2500_getnv_network_id_response(void* handle, struct dust_dn2500_getnv_network_id_response_t* p, struct dust_dn2500_unknown_data_t* un); 
.................... int8_t dust_dn2500_getnv_tx_power_response(void* handle, struct dust_dn2500_getnv_tx_power_response_t* p, struct dust_dn2500_unknown_data_t* un); 
.................... int8_t dust_dn2500_getnv_powerinfo_response(void* handle, struct dust_dn2500_getnv_powerinfo_response_t* p, struct dust_dn2500_unknown_data_t* un); 
.................... int8_t dust_dn2500_getnv_ttl_response(void* handle, struct dust_dn2500_getnv_ttl_response_t* p, struct dust_dn2500_unknown_data_t* un); 
.................... int8_t dust_dn2500_getnv_hart_antenna_gain(void* handle, struct dust_dn2500_getnv_hart_antenna_gain_response_t* p, struct dust_dn2500_unknown_data_t* un); 
.................... int8_t dust_dn2500_getnv_otap_lockout(void* handle, struct dust_dn2500_getnv_otap_lockout_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................  
.................... // set non-volatile response packets received by sensor processor 
.................... int8_t dust_dn2500_setnv_mac_address_response(void* handle, struct dust_dn2500_setnv_mac_address_response_t* p, struct dust_dn2500_unknown_data_t* un); 
.................... int8_t dust_dn2500_setnv_network_id_response(void* handle, struct dust_dn2500_setnv_network_id_response_t* p, struct dust_dn2500_unknown_data_t* un); 
.................... int8_t dust_dn2500_setnv_tx_power_response(void* handle, struct dust_dn2500_setnv_tx_power_response_t* p, struct dust_dn2500_unknown_data_t* un); 
.................... int8_t dust_dn2500_setnv_joinkey_response(void* handle, struct dust_dn2500_setnv_joinkey_response_t* p, struct dust_dn2500_unknown_data_t* un); 
.................... int8_t dust_dn2500_setnv_powerinfo_response(void* handle, struct dust_dn2500_setnv_powerinfo_response_t* p, struct dust_dn2500_unknown_data_t* un); 
.................... int8_t dust_dn2500_setnv_ttl_response(void* handle, struct dust_dn2500_setnv_ttl_response_t* p, struct dust_dn2500_unknown_data_t* un); 
.................... int8_t dust_dn2500_setnv_hart_antenna_gain(void* handle, struct dust_dn2500_setnv_hart_antenna_gain_response_t* p, struct dust_dn2500_unknown_data_t* un); 
.................... int8_t dust_dn2500_setnv_otap_lockout(void* handle, struct dust_dn2500_setnv_otap_lockout_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................  
.................... // motes response packets received by sensor processor 
.................... int8_t dust_dn2500_send_response(void* handle, struct dust_dn2500_send_response_t* p, struct dust_dn2500_unknown_data_t* un); 
.................... int8_t dust_dn2500_join_response(void* handle, struct dust_dn2500_join_response_t* p, struct dust_dn2500_unknown_data_t* un); 
.................... int8_t dust_dn2500_disconnect_response(void* handle, struct dust_dn2500_disconnect_response_t* p, struct dust_dn2500_unknown_data_t* un); 
.................... int8_t dust_dn2500_search_response(void* handle, struct dust_dn2500_search_response_t* p, struct dust_dn2500_unknown_data_t* un); 
.................... int8_t dust_dn2500_reset_response(void* handle, struct dust_dn2500_reset_response_t* p, struct dust_dn2500_unknown_data_t* un); 
.................... int8_t dust_dn2500_lowPowerSleep_response(void* handle, struct dust_dn2500_lowPowerSleep_response_t* p, struct dust_dn2500_unknown_data_t* un); 
.................... int8_t dust_dn2500_testRadioTx_response(void* handle, struct dust_dn2500_testRadioTx_response_t* p, struct dust_dn2500_unknown_data_t* un); 
.................... int8_t dust_dn2500_testRadioRx_response(void* handle, struct dust_dn2500_testRadioRx_response_t* p, struct dust_dn2500_unknown_data_t* un); 
.................... int8_t dust_dn2500_clearnv_response(void* handle, struct dust_dn2500_clearnv_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................  
.................... // Mote request packets received by sensor processor 
.................... int8_t dust_dn2500_time_request(void* handle, struct dust_dn2500_time_request_t* p, struct dust_dn2500_unknown_data_t* un); 
.................... int8_t dust_dn2500_service_indication(void* handle, struct dust_dn2500_service_indication_t* p, struct dust_dn2500_unknown_data_t* un); 
.................... int8_t dust_dn2500_events_request(void* handle, struct dust_dn2500_events_request_t* p, struct dust_dn2500_unknown_data_t* un); 
.................... int8_t dust_dn2500_data_request(void* handle, struct dust_dn2500_data_request_t* p, struct dust_dn2500_unknown_data_t* un); 
.................... int8_t dust_dn2500_unknown_command(void* handle, uint8_t* data, uint8_t len); 
....................  
.................... */ 
....................  
.................... #include "globals.h"                                
.................... // globals.h 
.................... // 
.................... // This file contains all of the global variables used in the firmware 
.................... //  
.................... // Add to this list carefull and keep it syncronized with vars_init().....                
....................            
.................... ////////////////////Global Variables Table of Contents///////////////////////// 
.................... //Test Globals 
.................... //LCD Globals 
.................... //Time Globals                                                                            
.................... //System Parameter Globals 
.................... //Hardware Enabled Globals                                
.................... //Control Related Globals                  
.................... //Valve Related Globals                                         
.................... //Mote Globals 
.................... //Priority Queue 
.................... //Time Queue                                                               
.................... //Sprinkler Stack                                                                                                 
.................... //Command Stack                     
.................... //System State Globals 
....................  
.................... //Where to put?                                                
.................... uint32_t global_last_connected_time = 0;         
.................... uint16_t global_xdcr_output = 0;                             
....................                                    
.................... // global that keeps track of why the system restarted/shutdown 
.................... uint8_t global_shutdown_cause = 0; 
.................... uint8_t global_previous_shutdown_cause = 0; 
....................  
.................... char global_firmware_version_string[5] = {'A','0','0','0',0};       
....................  
.................... ////////////////////Test Globals/////////////////////////////////////////////// 
.................... uint8_t test_global = 0; 
.................... uint8_t test_global_2 = 0; 
.................... uint32_t test_start_time = 0; 
.................... uint32_t test_end_time = 0; 
.................... uint16_t test_valve_open_1 = 0; 
.................... uint16_t test_rpm_1 = 0; 
.................... uint16_t test_duty_cycle_1 = 0; 
.................... uint16_t test_valve_open_2 = 0; 
.................... uint16_t test_rpm_2 = 0; 
.................... uint16_t test_duty_cycle_2 = 0; 
.................... uint16_t test_valve_open_3 = 0; 
.................... uint16_t test_rpm_3 = 0; 
.................... uint16_t test_duty_cycle_3 = 0; 
....................  
....................   
.................... ////////////////////LCD Globals//////////////////////////////////////////////// 
.................... unsigned char global_temp_line_buff[17]; 
.................... char* global_extra_lcd_ptr; 
....................                      
.................... // LCD skip update flag 
.................... // 0 = don't skip 
.................... // 1 = Last update skipped, clear screen and proceed as normal 
.................... // 2-255 = how many skips (plus 1) to skip.  LCD is updated 1/sec, so 4 =  
.................... //    3 seconds of skipping updates. 
.................... uint8_t     global_skip_lcd_update_count = 0;        
....................  
.................... // Current LCD page number 
.................... // 0 = don't display anything? 
.................... // 1-TOTAL_LCD_PAGES = display that page number     
.................... uint8_t     global_lcd_page_number = 1;       
....................                    
.................... ////////////////////Time Globals/////////////////////////////////////////////// 
.................... // keeps track of time since microprocessor has been awake in seconds 
.................... uint32_t global_rtc_time = 0; 
.................... // keeps track of the time within the mote system (taken from mote) 
.................... uint32_t global_utc_time = 0; 
.................... // keeps track of the time at book (as taken from the mote the first time after 
.................... //  program startup 
.................... uint32_t global_first_utc_time = 0; 
.................... // keeps track of when SW1 was last depressed (for recognition of long press event) 
.................... uint32_t sw1_start_time = 0;   
.................... ////////////////////System Parameter Globals/////////////////////////////////// 
.................... uint16_t global_sprinkler_num = 0; 
....................  
.................... // More globals that we might actually want to keep 
.................... uint8_t     serial_number_rcvd[8] = {0,0,0,0,0,0,0,0}; 
.................... uint8_t     macaddr_rcvd[8] = {0,0,0,0,0,0,0,0}; 
....................  
.................... ////////////////////Hardware Enabled Globals/////////////////////////////////// 
.................... uint8_t  global_hardware_enabled = 0;                                                                
....................    #BIT  global_lcd_enabled         = global_hardware_enabled.0 
....................    #BIT  global_gps_enabled         = global_hardware_enabled.1 
....................    #BIT  global_xcdr_type1_enabled  = global_hardware_enabled.2 
....................    #BIT  global_xcdr_type2_enabled  = global_hardware_enabled.3 
....................    #BIT  global_fixture_enabled     = global_hardware_enabled.4 
....................    #BIT  global_temp1_enabled       = global_hardware_enabled.5 
....................    #BIT  global_dust_enabled        = global_hardware_enabled.6 
....................    #BIT  global_dust_operational    = global_hardware_enabled.7 
....................  
.................... ////////////////////Control Related Globals//////////////////////////////////// 
.................... // keeps track of rpms (updated via interrupt routine) 
.................... uint16_t global_current_period = 0; 
.................... uint16_t global_current_rpm; 
.................... uint16_t global_rpm_set_value = 100; 
.................... uint32_t global_last_rpm_value_time = 0; 
....................  
.................... // keeps track of duty cycles of brake and charge 
.................... uint16_t global_brake_duty = 0; 
.................... uint16_t global_charge_duty = MAX_CHARGE; 
.................... // keeps track of set points for brake and charge duty cycles 
.................... uint16_t global_brake_duty_set_value = 0; 
.................... uint16_t global_charge_duty_set_value = MAX_CHARGE; 
....................  
.................... // keeps track of mppc level 
.................... uint8_t  global_mppc_value = 100; 
.................... uint8_t  global_mppc_set_value = 100; 
.................... // keeps track of vgen 
.................... uint16_t global_vgen = 0; 
.................... // keeps track of fixture dac value 
.................... uint16_t global_fixture_dac_value = NO_FIXTURE; 
....................  
.................... // specifies how the rpm is being controlled (see defines for more info) 
.................... uint8_t global_control_loop_mechanism = BRAKE_AND_CHARGE_START; 
.................... // JG: set to brake and charge for testing purposes Feb 2, 2017 
.................... //uint8_t global_control_loop_mechanism = BRAKE_AND_CHARGE_START; 
....................  
.................... ////////////////////Valve Related Globals////////////////////////////////////// 
.................... // keeps track of current valve position 
.................... uint16_t global_valve_position = VLV_PRECALIBRATION_POSITION;    
.................... // valve position set point 
.................... uint16_t global_valve_position_set_value = VLV_PRECALIBRATION_POSITION;    
....................                                 
.................... // 1/1024th of the time to go from open to close calculated by calibrate valve    
.................... //     routine in units of 2ndary oscillator ticks 
.................... uint16_t global_valve_time_to_close_1024th = DEFAULT_VLV_TIME_TO_CLOSE; 
.................... // 1/1024th of the time to go from close to open calculated by calibrate valve   
.................... //    routine in units of 2ndary oscillator ticks 
.................... uint16_t global_valve_time_to_open_1024th = DEFAULT_VLV_TIME_TO_OPEN; 
.................... // amount of time the valve has been in motion in units of 1/1024ths of a 
.................... //    millispan.  So, not really time, but distance. 
.................... uint16_t global_valve_time_in_motion_1024ths = 0; 
.................... // when the last valve calibration was done, in utc time 
.................... uint32_t global_valve_calibration_utc_time = 0; 
.................... // number of movements since last calibration/endstop  
.................... uint8_t  global_valve_movements_since_endstop = 0; 
....................  
.................... // calibrate FSR valve position (default is 0x2000, but should be set by message) 
.................... uint16_t global_calibrate_fsr_valve_position = 0x2000; 
.................... // calibrate FSR outcome in period (inverse of rpm).  Default/unknown is 0-1 
.................... uint16_t global_calibrate_fsr_period = 0-1; 
.................... // when the last fsr calibration was done, in utc time 
.................... uint32_t global_calibrate_fsr_utc_time = 0; 
....................  
.................... ////////////////////Mote Globals/////////////////////////////////////////////// 
.................... //event flags defined by mote 
.................... uint8_t  event_flags; 
....................    #BIT  fl_boot_event           = event_flags.0 
....................    #BIT  fl_alarm_event          = event_flags.1 
....................    #BIT  fl_time_event           = event_flags.2 
....................    #BIT  fl_joinfail_event       = event_flags.3 
....................    #BIT  fl_disconnected_event   = event_flags.4 
....................    #BIT  fl_operational_event    = event_flags.5 
....................    #BIT  fl_config_event         = event_flags.6 
....................    #BIT  fl_unknown_event        = event_flags.7 
....................  
.................... // Note that bytes_from_mote union contains the stripped unstuffed data 
.................... //  eg, bytes_from_mote.dust_rcvd[128] 
.................... mote_to_micro  bytes_from_mote; 
.................... mote_to_micro* p; 
....................  
.................... // It just can't get bigger than this! 
.................... // pkgen places message to be sent here 
.................... char        dust_send_buffer[MAX_SEND_BUFFER]; 
....................  
.................... // this is only for doing acks and only needs to be  
.................... // MAX_USER_DATA_SIZE*2 + 2 + 4 + 12 + 2 
.................... // MAX_USER_DATA_SIZE is 2 bytes for ack 
.................... char        dust_send_buffer_isr[2*2 + 2 + 4 + 12 + 2]; 
....................  
.................... // THIS is the buffer for RAW rcvd mote 
.................... //  mote packet data 
.................... char        dust_recive_buffer[MAX_RCV_BUFFER + 1]; 
....................  
.................... //  this is place 
.................... //  where the packet to be sent by micro 
.................... //  to NETWORK manager is placed prior 
.................... //  to dust_send_data call 
.................... char        payload_buff[MAX_USER_DATA_SIZE]; 
....................  
.................... // Keeps track of how many bytes to send and passed between pkgen and pksend 
.................... uint8_t num_of_bytes_to_send = 0; 
.................... uint8_t num_of_bytes_to_send_isr = 0; 
....................  
.................... // This is specific to the subroutine 
.................... //  pkgen_send() which creates the message 
.................... //  to be sent from the mote to the net                      
.................... uint8_t     send_prefix[12]; 
....................  
.................... // send_prefix[11] will be set to number of bytes in packet 
.................... // The send_prefix structure is as follows: 
.................... // [0]      CMD_SEND 
.................... // [1]      length of request       - this is payload length + 9 
.................... // [2]      FLAG_SEND_REQUEST 
.................... // [3]/[4]  destination address     - always DESTADDR_HI, DESTADDR_LO 
.................... // [5]      svc_index               - get this from service indication received 
.................... //                                     at join time 
.................... // [6]      APPDOMAIN_MAINTENANCE 
.................... // [7]      PRIORITY_HIGH 
.................... // [8][9]   reserved                - 0x00, 0x00  
.................... // [10]     sequence_num            - always 0xFF for mote-originated packets 
.................... // [11]     payload length          - length of the payload in bytes 
....................  
....................  
.................... // For ensuring a message was recieved properly from mote 
.................... uint8_t result_rcvd = 0; 
....................  
.................... // JG Jan 2017 
.................... int1 fl_alt_LCD; 
....................  
.................... // Flag for going through deal with mote ISR and going to sleep afterwards 
.................... int1 fl_mote_dealt; 
....................  
.................... // Flag for a sucessful get/set response eliminating a few other flags 
.................... int1  global_set_get_response; 
....................  
.................... // FLAGS TO GET RID OF! 
.................... // Flag for receiving an advertisment 
.................... int1  advert_rcvd_fl; 
.................... int1  setnetid_done_fl; 
.................... int1  ack_sent_fl; 
.................... int1  pkt_rcvd_fl; 
.................... int1  joinduty_done_fl; 
.................... int1  gettime_done_fl; 
.................... int1  fl_batNOEE; 
.................... int1  joinkey_done_fl; 
.................... int1  joincmd_done_fl; 
....................  
.................... uint8_t flags_rcvd = 0 ,param_type_rcvd = 0, svc_index_rcvd=0; 
.................... uint16_t mote_msgSEQ = 0; 
....................  
.................... //Globals for when advertisements are received 
.................... uint16_t network_id_rcvd = NETWORK_ID_DEF; 
.................... uint16_t mote_id_rcvd = 0; 
.................... int8_t rssi_rcvd = 0; 
.................... uint8_t hop_depth_rcvd = 0; 
....................  
.................... // global variable that keeps track of the current temperature of the mote.   
.................... //    It is updated every MOTE_CHECKS_TIME seconds 
.................... int8_t global_mote_temperature = 0; 
....................  
.................... ////////////////////Priority Queue///////////////////////////////////////////// 
.................... // Actual priority queue 
.................... volatile uint8_t global_priority_queue[MAX_PRIORITY_QUEUE_ITEMS] = {0}; 
.................... volatile uint8_t global_current_priority_queue_location = (0-1); 
....................  
.................... ////////////////////Time Queue///////////////////////////////////////////////// 
.................... // Actual time queue 
.................... struct TimeQueueItem global_time_queue[MAX_TIME_QUEUE_ITEMS] = {0}; 
.................... uint8_t global_current_time_queue_location = (0-1); 
....................  
.................... ////////////////////Sprinkler Queue//////////////////////////////////////////// 
.................... // Actual sprinkler queue 
.................... struct SprinklerQueueItem global_sprinkler_queue[MAX_SPRINKLER_QUEUE_ITEMS] = {0}; 
.................... uint8_t global_current_sprinkler_queue_location = (0-1); 
.................... // when the current sprinkler command is supposed to end 
.................... uint32_t global_current_sprinkler_settings_end_time = (0-1); 
....................  
.................... ////////////////////Command Queue////////////////////////////////////////////// 
.................... // Actual command queue              
.................... struct CommandQueueItem global_command_queue[MAX_COMMAND_QUEUE_ITEMS] = {0}; 
.................... uint8_t global_current_command_queue_location = (0-1); 
....................  
.................... ////////////////////Message Queue////////////////////////////////////////////// 
.................... // Actual command queue                 
.................... struct MessageQueueItem global_message_queue[MAX_MESSAGE_QUEUE_ITEMS] = {0}; 
.................... uint8_t global_current_message_queue_location = (0-1); 
.................... // global variable that stores the current errors encountered that will be sent 
.................... //    to the manager via an unsolicited error message 
.................... uint32_t global_error_message_bitfield = 0; 
....................  
.................... // the last error message's bitfield and send time for stopping reoccuring error messages 
.................... uint32_t last_error_message_sent_bitfield = 0; 
.................... uint32_t last_error_message_sent_rtc_time = 0; 
....................  
.................... ////////////////////System State Variables///////////////////////////////////// 
.................... uint8_t global_mote_state = MOTESTATE_UNKNOWN; 
.................... uint8_t global_system_state = SYSTEM_STATE_UNKNOWN; 
....................  
.................... ////////////////////Misc/////////////////////////////////////////////////////// 
....................  
....................  
.................... #include "eeprom.h" 
.................... // EEPROM.h 
.................... // This contains all things related to the EEPROM 
.................... // -functions 
.................... // -#defines for memory locations 
.................... // -#defines conveted to eeprom values to load/store out of EEPROM 
....................  
.................... ////////////////////EEPROM Locations Start/////////////////////////////////////////////////////////////  
....................                                                              
.................... // start of EEPROM locations 
.................... #define EE_START_LOCATION     0x0000 
.................... // Location ID                                                                    
.................... #define EE_SPRINKLER_NUM      0x0000 
.................... // Cause for shutdown/restart 
.................... #define EE_RESTART_CAUSE      0x0002                                               
.................... // Last valve calibrations and time            
.................... #define EE_VLV_TIME_TO_OPEN   0x0004                                      
.................... #define EE_VLV_TIME_TO_CLOSE  0x0006                                             
.................... #define EE_VLV_CAL_UTC_TIME   0x0008                                     
.................... // Last valve position 
.................... #define EE_VLV_POSITION       0x000C                                                    
....................                   
.................... // start of eeprom changable variables                                             
.................... #define EE_VLV_NEAR_CLOSED_RANGE_MAX 0x000E 
.................... #define EE_VLV_NEAR_OPENED_RANGE_MAX 0x0010               
.................... #define EE_DAC_LVL_OPENING_NEAR_OPENED 0x0012   
.................... #define EE_DAC_LVL_OPENING_NEAR_CLOSED 0x0014   
.................... #define EE_DAC_LVL_CLOSING_NEAR_OPENED 0x0016   
.................... #define EE_DAC_LVL_CLOSING_NEAR_CLOSED 0x0018   
.................... #define EE_DAC_LVL_IN_MIDDLE 0x001A 
.................... #define EE_DAC_LVL_INIT_CURRENT_BOOST 0x001C 
.................... #define EE_VLV_INIT_CURRENT_BOOST_TIME_1024THS 0x001E  
.................... #define EE_VLV_NOT_SPIN_LIMIT 0x0020   
.................... #define EE_VLV_NOT_SPIN_FIX 0x0022   
.................... #define EE_NOT_SPINNING_MAG_DECOUPLING_RPM_FIXED 0x0024   
.................... #define EE_VLV_MAGNETIC_COUPLING_LIMIT 0x0026   
.................... #define EE_VLV_MAGNETIC_COUPLING_FIX 0x0028   
.................... #define EE_RPM_TIMEOUT 0x002A 
.................... #define EE_MOTE_SEARCH_TIME 0x002C 
.................... #define EE_MOTE_NETWORK_SHUTDOWN_TIMEOUT 0x002E                                         
.................... // end of eeprom changeable variables 
....................  
.................... // last byte of EEPROM used 
.................... #define EE_END_LOCATION       0x002F     
....................                                           
....................  
.................... ////////////////////EEPROM Locations End/////////////////////////////////////////////////////////////// 
....................  
....................  ////////////////////EEPROM defines->globals Start//////////////////////////////////////////////////////   
.................... // Maximum value of "near closed" range 
.................... uint16_t VLV_NEAR_CLOSED_RANGE_MAX = 0x1000; 
.................... // Maximum value of "near opened" range 
.................... uint16_t VLV_NEAR_OPENED_RANGE_MAX =   0x7000;     
....................                                             
.................... // DAC level while opening near the fully open end 
.................... uint16_t DAC_LVL_OPENING_NEAR_OPENED =      24; 
.................... // DAC level while opening near the fully closed end 
.................... uint16_t DAC_LVL_OPENING_NEAR_CLOSED =      20;    
.................... // DAC level while closing near the fully open end 
.................... uint16_t DAC_LVL_CLOSING_NEAR_OPENED =      20; 
.................... // DAC level while closing near the fully closed end                         
.................... uint16_t DAC_LVL_CLOSING_NEAR_CLOSED =      24;  
.................... // DAC level while moving in the middle of the valve range and it's default 
.................... uint16_t DAC_LVL_IN_MIDDLE =                19;  
.................... // DAC level for the inital current boost/lowered current limit   
.................... uint16_t DAC_LVL_INIT_CURRENT_BOOST =       19;      
....................                                                             
.................... // Amount of millispans that a current boost/lovered dac level is implemented. 
.................... //    This is done outside of the (NEAR_CLOSED/OPEN_RANGE)    
.................... //    @ 45 seconds to close, 30 = 1.3 seconds 
.................... uint16_t VLV_INIT_CURRENT_BOOST_TIME_1024THS =  30;   
....................                                                
.................... // valve not-spinning and magnetic de-coupling defines                                                     
.................... // below this number is the regime where we watch for the not spinning case (low torque)  
.................... uint16_t VLV_NOT_SPIN_LIMIT =               0x4000; 
.................... // where we send the valve when we want to fix it.  If it gets fixed before reaching this valve position 
.................... //    it stops. If it does not get fixed by the time it reaches this position, it sends an error and stops. 
.................... uint16_t VLV_NOT_SPIN_FIX =                 0x7000; 
....................                                                
.................... // above this rpm, consider magnetic coupling or not-spinning fixed 
.................... uint8_t NOT_SPINNING_MAG_DECOUPLING_RPM_FIXED =  8;        
....................                                                    
.................... // above this number is the regime where we watch for the magnetic decoupling 
.................... uint16_t VLV_MAGNETIC_COUPLING_LIMIT =      0x5000;        
.................... // where to move the valve at a time when trying to recover  
.................... uint16_t VLV_MAGNETIC_COUPLING_FIX =        0x1000;              
.................... // amount to move the valve at a time when trying to recover    
....................                                                                            
.................... // how many seconds it takes to consider the rpm to be zero (or infinite for higher valve settings) 
.................... // 8 = 7.5 RPM (8 may be max of what ccp5 can handle without overflow)    
.................... // JG SAYS that RPM_TIMEOUT of 2 makes more sense because 
.................... //  any time which exceeds 1 second indicates that the RPM is less than 1.2, 
.................... //  a very low number which we can consider to equal 0. 
.................... uint16_t RPM_TIMEOUT =                     2; 
....................                                         
.................... // amount of seconds for mote to stay searching for advertisements                     
.................... uint16_t MOTE_SEARCH_TIME = 120;        
.................... // amount of time the mote will stay disconnected from the network before shutting down (1200 = 20 min)                                    
.................... uint16_t MOTE_NETWORK_SHUTDOWN_TIMEOUT = 1200;                      
....................  
.................... ////////////////////EEPROM defines->globals End////////////////////////////////////////////////////////  
....................   
.................... ////////////////////EEPROM Functions Start/////////////////////////////////////////////////////////////  
.................... uint8_t read_ee1(uint16_t source) 
.................... {                                                                  
....................    return read_eeprom(source); 
*
03384:  MOVFF  FF2,556
03388:  BCF    FF2.7
0338A:  MOVFF  555,FAA
0338E:  MOVFF  554,FA9
03392:  BCF    FA6.6
03394:  BCF    FA6.7
03396:  BSF    FA6.0
03398:  MOVF   FA8,W
0339A:  MOVLB  5
0339C:  BTFSC  x56.7
0339E:  BSF    FF2.7
033A0:  MOVWF  01
033A2:  MOVLB  0
033A4:  RETURN 0
.................... }                 
.................... uint16_t read_ee2(uint16_t source) 
.................... { 
....................    return (make16(read_eeprom(source+1), read_eeprom(source))); 
*
032B4:  MOVLW  01
032B6:  MOVLB  5
032B8:  ADDWF  x54,W
032BA:  MOVWF  x56
032BC:  MOVLW  00
032BE:  ADDWFC x55,W
032C0:  MOVWF  x57
032C2:  MOVFF  FF2,558
032C6:  BCF    FF2.7
032C8:  MOVFF  557,FAA
032CC:  MOVFF  556,FA9
032D0:  BCF    FA6.6
032D2:  BCF    FA6.7
032D4:  BSF    FA6.0
032D6:  MOVF   FA8,W
032D8:  BTFSC  x58.7
032DA:  BSF    FF2.7
032DC:  MOVWF  x56
032DE:  MOVFF  FF2,557
032E2:  BCF    FF2.7
032E4:  MOVFF  555,FAA
032E8:  MOVFF  554,FA9
032EC:  BCF    FA6.6
032EE:  BCF    FA6.7
032F0:  BSF    FA6.0
032F2:  MOVF   FA8,W
032F4:  BTFSC  x57.7
032F6:  BSF    FF2.7
032F8:  MOVWF  x59
032FA:  MOVFF  556,03
032FE:  MOVF   x59,W
03300:  MOVWF  01
03302:  MOVF   03,W
03304:  MOVWF  02
03306:  MOVLB  0
03308:  RETURN 0
.................... }  
.................... uint32_t read_ee4(uint16_t source) 
.................... { 
....................    return (make32(read_eeprom(source+3), read_eeprom(source+2), read_eeprom(source+1), read_eeprom(source))); 
*
033D8:  MOVLW  03
033DA:  MOVLB  5
033DC:  ADDWF  x54,W
033DE:  MOVWF  x56
033E0:  MOVLW  00
033E2:  ADDWFC x55,W
033E4:  MOVWF  x57
033E6:  MOVFF  FF2,558
033EA:  BCF    FF2.7
033EC:  MOVFF  557,FAA
033F0:  MOVFF  556,FA9
033F4:  BCF    FA6.6
033F6:  BCF    FA6.7
033F8:  BSF    FA6.0
033FA:  MOVF   FA8,W
033FC:  BTFSC  x58.7
033FE:  BSF    FF2.7
03400:  MOVWF  x56
03402:  MOVLW  02
03404:  ADDWF  x54,W
03406:  MOVWF  x59
03408:  MOVLW  00
0340A:  ADDWFC x55,W
0340C:  MOVWF  x5A
0340E:  MOVFF  FF2,557
03412:  BCF    FF2.7
03414:  MOVFF  55A,FAA
03418:  MOVFF  559,FA9
0341C:  BCF    FA6.6
0341E:  BCF    FA6.7
03420:  BSF    FA6.0
03422:  MOVF   FA8,W
03424:  BTFSC  x57.7
03426:  BSF    FF2.7
03428:  MOVWF  x59
0342A:  MOVLW  01
0342C:  ADDWF  x54,W
0342E:  MOVWF  x5A
03430:  MOVLW  00
03432:  ADDWFC x55,W
03434:  MOVWF  x5B
03436:  MOVFF  FF2,55C
0343A:  BCF    FF2.7
0343C:  MOVFF  55B,FAA
03440:  MOVFF  55A,FA9
03444:  BCF    FA6.6
03446:  BCF    FA6.7
03448:  BSF    FA6.0
0344A:  MOVF   FA8,W
0344C:  BTFSC  x5C.7
0344E:  BSF    FF2.7
03450:  MOVWF  x5A
03452:  MOVFF  FF2,55B
03456:  BCF    FF2.7
03458:  MOVFF  555,FAA
0345C:  MOVFF  554,FA9
03460:  BCF    FA6.6
03462:  BCF    FA6.7
03464:  BSF    FA6.0
03466:  MOVF   FA8,W
03468:  BTFSC  x5B.7
0346A:  BSF    FF2.7
0346C:  MOVWF  x5D
0346E:  MOVFF  556,03
03472:  MOVFF  559,02
03476:  MOVFF  55A,01
0347A:  MOVFF  55D,00
0347E:  MOVLB  0
03480:  RETURN 0
.................... } 
....................  
.................... void write_ee1(uint16_t dest, uint8_t dat8) 
.................... { 
....................    write_eeprom(dest, dat8); 
*
033A6:  MOVF   FF2,W
033A8:  MOVWF  00
033AA:  BCF    FF2.7
033AC:  MOVFF  555,FAA
033B0:  MOVFF  554,FA9
033B4:  MOVFF  556,FA8
033B8:  BCF    FA6.6
033BA:  BCF    FA6.7
033BC:  BSF    FA6.2
033BE:  MOVLB  F
033C0:  MOVLW  55
033C2:  MOVWF  FA7
033C4:  MOVLW  AA
033C6:  MOVWF  FA7
033C8:  BSF    FA6.1
033CA:  BTFSC  FA6.1
033CC:  BRA    33CA
033CE:  BCF    FA6.2
033D0:  MOVF   00,W
033D2:  IORWF  FF2,F
033D4:  MOVLB  0
033D6:  RETURN 0
.................... } 
....................  
.................... void write_ee2(uint16_t dest, uint16_t dat16) 
.................... { 
....................    write_eeprom(dest++, make8(dat16,0)); 
*
0330A:  MOVLB  5
0330C:  MOVF   x57,W
0330E:  MOVWF  03
03310:  MOVF   x56,W
03312:  INCF   x56,F
03314:  BTFSC  FD8.2
03316:  INCF   x57,F
03318:  MOVWF  x5A
0331A:  MOVFF  03,55B
0331E:  MOVFF  558,55C
03322:  MOVF   FF2,W
03324:  MOVWF  00
03326:  BCF    FF2.7
03328:  MOVFF  55B,FAA
0332C:  MOVFF  55A,FA9
03330:  MOVFF  55C,FA8
03334:  BCF    FA6.6
03336:  BCF    FA6.7
03338:  BSF    FA6.2
0333A:  MOVLB  F
0333C:  MOVLW  55
0333E:  MOVWF  FA7
03340:  MOVLW  AA
03342:  MOVWF  FA7
03344:  BSF    FA6.1
03346:  BTFSC  FA6.1
03348:  BRA    3346
0334A:  BCF    FA6.2
0334C:  MOVF   00,W
0334E:  IORWF  FF2,F
....................    write_eeprom(dest, make8(dat16,1)); 
03350:  MOVFF  559,55A
03354:  MOVFF  FF2,00
03358:  BCF    FF2.7
0335A:  MOVFF  557,FAA
0335E:  MOVFF  556,FA9
03362:  MOVFF  559,FA8
03366:  BCF    FA6.6
03368:  BCF    FA6.7
0336A:  BSF    FA6.2
0336C:  MOVLW  55
0336E:  MOVWF  FA7
03370:  MOVLW  AA
03372:  MOVWF  FA7
03374:  BSF    FA6.1
03376:  BTFSC  FA6.1
03378:  BRA    3376
0337A:  BCF    FA6.2
0337C:  MOVF   00,W
0337E:  IORWF  FF2,F
03380:  MOVLB  0
03382:  RETURN 0
.................... } 
....................  
.................... void write_ee4(uint16_t dest, uint32_t dat32) 
.................... { 
....................    write_eeprom(dest++, make8(dat32,0)); 
*
06AC6:  MOVLB  5
06AC8:  MOVF   x59,W
06ACA:  MOVWF  03
06ACC:  MOVF   x58,W
06ACE:  INCF   x58,F
06AD0:  BTFSC  FD8.2
06AD2:  INCF   x59,F
06AD4:  MOVWF  x5E
06AD6:  MOVFF  03,55F
06ADA:  MOVFF  55A,560
06ADE:  MOVF   FF2,W
06AE0:  MOVWF  00
06AE2:  BCF    FF2.7
06AE4:  MOVFF  55F,FAA
06AE8:  MOVFF  55E,FA9
06AEC:  MOVFF  560,FA8
06AF0:  BCF    FA6.6
06AF2:  BCF    FA6.7
06AF4:  BSF    FA6.2
06AF6:  MOVLB  F
06AF8:  MOVLW  55
06AFA:  MOVWF  FA7
06AFC:  MOVLW  AA
06AFE:  MOVWF  FA7
06B00:  BSF    FA6.1
06B02:  BTFSC  FA6.1
06B04:  BRA    6B02
06B06:  BCF    FA6.2
06B08:  MOVF   00,W
06B0A:  IORWF  FF2,F
....................    write_eeprom(dest++, make8(dat32,1)); 
06B0C:  MOVLB  5
06B0E:  MOVF   x59,W
06B10:  MOVWF  03
06B12:  MOVF   x58,W
06B14:  INCF   x58,F
06B16:  BTFSC  FD8.2
06B18:  INCF   x59,F
06B1A:  MOVWF  x5E
06B1C:  MOVFF  03,55F
06B20:  MOVFF  55B,560
06B24:  MOVF   FF2,W
06B26:  MOVWF  00
06B28:  BCF    FF2.7
06B2A:  MOVFF  55F,FAA
06B2E:  MOVFF  55E,FA9
06B32:  MOVFF  560,FA8
06B36:  BCF    FA6.6
06B38:  BCF    FA6.7
06B3A:  BSF    FA6.2
06B3C:  MOVLB  F
06B3E:  MOVLW  55
06B40:  MOVWF  FA7
06B42:  MOVLW  AA
06B44:  MOVWF  FA7
06B46:  BSF    FA6.1
06B48:  BTFSC  FA6.1
06B4A:  BRA    6B48
06B4C:  BCF    FA6.2
06B4E:  MOVF   00,W
06B50:  IORWF  FF2,F
....................    write_eeprom(dest++, make8(dat32,2)); 
06B52:  MOVLB  5
06B54:  MOVF   x59,W
06B56:  MOVWF  03
06B58:  MOVF   x58,W
06B5A:  INCF   x58,F
06B5C:  BTFSC  FD8.2
06B5E:  INCF   x59,F
06B60:  MOVWF  x5E
06B62:  MOVFF  03,55F
06B66:  MOVFF  55C,560
06B6A:  MOVF   FF2,W
06B6C:  MOVWF  00
06B6E:  BCF    FF2.7
06B70:  MOVFF  55F,FAA
06B74:  MOVFF  55E,FA9
06B78:  MOVFF  560,FA8
06B7C:  BCF    FA6.6
06B7E:  BCF    FA6.7
06B80:  BSF    FA6.2
06B82:  MOVLB  F
06B84:  MOVLW  55
06B86:  MOVWF  FA7
06B88:  MOVLW  AA
06B8A:  MOVWF  FA7
06B8C:  BSF    FA6.1
06B8E:  BTFSC  FA6.1
06B90:  BRA    6B8E
06B92:  BCF    FA6.2
06B94:  MOVF   00,W
06B96:  IORWF  FF2,F
....................    write_eeprom(dest, make8(dat32,3)); 
06B98:  MOVFF  55D,55E
06B9C:  MOVFF  FF2,00
06BA0:  BCF    FF2.7
06BA2:  MOVFF  559,FAA
06BA6:  MOVFF  558,FA9
06BAA:  MOVFF  55D,FA8
06BAE:  BCF    FA6.6
06BB0:  BCF    FA6.7
06BB2:  BSF    FA6.2
06BB4:  MOVLW  55
06BB6:  MOVWF  FA7
06BB8:  MOVLW  AA
06BBA:  MOVWF  FA7
06BBC:  BSF    FA6.1
06BBE:  BTFSC  FA6.1
06BC0:  BRA    6BBE
06BC2:  BCF    FA6.2
06BC4:  MOVF   00,W
06BC6:  IORWF  FF2,F
06BC8:  MOVLB  0
06BCA:  RETURN 0
.................... }                                              
....................  
.................... void store_all_eeprom_values(void) 
.................... {                                                                                                   
....................  
....................    // store valve calibration times in EEPROM 
....................    write_ee2(EE_VLV_TIME_TO_OPEN, global_valve_time_to_open_1024th); 
*
09E22:  MOVLB  5
09E24:  CLRF   x57
09E26:  MOVLW  04
09E28:  MOVWF  x56
09E2A:  MOVFF  C8,559
09E2E:  MOVFF  C7,558
09E32:  MOVLB  0
09E34:  CALL   330A
....................    write_ee2(EE_VLV_TIME_TO_CLOSE, global_valve_time_to_close_1024th); 
09E38:  MOVLB  5
09E3A:  CLRF   x57
09E3C:  MOVLW  06
09E3E:  MOVWF  x56
09E40:  MOVFF  C6,559
09E44:  MOVFF  C5,558
09E48:  MOVLB  0
09E4A:  CALL   330A
....................    write_ee4(EE_VLV_CAL_UTC_TIME, global_valve_calibration_utc_time); 
09E4E:  MOVLB  5
09E50:  CLRF   x59
09E52:  MOVLW  08
09E54:  MOVWF  x58
09E56:  MOVFF  CE,55D
09E5A:  MOVFF  CD,55C
09E5E:  MOVFF  CC,55B
09E62:  MOVFF  CB,55A
09E66:  MOVLB  0
09E68:  CALL   6AC6
....................    write_ee2(EE_VLV_POSITION, global_valve_position); 
09E6C:  MOVLB  5
09E6E:  CLRF   x57
09E70:  MOVLW  0C
09E72:  MOVWF  x56
09E74:  MOVFF  C2,559
09E78:  MOVFF  C1,558
09E7C:  MOVLB  0
09E7E:  CALL   330A
....................    // save the shutdown/restart reason in EEPROM 
....................    write_ee1(EE_RESTART_CAUSE, global_shutdown_cause);                                         
09E82:  MOVLB  5
09E84:  CLRF   x55
09E86:  MOVLW  02
09E88:  MOVWF  x54
09E8A:  MOVFF  4D,556
09E8E:  MOVLB  0
09E90:  CALL   33A6
09E94:  RETURN 0
....................                                                                          
.................... } 
....................  
....................  
.................... void read_all_eeprom_values(void) 
.................... { 
....................    // if EEPROM is freshly flashed, overwrite sprinkler number with 0 
....................    if (read_ee2(EE_SPRINKLER_NUM) == 0xFFFF) write_ee2(EE_SPRINKLER_NUM,0);      
*
03482:  MOVLB  5
03484:  CLRF   x55
03486:  CLRF   x54
03488:  MOVLB  0
0348A:  RCALL  32B4
0348C:  MOVFF  02,54C
03490:  MOVFF  01,54B
03494:  MOVLB  5
03496:  INCFSZ 01,W
03498:  BRA    34AC
0349A:  INCFSZ x4C,W
0349C:  BRA    34AC
0349E:  CLRF   x57
034A0:  CLRF   x56
034A2:  CLRF   x59
034A4:  CLRF   x58
034A6:  MOVLB  0
034A8:  RCALL  330A
034AA:  MOVLB  5
....................    // pull the sprinkler number from EEPROM  
....................    global_sprinkler_num = read_ee2(EE_SPRINKLER_NUM); 
034AC:  CLRF   x55
034AE:  CLRF   x54
034B0:  MOVLB  0
034B2:  RCALL  32B4
034B4:  MOVFF  02,96
034B8:  MOVFF  01,95
....................    // grab the shutdown cause and overwrite it for next time 
....................    global_previous_shutdown_cause = read_ee1(EE_RESTART_CAUSE); 
034BC:  MOVLB  5
034BE:  CLRF   x55
034C0:  MOVLW  02
034C2:  MOVWF  x54
034C4:  MOVLB  0
034C6:  RCALL  3384
034C8:  MOVFF  01,4E
....................    write_ee1(EE_RESTART_CAUSE,NO_ERR); 
034CC:  MOVLB  5
034CE:  CLRF   x55
034D0:  MOVLW  02
034D2:  MOVWF  x54
034D4:  CLRF   x56
034D6:  MOVLB  0
034D8:  RCALL  33A6
....................                                                     
....................    // read valve calibration times and position in EEPROM 
....................    // if freshly flashed, valve position should default to 0xFFFF, which 
....................    // is defined as VLV_POSITION_UNKNOWN 
....................    global_valve_time_to_open_1024th = read_ee2(EE_VLV_TIME_TO_OPEN); 
034DA:  MOVLB  5
034DC:  CLRF   x55
034DE:  MOVLW  04
034E0:  MOVWF  x54
034E2:  MOVLB  0
034E4:  RCALL  32B4
034E6:  MOVFF  02,C8
034EA:  MOVFF  01,C7
....................    global_valve_time_to_close_1024th = read_ee2(EE_VLV_TIME_TO_CLOSE); 
034EE:  MOVLB  5
034F0:  CLRF   x55
034F2:  MOVLW  06
034F4:  MOVWF  x54
034F6:  MOVLB  0
034F8:  RCALL  32B4
034FA:  MOVFF  02,C6
034FE:  MOVFF  01,C5
....................     
....................    if ((global_valve_time_to_open_1024th < ERROR_VLV_CAL_TIME_LO) || \ 
....................        (global_valve_time_to_open_1024th > ERROR_VLV_CAL_TIME_HI)) 
03502:  MOVF   xC8,W
03504:  SUBLW  02
03506:  BNC   3510
03508:  BNZ   3520
0350A:  MOVF   xC7,W
0350C:  SUBLW  ED
0350E:  BC    3520
03510:  MOVF   xC8,W
03512:  SUBLW  08
03514:  BC    3538
03516:  XORLW  FF
03518:  BNZ   3520
0351A:  MOVF   xC7,W
0351C:  SUBLW  C4
0351E:  BC    3538
....................    { 
....................       global_valve_time_to_open_1024th = DEFAULT_VLV_TIME_TO_OPEN; 
03520:  MOVLW  05
03522:  MOVWF  xC8
03524:  CLRF   xC7
....................       write_ee2 (EE_VLV_TIME_TO_OPEN, DEFAULT_VLV_TIME_TO_OPEN); 
03526:  MOVLB  5
03528:  CLRF   x57
0352A:  MOVLW  04
0352C:  MOVWF  x56
0352E:  MOVLW  05
03530:  MOVWF  x59
03532:  CLRF   x58
03534:  MOVLB  0
03536:  RCALL  330A
....................    } 
....................     
....................    if ((global_valve_time_to_close_1024th < ERROR_VLV_CAL_TIME_LO) || \ 
....................        (global_valve_time_to_close_1024th > ERROR_VLV_CAL_TIME_HI)) 
03538:  MOVF   xC6,W
0353A:  SUBLW  02
0353C:  BNC   3546
0353E:  BNZ   3556
03540:  MOVF   xC5,W
03542:  SUBLW  ED
03544:  BC    3556
03546:  MOVF   xC6,W
03548:  SUBLW  08
0354A:  BC    356E
0354C:  XORLW  FF
0354E:  BNZ   3556
03550:  MOVF   xC5,W
03552:  SUBLW  C4
03554:  BC    356E
....................    { 
....................       global_valve_time_to_close_1024th = DEFAULT_VLV_TIME_TO_CLOSE; 
03556:  MOVLW  05
03558:  MOVWF  xC6
0355A:  CLRF   xC5
....................       write_ee2 (EE_VLV_TIME_TO_OPEN, DEFAULT_VLV_TIME_TO_OPEN); 
0355C:  MOVLB  5
0355E:  CLRF   x57
03560:  MOVLW  04
03562:  MOVWF  x56
03564:  MOVLW  05
03566:  MOVWF  x59
03568:  CLRF   x58
0356A:  MOVLB  0
0356C:  RCALL  330A
....................    } 
....................  
....................  // for cleared EEPROM, the following read will give us 0xFFFFFFFF, so 
....................  //  add 1 so that it is 0.  This global is compared to current time 
....................  //  to determine if the valve calibration is stale 
....................    global_valve_calibration_utc_time = 1 + read_ee4(EE_VLV_CAL_UTC_TIME); 
0356E:  MOVLB  5
03570:  CLRF   x55
03572:  MOVLW  08
03574:  MOVWF  x54
03576:  MOVLB  0
03578:  RCALL  33D8
0357A:  MOVLW  01
0357C:  ADDWF  00,W
0357E:  MOVWF  xCB
03580:  MOVLW  00
03582:  ADDWFC 01,W
03584:  MOVWF  xCC
03586:  MOVLW  00
03588:  ADDWFC 02,W
0358A:  MOVWF  xCD
0358C:  MOVLW  00
0358E:  ADDWFC 03,W
03590:  MOVWF  xCE
....................    global_valve_position = read_ee2(EE_VLV_POSITION); 
03592:  MOVLB  5
03594:  CLRF   x55
03596:  MOVLW  0C
03598:  MOVWF  x54
0359A:  MOVLB  0
0359C:  RCALL  32B4
0359E:  MOVFF  02,C2
035A2:  MOVFF  01,C1
....................    // store unknown valve position incase it doesn't get stored properly on shutdown/restart 
....................    //    so the position isn't used from before 
....................    write_ee2(EE_VLV_POSITION, VLV_POSITION_UNKNOWN); 
035A6:  MOVLB  5
035A8:  CLRF   x57
035AA:  MOVLW  0C
035AC:  MOVWF  x56
035AE:  SETF   x59
035B0:  SETF   x58
035B2:  MOVLB  0
035B4:  RCALL  330A
035B6:  GOTO   A218 (RETURN)
....................  
.................... } 
....................  
.................... void store_vcal_eeprom_values(void) 
.................... {   
....................    // store valve calibration times in EEPROM 
....................    write_ee2(EE_VLV_TIME_TO_OPEN, global_valve_time_to_open_1024th); 
*
08098:  MOVLB  5
0809A:  CLRF   x57
0809C:  MOVLW  04
0809E:  MOVWF  x56
080A0:  MOVFF  C8,559
080A4:  MOVFF  C7,558
080A8:  MOVLB  0
080AA:  CALL   330A
....................    write_ee2(EE_VLV_TIME_TO_CLOSE, global_valve_time_to_close_1024th); 
080AE:  MOVLB  5
080B0:  CLRF   x57
080B2:  MOVLW  06
080B4:  MOVWF  x56
080B6:  MOVFF  C6,559
080BA:  MOVFF  C5,558
080BE:  MOVLB  0
080C0:  CALL   330A
....................    write_ee4(EE_VLV_CAL_UTC_TIME, global_valve_calibration_utc_time); 
080C4:  MOVLB  5
080C6:  CLRF   x59
080C8:  MOVLW  08
080CA:  MOVWF  x58
080CC:  MOVFF  CE,55D
080D0:  MOVFF  CD,55C
080D4:  MOVFF  CC,55B
080D8:  MOVFF  CB,55A
080DC:  MOVLB  0
080DE:  CALL   6AC6
080E2:  GOTO   A7B8 (RETURN)
.................... }                                                               
....................  
.................... void read_all_eeprom_variables(void)     
.................... {                                        
....................    uint16_t temp_u16; 
....................  
....................    temp_u16 = read_ee2(EE_VLV_NEAR_CLOSED_RANGE_MAX);        
*
035BA:  MOVLB  5
035BC:  CLRF   x55
035BE:  MOVLW  0E
035C0:  MOVWF  x54
035C2:  MOVLB  0
035C4:  RCALL  32B4
035C6:  MOVFF  02,54C
035CA:  MOVFF  01,54B
....................    if (temp_u16 != 0xFFFF) VLV_NEAR_CLOSED_RANGE_MAX = temp_u16;  
035CE:  MOVLB  5
035D0:  INCFSZ x4B,W
035D2:  BRA    35DA
035D4:  INCFSZ x4C,W
035D6:  BRA    35DA
035D8:  BRA    35E2
035DA:  MOVFF  54C,507
035DE:  MOVFF  54B,506
....................     
....................    temp_u16 = read_ee2(EE_VLV_NEAR_OPENED_RANGE_MAX);        
035E2:  CLRF   x55
035E4:  MOVLW  10
035E6:  MOVWF  x54
035E8:  MOVLB  0
035EA:  RCALL  32B4
035EC:  MOVFF  02,54C
035F0:  MOVFF  01,54B
....................    if (temp_u16 != 0xFFFF) VLV_NEAR_OPENED_RANGE_MAX = temp_u16; 
035F4:  MOVLB  5
035F6:  INCFSZ x4B,W
035F8:  BRA    3600
035FA:  INCFSZ x4C,W
035FC:  BRA    3600
035FE:  BRA    3608
03600:  MOVFF  54C,509
03604:  MOVFF  54B,508
....................     
....................    temp_u16 = read_ee2(EE_DAC_LVL_OPENING_NEAR_OPENED);        
03608:  CLRF   x55
0360A:  MOVLW  12
0360C:  MOVWF  x54
0360E:  MOVLB  0
03610:  RCALL  32B4
03612:  MOVFF  02,54C
03616:  MOVFF  01,54B
....................    if (temp_u16 != 0xFFFF) DAC_LVL_OPENING_NEAR_OPENED = temp_u16; 
0361A:  MOVLB  5
0361C:  INCFSZ x4B,W
0361E:  BRA    3626
03620:  INCFSZ x4C,W
03622:  BRA    3626
03624:  BRA    362E
03626:  MOVFF  54C,50B
0362A:  MOVFF  54B,50A
....................     
....................    temp_u16 = read_ee2(EE_DAC_LVL_OPENING_NEAR_CLOSED);        
0362E:  CLRF   x55
03630:  MOVLW  14
03632:  MOVWF  x54
03634:  MOVLB  0
03636:  RCALL  32B4
03638:  MOVFF  02,54C
0363C:  MOVFF  01,54B
....................    if (temp_u16 != 0xFFFF) DAC_LVL_OPENING_NEAR_CLOSED = temp_u16; 
03640:  MOVLB  5
03642:  INCFSZ x4B,W
03644:  BRA    364C
03646:  INCFSZ x4C,W
03648:  BRA    364C
0364A:  BRA    3654
0364C:  MOVFF  54C,50D
03650:  MOVFF  54B,50C
....................     
....................    temp_u16 = read_ee2(EE_DAC_LVL_CLOSING_NEAR_OPENED);        
03654:  CLRF   x55
03656:  MOVLW  16
03658:  MOVWF  x54
0365A:  MOVLB  0
0365C:  RCALL  32B4
0365E:  MOVFF  02,54C
03662:  MOVFF  01,54B
....................    if (temp_u16 != 0xFFFF) DAC_LVL_CLOSING_NEAR_OPENED = temp_u16; 
03666:  MOVLB  5
03668:  INCFSZ x4B,W
0366A:  BRA    3672
0366C:  INCFSZ x4C,W
0366E:  BRA    3672
03670:  BRA    367A
03672:  MOVFF  54C,50F
03676:  MOVFF  54B,50E
....................     
....................    temp_u16 = read_ee2(EE_DAC_LVL_CLOSING_NEAR_CLOSED);        
0367A:  CLRF   x55
0367C:  MOVLW  18
0367E:  MOVWF  x54
03680:  MOVLB  0
03682:  RCALL  32B4
03684:  MOVFF  02,54C
03688:  MOVFF  01,54B
....................    if (temp_u16 != 0xFFFF) DAC_LVL_CLOSING_NEAR_CLOSED = temp_u16; 
0368C:  MOVLB  5
0368E:  INCFSZ x4B,W
03690:  BRA    3698
03692:  INCFSZ x4C,W
03694:  BRA    3698
03696:  BRA    36A0
03698:  MOVFF  54C,511
0369C:  MOVFF  54B,510
....................     
....................    temp_u16 = read_ee2(EE_DAC_LVL_IN_MIDDLE);        
036A0:  CLRF   x55
036A2:  MOVLW  1A
036A4:  MOVWF  x54
036A6:  MOVLB  0
036A8:  RCALL  32B4
036AA:  MOVFF  02,54C
036AE:  MOVFF  01,54B
....................    if (temp_u16 != 0xFFFF) DAC_LVL_IN_MIDDLE = temp_u16; 
036B2:  MOVLB  5
036B4:  INCFSZ x4B,W
036B6:  BRA    36BE
036B8:  INCFSZ x4C,W
036BA:  BRA    36BE
036BC:  BRA    36C6
036BE:  MOVFF  54C,513
036C2:  MOVFF  54B,512
....................     
....................    temp_u16 = read_ee2(EE_DAC_LVL_INIT_CURRENT_BOOST);        
036C6:  CLRF   x55
036C8:  MOVLW  1C
036CA:  MOVWF  x54
036CC:  MOVLB  0
036CE:  RCALL  32B4
036D0:  MOVFF  02,54C
036D4:  MOVFF  01,54B
....................    if (temp_u16 != 0xFFFF) DAC_LVL_INIT_CURRENT_BOOST = temp_u16; 
036D8:  MOVLB  5
036DA:  INCFSZ x4B,W
036DC:  BRA    36E4
036DE:  INCFSZ x4C,W
036E0:  BRA    36E4
036E2:  BRA    36EC
036E4:  MOVFF  54C,515
036E8:  MOVFF  54B,514
....................     
....................    temp_u16 = read_ee2(EE_VLV_INIT_CURRENT_BOOST_TIME_1024THS);        
036EC:  CLRF   x55
036EE:  MOVLW  1E
036F0:  MOVWF  x54
036F2:  MOVLB  0
036F4:  RCALL  32B4
036F6:  MOVFF  02,54C
036FA:  MOVFF  01,54B
....................    if (temp_u16 != 0xFFFF) VLV_INIT_CURRENT_BOOST_TIME_1024THS = temp_u16; 
036FE:  MOVLB  5
03700:  INCFSZ x4B,W
03702:  BRA    370A
03704:  INCFSZ x4C,W
03706:  BRA    370A
03708:  BRA    3712
0370A:  MOVFF  54C,517
0370E:  MOVFF  54B,516
....................     
....................    temp_u16 = read_ee2(EE_VLV_NOT_SPIN_LIMIT);        
03712:  CLRF   x55
03714:  MOVLW  20
03716:  MOVWF  x54
03718:  MOVLB  0
0371A:  RCALL  32B4
0371C:  MOVFF  02,54C
03720:  MOVFF  01,54B
....................    if (temp_u16 != 0xFFFF) VLV_NOT_SPIN_LIMIT = temp_u16; 
03724:  MOVLB  5
03726:  INCFSZ x4B,W
03728:  BRA    3730
0372A:  INCFSZ x4C,W
0372C:  BRA    3730
0372E:  BRA    3738
03730:  MOVFF  54C,519
03734:  MOVFF  54B,518
....................     
....................    temp_u16 = read_ee2(EE_VLV_NOT_SPIN_FIX);        
03738:  CLRF   x55
0373A:  MOVLW  22
0373C:  MOVWF  x54
0373E:  MOVLB  0
03740:  RCALL  32B4
03742:  MOVFF  02,54C
03746:  MOVFF  01,54B
....................    if (temp_u16 != 0xFFFF) VLV_NOT_SPIN_FIX = temp_u16;   
0374A:  MOVLB  5
0374C:  INCFSZ x4B,W
0374E:  BRA    3756
03750:  INCFSZ x4C,W
03752:  BRA    3756
03754:  BRA    375E
03756:  MOVFF  54C,51B
0375A:  MOVFF  54B,51A
....................     
....................    temp_u16 = read_ee2(EE_NOT_SPINNING_MAG_DECOUPLING_RPM_FIXED);        
0375E:  CLRF   x55
03760:  MOVLW  24
03762:  MOVWF  x54
03764:  MOVLB  0
03766:  RCALL  32B4
03768:  MOVFF  02,54C
0376C:  MOVFF  01,54B
....................    if (temp_u16 != 0xFFFF) NOT_SPINNING_MAG_DECOUPLING_RPM_FIXED = temp_u16;   
03770:  MOVLB  5
03772:  INCFSZ x4B,W
03774:  BRA    377C
03776:  INCFSZ x4C,W
03778:  BRA    377C
0377A:  BRA    3780
0377C:  MOVFF  54B,51C
....................     
....................    temp_u16 = read_ee2(EE_VLV_MAGNETIC_COUPLING_LIMIT);        
03780:  CLRF   x55
03782:  MOVLW  26
03784:  MOVWF  x54
03786:  MOVLB  0
03788:  RCALL  32B4
0378A:  MOVFF  02,54C
0378E:  MOVFF  01,54B
....................    if (temp_u16 != 0xFFFF) VLV_MAGNETIC_COUPLING_LIMIT = temp_u16;   
03792:  MOVLB  5
03794:  INCFSZ x4B,W
03796:  BRA    379E
03798:  INCFSZ x4C,W
0379A:  BRA    379E
0379C:  BRA    37A6
0379E:  MOVFF  54C,51E
037A2:  MOVFF  54B,51D
....................     
....................    temp_u16 = read_ee2(EE_VLV_MAGNETIC_COUPLING_FIX);        
037A6:  CLRF   x55
037A8:  MOVLW  28
037AA:  MOVWF  x54
037AC:  MOVLB  0
037AE:  RCALL  32B4
037B0:  MOVFF  02,54C
037B4:  MOVFF  01,54B
....................    if (temp_u16 != 0xFFFF) VLV_MAGNETIC_COUPLING_FIX = temp_u16; 
037B8:  MOVLB  5
037BA:  INCFSZ x4B,W
037BC:  BRA    37C4
037BE:  INCFSZ x4C,W
037C0:  BRA    37C4
037C2:  BRA    37CC
037C4:  MOVFF  54C,520
037C8:  MOVFF  54B,51F
....................     
....................    temp_u16 = read_ee2(EE_RPM_TIMEOUT);                       
037CC:  CLRF   x55
037CE:  MOVLW  2A
037D0:  MOVWF  x54
037D2:  MOVLB  0
037D4:  RCALL  32B4
037D6:  MOVFF  02,54C
037DA:  MOVFF  01,54B
....................    if (temp_u16 != 0xFFFF) RPM_TIMEOUT = temp_u16;   
037DE:  MOVLB  5
037E0:  INCFSZ x4B,W
037E2:  BRA    37EA
037E4:  INCFSZ x4C,W
037E6:  BRA    37EA
037E8:  BRA    37F2
037EA:  MOVFF  54C,522
037EE:  MOVFF  54B,521
....................     
....................    temp_u16 = read_ee2(EE_MOTE_SEARCH_TIME);        
037F2:  CLRF   x55
037F4:  MOVLW  2C
037F6:  MOVWF  x54
037F8:  MOVLB  0
037FA:  RCALL  32B4
037FC:  MOVFF  02,54C
03800:  MOVFF  01,54B
....................    if (temp_u16 != 0xFFFF) MOTE_SEARCH_TIME = temp_u16;   
03804:  MOVLB  5
03806:  INCFSZ x4B,W
03808:  BRA    3810
0380A:  INCFSZ x4C,W
0380C:  BRA    3810
0380E:  BRA    3818
03810:  MOVFF  54C,524
03814:  MOVFF  54B,523
....................     
....................    temp_u16 = read_ee2(EE_MOTE_NETWORK_SHUTDOWN_TIMEOUT);        
03818:  CLRF   x55
0381A:  MOVLW  2E
0381C:  MOVWF  x54
0381E:  MOVLB  0
03820:  RCALL  32B4
03822:  MOVFF  02,54C
03826:  MOVFF  01,54B
....................    if (temp_u16 != 0xFFFF) MOTE_NETWORK_SHUTDOWN_TIMEOUT = temp_u16;    
0382A:  MOVLB  5
0382C:  INCFSZ x4B,W
0382E:  BRA    3836
03830:  INCFSZ x4C,W
03832:  BRA    3836
03834:  BRA    383E
03836:  MOVFF  54C,526
0383A:  MOVFF  54B,525
0383E:  MOVLB  0
03840:  GOTO   A21C (RETURN)
.................... } 
....................     
....................  
.................... ////////////////////EEPROM Functions End///////////////////////////////////////////////////////////////  
....................                                                                                                     
....................  
....................   
....................  
....................   
.................... // specific headers                    
.................... #include "pic.h" 
.................... // This file contains all functions related to PIC functions and setup 
....................  
.................... //Function Definitions 
....................  
.................... // These defines are used in the oscillator setup subroutines below. 
.................... // Note the situations of concern: 
.................... //    4MHz osc: TMR2 prescale 16, postscale 6, PR2=99;         DIV16_POST6  
.................... //       [PWM freq 625Hz, PWM resolution 400, TMR2 int rate: 9.6ms] 
.................... //    3.6864MHz osc: TMR2 prescale 16, postscale 6, PR2=99;    DIV16_POST6 
.................... //       [PWM freq 576Hz, PWM resolution 400, TMR2 int rate: 10.4ms] 
.................... //    1MHz osc: TMR2 prescale 4, postscale 6, PR2=99;          DIV4_POST6 
.................... //       [PWM freq 625Hz, PWM resolution 400, TMR2 int rate: 9.6ms] 
.................... //    250KHz osc: TMR2 prescale 16, postscale 6, PR2=99;       DIV1_POST6 
.................... //       [PWM freq 625Hz, PWM resolution 400, TMR2 int rate: 9.6ms] 
.................... //    32768Hz osc: TMR2 prescale 1, postscale 1, PR2=79;       DIV1_POST1 
.................... //       [no PWM, TMR2 int rate: 9.8ms] 
.................... //    31250Hz osc: TMR2 prescale 1, postscale 1, PR2=79;       DIV1_POST1 
.................... //       [no PWM, TMR2 int rate: 10.2ms] 
....................  
.................... // SEE p 177 of DS41412F [PIC18(L)F2X/4XK22 datasheet] 
.................... #define  DIV16_POST6    0b00101110 
.................... #define  DIV4_POST6     0b00101101 
.................... #define  DIV1_POST6     0b00101100 
.................... #define  DIV1_POST1     0b00000100 
....................  
.................... // Each of these subroutines 
.................... //    a. save INTCON (high and low global int enab bits) 
.................... //    b. disable global interrupts 
.................... //    c. select the oscillator 
.................... //    d. set up TMR2, which is used to produce the PWM waveforms 
.................... //       and to cause interrupts to checking, e.g., the valve motor current 
.................... //    e. set up delnum param used by the newdel_10ms routine, 
.................... //       which is oscillator-dependent 
.................... //    f. restore INTCON 
....................  
.................... // These routines simply set up OSCCON, T0CON, T2CON, PR2 and osctype. 
....................  
.................... // PR2 is selected to provide a resolution of 400 in the PWM duty cycle 
.................... //  when clock is 250KHz and above. 
.................... // Below 250KHz the duty cycle resolution is unimportant because we would  
.................... //  be idling... 
.................... // The combination of PR2 and T2CON (T2CON includes prescale (1/4/16)  
.................... //  and postscale (..6..) ensures that the TMR2 ints occur at the proper rate  
.................... //  of approx 10ms regardless of the oscillator choice. 
.................... // Finally T0CON is set such that the timer 0 prescaler is selected to provide 
.................... //  TMR0 functionality and accuracy largely independent of oscillator choice: 
.................... //  e.g., at 31250/250k/1m/4m clock, T0CON is set such that the prescaler is  
.................... //   set to 2/16/64/256 thus providing a consistent counting rate of 3906.25Hz 
.................... //   and a programmable overflow time ranging from 256us up to about 16.8s 
.................... //  Accuracy is a bit compromised when running with the 3.6864MHz primary  
.................... //   crystal, but this error is not significant.... (an 8.5% error...) 
....................  
.................... //  Interrupts disabled to prevent reentrancy 
.................... void     fosc_pri(void) 
.................... { 
....................    uint8_t     tmp_intcon; 
....................    tmp_intcon = INTCON & 0xC0; 
*
01172:  MOVF   FF2,W
01174:  ANDLW  C0
01176:  MOVLB  5
01178:  MOVWF  xA4
....................    disable_interrupts(GLOBAL); 
0117A:  BCF    FF2.6
0117C:  BCF    FF2.7
0117E:  BTFSC  FF2.7
01180:  BRA    117C
....................    OSCCON = 0x00;       // select primary xtal oscillator 
01182:  CLRF   FD3
....................    T0CON = T0_DIV_256;  // 278usec per tick 
01184:  MOVLW  07
01186:  MOVWF  FD5
....................    T2CON = 0b01110010;  // T2 scale factor 15*16 (248usec per tick equiv) 
01188:  MOVLW  72
0118A:  MOVWF  FBA
....................    T4CON = 0b01110010;  // T4 scale factor 15*16 (248usec per tick equiv) 
0118C:  MOVLB  F
0118E:  MOVWF  x51
....................    PR2 = 99;            
01190:  MOVLW  63
01192:  MOVWF  FBB
....................    INTCON |= tmp_intcon; 
01194:  MOVLB  5
01196:  MOVF   xA4,W
01198:  IORWF  FF2,F
0119A:  MOVLB  0
0119C:  RETURN 0
.................... } 
....................  
.................... void     fosc_pri_ISR(void) 
.................... { 
....................    uint8_t     tmp_intcon; 
....................    tmp_intcon = INTCON & 0xC0; 
*
00916:  MOVF   FF2,W
00918:  ANDLW  C0
0091A:  MOVLB  5
0091C:  MOVWF  x87
....................    disable_interrupts(GLOBAL); 
0091E:  BCF    FF2.6
00920:  BCF    FF2.7
00922:  BTFSC  FF2.7
00924:  BRA    0920
....................    OSCCON = 0x00;       // select primary xtal oscillator 
00926:  CLRF   FD3
....................    T0CON = T0_DIV_256;  // 278usec per tick 
00928:  MOVLW  07
0092A:  MOVWF  FD5
....................    T2CON = 0b01110010;  // T2 scale factor 15*16 (248usec per tick equiv) 
0092C:  MOVLW  72
0092E:  MOVWF  FBA
....................    T4CON = 0b01110010;  // T4 scale factor 15*16 (248usec per tick equiv) 
00930:  MOVLB  F
00932:  MOVWF  x51
....................    PR2 = 99; 
00934:  MOVLW  63
00936:  MOVWF  FBB
....................    INTCON |= tmp_intcon; 
00938:  MOVLB  5
0093A:  MOVF   x87,W
0093C:  IORWF  FF2,F
0093E:  MOVLB  0
00940:  GOTO   17BC (RETURN)
.................... } 
....................  
.................... void     fosc_4m(void) 
.................... { 
....................    uint8_t     tmp_intcon; 
....................    tmp_intcon = INTCON & 0xC0; 
....................    disable_interrupts(GLOBAL); 
....................    OSCCON = 0x52;       // select 4MHz internal oscillator 
....................    T0CON = T0_DIV_256;  // 256usec per tick 
....................    T2CON = 0b01111010;  // T2 scale factor 16x16 (256usec per tick equiv) 
....................    T4CON = 0b01111010;  // T4 scale factor 16x16 (256usec per tick equiv) 
....................    PR2 = 99; 
....................    INTCON |= tmp_intcon; 
.................... } 
....................  
....................  
.................... void     fosc_1m(void) 
.................... { 
....................    uint8_t     tmp_intcon; 
....................    tmp_intcon = INTCON & 0xC0; 
....................    disable_interrupts(GLOBAL); 
....................    OSCCON = 0x32;       // select 1MHz internal oscillator 
....................    T0CON = T0_DIV_64;   // 256usec per tick 
....................    T2CON = 0b00011010;  // T2 scale factor 4*16 (256usec per tick equiv) 
....................    T4CON = 0b00011010;  // T4 scale factor 4*16 (256usec per tick equiv) 
....................    PR2 = 99; 
....................    INTCON |= tmp_intcon; 
.................... } 
....................  
.................... void     fosc_250k(void) 
.................... { 
....................    uint8_t     tmp_intcon; 
....................    tmp_intcon = INTCON & 0xC0; 
*
0323A:  MOVF   FF2,W
0323C:  ANDLW  C0
0323E:  MOVLB  5
03240:  MOVWF  x4B
....................    disable_interrupts(GLOBAL); 
03242:  BCF    FF2.6
03244:  BCF    FF2.7
03246:  BTFSC  FF2.7
03248:  BRA    3244
....................    OSCCON = 0x12;       // select 250KHz internal oscillator 
0324A:  MOVLW  12
0324C:  MOVWF  FD3
....................    T0CON = T0_DIV_16;   // 256usec per tick 
0324E:  MOVLW  03
03250:  MOVWF  FD5
....................    T2CON = 0b00000010;  // T2 scale factor 1*16 (256usec per tick equiv) 
03252:  MOVLW  02
03254:  MOVWF  FBA
....................    T4CON = 0b00000010;  // T4 scale factor 1*16 (256usec per tick equiv) 
03256:  MOVLB  F
03258:  MOVWF  x51
....................    PR2 = 99; 
0325A:  MOVLW  63
0325C:  MOVWF  FBB
....................    INTCON |= tmp_intcon; 
0325E:  MOVLB  5
03260:  MOVF   x4B,W
03262:  IORWF  FF2,F
03264:  MOVLB  0
03266:  GOTO   3272 (RETURN)
.................... } 
....................  
.................... void     fosc_250k_ISR(void)  
.................... { 
....................    uint8_t     tmp_intcon; 
....................    tmp_intcon = INTCON & 0xC0; 
....................    disable_interrupts(GLOBAL); 
....................    OSCCON = 0x12;       // select 250KHz internal oscillator 
....................    T0CON = T0_DIV_16;   // 256usec per tick 
....................    T2CON = 0b00000010;  // T2 scale factor 1*16 (256usec per tick equiv) 
....................    T4CON = 0b00000010;  // T4 scale factor 1*16 (256usec per tick equiv) 
....................    PR2 = 99; 
....................    INTCON |= tmp_intcon; 
.................... } 
....................  
.................... void     fosc_31250(void) 
.................... { 
....................    uint8_t     tmp_intcon; 
....................    tmp_intcon = INTCON & 0xC0; 
....................    disable_interrupts(GLOBAL); 
....................    OSCCON = 0x02;       // select 31250Hz internal oscillator 
....................    T0CON = T0_DIV_2;    // 256usec per tick 
....................    T2CON = 0b00001000;  // T2 scale factor 2*1 (256usec per tick equiv) 
....................    T4CON = 0b00001000;  // T4 scale factor 2*1 (256usec per tick equiv) 
....................    PR2 = 79; 
....................    INTCON |= tmp_intcon; 
.................... }       
....................  
.................... void     fosc_31250_ISR(void)  
.................... { 
....................    uint8_t     tmp_intcon; 
....................    tmp_intcon = INTCON & 0xC0; 
....................    disable_interrupts(GLOBAL); 
....................    OSCCON = 0x02;       // select 31250Hz internal oscillator 
....................    T0CON = T0_DIV_2;    // 256usec per tick 
....................    T2CON = 0b00001000;  // T2 scale factor 2*1 (256usec per tick equiv) 
....................    T4CON = 0b00001000;  // T4 scale factor 2*1 (256usec per tick equiv) 
....................    PR2 = 79; 
....................    INTCON |= tmp_intcon; 
.................... }       
....................  
.................... void     fosc_sec(void) 
.................... { 
....................    uint8_t     tmp_intcon; 
....................    tmp_intcon = INTCON & 0xC0; 
....................    disable_interrupts(GLOBAL); 
....................    OSCCON = 0x01;       // select secondary xtal oscillator 
....................    T0CON = T0_DIV_2;    // 244usec per tick 
....................    T2CON = 0b00001000;  // T2 scale factor 2*1 (244usec per tick equiv) 
....................    T4CON = 0b00001000;  // T4 scale factor 2*1 (244usec per tick equiv) 
....................    PR2 = 79; 
....................    INTCON |= tmp_intcon; 
.................... } 
....................  
.................... void osc_init(void) 
.................... { 
.................... // initalizes the oscillators/crystals, sets up delays, RS232, and i2c 
....................  
....................     
....................    // set stack pointer to 0 in case things restart 
....................    STKPTR = 0; 
0326A:  CLRF   FFC
....................     
....................    #use delay(clock=3,686,400) 
....................    #use RS232 (uart1, baud=115200, ERRORS) 
*
0119E:  BTFSS  F9E.4
011A0:  BRA    119E
011A2:  MOVWF  FAD
011A4:  RETURN 0
....................    //#use RS232 (uart2, baud=9600) 
....................     
....................    // start up 32.768KHz xtal oscillator 
....................    SOSCGO = TRUE; 
*
0326C:  BSF    FD2.3
....................    // use medium freq internal osc (lower power) for 250KHz and 500KHz choices   
....................    MFIOSEL = TRUE;   
0326E:  BSF    FD2.4
....................     
....................    // switch to main 250k internal osc and setup delay functions                                     
....................    fosc_250k(); 
03270:  BRA    323A
....................    #use delay(clock=250KHZ) 
*
038C8:  MOVLW  05
038CA:  MOVWF  FEA
038CC:  MOVLW  64
038CE:  MOVWF  FE9
038D0:  MOVF   FEF,W
038D2:  BZ    38E2
038D4:  MOVLW  13
038D6:  MOVWF  00
038D8:  DECFSZ 00,F
038DA:  BRA    38D8
038DC:  NOP   
038DE:  DECFSZ FEF,F
038E0:  BRA    38D4
038E2:  RETURN 0
....................     
....................    // setup i2c for use on 250khz main clock 
....................    #use i2c(master, I2C1, FORCE_HW, NO_STRETCH, FAST=10000) 
*
03272:  GOTO   A1D4 (RETURN)
*
038E4:  BCF    FC6.7
038E6:  BCF    F9E.3
038E8:  MOVFF  57C,FC9
038EC:  MOVLW  02
038EE:  BTFSC  FC6.7
038F0:  BRA    38FC
038F2:  BTFSS  F9E.3
038F4:  BRA    38F2
038F6:  MOVLW  00
038F8:  BTFSC  FC5.6
038FA:  MOVLW  01
038FC:  MOVWF  01
038FE:  RETURN 0
.................... } 
....................  
....................     
....................    // during initialization, except for servicing the mote, the fosc is 
....................    //  always at 250KHz 
....................    // The #use delay above ensures that delay_ms instructions are  
....................    //  compiled properly 
....................    // Built-in compiler delay functionality works fine until mote ints 
....................    //  occur because mote service speeds up the clock and screws up the 
....................    //  compiler built-in delay function..... 
....................  
....................    // The assumption is that I2C communications takes place when system  
....................    //  clock is set to 250KHz 
....................     
.................... void     setup_T0_int(uint16_t value) 
.................... { 
.................... // Use this routine to set up TMR0 such that its flag sets after  
.................... //  the designated time. 
.................... // These are not functions that hang up processing.  They merely ensure 
.................... //  that something takes place before a programmable amount of time passes. 
.................... // 
.................... // Add more possibilities as required.... 
.................... // The defines for "value" can be found in the .h file 
....................    disable_interrupts(GLOBAL); 
*
03844:  BCF    FF2.6
03846:  BCF    FF2.7
03848:  BTFSC  FF2.7
0384A:  BRA    3846
....................    TMR0ON = FALSE; 
0384C:  BCF    FD5.7
....................    set_timer0(value); 
0384E:  MOVFF  569,FD7
03852:  MOVFF  568,FD6
....................    TMR0IF = FALSE; 
03856:  BCF    FF2.2
....................    TMR0ON = TRUE; 
03858:  BSF    FD5.7
....................    enable_interrupts(GLOBAL); 
0385A:  MOVLW  C0
0385C:  IORWF  FF2,F
0385E:  RETURN 0
.................... } 
....................  
.................... void     setup_T2_int(uint8_t value) 
.................... { 
.................... // Use this routine during ISRs to set up TMR4 such that its flag sets 
.................... //  after the designated time. 
....................    TMR2ON = FALSE; 
*
04E82:  BCF    FBA.2
....................    set_timer2(0); 
04E84:  CLRF   FBC
....................    PR2 = value; 
04E86:  MOVFF  54B,FBB
....................    TMR2IF = FALSE; 
04E8A:  BCF    F9E.1
....................    TMR2ON = TRUE; 
04E8C:  BSF    FBA.2
04E8E:  RETURN 0
.................... } 
....................  
.................... void     setup_T4_int(uint8_t value) 
.................... { 
.................... // Use this routine during ISRs to set up TMR4 such that its flag sets 
.................... //  after the designated time. 
....................    TMR4ON = FALSE; 
*
00944:  MOVLB  F
00946:  BCF    x51.2
....................    set_timer4(0); 
00948:  CLRF   x53
....................    PR4 = value; 
0094A:  MOVFF  5A4,F52
....................    TMR4IF = FALSE; 
0094E:  BCF    F7E.0
....................    TMR4ON = TRUE; 
00950:  BSF    x51.2
00952:  MOVLB  0
00954:  RETURN 0
.................... } 
....................  
....................  
.................... void periph_init(void) 
.................... {  
....................    /* Initalizes and configures all perhips, ports, timers, etc. 
....................     * Items initalized include: 
....................     * Interrupts 
....................     * GPIOs 
....................     * Pullup resistors (Port B) 
....................     * Unused periphs in pic (turned off for lower power usage) 
....................     * Timers 
....................     * CCPs 
....................     *  
....................     */ 
....................  
....................    // extra insurance that we aren't interrupted while setting up periph    
....................    disable_interrupts(GLOBAL); 
*
04016:  BCF    FF2.6
04018:  BCF    FF2.7
0401A:  BTFSC  FF2.7
0401C:  BRA    4018
....................     
....................    // get I/O lines and hardware in general into LOWEST POSSIBLE current draw 
....................    setup_vref(VREF_OFF); 
0401E:  MOVLB  F
04020:  CLRF   x42
....................    setup_dac(DAC_OFF); 
04022:  CLRF   x41
....................    setup_adc(ADC_OFF); 
04024:  BCF    FC2.0
....................     
....................    // ensure that the CTMU is off 
....................    CTMUICON = 0; 
04026:  CLRF   x43
....................    CTMUCONL = 0; 
04028:  CLRF   x44
....................    CTMUCONH = 0; 
0402A:  CLRF   x45
....................     
....................    // ensure that the SR latch is off 
....................    SRCON0 = 0; 
0402C:  CLRF   x47
....................    SRCON1 = 0; 
0402E:  CLRF   x46
....................  
....................    // turns off comarator. Funny define from PICklkk 
....................    setup_comparator(NC_NC_NC_NC); 
04030:  CLRF   F77
04032:  MOVLW  04
04034:  MOVWF  F78
04036:  MOVWF  F79
....................     
....................    /* definitively establishes that TMR2 is used to generate PWM frequency 
....................     * for P1x, P2x, P3x 
....................     */ 
....................    CCPTMRS0 = 0; 
04038:  CLRF   x49
....................    CCPTMRS1 = 0;     
0403A:  CLRF   x48
....................     
....................    /* ADC setup (ports, configuration, reference) 
....................     * to perform an acquisition, select the channel and then turn on the ADC 
....................     * [ADON=TRUE]. Then do a read_adc() 
....................     */ 
....................    setup_adc_ports(sAN0|sAN1|sAN12); 
0403C:  MOVF   FC1,W
0403E:  ANDLW  F0
04040:  MOVWF  FC1
04042:  MOVLW  03
04044:  MOVWF  x38
04046:  MOVLW  00
04048:  MOVWF  x3C
0404A:  MOVLW  01
0404C:  MOVWF  x39
0404E:  MOVLW  00
04050:  MOVWF  x3A
04052:  MOVWF  x3B
....................    ADCON2 = ADC_SETUP_DEF; 
04054:  SETF   FC0
....................    setup_adc_reference(VSS_VDD); 
04056:  BCF    FC1.0
04058:  BCF    FC1.1
0405A:  BCF    FC1.2
0405C:  BCF    FC1.3
....................     
....................    /* setup pullup resistors on Port B for Mote Uart flow and XDCR detection    
....................     * RB2 (MOTE_TX_RTSn)    
....................     */  
....................     // JG: think about this in light of other port_b_pullups code! 
....................    port_b_pullups(0b00000100); 
0405E:  MOVLW  04
04060:  MOVWF  F61
04062:  BCF    FF1.7
....................                                            
....................    // turns uart off 
....................    setup_uart(FALSE); 
04064:  BCF    FAB.7
04066:  BCF    FAB.4
04068:  BCF    FAC.5
....................     
....................    // set the inital state and i/o characteristics for all ports 
....................    output_a(PORTA_INIT);                
0406A:  MOVLW  74
0406C:  MOVWF  F89
....................    output_b(PORTB_INIT); 
0406E:  MOVLW  18
04070:  MOVWF  F8A
....................    output_c(PORTC_INIT); 
04072:  MOVLW  45
04074:  MOVWF  F8B
....................    output_d(PORTD_INIT); 
04076:  MOVLW  76
04078:  MOVWF  F8C
....................    output_e(PORTE_INIT); 
0407A:  CLRF   F8D
....................    set_tris_a(TRISA_NORM); 
0407C:  MOVLW  8B
0407E:  MOVWF  F92
....................    set_tris_b(TRISB_NORM); 
04080:  MOVLW  F7
04082:  MOVWF  F93
....................    set_tris_c(TRISC_NORM); 
04084:  MOVLW  9A
04086:  MOVWF  F94
....................    set_tris_d(TRISD_NORM); 
04088:  MOVLW  80
0408A:  MOVWF  F95
....................    set_tris_e(TRISE_NORM); 
0408C:  BCF    F96.0
0408E:  BCF    F96.1
04090:  BSF    F96.2
04092:  BSF    F96.3
....................   
....................    //********************Timers setup start********************     
....................     
....................    // TMR0 for general timing functions 
....................    setup_timer_0(T0_OFF); 
04094:  CLRF   FD5
....................     
....................    /* TMR1 is used in valve motion algorithm 
....................     * It is timed by the external secondary (32.768kHz) xtal 
....................     * Initalized in off mode 
....................     */ 
....................    setup_timer_1(T1_ENABLE_SOSC | T1_EXTERNAL | T1_DIV_BY_1); 
04096:  MOVLW  8F
04098:  MOVWF  FCD
0409A:  CLRF   FCC
....................    TMR1ON = FALSE; 
0409C:  BCF    FCD.0
....................    set_timer1(0); 
0409E:  CLRF   FCF
040A0:  CLRF   FCE
....................     
....................    /* TMR2 is used in all PWM generation and to produce 
....................     * an interrupt event every approx 16msec if desired 
....................     * TMR2 setup handled by oscillator setup macro above 
....................     * Initalized in off mode 
....................     */ 
....................    TMR2ON = FALSE; 
040A2:  BCF    FBA.2
....................    set_timer2(0); 
040A4:  CLRF   FBC
....................     
....................    /* TMR3 is used to count seconds 
....................     * It is timed by the external secondary (32.768kHz) xtal 
....................     * It is set to 8000 and overflows FFFF in 1 second. 
....................     * It is then reset to 8000 after counting 1 second after overflow 
....................     * Initalized in on mode 125ms before overflow (F000) 
....................     */ 
....................    setup_timer_3(T3_ENABLE_SOSC | T3_EXTERNAL | T3_DIV_BY_1);   
040A6:  CLRF   FB4
040A8:  MOVWF  FB1
....................    TMR3ON = FALSE; 
040AA:  BCF    FB1.0
....................    set_timer3(0); 
040AC:  CLRF   FB3
040AE:  CLRF   FB2
....................       
....................    // TMR4 is not used 
....................    setup_timer_4(T4_DISABLED,0,1); 
040B0:  MOVLW  00
040B2:  MOVWF  x51
040B4:  MOVLW  00
040B6:  MOVWF  x52
....................     
....................    /* TMR5 is dedicated to measurement of RPM 
....................     * It is timed by the external secondary (32.768kHz) xtal 
....................     * Initalized in off mode 
....................     */ 
....................    setup_timer_5(T5_ENABLE_SOSC|T5_EXTERNAL|T5_DIV_BY_1); 
040B8:  CLRF   x4D
040BA:  MOVLW  8F
040BC:  MOVWF  x4E
....................    TMR5ON = FALSE; 
040BE:  BCF    x4E.0
....................    set_timer5(0); 
040C0:  CLRF   x50
040C2:  CLRF   x4F
....................     
....................    // TMR6 is not used 
....................    //setup_timer_6(T6_DISABLED,0,1); 
....................    TMR6ON = FALSE; 
040C4:  BCF    x4A.2
....................    set_timer6(0); 
040C6:  CLRF   x4C
....................     
....................    // sets up TMR2, TMR0, TMR6 CON   
....................    T0CON = T0_DIV_16;   
040C8:  MOVLW  03
040CA:  MOVWF  FD5
....................    T2CON = DIV1_POST6; 
040CC:  MOVLW  2C
040CE:  MOVWF  FBA
....................    T6CON = DIV1_POST6;                  
040D0:  MOVWF  x4A
....................    PR2 = 99; 
040D2:  MOVLW  63
040D4:  MOVWF  FBB
....................    PR6 = 99;   
040D6:  MOVWF  x4B
....................     
....................    //********************Timers setup end********************     
....................     
....................    //********************CCP setup start********************     
....................     
....................    //setup_ccp1(CCP_USE_TIMER1_AND_TIMER2 | CCP_PWM_L_L | CCP_PULSE_STEERING_A); 
....................    // CCP1(pwm with TMR2) and P1A are specifically for braking control. 
....................    // Set as above when in use. 
....................    // When off, the BRK_CTRLn line can be set as an I/O for 
....................    //  either max brake (lo) of min (hi) brake. 
....................    // Note that duty cycle 0 for minimum braking,  
....................    //  duty cycle=400 for (almost) maximum braking. 
....................    setup_ccp1(CCP_OFF);          // CCP1 off for now 
040D8:  MOVLW  F0
040DA:  ANDWF  FBD,F
....................    // P1A (BRAKE_CTRLn) is initialized to brakes off (1) 
....................   
....................    //setup_ccp2(CCP_USE_TIMER1_AND_TIMER2 | CCP_PWM_H_H | CCP_PULSE_STEERING_A); 
....................    // CCP2(pwm with TMR2) and P2A are specifically for control of charging. 
....................    // Set above when in use. 
....................    // When off, the LTC3105_CTRL line can be set as an I/O for  
....................    //  either max charging (hi) or min (lo) charging. 
....................    // Note that duty cycle 0 for no charging, 
....................    //  duty cycle=400 for (almost) max charging. 
....................    setup_ccp2(CCP_OFF);          // CCP2 off for now 
040DC:  ANDWF  F66,F
....................    // P2A (LTC3105_CTRL) is initialized to max charging aggressiveness (1) 
....................     
....................    //setup_ccp3(CCP_USE_TIMER1_AND_TIMER2 | CCP_PWM_L_L | CCP_PULSE_STEERING_A); 
....................    //setup_ccp3(CCP_USE_TIMER1_AND_TIMER2 | CCP_PWM_L_L | CCP_PULSE_STEERING_B); 
....................    //setup_ccp3(CCP_USE_TIMER1_AND_TIMER2 | CCP_COMPARE_RESET_TIMER); 
....................    // CCP3(compare)/TMR1 is for valve timing;  
....................    // CCP3(pwm)/TMR2 if for valve motor speed control 
....................    //Steer output to P3A for closing, steer output to P3B for opening; 
....................    // both VLV_CTRL1 (P3A) and VLV_CTRL2 (P3B) hi for braking; 
....................    // both VLV_CTRL1 (P3A) and VLV_CTRL2 (P3B) lo for coasting; 
....................    // pulse P3A lo while P3B hi for closing, pulse P3B while P3A hi for opening 
....................    //Compare mode used to time valve motion after ramp is finished. 
....................    //  Set CCPf_3 to 0x8000 and start TMR1 for 1sec interrupts; or use other 
....................    //  values for different timings.  General purpose timing when valve not 
....................    //  being timed. 
....................    setup_ccp3(CCP_OFF);          // CCP3 off for now 
040DE:  ANDWF  x5D,F
....................  
....................    //setup_ccp4(CCP_USE_TIMER3_AND_TIMER4 | CCP_COMPARE_RESET_TIMER);  
....................    // CCP4/TMR3 serves only one purpose: the real-time-clock. 
....................    //  Set CCP_4 to 0x8000 and start TMR1 for 1sec interrupts 
....................     
....................    setup_ccp4(CCP_OFF);          // CCP4 off for now 
040E0:  ANDWF  x57,F
....................     
....................    //setup_ccp(CCP_USE_TIMER5_AND_TIMER6 | CCP_CAPTURE_RE); 
....................    // CCP5/TMR5 serves only one purpose: measurement of spin rate.  
....................    setup_ccp5(CCP_OFF); 
040E2:  ANDWF  x54,F
....................  
....................    //********************CCP setup end********************    
....................     
....................    //********************INT setup start******************   
....................     
....................    /* Diables: 
....................     * Global int (all ints) 
....................     * All peripheral ints 
....................     * TMR0 overflow int 
....................     * INT0 ext int 
....................     * Port B IOC int 
....................     * Clears: 
....................     * TMROIF, INT0IF, RBIF 
....................     */ 
....................    INTCON = 0; 
040E4:  CLRF   FF2
....................     
....................    // PORTB pullups are enabled 
....................    // INTEDG0,1,2 on falling edge 
....................    // TMR0 and RBIP priority  is low 
....................    INTCON2 = 0; 
040E6:  CLRF   FF1
....................     
....................    // External INT1, INT2 disabled/cleared and set to low priority                               
....................    INTCON3 = 0; 
040E8:  CLRF   FF0
....................     
....................    // Int priority enabled (part of RCON) 
....................    IPEN = TRUE; 
040EA:  BSF    FD0.7
....................     
....................    // Clear all peripheral interrupts 
....................    PIR1 = 0;                            
040EC:  CLRF   F9E
....................    PIR2 = 0; 
040EE:  CLRF   FA1
....................    PIR3 = 0; 
040F0:  CLRF   FA4
....................    PIR4 = 0; 
040F2:  CLRF   F7B
....................    PIR5 = 0; 
040F4:  CLRF   F7E
....................     
....................    // disable all peripheral interrupts 
....................    PIE1 = 0;                           
040F6:  CLRF   F9D
....................    PIE2 = 0; 
040F8:  CLRF   FA0
....................    PIE3 = 0; 
040FA:  CLRF   FA3
....................    PIE4 = 0; 
040FC:  CLRF   F7A
....................    PIE5 = 0; 
040FE:  CLRF   F7D
....................       
....................    //   IPR1 = 0; 
....................    //   IPR2 = 0; 
....................    //   IPR3 = 0; 
....................    //   IPR4 = 0; 
....................    //   IPR5 = 0; 
....................  
....................    // setup IOC to call INT_RB only on RB4 change 
....................    IOCB = 0b00010000;      
04100:  MOVLW  10
04102:  MOVWF  F62
....................     
....................    //********************INT setup end********************  
....................                                 
....................    // initialize I2C 
....................    i2c_init(TRUE); 
04104:  BCF    FCB.0
04106:  BCF    FCB.1
04108:  BCF    FCB.3
0410A:  MOVLW  06
0410C:  MOVWF  FC8
0410E:  MOVLW  28
04110:  MOVWF  FC6
04112:  BSF    FC7.7
04114:  BCF    FC7.6
....................                           
....................    // initalizes XDCR, sets global xdcr_enabled 
....................    adc_XDCR_init();                                     
04116:  MOVLB  0
04118:  GOTO   3860
....................          
....................    // initalize LCD, sets global lcd_enabled 
....................    LCD_init(); 
0411C:  RCALL  39E8
....................     
....................    // set mppc value to 0                  
....................    set_mppc(global_mppc_value); 
0411E:  MOVFF  BA,554
04122:  RCALL  3E6E
....................     
....................    // set battery charge cycle to 100%   
....................    set_charge_duty(global_charge_duty); 
04124:  MOVFF  B5,557
04128:  MOVFF  B4,556
0412C:  RCALL  3EFA
....................     
....................    // initalize fixture, sets global fixture_enabled 
....................    fixture_init(); 
0412E:  BRA    3FBC
....................     
....................    // Turn on LTC1541 and MCP4452  
....................    output_high(AUX_PWR); 
04130:  BSF    F8C.3
....................     
....................    /* This iS for power supply settling etc.. 
....................     * pause for 125ms or longer; should not hang; 
....................     */ 
....................    delay_ms(125); 
04132:  MOVLW  7D
04134:  MOVLB  5
04136:  MOVWF  x64
04138:  MOVLB  0
0413A:  CALL   38C8
0413E:  GOTO   A220 (RETURN)
....................     
....................  
....................      
.................... } 
....................  
.................... void vars_init(void) 
.................... { 
.................... // initalizes all global variables to default values from globals.h 
....................  
.................... ////////////////////Global Variables Table of Contents///////////////////////// 
.................... //Test Globals 
.................... //LCD Globals 
.................... //Time Globals 
.................... //Hardware Enabled Globals 
.................... //Control Related Globals 
.................... //Mote Globals 
.................... //Priority Queue 
.................... //Time Queue 
.................... //Sprinkler Stack 
.................... //Command Stack 
.................... //System State Globals 
....................  
.................... ////////////////////Test Globals/////////////////////////////////////////////// 
....................    test_global = 0; 
....................    test_global_2 = 0; 
....................    test_start_time = 0; 
....................    test_end_time = 0; 
....................    test_valve_open_1 = 0; 
....................    test_rpm_1 = 0; 
....................    test_duty_cycle_1 = 0; 
....................    test_valve_open_2 = 0; 
....................    test_rpm_2 = 0; 
....................    test_duty_cycle_2 = 0; 
....................    test_valve_open_3 = 0; 
....................    test_rpm_3 = 0; 
....................    test_duty_cycle_3 = 0; 
....................   
.................... ////////////////////LCD Globals//////////////////////////////////////////////// 
....................    memset(global_temp_line_buff, 0, sizeof global_temp_line_buff); 
....................    global_extra_lcd_ptr = NULL; 
....................  
.................... ////////////////////Time Globals/////////////////////////////////////////////// 
....................    // keeps track of time since microprocessor has been awake in seconds 
....................    global_rtc_time = 0; 
....................    // keeps track of the time within the mote system (taken from mote) 
....................    global_utc_time = 0; 
....................  
.................... ////////////////////Hardware Enabled Globals/////////////////////////////////// 
....................    global_lcd_enabled = 0; 
....................    global_xcdr_type1_enabled = 0; 
....................    global_xcdr_type2_enabled = 0; 
....................    global_fixture_enabled = 0; 
....................    global_dust_enabled = 0; 
....................  
.................... ////////////////////Control Related Globals//////////////////////////////////// 
....................    // keeps track of rpms (updated via interrupt routine) 
....................    global_current_period = 0; 
....................    global_rpm_set_value = 100; 
....................    // keeps track of duty cycles of brake and charge 
....................    global_brake_duty = 0; 
....................    global_charge_duty = MAX_CHARGE; 
....................    // keeps track of mppc level 
....................    global_mppc_value = 100; 
....................    // keeps track of vgen 
....................    global_vgen = 0; 
....................    // keeps track of fixture dac value 
....................    global_fixture_dac_value = NO_FIXTURE; 
....................  
.................... ////////////////////Valve Related Globals////////////////////////////////////// 
.................... // keeps track of current valve position 
....................    global_valve_position = VLV_POSITION_UNKNOWN; 
....................  
.................... ////////////////////Mote Globals/////////////////////////////////////////////// 
....................    //event flags defined by mote 
....................    event_flags = 0; 
....................  
....................    // Note that bytes_from_mote union contains the stripped unstuffed data 
....................    //  eg, bytes_from_mote.dust_rcvd[128] 
....................     
....................    memset (&bytes_from_mote, 0, sizeof bytes_from_mote); 
....................    p = NULL; 
....................  
....................    // It just can't get bigger than this! 
....................    // pkgen places message to be sent here 
....................    memset(dust_send_buffer, 0, sizeof(dust_send_buffer)); 
....................  
....................    // this is only for doing acks and only needs to be  
....................    // MAX_USER_DATA_SIZE*2 + 2 + 4 + 12 + 2 
....................    // MAX_USER_DATA_SIZE is 2 bytes for ack 
....................    memset(dust_send_buffer_isr, 0, sizeof dust_send_buffer_isr); 
....................  
....................    // THIS is the buffer for RAW rcvd mote 
....................    //  mote packet data 
....................    memset(dust_recive_buffer, 0, sizeof dust_recive_buffer); 
....................  
....................    //  this is place 
....................    //  where the packet to be sent by micro 
....................    //  to NETWORK manager is placed prior 
....................    //  to dust_send_data call 
....................    memset(payload_buff, 0, sizeof payload_buff); 
....................  
....................    // Keeps track of how many bytes to send and passed between pkgen and pksend 
....................    num_of_bytes_to_send = 0; 
....................    num_of_bytes_to_send_isr = 0; 
....................  
....................    // This is specific to the subroutine 
....................    //  pkgen_send() which creates the message 
....................    //  to be sent from the mote to the net                      
....................    send_prefix[0] = CMD_SEND; 
....................    send_prefix[1] = 0; 
....................    send_prefix[2] = FLAG_SEND_REQUEST; 
....................    send_prefix[3] = DESTADDR_HI; 
....................    send_prefix[4] = DESTADDR_LO; 
....................    send_prefix[6] = APPDOMAIN_MAINTENANCE; 
....................    send_prefix[7] = PRIORITY_HI; 
....................    send_prefix[8] = 0; 
....................    send_prefix[9] = 0; 
....................    send_prefix[10] = 0xFF; 
....................    send_prefix[11] = 0; 
....................     
....................    // send_prefix[11] will be set to number of bytes in packet    
....................       // The send_prefix structure is as follows: 
....................       // [0]      CMD_SEND 
....................       // [1]      length of request       - this is payload length + 9 
....................       // [2]      FLAG_SEND_REQUEST 
....................       // [3]/[4]  destination address     - always DESTADDR_HI, DESTADDR_LO 
....................       // [5]      svc_index               - get this from service indication received 
....................       //                                     at join time 
....................       // [6]      APPDOMAIN_MAINTENANCE 
....................       // [7]      PRIORITY_HIGH 
....................       // [8][9]   reserved                - 0x00, 0x00  
....................       // [10]     sequence_num            - always 0xFF for mote-originated packets 
....................       // [11]     payload length          - length of the payload in bytes 
....................  
....................  
....................    // For ensuring a message was recieved properly from mote 
....................    result_rcvd = 0; 
....................  
....................    // Flag for going through deal with mote ISR and going to sleep afterwards 
....................    fl_mote_dealt = 0; 
....................    fl_alt_LCD = 0; 
....................  
....................    // Flag for a sucessful get/set response eliminating a few other flags 
....................    global_set_get_response = 0; 
....................  
....................    // FLAGS TO GET RID OF! 
....................    // Flag for receiving an advertisment 
....................    advert_rcvd_fl = 0; 
....................    setnetid_done_fl = 0; 
....................    ack_sent_fl = 0; 
....................    pkt_rcvd_fl = 0; 
....................    joinduty_done_fl = 0; 
....................    gettime_done_fl = 0; 
....................    fl_batNOEE = 0; 
....................    joinkey_done_fl = 0; 
....................    joincmd_done_fl = 0; 
....................  
....................    flags_rcvd = 0, param_type_rcvd = 0, svc_index_rcvd=0; 
....................    mote_msgSEQ = 0; 
....................  
....................    //Globals for when advertisements are received 
....................    network_id_rcvd = 0; 
....................    mote_id_rcvd = 0; 
....................    rssi_rcvd = 0; 
....................    hop_depth_rcvd = 0; 
....................  
....................    // More globals that we might actually want to keep 
....................    memset(serial_number_rcvd, 0, sizeof serial_number_rcvd); 
....................    memset(macaddr_rcvd, 0, sizeof macaddr_rcvd); 
....................  
.................... ////////////////////Priority Queue///////////////////////////////////////////// 
....................    // Actual priority queue 
....................    memset(global_priority_queue, 0, sizeof global_priority_queue); 
....................    global_current_priority_queue_location = (0-1); 
....................  
.................... ////////////////////Time Queue///////////////////////////////////////////////// 
....................    // Actual time queue 
....................    memset(global_time_queue, 0, sizeof global_time_queue); 
....................    global_current_time_queue_location = (0-1); 
....................  
.................... ////////////////////Sprinkler Queue//////////////////////////////////////////// 
....................    // Actual sprinkler queue 
....................    memset(global_sprinkler_queue, 0, sizeof global_sprinkler_queue); 
....................  
.................... ////////////////////Command Queue////////////////////////////////////////////// 
....................    // Actual command queue 
....................    memset(global_command_queue, 0, sizeof global_command_queue); 
....................  
.................... ////////////////////System State Variables///////////////////////////////////// 
....................    global_mote_state = MOTESTATE_UNKNOWN; 
....................    global_system_state = SYSTEM_INIT; 
.................... } 
....................  
.................... void deep_sleep(void) 
.................... {  // zzzzzzz....... 
....................  
.................... // Ways out of deep sleep: MCLR button, V_GEN_INT (int1) 
.................... // SW1 DOES not wake it up... 
....................  
....................    disable_interrupts(GLOBAL); 
*
09538:  BCF    FF2.6
0953A:  BCF    FF2.7
0953C:  BTFSC  FF2.7
0953E:  BRA    953A
....................    strcpy (global_temp_line_buff, "Enter Deep Sleep"); 
09540:  CLRF   FEA
09542:  MOVLW  70
09544:  MOVWF  FE9
09546:  MOVLW  00
09548:  CALL   03BA
0954C:  TBLRD*-
0954E:  TBLRD*+
09550:  MOVF   FF5,W
09552:  MOVWF  FEE
09554:  IORLW  00
09556:  BNZ   954E
....................    LCD_line1(global_temp_line_buff); 
09558:  MOVLB  5
0955A:  CLRF   x64
0955C:  MOVLW  70
0955E:  MOVWF  x63
09560:  MOVLB  0
09562:  CALL   3932
....................    strcpy (global_temp_line_buff, "Reason:         "); 
09566:  CLRF   FEA
09568:  MOVLW  70
0956A:  MOVWF  FE9
0956C:  MOVLW  00
0956E:  CALL   03DC
09572:  TBLRD*-
09574:  TBLRD*+
09576:  MOVF   FF5,W
09578:  MOVWF  FEE
0957A:  IORLW  00
0957C:  BNZ   9574
....................    global_temp_line_buff[8] = hi2asc(global_shutdown_cause); 
0957E:  MOVFF  4D,564
09582:  CALL   3276
09586:  MOVFF  01,78
....................    global_temp_line_buff[9] = lo2asc(global_shutdown_cause); 
0958A:  MOVFF  4D,564
0958E:  CALL   3296
09592:  MOVFF  01,79
....................    LCD_line2(global_temp_line_buff);      
09596:  MOVLB  5
09598:  CLRF   x64
0959A:  MOVLW  70
0959C:  MOVWF  x63
0959E:  MOVLB  0
095A0:  CALL   398C
....................     
....................    setup_T0_int(T0_6S); 
095A4:  MOVLW  A4
095A6:  MOVLB  5
095A8:  MOVWF  x69
095AA:  MOVLW  73
095AC:  MOVWF  x68
095AE:  MOVLB  0
095B0:  CALL   3844
....................    while (!TMR0IF); 
095B4:  BTFSS  FF2.2
095B6:  BRA    95B4
....................     
....................    LCD_shutdown(); 
095B8:  BRA    94C0
....................    output_a(PORTA_DEEP); 
095BA:  MOVLW  74
095BC:  MOVWF  F89
....................    output_b(PORTB_DEEP); 
095BE:  MOVLW  10
095C0:  MOVWF  F8A
....................    output_c(PORTC_DEEP); 
095C2:  MOVLW  45
095C4:  MOVWF  F8B
....................    output_d(PORTD_DEEP); 
095C6:  MOVLW  76
095C8:  MOVWF  F8C
....................    output_e(PORTE_DEEP); 
095CA:  CLRF   F8D
....................    set_tris_a(TRISA_NORM); 
095CC:  MOVLW  8B
095CE:  MOVWF  F92
....................    set_tris_b(TRISB_NORM); 
095D0:  MOVLW  F7
095D2:  MOVWF  F93
....................    set_tris_c(TRISC_NORM); 
095D4:  MOVLW  9A
095D6:  MOVWF  F94
....................    set_tris_d(TRISD_NORM); 
095D8:  MOVLW  80
095DA:  MOVWF  F95
....................    set_tris_e(TRISE_NORM); 
095DC:  BCF    F96.0
095DE:  BCF    F96.1
095E0:  BSF    F96.2
095E2:  BSF    F96.3
....................  
....................    setup_vref(VREF_OFF); 
095E4:  MOVLB  F
095E6:  CLRF   x42
....................    setup_dac(DAC_OFF); 
095E8:  CLRF   x41
....................    setup_adc(ADC_OFF); 
095EA:  BCF    FC2.0
....................    setup_CCP1(CCP_OFF); 
095EC:  MOVLW  F0
095EE:  ANDWF  FBD,F
....................    setup_CCP2(CCP_OFF); 
095F0:  ANDWF  F66,F
....................    setup_CCP3(CCP_OFF);    
095F2:  ANDWF  x5D,F
....................    setup_CCP4(CCP_OFF); 
095F4:  ANDWF  x57,F
....................    setup_CCP5(CCP_OFF); 
095F6:  ANDWF  x54,F
....................    setup_comparator(NC_NC_NC_NC); 
095F8:  CLRF   F77
095FA:  MOVLW  04
095FC:  MOVWF  F78
095FE:  MOVWF  F79
....................     
....................    clear_interrupt(INT_TIMER0); 
09600:  BCF    FF2.2
....................    setup_timer_1(T1_DISABLED); 
09602:  CLRF   FCD
09604:  CLRF   FCC
....................    setup_timer_2(T2_DISABLED,0,1); 
09606:  MOVLW  00
09608:  MOVWF  FBA
0960A:  MOVLW  00
0960C:  MOVWF  FBB
....................    setup_timer_3(T3_DISABLED); 
0960E:  CLRF   FB4
09610:  CLRF   FB1
....................    setup_timer_4(T4_DISABLED,0,1); 
09612:  MOVWF  x51
09614:  MOVLW  00
09616:  MOVWF  x52
....................    setup_timer_5(T5_DISABLED); 
09618:  CLRF   x4D
0961A:  CLRF   x4E
....................    setup_timer_6(T6_DISABLED,0,1); 
0961C:  MOVWF  x4A
0961E:  MOVLW  00
09620:  MOVWF  x4B
....................     
....................    setup_wdt(WDT_OFF);    
09622:  BCF    FD1.0
....................  
....................    setup_uart(FALSE); 
09624:  BCF    FAB.7
09626:  BCF    FAB.4
09628:  BCF    FAC.5
....................  
....................    INTCON = 0;                         // TMR0, INT0. IOC ints disabled/cleared 
0962A:  CLRF   FF2
....................                                        //  High and Low Priority ints disabled 
....................    INTCON2 = 0;                        // RB port change int is low priority 
0962C:  CLRF   FF1
....................                                        //  PORTB pullups are enabled 
....................    INTCON3 = 0;                        // INT1, INT2 ints disabled/cleared 
0962E:  CLRF   FF0
....................    IPEN = TRUE;                        // Int priority enabled (part of RCON) 
09630:  BSF    FD0.7
....................     
....................    PIR1 = 0;                           // clear various interrupt flags 
09632:  CLRF   F9E
....................    PIR2 = 0; 
09634:  CLRF   FA1
....................    PIR3 = 0; 
09636:  CLRF   FA4
....................    PIR4 = 0; 
09638:  CLRF   F7B
....................    PIR5 = 0; 
0963A:  CLRF   F7E
....................     
....................    PIE1 = 0;                           // disable various interuupts 
0963C:  CLRF   F9D
....................    PIE2 = 0; 
0963E:  CLRF   FA0
....................    PIE3 = 0; 
09640:  CLRF   FA3
....................    PIE4 = 0; 
09642:  CLRF   F7A
....................    PIE5 = 0; 
09644:  CLRF   F7D
....................       
....................    IPR1 = 0; 
09646:  CLRF   F9F
....................    IPR2 = 0; 
09648:  CLRF   FA2
....................    IPR3 = 0; 
0964A:  CLRF   FA5
....................    IPR4 = 0; 
0964C:  CLRF   F7C
....................    IPR5 = 0;   
0964E:  CLRF   F7F
....................     
....................    IOCB = 0;                     // disable all PORTB interrupt on change 
09650:  CLRF   F62
....................                                  //  functionality 
....................    setup_adc_ports(NO_ANALOGS);                               
09652:  MOVF   FC1,W
09654:  ANDLW  F0
09656:  MOVWF  FC1
09658:  MOVLW  00
0965A:  MOVWF  x38
0965C:  MOVWF  x3C
0965E:  MOVWF  x39
09660:  MOVWF  x3A
09662:  MOVWF  x3B
....................    clear_interrupt(INT_EXT); 
09664:  BCF    FF2.1
....................    //clear_interrupt(INT_EXT2); 
....................    enable_interrupts(INT_EXT_L2H);  
09666:  BSF    FF2.4
09668:  BSF    FF1.6
....................    //enable_interrupts(INT_EXT2_H2L);  
....................    enable_interrupts(GLOBAL); 
0966A:  MOVLW  C0
0966C:  IORWF  FF2,F
....................    delay_ms(1000);  
0966E:  MOVLW  04
09670:  MOVLB  5
09672:  MOVWF  x63
09674:  MOVLW  FA
09676:  MOVWF  x64
09678:  MOVLB  0
0967A:  CALL   38C8
0967E:  MOVLB  5
09680:  DECFSZ x63,F
09682:  BRA    9674
....................       
....................    sleep(SLEEP_FULL); 
09684:  MOVFF  FD3,00
09688:  BCF    FD3.7
0968A:  SLEEP 
0968C:  MOVFF  00,FD3
....................  
....................    //reset_cpu(); 
....................    // wake up because of generator spin or SW1/Hall effect 
....................    if (input(V_GEN_INT)) 
09690:  BTFSS  F81.0
09692:  BRA    9696
....................    { 
....................    //   reset_cause = SPIN_RESTART; 
....................    // otherwise it was the SW1/Hall effect that woke it up 
....................       reset_cpu(); 
09694:  RESET
....................    } 
09696:  MOVLB  0
09698:  RETURN 0
....................    // deep sleep is exited by a MCLR, or V_GEN_INT (SPIN RESTART) 
....................    // If for some reason it woke up, but not because of a SPIN_RESTART 
....................    //  then simply go back to deep_sleep 
....................     
....................     
.................... }  
....................  
....................  
.................... void start_rtc(void) 
.................... { 
....................    global_rtc_time = 0; 
*
041E2:  CLRF   x88
041E4:  CLRF   x87
041E6:  CLRF   x86
041E8:  CLRF   x85
....................    CCP_4 = 0x8000; 
041EA:  MOVLW  80
041EC:  MOVLB  F
041EE:  MOVWF  x59
041F0:  CLRF   x58
....................    setup_ccp4(CCP_USE_TIMER3_AND_TIMER4 | CCP_COMPARE_RESET_TIMER); 
041F2:  MOVLW  0B
041F4:  MOVWF  x57
041F6:  MOVLW  FC
041F8:  ANDWF  x48,F
041FA:  MOVLW  01
041FC:  IORWF  x48,F
....................    CCP4IF = FALSE; 
041FE:  BCF    F7B.1
....................    setup_timer_3(T3_ENABLE_SOSC | T3_EXTERNAL_SYNC | T3_DIV_BY_1); 
04200:  CLRF   FB4
04202:  MOVLW  8B
04204:  MOVWF  FB1
....................    set_timer3(0);    
04206:  CLRF   FB3
04208:  CLRF   FB2
....................    clear_interrupt(INT_CCP4); 
0420A:  BCF    F7B.1
....................    enable_interrupts(INT_CCP4); 
0420C:  BSF    F7A.1
0420E:  MOVLB  0
04210:  GOTO   A230 (RETURN)
.................... } 
....................  
.................... void safeI2C_start(void) 
.................... { 
....................    setup_T0_int(T0_10MS); 
*
03E1C:  MOVLB  5
03E1E:  SETF   x69
03E20:  MOVLW  D9
03E22:  MOVWF  x68
03E24:  MOVLB  0
03E26:  RCALL  3844
....................    while (I2CBUSY && !TMR0IF); 
03E28:  BTFSS  FC7.0
03E2A:  BRA    3E30
03E2C:  BTFSS  FF2.2
03E2E:  BRA    3E28
....................    if (!I2CBUSY) 
03E30:  BTFSC  FC7.0
03E32:  BRA    3E3C
....................       i2c_start(); 
03E34:  BSF    FC5.0
03E36:  BTFSC  FC5.0
03E38:  BRA    3E36
03E3A:  BRA    3E58
....................    else 
....................    { 
....................       BCL1IF = FALSE; 
03E3C:  BCF    FA1.3
....................       WCOL = FALSE; 
03E3E:  BCF    FC6.7
....................       i2c_init(TRUE); 
03E40:  BCF    FCB.0
03E42:  BCF    FCB.1
03E44:  BCF    FCB.3
03E46:  MOVLW  06
03E48:  MOVWF  FC8
03E4A:  MOVLW  28
03E4C:  MOVWF  FC6
03E4E:  BSF    FC7.7
03E50:  BCF    FC7.6
....................       i2c_start(); 
03E52:  BSF    FC5.1
03E54:  BTFSC  FC5.1
03E56:  BRA    3E54
....................    } 
03E58:  RETURN 0
....................        
.................... } 
....................  
.................... void safeI2C_write(uint8_t value) 
.................... { 
....................    // thinking that a spike on the data or clock line is f'ing up 
....................    // i2c transmission, this routine simply looks for the ACK and if 
....................    // it does not see it, tries ONE MORE TIME and one more time only! 
....................    int1  unsuccess_fl; 
....................     
....................    unsuccess_fl = i2c_write(value); 
03E5A:  MOVFF  555,57C
03E5E:  RCALL  38E4
03E60:  MOVF   01,W
03E62:  MOVLB  5
03E64:  BCF    x56.0
03E66:  BTFSC  01.0
03E68:  BSF    x56.0
03E6A:  MOVLB  0
03E6C:  RETURN 0
.................... //   if (unsuccess_fl) 
.................... //      i2c_write(value); 
.................... }     
....................  
.................... void setup_rb4_int(void) 
.................... { 
....................    // sets up the RB4 interrupt 
....................    RBIF = FALSE; 
*
04790:  BCF    FF2.0
....................    enable_interrupts(INT_RB4);       
04792:  BSF    FF2.3
04794:  BSF    F62.4
04796:  GOTO   A2C0 (RETURN)
.................... }      
....................       
.................... void write_system_state(uint8_t system_state_to_change_to)  
.................... {                
....................    // Modifies the global_system_state varible outside of the ISRs 
....................    // Also deals with the transition from SYSTEM_IDLE to SYSTEM_RUN and back 
....................                                                                     
....................    // If going from SYSTEM_IDLE to SYSTEM_RUN    
....................    if ((global_system_state == SYSTEM_IDLE) && (system_state_to_change_to == SYSTEM_RUN))  
*
03208:  MOVLB  5
0320A:  MOVF   x05,W
0320C:  SUBLW  03
0320E:  BNZ   3218
03210:  MOVF   x4B,W
03212:  SUBLW  02
03214:  BNZ   3218
....................    {                            
....................       // change processor speed?  
....................       //fosc_250k();  
....................    }  
03216:  BRA    3232
....................    // If going from SYSTEM_RUN to SYSTEM_IDLE    
....................    else if ((global_system_state == SYSTEM_RUN) && (system_state_to_change_to == SYSTEM_IDLE))                
03218:  MOVF   x05,W
0321A:  SUBLW  02
0321C:  BNZ   3226
0321E:  MOVF   x4B,W
03220:  SUBLW  03
03222:  BNZ   3226
....................    { 
....................       // change processor speed? 
....................       //fosc_31250();             
....................    }  
03224:  BRA    3232
....................    // If going from SYSTEM_IDLE to anything else    
....................    else if ((global_system_state == SYSTEM_IDLE) && (system_state_to_change_to != SYSTEM_IDLE)) 
03226:  MOVF   x05,W
03228:  SUBLW  03
0322A:  BNZ   3232
0322C:  MOVF   x4B,W
0322E:  SUBLW  03
03230:  BZ    3232
....................    {      
....................       // change processor speed?  
....................       //fosc_250k();      
....................    }                          
....................    // actually change the state 
....................    global_system_state = system_state_to_change_to; 
03232:  MOVFF  54B,505
03236:  MOVLB  0
03238:  RETURN 0
.................... }       
....................  
.................... uint8_t read_system_state(void)        
.................... { 
....................    // safely read the system state outside of ISRs 
....................    return global_system_state; 
*
01F02:  MOVLB  5
01F04:  MOVFF  505,01
01F08:  MOVLB  0
01F0A:  RETURN 0
.................... } 
....................    
....................  
.................... #include "dust.h"                                        
.................... void mote_init(void) 
.................... { 
....................    // sets the mote message sequence to a random number 
....................    init_msgSEQ(); 
*
04416:  BRA    43CC
....................    // enable appropriate interrupts for mote response 
....................    clear_interrupt(INT_EXT2_H2L); 
04418:  BCF    FF0.1
....................    enable_interrupts(INT_EXT2_H2L); 
0441A:  BSF    FF0.4
0441C:  BCF    FF1.4
0441E:  GOTO   A238 (RETURN)
.................... }    
....................     
.................... void mote_reset(void) 
.................... { 
....................    // Resets the mote, enables interrupts for the mote to respond, and 
....................    // schedules a WAIT_FOR_BOOT_EVENT to see if the mote responded 
....................   
....................    // Force an reset 
....................    output_low(MOTE_RESETn); 
*
04670:  BCF    F8C.4
....................    // definitely long enough at any clock speed 
....................    setup_T0_int(T0_250MS); 
04672:  MOVLW  FC
04674:  MOVLB  5
04676:  MOVWF  x69
04678:  MOVLW  30
0467A:  MOVWF  x68
0467C:  MOVLB  0
0467E:  CALL   3844
....................    while (!TMR0IF);    
04682:  BTFSS  FF2.2
04684:  BRA    4682
....................    output_high(MOTE_RESETn); 
04686:  BSF    F8C.4
....................       
....................    // add boot event checkup 
....................    PUSH_TIME_QUEUE_MACRO((global_rtc_time + 6), WAIT_FOR_BOOT_EVENT) 
04688:  BCF    F7A.1
0468A:  MOVLW  06
0468C:  ADDWF  x85,W
0468E:  MOVLB  5
04690:  MOVWF  x4B
04692:  MOVLW  00
04694:  MOVLB  0
04696:  ADDWFC x86,W
04698:  MOVLB  5
0469A:  MOVWF  x4C
0469C:  MOVLW  00
0469E:  MOVLB  0
046A0:  ADDWFC x87,W
046A2:  MOVLB  5
046A4:  MOVWF  x4D
046A6:  MOVLW  00
046A8:  MOVLB  0
046AA:  ADDWFC x88,W
046AC:  MOVLB  5
046AE:  MOVWF  x4E
046B0:  MOVWF  x59
046B2:  MOVFF  54D,558
046B6:  MOVFF  54C,557
046BA:  MOVFF  54B,556
046BE:  MOVLW  10
046C0:  MOVWF  x5A
046C2:  MOVLB  0
046C4:  RCALL  4422
046C6:  BSF    F7A.1
046C8:  RETURN 0
.................... } 
....................  
.................... uint8_t mote_sleep(void) 
.................... { 
....................    uint8_t  result_byte; 
....................  
....................    // set the join duty and timeout error handling 
....................    global_set_get_response = FALSE; 
*
09E96:  MOVLB  3
09E98:  BCF    x60.2
....................    pkgen_sleep(); 
09E9A:  MOVLW  09
09E9C:  MOVLB  5
09E9E:  MOVWF  x4C
09EA0:  CLRF   x4D
09EA2:  MOVLW  04
09EA4:  MOVWF  x4E
09EA6:  CLRF   x66
09EA8:  CLRF   x65
09EAA:  CLRF   x67
09EAC:  MOVLW  05
09EAE:  MOVWF  x69
09EB0:  MOVLW  4C
09EB2:  MOVWF  x68
09EB4:  MOVLW  03
09EB6:  MOVWF  x6A
09EB8:  MOVLB  0
09EBA:  CALL   5E68
....................    result_byte = dust_hdlc_pksend(); 
09EBE:  CALL   6112
09EC2:  MOVFF  01,54B
....................    setup_T0_int(T0_250MS); 
09EC6:  MOVLW  FC
09EC8:  MOVLB  5
09ECA:  MOVWF  x69
09ECC:  MOVLW  30
09ECE:  MOVWF  x68
09ED0:  MOVLB  0
09ED2:  CALL   3844
....................    while (!TMR0IF && !result_byte); 
09ED6:  BTFSC  FF2.2
09ED8:  BRA    9EE8
09EDA:  MOVLB  5
09EDC:  MOVF   x4B,F
09EDE:  BTFSS  FD8.2
09EE0:  BRA    9EE6
09EE2:  MOVLB  0
09EE4:  BRA    9ED6
09EE6:  MOVLB  0
....................    if (TMR0IF || result_byte) 
09EE8:  BTFSC  FF2.2
09EEA:  BRA    9EF4
09EEC:  MOVLB  5
09EEE:  MOVF   x4B,F
09EF0:  BZ    9EF8
09EF2:  MOVLB  0
....................    { 
....................       //return ERR_MOTE_UNRESPONSIVE; 
....................    } 
09EF4:  BRA    9F00
09EF6:  MOVLB  5
....................    else 
....................    { 
....................       return NO_ERR; 
09EF8:  MOVLW  00
09EFA:  MOVWF  01
09EFC:  BRA    9F06
09EFE:  MOVLB  0
....................    } 
....................    return NO_ERR; 
09F00:  MOVLW  00
09F02:  MOVWF  01
09F04:  MOVLB  5
09F06:  MOVLB  0
09F08:  GOTO   AF3A (RETURN)
.................... } 
....................  
.................... void     search_for_strongest(void) 
*
097A6:  MOVLW  80
097A8:  MOVLB  5
097AA:  MOVWF  x4C
097AC:  CLRF   x4E
097AE:  CLRF   x4D
097B0:  CLRF   x50
097B2:  CLRF   x4F
.................... { 
....................    uint8_t     result_byte; 
....................    int8_t      rssi_best = -128; 
....................    int16_t     net_id_best = 0, net_id_current = 0;; 
....................    uint32_t    search_start_time = 0; 
....................    int1        net_id_selected = 0; 
097B4:  CLRF   x54
097B6:  CLRF   x53
097B8:  CLRF   x52
097BA:  CLRF   x51
097BC:  BCF    x55.0
....................     
....................    strcpy (global_temp_line_buff, " Searching ???? "); 
097BE:  CLRF   FEA
097C0:  MOVLW  70
097C2:  MOVWF  FE9
097C4:  MOVLW  00
097C6:  MOVLB  0
097C8:  CALL   03FE
097CC:  TBLRD*-
097CE:  TBLRD*+
097D0:  MOVF   FF5,W
097D2:  MOVWF  FEE
097D4:  IORLW  00
097D6:  BNZ   97CE
....................    LCD_line1(global_temp_line_buff); 
097D8:  MOVLB  5
097DA:  CLRF   x64
097DC:  MOVLW  70
097DE:  MOVWF  x63
097E0:  MOVLB  0
097E2:  CALL   3932
....................    strcpy (global_temp_line_buff, "nnnn iii sss ddd"); 
097E6:  CLRF   FEA
097E8:  MOVLW  70
097EA:  MOVWF  FE9
097EC:  MOVLW  00
097EE:  CALL   0420
097F2:  TBLRD*-
097F4:  TBLRD*+
097F6:  MOVF   FF5,W
097F8:  MOVWF  FEE
097FA:  IORLW  00
097FC:  BNZ   97F4
....................    LCD_line2(global_temp_line_buff); 
097FE:  MOVLB  5
09800:  CLRF   x64
09802:  MOVLW  70
09804:  MOVWF  x63
09806:  MOVLB  0
09808:  CALL   398C
....................    
....................    //prepare mote message for searching 
....................    pkgen_search(); 
0980C:  MOVLW  11
0980E:  MOVLB  5
09810:  MOVWF  x56
09812:  CLRF   x57
09814:  MOVLW  04
09816:  MOVWF  x58
09818:  CLRF   x66
0981A:  CLRF   x65
0981C:  CLRF   x67
0981E:  MOVLW  05
09820:  MOVWF  x69
09822:  MOVLW  56
09824:  MOVWF  x68
09826:  MOVLW  03
09828:  MOVWF  x6A
0982A:  MOVLB  0
0982C:  CALL   5E68
....................    result_byte = dust_hdlc_pksend();          
09830:  CALL   6112
09834:  MOVFF  01,54B
....................     
....................    // hangs until search begins or request times out; 
....................    setup_T0_int(T0_250MS); 
09838:  MOVLW  FC
0983A:  MOVLB  5
0983C:  MOVWF  x69
0983E:  MOVLW  30
09840:  MOVWF  x68
09842:  MOVLB  0
09844:  CALL   3844
....................    while (!TMR0IF && (global_mote_state != MOTESTATE_SEARCHING) && !result_byte); 
09848:  BTFSC  FF2.2
0984A:  BRA    9866
0984C:  MOVLB  5
0984E:  MOVF   x04,W
09850:  SUBLW  02
09852:  BTFSS  FD8.2
09854:  BRA    985A
09856:  MOVLB  0
09858:  BRA    9866
0985A:  MOVF   x4B,F
0985C:  BTFSS  FD8.2
0985E:  BRA    9864
09860:  MOVLB  0
09862:  BRA    9848
09864:  MOVLB  0
....................     
....................    //  immediately goes to sleep if ERR_MTNOTREADY 
....................    if (TMR0IF || global_mote_state != MOTESTATE_SEARCHING) 
09866:  BTFSC  FF2.2
09868:  BRA    9874
0986A:  MOVLB  5
0986C:  MOVF   x04,W
0986E:  SUBLW  02
09870:  BZ    987C
09872:  MOVLB  0
....................    { 
....................       global_shutdown_cause = ERR_NO_ADV_WHILE_SEARCHING; 
09874:  MOVLW  02
09876:  MOVWF  4D
....................       deep_sleep();       
09878:  RCALL  9538
0987A:  MOVLB  5
....................    } 
....................     
....................     
....................    // Search algorithm continues for MOTE_SEARCH_TIME or until net_id is selected 
....................    search_start_time = global_rtc_time; 
0987C:  MOVFF  88,554
09880:  MOVFF  87,553
09884:  MOVFF  86,552
09888:  MOVFF  85,551
....................    while((global_rtc_time < (search_start_time + MOTE_SEARCH_TIME)) && !net_id_selected) 
0988C:  MOVF   x23,W
0988E:  ADDWF  x51,W
09890:  MOVWF  00
09892:  MOVF   x24,W
09894:  ADDWFC x52,W
09896:  MOVWF  01
09898:  MOVLW  00
0989A:  ADDWFC x53,W
0989C:  MOVWF  02
0989E:  MOVLW  00
098A0:  ADDWFC x54,W
098A2:  MOVWF  03
098A4:  MOVLB  0
098A6:  MOVF   x88,W
098A8:  SUBWF  03,W
098AA:  BTFSS  FD8.0
098AC:  BRA    9A5E
098AE:  BNZ   98CC
098B0:  MOVF   x87,W
098B2:  SUBWF  02,W
098B4:  BTFSS  FD8.0
098B6:  BRA    9A5E
098B8:  BNZ   98CC
098BA:  MOVF   x86,W
098BC:  SUBWF  01,W
098BE:  BTFSS  FD8.0
098C0:  BRA    9A5E
098C2:  BNZ   98CC
098C4:  MOVF   00,W
098C6:  SUBWF  x85,W
098C8:  BTFSC  FD8.0
098CA:  BRA    9A5E
098CC:  MOVLB  5
098CE:  BTFSS  x55.0
098D0:  BRA    98D6
098D2:  MOVLB  0
098D4:  BRA    9A5E
....................    { 
....................       // use SW1 to exit early, give user a chance to select strongest netid 
....................       setup_T0_int(T0_2S); 
098D6:  MOVLW  E1
098D8:  MOVWF  x69
098DA:  MOVLW  7C
098DC:  MOVWF  x68
098DE:  MOVLB  0
098E0:  CALL   3844
....................       while (!TMR0IF) 
098E4:  BTFSC  FF2.2
098E6:  BRA    990E
....................       { 
....................          if (!input(SW1n))                
098E8:  BTFSC  F81.4
098EA:  BRA    990C
....................          { 
....................             //wait for 250MS for debounce                    
....................             setup_T0_int(T0_250MS); 
098EC:  MOVLW  FC
098EE:  MOVLB  5
098F0:  MOVWF  x69
098F2:  MOVLW  30
098F4:  MOVWF  x68
098F6:  MOVLB  0
098F8:  CALL   3844
....................             while (!TMR0IF);                                                  
098FC:  BTFSS  FF2.2
098FE:  BRA    98FC
....................             //check button after 250ms to see if it's still depressed, if so, exit 
....................             if (!input(SW1n)) 
09900:  BTFSC  F81.4
09902:  BRA    990C
....................             { 
....................                net_id_selected = TRUE; 
09904:  MOVLB  5
09906:  BSF    x55.0
....................                break; 
09908:  MOVLB  0
0990A:  BRA    990E
....................             }                                                                
....................          } 
0990C:  BRA    98E4
....................       } 
....................        
....................       // if a new advertisement flag is triggered                      
....................       if (advert_rcvd_fl) 
0990E:  MOVLB  3
09910:  BTFSS  x60.3
09912:  BRA    9A58
....................          { 
....................             //saves current net id 
....................             net_id_current = network_id_rcvd; 
09914:  MOVFF  368,550
09918:  MOVFF  367,54F
....................             //displays information from advertisement 
....................             process_advert(); 
0991C:  MOVLB  0
0991E:  BRA    969A
....................             //reset advertisement flag 
....................             advert_rcvd_fl = FALSE; 
09920:  MOVLB  3
09922:  BCF    x60.3
....................  
....................             //if the advertisement came from a manager, give user a chance to  
....................             //select it and exit 
....................             if (mote_id_rcvd == 1) 
09924:  DECFSZ x69,W
09926:  BRA    9A58
09928:  MOVF   x6A,F
0992A:  BTFSS  FD8.2
0992C:  BRA    9A58
....................             { 
....................                // if lcd is connected, give user a chance to select it 
....................                if (global_lcd_enabled == TRUE) 
0992E:  MOVLB  0
09930:  BTFSS  xA7.0
09932:  BRA    99C4
....................                { 
....................                   strcpy (global_temp_line_buff, "SW1 to Join     "); 
09934:  CLRF   FEA
09936:  MOVLW  70
09938:  MOVWF  FE9
0993A:  MOVLW  00
0993C:  CALL   0442
09940:  TBLRD*-
09942:  TBLRD*+
09944:  MOVF   FF5,W
09946:  MOVWF  FEE
09948:  IORLW  00
0994A:  BNZ   9942
....................                   global_temp_line_buff[12] = hi2asc(make8(network_id_rcvd,1)); 
0994C:  MOVFF  368,563
09950:  MOVFF  368,564
09954:  CALL   3276
09958:  MOVFF  01,7C
....................                   global_temp_line_buff[13] = lo2asc(make8(network_id_rcvd,1)); 
0995C:  MOVFF  368,563
09960:  MOVFF  368,564
09964:  CALL   3296
09968:  MOVFF  01,7D
....................                   global_temp_line_buff[14] = hi2asc(make8(network_id_rcvd,0)); 
0996C:  MOVFF  367,563
09970:  MOVFF  367,564
09974:  CALL   3276
09978:  MOVFF  01,7E
....................                   global_temp_line_buff[15] = lo2asc(make8(network_id_rcvd,0)); 
0997C:  MOVFF  367,563
09980:  MOVFF  367,564
09984:  CALL   3296
09988:  MOVFF  01,7F
....................                   LCD_line1(global_temp_line_buff); 
0998C:  MOVLB  5
0998E:  CLRF   x64
09990:  MOVLW  70
09992:  MOVWF  x63
09994:  MOVLB  0
09996:  CALL   3932
....................                    
....................                   // give the user a chance to select the current NetID for 4sec 
....................                   setup_T0_int(T0_4S); 
0999A:  MOVLW  C2
0999C:  MOVLB  5
0999E:  MOVWF  x69
099A0:  MOVLW  F7
099A2:  MOVWF  x68
099A4:  MOVLB  0
099A6:  CALL   3844
....................                   while (!TMR0IF) 
099AA:  BTFSC  FF2.2
099AC:  BRA    99C4
....................                   {                               
....................                      if (!input(SW1n)) 
099AE:  BTFSC  F81.4
099B0:  BRA    99C2
....................                      { 
....................                         net_id_best = net_id_current; 
099B2:  MOVFF  550,54E
099B6:  MOVFF  54F,54D
....................                         net_id_selected = 1; 
099BA:  MOVLB  5
099BC:  BSF    x55.0
....................                         break; 
099BE:  MOVLB  0
099C0:  BRA    99C4
....................                      } 
099C2:  BRA    99AA
....................                   } 
....................                } 
....................                 
....................                // store the strongest signal unless user selected network 
....................                if ((rssi_rcvd > rssi_best) && (net_id_selected == FALSE)) 
099C4:  MOVLB  5
099C6:  MOVF   x4C,W
099C8:  XORLW  80
099CA:  MOVWF  00
099CC:  MOVLB  3
099CE:  MOVF   x6B,W
099D0:  XORLW  80
099D2:  SUBWF  00,W
099D4:  BC    99EE
099D6:  MOVLB  5
099D8:  BTFSS  x55.0
099DA:  BRA    99E0
099DC:  MOVLB  3
099DE:  BRA    99EE
....................                { 
....................                   rssi_best = rssi_rcvd; 
099E0:  MOVFF  36B,54C
....................                   net_id_best = network_id_rcvd; 
099E4:  MOVFF  368,54E
099E8:  MOVFF  367,54D
099EC:  MOVLB  3
....................                } 
....................                strcpy (global_temp_line_buff, "Strongest:      "); 
099EE:  CLRF   FEA
099F0:  MOVLW  70
099F2:  MOVWF  FE9
099F4:  MOVLW  00
099F6:  MOVLB  0
099F8:  CALL   0464
099FC:  TBLRD*-
099FE:  TBLRD*+
09A00:  MOVF   FF5,W
09A02:  MOVWF  FEE
09A04:  IORLW  00
09A06:  BNZ   99FE
....................                global_temp_line_buff[12] = hi2asc(make8(net_id_best,1)); 
09A08:  MOVFF  54E,563
09A0C:  MOVFF  54E,564
09A10:  CALL   3276
09A14:  MOVFF  01,7C
....................                global_temp_line_buff[13] = lo2asc(make8(net_id_best,1)); 
09A18:  MOVFF  54E,563
09A1C:  MOVFF  54E,564
09A20:  CALL   3296
09A24:  MOVFF  01,7D
....................                global_temp_line_buff[14] = hi2asc(make8(net_id_best,0)); 
09A28:  MOVFF  54D,563
09A2C:  MOVFF  54D,564
09A30:  CALL   3276
09A34:  MOVFF  01,7E
....................                global_temp_line_buff[15] = lo2asc(make8(net_id_best,0)); 
09A38:  MOVFF  54D,563
09A3C:  MOVFF  54D,564
09A40:  CALL   3296
09A44:  MOVFF  01,7F
....................                LCD_line1(global_temp_line_buff); 
09A48:  MOVLB  5
09A4A:  CLRF   x64
09A4C:  MOVLW  70
09A4E:  MOVWF  x63
09A50:  MOVLB  0
09A52:  CALL   3932
09A56:  MOVLB  3
....................             } 
....................          } 
09A58:  MOVLB  5
09A5A:  BRA    988C
09A5C:  MOVLB  0
....................       } 
....................                 
....................    disable_interrupts(GLOBAL); 
09A5E:  BCF    FF2.6
09A60:  BCF    FF2.7
09A62:  BTFSC  FF2.7
09A64:  BRA    9A60
....................     
....................    net_id_best = __swap16(net_id_best);        // swap the bytes [why?] 
09A66:  MOVFF  54D,564
09A6A:  MOVLB  5
09A6C:  CLRF   x63
09A6E:  MOVF   x4E,W
09A70:  CLRF   03
09A72:  IORWF  x63,W
09A74:  MOVWF  00
09A76:  MOVF   03,W
09A78:  IORWF  x4D,W
09A7A:  MOVFF  00,54D
09A7E:  MOVWF  x4E
....................    if (!net_id_best) 
09A80:  MOVF   x4D,W
09A82:  IORWF  x4E,W
09A84:  BNZ   9A90
....................    { 
....................       // send to deep sleep as no network was found 
....................       global_shutdown_cause = ERR_NO_ADV_WHILE_SEARCHING; 
09A86:  MOVLW  02
09A88:  MOVWF  4D
....................       deep_sleep(); 
09A8A:  MOVLB  0
09A8C:  RCALL  9538
09A8E:  MOVLB  5
....................    } 
....................    
....................    // now set the best network id into the motes NV memory 
....................    pkgen_setnv_networkid(net_id_best); 
09A90:  MOVLW  03
09A92:  MOVWF  x59
09A94:  MOVLW  07
09A96:  MOVWF  x5A
09A98:  MOVLW  04
09A9A:  MOVWF  x5B
09A9C:  CLRF   x5C
09A9E:  CLRF   x5D
09AA0:  CLRF   x5E
09AA2:  CLRF   x5F
09AA4:  MOVLW  03
09AA6:  MOVWF  x60
09AA8:  MOVFF  54E,562
09AAC:  MOVFF  54D,561
09AB0:  MOVLW  05
09AB2:  MOVWF  x64
09AB4:  MOVLW  61
09AB6:  MOVWF  x63
09AB8:  MOVLW  05
09ABA:  MOVWF  x66
09ABC:  MOVLW  59
09ABE:  MOVWF  x65
09AC0:  MOVLW  08
09AC2:  MOVWF  x67
09AC4:  MOVFF  564,569
09AC8:  MOVFF  563,568
09ACC:  MOVLW  02
09ACE:  MOVWF  x6A
09AD0:  MOVLB  0
09AD2:  CALL   5E68
....................    result_byte = dust_hdlc_pksend(); 
09AD6:  CALL   6112
09ADA:  MOVFF  01,54B
....................    setup_T0_int(T0_250MS); 
09ADE:  MOVLW  FC
09AE0:  MOVLB  5
09AE2:  MOVWF  x69
09AE4:  MOVLW  30
09AE6:  MOVWF  x68
09AE8:  MOVLB  0
09AEA:  CALL   3844
....................    while (!TMR0IF && !setnetid_done_fl && !result_byte); 
09AEE:  BTFSC  FF2.2
09AF0:  BRA    9B0A
09AF2:  MOVLB  3
09AF4:  BTFSS  x60.4
09AF6:  BRA    9AFC
09AF8:  MOVLB  0
09AFA:  BRA    9B0A
09AFC:  MOVLB  5
09AFE:  MOVF   x4B,F
09B00:  BTFSS  FD8.2
09B02:  BRA    9B08
09B04:  MOVLB  0
09B06:  BRA    9AEE
09B08:  MOVLB  0
....................     
....................    if (TMR0IF || result_byte) 
09B0A:  BTFSC  FF2.2
09B0C:  BRA    9B16
09B0E:  MOVLB  5
09B10:  MOVF   x4B,F
09B12:  BZ    9B1E
09B14:  MOVLB  0
....................    { 
....................       // send to deep sleep network couldn't be joined 
....................       global_shutdown_cause = ERR_NETWORK_JOIN_FAIL; 
09B16:  MOVLW  06
09B18:  MOVWF  4D
....................       deep_sleep(); 
09B1A:  RCALL  9538
09B1C:  MOVLB  5
....................    } 
....................     
....................    strcpy (global_temp_line_buff, " Search Success "); 
09B1E:  CLRF   FEA
09B20:  MOVLW  70
09B22:  MOVWF  FE9
09B24:  MOVLW  00
09B26:  MOVLB  0
09B28:  CALL   0486
09B2C:  TBLRD*-
09B2E:  TBLRD*+
09B30:  MOVF   FF5,W
09B32:  MOVWF  FEE
09B34:  IORLW  00
09B36:  BNZ   9B2E
....................    LCD_line1(global_temp_line_buff); 
09B38:  MOVLB  5
09B3A:  CLRF   x64
09B3C:  MOVLW  70
09B3E:  MOVWF  x63
09B40:  MOVLB  0
09B42:  CALL   3932
....................    strcpy (global_temp_line_buff, "Next join:      "); 
09B46:  CLRF   FEA
09B48:  MOVLW  70
09B4A:  MOVWF  FE9
09B4C:  MOVLW  00
09B4E:  CALL   04A8
09B52:  TBLRD*-
09B54:  TBLRD*+
09B56:  MOVF   FF5,W
09B58:  MOVWF  FEE
09B5A:  IORLW  00
09B5C:  BNZ   9B54
....................    global_temp_line_buff[12] = hi2asc(make8(net_id_best,0)); 
09B5E:  MOVFF  54D,563
09B62:  MOVFF  54D,564
09B66:  CALL   3276
09B6A:  MOVFF  01,7C
....................    global_temp_line_buff[13] = lo2asc(make8(net_id_best,0)); 
09B6E:  MOVFF  54D,563
09B72:  MOVFF  54D,564
09B76:  CALL   3296
09B7A:  MOVFF  01,7D
....................    global_temp_line_buff[14] = hi2asc(make8(net_id_best,1)); 
09B7E:  MOVFF  54E,563
09B82:  MOVFF  54E,564
09B86:  CALL   3276
09B8A:  MOVFF  01,7E
....................    global_temp_line_buff[15] = lo2asc(make8(net_id_best,1)); 
09B8E:  MOVFF  54E,563
09B92:  MOVFF  54E,564
09B96:  CALL   3296
09B9A:  MOVFF  01,7F
....................    LCD_line2(global_temp_line_buff); 
09B9E:  MOVLB  5
09BA0:  CLRF   x64
09BA2:  MOVLW  70
09BA4:  MOVWF  x63
09BA6:  MOVLB  0
09BA8:  CALL   398C
....................  
....................    // Let it sit on the screen for a couple seconds 
....................    setup_T0_int(T0_2S); 
09BAC:  MOVLW  E1
09BAE:  MOVLB  5
09BB0:  MOVWF  x69
09BB2:  MOVLW  7C
09BB4:  MOVWF  x68
09BB6:  MOVLB  0
09BB8:  CALL   3844
....................    while (!TMR0IF);       
09BBC:  BTFSS  FF2.2
09BBE:  BRA    9BBC
....................     
....................    happy_lites();                                            
09BC0:  CALL   4E34
....................                                                  
....................    // send to deep sleep as network id is now set 
....................    global_shutdown_cause |= NEW_NETWORK_ID_SET; 
09BC4:  MOVLW  03
09BC6:  IORWF  4D,F
....................    deep_sleep(); 
09BC8:  RCALL  9538
....................     
....................    return; 
09BCA:  GOTO   AFD0 (RETURN)
.................... } 
....................  
.................... void  process_advert(void) 
.................... { 
....................    strcpy (global_temp_line_buff, "                "); 
*
0969A:  CLRF   FEA
0969C:  MOVLW  70
0969E:  MOVWF  FE9
096A0:  MOVLW  00
096A2:  CALL   04CA
096A6:  TBLRD*-
096A8:  TBLRD*+
096AA:  MOVF   FF5,W
096AC:  MOVWF  FEE
096AE:  IORLW  00
096B0:  BNZ   96A8
....................  
....................    global_temp_line_buff[0] = hi2asc(make8(network_id_rcvd,1)); 
096B2:  MOVFF  368,563
096B6:  MOVFF  368,564
096BA:  CALL   3276
096BE:  MOVFF  01,70
....................    global_temp_line_buff[1] = lo2asc(make8(network_id_rcvd,1)); 
096C2:  MOVFF  368,563
096C6:  MOVFF  368,564
096CA:  CALL   3296
096CE:  MOVFF  01,71
....................    global_temp_line_buff[2] = hi2asc(make8(network_id_rcvd,0)); 
096D2:  MOVFF  367,563
096D6:  MOVFF  367,564
096DA:  CALL   3276
096DE:  MOVFF  01,72
....................    global_temp_line_buff[3] = lo2asc(make8(network_id_rcvd,0)); 
096E2:  MOVFF  367,563
096E6:  MOVFF  367,564
096EA:  CALL   3296
096EE:  MOVFF  01,73
....................    // NOTE network_id_rcvd is swapped when rcvd to simplify 
....................    //  the netID comparisons that take place later 
....................     
....................    LCD_line2(global_temp_line_buff);  
096F2:  MOVLB  5
096F4:  CLRF   x64
096F6:  MOVLW  70
096F8:  MOVWF  x63
096FA:  MOVLB  0
096FC:  CALL   398C
....................     
....................    mote_id_rcvd = __swap16(mote_id_rcvd);    // swap the bytes [why?] 
09700:  MOVFF  369,564
09704:  MOVLB  5
09706:  CLRF   x63
09708:  MOVLB  3
0970A:  MOVF   x6A,W
0970C:  CLRF   03
0970E:  MOVLB  5
09710:  IORWF  x63,W
09712:  MOVLB  3
09714:  MOVWF  x69
09716:  MOVF   03,W
09718:  MOVLB  5
0971A:  IORWF  x64,W
0971C:  MOVLB  3
0971E:  MOVWF  x6A
....................     
....................    LCD_place_uint16(mote_id_rcvd, 1, 5, 3); 
09720:  MOVFF  36A,564
09724:  MOVFF  369,563
09728:  MOVLW  01
0972A:  MOVLB  5
0972C:  MOVWF  x65
0972E:  MOVLW  05
09730:  MOVWF  x66
09732:  MOVLW  03
09734:  MOVWF  x67
09736:  MOVLB  0
09738:  CALL   6838
....................  
....................     
....................       if (rssi_rcvd >= 0) 
0973C:  MOVLB  3
0973E:  BTFSC  x6B.7
09740:  BRA    9762
....................       { 
....................          LCD_place_uint8(((uint8_t)(rssi_rcvd) + 128), 1, 9, 3); 
09742:  MOVLW  80
09744:  ADDWF  x6B,W
09746:  MOVLB  5
09748:  MOVWF  x63
0974A:  MOVWF  x64
0974C:  MOVLW  01
0974E:  MOVWF  x65
09750:  MOVLW  09
09752:  MOVWF  x66
09754:  MOVLW  03
09756:  MOVWF  x67
09758:  MOVLB  0
0975A:  CALL   6912
....................       } 
0975E:  BRA    978A
09760:  MOVLB  3
....................       else 
....................       { 
....................          LCD_place_uint8((128 - abs(rssi_rcvd)), 1, 9, 3); 
09762:  MOVF   x6B,W
09764:  BTFSS  x6B.7
09766:  BRA    976E
09768:  MOVLW  00
0976A:  BSF    FD8.0
0976C:  SUBFWB x6B,W
0976E:  XORLW  FF
09770:  ADDLW  81
09772:  MOVLB  5
09774:  MOVWF  x63
09776:  MOVWF  x64
09778:  MOVLW  01
0977A:  MOVWF  x65
0977C:  MOVLW  09
0977E:  MOVWF  x66
09780:  MOVLW  03
09782:  MOVWF  x67
09784:  MOVLB  0
09786:  CALL   6912
....................       } 
....................     
....................    LCD_place_uint8(hop_depth_rcvd, 1, 13, 3); 
0978A:  MOVFF  36C,564
0978E:  MOVLW  01
09790:  MOVLB  5
09792:  MOVWF  x65
09794:  MOVLW  0D
09796:  MOVWF  x66
09798:  MOVLW  03
0979A:  MOVWF  x67
0979C:  MOVLB  0
0979E:  CALL   6912
097A2:  GOTO   9920 (RETURN)
.................... } 
....................  
.................... uint8_t     initiate_join(void) 
.................... { 
.................... // initiates a join by setting the joinduty to the max   
....................    uint8_t  result_byte; 
....................     
....................    // set the join duty and timeout error handling 
....................    global_set_get_response = FALSE; 
*
09BCE:  MOVLB  3
09BD0:  BCF    x60.2
....................    pkgen_set_joinduty(0xFF); 
09BD2:  MOVLW  01
09BD4:  MOVLB  5
09BD6:  MOVWF  x4C
09BD8:  MOVLW  02
09BDA:  MOVWF  x4D
09BDC:  MOVLW  04
09BDE:  MOVWF  x4E
09BE0:  MOVLW  06
09BE2:  MOVWF  x4F
09BE4:  SETF   x50
09BE6:  MOVLW  05
09BE8:  MOVWF  x66
09BEA:  MOVLW  4C
09BEC:  MOVWF  x65
09BEE:  MOVLW  04
09BF0:  MOVWF  x67
09BF2:  MOVLW  05
09BF4:  MOVWF  x69
09BF6:  MOVLW  50
09BF8:  MOVWF  x68
09BFA:  MOVLW  01
09BFC:  MOVWF  x6A
09BFE:  MOVLB  0
09C00:  CALL   5E68
....................    result_byte = dust_hdlc_pksend(); 
09C04:  CALL   6112
09C08:  MOVFF  01,54B
....................    setup_T0_int(T0_250MS); 
09C0C:  MOVLW  FC
09C0E:  MOVLB  5
09C10:  MOVWF  x69
09C12:  MOVLW  30
09C14:  MOVWF  x68
09C16:  MOVLB  0
09C18:  CALL   3844
....................    while (!TMR0IF && !global_set_get_response && !result_byte); 
09C1C:  BTFSC  FF2.2
09C1E:  BRA    9C38
09C20:  MOVLB  3
09C22:  BTFSS  x60.2
09C24:  BRA    9C2A
09C26:  MOVLB  0
09C28:  BRA    9C38
09C2A:  MOVLB  5
09C2C:  MOVF   x4B,F
09C2E:  BTFSS  FD8.2
09C30:  BRA    9C36
09C32:  MOVLB  0
09C34:  BRA    9C1C
09C36:  MOVLB  0
....................    if (TMR0IF || result_byte) 
09C38:  BTFSC  FF2.2
09C3A:  BRA    9C44
09C3C:  MOVLB  5
09C3E:  MOVF   x4B,F
09C40:  BZ    9C4C
09C42:  MOVLB  0
....................       return ERR_MTJOINDUTY;  
09C44:  MOVLW  07
09C46:  MOVWF  01
09C48:  BRA    9D42
09C4A:  MOVLB  5
....................     
....................    // set the joinkey and timeout error handling   
....................    global_set_get_response = FALSE; 
09C4C:  MOVLB  3
09C4E:  BCF    x60.2
....................    pkgen_setnv_joinkey(joinkey); 
09C50:  MOVLW  03
09C52:  MOVLB  5
09C54:  MOVWF  x51
09C56:  MOVLW  15
09C58:  MOVWF  x52
09C5A:  MOVLW  04
09C5C:  MOVWF  x53
09C5E:  CLRF   x54
09C60:  CLRF   x55
09C62:  CLRF   x56
09C64:  CLRF   x57
09C66:  MOVLW  02
09C68:  MOVWF  x58
09C6A:  MOVLW  05
09C6C:  MOVWF  x66
09C6E:  MOVLW  51
09C70:  MOVWF  x65
09C72:  MOVLW  08
09C74:  MOVWF  x67
09C76:  CLRF   x69
09C78:  MOVLW  37
09C7A:  MOVWF  x68
09C7C:  MOVLW  10
09C7E:  MOVWF  x6A
09C80:  MOVLB  0
09C82:  CALL   5E68
....................    result_byte = dust_hdlc_pksend(); 
09C86:  CALL   6112
09C8A:  MOVFF  01,54B
....................    setup_T0_int(T0_250MS); 
09C8E:  MOVLW  FC
09C90:  MOVLB  5
09C92:  MOVWF  x69
09C94:  MOVLW  30
09C96:  MOVWF  x68
09C98:  MOVLB  0
09C9A:  CALL   3844
....................    while (!TMR0IF && !global_set_get_response && !result_byte); 
09C9E:  BTFSC  FF2.2
09CA0:  BRA    9CBA
09CA2:  MOVLB  3
09CA4:  BTFSS  x60.2
09CA6:  BRA    9CAC
09CA8:  MOVLB  0
09CAA:  BRA    9CBA
09CAC:  MOVLB  5
09CAE:  MOVF   x4B,F
09CB0:  BTFSS  FD8.2
09CB2:  BRA    9CB8
09CB4:  MOVLB  0
09CB6:  BRA    9C9E
09CB8:  MOVLB  0
....................    if (TMR0IF || result_byte) 
09CBA:  BTFSC  FF2.2
09CBC:  BRA    9CC6
09CBE:  MOVLB  5
09CC0:  MOVF   x4B,F
09CC2:  BZ    9CCE
09CC4:  MOVLB  0
....................       return ERR_MTJOINKEY;   
09CC6:  MOVLW  08
09CC8:  MOVWF  01
09CCA:  BRA    9D42
09CCC:  MOVLB  5
....................        
....................    // NOTE that we assume that the non-volatile memory of the mote 
....................    //  contains a valid network ID.... 
....................    // The join could fail if blue box not found or if it is trying to join 
....................    //  to a nonvalid network ID 
....................     
....................    // actually send the join command 
....................    global_set_get_response = FALSE; 
09CCE:  MOVLB  3
09CD0:  BCF    x60.2
....................    pkgen_join(); 
09CD2:  MOVLW  06
09CD4:  MOVLB  5
09CD6:  MOVWF  x59
09CD8:  CLRF   x5A
09CDA:  MOVLW  04
09CDC:  MOVWF  x5B
09CDE:  CLRF   x66
09CE0:  CLRF   x65
09CE2:  CLRF   x67
09CE4:  MOVLW  05
09CE6:  MOVWF  x69
09CE8:  MOVLW  59
09CEA:  MOVWF  x68
09CEC:  MOVLW  03
09CEE:  MOVWF  x6A
09CF0:  MOVLB  0
09CF2:  CALL   5E68
....................    result_byte = dust_hdlc_pksend(); 
09CF6:  CALL   6112
09CFA:  MOVFF  01,54B
....................    setup_T0_int(T0_250MS); 
09CFE:  MOVLW  FC
09D00:  MOVLB  5
09D02:  MOVWF  x69
09D04:  MOVLW  30
09D06:  MOVWF  x68
09D08:  MOVLB  0
09D0A:  CALL   3844
....................    while (!TMR0IF && !global_set_get_response && !result_byte); 
09D0E:  BTFSC  FF2.2
09D10:  BRA    9D2A
09D12:  MOVLB  3
09D14:  BTFSS  x60.2
09D16:  BRA    9D1C
09D18:  MOVLB  0
09D1A:  BRA    9D2A
09D1C:  MOVLB  5
09D1E:  MOVF   x4B,F
09D20:  BTFSS  FD8.2
09D22:  BRA    9D28
09D24:  MOVLB  0
09D26:  BRA    9D0E
09D28:  MOVLB  0
....................    if (TMR0IF || result_byte) 
09D2A:  BTFSC  FF2.2
09D2C:  BRA    9D36
09D2E:  MOVLB  5
09D30:  MOVF   x4B,F
09D32:  BZ    9D3E
09D34:  MOVLB  0
....................       return ERR_NETWORK_JOIN_FAIL; 
09D36:  MOVLW  06
09D38:  MOVWF  01
09D3A:  BRA    9D42
09D3C:  MOVLB  5
....................      
....................    return NO_ERR; 
09D3E:  MOVLW  00
09D40:  MOVWF  01
09D42:  MOVLB  0
09D44:  GOTO   AFD0 (RETURN)
.................... } 
....................  
.................... void mote_state_check(void) 
.................... { 
.................... // Asks mote what it's status is and responds accordingly (including following 
.................... // up on the mote status later) 
.................... // Restarts mote if needed, triggers join/rejoin if needed, and continues to  
.................... // check status until mote is operational 
....................    uint8_t result_byte; 
....................  
....................    // send the mote status package to the mote 
....................    global_set_get_response = FALSE; 
*
08D5C:  MOVLB  3
08D5E:  BCF    x60.2
....................    pkgen_get_motestatus(); 
08D60:  MOVLW  02
08D62:  MOVLB  5
08D64:  MOVWF  x4C
08D66:  MOVLW  01
08D68:  MOVWF  x4D
08D6A:  MOVLW  04
08D6C:  MOVWF  x4E
08D6E:  MOVLW  0E
08D70:  MOVWF  x4F
08D72:  CLRF   x66
08D74:  CLRF   x65
08D76:  CLRF   x67
08D78:  MOVLW  05
08D7A:  MOVWF  x69
08D7C:  MOVLW  4C
08D7E:  MOVWF  x68
08D80:  MOVLW  04
08D82:  MOVWF  x6A
08D84:  MOVLB  0
08D86:  CALL   5E68
....................    result_byte = dust_hdlc_pksend();                                               
08D8A:  CALL   6112
08D8E:  MOVFF  01,54B
....................    setup_T0_int(T0_250MS); 
08D92:  MOVLW  FC
08D94:  MOVLB  5
08D96:  MOVWF  x69
08D98:  MOVLW  30
08D9A:  MOVWF  x68
08D9C:  MOVLB  0
08D9E:  CALL   3844
....................    while (!TMR0IF && !global_set_get_response && !result_byte); 
08DA2:  BTFSC  FF2.2
08DA4:  BRA    8DBE
08DA6:  MOVLB  3
08DA8:  BTFSS  x60.2
08DAA:  BRA    8DB0
08DAC:  MOVLB  0
08DAE:  BRA    8DBE
08DB0:  MOVLB  5
08DB2:  MOVF   x4B,F
08DB4:  BTFSS  FD8.2
08DB6:  BRA    8DBC
08DB8:  MOVLB  0
08DBA:  BRA    8DA2
08DBC:  MOVLB  0
....................     
....................    // if the mote status request fails, trigger a mote reboot 
....................    if (TMR0IF || result_byte) 
08DBE:  BTFSC  FF2.2
08DC0:  BRA    8DCA
08DC2:  MOVLB  5
08DC4:  MOVF   x4B,F
08DC6:  BZ    8E20
08DC8:  MOVLB  0
....................    { 
....................       PUSH_PRIORITY_QUEUE_MACRO(RESET_MOTE); 
08DCA:  BCF    F7A.1
08DCC:  MOVLW  11
08DCE:  MOVLB  5
08DD0:  MOVWF  x52
08DD2:  MOVLB  0
08DD4:  CALL   46CA
08DD8:  BSF    F7A.1
....................       PUSH_TIME_QUEUE_MACRO((global_rtc_time + 10), CHECK_MOTE_STATE) 
08DDA:  BCF    F7A.1
08DDC:  MOVLW  0A
08DDE:  ADDWF  x85,W
08DE0:  MOVLB  5
08DE2:  MOVWF  x50
08DE4:  MOVLW  00
08DE6:  MOVLB  0
08DE8:  ADDWFC x86,W
08DEA:  MOVLB  5
08DEC:  MOVWF  x51
08DEE:  MOVLW  00
08DF0:  MOVLB  0
08DF2:  ADDWFC x87,W
08DF4:  MOVLB  5
08DF6:  MOVWF  x52
08DF8:  MOVLW  00
08DFA:  MOVLB  0
08DFC:  ADDWFC x88,W
08DFE:  MOVLB  5
08E00:  MOVWF  x53
08E02:  MOVWF  x59
08E04:  MOVFF  552,558
08E08:  MOVFF  551,557
08E0C:  MOVFF  550,556
08E10:  MOVLW  B4
08E12:  MOVWF  x5A
08E14:  MOVLB  0
08E16:  CALL   4422
08E1A:  BSF    F7A.1
....................    } 
08E1C:  BRA    90BE
08E1E:  MOVLB  5
....................    // if it has been more than MOTE_NETWORK_SHUTDOWN_TIMEOUT seconds since the mote  
....................    //    returned an operational state, and the mote is in the SYSTEM_RUN state or the SYSTEM_IDLE state 
....................    //    (not looking for a network) 
....................    else if (((global_rtc_time - global_last_connected_time) > MOTE_NETWORK_SHUTDOWN_TIMEOUT) && \ 
....................       ((read_system_state() == SYSTEM_RUN) || (read_system_state() == SYSTEM_IDLE)))    
08E20:  MOVF   47,W
08E22:  MOVLB  0
08E24:  SUBWF  x85,W
08E26:  MOVLB  5
08E28:  MOVWF  x50
08E2A:  MOVF   48,W
08E2C:  MOVLB  0
08E2E:  SUBWFB x86,W
08E30:  MOVLB  5
08E32:  MOVWF  x51
08E34:  MOVF   49,W
08E36:  MOVLB  0
08E38:  SUBWFB x87,W
08E3A:  MOVLB  5
08E3C:  MOVWF  x52
08E3E:  MOVF   4A,W
08E40:  MOVLB  0
08E42:  SUBWFB x88,W
08E44:  MOVLB  5
08E46:  MOVWF  x53
08E48:  MOVF   x53,F
08E4A:  BNZ   8E5E
08E4C:  MOVF   x52,F
08E4E:  BNZ   8E5E
08E50:  MOVF   x26,W
08E52:  SUBWF  x51,W
08E54:  BNC   8ECC
08E56:  BNZ   8E5E
08E58:  MOVF   x50,W
08E5A:  SUBWF  x25,W
08E5C:  BC    8ECC
08E5E:  MOVLB  0
08E60:  CALL   1F02
08E64:  MOVF   01,W
08E66:  SUBLW  02
08E68:  BZ    8E7A
08E6A:  CALL   1F02
08E6E:  MOVF   01,W
08E70:  SUBLW  03
08E72:  BTFSC  FD8.2
08E74:  BRA    8E7A
08E76:  MOVLB  5
08E78:  BRA    8ECC
....................    {                                       
....................          // set the shutdown cause and schedule a shutdown 10 seconds later 
....................          global_shutdown_cause = ERR_NO_NETWORK_TIMEOUT; 
08E7A:  MOVLW  0D
08E7C:  MOVWF  4D
....................          PUSH_PRIORITY_QUEUE(OPEN_VALVE_UNKNOWN_STATE);   
08E7E:  MOVLW  3E
08E80:  MOVLB  5
08E82:  MOVWF  x52
08E84:  MOVLB  0
08E86:  CALL   46CA
....................          PUSH_TIME_QUEUE(global_rtc_time + 10, SHUTDOWN_SYSTEM);    
08E8A:  MOVLW  0A
08E8C:  ADDWF  x85,W
08E8E:  MOVLB  5
08E90:  MOVWF  x50
08E92:  MOVLW  00
08E94:  MOVLB  0
08E96:  ADDWFC x86,W
08E98:  MOVLB  5
08E9A:  MOVWF  x51
08E9C:  MOVLW  00
08E9E:  MOVLB  0
08EA0:  ADDWFC x87,W
08EA2:  MOVLB  5
08EA4:  MOVWF  x52
08EA6:  MOVLW  00
08EA8:  MOVLB  0
08EAA:  ADDWFC x88,W
08EAC:  MOVLB  5
08EAE:  MOVWF  x53
08EB0:  MOVWF  x59
08EB2:  MOVFF  552,558
08EB6:  MOVFF  551,557
08EBA:  MOVFF  550,556
08EBE:  MOVLW  F1
08EC0:  MOVWF  x5A
08EC2:  MOVLB  0
08EC4:  CALL   4422
....................    } 
08EC8:  BRA    90BE
08ECA:  MOVLB  5
....................     
....................    // if mote is idle or disconnected, initiate a join and check on mote later 
....................    else if ((global_mote_state == MOTESTATE_IDLE) ||                          \ 
....................       (global_mote_state == MOTESTATE_DISCONNECTED))   
08ECC:  DECFSZ x04,W
08ECE:  BRA    8ED2
08ED0:  BRA    8ED8
08ED2:  MOVF   x04,W
08ED4:  SUBLW  06
08ED6:  BNZ   8F2C
....................    { 
....................       PUSH_PRIORITY_QUEUE_MACRO(INIT_JOIN); 
08ED8:  BCF    F7A.1
08EDA:  MOVLW  B3
08EDC:  MOVWF  x52
08EDE:  MOVLB  0
08EE0:  CALL   46CA
08EE4:  BSF    F7A.1
....................       PUSH_TIME_QUEUE_MACRO((global_rtc_time + 10), CHECK_MOTE_STATE) 
08EE6:  BCF    F7A.1
08EE8:  MOVLW  0A
08EEA:  ADDWF  x85,W
08EEC:  MOVLB  5
08EEE:  MOVWF  x50
08EF0:  MOVLW  00
08EF2:  MOVLB  0
08EF4:  ADDWFC x86,W
08EF6:  MOVLB  5
08EF8:  MOVWF  x51
08EFA:  MOVLW  00
08EFC:  MOVLB  0
08EFE:  ADDWFC x87,W
08F00:  MOVLB  5
08F02:  MOVWF  x52
08F04:  MOVLW  00
08F06:  MOVLB  0
08F08:  ADDWFC x88,W
08F0A:  MOVLB  5
08F0C:  MOVWF  x53
08F0E:  MOVWF  x59
08F10:  MOVFF  552,558
08F14:  MOVFF  551,557
08F18:  MOVFF  550,556
08F1C:  MOVLW  B4
08F1E:  MOVWF  x5A
08F20:  MOVLB  0
08F22:  CALL   4422
08F26:  BSF    F7A.1
.................... //      LCD_place_char('D',1,15);     
....................    }                                                          
08F28:  BRA    90BE
08F2A:  MOVLB  5
....................     
....................    // if mote is in one of these odd/unwanted modes, trigger reset 
....................    // and a status check (to initiate a join) in the future 
....................    else if ((global_mote_state == MOTESTATE_RADIOTEST) ||                     \ 
....................       (global_mote_state == MOTESTATE_UNKNOWN))                      
08F2C:  MOVF   x04,W
08F2E:  SUBLW  07
08F30:  BZ    8F36
08F32:  INCFSZ x04,W
08F34:  BRA    8F8A
....................    {    
....................       PUSH_PRIORITY_QUEUE_MACRO(RESET_MOTE); 
08F36:  BCF    F7A.1
08F38:  MOVLW  11
08F3A:  MOVWF  x52
08F3C:  MOVLB  0
08F3E:  CALL   46CA
08F42:  BSF    F7A.1
....................       PUSH_TIME_QUEUE_MACRO((global_rtc_time + 10), CHECK_MOTE_STATE) 
08F44:  BCF    F7A.1
08F46:  MOVLW  0A
08F48:  ADDWF  x85,W
08F4A:  MOVLB  5
08F4C:  MOVWF  x50
08F4E:  MOVLW  00
08F50:  MOVLB  0
08F52:  ADDWFC x86,W
08F54:  MOVLB  5
08F56:  MOVWF  x51
08F58:  MOVLW  00
08F5A:  MOVLB  0
08F5C:  ADDWFC x87,W
08F5E:  MOVLB  5
08F60:  MOVWF  x52
08F62:  MOVLW  00
08F64:  MOVLB  0
08F66:  ADDWFC x88,W
08F68:  MOVLB  5
08F6A:  MOVWF  x53
08F6C:  MOVWF  x59
08F6E:  MOVFF  552,558
08F72:  MOVFF  551,557
08F76:  MOVFF  550,556
08F7A:  MOVLW  B4
08F7C:  MOVWF  x5A
08F7E:  MOVLB  0
08F80:  CALL   4422
08F84:  BSF    F7A.1
.................... //      LCD_place_char('U',1,15); 
....................    } 
08F86:  BRA    90BE
08F88:  MOVLB  5
....................     
....................    // if mote is in promiscuous listen mode but the system state is not  
....................    //    searching for the network, restart as it's unwanted. 
....................    else if ((global_mote_state == MOTESTATE_PROMISCUOUS) &&                   \ 
....................       (!(read_system_state() == SYSTEM_SEARCHING_FOR_NETWORK))) 
08F8A:  MOVF   x04,W
08F8C:  SUBLW  08
08F8E:  BNZ   8FF8
08F90:  MOVLB  0
08F92:  CALL   1F02
08F96:  MOVF   01,W
08F98:  SUBLW  20
08F9A:  BTFSS  FD8.2
08F9C:  BRA    8FA2
08F9E:  MOVLB  5
08FA0:  BRA    8FF8
....................    {                                                     
....................       PUSH_PRIORITY_QUEUE_MACRO(RESET_MOTE); 
08FA2:  BCF    F7A.1
08FA4:  MOVLW  11
08FA6:  MOVLB  5
08FA8:  MOVWF  x52
08FAA:  MOVLB  0
08FAC:  CALL   46CA
08FB0:  BSF    F7A.1
....................       PUSH_TIME_QUEUE_MACRO((global_rtc_time + 10), CHECK_MOTE_STATE) 
08FB2:  BCF    F7A.1
08FB4:  MOVLW  0A
08FB6:  ADDWF  x85,W
08FB8:  MOVLB  5
08FBA:  MOVWF  x50
08FBC:  MOVLW  00
08FBE:  MOVLB  0
08FC0:  ADDWFC x86,W
08FC2:  MOVLB  5
08FC4:  MOVWF  x51
08FC6:  MOVLW  00
08FC8:  MOVLB  0
08FCA:  ADDWFC x87,W
08FCC:  MOVLB  5
08FCE:  MOVWF  x52
08FD0:  MOVLW  00
08FD2:  MOVLB  0
08FD4:  ADDWFC x88,W
08FD6:  MOVLB  5
08FD8:  MOVWF  x53
08FDA:  MOVWF  x59
08FDC:  MOVFF  552,558
08FE0:  MOVFF  551,557
08FE4:  MOVFF  550,556
08FE8:  MOVLW  B4
08FEA:  MOVWF  x5A
08FEC:  MOVLB  0
08FEE:  CALL   4422
08FF2:  BSF    F7A.1
.................... //      LCD_place_char('N',1,15); 
....................    } 
08FF4:  BRA    90BE
08FF6:  MOVLB  5
....................     
....................    // if the mote is booting or initiating a join, check up on it later 
....................    else if ((global_mote_state == MOTESTATE_INIT) ||                          \ 
....................       (global_mote_state == MOTESTATE_SEARCHING) ||                           \ 
....................       (global_mote_state == MOTESTATE_NEGOTIATING) ||                         \ 
....................       (global_mote_state == MOTESTATE_CONNECTED)) 
08FF8:  MOVF   x04,F
08FFA:  BZ    900E
08FFC:  MOVF   x04,W
08FFE:  SUBLW  02
09000:  BZ    900E
09002:  MOVF   x04,W
09004:  SUBLW  03
09006:  BZ    900E
09008:  MOVF   x04,W
0900A:  SUBLW  04
0900C:  BNZ   9056
....................    {                                                                                
....................       PUSH_TIME_QUEUE_MACRO((global_rtc_time + 10), CHECK_MOTE_STATE)   
0900E:  BCF    F7A.1
09010:  MOVLW  0A
09012:  MOVLB  0
09014:  ADDWF  x85,W
09016:  MOVLB  5
09018:  MOVWF  x50
0901A:  MOVLW  00
0901C:  MOVLB  0
0901E:  ADDWFC x86,W
09020:  MOVLB  5
09022:  MOVWF  x51
09024:  MOVLW  00
09026:  MOVLB  0
09028:  ADDWFC x87,W
0902A:  MOVLB  5
0902C:  MOVWF  x52
0902E:  MOVLW  00
09030:  MOVLB  0
09032:  ADDWFC x88,W
09034:  MOVLB  5
09036:  MOVWF  x53
09038:  MOVWF  x59
0903A:  MOVFF  552,558
0903E:  MOVFF  551,557
09042:  MOVFF  550,556
09046:  MOVLW  B4
09048:  MOVWF  x5A
0904A:  MOVLB  0
0904C:  CALL   4422
09050:  BSF    F7A.1
.................... //      LCD_place_char('I',1,15);  
....................    } 
09052:  BRA    90BE
09054:  MOVLB  5
....................     
....................    // mote is operational, do nothing 
....................    else if (global_mote_state == MOTESTATE_OPERATIONAL) 
09056:  MOVF   x04,W
09058:  SUBLW  05
0905A:  BNZ   906E
....................    {  
....................       global_last_connected_time = global_rtc_time; 
0905C:  MOVFF  88,4A
09060:  MOVFF  87,49
09064:  MOVFF  86,48
09068:  MOVFF  85,47
.................... //      LCD_place_char('O',1,15);      
....................       break; 
....................    } 
0906C:  BRA    90C0
....................     
....................    // incase there is some other crazy mote status, restart mote and retry 
....................    else 
....................    { 
....................       PUSH_PRIORITY_QUEUE_MACRO(RESET_MOTE); 
0906E:  BCF    F7A.1
09070:  MOVLW  11
09072:  MOVWF  x52
09074:  MOVLB  0
09076:  CALL   46CA
0907A:  BSF    F7A.1
....................       PUSH_TIME_QUEUE_MACRO((global_rtc_time + 10), CHECK_MOTE_STATE) 
0907C:  BCF    F7A.1
0907E:  MOVLW  0A
09080:  ADDWF  x85,W
09082:  MOVLB  5
09084:  MOVWF  x50
09086:  MOVLW  00
09088:  MOVLB  0
0908A:  ADDWFC x86,W
0908C:  MOVLB  5
0908E:  MOVWF  x51
09090:  MOVLW  00
09092:  MOVLB  0
09094:  ADDWFC x87,W
09096:  MOVLB  5
09098:  MOVWF  x52
0909A:  MOVLW  00
0909C:  MOVLB  0
0909E:  ADDWFC x88,W
090A0:  MOVLB  5
090A2:  MOVWF  x53
090A4:  MOVWF  x59
090A6:  MOVFF  552,558
090AA:  MOVFF  551,557
090AE:  MOVFF  550,556
090B2:  MOVLW  B4
090B4:  MOVWF  x5A
090B6:  MOVLB  0
090B8:  CALL   4422
090BC:  BSF    F7A.1
090BE:  MOVLB  5
....................    } 
....................    break; 
090C0:  MOVLB  0
090C2:  GOTO   AFD0 (RETURN)
.................... } 
....................  
.................... void mote_info_check(void) 
.................... // queries the mote to send back information including mac address (serial no), 
.................... //  hardware model/rev, API version, etc. 
.................... { 
....................    uint8_t result_byte; 
....................     
....................    // if the mote is not enabled/ready exit! 
....................    if (global_dust_enabled == FALSE) return; 
090C6:  BTFSS  xA7.6
090C8:  BRA    914C
....................        
....................    // set the response flag 
....................    global_set_get_response = FALSE; 
090CA:  MOVLB  3
090CC:  BCF    x60.2
....................    // generate the message and send the message 
....................     
....................    pkgen_get_moteinfo(); 
090CE:  MOVLW  02
090D0:  MOVLB  5
090D2:  MOVWF  x4C
090D4:  MOVLW  01
090D6:  MOVWF  x4D
090D8:  MOVLW  04
090DA:  MOVWF  x4E
090DC:  MOVLW  0C
090DE:  MOVWF  x4F
090E0:  CLRF   x66
090E2:  CLRF   x65
090E4:  CLRF   x67
090E6:  MOVLW  05
090E8:  MOVWF  x69
090EA:  MOVLW  4C
090EC:  MOVWF  x68
090EE:  MOVLW  04
090F0:  MOVWF  x6A
090F2:  MOVLB  0
090F4:  CALL   5E68
....................    result_byte = dust_hdlc_pksend(); 
090F8:  CALL   6112
090FC:  MOVFF  01,54B
....................    // set message timeout 
....................    setup_T0_int(T0_250MS); 
09100:  MOVLW  FC
09102:  MOVLB  5
09104:  MOVWF  x69
09106:  MOVLW  30
09108:  MOVWF  x68
0910A:  MOVLB  0
0910C:  CALL   3844
....................    while (!TMR0IF && !global_set_get_response && !result_byte); 
09110:  BTFSC  FF2.2
09112:  BRA    912C
09114:  MOVLB  3
09116:  BTFSS  x60.2
09118:  BRA    911E
0911A:  MOVLB  0
0911C:  BRA    912C
0911E:  MOVLB  5
09120:  MOVF   x4B,F
09122:  BTFSS  FD8.2
09124:  BRA    912A
09126:  MOVLB  0
09128:  BRA    9110
0912A:  MOVLB  0
....................    // if the message fails, send an error message (kinda pointless though) 
....................    if (TMR0IF || result_byte) 
0912C:  BTFSC  FF2.2
0912E:  BRA    9138
09130:  MOVLB  5
09132:  MOVF   x4B,F
09134:  BZ    914E
09136:  MOVLB  0
....................    { 
....................       global_error_message_bitfield |= ERR_MOTE_UNRESPONSIVE; 
09138:  MOVLB  4
0913A:  BSF    xF8.2
....................       PUSH_MESSAGE_QUEUE_MACRO(MSG_MOTE_ERROR_MSG); 
0913C:  BCF    F7A.1
0913E:  MOVLW  A0
09140:  MOVLB  5
09142:  MOVWF  x54
09144:  MOVLB  0
09146:  CALL   4FF4
0914A:  BSF    F7A.1
0914C:  MOVLB  5
....................    } 
0914E:  MOVLB  0
09150:  GOTO   AFD0 (RETURN)
....................     
.................... } 
....................  
.................... void mote_temp_check(void) 
.................... // queries the mote to send the temperature back and stores it in the global 
.................... //    variable global_mote_temperature  
.................... { 
....................    uint8_t result_byte; 
....................     
....................    // if the mote is not enabled/ready exit! 
....................    if (global_dust_enabled == FALSE) return; 
*
0938E:  BTFSS  xA7.6
09390:  BRA    94B8
....................     
....................    // set the response flag 
....................    global_set_get_response = FALSE; 
09392:  MOVLB  3
09394:  BCF    x60.2
....................    // generate the message and send the message 
....................    pkgen_get_charge(); 
09396:  MOVLW  02
09398:  MOVLB  5
0939A:  MOVWF  x4C
0939C:  MOVLW  01
0939E:  MOVWF  x4D
093A0:  MOVLW  04
093A2:  MOVWF  x4E
093A4:  MOVLW  10
093A6:  MOVWF  x4F
093A8:  CLRF   x66
093AA:  CLRF   x65
093AC:  CLRF   x67
093AE:  MOVLW  05
093B0:  MOVWF  x69
093B2:  MOVLW  4C
093B4:  MOVWF  x68
093B6:  MOVLW  04
093B8:  MOVWF  x6A
093BA:  MOVLB  0
093BC:  CALL   5E68
....................    result_byte = dust_hdlc_pksend(); 
093C0:  CALL   6112
093C4:  MOVFF  01,54B
....................    // set message timeout 
....................    setup_T0_int(T0_250MS); 
093C8:  MOVLW  FC
093CA:  MOVLB  5
093CC:  MOVWF  x69
093CE:  MOVLW  30
093D0:  MOVWF  x68
093D2:  MOVLB  0
093D4:  CALL   3844
....................    while (!TMR0IF && !global_set_get_response && !result_byte); 
093D8:  BTFSC  FF2.2
093DA:  BRA    93F4
093DC:  MOVLB  3
093DE:  BTFSS  x60.2
093E0:  BRA    93E6
093E2:  MOVLB  0
093E4:  BRA    93F4
093E6:  MOVLB  5
093E8:  MOVF   x4B,F
093EA:  BTFSS  FD8.2
093EC:  BRA    93F2
093EE:  MOVLB  0
093F0:  BRA    93D8
093F2:  MOVLB  0
....................    // if the message fails, send an error message (kinda pointless though) 
....................    if (TMR0IF || result_byte) 
093F4:  BTFSC  FF2.2
093F6:  BRA    9400
093F8:  MOVLB  5
093FA:  MOVF   x4B,F
093FC:  BZ    9416
093FE:  MOVLB  0
....................    { 
....................       global_error_message_bitfield |= ERR_MOTE_UNRESPONSIVE; 
09400:  MOVLB  4
09402:  BSF    xF8.2
....................       PUSH_MESSAGE_QUEUE_MACRO(MSG_MOTE_ERROR_MSG); 
09404:  BCF    F7A.1
09406:  MOVLW  A0
09408:  MOVLB  5
0940A:  MOVWF  x54
0940C:  MOVLB  0
0940E:  CALL   4FF4
09412:  BSF    F7A.1
09414:  MOVLB  5
....................    } 
....................     
....................    // if mote temp is outside of operating range, send an error message and queue up a shutdown 
....................    if ((global_mote_temperature < MOTE_MIN_TEMP_SHUTDOWN) || (global_mote_temperature > MOTE_MAX_TEMP_SHUTDOWN)) 
09416:  MOVLB  3
09418:  MOVF   x6D,W
0941A:  XORLW  80
0941C:  SUBLW  57
0941E:  BC    942A
09420:  BTFSC  x6D.7
09422:  BRA    9492
09424:  MOVF   x6D,W
09426:  SUBLW  55
09428:  BC    9492
....................    { 
....................       // set message error bitfield and queue error message 
....................       global_error_message_bitfield |= (ERR_MSG_MOTE_TEMP_OUT_OF_RANGE | ERR_MSG_MOTE_GOING_TO_DEEP_SLEEP); 
0942A:  MOVLB  4
0942C:  BSF    xF8.6
0942E:  BSF    xFB.7
....................       PUSH_MESSAGE_QUEUE_MACRO(MSG_MOTE_ERROR_MSG); 
09430:  BCF    F7A.1
09432:  MOVLW  A0
09434:  MOVLB  5
09436:  MOVWF  x54
09438:  MOVLB  0
0943A:  CALL   4FF4
0943E:  BSF    F7A.1
....................        
....................       // set the shutdown cause and schedule a shutdown 10 seconds later 
....................       PUSH_PRIORITY_QUEUE(OPEN_VALVE_UNKNOWN_STATE);   
09440:  MOVLW  3E
09442:  MOVLB  5
09444:  MOVWF  x52
09446:  MOVLB  0
09448:  CALL   46CA
....................       global_shutdown_cause = ERR_MOTE_OUT_OF_TEMP_RANGE; 
0944C:  MOVLW  05
0944E:  MOVWF  4D
....................       PUSH_TIME_QUEUE(global_rtc_time + 10, SHUTDOWN_SYSTEM); 
09450:  MOVLW  0A
09452:  ADDWF  x85,W
09454:  MOVLB  5
09456:  MOVWF  x50
09458:  MOVLW  00
0945A:  MOVLB  0
0945C:  ADDWFC x86,W
0945E:  MOVLB  5
09460:  MOVWF  x51
09462:  MOVLW  00
09464:  MOVLB  0
09466:  ADDWFC x87,W
09468:  MOVLB  5
0946A:  MOVWF  x52
0946C:  MOVLW  00
0946E:  MOVLB  0
09470:  ADDWFC x88,W
09472:  MOVLB  5
09474:  MOVWF  x53
09476:  MOVWF  x59
09478:  MOVFF  552,558
0947C:  MOVFF  551,557
09480:  MOVFF  550,556
09484:  MOVLW  F1
09486:  MOVWF  x5A
09488:  MOVLB  0
0948A:  CALL   4422
....................    } 
0948E:  BRA    94B8
09490:  MOVLB  3
....................       // if mote temp is ALMOST outside of operating range, send an error message 
....................    else if ((global_mote_temperature < MOTE_MIN_TEMP_WARNING) || (global_mote_temperature > MOTE_MAX_TEMP_WARNING)) 
09492:  MOVF   x6D,W
09494:  XORLW  80
09496:  SUBLW  5C
09498:  BC    94A4
0949A:  BTFSC  x6D.7
0949C:  BRA    94BA
0949E:  MOVF   x6D,W
094A0:  SUBLW  50
094A2:  BC    94BA
....................    { 
....................       // set message error bitfield and queue error message 
....................       global_error_message_bitfield |= (ERR_MSG_MOTE_TEMP_OUT_OF_RANGE); 
094A4:  MOVLB  4
094A6:  BSF    xF8.6
....................       PUSH_MESSAGE_QUEUE_MACRO(MSG_MOTE_ERROR_MSG); 
094A8:  BCF    F7A.1
094AA:  MOVLW  A0
094AC:  MOVLB  5
094AE:  MOVWF  x54
094B0:  MOVLB  0
094B2:  CALL   4FF4
094B6:  BSF    F7A.1
094B8:  MOVLB  3
....................    } 
094BA:  MOVLB  0
094BC:  GOTO   AFD0 (RETURN)
....................        
.................... } 
....................  
.................... void mote_time_update(void) 
.................... // queries the mote to for the utc time and update the micro's utc time 
.................... { 
....................    uint8_t result_byte; 
....................     
....................    // if the mote is not enabled/ready exit! 
....................    if (global_dust_enabled == FALSE) return; 
*
09154:  BTFSS  xA7.6
09156:  BRA    91DA
....................     
....................    // set the response flag 
....................    global_set_get_response = FALSE; 
09158:  MOVLB  3
0915A:  BCF    x60.2
....................    // generate the message and send the message 
....................    pkgen_get_time(); 
0915C:  MOVLW  02
0915E:  MOVLB  5
09160:  MOVWF  x4C
09162:  MOVLW  01
09164:  MOVWF  x4D
09166:  MOVLW  04
09168:  MOVWF  x4E
0916A:  MOVLW  0F
0916C:  MOVWF  x4F
0916E:  CLRF   x66
09170:  CLRF   x65
09172:  CLRF   x67
09174:  MOVLW  05
09176:  MOVWF  x69
09178:  MOVLW  4C
0917A:  MOVWF  x68
0917C:  MOVLW  04
0917E:  MOVWF  x6A
09180:  MOVLB  0
09182:  CALL   5E68
....................    result_byte = dust_hdlc_pksend(); 
09186:  CALL   6112
0918A:  MOVFF  01,54B
....................    // set message timeout 
....................    setup_T0_int(T0_250MS); 
0918E:  MOVLW  FC
09190:  MOVLB  5
09192:  MOVWF  x69
09194:  MOVLW  30
09196:  MOVWF  x68
09198:  MOVLB  0
0919A:  CALL   3844
....................    while (!TMR0IF && !global_set_get_response && !result_byte); 
0919E:  BTFSC  FF2.2
091A0:  BRA    91BA
091A2:  MOVLB  3
091A4:  BTFSS  x60.2
091A6:  BRA    91AC
091A8:  MOVLB  0
091AA:  BRA    91BA
091AC:  MOVLB  5
091AE:  MOVF   x4B,F
091B0:  BTFSS  FD8.2
091B2:  BRA    91B8
091B4:  MOVLB  0
091B6:  BRA    919E
091B8:  MOVLB  0
....................    // if the message fails, send an error message (kinda pointless though) 
....................    if (TMR0IF || result_byte) 
091BA:  BTFSC  FF2.2
091BC:  BRA    91C6
091BE:  MOVLB  5
091C0:  MOVF   x4B,F
091C2:  BZ    91DC
091C4:  MOVLB  0
....................    { 
....................       global_error_message_bitfield |= ERR_MOTE_UNRESPONSIVE; 
091C6:  MOVLB  4
091C8:  BSF    xF8.2
....................       PUSH_MESSAGE_QUEUE_MACRO(MSG_MOTE_ERROR_MSG); 
091CA:  BCF    F7A.1
091CC:  MOVLW  A0
091CE:  MOVLB  5
091D0:  MOVWF  x54
091D2:  MOVLB  0
091D4:  CALL   4FF4
091D8:  BSF    F7A.1
091DA:  MOVLB  5
....................    }      
091DC:  MOVLB  0
091DE:  GOTO   AFD0 (RETURN)
.................... } 
....................  
.................... void get_mote_net_info(void) 
.................... // queries the mote to get the macaddress 
.................... { 
....................    uint8_t result_byte; 
....................     
....................    // if the mote is not enabled/ready exit! 
....................    if (global_dust_enabled == FALSE) return; 
091E2:  BTFSS  xA7.6
091E4:  BRA    9268
....................     
....................    // set the response flag 
....................    global_set_get_response = FALSE; 
091E6:  MOVLB  3
091E8:  BCF    x60.2
....................    // generate the message and send the message 
....................    pkgen_get_networkinfo(); 
091EA:  MOVLW  02
091EC:  MOVLB  5
091EE:  MOVWF  x4C
091F0:  MOVLW  01
091F2:  MOVWF  x4D
091F4:  MOVLW  04
091F6:  MOVWF  x4E
091F8:  MOVLW  0D
091FA:  MOVWF  x4F
091FC:  CLRF   x66
091FE:  CLRF   x65
09200:  CLRF   x67
09202:  MOVLW  05
09204:  MOVWF  x69
09206:  MOVLW  4C
09208:  MOVWF  x68
0920A:  MOVLW  04
0920C:  MOVWF  x6A
0920E:  MOVLB  0
09210:  CALL   5E68
....................    result_byte = dust_hdlc_pksend(); 
09214:  CALL   6112
09218:  MOVFF  01,54B
....................    // set message timeout 
....................    setup_T0_int(T0_250MS); 
0921C:  MOVLW  FC
0921E:  MOVLB  5
09220:  MOVWF  x69
09222:  MOVLW  30
09224:  MOVWF  x68
09226:  MOVLB  0
09228:  CALL   3844
....................    while (!TMR0IF && !global_set_get_response && !result_byte); 
0922C:  BTFSC  FF2.2
0922E:  BRA    9248
09230:  MOVLB  3
09232:  BTFSS  x60.2
09234:  BRA    923A
09236:  MOVLB  0
09238:  BRA    9248
0923A:  MOVLB  5
0923C:  MOVF   x4B,F
0923E:  BTFSS  FD8.2
09240:  BRA    9246
09242:  MOVLB  0
09244:  BRA    922C
09246:  MOVLB  0
....................    // if the message fails, send an error message (kinda pointless though) 
....................    if (TMR0IF || result_byte) 
09248:  BTFSC  FF2.2
0924A:  BRA    9254
0924C:  MOVLB  5
0924E:  MOVF   x4B,F
09250:  BZ    926A
09252:  MOVLB  0
....................    { 
....................       global_error_message_bitfield |= ERR_MOTE_UNRESPONSIVE; 
09254:  MOVLB  4
09256:  BSF    xF8.2
....................       PUSH_MESSAGE_QUEUE_MACRO(MSG_MOTE_ERROR_MSG); 
09258:  BCF    F7A.1
0925A:  MOVLW  A0
0925C:  MOVLB  5
0925E:  MOVWF  x54
09260:  MOVLB  0
09262:  CALL   4FF4
09266:  BSF    F7A.1
09268:  MOVLB  5
....................    }      
0926A:  MOVLB  0
0926C:  GOTO   AFD0 (RETURN)
.................... } 
....................  
.................... void init_msgSEQ(void) 
.................... { 
....................    // uses the battery voltage and vgen to seed the random number generator 
....................    srand((get_vbatt(0)<<16) || get_vgen(0)); 
*
043CC:  MOVLB  5
043CE:  CLRF   x68
043D0:  MOVLB  0
043D2:  RCALL  4236
043D4:  MOVFF  02,54C
043D8:  MOVFF  01,54B
043DC:  MOVLW  00
043DE:  CLRF   03
043E0:  IORWF  03,W
043E2:  BNZ   43F6
043E4:  MOVLB  5
043E6:  CLRF   x57
043E8:  MOVLB  0
043EA:  RCALL  4290
043EC:  MOVF   01,W
043EE:  IORWF  02,W
043F0:  BNZ   43F6
043F2:  MOVLW  00
043F4:  BRA    43F8
043F6:  MOVLW  01
043F8:  MOVLB  5
043FA:  MOVWF  x4B
043FC:  CLRF   x4F
043FE:  CLRF   x4E
04400:  CLRF   x4D
04402:  MOVWF  x4C
04404:  MOVLB  0
04406:  BRA    42F2
....................    mote_msgSEQ = (uint16_t)rand(); 
04408:  BRA    434C
0440A:  MOVFF  02,366
0440E:  MOVFF  01,365
04412:  GOTO   4418 (RETURN)
.................... } 
....................  
.................... void deal_with_mote_ISR(void) 
*
01248:  MOVLB  5
0124A:  CLRF   x8A
0124C:  BCF    x8B.0
0124E:  CLRF   x8C
01250:  CLRF   x8D
01252:  CLRF   x91
01254:  CLRF   x90
01256:  CLRF   x8F
01258:  CLRF   x8E
0125A:  CLRF   x95
0125C:  CLRF   x94
0125E:  CLRF   x93
01260:  CLRF   x92
01262:  CLRF   x99
01264:  CLRF   x98
01266:  CLRF   x97
01268:  CLRF   x96
0126A:  CLRF   x9A
.................... { 
....................    uint8_t     i; 
....................     
....................    uint16_t    tmp2u16; 
....................     
....................    uint8_t     cmd_rcvd = 0; 
....................    int1        send_ack = FALSE; 
....................     
....................    uint8_t     response_type = 0; 
....................    uint8_t     len_data_rcvd = 0; 
....................    uint32_t    utc_sec_rcvd = 0; 
....................    uint32_t    utc_usec_rcvd = 0; 
....................    uint32_t    new_events_rcvd = 0; 
....................     
....................    // bytes grabbed by get_dustmsg and sent to pkdecode 
....................    uint8_t      num_of_bytes_rcvd_from_mote = 0; 
....................  
....................    // Actually grab the message from the mote 
....................    // gets bytes rcvd(global), dust_recive_buffer, some errors 
....................    num_of_bytes_rcvd_from_mote = get_dustmsg_ISR(); 
0126C:  MOVLB  0
0126E:  GOTO   0956
01272:  MOVFF  01,59A
....................     
....................    // Add error handling from get_dustmsg_ISR 
....................    // Send NACK? 
....................    
....................    //decodes the message and returns how many bytes were recived 
....................    dust_hdlc_pkdecode_ISR(num_of_bytes_rcvd_from_mote); 
01276:  MOVFF  59A,59F
0127A:  BRA    0AE0
....................     
....................    // Add error handling from pkdecode 
....................    // Send NACK? 
....................     
....................    // get the command type 
....................    cmd_rcvd = bytes_from_mote.dust_rcvd[0];         
0127C:  MOVFF  D9,58A
....................  
....................    // set these for CMD_TIME, _SERVICE, _EVENT, and _DATA 
....................    //   prefix_x[0] = cmd_rcvd; 
....................    //   prefix_x[1] = 0x00; 
....................    flags_rcvd = bytes_from_mote.dust_rcvd[2]; 
01280:  MOVFF  DB,362
....................  
....................    response_type = RC_OK; 
01284:  MOVLB  5
01286:  CLRF   x8C
....................     
....................    //  
....................    if (cmd_rcvd == CMD_SET || cmd_rcvd == CMD_GET || \ 
....................        cmd_rcvd == CMD_SETNV || cmd_rcvd == CMD_GETNV || \ 
....................        cmd_rcvd == CMD_SEND || cmd_rcvd == CMD_JOIN || \ 
....................        cmd_rcvd == CMD_DISCONNECT || cmd_rcvd == CMD_RESET || \ 
....................        cmd_rcvd == CMD_SLEEP || cmd_rcvd == CMD_TESTRADIOTX || \ 
....................        cmd_rcvd == CMD_TESTRADIORX || cmd_rcvd == CMD_CLEARNV || \ 
....................        cmd_rcvd == CMD_SEARCH) 
01288:  DECFSZ x8A,W
0128A:  BRA    128E
0128C:  BRA    12D6
0128E:  MOVF   x8A,W
01290:  SUBLW  02
01292:  BZ    12D6
01294:  MOVF   x8A,W
01296:  SUBLW  03
01298:  BZ    12D6
0129A:  MOVF   x8A,W
0129C:  SUBLW  04
0129E:  BZ    12D6
012A0:  MOVF   x8A,W
012A2:  SUBLW  05
012A4:  BZ    12D6
012A6:  MOVF   x8A,W
012A8:  SUBLW  06
012AA:  BZ    12D6
012AC:  MOVF   x8A,W
012AE:  SUBLW  07
012B0:  BZ    12D6
012B2:  MOVF   x8A,W
012B4:  SUBLW  08
012B6:  BZ    12D6
012B8:  MOVF   x8A,W
012BA:  SUBLW  09
012BC:  BZ    12D6
012BE:  MOVF   x8A,W
012C0:  SUBLW  0B
012C2:  BZ    12D6
012C4:  MOVF   x8A,W
012C6:  SUBLW  0C
012C8:  BZ    12D6
012CA:  MOVF   x8A,W
012CC:  SUBLW  10
012CE:  BZ    12D6
012D0:  MOVF   x8A,W
012D2:  SUBLW  11
012D4:  BNZ   12DA
....................    { 
....................        // we are hoping that result_rcvd = RC_OK) 
....................        result_rcvd = bytes_from_mote.dust_rcvd[3]; 
012D6:  MOVFF  DC,35F
....................    }    
....................  
....................    // Determine parameter type and if the response was ok for set and get commands 
....................    if (cmd_rcvd == CMD_SET || cmd_rcvd == CMD_GET || \ 
....................        cmd_rcvd == CMD_SETNV || cmd_rcvd == CMD_GETNV) 
012DA:  DECFSZ x8A,W
012DC:  BRA    12E0
012DE:  BRA    12F2
012E0:  MOVF   x8A,W
012E2:  SUBLW  02
012E4:  BZ    12F2
012E6:  MOVF   x8A,W
012E8:  SUBLW  03
012EA:  BZ    12F2
012EC:  MOVF   x8A,W
012EE:  SUBLW  04
012F0:  BNZ   1300
....................    {      
....................        param_type_rcvd = bytes_from_mote.dust_rcvd[4]; 
012F2:  MOVFF  DD,363
....................        // this eliminates a bunch of flags for one response "ok" flag 
....................        if (result_rcvd == RC_OK) global_set_get_response = TRUE; 
012F6:  MOVLB  3
012F8:  MOVF   x5F,F
012FA:  BNZ   12FE
012FC:  BSF    x60.2
012FE:  MOVLB  5
....................    } 
....................     
....................    // Main switch for all types of mote messages 
....................    switch (cmd_rcvd) 
01300:  MOVF   x8A,W
01302:  XORLW  01
01304:  MOVLB  0
01306:  BZ    136E
01308:  XORLW  03
0130A:  BZ    1380
0130C:  XORLW  01
0130E:  BTFSC  FD8.2
01310:  BRA    1514
01312:  XORLW  07
01314:  BTFSC  FD8.2
01316:  BRA    1526
01318:  XORLW  01
0131A:  BTFSC  FD8.2
0131C:  BRA    158C
0131E:  XORLW  02
01320:  BTFSC  FD8.2
01322:  BRA    158C
01324:  XORLW  0F
01326:  BTFSC  FD8.2
01328:  BRA    158C
0132A:  XORLW  01
0132C:  BTFSC  FD8.2
0132E:  BRA    158C
01330:  XORLW  02
01332:  BTFSC  FD8.2
01334:  BRA    158C
01336:  XORLW  07
01338:  BTFSC  FD8.2
0133A:  BRA    158C
0133C:  XORLW  1C
0133E:  BTFSC  FD8.2
01340:  BRA    158C
01342:  XORLW  01
01344:  BTFSC  FD8.2
01346:  BRA    158E
01348:  XORLW  17
0134A:  BTFSC  FD8.2
0134C:  BRA    15A0
0134E:  XORLW  0B
01350:  BTFSC  FD8.2
01352:  BRA    15B4
01354:  XORLW  03
01356:  BTFSC  FD8.2
01358:  BRA    161C
0135A:  XORLW  01
0135C:  BTFSC  FD8.2
0135E:  BRA    1628
01360:  XORLW  1D
01362:  BTFSC  FD8.2
01364:  BRA    16A6
01366:  XORLW  93
01368:  BTFSC  FD8.2
0136A:  BRA    16D2
0136C:  BRA    173A
....................    {   
....................       // receipt of response after a SET command 
....................       case  CMD_SET: 
....................          // byte4 is the param_type for all SET responses 
....................          switch (param_type_rcvd) 
0136E:  MOVLB  3
01370:  MOVF   x63,W
01372:  XORLW  06
01374:  MOVLB  0
01376:  BZ    137E
01378:  XORLW  0E
0137A:  BZ    1380
0137C:  BRA    1380
....................          {   
....................             case  PARAM_JOINDUTY: 
....................                break; 
0137E:  BRA    1380
....................             case  PARAM_SERVICE: 
....................                //    save info, no ack 
....................                //    rem_svc_entries_rcvd = \ 
....................                //    bytes_from_mote.set_service_response.rem_svc_entries; 
....................                break; 
....................             default:           
....................          } 
....................           
....................       // receipt of response after a GET command 
....................       case  CMD_GET: 
....................          // byte4 is the param_type for all GET responses 
....................          switch (param_type_rcvd) 
01380:  MOVLB  3
01382:  MOVF   x63,W
01384:  XORLW  08
01386:  MOVLB  0
01388:  BZ    13A4
0138A:  XORLW  04
0138C:  BZ    13AA
0138E:  XORLW  01
01390:  BZ    13EE
01392:  XORLW  03
01394:  BZ    144A
01396:  XORLW  01
01398:  BTFSC  FD8.2
0139A:  BRA    14AA
0139C:  XORLW  1F
0139E:  BTFSC  FD8.2
013A0:  BRA    1510
013A2:  BRA    1514
....................          {   
....................             case  PARAM_SERVICE: 
....................                svc_index_rcvd = bytes_from_mote.get_service_response.svc_index; 
013A4:  MOVFF  DE,364
....................                /* 
....................                svc_state_rcvd = bytes_from_mote.get_service_response.svc_state; 
....................                svc_flags_rcvd = bytes_from_mote.get_service_response.svc_flags; 
....................                app_domain_rcvd = \ 
....................                   bytes_from_mote.get_service_response.app_domain; 
....................                */ 
....................                //destaddr_rcvd = bytes_from_mote.get_service_response.destaddr; 
....................                //time_rcvd = bytes_from_mote.get_service_response.time; 
....................                break; 
013A8:  BRA    1514
....................  
....................             case  PARAM_MOTEINFO: 
....................                for (i=0; i<8; i++) 
013AA:  MOVLB  5
013AC:  CLRF   x87
013AE:  MOVF   x87,W
013B0:  SUBLW  07
013B2:  BNC   13EA
....................                   serial_number_rcvd[i] = \ 
....................                      bytes_from_mote.get_moteinfo_response.serial_number[i]; 
013B4:  CLRF   03
013B6:  MOVF   x87,W
013B8:  ADDLW  97
013BA:  MOVWF  01
013BC:  MOVLW  00
013BE:  ADDWFC 03,F
013C0:  MOVFF  01,59F
013C4:  MOVFF  03,5A0
013C8:  CLRF   03
013CA:  MOVF   x87,W
013CC:  ADDLW  DF
013CE:  MOVWF  FE9
013D0:  MOVLW  00
013D2:  ADDWFC 03,W
013D4:  MOVWF  FEA
013D6:  MOVFF  FEF,5A1
013DA:  MOVFF  5A0,FEA
013DE:  MOVFF  01,FE9
013E2:  MOVFF  5A1,FEF
013E6:  INCF   x87,F
013E8:  BRA    13AE
....................                    
....................                /* 
....................                api_version_rcvd = \ 
....................                   bytes_from_mote.get_moteinfo_response.api_version; 
....................                hw_model_rcvd = bytes_from_mote.get_moteinfo_response.hw_model; 
....................                hw_version_rcvd = \ 
....................                   bytes_from_mote.get_moteinfo_response.hw_version; 
....................                sw_major_ver_rcvd = \ 
....................                   bytes_from_mote.get_moteinfo_response.sw_major_ver; 
....................                sw_minor_ver_rcvd = \ 
....................                   bytes_from_mote.get_moteinfo_response.sw_minor_ver; 
....................                sw_patch_rcvd = bytes_from_mote.get_moteinfo_response.sw_patch; 
....................                sw_build_rcvd = bytes_from_mote.get_moteinfo_response.sw_build; 
....................                */ 
....................                break; 
013EA:  MOVLB  0
013EC:  BRA    1514
....................  
....................             case  PARAM_NETWORKINFO: 
....................                for (i=0; i<8; i++) 
013EE:  MOVLB  5
013F0:  CLRF   x87
013F2:  MOVF   x87,W
013F4:  SUBLW  07
013F6:  BNC   142E
....................                   macaddr_rcvd[i] = \ 
....................                      bytes_from_mote.get_networkinfo_response.macaddr[i]; 
013F8:  CLRF   03
013FA:  MOVF   x87,W
013FC:  ADDLW  9F
013FE:  MOVWF  01
01400:  MOVLW  00
01402:  ADDWFC 03,F
01404:  MOVFF  01,59F
01408:  MOVFF  03,5A0
0140C:  CLRF   03
0140E:  MOVF   x87,W
01410:  ADDLW  DE
01412:  MOVWF  FE9
01414:  MOVLW  00
01416:  ADDWFC 03,W
01418:  MOVWF  FEA
0141A:  MOVFF  FEF,5A1
0141E:  MOVFF  5A0,FEA
01422:  MOVFF  01,FE9
01426:  MOVFF  5A1,FEF
0142A:  INCF   x87,F
0142C:  BRA    13F2
....................                mote_id_rcvd = bytes_from_mote.get_networkinfo_response.mote_id; 
0142E:  MOVFF  E7,36A
01432:  MOVFF  E6,369
....................                tmp2u16 = bytes_from_mote.get_networkinfo_response.network_id; 
01436:  MOVFF  E9,589
0143A:  MOVFF  E8,588
....................                network_id_rcvd = make16(make8(tmp2u16,0),make8(tmp2u16,1)); 
0143E:  MOVFF  588,368
01442:  MOVFF  589,367
....................  
....................                break; 
01446:  MOVLB  0
01448:  BRA    1514
....................  
....................             case  PARAM_MOTESTATUS: 
....................                global_mote_state = bytes_from_mote.get_motestatus_response.mote_state; 
0144A:  MOVFF  DE,504
....................                 
....................                // this is where I decide if the mote is alive or not 
....................                global_dust_enabled = TRUE; 
0144E:  BSF    xA7.6
....................                 
....................                // If the mote isn't fully connected (operational) set the global 
....................                //    dust operational bit to false 
....................                if (global_mote_state != MOTESTATE_OPERATIONAL) 
01450:  MOVLB  5
01452:  MOVF   x04,W
01454:  SUBLW  05
01456:  BZ    1460
....................                { 
....................                   global_dust_operational = FALSE; 
01458:  MOVLB  0
0145A:  BCF    xA7.7
....................                } 
0145C:  BRA    14A8
0145E:  MOVLB  5
....................                // If the mote is fully connected... 
....................                else  
....................                { 
....................                   // and it wasn't before... 
....................                   if (global_dust_operational == FALSE) 
01460:  MOVLB  0
01462:  BTFSC  xA7.7
01464:  BRA    14A8
....................                   { 
....................   
....................                      // set it to be connected and send a join message! 
....................                      global_dust_operational = TRUE; 
01466:  BSF    xA7.7
....................                      PUSH_MESSAGE_QUEUE_ISR_MACRO(MSG_MOTE_JOIN_MSG); 
01468:  BCF    F7A.1
0146A:  MOVLW  94
0146C:  MOVLB  5
0146E:  MOVWF  x9F
01470:  MOVLB  0
01472:  CALL   0C26
01476:  BSF    F7A.1
01478:  CLRF   19
0147A:  BTFSC  FF2.7
0147C:  BSF    19.7
0147E:  BCF    FF2.7
....................                      PUSH_PRIORITY_QUEUE_ISR_MACRO(UPDATE_MOTE_TIME); 
01480:  MOVLW  A3
01482:  MOVLB  5
01484:  MOVWF  xB7
01486:  MOVLB  0
01488:  CALL   082A
0148C:  BTFSC  19.7
0148E:  BSF    FF2.7
01490:  CLRF   19
01492:  BTFSC  FF2.7
01494:  BSF    19.7
01496:  BCF    FF2.7
....................                      PUSH_PRIORITY_QUEUE_ISR_MACRO(CHECK_MOTE_TEMP); 
01498:  MOVLW  A2
0149A:  MOVLB  5
0149C:  MOVWF  xB7
0149E:  MOVLB  0
014A0:  CALL   082A
014A4:  BTFSC  19.7
014A6:  BSF    FF2.7
....................                   } 
....................                }    
....................                //mote_alarms_rcvd = \ 
....................                //   bytes_from_mote.get_motestatus_response.mote_alarms; 
.................... /* 
....................                change_counter_rcvd = \ 
....................                   bytes_from_mote.get_motestatus_response.change_counter; 
....................                number_of_parents_rcvd = \ 
....................                   bytes_from_mote.get_motestatus_response.number_of_parents; 
.................... */ 
....................                break; 
014A8:  BRA    1514
....................  
....................             case  PARAM_TIME: 
....................                utc_sec_rcvd = bytes_from_mote.get_time_response.utc_sec; 
014AA:  MOVFF  E1,591
014AE:  MOVFF  E0,590
014B2:  MOVFF  DF,58F
014B6:  MOVFF  DE,58E
....................                // JG: save first utc time reported from mote since boot 
....................                if (!global_utc_time) 
014BA:  MOVF   x89,F
014BC:  BNZ   14DA
014BE:  MOVF   x8A,F
014C0:  BNZ   14DA
014C2:  MOVF   x8B,F
014C4:  BNZ   14DA
014C6:  MOVF   x8C,F
014C8:  BNZ   14DA
....................                { 
....................                   global_first_utc_time = make32(make8(utc_sec_rcvd,0), \ 
....................                    make8(utc_sec_rcvd,1), make8(utc_sec_rcvd,2), \ 
....................                    make8(utc_sec_rcvd,3));     //  **fix byte order** 
014CA:  MOVFF  58E,90
014CE:  MOVFF  58F,8F
014D2:  MOVFF  590,8E
014D6:  MOVFF  591,8D
....................                } 
....................                 
....................                global_utc_time = make32(make8(utc_sec_rcvd,0), \ 
....................                 make8(utc_sec_rcvd,1), make8(utc_sec_rcvd,2), \ 
....................                 make8(utc_sec_rcvd,3));     //  **fix byte order** 
014DA:  MOVFF  58E,8C
014DE:  MOVFF  58F,8B
014E2:  MOVFF  590,8A
014E6:  MOVFF  591,89
....................                               
....................                utc_usec_rcvd = bytes_from_mote.get_time_response.utc_usec; 
014EA:  MOVFF  E5,595
014EE:  MOVFF  E4,594
014F2:  MOVFF  E3,593
014F6:  MOVFF  E2,592
....................                if (mote_msgSEQ == 0) 
014FA:  MOVLB  3
014FC:  MOVF   x65,F
014FE:  BNZ   150C
01500:  MOVF   x66,F
01502:  BNZ   150C
....................                { 
....................                   mote_msgSEQ = make16(make8(utc_usec_rcvd,2), \                   
....................                      make8(utc_usec_rcvd,3)); 
01504:  MOVFF  594,366
01508:  MOVFF  595,365
....................                } 
....................                // This value is used to establish a "random" value for  
....................                //  the mote message Sequence ID 
.................... /*                
....................                for (i=0; i<5; i++) 
....................                   asn_rcvd[i] = bytes_from_mote.get_time_response.asn[i]; 
....................                asn_offset_rcvd = bytes_from_mote.get_time_response.asn_offset; 
.................... */                
....................                break; 
0150C:  MOVLB  0
0150E:  BRA    1514
....................  
....................             case  PARAM_CHARGE: 
....................                //charge_mC_rcvd = bytes_from_mote.get_charge_response.charge_mC; 
....................                //uptime_sec_rcvd = bytes_from_mote.get_charge_response.uptime_sec; 
....................                global_mote_temperature = \ 
....................                   bytes_from_mote.get_charge_response.temp_celsius; 
01510:  MOVFF  E6,36D
....................                //temp_frac_celsius_rcvd = \ 
....................                //   bytes_from_mote.get_charge_response.temp_frac_celsius; 
....................                break; 
.................... /* 
....................             case  PARAM_RADIOSTATSRX: 
....................                num_of_received_packets_rcvd = \ 
....................                   bytes_from_mote.get_testrx_response.num_of_received_packets; 
....................                num_of_recep_failures = \ 
....................                   bytes_from_mote.get_testrx_response.num_of_recep_failures; 
....................                break; 
.................... */ 
....................             default: 
....................          } 
....................  
....................       case  CMD_SETNV: 
....................       // receipt of response after a SETNV command 
....................           switch (param_type_rcvd) 
01514:  MOVLB  3
01516:  MOVF   x63,W
01518:  XORLW  02
0151A:  MOVLB  0
0151C:  BZ    1524
0151E:  XORLW  01
01520:  BZ    1526
01522:  BRA    1526
....................          {  // byte4 is the param_type for all SETNV responses 
....................             /* 
....................             case PARAM_MACADDR: case  PARAM_TXPOWER: \ 
....................             case  PARAM_POWERINFO: case  PARAM_OTAPLOCK: \ 
....................             case PARAM_SPECIAL1: case PARAM_SPECIAL2: 
....................                break; 
....................             */ 
....................             case PARAM_JOINKEY:  
....................                break; 
01524:  BRA    1526
....................             case  PARAM_NETWORKID:  
....................                break; 
....................             default: 
....................          } 
....................  
....................       case  CMD_GETNV: 
....................       // receipt of response after a GETNV command 
....................          switch (param_type_rcvd) 
01526:  MOVLB  3
01528:  MOVF   x63,W
0152A:  XORLW  01
0152C:  MOVLB  0
0152E:  BZ    1536
01530:  XORLW  02
01532:  BZ    1578
01534:  BRA    158C
....................          {  // byte4 is the param_type for all GETNV responses 
....................             case  PARAM_MACADDR: 
....................                for (i=0; i<8; i++) 
01536:  MOVLB  5
01538:  CLRF   x87
0153A:  MOVF   x87,W
0153C:  SUBLW  07
0153E:  BNC   1576
....................                   macaddr_rcvd[i] = \ 
....................                      bytes_from_mote.getNV_macaddr_response.macaddr[i]; 
01540:  CLRF   03
01542:  MOVF   x87,W
01544:  ADDLW  9F
01546:  MOVWF  01
01548:  MOVLW  00
0154A:  ADDWFC 03,F
0154C:  MOVFF  01,59F
01550:  MOVFF  03,5A0
01554:  CLRF   03
01556:  MOVF   x87,W
01558:  ADDLW  DE
0155A:  MOVWF  FE9
0155C:  MOVLW  00
0155E:  ADDWFC 03,W
01560:  MOVWF  FEA
01562:  MOVFF  FEF,5A1
01566:  MOVFF  5A0,FEA
0156A:  MOVFF  01,FE9
0156E:  MOVFF  5A1,FEF
01572:  INCF   x87,F
01574:  BRA    153A
....................                break; 
01576:  BRA    158A
....................  
....................             case  PARAM_NETWORKID: 
....................                tmp2u16 = bytes_from_mote.getNV_networkid_response.network_id; 
01578:  MOVFF  DF,589
0157C:  MOVFF  DE,588
....................                network_id_rcvd = make16(make8(tmp2u16,0),make8(tmp2u16,1)); 
01580:  MOVFF  588,368
01584:  MOVFF  589,367
....................                break; 
01588:  MOVLB  5
0158A:  MOVLB  0
....................  
....................             default: 
....................           } 
....................  
....................       case  CMD_SEND:         case  CMD_DISCONNECT: \ 
....................       case  CMD_RESET:        case  CMD_SLEEP:     case  CMD_TESTRADIOTX: \ 
....................       case  CMD_TESTRADIORX:  case  CMD_CLEARNV: 
....................          // info saved above; receipt of response after any of the 
....................          // the above; no ack 
....................          break; 
0158C:  BRA    173A
....................       case CMD_SEARCH: 
....................          if (result_rcvd == RC_OK) 
0158E:  MOVLB  3
01590:  MOVF   x5F,F
01592:  BNZ   159C
....................          { 
....................             global_mote_state= MOTESTATE_SEARCHING; 
01594:  MOVLW  02
01596:  MOVLB  5
01598:  MOVWF  x04
0159A:  MOVLB  3
....................          } 
....................          break; 
0159C:  MOVLB  0
0159E:  BRA    173A
....................       case CMD_JOIN: 
....................          if (result_rcvd == RC_OK) 
015A0:  MOVLB  3
015A2:  MOVF   x5F,F
015A4:  BNZ   15AE
....................             global_mote_state = MOTESTATE_NEGOTIATING; 
015A6:  MOVLW  03
015A8:  MOVLB  5
015AA:  MOVWF  x04
015AC:  MOVLB  3
....................             joincmd_done_fl = TRUE; 
015AE:  BSF    x61.3
....................          break; 
015B0:  MOVLB  0
015B2:  BRA    173A
....................  
....................       case  CMD_TIME: 
....................       // receipt of response after a _TIME hardware interrupt 
....................          utc_sec_rcvd = bytes_from_mote.time_indication.utc_sec; 
015B4:  MOVFF  DF,591
015B8:  MOVFF  DE,590
015BC:  MOVFF  DD,58F
015C0:  MOVFF  DC,58E
....................           
....................          // JG: save first utc time reported from mote since boot 
....................          if (!global_utc_time) 
015C4:  MOVF   x89,F
015C6:  BNZ   15E4
015C8:  MOVF   x8A,F
015CA:  BNZ   15E4
015CC:  MOVF   x8B,F
015CE:  BNZ   15E4
015D0:  MOVF   x8C,F
015D2:  BNZ   15E4
....................          { 
....................             global_first_utc_time = make32(make8(utc_sec_rcvd,0), \ 
....................              make8(utc_sec_rcvd,1), make8(utc_sec_rcvd,2), \ 
....................              make8(utc_sec_rcvd,3));     //  **fix byte order** 
015D4:  MOVFF  58E,90
015D8:  MOVFF  58F,8F
015DC:  MOVFF  590,8E
015E0:  MOVFF  591,8D
....................          } 
....................  
....................          global_utc_time = make32(make8(utc_sec_rcvd,0), \ 
....................           make8(utc_sec_rcvd,1), make8(utc_sec_rcvd,2), \ 
....................           make8(utc_sec_rcvd,3));     //  **fix byte order** 
015E4:  MOVFF  58E,8C
015E8:  MOVFF  58F,8B
015EC:  MOVFF  590,8A
015F0:  MOVFF  591,89
....................          utc_usec_rcvd = bytes_from_mote.time_indication.utc_usec; 
015F4:  MOVFF  E3,595
015F8:  MOVFF  E2,594
015FC:  MOVFF  E1,593
01600:  MOVFF  E0,592
....................          if (!mote_msgSEQ) 
01604:  MOVLB  3
01606:  MOVF   x65,W
01608:  IORWF  x66,W
0160A:  BNZ   1614
....................          { 
....................             mote_msgSEQ = make16(make8(utc_usec_rcvd,2), \                   
....................                make8(utc_usec_rcvd,3)); 
0160C:  MOVFF  594,366
01610:  MOVFF  595,365
....................          } 
....................  
....................          /* 
....................          for (i=0; i<5; i++) 
....................             asn_rcvd[i] = bytes_from_mote.time_indication.asn[i]; 
....................          asn_offset_rcvd = bytes_from_mote.time_indication.asn_offset; 
....................          */ 
....................  
.................... //         dust_hdlc_pkgen(prefix_x, 2, (uint8_t*)&r_x, 2);   // type A 
....................          send_ack = TRUE; 
01614:  MOVLB  5
01616:  BSF    x8B.0
....................          break; 
01618:  MOVLB  0
0161A:  BRA    173A
....................  
....................       case  CMD_SERVICE: 
....................       // receipt of a service indication from from manager 
....................          //event_code_rcvd = bytes_from_mote.service_indication.event_code; 
....................          svc_index_rcvd = bytes_from_mote.service_indication.svc_index; 
0161C:  MOVFF  DE,364
....................          /* 
....................          mgr_code_rcvd = bytes_from_mote.service_indication.mgr_code; 
....................          svc_state_rcvd = bytes_from_mote.service_indication.svc_state; 
....................          svc_flags_rcvd = bytes_from_mote.service_indication.svc_flags; 
....................          app_domain_rcvd = bytes_from_mote.service_indication.app_domain; 
....................          */ 
....................          //destaddr_rcvd = bytes_from_mote.service_indication.destaddr; 
....................          //time_rcvd = bytes_from_mote.service_indication.time; 
....................  
....................  //        dust_hdlc_pkgen(prefix_x, 2, (uint8_t*)&r_x, 2);   // type A 
....................  
....................          send_ack = TRUE; 
01620:  MOVLB  5
01622:  BSF    x8B.0
....................          break; 
01624:  MOVLB  0
01626:  BRA    173A
....................  
....................       case  CMD_EVENT: 
....................       // receipt of an event indication from the mote 
....................          // this is where I decide if the mote is alive or not 
....................          global_dust_enabled = TRUE; 
01628:  BSF    xA7.6
....................           
....................          new_events_rcvd = bytes_from_mote.events_indication.new_events; 
0162A:  MOVFF  DF,599
0162E:  MOVFF  DE,598
01632:  MOVFF  DD,597
01636:  MOVFF  DC,596
....................          global_mote_state = bytes_from_mote.events_indication.mote_state; 
0163A:  MOVFF  E0,504
....................           
....................          // If the mote isn't fully connected (operational) set the global 
....................          //    dust operational bit to false 
....................          if (global_mote_state != MOTESTATE_OPERATIONAL) 
0163E:  MOVLB  5
01640:  MOVF   x04,W
01642:  SUBLW  05
01644:  BZ    164E
....................          { 
....................             global_dust_operational = FALSE; 
01646:  MOVLB  0
01648:  BCF    xA7.7
....................          } 
0164A:  BRA    1696
0164C:  MOVLB  5
....................          // If the mote is fully connected... 
....................          else  
....................          {                                
....................             // and it wasn't before... 
....................             if (global_dust_operational == FALSE) 
0164E:  MOVLB  0
01650:  BTFSC  xA7.7
01652:  BRA    1696
....................             { 
....................                // set it to be connected and send a join message! 
....................                global_dust_operational = TRUE; 
01654:  BSF    xA7.7
....................                PUSH_MESSAGE_QUEUE_ISR_MACRO(MSG_MOTE_JOIN_MSG); 
01656:  BCF    F7A.1
01658:  MOVLW  94
0165A:  MOVLB  5
0165C:  MOVWF  x9F
0165E:  MOVLB  0
01660:  CALL   0C26
01664:  BSF    F7A.1
01666:  CLRF   19
01668:  BTFSC  FF2.7
0166A:  BSF    19.7
0166C:  BCF    FF2.7
....................                                              
....................                PUSH_PRIORITY_QUEUE_ISR_MACRO(UPDATE_MOTE_TIME); 
0166E:  MOVLW  A3
01670:  MOVLB  5
01672:  MOVWF  xB7
01674:  MOVLB  0
01676:  CALL   082A
0167A:  BTFSC  19.7
0167C:  BSF    FF2.7
0167E:  CLRF   19
01680:  BTFSC  FF2.7
01682:  BSF    19.7
01684:  BCF    FF2.7
....................                PUSH_PRIORITY_QUEUE_ISR_MACRO(CHECK_MOTE_TEMP);    
01686:  MOVLW  A2
01688:  MOVLB  5
0168A:  MOVWF  xB7
0168C:  MOVLB  0
0168E:  CALL   082A
01692:  BTFSC  19.7
01694:  BSF    FF2.7
....................             } 
....................          } 
....................          //mote_alarms_rcvd = bytes_from_mote.events_indication.mote_alarms; 
....................  
....................          event_flags |= make8(new_events_rcvd,3);  // only last byte has 
01696:  MOVLB  5
01698:  MOVF   x99,W
0169A:  MOVLB  0
0169C:  IORWF  xD8,F
....................          // defined events for Eterna 
....................     
....................          send_ack = TRUE;           
0169E:  MOVLB  5
016A0:  BSF    x8B.0
....................          break; 
016A2:  MOVLB  0
016A4:  BRA    173A
....................  
....................       case  CMD_ADVERT: 
....................       // receipt of an event indication from the mote 
....................          tmp2u16 = bytes_from_mote.advert_indication.network_id; 
016A6:  MOVFF  DD,589
016AA:  MOVFF  DC,588
....................          network_id_rcvd = make16(make8(tmp2u16,0),make8(tmp2u16,1)); 
016AE:  MOVFF  588,368
016B2:  MOVFF  589,367
....................          mote_id_rcvd = bytes_from_mote.advert_indication.mote_id; 
016B6:  MOVFF  DF,36A
016BA:  MOVFF  DE,369
....................           
....................          rssi_rcvd = bytes_from_mote.advert_indication.rssi; 
016BE:  MOVFF  E0,36B
....................          hop_depth_rcvd = bytes_from_mote.advert_indication.hop_depth; 
016C2:  MOVFF  E1,36C
....................           
....................          advert_rcvd_fl = TRUE; 
016C6:  MOVLB  3
016C8:  BSF    x60.3
....................    //      dust_hdlc_pkgen(prefix_x, 2, (uint8_t*)&r_x, 2);   // type A 
....................  
....................          send_ack = TRUE; 
016CA:  MOVLB  5
016CC:  BSF    x8B.0
....................          break; 
016CE:  MOVLB  0
016D0:  BRA    173A
....................  
....................       case  CMD_DATA: 
....................       // receipt of a data packet payload from the manager 
....................          //sourceaddr_rcvd = bytes_from_mote.data_from_net.sourceaddr; 
....................          //sequence_num_rcvd = bytes_from_mote.data_from_net.sequence_num; 
....................          len_data_rcvd = bytes_from_mote.data_from_net.len_data; 
016D2:  MOVFF  DF,58D
....................  
....................          if (len_data_rcvd <= MAX_USER_DATA_SIZE) 
016D6:  MOVLB  5
016D8:  MOVF   x8D,W
016DA:  SUBLW  5E
016DC:  BNC   171E
....................          { 
....................             for (i=0; i<len_data_rcvd; i++) 
016DE:  CLRF   x87
016E0:  MOVF   x8D,W
016E2:  SUBWF  x87,W
016E4:  BC    171C
....................               payload_buff[i] = bytes_from_mote.data_from_net.data[i]; 
016E6:  CLRF   03
016E8:  MOVF   x87,W
016EA:  ADDLW  F3
016EC:  MOVWF  01
016EE:  MOVLW  02
016F0:  ADDWFC 03,F
016F2:  MOVFF  01,59F
016F6:  MOVFF  03,5A0
016FA:  CLRF   03
016FC:  MOVF   x87,W
016FE:  ADDLW  E0
01700:  MOVWF  FE9
01702:  MOVLW  00
01704:  ADDWFC 03,W
01706:  MOVWF  FEA
01708:  MOVFF  FEF,5A1
0170C:  MOVFF  5A0,FEA
01710:  MOVFF  01,FE9
01714:  MOVFF  5A1,FEF
01718:  INCF   x87,F
0171A:  BRA    16E0
....................          } 
0171C:  BRA    1722
....................          else 
....................          {     
....................             response_type = RC_INVALID_LEN; 
0171E:  MOVLW  04
01720:  MOVWF  x8C
....................          } 
....................           
....................          send_ack = TRUE; 
01722:  BSF    x8B.0
01724:  CLRF   19
01726:  BTFSC  FF2.7
01728:  BSF    19.7
0172A:  BCF    FF2.7
....................  
....................          PUSH_PRIORITY_QUEUE_ISR_MACRO(DEAL_WITH_NEW_PACKET)          
0172C:  MOVLW  20
0172E:  MOVWF  xB7
01730:  MOVLB  0
01732:  CALL   082A
01736:  BTFSC  19.7
01738:  BSF    FF2.7
....................          break; 
....................  
....................       default: 
....................    } 
....................  
....................    // Send acks for appropriate messages 
....................     if (send_ack) 
0173A:  MOVLB  5
0173C:  BTFSS  x8B.0
0173E:  BRA    17A2
....................    { 
....................       // generates the dust message 
....................       uint8_t pkgen_buf[2], cmd_rcvd_buf[2]; 
....................       pkgen_buf[0] = (flags_rcvd+1); 
01740:  MOVLW  01
01742:  MOVLB  3
01744:  ADDWF  x62,W
01746:  MOVLB  5
01748:  MOVWF  x9B
....................       pkgen_buf[1] = response_type; 
0174A:  MOVFF  58C,59C
....................       cmd_rcvd_buf[0] = cmd_rcvd; 
0174E:  MOVFF  58A,59D
....................       cmd_rcvd_buf[1] = 0; 
01752:  CLRF   x9E
....................        
....................       dust_hdlc_pkgen_ISR(cmd_rcvd_buf, 2, pkgen_buf , 2); 
01754:  MOVLW  05
01756:  MOVWF  xA0
01758:  MOVLW  9D
0175A:  MOVWF  x9F
0175C:  MOVLW  02
0175E:  MOVWF  xA1
01760:  MOVLW  05
01762:  MOVWF  xA3
01764:  MOVLW  9B
01766:  MOVWF  xA2
01768:  MOVLW  02
0176A:  MOVWF  xA4
0176C:  MOVLB  0
0176E:  CALL   0EE4
....................        
....................       // try 3 times to send the ack 
....................       for (i = 0; i < 3; i++) 
01772:  MOVLB  5
01774:  CLRF   x87
01776:  MOVF   x87,W
01778:  SUBLW  02
0177A:  BNC   17A2
....................       { 
....................          // successful ack send 
....................          if (dust_hdlc_pksend_ISR() == NO_ERR)  
0177C:  MOVLB  0
0177E:  RCALL  11A6
01780:  MOVF   01,F
01782:  BNZ   178C
....................          { 
....................             break; 
01784:  MOVLB  5
01786:  BRA    17A2
....................          } 
01788:  BRA    179E
0178A:  MOVLB  0
....................          // wait 50ms and try again 
....................          else 
....................          { 
....................             setup_T4_int(T4_50MS); 
0178C:  MOVLW  C7
0178E:  MOVLB  5
01790:  MOVWF  xA4
01792:  MOVLB  0
01794:  CALL   0944
....................             while(!TMR4IF);     
01798:  BTFSS  F7E.0
0179A:  BRA    1798
0179C:  MOVLB  5
....................          } 
0179E:  INCF   x87,F
017A0:  BRA    1776
....................        
....................       // Add error handling if no ack (not sure how) 
....................       } 
....................    } 
017A2:  MOVLB  0
017A4:  GOTO   17C0 (RETURN)
.................... } 
....................  
....................  
.................... uint8_t get_dustmsg_ISR(void) 
*
00956:  MOVLB  5
00958:  CLRF   x9F
.................... { 
.................... // After being prompted by a hardware interrupts on the UART lines 
.................... // this routine is called to actually collect the serial data and  
.................... // store it in dust_recive_buffer 
.................... // 
.................... // Returns the number of chars collected (1 char = 1 not 0) or some error code 
.................... // Error Codes: 
.................... // -ERR_GET_DUSTMSG_MESSAGE_LENGTH  
.................... // -ERR_GET_DUSTMSG_FRAMING_ERROR 
....................  
.................... //  When the hardware UART is specified by #use rs232(): 
.................... //  RS232_ERRORS is used only by the getc() function. 
.................... //  RS232_ERRORS is a copy of the RCSTA register except 
.................... //  that Bit 0 is used to indicate a parity error. 
.................... //  RS232 Errors are not yet implemented 
....................  
....................    uint8_t     bytes_rcvd = 0; 
....................     
....................    // Start the UART and pause for initialization 
....................    setup_uart(TRUE);           
0095A:  BSF    FAB.7
0095C:  BSF    FAB.4
0095E:  BSF    FAC.5
....................    setup_T4_int(T4_500US); 
00960:  MOVLW  01
00962:  MOVWF  xA4
00964:  MOVLB  0
00966:  RCALL  0944
....................    while(!TMR4IF);        
00968:  BTFSS  F7E.0
0096A:  BRA    0968
....................     
....................    // recieve up to MAX_RCV_BUFFER  
....................    for (bytes_rcvd = 0; bytes_rcvd < MAX_RCV_BUFFER; bytes_rcvd++) 
0096C:  MOVLB  5
0096E:  CLRF   x9F
00970:  MOVF   x9F,W
00972:  SUBLW  C9
00974:  BNC   09CC
....................    { 
....................       // clear to send a byte 
....................       output_low(MOTE_TX_CTSn);  
00976:  BCF    F89.5
....................        
....................       // setup individual byte timeout and wait for next char 
....................       setup_T4_int(T0_10MS);    
00978:  MOVLW  D9
0097A:  MOVWF  xA4
0097C:  MOVLB  0
0097E:  RCALL  0944
....................       while (!kbhit() && !TMR4IF);  
00980:  BTFSC  F9E.5
00982:  BRA    0988
00984:  BTFSS  F7E.0
00986:  BRA    0980
....................        
....................       // not clear to send the next byte until we process this one 
....................       output_high(MOTE_TX_CTSn); 
00988:  BSF    F89.5
....................        
....................       // return error on byte timeout 
....................       if (TMR4IF)  
0098A:  BTFSS  F7E.0
0098C:  BRA    099A
....................       { 
....................          setup_uart(FALSE);  
0098E:  BCF    FAB.7
00990:  BCF    FAB.4
00992:  BCF    FAC.5
....................          return ERR_DUSTMSG_TIMEOUT; 
00994:  MOVLW  FC
00996:  MOVWF  01
00998:  BRA    0A3C
....................       } 
....................        
....................       // grab the byte from the receive register 
....................       dust_recive_buffer[bytes_rcvd] = RCREG1;         
0099A:  CLRF   03
0099C:  MOVLB  5
0099E:  MOVF   x9F,W
009A0:  ADDLW  28
009A2:  MOVWF  FE9
009A4:  MOVLW  02
009A6:  ADDWFC 03,W
009A8:  MOVWF  FEA
009AA:  MOVFF  FAE,FEF
....................        
....................       // done with getting message, break out of loop 
....................       if ((dust_recive_buffer[bytes_rcvd] == FLAG_SEQUENCE) && (bytes_rcvd != 0)) 
009AE:  CLRF   03
009B0:  MOVF   x9F,W
009B2:  ADDLW  28
009B4:  MOVWF  FE9
009B6:  MOVLW  02
009B8:  ADDWFC 03,W
009BA:  MOVWF  FEA
009BC:  MOVF   FEF,W
009BE:  SUBLW  7E
009C0:  BNZ   09C8
009C2:  MOVF   x9F,F
009C4:  BZ    09C8
....................       { 
....................          break;          
009C6:  BRA    09CC
....................       }  
009C8:  INCF   x9F,F
009CA:  BRA    0970
....................    } 
....................      
....................    // after the message is done, stop the uart 
....................    setup_uart(FALSE);  
009CC:  BCF    FAB.7
009CE:  BCF    FAB.4
009D0:  BCF    FAC.5
....................     
....................    // Check for errors 
....................    // at this point only possible errors are framing and message length 
....................    // Too long of a message (no ending flag sequence) 
....................    if ((bytes_rcvd == MAX_RCV_BUFFER) && (dust_recive_buffer[bytes_rcvd] != FLAG_SEQUENCE)) 
009D2:  MOVF   x9F,W
009D4:  SUBLW  CA
009D6:  BNZ   09F8
009D8:  CLRF   03
009DA:  MOVF   x9F,W
009DC:  ADDLW  28
009DE:  MOVWF  FE9
009E0:  MOVLW  02
009E2:  ADDWFC 03,W
009E4:  MOVWF  FEA
009E6:  MOVF   FEF,W
009E8:  SUBLW  7E
009EA:  BZ    09F8
....................    { 
....................       return ERR_DUSTMSG_MESSAGE_LENGTH; 
009EC:  MOVLW  FF
009EE:  MOVWF  01
009F0:  MOVLB  0
009F2:  BRA    0A3C
....................    } 
009F4:  BRA    0A3C
009F6:  MOVLB  5
....................    // Too small of a message, return error code 
....................    else if (bytes_rcvd < 5) 
009F8:  MOVF   x9F,W
009FA:  SUBLW  04
009FC:  BNC   0A08
....................    { 
....................       return ERR_DUSTMSG_MESSAGE_LENGTH; 
009FE:  MOVLW  FF
00A00:  MOVWF  01
00A02:  MOVLB  0
00A04:  BRA    0A3C
....................    } 
00A06:  BRA    0A3C
....................    // Framing error, return error code 
....................    else if ((dust_recive_buffer[0] != FLAG_SEQUENCE) || (dust_recive_buffer[bytes_rcvd] != FLAG_SEQUENCE)) 
00A08:  MOVLB  2
00A0A:  MOVF   x28,W
00A0C:  SUBLW  7E
00A0E:  BNZ   0A28
00A10:  CLRF   03
00A12:  MOVLB  5
00A14:  MOVF   x9F,W
00A16:  ADDLW  28
00A18:  MOVWF  FE9
00A1A:  MOVLW  02
00A1C:  ADDWFC 03,W
00A1E:  MOVWF  FEA
00A20:  MOVF   FEF,W
00A22:  SUBLW  7E
00A24:  BZ    0A34
00A26:  MOVLB  2
....................    { 
....................       return ERR_DUSTMSG_FRAMING_ERROR; 
00A28:  MOVLW  FE
00A2A:  MOVWF  01
00A2C:  MOVLB  0
00A2E:  BRA    0A3C
....................    } 
00A30:  BRA    0A3C
00A32:  MOVLB  5
....................    // all is well, exit normally 
....................    else 
....................    {           
....................       // return how many bytes recieved in actual (starting at 1) number       
....................       return (bytes_rcvd + 1); 
00A34:  MOVLW  01
00A36:  ADDWF  x9F,W
00A38:  MOVWF  01
00A3A:  MOVLB  0
....................    } 
00A3C:  GOTO   1272 (RETURN)
.................... } 
....................  
.................... void dust_hdlc_pkgen(uint8_t* prefix, uint8_t size, \ 
....................                        uint8_t* buf, uint8_t size_buf) 
*
05E68:  MOVLB  5
05E6A:  CLRF   x6C
05E6C:  CLRF   x6B
05E6E:  CLRF   x6D
05E70:  CLRF   x6E
05E72:  CLRF   x6F
.................... { 
.................... // dust_hdlc_pkgen() 
.................... // 
.................... // Generate an HDLC packet ready for a mote. 
.................... // 
.................... // 1. Calc CRC-16 
.................... // 2. Add start delimiters (flag sequence) 
.................... // 3. Byte stuff 0x7e & 0x7d 
.................... // 4. Add end delimiters (flag sequence) 
.................... // 
....................      
....................    uint16_t    fcs16       = 0; 
....................    uint8_t     data8       = 0; 
....................    uint8_t     i           = 0; 
....................    uint8_t     j           = 0; 
....................  
.................... // Step 1 
....................    fcs16 = FCS_INITIAL_FCS16; 
05E74:  SETF   x6C
05E76:  SETF   x6B
....................     
....................    // FCS the prefix bytes 
....................    for (i = 0; i < size; i++) 
05E78:  CLRF   x6E
05E7A:  MOVF   x67,W
05E7C:  SUBWF  x6E,W
05E7E:  BC    5EB8
....................    { 
....................       fcs16 = fcs_fcs16(fcs16, prefix[i]); 
05E80:  MOVF   x6E,W
05E82:  ADDWF  x65,W
05E84:  MOVWF  FE9
05E86:  MOVLW  00
05E88:  ADDWFC x66,W
05E8A:  MOVWF  FEA
05E8C:  MOVFF  FEF,5AD
05E90:  CLRF   19
05E92:  BTFSC  FF2.7
05E94:  BSF    19.7
05E96:  BCF    FF2.7
05E98:  MOVFF  56C,5AC
05E9C:  MOVFF  56B,5AB
05EA0:  MOVLB  0
05EA2:  CALL   0EA2
05EA6:  BTFSC  19.7
05EA8:  BSF    FF2.7
05EAA:  MOVFF  02,56C
05EAE:  MOVFF  01,56B
05EB2:  MOVLB  5
05EB4:  INCF   x6E,F
05EB6:  BRA    5E7A
....................    } 
....................     
....................    // FCS the data packet bytes 
....................    for (i = 0; i < size_buf; i++) 
05EB8:  CLRF   x6E
05EBA:  MOVF   x6A,W
05EBC:  SUBWF  x6E,W
05EBE:  BC    5EF8
....................    { 
....................       fcs16 = fcs_fcs16(fcs16, buf[i]); 
05EC0:  MOVF   x6E,W
05EC2:  ADDWF  x68,W
05EC4:  MOVWF  FE9
05EC6:  MOVLW  00
05EC8:  ADDWFC x69,W
05ECA:  MOVWF  FEA
05ECC:  MOVFF  FEF,5AD
05ED0:  CLRF   19
05ED2:  BTFSC  FF2.7
05ED4:  BSF    19.7
05ED6:  BCF    FF2.7
05ED8:  MOVFF  56C,5AC
05EDC:  MOVFF  56B,5AB
05EE0:  MOVLB  0
05EE2:  CALL   0EA2
05EE6:  BTFSC  19.7
05EE8:  BSF    FF2.7
05EEA:  MOVFF  02,56C
05EEE:  MOVFF  01,56B
05EF2:  MOVLB  5
05EF4:  INCF   x6E,F
05EF6:  BRA    5EBA
....................    } 
....................  
....................    // add 1's complement 
....................    fcs16 = ~(fcs16);  
05EF8:  COMF   x6B,F
05EFA:  COMF   x6C,F
....................  
.................... // Step 2 
....................    //Set initial delimiter 
....................    j = 0; 
05EFC:  CLRF   x6F
....................    dust_send_buffer[j++]  = FLAG_SEQUENCE; 
05EFE:  MOVF   x6F,W
05F00:  INCF   x6F,F
05F02:  CLRF   03
05F04:  ADDLW  40
05F06:  MOVWF  FE9
05F08:  MOVLW  01
05F0A:  ADDWFC 03,W
05F0C:  MOVWF  FEA
05F0E:  MOVLW  7E
05F10:  MOVWF  FEF
....................  
.................... // Step 3 
....................    // Stuff prefix buffer 
....................    for (i = 0; i < size; i++) 
05F12:  CLRF   x6E
05F14:  MOVF   x67,W
05F16:  SUBWF  x6E,W
05F18:  BC    5FB4
....................    { 
....................       STUFF_BYTE(prefix[i], dust_send_buffer, j); 
05F1A:  MOVF   x6E,W
05F1C:  ADDWF  x65,W
05F1E:  MOVWF  FE9
05F20:  MOVLW  00
05F22:  ADDWFC x66,W
05F24:  MOVWF  FEA
05F26:  MOVF   FEF,W
05F28:  SUBLW  7D
05F2A:  BZ    5F3E
05F2C:  MOVF   x6E,W
05F2E:  ADDWF  x65,W
05F30:  MOVWF  FE9
05F32:  MOVLW  00
05F34:  ADDWFC x66,W
05F36:  MOVWF  FEA
05F38:  MOVF   FEF,W
05F3A:  SUBLW  7E
05F3C:  BNZ   5F86
05F3E:  MOVF   x6F,W
05F40:  INCF   x6F,F
05F42:  CLRF   03
05F44:  ADDLW  40
05F46:  MOVWF  FE9
05F48:  MOVLW  01
05F4A:  ADDWFC 03,W
05F4C:  MOVWF  FEA
05F4E:  MOVLW  7D
05F50:  MOVWF  FEF
05F52:  MOVF   x6F,W
05F54:  INCF   x6F,F
05F56:  CLRF   03
05F58:  ADDLW  40
05F5A:  MOVWF  01
05F5C:  MOVLW  01
05F5E:  ADDWFC 03,F
05F60:  MOVFF  01,570
05F64:  MOVFF  03,571
05F68:  MOVF   x6E,W
05F6A:  ADDWF  x65,W
05F6C:  MOVWF  FE9
05F6E:  MOVLW  00
05F70:  ADDWFC x66,W
05F72:  MOVWF  FEA
05F74:  MOVF   FEF,W
05F76:  XORLW  20
05F78:  MOVWF  x72
05F7A:  MOVFF  03,FEA
05F7E:  MOVFF  01,FE9
05F82:  MOVWF  FEF
05F84:  BRA    5FB0
05F86:  MOVF   x6F,W
05F88:  INCF   x6F,F
05F8A:  CLRF   03
05F8C:  ADDLW  40
05F8E:  MOVWF  01
05F90:  MOVLW  01
05F92:  ADDWFC 03,F
05F94:  MOVF   x6E,W
05F96:  ADDWF  x65,W
05F98:  MOVWF  FE9
05F9A:  MOVLW  00
05F9C:  ADDWFC x66,W
05F9E:  MOVWF  FEA
05FA0:  MOVFF  FEF,572
05FA4:  MOVFF  03,FEA
05FA8:  MOVFF  01,FE9
05FAC:  MOVFF  572,FEF
05FB0:  INCF   x6E,F
05FB2:  BRA    5F14
....................    } 
....................  
....................    // Stuff data buffer 
....................    for (i = 0; i < size_buf; i++) 
05FB4:  CLRF   x6E
05FB6:  MOVF   x6A,W
05FB8:  SUBWF  x6E,W
05FBA:  BC    6056
....................    { 
....................       STUFF_BYTE(buf[i], dust_send_buffer, j); 
05FBC:  MOVF   x6E,W
05FBE:  ADDWF  x68,W
05FC0:  MOVWF  FE9
05FC2:  MOVLW  00
05FC4:  ADDWFC x69,W
05FC6:  MOVWF  FEA
05FC8:  MOVF   FEF,W
05FCA:  SUBLW  7D
05FCC:  BZ    5FE0
05FCE:  MOVF   x6E,W
05FD0:  ADDWF  x68,W
05FD2:  MOVWF  FE9
05FD4:  MOVLW  00
05FD6:  ADDWFC x69,W
05FD8:  MOVWF  FEA
05FDA:  MOVF   FEF,W
05FDC:  SUBLW  7E
05FDE:  BNZ   6028
05FE0:  MOVF   x6F,W
05FE2:  INCF   x6F,F
05FE4:  CLRF   03
05FE6:  ADDLW  40
05FE8:  MOVWF  FE9
05FEA:  MOVLW  01
05FEC:  ADDWFC 03,W
05FEE:  MOVWF  FEA
05FF0:  MOVLW  7D
05FF2:  MOVWF  FEF
05FF4:  MOVF   x6F,W
05FF6:  INCF   x6F,F
05FF8:  CLRF   03
05FFA:  ADDLW  40
05FFC:  MOVWF  01
05FFE:  MOVLW  01
06000:  ADDWFC 03,F
06002:  MOVFF  01,570
06006:  MOVFF  03,571
0600A:  MOVF   x6E,W
0600C:  ADDWF  x68,W
0600E:  MOVWF  FE9
06010:  MOVLW  00
06012:  ADDWFC x69,W
06014:  MOVWF  FEA
06016:  MOVF   FEF,W
06018:  XORLW  20
0601A:  MOVWF  x72
0601C:  MOVFF  03,FEA
06020:  MOVFF  01,FE9
06024:  MOVWF  FEF
06026:  BRA    6052
06028:  MOVF   x6F,W
0602A:  INCF   x6F,F
0602C:  CLRF   03
0602E:  ADDLW  40
06030:  MOVWF  01
06032:  MOVLW  01
06034:  ADDWFC 03,F
06036:  MOVF   x6E,W
06038:  ADDWF  x68,W
0603A:  MOVWF  FE9
0603C:  MOVLW  00
0603E:  ADDWFC x69,W
06040:  MOVWF  FEA
06042:  MOVFF  FEF,572
06046:  MOVFF  03,FEA
0604A:  MOVFF  01,FE9
0604E:  MOVFF  572,FEF
06052:  INCF   x6E,F
06054:  BRA    5FB6
....................    } 
....................  
....................    // Add least significiant byte 1st (RFC 1622). Do byte stuffing. 
....................    data8 = (uint8_t)(fcs16 & 0xff); 
06056:  MOVFF  56B,56D
....................    STUFF_BYTE(data8, dust_send_buffer, j); 
0605A:  MOVF   x6D,W
0605C:  SUBLW  7D
0605E:  BZ    6066
06060:  MOVF   x6D,W
06062:  SUBLW  7E
06064:  BNZ   6092
06066:  MOVF   x6F,W
06068:  INCF   x6F,F
0606A:  CLRF   03
0606C:  ADDLW  40
0606E:  MOVWF  FE9
06070:  MOVLW  01
06072:  ADDWFC 03,W
06074:  MOVWF  FEA
06076:  MOVLW  7D
06078:  MOVWF  FEF
0607A:  MOVF   x6F,W
0607C:  INCF   x6F,F
0607E:  CLRF   03
06080:  ADDLW  40
06082:  MOVWF  FE9
06084:  MOVLW  01
06086:  ADDWFC 03,W
06088:  MOVWF  FEA
0608A:  MOVF   x6D,W
0608C:  XORLW  20
0608E:  MOVWF  FEF
06090:  BRA    60A6
06092:  MOVF   x6F,W
06094:  INCF   x6F,F
06096:  CLRF   03
06098:  ADDLW  40
0609A:  MOVWF  FE9
0609C:  MOVLW  01
0609E:  ADDWFC 03,W
060A0:  MOVWF  FEA
060A2:  MOVFF  56D,FEF
....................  
....................    // Add most significiant byte 2nd (RFC 1622). Do byte stuffing. 
....................    data8 = (uint8_t)((fcs16>>8) & 0xff); 
060A6:  MOVFF  56C,56D
....................    STUFF_BYTE(data8, dust_send_buffer, j); 
060AA:  MOVF   x6D,W
060AC:  SUBLW  7D
060AE:  BZ    60B6
060B0:  MOVF   x6D,W
060B2:  SUBLW  7E
060B4:  BNZ   60E2
060B6:  MOVF   x6F,W
060B8:  INCF   x6F,F
060BA:  CLRF   03
060BC:  ADDLW  40
060BE:  MOVWF  FE9
060C0:  MOVLW  01
060C2:  ADDWFC 03,W
060C4:  MOVWF  FEA
060C6:  MOVLW  7D
060C8:  MOVWF  FEF
060CA:  MOVF   x6F,W
060CC:  INCF   x6F,F
060CE:  CLRF   03
060D0:  ADDLW  40
060D2:  MOVWF  FE9
060D4:  MOVLW  01
060D6:  ADDWFC 03,W
060D8:  MOVWF  FEA
060DA:  MOVF   x6D,W
060DC:  XORLW  20
060DE:  MOVWF  FEF
060E0:  BRA    60F6
060E2:  MOVF   x6F,W
060E4:  INCF   x6F,F
060E6:  CLRF   03
060E8:  ADDLW  40
060EA:  MOVWF  FE9
060EC:  MOVLW  01
060EE:  ADDWFC 03,W
060F0:  MOVWF  FEA
060F2:  MOVFF  56D,FEF
....................  
.................... // Step 4 
....................    // CHECK_BUF_SIZE(j+1); 
....................    dust_send_buffer[j++]  = FLAG_SEQUENCE; 
060F6:  MOVF   x6F,W
060F8:  INCF   x6F,F
060FA:  CLRF   03
060FC:  ADDLW  40
060FE:  MOVWF  FE9
06100:  MOVLW  01
06102:  ADDWFC 03,W
06104:  MOVWF  FEA
06106:  MOVLW  7E
06108:  MOVWF  FEF
....................  
....................    // Set the number of bytes actually written 
....................    num_of_bytes_to_send = j; 
0610A:  MOVFF  56F,351
....................     
....................    return; 
0610E:  MOVLB  0
06110:  RETURN 0
.................... } 
....................  
.................... void dust_hdlc_pkgen_ISR(uint8_t* prefix, uint8_t size, \ 
....................                        uint8_t* buf, uint8_t size_buf) 
*
00EE4:  MOVLB  5
00EE6:  CLRF   xA6
00EE8:  CLRF   xA5
00EEA:  CLRF   xA7
00EEC:  CLRF   xA8
00EEE:  CLRF   xA9
.................... { 
.................... // Generate an HDLC packet ready for a mote. 
.................... // 
.................... // 1. Calc CRC-16 
.................... // 2. Add start delimiters (flag sequence) 
.................... // 3. Byte stuff 0x7e & 0x7d 
.................... // 4. Add end delimiters (flag sequence) 
.................... // 
....................      
....................    uint16_t    fcs16       = 0; 
....................    uint8_t     data8       = 0; 
....................    uint8_t     i           = 0; 
....................    uint8_t     j           = 0; 
....................  
.................... // Step 1 
....................    fcs16 = FCS_INITIAL_FCS16; 
00EF0:  SETF   xA6
00EF2:  SETF   xA5
....................     
....................    // FCS the prefix bytes 
....................    for (i = 0; i < size; i++) 
00EF4:  CLRF   xA8
00EF6:  MOVF   xA1,W
00EF8:  SUBWF  xA8,W
00EFA:  BC    0F26
....................    { 
....................       fcs16 = fcs_fcs16(fcs16, prefix[i]); 
00EFC:  MOVF   xA8,W
00EFE:  ADDWF  x9F,W
00F00:  MOVWF  FE9
00F02:  MOVLW  00
00F04:  ADDWFC xA0,W
00F06:  MOVWF  FEA
00F08:  MOVFF  FEF,5AD
00F0C:  MOVFF  5A6,5AC
00F10:  MOVFF  5A5,5AB
00F14:  MOVLB  0
00F16:  RCALL  0EA2
00F18:  MOVFF  02,5A6
00F1C:  MOVFF  01,5A5
00F20:  MOVLB  5
00F22:  INCF   xA8,F
00F24:  BRA    0EF6
....................    } 
....................     
....................    // FCS the data packet bytes 
....................    for (i = 0; i < size_buf; i++) 
00F26:  CLRF   xA8
00F28:  MOVF   xA4,W
00F2A:  SUBWF  xA8,W
00F2C:  BC    0F58
....................    { 
....................       fcs16 = fcs_fcs16(fcs16, buf[i]); 
00F2E:  MOVF   xA8,W
00F30:  ADDWF  xA2,W
00F32:  MOVWF  FE9
00F34:  MOVLW  00
00F36:  ADDWFC xA3,W
00F38:  MOVWF  FEA
00F3A:  MOVFF  FEF,5AD
00F3E:  MOVFF  5A6,5AC
00F42:  MOVFF  5A5,5AB
00F46:  MOVLB  0
00F48:  RCALL  0EA2
00F4A:  MOVFF  02,5A6
00F4E:  MOVFF  01,5A5
00F52:  MOVLB  5
00F54:  INCF   xA8,F
00F56:  BRA    0F28
....................    } 
....................  
....................    // add 1's complement 
....................    fcs16 = ~(fcs16);  
00F58:  COMF   xA5,F
00F5A:  COMF   xA6,F
....................  
.................... // Step 2 
....................    //Set initial delimiter 
....................    j = 0; 
00F5C:  CLRF   xA9
....................    dust_send_buffer_isr[j++]  = FLAG_SEQUENCE; 
00F5E:  MOVF   xA9,W
00F60:  INCF   xA9,F
00F62:  CLRF   03
00F64:  ADDLW  10
00F66:  MOVWF  FE9
00F68:  MOVLW  02
00F6A:  ADDWFC 03,W
00F6C:  MOVWF  FEA
00F6E:  MOVLW  7E
00F70:  MOVWF  FEF
....................  
.................... // Step 3 
....................    // Stuff prefix buffer 
....................    for (i = 0; i < size; i++) 
00F72:  CLRF   xA8
00F74:  MOVF   xA1,W
00F76:  SUBWF  xA8,W
00F78:  BC    1014
....................    { 
....................       STUFF_BYTE(prefix[i], dust_send_buffer_isr, j); 
00F7A:  MOVF   xA8,W
00F7C:  ADDWF  x9F,W
00F7E:  MOVWF  FE9
00F80:  MOVLW  00
00F82:  ADDWFC xA0,W
00F84:  MOVWF  FEA
00F86:  MOVF   FEF,W
00F88:  SUBLW  7D
00F8A:  BZ    0F9E
00F8C:  MOVF   xA8,W
00F8E:  ADDWF  x9F,W
00F90:  MOVWF  FE9
00F92:  MOVLW  00
00F94:  ADDWFC xA0,W
00F96:  MOVWF  FEA
00F98:  MOVF   FEF,W
00F9A:  SUBLW  7E
00F9C:  BNZ   0FE6
00F9E:  MOVF   xA9,W
00FA0:  INCF   xA9,F
00FA2:  CLRF   03
00FA4:  ADDLW  10
00FA6:  MOVWF  FE9
00FA8:  MOVLW  02
00FAA:  ADDWFC 03,W
00FAC:  MOVWF  FEA
00FAE:  MOVLW  7D
00FB0:  MOVWF  FEF
00FB2:  MOVF   xA9,W
00FB4:  INCF   xA9,F
00FB6:  CLRF   03
00FB8:  ADDLW  10
00FBA:  MOVWF  01
00FBC:  MOVLW  02
00FBE:  ADDWFC 03,F
00FC0:  MOVFF  01,5AA
00FC4:  MOVFF  03,5AB
00FC8:  MOVF   xA8,W
00FCA:  ADDWF  x9F,W
00FCC:  MOVWF  FE9
00FCE:  MOVLW  00
00FD0:  ADDWFC xA0,W
00FD2:  MOVWF  FEA
00FD4:  MOVF   FEF,W
00FD6:  XORLW  20
00FD8:  MOVWF  xAC
00FDA:  MOVFF  03,FEA
00FDE:  MOVFF  01,FE9
00FE2:  MOVWF  FEF
00FE4:  BRA    1010
00FE6:  MOVF   xA9,W
00FE8:  INCF   xA9,F
00FEA:  CLRF   03
00FEC:  ADDLW  10
00FEE:  MOVWF  01
00FF0:  MOVLW  02
00FF2:  ADDWFC 03,F
00FF4:  MOVF   xA8,W
00FF6:  ADDWF  x9F,W
00FF8:  MOVWF  FE9
00FFA:  MOVLW  00
00FFC:  ADDWFC xA0,W
00FFE:  MOVWF  FEA
01000:  MOVFF  FEF,5AC
01004:  MOVFF  03,FEA
01008:  MOVFF  01,FE9
0100C:  MOVFF  5AC,FEF
01010:  INCF   xA8,F
01012:  BRA    0F74
....................    } 
....................  
....................    // Stuff data buffer 
....................    for (i = 0; i < size_buf; i++) 
01014:  CLRF   xA8
01016:  MOVF   xA4,W
01018:  SUBWF  xA8,W
0101A:  BC    10B6
....................    { 
....................       STUFF_BYTE(buf[i], dust_send_buffer_isr, j); 
0101C:  MOVF   xA8,W
0101E:  ADDWF  xA2,W
01020:  MOVWF  FE9
01022:  MOVLW  00
01024:  ADDWFC xA3,W
01026:  MOVWF  FEA
01028:  MOVF   FEF,W
0102A:  SUBLW  7D
0102C:  BZ    1040
0102E:  MOVF   xA8,W
01030:  ADDWF  xA2,W
01032:  MOVWF  FE9
01034:  MOVLW  00
01036:  ADDWFC xA3,W
01038:  MOVWF  FEA
0103A:  MOVF   FEF,W
0103C:  SUBLW  7E
0103E:  BNZ   1088
01040:  MOVF   xA9,W
01042:  INCF   xA9,F
01044:  CLRF   03
01046:  ADDLW  10
01048:  MOVWF  FE9
0104A:  MOVLW  02
0104C:  ADDWFC 03,W
0104E:  MOVWF  FEA
01050:  MOVLW  7D
01052:  MOVWF  FEF
01054:  MOVF   xA9,W
01056:  INCF   xA9,F
01058:  CLRF   03
0105A:  ADDLW  10
0105C:  MOVWF  01
0105E:  MOVLW  02
01060:  ADDWFC 03,F
01062:  MOVFF  01,5AA
01066:  MOVFF  03,5AB
0106A:  MOVF   xA8,W
0106C:  ADDWF  xA2,W
0106E:  MOVWF  FE9
01070:  MOVLW  00
01072:  ADDWFC xA3,W
01074:  MOVWF  FEA
01076:  MOVF   FEF,W
01078:  XORLW  20
0107A:  MOVWF  xAC
0107C:  MOVFF  03,FEA
01080:  MOVFF  01,FE9
01084:  MOVWF  FEF
01086:  BRA    10B2
01088:  MOVF   xA9,W
0108A:  INCF   xA9,F
0108C:  CLRF   03
0108E:  ADDLW  10
01090:  MOVWF  01
01092:  MOVLW  02
01094:  ADDWFC 03,F
01096:  MOVF   xA8,W
01098:  ADDWF  xA2,W
0109A:  MOVWF  FE9
0109C:  MOVLW  00
0109E:  ADDWFC xA3,W
010A0:  MOVWF  FEA
010A2:  MOVFF  FEF,5AC
010A6:  MOVFF  03,FEA
010AA:  MOVFF  01,FE9
010AE:  MOVFF  5AC,FEF
010B2:  INCF   xA8,F
010B4:  BRA    1016
....................    } 
....................  
....................    // Add least significiant byte 1st (RFC 1622). Do byte stuffing. 
....................    data8 = (uint8_t)(fcs16 & 0xff); 
010B6:  MOVFF  5A5,5A7
....................    STUFF_BYTE(data8, dust_send_buffer_isr, j); 
010BA:  MOVF   xA7,W
010BC:  SUBLW  7D
010BE:  BZ    10C6
010C0:  MOVF   xA7,W
010C2:  SUBLW  7E
010C4:  BNZ   10F2
010C6:  MOVF   xA9,W
010C8:  INCF   xA9,F
010CA:  CLRF   03
010CC:  ADDLW  10
010CE:  MOVWF  FE9
010D0:  MOVLW  02
010D2:  ADDWFC 03,W
010D4:  MOVWF  FEA
010D6:  MOVLW  7D
010D8:  MOVWF  FEF
010DA:  MOVF   xA9,W
010DC:  INCF   xA9,F
010DE:  CLRF   03
010E0:  ADDLW  10
010E2:  MOVWF  FE9
010E4:  MOVLW  02
010E6:  ADDWFC 03,W
010E8:  MOVWF  FEA
010EA:  MOVF   xA7,W
010EC:  XORLW  20
010EE:  MOVWF  FEF
010F0:  BRA    1106
010F2:  MOVF   xA9,W
010F4:  INCF   xA9,F
010F6:  CLRF   03
010F8:  ADDLW  10
010FA:  MOVWF  FE9
010FC:  MOVLW  02
010FE:  ADDWFC 03,W
01100:  MOVWF  FEA
01102:  MOVFF  5A7,FEF
....................  
....................    // Add most significiant byte 2nd (RFC 1622). Do byte stuffing. 
....................    data8 = (uint8_t)((fcs16>>8) & 0xff); 
01106:  MOVFF  5A6,5A7
....................    STUFF_BYTE(data8, dust_send_buffer_isr, j); 
0110A:  MOVF   xA7,W
0110C:  SUBLW  7D
0110E:  BZ    1116
01110:  MOVF   xA7,W
01112:  SUBLW  7E
01114:  BNZ   1142
01116:  MOVF   xA9,W
01118:  INCF   xA9,F
0111A:  CLRF   03
0111C:  ADDLW  10
0111E:  MOVWF  FE9
01120:  MOVLW  02
01122:  ADDWFC 03,W
01124:  MOVWF  FEA
01126:  MOVLW  7D
01128:  MOVWF  FEF
0112A:  MOVF   xA9,W
0112C:  INCF   xA9,F
0112E:  CLRF   03
01130:  ADDLW  10
01132:  MOVWF  FE9
01134:  MOVLW  02
01136:  ADDWFC 03,W
01138:  MOVWF  FEA
0113A:  MOVF   xA7,W
0113C:  XORLW  20
0113E:  MOVWF  FEF
01140:  BRA    1156
01142:  MOVF   xA9,W
01144:  INCF   xA9,F
01146:  CLRF   03
01148:  ADDLW  10
0114A:  MOVWF  FE9
0114C:  MOVLW  02
0114E:  ADDWFC 03,W
01150:  MOVWF  FEA
01152:  MOVFF  5A7,FEF
....................  
.................... // Step 4 
....................    // CHECK_BUF_SIZE(j+1); 
....................    dust_send_buffer_isr[j++]  = FLAG_SEQUENCE; 
01156:  MOVF   xA9,W
01158:  INCF   xA9,F
0115A:  CLRF   03
0115C:  ADDLW  10
0115E:  MOVWF  FE9
01160:  MOVLW  02
01162:  ADDWFC 03,W
01164:  MOVWF  FEA
01166:  MOVLW  7E
01168:  MOVWF  FEF
....................  
....................    // Set the number of bytes actually written 
....................    num_of_bytes_to_send_isr = j; 
0116A:  MOVFF  5A9,352
....................     
....................    return; 
0116E:  MOVLB  0
01170:  RETURN 0
.................... } 
....................  
.................... uint8_t dust_hdlc_pksend() 
.................... { 
.................... // This routine actually sends out the packet from the micro to the mote 
....................  
....................    uint8_t     n; 
....................    uint8_t     tmp_oscccon, tmp_t2con, tmp_pr2, tmp_t0con; 
....................     
....................    // save the crystal status for later restore 
....................    tmp_oscccon = OSCCON; 
*
06112:  MOVFF  FD3,564
....................    tmp_t2con = T2CON; 
06116:  MOVFF  FBA,565
....................    tmp_pr2 = PR2; 
0611A:  MOVFF  FBB,566
....................    tmp_t0con = T0CON; 
0611E:  MOVFF  FD5,567
06122:  CLRF   19
06124:  BTFSC  FF2.7
06126:  BSF    19.7
06128:  BCF    FF2.7
....................     
....................    // turn on high-speed crystal for UART communication 
....................    fosc_pri(); 
0612A:  CALL   1172
0612E:  BTFSC  19.7
06130:  BSF    FF2.7
....................  
....................    // prepare mote to recieve data 
....................    output_low(MOTE_RX_RTSn); 
06132:  BCF    F8C.5
....................    
....................    // turn on uart and wait for it to initalize 
....................    setup_uart(TRUE);                      
06134:  BSF    FAB.7
06136:  BSF    FAB.4
06138:  BSF    FAC.5
....................    setup_T0_int(T0_500US); 
0613A:  MOVLB  5
0613C:  SETF   x69
0613E:  MOVLW  FE
06140:  MOVWF  x68
06142:  MOVLB  0
06144:  CALL   3844
....................    while(!TMR0IF);    
06148:  BTFSS  FF2.2
0614A:  BRA    6148
....................  
....................    // loop for sending out bytes 
....................    for (n = 0; n < num_of_bytes_to_send; n++) 
0614C:  MOVLB  5
0614E:  CLRF   x63
06150:  MOVLB  3
06152:  MOVF   x51,W
06154:  MOVLB  5
06156:  SUBWF  x63,W
06158:  BC    61A4
....................    { 
....................       // setup send timeout for error handling 
....................       setup_T0_int(T0_10MS); 
0615A:  SETF   x69
0615C:  MOVLW  D9
0615E:  MOVWF  x68
06160:  MOVLB  0
06162:  CALL   3844
....................  
....................       // wait until a transmit is done or timeout error 
....................       while (!TRMT1 && !TMR0IF); 
06166:  BTFSC  FAC.1
06168:  BRA    616E
0616A:  BTFSS  FF2.2
0616C:  BRA    6166
....................        
....................       // if the timeout occured before the tranmit finished 
....................       if (TMR0IF) 
0616E:  BTFSS  FF2.2
06170:  BRA    6182
....................       { 
....................          // tell mote that it is no longer going to recieve data 
....................          output_high(MOTE_RX_RTSn); 
06172:  BSF    F8C.5
....................          // turn off uart 
....................          setup_uart(FALSE); 
06174:  BCF    FAB.7
06176:  BCF    FAB.4
06178:  BCF    FAC.5
....................          // return error code 
....................          return ERR_DUSTMSG_TIMEOUT; 
0617A:  MOVLW  FC
0617C:  MOVWF  01
0617E:  BRA    61C6
....................       } 
06180:  BRA    619E
....................       // if transmit buffer is open 
....................       else 
....................       { 
....................          // send byte to mote 
....................          putc(dust_send_buffer[n]); 
06182:  CLRF   03
06184:  MOVLB  5
06186:  MOVF   x63,W
06188:  ADDLW  40
0618A:  MOVWF  FE9
0618C:  MOVLW  01
0618E:  ADDWFC 03,W
06190:  MOVWF  FEA
06192:  MOVFF  FEF,568
06196:  MOVF   x68,W
06198:  MOVLB  0
0619A:  CALL   119E
....................       } 
0619E:  MOVLB  5
061A0:  INCF   x63,F
061A2:  BRA    6150
....................    } 
....................     
....................    // wait until the last transmit is done 
....................    while (!TRMT1); 
061A4:  BTFSS  FAC.1
061A6:  BRA    61A4
....................  
....................    // tell mote that it no longer is going to recieve data 
....................    output_high(MOTE_RX_RTSn); 
061A8:  BSF    F8C.5
....................     
....................    // turn off the uart 
....................    setup_uart(FALSE); 
061AA:  BCF    FAB.7
061AC:  BCF    FAB.4
061AE:  BCF    FAC.5
....................     
....................    //fosc_250k(); 
....................    
....................    // restore the crystal status 
....................    OSCCON = tmp_oscccon; 
061B0:  MOVFF  564,FD3
....................    T2CON = tmp_t2con; 
061B4:  MOVFF  565,FBA
....................    T0CON = tmp_t0con; 
061B8:  MOVFF  567,FD5
....................    PR2 = tmp_PR2; 
061BC:  MOVFF  566,FBB
....................     
....................    // return no error 
....................    return NO_ERR; 
061C0:  MOVLW  00
061C2:  MOVWF  01
061C4:  MOVLB  0
061C6:  RETURN 0
.................... } 
....................  
.................... uint8_t dust_hdlc_pksend_ISR() 
.................... { 
.................... // We're now running at 3.6864MHz at 115.2K baud 
.................... // This routine actually sends out the packet from the micro to the mote 
....................     
....................    uint8_t     n; 
....................    uint8_t     tmp_oscccon, tmp_t2con, tmp_pr2, tmp_t0con; 
....................     
....................    // save the crystal status for later restore 
....................    tmp_oscccon = OSCCON; 
*
011A6:  MOVFF  FD3,5A0
....................    tmp_t2con = T2CON; 
011AA:  MOVFF  FBA,5A1
....................    tmp_pr2 = PR2; 
011AE:  MOVFF  FBB,5A2
....................    tmp_t0con = T0CON; 
011B2:  MOVFF  FD5,5A3
....................     
....................    // turn on high-speed crystal for UART communication 
....................    fosc_pri(); 
011B6:  RCALL  1172
....................  
....................    // prepare mote to recieve data 
....................    output_low(MOTE_RX_RTSn); 
011B8:  BCF    F8C.5
....................    
....................    // turn on uart and wait for it to initalize 
....................    setup_uart(TRUE);                      
011BA:  BSF    FAB.7
011BC:  BSF    FAB.4
011BE:  BSF    FAC.5
....................    setup_T4_int(T4_500US); 
011C0:  MOVLW  01
011C2:  MOVLB  5
011C4:  MOVWF  xA4
011C6:  MOVLB  0
011C8:  CALL   0944
....................    while(!TMR4IF);    
011CC:  BTFSS  F7E.0
011CE:  BRA    11CC
....................  
....................    for (n = 0; n < num_of_bytes_to_send_isr; n++) 
011D0:  MOVLB  5
011D2:  CLRF   x9F
011D4:  MOVLB  3
011D6:  MOVF   x52,W
011D8:  MOVLB  5
011DA:  SUBWF  x9F,W
011DC:  BC    1224
....................    { 
....................       // setup send timeout for error handling 
....................       setup_T4_int(T4_10MS); 
011DE:  MOVLW  27
011E0:  MOVWF  xA4
011E2:  MOVLB  0
011E4:  CALL   0944
....................  
....................       // wait until a transmit is done or timeout error 
....................       while (!TRMT1 && !TMR4IF); 
011E8:  BTFSC  FAC.1
011EA:  BRA    11F0
011EC:  BTFSS  F7E.0
011EE:  BRA    11E8
....................        
....................       // if the timeout occured before the tranmit finished 
....................       if (TMR4IF) 
011F0:  BTFSS  F7E.0
011F2:  BRA    1204
....................       { 
....................          // tell mote that it is no longer going to recieve data 
....................          output_high(MOTE_RX_RTSn); 
011F4:  BSF    F8C.5
....................          // turn off uart 
....................          setup_uart(FALSE); 
011F6:  BCF    FAB.7
011F8:  BCF    FAB.4
011FA:  BCF    FAC.5
....................          // return error code 
....................          return ERR_DUSTMSG_TIMEOUT; 
011FC:  MOVLW  FC
011FE:  MOVWF  01
01200:  BRA    1246
....................       } 
01202:  BRA    121E
....................       // if transmit buffer is open 
....................       else 
....................       { 
....................          // send byte to mote 
....................          putc(dust_send_buffer_isr[n]); 
01204:  CLRF   03
01206:  MOVLB  5
01208:  MOVF   x9F,W
0120A:  ADDLW  10
0120C:  MOVWF  FE9
0120E:  MOVLW  02
01210:  ADDWFC 03,W
01212:  MOVWF  FEA
01214:  MOVFF  FEF,5A4
01218:  MOVF   xA4,W
0121A:  MOVLB  0
0121C:  RCALL  119E
....................       } 
0121E:  MOVLB  5
01220:  INCF   x9F,F
01222:  BRA    11D4
....................    } 
....................     
....................    // wait until the last transmit is done 
....................    while (!TRMT1); 
01224:  BTFSS  FAC.1
01226:  BRA    1224
....................  
....................    // tell mote that it no longer is going to recieve data 
....................    output_high(MOTE_RX_RTSn); 
01228:  BSF    F8C.5
....................     
....................    // turn off the uart 
....................    setup_uart(FALSE); 
0122A:  BCF    FAB.7
0122C:  BCF    FAB.4
0122E:  BCF    FAC.5
....................     
....................    // restore the crystal status 
....................    OSCCON = tmp_oscccon; 
01230:  MOVFF  5A0,FD3
....................    T2CON = tmp_t2con; 
01234:  MOVFF  5A1,FBA
....................    T0CON = tmp_t0con; 
01238:  MOVFF  5A3,FD5
....................    PR2 = tmp_PR2; 
0123C:  MOVFF  5A2,FBB
....................     
....................    // return no error 
....................    return NO_ERR; 
01240:  MOVLW  00
01242:  MOVWF  01
01244:  MOVLB  0
01246:  RETURN 0
.................... } 
....................  
.................... uint8_t dust_hdlc_pkdecode_ISR(uint8_t bytes_to_decode) 
*
00AE0:  MOVLB  5
00AE2:  CLRF   xA1
00AE4:  CLRF   xA0
00AE6:  CLRF   xA8
.................... { 
.................... /* 
....................  * Decode an HDLC packet from Mote. 
....................  * 
....................  * NOTE: The destination buffer must contain an extra 
....................  *       2 bytes to hold CRC data.  This requirement 
....................  *       simplifies the code and improves performance. 
....................  * 
....................  * 1. Remove delimiters 
....................  * 2. Unstuff *payload* and CRC bytes 
....................  * 3. Assemble CRC bytes 
....................  * 4. Check CRC 
....................  *  
....................  * Returns error messages or the number of byte decoded 
.................... */ 
....................  
.................... //  Note changes to routine as supplied by Dust: 
.................... //  The buffer and buffer size for the storage of received packet 
.................... //   are hardwired to be dust_recive_buffer[128] for the raw data 
.................... //   and bytes_from_mote.dust_rcvd for the unstuffed and stripped data 
....................  
....................    uint16_t    crc16       = 0; 
....................    uint8_t*    src_ptr; 
....................    uint8_t*    src_ptr_end; 
....................    uint8_t*    dest_ptr; 
....................  
....................    uint8_t      dust_bytes_rcvd = 0; 
....................  
.................... // 1 Check for start/end delimiters 
....................     if ((FLAG_SEQUENCE != dust_recive_buffer[0]) || 
....................         (FLAG_SEQUENCE != dust_recive_buffer[bytes_to_decode-1]))  
00AE8:  MOVLB  2
00AEA:  MOVF   x28,W
00AEC:  SUBLW  7E
00AEE:  BNZ   0B0A
00AF0:  MOVLW  01
00AF2:  MOVLB  5
00AF4:  SUBWF  x9F,W
00AF6:  CLRF   03
00AF8:  ADDLW  28
00AFA:  MOVWF  FE9
00AFC:  MOVLW  02
00AFE:  ADDWFC 03,W
00B00:  MOVWF  FEA
00B02:  MOVF   FEF,W
00B04:  SUBLW  7E
00B06:  BZ    0B12
00B08:  MOVLB  2
....................     { 
....................         // return framing error 
....................         return ERR_DUSTMSG_FRAMING_ERROR; 
00B0A:  MOVLW  FE
00B0C:  MOVWF  01
00B0E:  BRA    0C20
00B10:  MOVLB  5
....................     } 
....................  
.................... // 2 Unstuff *payload* and CRC data into destination buffer 
....................     dest_ptr    = bytes_from_mote.dust_rcvd; 
00B12:  CLRF   xA7
00B14:  MOVLW  D9
00B16:  MOVWF  xA6
....................     src_ptr_end = &dust_recive_buffer[bytes_to_decode-1]; 
00B18:  MOVLW  01
00B1A:  SUBWF  x9F,W
00B1C:  CLRF   03
00B1E:  ADDLW  28
00B20:  MOVWF  01
00B22:  MOVLW  02
00B24:  ADDWFC 03,F
00B26:  MOVFF  01,5A4
00B2A:  MOVFF  03,5A5
....................     for (src_ptr = &dust_recive_buffer[1]; src_ptr < src_ptr_end; src_ptr++) 
00B2E:  MOVLW  02
00B30:  MOVWF  xA3
00B32:  MOVLW  29
00B34:  MOVWF  xA2
00B36:  MOVF   xA3,W
00B38:  SUBWF  xA5,W
00B3A:  BNC   0BAC
00B3C:  BNZ   0B44
00B3E:  MOVF   xA4,W
00B40:  SUBWF  xA2,W
00B42:  BC    0BAC
....................     { 
....................         if (*src_ptr == CONTROL_ESCAPE) { 
00B44:  MOVFF  5A3,03
00B48:  MOVFF  5A2,FE9
00B4C:  MOVFF  5A3,FEA
00B50:  MOVF   FEF,W
00B52:  SUBLW  7D
00B54:  BNZ   0B82
....................            src_ptr++; /* skip to next byte, which contains the actual data */ 
00B56:  INCF   xA2,F
00B58:  BTFSC  FD8.2
00B5A:  INCF   xA3,F
....................             *dest_ptr++ = *src_ptr ^ XOR_BYTE; 
00B5C:  MOVFF  5A7,5AA
00B60:  MOVF   xA6,W
00B62:  INCF   xA6,F
00B64:  BTFSC  FD8.2
00B66:  INCF   xA7,F
00B68:  MOVWF  xA9
00B6A:  MOVFF  5A2,FE9
00B6E:  MOVFF  5A3,FEA
00B72:  MOVF   FEF,W
00B74:  XORLW  20
00B76:  MOVFF  5AA,FEA
00B7A:  MOVFF  5A9,FE9
00B7E:  MOVWF  FEF
....................         } 
00B80:  BRA    0BA4
....................         else 
....................         { 
....................             *dest_ptr++ = *src_ptr; 
00B82:  MOVFF  5A7,5AA
00B86:  MOVF   xA6,W
00B88:  INCF   xA6,F
00B8A:  BTFSC  FD8.2
00B8C:  INCF   xA7,F
00B8E:  MOVFF  5A2,FE9
00B92:  MOVFF  5A3,FEA
00B96:  MOVFF  FEF,5AB
00B9A:  MOVFF  5AA,FEA
00B9E:  MOVWF  FE9
00BA0:  MOVFF  5AB,FEF
....................         } 
00BA4:  INCF   xA2,F
00BA6:  BTFSC  FD8.2
00BA8:  INCF   xA3,F
00BAA:  BRA    0B36
....................     } 
....................  
.................... // 3 Assemble CRC 
....................     dest_ptr--;                 /* now points to MSBs */ 
00BAC:  MOVF   xA6,W
00BAE:  BTFSC  FD8.2
00BB0:  DECF   xA7,F
00BB2:  DECF   xA6,F
....................     crc16 = *dest_ptr-- << 8; 
00BB4:  MOVFF  5A7,03
00BB8:  MOVF   xA6,W
00BBA:  BTFSC  FD8.2
00BBC:  DECF   xA7,F
00BBE:  DECF   xA6,F
00BC0:  MOVWF  FE9
00BC2:  MOVFF  03,FEA
00BC6:  MOVFF  FEF,5A1
00BCA:  CLRF   xA0
....................     crc16 += *dest_ptr;         /* add LSBs */ 
00BCC:  MOVFF  5A6,FE9
00BD0:  MOVFF  5A7,FEA
00BD4:  MOVF   FEF,W
00BD6:  ADDWF  xA0,F
00BD8:  MOVLW  00
00BDA:  ADDWFC xA1,F
....................  
....................     /* Fill in the number of bytes actually written */ 
....................    dust_bytes_rcvd = (uint8_t)(dest_ptr - bytes_from_mote.dust_rcvd); 
00BDC:  MOVLW  D9
00BDE:  SUBWF  xA6,W
00BE0:  MOVWF  00
00BE2:  MOVLW  00
00BE4:  SUBWFB xA7,W
00BE6:  MOVFF  00,5A8
....................  
.................... // 4 Return error if CRCs don't match       
....................     if (fcs_calc_ISR(bytes_from_mote.dust_rcvd, dust_bytes_rcvd) != crc16 )  
00BEA:  CLRF   xAA
00BEC:  MOVLW  D9
00BEE:  MOVWF  xA9
00BF0:  CLRF   xAC
00BF2:  MOVFF  5A8,5AB
00BF6:  MOVLB  0
00BF8:  BRA    0A84
00BFA:  MOVFF  02,5AA
00BFE:  MOVFF  01,5A9
00C02:  MOVLB  5
00C04:  MOVF   xA0,W
00C06:  SUBWF  01,W
00C08:  BNZ   0C10
00C0A:  MOVF   xA1,W
00C0C:  SUBWF  xAA,W
00C0E:  BZ    0C1A
....................     { 
....................        // indicate bad CRC 
....................        return ERR_DUSTMSG_CRC;       
00C10:  MOVLW  FB
00C12:  MOVWF  01
00C14:  MOVLB  2
00C16:  BRA    0C20
00C18:  MOVLB  5
....................     } 
....................    return dust_bytes_rcvd; 
00C1A:  MOVFF  5A8,01
00C1E:  MOVLB  2
00C20:  MOVLB  0
00C22:  GOTO   127C (RETURN)
.................... } 
....................  
.................... uint16_t fcs_fcs16(uint16_t fcs, uint8_t data) 
.................... { 
....................    return (fcs >> 8) ^ fcstab[(fcs ^ data) & 0xff]; 
*
00EA2:  MOVFF  5AC,5AE
00EA6:  MOVLB  5
00EA8:  CLRF   xAF
00EAA:  MOVF   xAB,W
00EAC:  XORWF  xAD,W
00EAE:  MOVWF  xB0
00EB0:  CLRF   xB1
00EB2:  BCF    FD8.0
00EB4:  RLCF   xB0,W
00EB6:  MOVWF  02
00EB8:  RLCF   xB1,W
00EBA:  MOVWF  03
00EBC:  MOVF   02,W
00EBE:  MOVFF  03,FF7
00EC2:  MOVLB  0
00EC4:  CALL   01AC
00EC8:  TBLRD*+
00ECA:  MOVFF  FF5,03
00ECE:  MOVLB  5
00ED0:  XORWF  xAE,W
00ED2:  MOVWF  00
00ED4:  MOVF   03,W
00ED6:  XORWF  xAF,W
00ED8:  MOVWF  03
00EDA:  MOVFF  00,01
00EDE:  MOVWF  02
00EE0:  MOVLB  0
00EE2:  RETURN 0
.................... } 
....................  
.................... uint16_t fcs_fcs16_ISR(uint16_t fcs, uint8_t data) 
.................... { 
....................    return (fcs >> 8) ^ fcstab[(fcs ^ data) & 0xff]; 
*
00A40:  MOVFF  5B1,5B3
00A44:  MOVLB  5
00A46:  CLRF   xB4
00A48:  MOVF   xB0,W
00A4A:  XORWF  xB2,W
00A4C:  MOVWF  xB5
00A4E:  CLRF   xB6
00A50:  BCF    FD8.0
00A52:  RLCF   xB5,W
00A54:  MOVWF  02
00A56:  RLCF   xB6,W
00A58:  MOVWF  03
00A5A:  MOVF   02,W
00A5C:  MOVFF  03,FF7
00A60:  MOVLB  0
00A62:  CALL   01AC
00A66:  TBLRD*+
00A68:  MOVFF  FF5,03
00A6C:  MOVLB  5
00A6E:  XORWF  xB3,W
00A70:  MOVWF  00
00A72:  MOVF   03,W
00A74:  XORWF  xB4,W
00A76:  MOVWF  03
00A78:  MOVFF  00,01
00A7C:  MOVWF  02
00A7E:  MOVLB  0
00A80:  GOTO   0AB6 (RETURN)
.................... } 
....................  
.................... static uint16_t fcs_calc(uint8_t* p, uint16_t size) 
.................... { 
.................... /* fcs_calc() 
....................  * 
....................  * Calculate the 2 byte CRC-16 value given a buffer. 
....................  * 
....................  * Returns: 
....................  *      2 byte CRC-16 value 
....................  */ 
....................     uint16_t    fcs = 0; 
....................     fcs = FCS_INITIAL_FCS16; 
....................     while (size) { 
....................         fcs = fcs_fcs16(fcs, *p++); 
....................         size--; 
....................     } 
....................     return ~fcs; /* add 1's complement */ 
.................... } 
....................  
.................... static uint16_t fcs_calc_ISR(uint8_t* p, uint16_t size) 
00A84:  MOVLB  5
00A86:  CLRF   xAE
00A88:  CLRF   xAD
.................... { 
....................     uint16_t    fcs = 0; 
....................     fcs = FCS_INITIAL_FCS16; 
00A8A:  SETF   xAE
00A8C:  SETF   xAD
....................     while (size) { 
00A8E:  MOVF   xAB,W
00A90:  IORWF  xAC,W
00A92:  BZ    0ACA
....................         fcs = fcs_fcs16_ISR(fcs, *p++); 
00A94:  MOVFF  5AA,03
00A98:  MOVF   xA9,W
00A9A:  INCF   xA9,F
00A9C:  BTFSC  FD8.2
00A9E:  INCF   xAA,F
00AA0:  MOVWF  FE9
00AA2:  MOVFF  03,FEA
00AA6:  MOVFF  FEF,5B2
00AAA:  MOVFF  5AE,5B1
00AAE:  MOVFF  5AD,5B0
00AB2:  MOVLB  0
00AB4:  BRA    0A40
00AB6:  MOVFF  02,5AE
00ABA:  MOVFF  01,5AD
....................         size--; 
00ABE:  MOVLB  5
00AC0:  MOVF   xAB,W
00AC2:  BTFSC  FD8.2
00AC4:  DECF   xAC,F
00AC6:  DECF   xAB,F
00AC8:  BRA    0A8E
....................     } 
....................     return ~fcs; /* add 1's complement */ 
00ACA:  MOVFF  5AE,03
00ACE:  COMF   03,F
00AD0:  MOVF   xAD,W
00AD2:  XORLW  FF
00AD4:  MOVWF  01
00AD6:  MOVFF  03,02
00ADA:  MOVLB  0
00ADC:  GOTO   0BFA (RETURN)
.................... } 
....................  
.................... uint8_t deal_with_packet(void) 
.................... { 
....................    uint8_t  command_id_received; 
....................    uint16_t mgr_msgSEQ; 
....................    uint32_t temp_uint32; 
....................    // clear out for use as NACK bitfield each time 
....................    temp_uint32 = 0; 
*
0712E:  MOVLB  5
07130:  CLRF   x51
07132:  CLRF   x50
07134:  CLRF   x4F
07136:  CLRF   x4E
....................    static struct CommandQueueItem command_queue_item; 
....................    static struct SprinklerZoneSettingsItem sprinkler_zone_settings_item; 
....................    &command_queue_item.sprinkler_settings = &sprinkler_zone_settings_item; 
07138:  MOVLW  05
0713A:  MOVWF  x31
0713C:  MOVLW  34
0713E:  MOVWF  x30
....................     
....................    // This Dust-recommended prepend for messages (both from manager to mote and 
....................    //    from mote to manager) ensures that we do not conflict with any future 
....................    //    Hart-related aspects.  
....................     
....................    // This prepend is in the same spot for messages going either direction 
....................    // Return with an error if any char is incorrect 
....................    if ((payload_buff[0] != 0x00) || (payload_buff[1] != 0x00) ||              \ 
....................       (payload_buff[2] != 0xFC) || (payload_buff[3] != 0x12)) 
07140:  MOVLB  2
07142:  MOVF   xF3,F
07144:  BNZ   7156
07146:  MOVF   xF4,F
07148:  BNZ   7156
0714A:  MOVF   xF5,W
0714C:  SUBLW  FC
0714E:  BNZ   7156
07150:  MOVF   xF6,W
07152:  SUBLW  12
07154:  BZ    715E
....................    {    
....................       return ERR_BAD_PAYLOAD; 
07156:  MOVLW  F9
07158:  MOVWF  01
0715A:  GOTO   7FEC
....................    } 
....................     
....................    // The mgr_msgSEQ, a sequence number used by the manager software to identify 
....................    //    messages which are ACK'd or NACK'd always follows the prepend. 
....................    mgr_msgSEQ = make16(payload_buff[5],payload_buff[4]); 
0715E:  MOVFF  2F8,54D
07162:  MOVFF  2F7,54C
....................     
....................    // Then comes the msg_rcvd identifier which is the packet's intent, 
....................    //    such as 'give me a full report,' or 'do a warm start.' 
....................    // We leave payload_buff[6] alone so the command ID is identical for the  
....................    //    response message 
....................    command_id_received = payload_buff[6]; 
07166:  MOVFF  2F9,54B
....................   
....................    // Switch for sorting through different messages recieved 
....................    switch (command_id_received) 
0716A:  MOVLW  01
0716C:  MOVLB  5
0716E:  SUBWF  x4B,W
07170:  ADDLW  BA
07172:  BTFSC  FD8.0
07174:  GOTO   7FEA
07178:  ADDLW  46
0717A:  MOVLB  0
0717C:  GOTO   7FF2
....................    { 
....................    // Manager ACKs or NACKs unsolicited messages from micro to manager such as: 
....................    //    a. Message at startup 
....................    //    b. ERROR messages 
....................    //    c. Valve calibrate response 
....................    //    d. Bulk data dump 
....................     
.................... //////// Manager ACKs/NACKs//////// 
....................       // Manager ACKs 
....................       case MSG_MGR_ACK: 
....................          // clear off unsolicited message of proper msgSEQ 
....................          REMOVE_MESSAGE_QUEUE_MACRO(mgr_msgSEQ); 
07180:  BCF    F7A.1
07182:  MOVFF  54D,553
07186:  MOVFF  54C,552
0718A:  GOTO   5C52
0718E:  BSF    F7A.1
....................          break; 
07190:  MOVLB  5
07192:  GOTO   7FEA
....................                                                         
....................       // Manager NACKs    
....................       case MSG_MGR_NACK: 
....................          // Do nothing. Messages will get resent as if it never got acked by 
....................          //    manager 
....................          break;    
07196:  MOVLB  5
07198:  GOTO   7FEA
....................        
.................... //////// Report Requests//////// 
....................       // Manager requests a full report 
....................       case MSG_MGR_FULL_REPORT: 
....................          send_full_report(command_id_received, mgr_msgSEQ);   
0719C:  MOVFF  54B,552
071A0:  MOVFF  54D,554
071A4:  MOVFF  54C,553
071A8:  CALL   6222
....................          break; 
071AC:  MOVLB  5
071AE:  GOTO   7FEA
....................       // Manager requests a health report 
....................       case MSG_MGR_HEALTH_REPORT: 
....................          send_health_report(command_id_received, mgr_msgSEQ); 
071B2:  MOVFF  54B,552
071B6:  MOVFF  54D,554
071BA:  MOVFF  54C,553
071BE:  GOTO   653C
....................          break; 
071C2:  MOVLB  5
071C4:  GOTO   7FEA
....................       // Manager requests a valve report 
....................       case MSG_MGR_VALVE_REPORT: 
....................          send_valve_report(command_id_received, mgr_msgSEQ); 
071C8:  MOVFF  54B,552
071CC:  MOVFF  54D,554
071D0:  MOVFF  54C,553
071D4:  CALL   65C2
....................          break; 
071D8:  MOVLB  5
071DA:  GOTO   7FEA
....................        
.................... //////// Restart/Shutdown Commands////////                                            
....................       // Manager requests a warm restart (micro reboots) 
....................       case MSG_MGR_WARM_RESTART: 
....................          send_ack(command_id_received, mgr_msgSEQ); 
071DE:  MOVFF  54B,552
071E2:  MOVFF  54D,554
071E6:  MOVFF  54C,553
071EA:  CALL   66F6
....................          // set the shutdown cause 
....................          global_shutdown_cause = WARM_RESTART_REQUEST; 
071EE:  MOVLW  09
071F0:  MOVWF  4D
....................          // save the shutdown/restart reason in EEPROM 
....................          write_ee1(EE_RESTART_CAUSE, global_shutdown_cause); 
071F2:  MOVLB  5
071F4:  CLRF   x55
071F6:  MOVLW  02
071F8:  MOVWF  x54
071FA:  MOVFF  4D,556
071FE:  MOVLB  0
07200:  CALL   33A6
....................          // restart micro                                                         
....................          PUSH_TIME_QUEUE_MACRO(global_rtc_time + 5, CPU_RESET);  
07204:  BCF    F7A.1
07206:  MOVLW  05
07208:  ADDWF  x85,W
0720A:  MOVLB  5
0720C:  MOVWF  x52
0720E:  MOVLW  00
07210:  MOVLB  0
07212:  ADDWFC x86,W
07214:  MOVLB  5
07216:  MOVWF  x53
07218:  MOVLW  00
0721A:  MOVLB  0
0721C:  ADDWFC x87,W
0721E:  MOVLB  5
07220:  MOVWF  x54
07222:  MOVLW  00
07224:  MOVLB  0
07226:  ADDWFC x88,W
07228:  MOVLB  5
0722A:  MOVWF  x55
0722C:  MOVWF  x59
0722E:  MOVFF  554,558
07232:  MOVFF  553,557
07236:  MOVFF  552,556
0723A:  MOVLW  F0
0723C:  MOVWF  x5A
0723E:  MOVLB  0
07240:  CALL   4422
07244:  BSF    F7A.1
....................          break;  
07246:  MOVLB  5
07248:  GOTO   7FEA
....................       // Manager requests a cold restart (mote and micro reboot)   
....................       case MSG_MGR_COLD_RESTART: 
....................          send_ack(command_id_received, mgr_msgSEQ); 
0724C:  MOVFF  54B,552
07250:  MOVFF  54D,554
07254:  MOVFF  54C,553
07258:  CALL   66F6
....................          // set the shutdown cause 
....................          global_shutdown_cause = COLD_RESTART_REQUEST; 
0725C:  MOVLW  0A
0725E:  MOVWF  4D
....................          // save the shutdown/restart reason in EEPROM 
....................          write_ee1(EE_RESTART_CAUSE, global_shutdown_cause); 
07260:  MOVLB  5
07262:  CLRF   x55
07264:  MOVLW  02
07266:  MOVWF  x54
07268:  MOVFF  4D,556
0726C:  MOVLB  0
0726E:  CALL   33A6
....................          // restart micro 
....................          PUSH_TIME_QUEUE_MACRO(global_rtc_time + 5, CPU_RESET); 
07272:  BCF    F7A.1
07274:  MOVLW  05
07276:  ADDWF  x85,W
07278:  MOVLB  5
0727A:  MOVWF  x52
0727C:  MOVLW  00
0727E:  MOVLB  0
07280:  ADDWFC x86,W
07282:  MOVLB  5
07284:  MOVWF  x53
07286:  MOVLW  00
07288:  MOVLB  0
0728A:  ADDWFC x87,W
0728C:  MOVLB  5
0728E:  MOVWF  x54
07290:  MOVLW  00
07292:  MOVLB  0
07294:  ADDWFC x88,W
07296:  MOVLB  5
07298:  MOVWF  x55
0729A:  MOVWF  x59
0729C:  MOVFF  554,558
072A0:  MOVFF  553,557
072A4:  MOVFF  552,556
072A8:  MOVLW  F0
072AA:  MOVWF  x5A
072AC:  MOVLB  0
072AE:  CALL   4422
072B2:  BSF    F7A.1
....................          break; 
072B4:  MOVLB  5
072B6:  GOTO   7FEA
....................       // Manager requests a rejoin (restart mote and rejoin)  
....................       case MSG_MGR_FORCE_REJOIN: 
....................          send_ack(command_id_received, mgr_msgSEQ); 
072BA:  MOVFF  54B,552
072BE:  MOVFF  54D,554
072C2:  MOVFF  54C,553
072C6:  CALL   66F6
....................          // schedule rejoin/restart mote 
....................          PUSH_TIME_QUEUE_MACRO(global_rtc_time + 5, RESET_MOTE); 
072CA:  BCF    F7A.1
072CC:  MOVLW  05
072CE:  ADDWF  x85,W
072D0:  MOVLB  5
072D2:  MOVWF  x52
072D4:  MOVLW  00
072D6:  MOVLB  0
072D8:  ADDWFC x86,W
072DA:  MOVLB  5
072DC:  MOVWF  x53
072DE:  MOVLW  00
072E0:  MOVLB  0
072E2:  ADDWFC x87,W
072E4:  MOVLB  5
072E6:  MOVWF  x54
072E8:  MOVLW  00
072EA:  MOVLB  0
072EC:  ADDWFC x88,W
072EE:  MOVLB  5
072F0:  MOVWF  x55
072F2:  MOVWF  x59
072F4:  MOVFF  554,558
072F8:  MOVFF  553,557
072FC:  MOVFF  552,556
07300:  MOVLW  11
07302:  MOVWF  x5A
07304:  MOVLB  0
07306:  CALL   4422
0730A:  BSF    F7A.1
....................          break; 
0730C:  MOVLB  5
0730E:  GOTO   7FEA
....................       // Manager requests a shutdown (deep sleep, move valve to specified position 
....................       //    and at a certain time) 
....................       case MSG_MGR_SHUTDOWN: 
....................          send_ack(command_id_received, mgr_msgSEQ); 
07312:  MOVFF  54B,552
07316:  MOVFF  54D,554
0731A:  MOVFF  54C,553
0731E:  CALL   66F6
....................          // set valve posisition and move valve 
....................          global_valve_position_set_value = make16(payload_buff[12], payload_buff[11]); 
07322:  MOVFF  2FF,C4
07326:  MOVFF  2FE,C3
....................          PUSH_PRIORITY_QUEUE_MACRO(MOVE_VALVE); 
0732A:  BCF    F7A.1
0732C:  MOVLW  40
0732E:  MOVLB  5
07330:  MOVWF  x52
07332:  MOVLB  0
07334:  CALL   46CA
07338:  BSF    F7A.1
....................          // set the shutdown cause 
....................          global_shutdown_cause = MANAGER_SHUTDOWN_REQUEST; 
0733A:  MOVLW  0B
0733C:  MOVWF  4D
....................          // figure out the shutdown time in rtc time (given in utc time or 0 for NOW) 
....................          // temp_uint32 is now the utc shutdown time 
....................          temp_uint32 = make32(payload_buff[10], payload_buff[9],payload_buff[8], payload_buff[7]); 
0733E:  MOVFF  2FD,551
07342:  MOVFF  2FC,550
07346:  MOVFF  2FB,54F
0734A:  MOVFF  2FA,54E
....................           
....................          // if shutdown isn't now (time = 0), utc_shutdown_time + rtc_time - utc_time = rtc_shutdown_time 
....................          if (temp_uint32 != 0) 
0734E:  MOVLB  5
07350:  MOVF   x4E,F
07352:  BNZ   7360
07354:  MOVF   x4F,F
07356:  BNZ   7360
07358:  MOVF   x50,F
0735A:  BNZ   7360
0735C:  MOVF   x51,F
0735E:  BZ    73CE
....................          { 
....................             temp_uint32 += global_rtc_time - global_utc_time; 
07360:  MOVLB  0
07362:  MOVF   x89,W
07364:  SUBWF  x85,W
07366:  MOVWF  00
07368:  MOVF   x8A,W
0736A:  SUBWFB x86,W
0736C:  MOVWF  01
0736E:  MOVF   x8B,W
07370:  SUBWFB x87,W
07372:  MOVWF  02
07374:  MOVF   x8C,W
07376:  SUBWFB x88,W
07378:  MOVWF  03
0737A:  MOVF   00,W
0737C:  MOVLB  5
0737E:  ADDWF  x4E,F
07380:  MOVF   01,W
07382:  ADDWFC x4F,F
07384:  MOVF   02,W
07386:  ADDWFC x50,F
07388:  MOVF   03,W
0738A:  ADDWFC x51,F
....................             // in some rare cases, this simple math might give a huge number (more than an hour past current rtc 
....................             //    time.) In that case, time should be now. 
....................             // The rare case would be when there is latency in the network more than the  
....................             //    elapsed rtc time. 
....................             if (temp_uint32 > (global_rtc_time + 3600)) 
0738C:  MOVLW  10
0738E:  MOVLB  0
07390:  ADDWF  x85,W
07392:  MOVWF  00
07394:  MOVLW  0E
07396:  ADDWFC x86,W
07398:  MOVWF  01
0739A:  MOVLW  00
0739C:  ADDWFC x87,W
0739E:  MOVWF  02
073A0:  MOVLW  00
073A2:  ADDWFC x88,W
073A4:  MOVWF  03
073A6:  MOVLB  5
073A8:  SUBWF  x51,W
073AA:  BNC   73CC
073AC:  BNZ   73C4
073AE:  MOVF   02,W
073B0:  SUBWF  x50,W
073B2:  BNC   73CC
073B4:  BNZ   73C4
073B6:  MOVF   01,W
073B8:  SUBWF  x4F,W
073BA:  BNC   73CC
073BC:  BNZ   73C4
073BE:  MOVF   x4E,W
073C0:  SUBWF  00,W
073C2:  BC    73CC
....................             {  
....................                temp_uint32 = 0; 
073C4:  CLRF   x51
073C6:  CLRF   x50
073C8:  CLRF   x4F
073CA:  CLRF   x4E
....................             } 
....................          } 
073CC:  BRA    73DE
....................          // shutdown time is now (sent time is 0) 
....................          else 
....................          { 
....................             temp_uint32 = global_rtc_time; 
073CE:  MOVFF  88,551
073D2:  MOVFF  87,550
073D6:  MOVFF  86,54F
073DA:  MOVFF  85,54E
....................          }                                   
....................          // schedule the shutdown 
....................          PUSH_TIME_QUEUE_MACRO(temp_uint32, SHUTDOWN_SYSTEM); 
073DE:  BCF    F7A.1
073E0:  MOVFF  551,559
073E4:  MOVFF  550,558
073E8:  MOVFF  54F,557
073EC:  MOVFF  54E,556
073F0:  MOVLW  F1
073F2:  MOVWF  x5A
073F4:  MOVLB  0
073F6:  CALL   4422
073FA:  BSF    F7A.1
....................          break; 
073FC:  MOVLB  5
073FE:  GOTO   7FEA
....................  
.................... //////// Erraneous Commands//////// 
....................       case MSG_MGR_UPDATE_SP_NUM: 
....................          // update sprinkler number 
....................          // check if number is in a valid range, NACK if no good. 
....................          global_sprinkler_num = make16(payload_buff[8], payload_buff[7]); 
07402:  MOVFF  2FB,96
07406:  MOVFF  2FA,95
....................          // write sprinkler number 
....................          write_ee2(EE_SPRINKLER_NUM, global_sprinkler_num); 
0740A:  MOVLB  5
0740C:  CLRF   x57
0740E:  CLRF   x56
07410:  MOVFF  96,559
07414:  MOVFF  95,558
07418:  MOVLB  0
0741A:  CALL   330A
....................          send_update_sp_num_response(command_id_received, mgr_msgSEQ); 
0741E:  MOVFF  54B,552
07422:  MOVFF  54D,554
07426:  MOVFF  54C,553
0742A:  GOTO   671C
....................          break; 
0742E:  MOVLB  5
07430:  GOTO   7FEA
....................       case MSG_MGR_CAL_VALVE: 
....................          send_ack(command_id_received, mgr_msgSEQ);             
07434:  MOVFF  54B,552
07438:  MOVFF  54D,554
0743C:  MOVFF  54C,553
07440:  CALL   66F6
....................          // schedule calibrate valve 
....................          PUSH_PRIORITY_QUEUE_MACRO(CALIBRATE_VALVE_1);    
07444:  BCF    F7A.1
07446:  MOVLW  31
07448:  MOVLB  5
0744A:  MOVWF  x52
0744C:  MOVLB  0
0744E:  CALL   46CA
07452:  BSF    F7A.1
....................          break; 
07454:  MOVLB  5
07456:  GOTO   7FEA
....................       case MSG_MGR_CAL_FSR:          
....................          if (read_system_state() != SYSTEM_RUN)    
0745A:  CALL   1F02
0745E:  MOVF   01,W
07460:  SUBLW  02
07462:  BZ    746A
....................          {        
....................             temp_uint32 |= NACK_BITFIELD_INCOMPATIBLE_STATE; 
07464:  MOVLB  5
07466:  BSF    x4E.5
07468:  MOVLB  0
....................          }                                                     
....................          if (global_valve_position == VLV_POSITION_UNKNOWN) 
0746A:  INCFSZ xC1,W
0746C:  BRA    7478
0746E:  INCFSZ xC2,W
07470:  BRA    7478
....................          { 
....................             temp_uint32 |= NACK_BITFIELD_VLV_POSITION_UNKNOWN;     
07472:  MOVLB  5
07474:  BSF    x4E.0
07476:  MOVLB  0
....................          } 
....................          if (!is_valve_position_valid(make16(payload_buff[8], payload_buff[7])))    
07478:  MOVFF  2FB,553
0747C:  MOVFF  2FA,552
07480:  MOVFF  2FB,555
07484:  MOVFF  2FA,554
07488:  CALL   6750
0748C:  MOVF   01,F
0748E:  BNZ   7496
....................          {                                                                       
....................             temp_uint32 |= NACK_BITFIELD_INVALID_VLV_SETTING;                     
07490:  MOVLB  5
07492:  BSF    x4E.1
07494:  MOVLB  0
....................          } 
....................          // if the NACK bitfield contains anything, send the nack instead of proceeding 
....................          if (temp_uint32 != 0)          
07496:  MOVLB  5
07498:  MOVF   x4E,F
0749A:  BNZ   74A8
0749C:  MOVF   x4F,F
0749E:  BNZ   74A8
074A0:  MOVF   x50,F
074A2:  BNZ   74A8
074A4:  MOVF   x51,F
074A6:  BZ    74CE
....................          { 
....................             send_nack(command_id_received, mgr_msgSEQ, temp_uint32); 
074A8:  MOVFF  54B,552
074AC:  MOVFF  54D,554
074B0:  MOVFF  54C,553
074B4:  MOVFF  551,558
074B8:  MOVFF  550,557
074BC:  MOVFF  54F,556
074C0:  MOVFF  54E,555
074C4:  MOVLB  0
074C6:  CALL   6772
....................          }                                             
074CA:  BRA    74F0
074CC:  MOVLB  5
....................          else                                              
....................          {                  
....................             send_ack(command_id_received, mgr_msgSEQ); 
074CE:  MOVFF  54B,552
074D2:  MOVFF  54D,554
074D6:  MOVFF  54C,553
074DA:  MOVLB  0
074DC:  CALL   66F6
....................             // schedule calibrate valve                    
....................             PUSH_PRIORITY_QUEUE_MACRO(CALIBRATE_FSR_1);   
074E0:  BCF    F7A.1
074E2:  MOVLW  37
074E4:  MOVLB  5
074E6:  MOVWF  x52
074E8:  MOVLB  0
074EA:  CALL   46CA
074EE:  BSF    F7A.1
....................          } 
....................          break; 
074F0:  MOVLB  5
074F2:  GOTO   7FEA
....................           
....................       case MSG_MGR_AQUIRE_GPS:  
....................          send_ack(command_id_received, mgr_msgSEQ); 
074F6:  MOVFF  54B,552
074FA:  MOVFF  54D,554
074FE:  MOVFF  54C,553
07502:  CALL   66F6
....................          // start gps point aquisition                         
....................          PUSH_PRIORITY_QUEUE_MACRO(START_GPS_AQUISITION);               
07506:  BCF    F7A.1
07508:  MOVLW  50
0750A:  MOVLB  5
0750C:  MOVWF  x52
0750E:  MOVLB  0
07510:  CALL   46CA
07514:  BSF    F7A.1
....................          break; 
07516:  MOVLB  5
07518:  GOTO   7FEA
....................                                                                           
....................       case MSG_MGR_UPDATE_EEPROM:                                
....................          LCD_clear();                                                 
0751C:  CALL   5C18
....................          LCD_place_uint16(make16(payload_buff[8], payload_buff[7]),0,0,5);   
07520:  MOVFF  2FB,553
07524:  MOVFF  2FA,552
07528:  MOVFF  2FB,564
0752C:  MOVFF  2FA,563
07530:  MOVLB  5
07532:  CLRF   x65
07534:  CLRF   x66
07536:  MOVLW  05
07538:  MOVWF  x67
0753A:  MOVLB  0
0753C:  CALL   6838
....................          LCD_place_uint8(payload_buff[9],0,7,3);          
07540:  MOVFF  2FC,564
07544:  MOVLB  5
07546:  CLRF   x65
07548:  MOVLW  07
0754A:  MOVWF  x66
0754C:  MOVLW  03
0754E:  MOVWF  x67
07550:  MOVLB  0
07552:  CALL   6912
....................          LCD_place_uint32(make32(payload_buff[13],payload_buff[12],payload_buff[11],payload_buff[10]),1,0,8); 
07556:  MOVFF  300,555
0755A:  MOVFF  2FF,554
0755E:  MOVFF  2FE,553
07562:  MOVFF  2FD,552
07566:  MOVFF  300,559
0756A:  MOVFF  2FF,558
0756E:  MOVFF  2FE,557
07572:  MOVFF  2FD,556
07576:  MOVLW  01
07578:  MOVLB  5
0757A:  MOVWF  x5A
0757C:  CLRF   x5B
0757E:  MOVLW  08
07580:  MOVWF  x5C
07582:  MOVLB  0
07584:  CALL   69A6
....................          global_skip_lcd_update_count = 3;         
07588:  MOVLW  03
0758A:  MOVWF  x83
....................                                                                                                  
....................          // if eeprom location is outside of the valid range                                      
....................          //    (not in between start and end location (taking into account the number of bytes))    
....................          if ((make16(payload_buff[8], payload_buff[7]) < EE_START_LOCATION) ||                        \                      
....................             ((make16(payload_buff[8], payload_buff[7]) + payload_buff[9] - 1) > EE_END_LOCATION) ||   \                                                
....................             // also check if number of bytes != 1, 2, or 4 
....................             (!((payload_buff[9] == 1) || (payload_buff[9] == 2) || (payload_buff[9] == 4))))        
0758C:  MOVFF  2FB,553
07590:  MOVFF  2FA,552
07594:  MOVLB  2
07596:  MOVF   xFC,W
07598:  MOVLB  5
0759A:  ADDWF  x52,F
0759C:  MOVLW  00
0759E:  ADDWFC x53,F
075A0:  MOVLW  01
075A2:  SUBWF  x52,F
075A4:  MOVLW  00
075A6:  SUBWFB x53,F
075A8:  BNZ   75C6
075AA:  MOVF   x52,W
075AC:  SUBLW  2F
075AE:  BNC   75C6
075B0:  MOVLB  2
075B2:  DECFSZ xFC,W
075B4:  BRA    75B8
075B6:  BRA    75E6
075B8:  MOVF   xFC,W
075BA:  SUBLW  02
075BC:  BZ    75E6
075BE:  MOVF   xFC,W
075C0:  SUBLW  04
075C2:  BZ    75E6
075C4:  MOVLB  5
....................          {                                                                                         
....................             send_nack(command_id_received, mgr_msgSEQ, NACK_BITFIELD_INVALID_EEPROM_SETTINGS);     
075C6:  MOVFF  54B,552
075CA:  MOVFF  54D,554
075CE:  MOVFF  54C,553
075D2:  CLRF   x58
075D4:  CLRF   x57
075D6:  MOVLW  01
075D8:  MOVWF  x56
075DA:  CLRF   x55
075DC:  MOVLB  0
075DE:  CALL   6772
....................          }                                                                                            
075E2:  BRA    7688
075E4:  MOVLB  2
....................          // valid location and number of bytes                      
....................          else                                    
....................          {                                                                                                 
....................             if (payload_buff[9] == 1) 
075E6:  DECFSZ xFC,W
075E8:  BRA    7608
....................             { 
....................                write_ee1(make16(payload_buff[8], payload_buff[7]),payload_buff[10]); 
075EA:  MOVFF  2FB,553
075EE:  MOVFF  2FA,552
075F2:  MOVFF  2FB,555
075F6:  MOVFF  2FA,554
075FA:  MOVFF  2FD,556
075FE:  MOVLB  0
07600:  CALL   33A6
....................             } 
07604:  BRA    7674
07606:  MOVLB  2
....................             else if (payload_buff[9] == 2)                
07608:  MOVF   xFC,W
0760A:  SUBLW  02
0760C:  BNZ   7638
....................             {                                           
....................                write_ee2(make16(payload_buff[8], payload_buff[7]),make16(payload_buff[11],payload_buff[10])); 
0760E:  MOVFF  2FB,553
07612:  MOVFF  2FA,552
07616:  MOVFF  2FE,555
0761A:  MOVFF  2FD,554
0761E:  MOVFF  2FB,557
07622:  MOVFF  2FA,556
07626:  MOVFF  2FE,559
0762A:  MOVFF  2FD,558
0762E:  MOVLB  0
07630:  CALL   330A
....................             } 
07634:  BRA    7674
07636:  MOVLB  2
....................             else if (payload_buff[9] == 4)                                            
07638:  MOVF   xFC,W
0763A:  SUBLW  04
0763C:  BNZ   7676
....................             { 
....................                write_ee4(make16(payload_buff[8], payload_buff[7]),make32(payload_buff[13],payload_buff[12],payload_buff[11],payload_buff[10])); 
0763E:  MOVFF  2FB,553
07642:  MOVFF  2FA,552
07646:  MOVFF  300,557
0764A:  MOVFF  2FF,556
0764E:  MOVFF  2FE,555
07652:  MOVFF  2FD,554
07656:  MOVFF  2FB,559
0765A:  MOVFF  2FA,558
0765E:  MOVFF  300,55D
07662:  MOVFF  2FF,55C
07666:  MOVFF  2FE,55B
0766A:  MOVFF  2FD,55A
0766E:  MOVLB  0
07670:  CALL   6AC6
07674:  MOVLB  2
....................             } 
....................             send_ack(command_id_received, mgr_msgSEQ); 
07676:  MOVFF  54B,552
0767A:  MOVFF  54D,554
0767E:  MOVFF  54C,553
07682:  MOVLB  0
07684:  CALL   66F6
....................          } 
....................          break;  
07688:  MOVLB  5
0768A:  GOTO   7FEA
....................        
....................       case MSG_MGR_READ_EEPROM:                                                                              
....................          // if eeprom location is outside of the valid range                                      
....................          //    (not in between start and end location (taking into account the number of bytes))    
....................          if ((make16(payload_buff[8], payload_buff[7]) < EE_START_LOCATION) ||                        \                      
....................             ((make16(payload_buff[8], payload_buff[7]) + payload_buff[9] - 1) > EE_END_LOCATION) ||   \                                                
....................             // also check if number of bytes != 1, 2, or 4 
....................             (!((payload_buff[9] == 1) || (payload_buff[9] == 2) || (payload_buff[9] == 4))))        
0768E:  MOVFF  2FB,553
07692:  MOVFF  2FA,552
07696:  MOVLB  2
07698:  MOVF   xFC,W
0769A:  MOVLB  5
0769C:  ADDWF  x52,F
0769E:  MOVLW  00
076A0:  ADDWFC x53,F
076A2:  MOVLW  01
076A4:  SUBWF  x52,F
076A6:  MOVLW  00
076A8:  SUBWFB x53,F
076AA:  BNZ   76C8
076AC:  MOVF   x52,W
076AE:  SUBLW  2F
076B0:  BNC   76C8
076B2:  MOVLB  2
076B4:  DECFSZ xFC,W
076B6:  BRA    76BA
076B8:  BRA    76E8
076BA:  MOVF   xFC,W
076BC:  SUBLW  02
076BE:  BZ    76E8
076C0:  MOVF   xFC,W
076C2:  SUBLW  04
076C4:  BZ    76E8
076C6:  MOVLB  5
....................          {                                                                                         
....................             send_nack(command_id_received, mgr_msgSEQ, NACK_BITFIELD_INVALID_EEPROM_SETTINGS);     
076C8:  MOVFF  54B,552
076CC:  MOVFF  54D,554
076D0:  MOVFF  54C,553
076D4:  CLRF   x58
076D6:  CLRF   x57
076D8:  MOVLW  01
076DA:  MOVWF  x56
076DC:  CLRF   x55
076DE:  MOVLB  0
076E0:  CALL   6772
....................          }                                                                                            
076E4:  BRA    77A0
076E6:  MOVLB  2
....................          // valid location and number of bytes                      
....................          else                                    
....................          {                                                                                                 
....................             if (payload_buff[9] == 1) 
076E8:  DECFSZ xFC,W
076EA:  BRA    7712
....................             {                                 
....................                temp_uint32 = read_ee1(make16(payload_buff[8], payload_buff[7])); 
076EC:  MOVFF  2FB,553
076F0:  MOVFF  2FA,552
076F4:  MOVFF  2FB,555
076F8:  MOVFF  2FA,554
076FC:  MOVLB  0
076FE:  CALL   3384
07702:  MOVLB  5
07704:  CLRF   x51
07706:  CLRF   x50
07708:  CLRF   x4F
0770A:  MOVFF  01,54E
....................             } 
0770E:  BRA    776E
07710:  MOVLB  2
....................             else if (payload_buff[9] == 2)                
07712:  MOVF   xFC,W
07714:  SUBLW  02
07716:  BNZ   7740
....................             {                                           
....................                temp_uint32 = read_ee2(make16(payload_buff[8], payload_buff[7]));        
07718:  MOVFF  2FB,553
0771C:  MOVFF  2FA,552
07720:  MOVFF  2FB,555
07724:  MOVFF  2FA,554
07728:  MOVLB  0
0772A:  CALL   32B4
0772E:  MOVLB  5
07730:  CLRF   x51
07732:  CLRF   x50
07734:  MOVFF  02,54F
07738:  MOVFF  01,54E
....................             } 
0773C:  BRA    776E
0773E:  MOVLB  2
....................             else if (payload_buff[9] == 4)                                            
07740:  MOVF   xFC,W
07742:  SUBLW  04
07744:  BNZ   776C
....................             { 
....................                temp_uint32 = read_ee4(make16(payload_buff[8], payload_buff[7])); 
07746:  MOVFF  2FB,553
0774A:  MOVFF  2FA,552
0774E:  MOVFF  2FB,555
07752:  MOVFF  2FA,554
07756:  MOVLB  0
07758:  CALL   33D8
0775C:  MOVFF  03,551
07760:  MOVFF  02,550
07764:  MOVFF  01,54F
07768:  MOVFF  00,54E
0776C:  MOVLB  5
....................             } 
....................             send_read_eeprom_response(command_id_received, mgr_msgSEQ, make16(payload_buff[8], payload_buff[7]), temp_uint32);   
0776E:  MOVFF  2FB,553
07772:  MOVFF  2FA,552
07776:  MOVFF  54B,554
0777A:  MOVFF  54D,556
0777E:  MOVFF  54C,555
07782:  MOVFF  2FB,558
07786:  MOVFF  2FA,557
0778A:  MOVFF  551,55C
0778E:  MOVFF  550,55B
07792:  MOVFF  54F,55A
07796:  MOVFF  54E,559
0779A:  MOVLB  0
0779C:  GOTO   6BCC
....................          } 
....................          break; 
077A0:  MOVLB  5
077A2:  GOTO   7FEA
....................        
....................       case MSG_MGR_READ_XDCR:                                                     
....................          // if the type1 (fancy expensive all-sensors xdcrs) are connected    
....................          if (global_xcdr_type1_enabled)                                      
077A6:  BTFSS  xA7.2
077A8:  BRA    77CC
....................          {                              
....................             // ack it (yes, because it takes ~50ms for the xdcr to settle, it must be an 
....................             //    unsolicited response that happens later) 
....................             send_ack(command_id_received, mgr_msgSEQ);       
077AA:  MOVFF  54B,552
077AE:  MOVFF  54D,554
077B2:  MOVFF  54C,553
077B6:  CALL   66F6
....................             // schedule calibrate valve                               
....................             PUSH_PRIORITY_QUEUE_MACRO(TAKE_XCDR_MESUREMENT_1);   
077BA:  BCF    F7A.1
077BC:  MOVLW  55
077BE:  MOVLB  5
077C0:  MOVWF  x52
077C2:  MOVLB  0
077C4:  CALL   46CA
077C8:  BSF    F7A.1
....................          }                                       
077CA:  BRA    77F2
....................          // if a xdcr isn't connected, then nack it! 
....................          else                                
....................          {   
....................             temp_uint32 |= NACK_BITFIELD_INVALID_HARDWARE; 
077CC:  MOVLB  5
077CE:  BSF    x4E.7
....................             send_nack(command_id_received, mgr_msgSEQ, temp_uint32);   
077D0:  MOVFF  54B,552
077D4:  MOVFF  54D,554
077D8:  MOVFF  54C,553
077DC:  MOVFF  551,558
077E0:  MOVFF  550,557
077E4:  MOVFF  54F,556
077E8:  MOVFF  54E,555
077EC:  MOVLB  0
077EE:  CALL   6772
....................          }        
....................          break;                                          
077F2:  MOVLB  5
077F4:  GOTO   7FEA
....................                                                                      
....................           
.................... //////// Run/Test/Demo Commands////////         
....................       case MSG_MGR_RUN_CMD_NO_MOD: 
....................              
....................          if (global_valve_position == VLV_POSITION_UNKNOWN) 
077F8:  INCFSZ xC1,W
077FA:  BRA    7806
077FC:  INCFSZ xC2,W
077FE:  BRA    7806
....................          { 
....................             temp_uint32 |= NACK_BITFIELD_VLV_POSITION_UNKNOWN; 
07800:  MOVLB  5
07802:  BSF    x4E.0
07804:  MOVLB  0
....................          } 
....................          if (!is_valve_position_valid(make16(payload_buff[16], payload_buff[15]))) 
07806:  MOVFF  303,553
0780A:  MOVFF  302,552
0780E:  MOVFF  303,555
07812:  MOVFF  302,554
07816:  CALL   6750
0781A:  MOVF   01,F
0781C:  BNZ   7824
....................          { 
....................             temp_uint32 |= NACK_BITFIELD_INVALID_VLV_SETTING; 
0781E:  MOVLB  5
07820:  BSF    x4E.1
07822:  MOVLB  0
....................          } 
....................          if (!is_rpm_setting_valid(make16(payload_buff[18], payload_buff[17]))) 
07824:  MOVFF  305,553
07828:  MOVFF  304,552
0782C:  MOVFF  305,555
07830:  MOVFF  304,554
07834:  CALL   6C26
07838:  MOVF   01,F
0783A:  BNZ   7842
....................          { 
....................             temp_uint32 |= NACK_BITFIELD_INVALID_RPM_SETTING; 
0783C:  MOVLB  5
0783E:  BSF    x4E.2
07840:  MOVLB  0
....................          } 
....................   
....................          // if the NACK bitfield contains anything, send the nack instead of proceeding 
....................          if (temp_uint32 != 0) 
07842:  MOVLB  5
07844:  MOVF   x4E,F
07846:  BNZ   7854
07848:  MOVF   x4F,F
0784A:  BNZ   7854
0784C:  MOVF   x50,F
0784E:  BNZ   7854
07850:  MOVF   x51,F
07852:  BZ    787A
....................          { 
....................             send_nack(command_id_received, mgr_msgSEQ, temp_uint32);  
07854:  MOVFF  54B,552
07858:  MOVFF  54D,554
0785C:  MOVFF  54C,553
07860:  MOVFF  551,558
07864:  MOVFF  550,557
07868:  MOVFF  54F,556
0786C:  MOVFF  54E,555
07870:  MOVLB  0
07872:  CALL   6772
....................          }      
07876:  BRA    7904
07878:  MOVLB  5
....................          // add non-modulated run command to command queue  
....................          else 
....................          { 
....................             push_sprinkler_queue(make32(payload_buff[10],payload_buff[9],payload_buff[8],payload_buff[7]), \ 
....................                make32(payload_buff[14],payload_buff[13],payload_buff[12],payload_buff[11]), \ 
....................                make16(payload_buff[16], payload_buff[15]), make16(payload_buff[18], payload_buff[17]), \ 
....................                0, BRAKE_AND_CHARGE_START); 
0787A:  MOVFF  2FD,555
0787E:  MOVFF  2FC,554
07882:  MOVFF  2FB,553
07886:  MOVFF  2FA,552
0788A:  MOVFF  301,559
0788E:  MOVFF  300,558
07892:  MOVFF  2FF,557
07896:  MOVFF  2FE,556
0789A:  MOVFF  303,55B
0789E:  MOVFF  302,55A
078A2:  MOVFF  305,55D
078A6:  MOVFF  304,55C
078AA:  MOVFF  2FD,561
078AE:  MOVFF  2FC,560
078B2:  MOVFF  2FB,55F
078B6:  MOVFF  2FA,55E
078BA:  MOVFF  301,565
078BE:  MOVFF  300,564
078C2:  MOVFF  2FF,563
078C6:  MOVFF  2FE,562
078CA:  MOVFF  303,567
078CE:  MOVFF  302,566
078D2:  MOVFF  305,569
078D6:  MOVFF  304,568
078DA:  CLRF   x6A
078DC:  CLRF   x6B
078DE:  MOVLB  0
078E0:  CALL   6C54
....................              
....................             // have the micro check the battery to determine the proper charging 
....................             PUSH_PRIORITY_QUEUE_MACRO(CHECK_BATTERY_STATE);  
078E4:  BCF    F7A.1
078E6:  MOVLW  A1
078E8:  MOVLB  5
078EA:  MOVWF  x52
078EC:  MOVLB  0
078EE:  CALL   46CA
078F2:  BSF    F7A.1
....................             send_sprinkler_cmd_response(command_id_received, mgr_msgSEQ); 
078F4:  MOVFF  54B,552
078F8:  MOVFF  54D,554
078FC:  MOVFF  54C,553
07900:  GOTO   6E92
....................          } 
....................          break; 
07904:  MOVLB  5
07906:  BRA    7FEA
....................           
....................       case MSG_MGR_RUN_CMD_MOD: 
....................          // since this isn't implemented, nack it 
....................          temp_uint32 |= NACK_BITFIELD_INCOMPATIBLE_STATE;   
07908:  MOVLB  5
0790A:  BSF    x4E.5
....................          send_nack(command_id_received, mgr_msgSEQ, temp_uint32); 
0790C:  MOVFF  54B,552
07910:  MOVFF  54D,554
07914:  MOVFF  54C,553
07918:  MOVFF  551,558
0791C:  MOVFF  550,557
07920:  MOVFF  54F,556
07924:  MOVFF  54E,555
07928:  MOVLB  0
0792A:  CALL   6772
....................                               
....................          // add modulated run command to command queue 
....................          // send_sprinkler_cmd_response(command_id_received, mgr_msgSEQ); 
....................          break; 
0792E:  MOVLB  5
07930:  BRA    7FEA
....................                                                    
....................       case MSG_MGR_TEST_NO_RPM_CTRL:    
....................              
....................          // this test added by JG 
....................          if (!is_valve_value_full_open_or_close(make16(payload_buff[8], payload_buff[7]))) 
07932:  MOVFF  2FB,553
07936:  MOVFF  2FA,552
0793A:  MOVFF  2FB,555
0793E:  MOVFF  2FA,554
07942:  CALL   70A8
07946:  MOVF   01,F
07948:  BNZ   7958
....................          { 
....................             if (global_valve_position == VLV_POSITION_UNKNOWN)   
0794A:  INCFSZ xC1,W
0794C:  BRA    7958
0794E:  INCFSZ xC2,W
07950:  BRA    7958
....................             {                                                     
....................                temp_uint32 |= NACK_BITFIELD_VLV_POSITION_UNKNOWN;  
07952:  MOVLB  5
07954:  BSF    x4E.0
07956:  MOVLB  0
....................             }                             
....................          }              
....................          if (!is_valve_position_valid(make16(payload_buff[8], payload_buff[7]))) 
07958:  MOVFF  2FB,553
0795C:  MOVFF  2FA,552
07960:  MOVFF  2FB,555
07964:  MOVFF  2FA,554
07968:  CALL   6750
0796C:  MOVF   01,F
0796E:  BNZ   7976
....................          { 
....................             temp_uint32 |= NACK_BITFIELD_INVALID_VLV_SETTING; 
07970:  MOVLB  5
07972:  BSF    x4E.1
07974:  MOVLB  0
....................          }  
....................          if (!is_brake_duty_valid(make16(payload_buff[10], payload_buff[9]))) 
07976:  MOVFF  2FD,553
0797A:  MOVFF  2FC,552
0797E:  MOVFF  2FD,555
07982:  MOVFF  2FC,554
07986:  GOTO   70CC
0798A:  MOVF   01,F
0798C:  BNZ   7994
....................          { 
....................             temp_uint32 |= NACK_BITFIELD_INVALID_BRAKE_SETTING; 
0798E:  MOVLB  5
07990:  BSF    x4E.3
07992:  MOVLB  0
....................          } 
....................          if (!is_charge_duty_valid(make16(payload_buff[12], payload_buff[11]))) 
07994:  MOVFF  2FF,553
07998:  MOVFF  2FE,552
0799C:  MOVFF  2FF,555
079A0:  MOVFF  2FE,554
079A4:  GOTO   70F0
079A8:  MOVF   01,F
079AA:  BNZ   79B2
....................          { 
....................             temp_uint32 |= NACK_BITFIELD_INVALID_CHARGE_SETTING; 
079AC:  MOVLB  5
079AE:  BSF    x4E.4
079B0:  MOVLB  0
....................          } 
....................          // if in mppc non-dynamic mode, check mppc 
....................          if ((payload_buff[14] == FALSE) && (!is_mppc_valid(payload_buff[13]))) 
079B2:  MOVLB  3
079B4:  MOVF   x01,F
079B6:  BNZ   79D2
079B8:  MOVFF  300,552
079BC:  MOVLB  0
079BE:  GOTO   7114
079C2:  MOVF   01,F
079C4:  BTFSC  FD8.2
079C6:  BRA    79CC
079C8:  MOVLB  3
079CA:  BRA    79D2
....................          { 
....................             temp_uint32 |= NACK_BITFIELD_INVALID_MPPC_SETTING; 
079CC:  MOVLB  5
079CE:  BSF    x4F.1
079D0:  MOVLB  3
....................          } 
....................           
....................          // if the NACK bitfield contains anything, send the nack instead of proceeding 
....................          if (temp_uint32 != 0) 
079D2:  MOVLB  5
079D4:  MOVF   x4E,F
079D6:  BNZ   79E4
079D8:  MOVF   x4F,F
079DA:  BNZ   79E4
079DC:  MOVF   x50,F
079DE:  BNZ   79E4
079E0:  MOVF   x51,F
079E2:  BZ    7A0A
....................          { 
....................             send_nack(command_id_received, mgr_msgSEQ, temp_uint32); 
079E4:  MOVFF  54B,552
079E8:  MOVFF  54D,554
079EC:  MOVFF  54C,553
079F0:  MOVFF  551,558
079F4:  MOVFF  550,557
079F8:  MOVFF  54F,556
079FC:  MOVFF  54E,555
07A00:  MOVLB  0
07A02:  CALL   6772
....................          } 
07A06:  BRA    7B40
07A08:  MOVLB  5
....................          // add non-modulated run command to command queue  
....................          else 
....................          { 
....................                                                  
....................             // deal with JG-added special cases of commands to fully open or 
....................             //  or fully close the valve in cases whete the valve has not 
....................             //  yet been calibrated 
....................             if ((make16(payload_buff[8], payload_buff[7]) == VLV_POSITION_OPENED) \ 
....................                && (global_valve_position == VLV_POSITION_UNKNOWN)) 
07A0A:  MOVFF  2FB,553
07A0E:  MOVFF  2FA,552
07A12:  MOVF   x52,F
07A14:  BNZ   7A46
07A16:  MOVF   x53,W
07A18:  SUBLW  80
07A1A:  BNZ   7A46
07A1C:  MOVLB  0
07A1E:  INCFSZ xC1,W
07A20:  BRA    7A24
07A22:  BRA    7A28
07A24:  MOVLB  5
07A26:  BRA    7A46
07A28:  INCFSZ xC2,W
07A2A:  BRA    7A2E
07A2C:  BRA    7A32
07A2E:  MOVLB  5
07A30:  BRA    7A46
....................             { 
....................                PUSH_PRIORITY_QUEUE_MACRO(OPEN_VALVE_UNKNOWN_STATE); 
07A32:  BCF    F7A.1
07A34:  MOVLW  3E
07A36:  MOVLB  5
07A38:  MOVWF  x52
07A3A:  MOVLB  0
07A3C:  CALL   46CA
07A40:  BSF    F7A.1
....................             } 
07A42:  BRA    7A8E
07A44:  MOVLB  5
....................              
....................             else if ((make16(payload_buff[8], payload_buff[7]) == VLV_POSITION_CLOSED) \ 
....................                && (global_valve_position == VLV_POSITION_UNKNOWN)) 
07A46:  MOVFF  2FB,553
07A4A:  MOVFF  2FA,552
07A4E:  MOVF   x52,F
07A50:  BNZ   7A80
07A52:  MOVF   x53,F
07A54:  BNZ   7A80
07A56:  MOVLB  0
07A58:  INCFSZ xC1,W
07A5A:  BRA    7A5E
07A5C:  BRA    7A62
07A5E:  MOVLB  5
07A60:  BRA    7A80
07A62:  INCFSZ xC2,W
07A64:  BRA    7A68
07A66:  BRA    7A6C
07A68:  MOVLB  5
07A6A:  BRA    7A80
....................             { 
....................                PUSH_PRIORITY_QUEUE_MACRO(CLOSE_VALVE_UNKNOWN_STATE); 
07A6C:  BCF    F7A.1
07A6E:  MOVLW  3F
07A70:  MOVLB  5
07A72:  MOVWF  x52
07A74:  MOVLB  0
07A76:  CALL   46CA
07A7A:  BSF    F7A.1
....................             } 
07A7C:  BRA    7A8E
07A7E:  MOVLB  5
....................               
....................             else 
....................             { 
....................                PUSH_PRIORITY_QUEUE_MACRO(MOVE_VALVE); 
07A80:  BCF    F7A.1
07A82:  MOVLW  40
07A84:  MOVWF  x52
07A86:  MOVLB  0
07A88:  CALL   46CA
07A8C:  BSF    F7A.1
....................             }                                        
....................                         
....................             global_brake_duty_set_value = (make16(payload_buff[10], payload_buff[9])); 
07A8E:  MOVFF  2FD,B7
07A92:  MOVFF  2FC,B6
....................             global_charge_duty_set_value = (make16(payload_buff[12], payload_buff[11])); 
07A96:  MOVFF  2FF,B9
07A9A:  MOVFF  2FE,B8
....................                                 
....................             // clear queue 
....................             clear_sprinkler_queue();  
07A9E:  CALL   53B0
....................              
....................             if (payload_buff[14] == FALSE)                                               
07AA2:  MOVLB  3
07AA4:  MOVF   x01,F
07AA6:  BNZ   7AE6
....................             { 
....................                // set test parameters with no rpm control and preset mppc value    
....................                push_sprinkler_queue(0, 0-1,make16(payload_buff[8], payload_buff[7]), 0, \ 
....................                0, NO_RPM_CONTROL);      
07AA8:  MOVFF  2FB,553
07AAC:  MOVFF  2FA,552
07AB0:  MOVLB  5
07AB2:  CLRF   x61
07AB4:  CLRF   x60
07AB6:  CLRF   x5F
07AB8:  CLRF   x5E
07ABA:  SETF   x65
07ABC:  SETF   x64
07ABE:  SETF   x63
07AC0:  SETF   x62
07AC2:  MOVFF  2FB,567
07AC6:  MOVFF  2FA,566
07ACA:  CLRF   x69
07ACC:  CLRF   x68
07ACE:  CLRF   x6A
07AD0:  MOVLW  05
07AD2:  MOVWF  x6B
07AD4:  MOVLB  0
07AD6:  CALL   6C54
....................                global_mppc_set_value = payload_buff[13]; 
07ADA:  MOVFF  300,BB
....................                global_control_loop_mechanism = NO_RPM_CONTROL; 
07ADE:  MOVLW  05
07AE0:  MOVWF  xC0
....................             } 
07AE2:  BRA    7B20
07AE4:  MOVLB  3
....................             else if (payload_buff[14] == TRUE)         
07AE6:  DECFSZ x01,W
07AE8:  BRA    7B22
....................             { 
....................                // set test parameters with no rpm control and dynamic mppc 
....................                push_sprinkler_queue(0, 0-1,make16(payload_buff[8], payload_buff[7]), 0, \ 
....................                0, NO_RPM_CONTROL_DYN_MPPC); 
07AEA:  MOVFF  2FB,553
07AEE:  MOVFF  2FA,552
07AF2:  MOVLB  5
07AF4:  CLRF   x61
07AF6:  CLRF   x60
07AF8:  CLRF   x5F
07AFA:  CLRF   x5E
07AFC:  SETF   x65
07AFE:  SETF   x64
07B00:  SETF   x63
07B02:  SETF   x62
07B04:  MOVFF  2FB,567
07B08:  MOVFF  2FA,566
07B0C:  CLRF   x69
07B0E:  CLRF   x68
07B10:  CLRF   x6A
07B12:  MOVLW  06
07B14:  MOVWF  x6B
07B16:  MOVLB  0
07B18:  CALL   6C54
....................                global_control_loop_mechanism = NO_RPM_CONTROL_DYN_MPPC; 
07B1C:  MOVLW  06
07B1E:  MOVWF  xC0
07B20:  MOVLB  3
....................             } 
....................              
....................             global_valve_position_set_value = make16(payload_buff[8], payload_buff[7]); 
07B22:  MOVFF  2FB,C4
07B26:  MOVFF  2FA,C3
....................             global_rpm_set_value = 0; 
07B2A:  MOVLB  0
07B2C:  CLRF   xAD
07B2E:  CLRF   xAC
....................  
....................             send_full_report(command_id_received, mgr_msgSEQ); 
07B30:  MOVFF  54B,552
07B34:  MOVFF  54D,554
07B38:  MOVFF  54C,553
07B3C:  CALL   6222
....................          } 
....................          break; 
07B40:  MOVLB  5
07B42:  BRA    7FEA
....................           
....................       case MSG_MGR_TEST_RPM_CTRL: 
....................        
....................          // this test added by JG 
....................          if (!is_valve_value_full_open_or_close(make16(payload_buff[8], payload_buff[7]))) 
07B44:  MOVFF  2FB,553
07B48:  MOVFF  2FA,552
07B4C:  MOVFF  2FB,555
07B50:  MOVFF  2FA,554
07B54:  CALL   70A8
07B58:  MOVF   01,F
07B5A:  BNZ   7B6A
....................          { 
....................             if (global_valve_position == VLV_POSITION_UNKNOWN) 
07B5C:  INCFSZ xC1,W
07B5E:  BRA    7B6A
07B60:  INCFSZ xC2,W
07B62:  BRA    7B6A
....................             { 
....................                temp_uint32 |= NACK_BITFIELD_VLV_POSITION_UNKNOWN; 
07B64:  MOVLB  5
07B66:  BSF    x4E.0
07B68:  MOVLB  0
....................             } 
....................          } 
....................          if (!is_valve_position_valid(make16(payload_buff[8], payload_buff[7]))) 
07B6A:  MOVFF  2FB,553
07B6E:  MOVFF  2FA,552
07B72:  MOVFF  2FB,555
07B76:  MOVFF  2FA,554
07B7A:  CALL   6750
07B7E:  MOVF   01,F
07B80:  BNZ   7B88
....................          { 
....................             temp_uint32 |= NACK_BITFIELD_INVALID_VLV_SETTING; 
07B82:  MOVLB  5
07B84:  BSF    x4E.1
07B86:  MOVLB  0
....................          } 
....................          if (!is_rpm_setting_valid(make16(payload_buff[10], payload_buff[9]))) 
07B88:  MOVFF  2FD,553
07B8C:  MOVFF  2FC,552
07B90:  MOVFF  2FD,555
07B94:  MOVFF  2FC,554
07B98:  CALL   6C26
07B9C:  MOVF   01,F
07B9E:  BNZ   7BA6
....................          {                                
....................             temp_uint32 |= NACK_BITFIELD_INVALID_RPM_SETTING; 
07BA0:  MOVLB  5
07BA2:  BSF    x4E.2
07BA4:  MOVLB  0
....................          } 
....................           
....................          // if the NACK bitfield contains anything, send the nack instead of proceeding 
....................          if (temp_uint32 != 0) 
07BA6:  MOVLB  5
07BA8:  MOVF   x4E,F
07BAA:  BNZ   7BB8
07BAC:  MOVF   x4F,F
07BAE:  BNZ   7BB8
07BB0:  MOVF   x50,F
07BB2:  BNZ   7BB8
07BB4:  MOVF   x51,F
07BB6:  BZ    7BDE
....................          { 
....................             send_nack(command_id_received, mgr_msgSEQ, temp_uint32); 
07BB8:  MOVFF  54B,552
07BBC:  MOVFF  54D,554
07BC0:  MOVFF  54C,553
07BC4:  MOVFF  551,558
07BC8:  MOVFF  550,557
07BCC:  MOVFF  54F,556
07BD0:  MOVFF  54E,555
07BD4:  MOVLB  0
07BD6:  CALL   6772
....................          } 
07BDA:  BRA    7D14
07BDC:  MOVLB  5
....................          // add non-modulated run command to command queue  
....................          else 
....................          {  
....................             // clear queue  
....................             clear_sprinkler_queue(); 
07BDE:  MOVLB  0
07BE0:  CALL   53B0
....................              
....................             // set test parameters with rpm control 
....................             // JG: Add test of extra byte to address whether or not to 
....................             //  be have charging as part of the control loop 
....................             if (payload_buff[11] == 0xFF) 
07BE4:  MOVLB  2
07BE6:  INCFSZ xFE,W
07BE8:  BRA    7C2C
....................             { 
....................                push_sprinkler_queue(0, 0-1,make16(payload_buff[8], payload_buff[7]), \ 
....................                   make16(payload_buff[10], payload_buff[9]), 0, BRAKE_AND_CHARGE_START); 
07BEA:  MOVFF  2FB,553
07BEE:  MOVFF  2FA,552
07BF2:  MOVFF  2FD,555
07BF6:  MOVFF  2FC,554
07BFA:  MOVLB  5
07BFC:  CLRF   x61
07BFE:  CLRF   x60
07C00:  CLRF   x5F
07C02:  CLRF   x5E
07C04:  SETF   x65
07C06:  SETF   x64
07C08:  SETF   x63
07C0A:  SETF   x62
07C0C:  MOVFF  2FB,567
07C10:  MOVFF  2FA,566
07C14:  MOVFF  2FD,569
07C18:  MOVFF  2FC,568
07C1C:  CLRF   x6A
07C1E:  CLRF   x6B
07C20:  MOVLB  0
07C22:  CALL   6C54
....................                    
....................                global_control_loop_mechanism = BRAKE_AND_CHARGE_START; 
07C26:  CLRF   xC0
....................             } 
07C28:  BRA    7C6E
07C2A:  MOVLB  2
....................             else 
....................             { 
....................                push_sprinkler_queue(0, 0-1,make16(payload_buff[8], payload_buff[7]), \ 
....................                   make16(payload_buff[10], payload_buff[9]), 0, BRAKE_ONLY); 
07C2C:  MOVFF  2FB,553
07C30:  MOVFF  2FA,552
07C34:  MOVFF  2FD,555
07C38:  MOVFF  2FC,554
07C3C:  MOVLB  5
07C3E:  CLRF   x61
07C40:  CLRF   x60
07C42:  CLRF   x5F
07C44:  CLRF   x5E
07C46:  SETF   x65
07C48:  SETF   x64
07C4A:  SETF   x63
07C4C:  SETF   x62
07C4E:  MOVFF  2FB,567
07C52:  MOVFF  2FA,566
07C56:  MOVFF  2FD,569
07C5A:  MOVFF  2FC,568
07C5E:  CLRF   x6A
07C60:  MOVLW  02
07C62:  MOVWF  x6B
07C64:  MOVLB  0
07C66:  CALL   6C54
....................                 
....................                global_control_loop_mechanism = BRAKE_ONLY; 
07C6A:  MOVLW  02
07C6C:  MOVWF  xC0
....................             } 
....................                 
....................             // deal with JG-added special cases of commands to fully open or 
....................             //  or fully close the valve in cases where the valve has not 
....................             //  yet been calibrated 
....................             if ((make16(payload_buff[8], payload_buff[7]) == VLV_POSITION_OPENED) \ 
....................                && (global_valve_position == VLV_POSITION_UNKNOWN)) 
07C6E:  MOVFF  2FB,553
07C72:  MOVFF  2FA,552
07C76:  MOVLB  5
07C78:  MOVF   x52,F
07C7A:  BNZ   7CAC
07C7C:  MOVF   x53,W
07C7E:  SUBLW  80
07C80:  BNZ   7CAC
07C82:  MOVLB  0
07C84:  INCFSZ xC1,W
07C86:  BRA    7C8A
07C88:  BRA    7C8E
07C8A:  MOVLB  5
07C8C:  BRA    7CAC
07C8E:  INCFSZ xC2,W
07C90:  BRA    7C94
07C92:  BRA    7C98
07C94:  MOVLB  5
07C96:  BRA    7CAC
....................             { 
....................                PUSH_PRIORITY_QUEUE_MACRO(OPEN_VALVE_UNKNOWN_STATE); 
07C98:  BCF    F7A.1
07C9A:  MOVLW  3E
07C9C:  MOVLB  5
07C9E:  MOVWF  x52
07CA0:  MOVLB  0
07CA2:  CALL   46CA
07CA6:  BSF    F7A.1
....................             } 
07CA8:  BRA    7CF4
07CAA:  MOVLB  5
....................              
....................             else if ((make16(payload_buff[8], payload_buff[7]) == VLV_POSITION_CLOSED) \ 
....................                && (global_valve_position == VLV_POSITION_UNKNOWN)) 
07CAC:  MOVFF  2FB,553
07CB0:  MOVFF  2FA,552
07CB4:  MOVF   x52,F
07CB6:  BNZ   7CE6
07CB8:  MOVF   x53,F
07CBA:  BNZ   7CE6
07CBC:  MOVLB  0
07CBE:  INCFSZ xC1,W
07CC0:  BRA    7CC4
07CC2:  BRA    7CC8
07CC4:  MOVLB  5
07CC6:  BRA    7CE6
07CC8:  INCFSZ xC2,W
07CCA:  BRA    7CCE
07CCC:  BRA    7CD2
07CCE:  MOVLB  5
07CD0:  BRA    7CE6
....................             { 
....................                PUSH_PRIORITY_QUEUE_MACRO(CLOSE_VALVE_UNKNOWN_STATE); 
07CD2:  BCF    F7A.1
07CD4:  MOVLW  3F
07CD6:  MOVLB  5
07CD8:  MOVWF  x52
07CDA:  MOVLB  0
07CDC:  CALL   46CA
07CE0:  BSF    F7A.1
....................             }                                      
07CE2:  BRA    7CF4
07CE4:  MOVLB  5
....................              
....................             else 
....................             { 
....................                PUSH_PRIORITY_QUEUE_MACRO(MOVE_VALVE);   
07CE6:  BCF    F7A.1
07CE8:  MOVLW  40
07CEA:  MOVWF  x52
07CEC:  MOVLB  0
07CEE:  CALL   46CA
07CF2:  BSF    F7A.1
....................             } 
....................              
....................             global_valve_position_set_value = make16(payload_buff[8], payload_buff[7]); 
07CF4:  MOVFF  2FB,C4
07CF8:  MOVFF  2FA,C3
....................             global_rpm_set_value = make16(payload_buff[10], payload_buff[9]); 
07CFC:  MOVFF  2FD,AD
07D00:  MOVFF  2FC,AC
....................             send_full_report(command_id_received, mgr_msgSEQ);    
07D04:  MOVFF  54B,552
07D08:  MOVFF  54D,554
07D0C:  MOVFF  54C,553
07D10:  CALL   6222
....................          } 
....................          break;  
07D14:  MOVLB  5
07D16:  BRA    7FEA
....................           
....................       case MSG_MGR_DEMO: 
....................          if (global_valve_position == VLV_POSITION_UNKNOWN) 
07D18:  INCFSZ xC1,W
07D1A:  BRA    7D26
07D1C:  INCFSZ xC2,W
07D1E:  BRA    7D26
....................          { 
....................             temp_uint32 |= NACK_BITFIELD_VLV_POSITION_UNKNOWN; 
07D20:  MOVLB  5
07D22:  BSF    x4E.0
07D24:  MOVLB  0
....................          }      
....................          // if the NACK bitfield contains anything, send the nack instead of proceeding 
....................          if (temp_uint32 != 0) 
07D26:  MOVLB  5
07D28:  MOVF   x4E,F
07D2A:  BNZ   7D38
07D2C:  MOVF   x4F,F
07D2E:  BNZ   7D38
07D30:  MOVF   x50,F
07D32:  BNZ   7D38
07D34:  MOVF   x51,F
07D36:  BZ    7D5E
....................          { 
....................             send_nack(command_id_received, mgr_msgSEQ, temp_uint32); 
07D38:  MOVFF  54B,552
07D3C:  MOVFF  54D,554
07D40:  MOVFF  54C,553
07D44:  MOVFF  551,558
07D48:  MOVFF  550,557
07D4C:  MOVFF  54F,556
07D50:  MOVFF  54E,555
07D54:  MOVLB  0
07D56:  CALL   6772
....................          }         
07D5A:  BRA    7F20
07D5C:  MOVLB  5
....................          else 
....................          { 
....................             clear_sprinkler_queue(); 
07D5E:  MOVLB  0
07D60:  CALL   53B0
....................             push_sprinkler_queue(global_utc_time, global_utc_time + 30, 0x4000, 100, 0, BRAKE_AND_CHARGE_START); 
07D64:  MOVLW  1E
07D66:  ADDWF  x89,W
07D68:  MOVLB  5
07D6A:  MOVWF  x52
07D6C:  MOVLW  00
07D6E:  MOVLB  0
07D70:  ADDWFC x8A,W
07D72:  MOVLB  5
07D74:  MOVWF  x53
07D76:  MOVLW  00
07D78:  MOVLB  0
07D7A:  ADDWFC x8B,W
07D7C:  MOVLB  5
07D7E:  MOVWF  x54
07D80:  MOVLW  00
07D82:  MOVLB  0
07D84:  ADDWFC x8C,W
07D86:  MOVLB  5
07D88:  MOVWF  x55
07D8A:  MOVFF  8C,561
07D8E:  MOVFF  8B,560
07D92:  MOVFF  8A,55F
07D96:  MOVFF  89,55E
07D9A:  MOVWF  x65
07D9C:  MOVFF  554,564
07DA0:  MOVFF  553,563
07DA4:  MOVFF  552,562
07DA8:  MOVLW  40
07DAA:  MOVWF  x67
07DAC:  CLRF   x66
07DAE:  CLRF   x69
07DB0:  MOVLW  64
07DB2:  MOVWF  x68
07DB4:  CLRF   x6A
07DB6:  CLRF   x6B
07DB8:  MOVLB  0
07DBA:  CALL   6C54
....................             push_sprinkler_queue(global_utc_time + 30, global_utc_time + 60, 0x4000, 50, 0, BRAKE_AND_CHARGE_START); 
07DBE:  MOVLW  1E
07DC0:  ADDWF  x89,W
07DC2:  MOVLB  5
07DC4:  MOVWF  x52
07DC6:  MOVLW  00
07DC8:  MOVLB  0
07DCA:  ADDWFC x8A,W
07DCC:  MOVLB  5
07DCE:  MOVWF  x53
07DD0:  MOVLW  00
07DD2:  MOVLB  0
07DD4:  ADDWFC x8B,W
07DD6:  MOVLB  5
07DD8:  MOVWF  x54
07DDA:  MOVLW  00
07DDC:  MOVLB  0
07DDE:  ADDWFC x8C,W
07DE0:  MOVLB  5
07DE2:  MOVWF  x55
07DE4:  MOVLW  3C
07DE6:  MOVLB  0
07DE8:  ADDWF  x89,W
07DEA:  MOVLB  5
07DEC:  MOVWF  x56
07DEE:  MOVLW  00
07DF0:  MOVLB  0
07DF2:  ADDWFC x8A,W
07DF4:  MOVLB  5
07DF6:  MOVWF  x57
07DF8:  MOVLW  00
07DFA:  MOVLB  0
07DFC:  ADDWFC x8B,W
07DFE:  MOVLB  5
07E00:  MOVWF  x58
07E02:  MOVLW  00
07E04:  MOVLB  0
07E06:  ADDWFC x8C,W
07E08:  MOVLB  5
07E0A:  MOVWF  x59
07E0C:  MOVFF  555,561
07E10:  MOVFF  554,560
07E14:  MOVFF  553,55F
07E18:  MOVFF  552,55E
07E1C:  MOVWF  x65
07E1E:  MOVFF  558,564
07E22:  MOVFF  557,563
07E26:  MOVFF  556,562
07E2A:  MOVLW  40
07E2C:  MOVWF  x67
07E2E:  CLRF   x66
07E30:  CLRF   x69
07E32:  MOVLW  32
07E34:  MOVWF  x68
07E36:  CLRF   x6A
07E38:  CLRF   x6B
07E3A:  MOVLB  0
07E3C:  CALL   6C54
....................             push_sprinkler_queue(global_utc_time + 60, global_utc_time + 90, 0x4000, 10, 0, BRAKE_AND_CHARGE_START); 
07E40:  MOVLW  3C
07E42:  ADDWF  x89,W
07E44:  MOVLB  5
07E46:  MOVWF  x52
07E48:  MOVLW  00
07E4A:  MOVLB  0
07E4C:  ADDWFC x8A,W
07E4E:  MOVLB  5
07E50:  MOVWF  x53
07E52:  MOVLW  00
07E54:  MOVLB  0
07E56:  ADDWFC x8B,W
07E58:  MOVLB  5
07E5A:  MOVWF  x54
07E5C:  MOVLW  00
07E5E:  MOVLB  0
07E60:  ADDWFC x8C,W
07E62:  MOVLB  5
07E64:  MOVWF  x55
07E66:  MOVLW  5A
07E68:  MOVLB  0
07E6A:  ADDWF  x89,W
07E6C:  MOVLB  5
07E6E:  MOVWF  x56
07E70:  MOVLW  00
07E72:  MOVLB  0
07E74:  ADDWFC x8A,W
07E76:  MOVLB  5
07E78:  MOVWF  x57
07E7A:  MOVLW  00
07E7C:  MOVLB  0
07E7E:  ADDWFC x8B,W
07E80:  MOVLB  5
07E82:  MOVWF  x58
07E84:  MOVLW  00
07E86:  MOVLB  0
07E88:  ADDWFC x8C,W
07E8A:  MOVLB  5
07E8C:  MOVWF  x59
07E8E:  MOVFF  555,561
07E92:  MOVFF  554,560
07E96:  MOVFF  553,55F
07E9A:  MOVFF  552,55E
07E9E:  MOVWF  x65
07EA0:  MOVFF  558,564
07EA4:  MOVFF  557,563
07EA8:  MOVFF  556,562
07EAC:  MOVLW  40
07EAE:  MOVWF  x67
07EB0:  CLRF   x66
07EB2:  CLRF   x69
07EB4:  MOVLW  0A
07EB6:  MOVWF  x68
07EB8:  CLRF   x6A
07EBA:  CLRF   x6B
07EBC:  MOVLB  0
07EBE:  CALL   6C54
....................             push_sprinkler_queue(global_utc_time + 90, 0-1, VLV_POSITION_CLOSED, 0, 0, BRAKE_AND_CHARGE_START); 
07EC2:  MOVLW  5A
07EC4:  ADDWF  x89,W
07EC6:  MOVLB  5
07EC8:  MOVWF  x52
07ECA:  MOVLW  00
07ECC:  MOVLB  0
07ECE:  ADDWFC x8A,W
07ED0:  MOVLB  5
07ED2:  MOVWF  x53
07ED4:  MOVLW  00
07ED6:  MOVLB  0
07ED8:  ADDWFC x8B,W
07EDA:  MOVLB  5
07EDC:  MOVWF  x54
07EDE:  MOVLW  00
07EE0:  MOVLB  0
07EE2:  ADDWFC x8C,W
07EE4:  MOVLB  5
07EE6:  MOVWF  x55
07EE8:  MOVWF  x61
07EEA:  MOVFF  554,560
07EEE:  MOVFF  553,55F
07EF2:  MOVFF  552,55E
07EF6:  SETF   x65
07EF8:  SETF   x64
07EFA:  SETF   x63
07EFC:  SETF   x62
07EFE:  CLRF   x67
07F00:  CLRF   x66
07F02:  CLRF   x69
07F04:  CLRF   x68
07F06:  CLRF   x6A
07F08:  CLRF   x6B
07F0A:  MOVLB  0
07F0C:  CALL   6C54
....................             send_ack(command_id_received, mgr_msgSEQ); 
07F10:  MOVFF  54B,552
07F14:  MOVFF  54D,554
07F18:  MOVFF  54C,553
07F1C:  CALL   66F6
....................             // add demo mode stuff to commmand queue 
....................          }                                 
....................       case MSG_MGR_CLEAR_SPINKLER_CMD_QUEUE: 
....................          clear_sprinkler_queue(); 
07F20:  CALL   53B0
....................          send_full_report(command_id_received, mgr_msgSEQ); 
07F24:  MOVFF  54B,552
07F28:  MOVFF  54D,554
07F2C:  MOVFF  54C,553
07F30:  CALL   6222
....................          break;  
07F34:  MOVLB  5
07F36:  BRA    7FEA
....................        
....................       // To force the valve to move and change nothing else  
....................       //    (retrieve current settings for brake, charge, etc. 
....................       //    Will force the valve to go fully open/closed if uncalibrated (position unknown)    
....................       case MSG_MGR_FORCE_VALVE_MOVEMENT:               
....................          // if the valve position is unknown and we're trying to send it full open or full closed,  
....................          //    set the valve position to the precalibration (the middle) and proceed as the valve 
....................          //    will recalibrate its position 
....................          if ((global_valve_position == VLV_POSITION_UNKNOWN) &&                                       \ 
....................             (is_valve_value_full_open_or_close(make16(payload_buff[8], payload_buff[7]))))   
07F38:  INCFSZ xC1,W
07F3A:  BRA    7F60
07F3C:  INCFSZ xC2,W
07F3E:  BRA    7F60
07F40:  MOVFF  2FB,553
07F44:  MOVFF  2FA,552
07F48:  MOVFF  2FB,555
07F4C:  MOVFF  2FA,554
07F50:  CALL   70A8
07F54:  MOVF   01,F
07F56:  BZ    7F60
....................          {                            
....................             global_valve_position = VLV_PRECALIBRATION_POSITION;  
07F58:  MOVLW  40
07F5A:  MOVWF  xC2
07F5C:  CLRF   xC1
....................          }       
07F5E:  BRA    7F86
....................           
....................          // if the valve position is unknown and we're trying to send it to a specific position, NACK it    
....................          else if ((global_valve_position == VLV_POSITION_UNKNOWN) &&                                  \ 
....................             (!is_valve_value_full_open_or_close(make16(payload_buff[8], payload_buff[7]))))  
07F60:  INCFSZ xC1,W
07F62:  BRA    7F86
07F64:  INCFSZ xC2,W
07F66:  BRA    7F86
07F68:  MOVFF  2FB,553
07F6C:  MOVFF  2FA,552
07F70:  MOVFF  2FB,555
07F74:  MOVFF  2FA,554
07F78:  CALL   70A8
07F7C:  MOVF   01,F
07F7E:  BNZ   7F86
....................          { 
....................             temp_uint32 |= NACK_BITFIELD_VLV_POSITION_UNKNOWN; 
07F80:  MOVLB  5
07F82:  BSF    x4E.0
07F84:  MOVLB  0
....................          }           
....................           
....................          // if the NACK bitfield contains anything, send the nack instead of proceeding 
....................          if (temp_uint32 != 0)                                      
07F86:  MOVLB  5
07F88:  MOVF   x4E,F
07F8A:  BNZ   7F98
07F8C:  MOVF   x4F,F
07F8E:  BNZ   7F98
07F90:  MOVF   x50,F
07F92:  BNZ   7F98
07F94:  MOVF   x51,F
07F96:  BZ    7FBE
....................          { 
....................             send_nack(command_id_received, mgr_msgSEQ, temp_uint32); 
07F98:  MOVFF  54B,552
07F9C:  MOVFF  54D,554
07FA0:  MOVFF  54C,553
07FA4:  MOVFF  551,558
07FA8:  MOVFF  550,557
07FAC:  MOVFF  54F,556
07FB0:  MOVFF  54E,555
07FB4:  MOVLB  0
07FB6:  CALL   6772
....................          }    
07FBA:  BRA    7FE4
07FBC:  MOVLB  5
....................          // otherwise, set the valve position, send a move valve command to the queue, and send a report 
....................          else  
....................          {     
....................             global_valve_position_set_value = make16(payload_buff[8], payload_buff[7]); 
07FBE:  MOVFF  2FB,C4
07FC2:  MOVFF  2FA,C3
....................             PUSH_PRIORITY_QUEUE_MACRO(MOVE_VALVE);   
07FC6:  BCF    F7A.1
07FC8:  MOVLW  40
07FCA:  MOVWF  x52
07FCC:  MOVLB  0
07FCE:  CALL   46CA
07FD2:  BSF    F7A.1
....................             send_valve_report(command_id_received, mgr_msgSEQ); 
07FD4:  MOVFF  54B,552
07FD8:  MOVFF  54D,554
07FDC:  MOVFF  54C,553
07FE0:  CALL   65C2
....................          } 
....................          break;     
07FE4:  MOVLB  5
07FE6:  BRA    7FEA
07FE8:  MOVLB  5
07FEA:  MOVLB  2
....................    }        
07FEC:  MOVLB  0
07FEE:  GOTO   A530 (RETURN)
.................... }  // deal_with_packet 
....................  
.................... void prepare_prefix_and_payload(uint8_t payload_buf_length) 
.................... { 
....................       // Setup send_prefix 
....................       send_prefix[0] = CMD_SEND; 
*
05DB0:  MOVLW  05
05DB2:  MOVLB  3
05DB4:  MOVWF  x53
....................       // set the size part of the prefix to payload length + 9 other bytes 
....................       send_prefix[1] = payload_buf_length + 9; 
05DB6:  MOVLW  09
05DB8:  MOVLB  5
05DBA:  ADDWF  x5D,W
05DBC:  MOVLB  3
05DBE:  MOVWF  x54
....................       send_prefix[2] = FLAG_SEND_REQUEST; 
05DC0:  MOVLW  04
05DC2:  MOVWF  x55
....................       send_prefix[3] = DESTADDR_HI; 
05DC4:  MOVLW  F9
05DC6:  MOVWF  x56
....................       send_prefix[4] = DESTADDR_LO; 
05DC8:  MOVLW  81
05DCA:  MOVWF  x57
....................       // setup the ???? 
....................       send_prefix[5] = svc_index_rcvd; 
05DCC:  MOVFF  364,358
....................       send_prefix[6] = APPDOMAIN_MAINTENANCE; 
05DD0:  MOVLW  02
05DD2:  MOVWF  x59
....................       send_prefix[7] = PRIORITY_HI; 
05DD4:  MOVWF  x5A
....................       send_prefix[8] = 0; 
05DD6:  CLRF   x5B
....................       send_prefix[9] = 0; 
05DD8:  CLRF   x5C
....................       send_prefix[10] = 0xFF; 
05DDA:  SETF   x5D
....................       send_prefix[11] = payload_buf_length; 
05DDC:  MOVFF  55D,35E
....................       payload_buff[0] = 0x00; 
05DE0:  MOVLB  2
05DE2:  CLRF   xF3
....................       payload_buff[1] = 0x00; 
05DE4:  CLRF   xF4
....................       payload_buff[2] = 0xFC; 
05DE6:  MOVLW  FC
05DE8:  MOVWF  xF5
....................       payload_buff[3] = 0x12;  
05DEA:  MOVLW  12
05DEC:  MOVWF  xF6
05DEE:  MOVLB  0
05DF0:  RETURN 0
.................... } 
.................... void prepare_prefix_and_payload_ISR(uint8_t payload_buf_length) 
.................... { 
....................       // Setup send_prefix 
....................       send_prefix[0] = CMD_SEND; 
*
023B2:  MOVLW  05
023B4:  MOVLB  3
023B6:  MOVWF  x53
....................       // set the size part of the prefix to payload length + 9 other bytes 
....................       send_prefix[1] = payload_buf_length + 9; 
023B8:  MOVLW  09
023BA:  MOVLB  5
023BC:  ADDWF  x93,W
023BE:  MOVLB  3
023C0:  MOVWF  x54
....................       send_prefix[2] = FLAG_SEND_REQUEST; 
023C2:  MOVLW  04
023C4:  MOVWF  x55
....................       send_prefix[3] = DESTADDR_HI; 
023C6:  MOVLW  F9
023C8:  MOVWF  x56
....................       send_prefix[4] = DESTADDR_LO; 
023CA:  MOVLW  81
023CC:  MOVWF  x57
....................       // setup the ???? 
....................       send_prefix[5] = svc_index_rcvd; 
023CE:  MOVFF  364,358
....................       send_prefix[6] = APPDOMAIN_MAINTENANCE; 
023D2:  MOVLW  02
023D4:  MOVWF  x59
....................       send_prefix[7] = PRIORITY_HI;                                                                       
023D6:  MOVWF  x5A
....................       send_prefix[8] = 0; 
023D8:  CLRF   x5B
....................       send_prefix[9] = 0; 
023DA:  CLRF   x5C
....................       send_prefix[10] = 0xFF; 
023DC:  SETF   x5D
....................       send_prefix[11] = payload_buf_length; 
023DE:  MOVFF  593,35E
....................       payload_buff[0] = 0x00; 
023E2:  MOVLB  2
023E4:  CLRF   xF3
....................       payload_buff[1] = 0x00; 
023E6:  CLRF   xF4
....................       payload_buff[2] = 0xFC;                           
023E8:  MOVLW  FC
023EA:  MOVWF  xF5
....................       payload_buff[3] = 0x12;  
023EC:  MOVLW  12
023EE:  MOVWF  xF6
023F0:  MOVLB  0
023F2:  RETURN 0
.................... } 
.................... void generate_message_and_send() 
.................... { 
....................    uint8_t n, res_byte; 
....................    // generate the message 
....................    dust_hdlc_pkgen(send_prefix, 12, payload_buff, send_prefix[11]); 
*
061C8:  MOVLW  03
061CA:  MOVLB  5
061CC:  MOVWF  x66
061CE:  MOVLW  53
061D0:  MOVWF  x65
061D2:  MOVLW  0C
061D4:  MOVWF  x67
061D6:  MOVLW  02
061D8:  MOVWF  x69
061DA:  MOVLW  F3
061DC:  MOVWF  x68
061DE:  MOVFF  35E,56A
061E2:  MOVLB  0
061E4:  RCALL  5E68
....................     
....................    // try to send the message a 3 times 
....................    for (n = 0; n < 3; n++) 
061E6:  MOVLB  5
061E8:  CLRF   x5D
061EA:  MOVF   x5D,W
061EC:  SUBLW  02
061EE:  BNC   621E
....................    { 
....................       // try to send the message 
....................       res_byte = dust_hdlc_pksend();    
061F0:  MOVLB  0
061F2:  RCALL  6112
061F4:  MOVFF  01,55E
....................       // timeout of 50ms if pksend returns an error 
....................       setup_T0_int(T0_50MS); 
061F8:  MOVLB  5
061FA:  SETF   x69
061FC:  MOVLW  3D
061FE:  MOVWF  x68
06200:  MOVLB  0
06202:  CALL   3844
....................       // if the message doesn't return no error, try sending again 
....................       while ((res_byte != NO_ERR) && !TMR0IF);        
06206:  MOVLB  5
06208:  MOVF   x5E,F
0620A:  BZ    6210
0620C:  BTFSS  FF2.2
0620E:  BRA    6208
....................       if (TMR0IF) 
06210:  BTFSS  FF2.2
06212:  BRA    6218
....................          continue; 
06214:  BRA    621A
06216:  BRA    621A
....................       else 
....................          break; 
06218:  BRA    621E
0621A:  INCF   x5D,F
0621C:  BRA    61EA
....................    } 
0621E:  MOVLB  0
06220:  RETURN 0
.................... } 
.................... void generate_message_and_send_ISR() 
.................... { 
....................    uint8_t n, res_byte; 
....................    // generate the message 
....................    dust_hdlc_pkgen_ISR(send_prefix, 12, payload_buff, send_prefix[11]); 
*
0244E:  MOVLW  03
02450:  MOVLB  5
02452:  MOVWF  xA0
02454:  MOVLW  53
02456:  MOVWF  x9F
02458:  MOVLW  0C
0245A:  MOVWF  xA1
0245C:  MOVLW  02
0245E:  MOVWF  xA3
02460:  MOVLW  F3
02462:  MOVWF  xA2
02464:  MOVFF  35E,5A4
02468:  MOVLB  0
0246A:  CALL   0EE4
....................                                     
....................    // try to send the message a 3 times 
....................    for (n = 0; n < 3; n++) 
0246E:  MOVLB  5
02470:  CLRF   x93
02472:  MOVF   x93,W
02474:  SUBLW  02
02476:  BNC   24A6
....................    { 
....................       // try to send the message 
....................       res_byte = dust_hdlc_pksend_ISR();    
02478:  MOVLB  0
0247A:  CALL   11A6
0247E:  MOVFF  01,594
....................       // timeout of 50ms if pksend returns an error 
....................       setup_T4_int(T4_50MS);  
02482:  MOVLW  C7
02484:  MOVLB  5
02486:  MOVWF  xA4
02488:  MOVLB  0
0248A:  CALL   0944
....................       // if the message doesn't return no error, try sending again 
....................       while ((res_byte != NO_ERR) && !TMR0IF);        
0248E:  MOVLB  5
02490:  MOVF   x94,F
02492:  BZ    2498
02494:  BTFSS  FF2.2
02496:  BRA    2490
....................       if (TMR4IF) 
02498:  BTFSS  F7E.0
0249A:  BRA    24A0
....................          continue; 
0249C:  BRA    24A2
0249E:  BRA    24A2
....................       else 
....................          break; 
024A0:  BRA    24A6
024A2:  INCF   x93,F
024A4:  BRA    2472
....................    } 
024A6:  MOVLB  0
024A8:  RETURN 0
.................... } 
....................  
.................... void send_full_report_ISR(uint8_t command_id_in_response_to, uint16_t msg_seq) 
.................... { 
....................    uint16_t temp_u16; 
....................    //flash led to help identifying motes 
....................    LED2_ON; 
....................    prepare_prefix_and_payload(58); 
....................    payload_buff[4] = make8(msg_seq,0); 
....................    payload_buff[5] = make8(msg_seq,1); 
....................    payload_buff[6] = command_id_in_response_to; 
....................    payload_buff[7] = MSG_MOTE_FULL_REPORT; 
....................    payload_buff[8] = make8(global_sprinkler_num, 0); 
....................    payload_buff[9] = make8(global_sprinkler_num, 1); 
....................    payload_buff[10] = global_hardware_enabled; 
....................    payload_buff[11] = read_system_state(); 
....................    // vbatt(unchanged charge state) 
.................... //   temp_u16 = get_vbatt_ISR(0); 
....................    temp_u16 = 0; 
....................    payload_buff[12] = make8(temp_u16, 0); 
....................    payload_buff[13] = make8(temp_u16, 1); 
....................    // vbatt(no charging)        
.................... //   temp_u16 = get_vbatt_ISR(1); 
....................    temp_u16 = 0; 
....................    payload_buff[14] = make8(temp_u16, 0); 
....................    payload_buff[15] = make8(temp_u16, 1); 
....................    // vgen(unchanged charge state) 
.................... //   temp_u16 = get_vgen_ISR(0); 
....................    temp_u16 = 0; 
....................    payload_buff[16] = make8(temp_u16, 0); 
....................    payload_buff[17] = make8(temp_u16, 1);       
....................    /* 
....................    disable_interrupts(INT_CCP5);              
....................    temp_u16 = convert_period_to_rpm(global_current_period); 
....................    enable_interrupts(INT_CCP5); 
....................    */ 
....................    temp_u16 = 0; 
....................    payload_buff[18] = make8(temp_u16, 0); 
....................    payload_buff[19] = make8(temp_u16, 1);                
....................    payload_buff[20] = make8(global_rpm_set_value,0); 
....................    payload_buff[21] = make8(global_rpm_set_value,1); 
....................    disable_interrupts(INT_CCP4); 
....................    if (global_current_sprinkler_queue_location != 255) 
....................    { 
....................       payload_buff[22] = make8(global_sprinkler_queue[global_current_sprinkler_queue_location].spin_rate,0); 
....................       payload_buff[23] = make8(global_sprinkler_queue[global_current_sprinkler_queue_location].spin_rate,1); 
....................    } 
....................    else 
....................    { 
....................       payload_buff[22] = 0; 
....................       payload_buff[23] = 0; 
....................    } 
....................    payload_buff[24] = make8(global_brake_duty,0); 
....................    payload_buff[25] = make8(global_brake_duty,1); 
....................    payload_buff[26] = make8(global_brake_duty_set_value,0); 
....................    payload_buff[27] = make8(global_brake_duty_set_value,1); 
....................    payload_buff[28] = make8(global_charge_duty,0); 
....................    payload_buff[29] = make8(global_charge_duty,1); 
....................    payload_buff[30] = make8(global_charge_duty_set_value,0); 
....................    payload_buff[31] = make8(global_charge_duty_set_value,1); 
....................    payload_buff[32] = global_mppc_value; 
....................    payload_buff[33] = global_control_loop_mechanism; 
....................    payload_buff[34] = make8(global_calibrate_fsr_valve_position, 0); 
....................    payload_buff[35] = make8(global_calibrate_fsr_valve_position, 1); 
....................    temp_u16 = convert_period_to_rpm(global_calibrate_fsr_period); 
....................    payload_buff[36] = make8(temp_u16, 0); 
....................    payload_buff[37] = make8(temp_u16, 1); 
....................    payload_buff[38] = LATE; 
....................    payload_buff[39] = make8(global_valve_position,0); 
....................    payload_buff[40] = make8(global_valve_position,1); 
....................    payload_buff[41] = make8(global_valve_position_set_value,0); 
....................    payload_buff[42] = make8(global_valve_position_set_value,1); 
....................    if (global_current_sprinkler_queue_location != 255) 
....................    { 
....................       payload_buff[43] = make8(global_sprinkler_queue[global_current_sprinkler_queue_location].vlv_open_amount,0); 
....................       payload_buff[44] = make8(global_sprinkler_queue[global_current_sprinkler_queue_location].vlv_open_amount,1); 
....................       payload_buff[45] = make8(global_sprinkler_queue[global_current_sprinkler_queue_location].start_time,0); 
....................       payload_buff[46] = make8(global_sprinkler_queue[global_current_sprinkler_queue_location].start_time,1); 
....................       payload_buff[47] = make8(global_sprinkler_queue[global_current_sprinkler_queue_location].start_time,2); 
....................       payload_buff[48] = make8(global_sprinkler_queue[global_current_sprinkler_queue_location].start_time,3); 
....................    } 
....................    else 
....................    { 
....................       payload_buff[43] = 0; 
....................       payload_buff[44] = 0; 
....................       payload_buff[45] = 0; 
....................       payload_buff[46] = 0; 
....................       payload_buff[47] = 0; 
....................       payload_buff[48] = 0; 
....................    } 
....................    enable_interrupts(INT_CCP4); 
....................    payload_buff[49] = make8(global_xdcr_output, 0); 
....................    payload_buff[50] = make8(global_xdcr_output, 1); 
....................       //  JG: changed from mote uptime to boot time 
....................    payload_buff[51] = make8(global_first_utc_time,0); 
....................    payload_buff[52] = make8(global_first_utc_time,1); 
....................    payload_buff[53] = make8(global_first_utc_time,2); 
....................    payload_buff[54] = make8(global_first_utc_time,3); 
....................    /* 
....................    payload_buff[51] = make8(global_rtc_time,0); 
....................    payload_buff[52] = make8(global_rtc_time,1); 
....................    payload_buff[53] = make8(global_rtc_time,2); 
....................    payload_buff[54] = make8(global_rtc_time,3); 
....................    */ 
....................    payload_buff[55] = global_previous_shutdown_cause; 
....................    payload_buff[56] = make8(FIRMWARE_VERSION,0); 
....................    payload_buff[57] = make8(FIRMWARE_VERSION,1); 
....................  
....................    generate_message_and_send(); 
....................    LED2_OFF; 
.................... } 
....................  
.................... void send_full_report(uint8_t command_id_in_response_to, uint16_t msg_seq) 
.................... { 
....................    uint16_t temp_u16; 
....................    //flash led to help identifying motes  
....................    prepare_prefix_and_payload(58); 
*
06222:  MOVLW  3A
06224:  MOVLB  5
06226:  MOVWF  x5D
06228:  MOVLB  0
0622A:  RCALL  5DB0
....................    payload_buff[4] = make8(msg_seq,0); 
0622C:  MOVFF  553,2F7
06230:  MOVLB  2
....................    payload_buff[5] = make8(msg_seq,1); 
06232:  MOVFF  554,2F8
06236:  MOVLB  2
....................    payload_buff[6] = command_id_in_response_to; 
06238:  MOVFF  552,2F9
....................    payload_buff[7] = MSG_MOTE_FULL_REPORT; 
0623C:  MOVLW  90
0623E:  MOVWF  xFA
....................    payload_buff[8] = make8(global_sprinkler_num, 0); 
06240:  MOVFF  95,2FB
06244:  MOVLB  2
....................    payload_buff[9] = make8(global_sprinkler_num, 1); 
06246:  MOVFF  96,2FC
0624A:  MOVLB  2
....................    payload_buff[10] = global_hardware_enabled; 
0624C:  MOVFF  A7,2FD
....................    payload_buff[11] = read_system_state(); 
06250:  MOVLB  0
06252:  CALL   1F02
06256:  MOVFF  01,2FE
....................    // vbatt(unchanged charge state) 
....................    temp_u16 = get_vbatt(0); 
0625A:  MOVLB  5
0625C:  CLRF   x68
0625E:  MOVLB  0
06260:  CALL   4236
06264:  MOVFF  02,556
06268:  MOVFF  01,555
....................    payload_buff[12] = make8(temp_u16, 0); 
0626C:  MOVFF  555,2FF
06270:  MOVLB  2
....................    payload_buff[13] = make8(temp_u16, 1); 
06272:  MOVFF  556,300
06276:  MOVLB  3
....................    // vbatt(no charging)        
....................    temp_u16 = get_vbatt(1); 
06278:  MOVLW  01
0627A:  MOVLB  5
0627C:  MOVWF  x68
0627E:  MOVLB  0
06280:  CALL   4236
06284:  MOVFF  02,556
06288:  MOVFF  01,555
....................    payload_buff[14] = make8(temp_u16, 0); 
0628C:  MOVFF  555,301
06290:  MOVLB  3
....................    payload_buff[15] = make8(temp_u16, 1); 
06292:  MOVFF  556,302
06296:  MOVLB  3
....................    // vgen(unchanged charge state) 
....................    temp_u16 = get_vgen(0); 
06298:  MOVLB  5
0629A:  CLRF   x57
0629C:  MOVLB  0
0629E:  CALL   4290
062A2:  MOVFF  02,556
062A6:  MOVFF  01,555
....................    payload_buff[16] = make8(temp_u16, 0); 
062AA:  MOVFF  555,303
062AE:  MOVLB  3
....................    payload_buff[17] = make8(temp_u16, 1);       
062B0:  MOVFF  556,304
062B4:  MOVLB  3
....................    disable_interrupts(INT_CCP5);              
062B6:  BCF    F7A.2
....................    temp_u16 = convert_period_to_rpm(global_current_period); 
062B8:  MOVFF  A9,558
062BC:  MOVFF  A8,557
062C0:  MOVLB  0
062C2:  RCALL  5DF2
062C4:  MOVFF  02,556
062C8:  MOVFF  01,555
....................    enable_interrupts(INT_CCP5); 
062CC:  BSF    F7A.2
....................    payload_buff[18] = make8(temp_u16, 0); 
062CE:  MOVFF  555,305
062D2:  MOVLB  3
....................    payload_buff[19] = make8(temp_u16, 1);                
062D4:  MOVFF  556,306
062D8:  MOVLB  3
....................    payload_buff[20] = make8(global_rpm_set_value,0); 
062DA:  MOVFF  AC,307
062DE:  MOVLB  3
....................    payload_buff[21] = make8(global_rpm_set_value,1); 
062E0:  MOVFF  AD,308
062E4:  MOVLB  3
....................    disable_interrupts(INT_CCP4); 
062E6:  BCF    F7A.1
....................    if (global_current_sprinkler_queue_location != 255) 
062E8:  MOVLB  4
062EA:  INCFSZ x29,W
062EC:  BRA    62F0
062EE:  BRA    6356
....................    { 
....................       payload_buff[22] = make8(global_sprinkler_queue[global_current_sprinkler_queue_location].spin_rate,0); 
062F0:  MOVF   x29,W
062F2:  MULLW  0E
062F4:  MOVF   FF3,W
062F6:  MOVLB  5
062F8:  CLRF   x58
062FA:  MOVWF  x57
062FC:  MOVLW  0A
062FE:  ADDWF  x57,W
06300:  MOVWF  01
06302:  MOVLW  00
06304:  ADDWFC x58,W
06306:  MOVWF  03
06308:  MOVF   01,W
0630A:  ADDLW  9D
0630C:  MOVWF  FE9
0630E:  MOVLW  03
06310:  ADDWFC 03,W
06312:  MOVWF  FEA
06314:  MOVFF  FEC,558
06318:  MOVF   FED,F
0631A:  MOVFF  FEF,309
0631E:  MOVLB  3
....................       payload_buff[23] = make8(global_sprinkler_queue[global_current_sprinkler_queue_location].spin_rate,1); 
06320:  MOVLB  4
06322:  MOVF   x29,W
06324:  MULLW  0E
06326:  MOVF   FF3,W
06328:  MOVLB  5
0632A:  CLRF   x58
0632C:  MOVWF  x57
0632E:  MOVLW  0A
06330:  ADDWF  x57,W
06332:  MOVWF  01
06334:  MOVLW  00
06336:  ADDWFC x58,W
06338:  MOVWF  03
0633A:  MOVF   01,W
0633C:  ADDLW  9D
0633E:  MOVWF  FE9
06340:  MOVLW  03
06342:  ADDWFC 03,W
06344:  MOVWF  FEA
06346:  MOVFF  FEC,30A
0634A:  MOVF   FED,F
0634C:  MOVFF  FEF,557
06350:  MOVLB  3
....................    } 
06352:  BRA    635C
06354:  MOVLB  4
....................    else 
....................    { 
....................       payload_buff[22] = 0; 
06356:  MOVLB  3
06358:  CLRF   x09
....................       payload_buff[23] = 0; 
0635A:  CLRF   x0A
....................    } 
....................    payload_buff[24] = make8(global_brake_duty,0); 
0635C:  MOVFF  B2,30B
06360:  MOVLB  3
....................    payload_buff[25] = make8(global_brake_duty,1); 
06362:  MOVFF  B3,30C
06366:  MOVLB  3
....................    payload_buff[26] = make8(global_brake_duty_set_value,0); 
06368:  MOVFF  B6,30D
0636C:  MOVLB  3
....................    payload_buff[27] = make8(global_brake_duty_set_value,1); 
0636E:  MOVFF  B7,30E
06372:  MOVLB  3
....................    payload_buff[28] = make8(global_charge_duty,0); 
06374:  MOVFF  B4,30F
06378:  MOVLB  3
....................    payload_buff[29] = make8(global_charge_duty,1); 
0637A:  MOVFF  B5,310
0637E:  MOVLB  3
....................    payload_buff[30] = make8(global_charge_duty_set_value,0); 
06380:  MOVFF  B8,311
06384:  MOVLB  3
....................    payload_buff[31] = make8(global_charge_duty_set_value,1); 
06386:  MOVFF  B9,312
0638A:  MOVLB  3
....................    payload_buff[32] = global_mppc_value; 
0638C:  MOVFF  BA,313
....................    payload_buff[33] = global_control_loop_mechanism; 
06390:  MOVFF  C0,314
....................    payload_buff[34] = make8(global_calibrate_fsr_valve_position, 0); 
06394:  MOVFF  D0,315
06398:  MOVLB  3
....................    payload_buff[35] = make8(global_calibrate_fsr_valve_position, 1); 
0639A:  MOVFF  D1,316
0639E:  MOVLB  3
....................    temp_u16 = convert_period_to_rpm(global_calibrate_fsr_period); 
063A0:  MOVFF  D3,558
063A4:  MOVFF  D2,557
063A8:  MOVLB  0
063AA:  RCALL  5DF2
063AC:  MOVFF  02,556
063B0:  MOVFF  01,555
....................    payload_buff[36] = make8(temp_u16, 0); 
063B4:  MOVFF  555,317
063B8:  MOVLB  3
....................    payload_buff[37] = make8(temp_u16, 1); 
063BA:  MOVFF  556,318
063BE:  MOVLB  3
....................    payload_buff[38] = LATE; 
063C0:  MOVFF  F8D,319
....................    payload_buff[39] = make8(global_valve_position,0); 
063C4:  MOVFF  C1,31A
063C8:  MOVLB  3
....................    payload_buff[40] = make8(global_valve_position,1); 
063CA:  MOVFF  C2,31B
063CE:  MOVLB  3
....................    payload_buff[41] = make8(global_valve_position_set_value,0); 
063D0:  MOVFF  C3,31C
063D4:  MOVLB  3
....................    payload_buff[42] = make8(global_valve_position_set_value,1); 
063D6:  MOVFF  C4,31D
063DA:  MOVLB  3
....................    if (global_current_sprinkler_queue_location != 255) 
063DC:  MOVLB  4
063DE:  INCFSZ x29,W
063E0:  BRA    63E4
063E2:  BRA    64FA
....................    { 
....................       payload_buff[43] = make8(global_sprinkler_queue[global_current_sprinkler_queue_location].vlv_open_amount,0); 
063E4:  MOVF   x29,W
063E6:  MULLW  0E
063E8:  MOVF   FF3,W
063EA:  MOVLB  5
063EC:  CLRF   x58
063EE:  MOVWF  x57
063F0:  MOVLW  08
063F2:  ADDWF  x57,W
063F4:  MOVWF  01
063F6:  MOVLW  00
063F8:  ADDWFC x58,W
063FA:  MOVWF  03
063FC:  MOVF   01,W
063FE:  ADDLW  9D
06400:  MOVWF  FE9
06402:  MOVLW  03
06404:  ADDWFC 03,W
06406:  MOVWF  FEA
06408:  MOVFF  FEC,558
0640C:  MOVF   FED,F
0640E:  MOVFF  FEF,31E
06412:  MOVLB  3
....................       payload_buff[44] = make8(global_sprinkler_queue[global_current_sprinkler_queue_location].vlv_open_amount,1); 
06414:  MOVLB  4
06416:  MOVF   x29,W
06418:  MULLW  0E
0641A:  MOVF   FF3,W
0641C:  MOVLB  5
0641E:  CLRF   x58
06420:  MOVWF  x57
06422:  MOVLW  08
06424:  ADDWF  x57,W
06426:  MOVWF  01
06428:  MOVLW  00
0642A:  ADDWFC x58,W
0642C:  MOVWF  03
0642E:  MOVF   01,W
06430:  ADDLW  9D
06432:  MOVWF  FE9
06434:  MOVLW  03
06436:  ADDWFC 03,W
06438:  MOVWF  FEA
0643A:  MOVFF  FEC,31F
0643E:  MOVF   FED,F
06440:  MOVFF  FEF,557
06444:  MOVLB  3
....................       payload_buff[45] = make8(global_sprinkler_queue[global_current_sprinkler_queue_location].start_time,0); 
06446:  MOVLB  4
06448:  MOVF   x29,W
0644A:  MULLW  0E
0644C:  MOVF   FF3,W
0644E:  MOVLB  5
06450:  CLRF   x58
06452:  MOVWF  x57
06454:  MOVLW  9D
06456:  ADDWF  x57,W
06458:  MOVWF  FE9
0645A:  MOVLW  03
0645C:  ADDWFC x58,W
0645E:  MOVWF  FEA
06460:  MOVFF  FEF,320
06464:  MOVFF  FEC,55A
06468:  MOVFF  FEC,55B
0646C:  MOVFF  FEC,55C
06470:  MOVLB  3
....................       payload_buff[46] = make8(global_sprinkler_queue[global_current_sprinkler_queue_location].start_time,1); 
06472:  MOVLB  4
06474:  MOVF   x29,W
06476:  MULLW  0E
06478:  MOVF   FF3,W
0647A:  MOVLB  5
0647C:  CLRF   x58
0647E:  MOVWF  x57
06480:  MOVLW  9D
06482:  ADDWF  x57,W
06484:  MOVWF  FE9
06486:  MOVLW  03
06488:  ADDWFC x58,W
0648A:  MOVWF  FEA
0648C:  MOVFF  FEF,559
06490:  MOVFF  FEC,321
06494:  MOVFF  FEC,55B
06498:  MOVFF  FEC,55C
0649C:  MOVLB  3
....................       payload_buff[47] = make8(global_sprinkler_queue[global_current_sprinkler_queue_location].start_time,2); 
0649E:  MOVLB  4
064A0:  MOVF   x29,W
064A2:  MULLW  0E
064A4:  MOVF   FF3,W
064A6:  MOVLB  5
064A8:  CLRF   x58
064AA:  MOVWF  x57
064AC:  MOVLW  9D
064AE:  ADDWF  x57,W
064B0:  MOVWF  FE9
064B2:  MOVLW  03
064B4:  ADDWFC x58,W
064B6:  MOVWF  FEA
064B8:  MOVFF  FEF,559
064BC:  MOVFF  FEC,55A
064C0:  MOVFF  FEC,322
064C4:  MOVFF  FEC,55C
064C8:  MOVLB  3
....................       payload_buff[48] = make8(global_sprinkler_queue[global_current_sprinkler_queue_location].start_time,3); 
064CA:  MOVLB  4
064CC:  MOVF   x29,W
064CE:  MULLW  0E
064D0:  MOVF   FF3,W
064D2:  MOVLB  5
064D4:  CLRF   x58
064D6:  MOVWF  x57
064D8:  MOVLW  9D
064DA:  ADDWF  x57,W
064DC:  MOVWF  FE9
064DE:  MOVLW  03
064E0:  ADDWFC x58,W
064E2:  MOVWF  FEA
064E4:  MOVFF  FEF,559
064E8:  MOVFF  FEC,55A
064EC:  MOVFF  FEC,55B
064F0:  MOVFF  FEC,323
064F4:  MOVLB  3
....................    } 
064F6:  BRA    6508
064F8:  MOVLB  4
....................    else 
....................    { 
....................       payload_buff[43] = 0; 
064FA:  MOVLB  3
064FC:  CLRF   x1E
....................       payload_buff[44] = 0; 
064FE:  CLRF   x1F
....................       payload_buff[45] = 0; 
06500:  CLRF   x20
....................       payload_buff[46] = 0; 
06502:  CLRF   x21
....................       payload_buff[47] = 0; 
06504:  CLRF   x22
....................       payload_buff[48] = 0; 
06506:  CLRF   x23
....................    } 
....................    enable_interrupts(INT_CCP4); 
06508:  BSF    F7A.1
....................    payload_buff[49] = make8(global_xdcr_output, 0); 
0650A:  MOVFF  4B,324
....................    payload_buff[50] = make8(global_xdcr_output, 1); 
0650E:  MOVFF  4C,325
....................       //  JG: changed from mote uptime to boot time 
....................    payload_buff[51] = make8(global_first_utc_time,0); 
06512:  MOVFF  8D,326
06516:  MOVLB  3
....................    payload_buff[52] = make8(global_first_utc_time,1); 
06518:  MOVFF  8E,327
0651C:  MOVLB  3
....................    payload_buff[53] = make8(global_first_utc_time,2); 
0651E:  MOVFF  8F,328
06522:  MOVLB  3
....................    payload_buff[54] = make8(global_first_utc_time,3); 
06524:  MOVFF  90,329
06528:  MOVLB  3
....................    /* 
....................    payload_buff[51] = make8(global_rtc_time,0); 
....................    payload_buff[52] = make8(global_rtc_time,1); 
....................    payload_buff[53] = make8(global_rtc_time,2); 
....................    payload_buff[54] = make8(global_rtc_time,3); 
....................    */ 
....................    payload_buff[55] = global_previous_shutdown_cause; 
0652A:  MOVFF  4E,32A
....................    payload_buff[56] = make8(FIRMWARE_VERSION,0); 
0652E:  MOVLW  14
06530:  MOVWF  x2B
....................    payload_buff[57] = make8(FIRMWARE_VERSION,1); 
06532:  MOVLW  E3
06534:  MOVWF  x2C
....................  
....................    generate_message_and_send(); 
06536:  MOVLB  0
06538:  RCALL  61C8
0653A:  RETURN 0
.................... } 
.................... void send_health_report(uint8_t command_id_in_response_to, uint16_t msg_seq) 
.................... {   
....................    uint16_t temp_u16; 
....................     
....................    prepare_prefix_and_payload(18); 
0653C:  MOVLW  12
0653E:  MOVLB  5
06540:  MOVWF  x5D
06542:  MOVLB  0
06544:  RCALL  5DB0
....................    payload_buff[4] = make8(msg_seq,0); 
06546:  MOVFF  553,2F7
0654A:  MOVLB  2
....................    payload_buff[5] = make8(msg_seq,1); 
0654C:  MOVFF  554,2F8
06550:  MOVLB  2
....................    payload_buff[6] = command_id_in_response_to; 
06552:  MOVFF  552,2F9
....................    payload_buff[7] = MSG_MOTE_HEALTH_REPORT; 
06556:  MOVLW  91
06558:  MOVWF  xFA
....................    payload_buff[8] = make8(global_sprinkler_num, 0); 
0655A:  MOVFF  95,2FB
0655E:  MOVLB  2
....................    payload_buff[9] = make8(global_sprinkler_num, 1); 
06560:  MOVFF  96,2FC
06564:  MOVLB  2
....................    payload_buff[10] = global_hardware_enabled; 
06566:  MOVFF  A7,2FD
....................    payload_buff[11] = read_system_state(); 
0656A:  MOVLB  0
0656C:  CALL   1F02
06570:  MOVFF  01,2FE
....................    // vbatt(unchanged charge state) 
....................    temp_u16 = get_vbatt(0); 
06574:  MOVLB  5
06576:  CLRF   x68
06578:  MOVLB  0
0657A:  CALL   4236
0657E:  MOVFF  02,556
06582:  MOVFF  01,555
....................    payload_buff[12] = make8(temp_u16, 0); 
06586:  MOVFF  555,2FF
0658A:  MOVLB  2
....................    payload_buff[13] = make8(temp_u16, 1); 
0658C:  MOVFF  556,300
06590:  MOVLB  3
....................    // vbatt(no charging) 
....................    temp_u16 = get_vbatt(1); 
06592:  MOVLW  01
06594:  MOVLB  5
06596:  MOVWF  x68
06598:  MOVLB  0
0659A:  CALL   4236
0659E:  MOVFF  02,556
065A2:  MOVFF  01,555
....................    payload_buff[14] = make8(temp_u16, 0); 
065A6:  MOVFF  555,301
065AA:  MOVLB  3
....................    payload_buff[15] = make8(temp_u16, 1); 
065AC:  MOVFF  556,302
065B0:  MOVLB  3
....................    payload_buff[16] = global_valve_movements_since_endstop; 
065B2:  MOVFF  CF,303
....................    // grab the most recent temperature 
....................    payload_buff[17] = global_mote_temperature; 
065B6:  MOVFF  36D,304
....................    generate_message_and_send(); 
065BA:  MOVLB  0
065BC:  RCALL  61C8
065BE:  GOTO   71C2 (RETURN)
.................... } 
.................... void send_valve_report(uint8_t command_id_in_response_to, uint16_t msg_seq) 
.................... { 
....................    uint16_t temp_u16; 
....................     
....................    prepare_prefix_and_payload(28); 
065C2:  MOVLW  1C
065C4:  MOVLB  5
065C6:  MOVWF  x5D
065C8:  MOVLB  0
065CA:  CALL   5DB0
....................    payload_buff[4] = make8(msg_seq,0); 
065CE:  MOVFF  553,2F7
065D2:  MOVLB  2
....................    payload_buff[5] = make8(msg_seq,1); 
065D4:  MOVFF  554,2F8
065D8:  MOVLB  2
....................    payload_buff[6] = command_id_in_response_to;                                                         
065DA:  MOVFF  552,2F9
....................    payload_buff[7] = MSG_MOTE_VALVE_REPORT;  
065DE:  MOVLW  92
065E0:  MOVWF  xFA
....................    payload_buff[8] = make8(global_sprinkler_num, 0); 
065E2:  MOVFF  95,2FB
065E6:  MOVLB  2
....................    payload_buff[9] = make8(global_sprinkler_num, 1); 
065E8:  MOVFF  96,2FC
065EC:  MOVLB  2
....................    payload_buff[10] = make8(global_valve_position, 0); 
065EE:  MOVFF  C1,2FD
065F2:  MOVLB  2
....................    payload_buff[11] = make8(global_valve_position, 1); 
065F4:  MOVFF  C2,2FE
065F8:  MOVLB  2
....................    payload_buff[12] = make8((global_valve_time_to_open_1024th << 4), 0); 
065FA:  MOVLB  0
065FC:  RLCF   xC7,W
065FE:  MOVLB  5
06600:  MOVWF  x57
06602:  MOVLB  0
06604:  RLCF   xC8,W
06606:  MOVLB  5
06608:  MOVWF  x58
0660A:  RLCF   x57,F
0660C:  RLCF   x58,F
0660E:  RLCF   x57,F
06610:  RLCF   x58,F
06612:  RLCF   x57,F
06614:  RLCF   x58,F
06616:  MOVLW  F0
06618:  ANDWF  x57,F
0661A:  MOVFF  557,2FF
0661E:  MOVLB  2
....................    payload_buff[13] = make8((global_valve_time_to_open_1024th << 4), 1); 
06620:  MOVLB  0
06622:  RLCF   xC7,W
06624:  MOVLB  5
06626:  MOVWF  x57
06628:  MOVLB  0
0662A:  RLCF   xC8,W
0662C:  MOVLB  5
0662E:  MOVWF  x58
06630:  RLCF   x57,F
06632:  RLCF   x58,F
06634:  RLCF   x57,F
06636:  RLCF   x58,F
06638:  RLCF   x57,F
0663A:  RLCF   x58,F
0663C:  MOVLW  F0
0663E:  ANDWF  x57,F
06640:  MOVFF  558,300
06644:  MOVLB  3
....................    payload_buff[14] = make8((global_valve_time_to_close_1024th << 4), 0); 
06646:  MOVLB  0
06648:  RLCF   xC5,W
0664A:  MOVLB  5
0664C:  MOVWF  x57
0664E:  MOVLB  0
06650:  RLCF   xC6,W
06652:  MOVLB  5
06654:  MOVWF  x58
06656:  RLCF   x57,F
06658:  RLCF   x58,F
0665A:  RLCF   x57,F
0665C:  RLCF   x58,F
0665E:  RLCF   x57,F
06660:  RLCF   x58,F
06662:  MOVLW  F0
06664:  ANDWF  x57,F
06666:  MOVFF  557,301
0666A:  MOVLB  3
....................    payload_buff[15] = make8((global_valve_time_to_close_1024th << 4), 1); 
0666C:  MOVLB  0
0666E:  RLCF   xC5,W
06670:  MOVLB  5
06672:  MOVWF  x57
06674:  MOVLB  0
06676:  RLCF   xC6,W
06678:  MOVLB  5
0667A:  MOVWF  x58
0667C:  RLCF   x57,F
0667E:  RLCF   x58,F
06680:  RLCF   x57,F
06682:  RLCF   x58,F
06684:  RLCF   x57,F
06686:  RLCF   x58,F
06688:  MOVLW  F0
0668A:  ANDWF  x57,F
0668C:  MOVFF  558,302
06690:  MOVLB  3
....................    payload_buff[16] = make8(global_valve_calibration_utc_time, 0); 
06692:  MOVFF  CB,303
06696:  MOVLB  3
....................    payload_buff[17] = make8(global_valve_calibration_utc_time, 1); 
06698:  MOVFF  CC,304
0669C:  MOVLB  3
....................    payload_buff[18] = make8(global_valve_calibration_utc_time, 2); 
0669E:  MOVFF  CD,305
066A2:  MOVLB  3
....................    payload_buff[19] = make8(global_valve_calibration_utc_time, 3); 
066A4:  MOVFF  CE,306
066A8:  MOVLB  3
....................    payload_buff[20] = make8(global_calibrate_fsr_valve_position, 0); 
066AA:  MOVFF  D0,307
066AE:  MOVLB  3
....................    payload_buff[21] = make8(global_calibrate_fsr_valve_position, 1); 
066B0:  MOVFF  D1,308
066B4:  MOVLB  3
....................    temp_u16 = convert_period_to_rpm(global_calibrate_fsr_period); 
066B6:  MOVFF  D3,558
066BA:  MOVFF  D2,557
066BE:  MOVLB  0
066C0:  CALL   5DF2
066C4:  MOVFF  02,556
066C8:  MOVFF  01,555
....................    payload_buff[22] = make8(temp_u16, 0); 
066CC:  MOVFF  555,309
066D0:  MOVLB  3
....................    payload_buff[23] = make8(temp_u16, 1); 
066D2:  MOVFF  556,30A
066D6:  MOVLB  3
....................    payload_buff[24] = make8(global_calibrate_fsr_utc_time, 0); 
066D8:  MOVFF  D4,30B
066DC:  MOVLB  3
....................    payload_buff[25] = make8(global_calibrate_fsr_utc_time, 1); 
066DE:  MOVFF  D5,30C
066E2:  MOVLB  3
....................    payload_buff[26] = make8(global_calibrate_fsr_utc_time, 2); 
066E4:  MOVFF  D6,30D
066E8:  MOVLB  3
....................    payload_buff[27] = make8(global_calibrate_fsr_utc_time, 3); 
066EA:  MOVFF  D7,30E
066EE:  MOVLB  3
....................    generate_message_and_send(); 
066F0:  MOVLB  0
066F2:  RCALL  61C8
066F4:  RETURN 0
.................... } 
.................... void send_sprinkler_cmd_response(uint8_t command_id_in_response_to, uint16_t msg_seq) 
.................... { 
....................    uint16_t temp_u16; 
....................     
....................    prepare_prefix_and_payload(25); 
*
06E92:  MOVLW  19
06E94:  MOVLB  5
06E96:  MOVWF  x5D
06E98:  MOVLB  0
06E9A:  CALL   5DB0
....................    payload_buff[4] = make8(msg_seq,0); 
06E9E:  MOVFF  553,2F7
06EA2:  MOVLB  2
....................    payload_buff[5] = make8(msg_seq,1); 
06EA4:  MOVFF  554,2F8
06EA8:  MOVLB  2
....................    payload_buff[6] = command_id_in_response_to; 
06EAA:  MOVFF  552,2F9
....................    payload_buff[7] = MSG_MOTE_SPINKLER_CMD_RESPONSE; 
06EAE:  MOVLW  93
06EB0:  MOVWF  xFA
....................    payload_buff[8] = make8(global_sprinkler_num, 0); 
06EB2:  MOVFF  95,2FB
06EB6:  MOVLB  2
....................    payload_buff[9] = make8(global_sprinkler_num, 1); 
06EB8:  MOVFF  96,2FC
06EBC:  MOVLB  2
....................    payload_buff[10] = global_hardware_enabled; 
06EBE:  MOVFF  A7,2FD
....................    payload_buff[11] = make8(global_rpm_set_value, 0); 
06EC2:  MOVFF  AC,2FE
06EC6:  MOVLB  2
....................    payload_buff[12] = make8(global_rpm_set_value, 1); 
06EC8:  MOVFF  AD,2FF
06ECC:  MOVLB  2
....................    disable_interrupts(INT_CCP4); 
06ECE:  BCF    F7A.1
....................    if (global_current_sprinkler_queue_location != 255) 
06ED0:  MOVLB  4
06ED2:  INCFSZ x29,W
06ED4:  BRA    6ED8
06ED6:  BRA    6F3E
....................    { 
....................       payload_buff[13] = make8(global_sprinkler_queue[global_current_sprinkler_queue_location].spin_rate,0); 
06ED8:  MOVF   x29,W
06EDA:  MULLW  0E
06EDC:  MOVF   FF3,W
06EDE:  MOVLB  5
06EE0:  CLRF   x58
06EE2:  MOVWF  x57
06EE4:  MOVLW  0A
06EE6:  ADDWF  x57,W
06EE8:  MOVWF  01
06EEA:  MOVLW  00
06EEC:  ADDWFC x58,W
06EEE:  MOVWF  03
06EF0:  MOVF   01,W
06EF2:  ADDLW  9D
06EF4:  MOVWF  FE9
06EF6:  MOVLW  03
06EF8:  ADDWFC 03,W
06EFA:  MOVWF  FEA
06EFC:  MOVFF  FEC,558
06F00:  MOVF   FED,F
06F02:  MOVFF  FEF,300
06F06:  MOVLB  3
....................       payload_buff[14] = make8(global_sprinkler_queue[global_current_sprinkler_queue_location].spin_rate,1); 
06F08:  MOVLB  4
06F0A:  MOVF   x29,W
06F0C:  MULLW  0E
06F0E:  MOVF   FF3,W
06F10:  MOVLB  5
06F12:  CLRF   x58
06F14:  MOVWF  x57
06F16:  MOVLW  0A
06F18:  ADDWF  x57,W
06F1A:  MOVWF  01
06F1C:  MOVLW  00
06F1E:  ADDWFC x58,W
06F20:  MOVWF  03
06F22:  MOVF   01,W
06F24:  ADDLW  9D
06F26:  MOVWF  FE9
06F28:  MOVLW  03
06F2A:  ADDWFC 03,W
06F2C:  MOVWF  FEA
06F2E:  MOVFF  FEC,301
06F32:  MOVF   FED,F
06F34:  MOVFF  FEF,557
06F38:  MOVLB  3
....................    } 
06F3A:  BRA    6F44
06F3C:  MOVLB  4
....................    else 
....................    { 
....................       payload_buff[13] = 0; 
06F3E:  MOVLB  3
06F40:  CLRF   x00
....................       payload_buff[14] = 0; 
06F42:  CLRF   x01
....................    } 
....................    payload_buff[15] = make8(global_valve_position_set_value,0); 
06F44:  MOVFF  C3,302
06F48:  MOVLB  3
....................    payload_buff[16] = make8(global_valve_position_set_value,1); 
06F4A:  MOVFF  C4,303
06F4E:  MOVLB  3
....................    if (global_current_sprinkler_queue_location != 255) 
06F50:  MOVLB  4
06F52:  INCFSZ x29,W
06F54:  BRA    6F58
06F56:  BRA    706E
....................    { 
....................       payload_buff[17] = make8(global_sprinkler_queue[global_current_sprinkler_queue_location].vlv_open_amount,0); 
06F58:  MOVF   x29,W
06F5A:  MULLW  0E
06F5C:  MOVF   FF3,W
06F5E:  MOVLB  5
06F60:  CLRF   x58
06F62:  MOVWF  x57
06F64:  MOVLW  08
06F66:  ADDWF  x57,W
06F68:  MOVWF  01
06F6A:  MOVLW  00
06F6C:  ADDWFC x58,W
06F6E:  MOVWF  03
06F70:  MOVF   01,W
06F72:  ADDLW  9D
06F74:  MOVWF  FE9
06F76:  MOVLW  03
06F78:  ADDWFC 03,W
06F7A:  MOVWF  FEA
06F7C:  MOVFF  FEC,558
06F80:  MOVF   FED,F
06F82:  MOVFF  FEF,304
06F86:  MOVLB  3
....................       payload_buff[18] = make8(global_sprinkler_queue[global_current_sprinkler_queue_location].vlv_open_amount,1); 
06F88:  MOVLB  4
06F8A:  MOVF   x29,W
06F8C:  MULLW  0E
06F8E:  MOVF   FF3,W
06F90:  MOVLB  5
06F92:  CLRF   x58
06F94:  MOVWF  x57
06F96:  MOVLW  08
06F98:  ADDWF  x57,W
06F9A:  MOVWF  01
06F9C:  MOVLW  00
06F9E:  ADDWFC x58,W
06FA0:  MOVWF  03
06FA2:  MOVF   01,W
06FA4:  ADDLW  9D
06FA6:  MOVWF  FE9
06FA8:  MOVLW  03
06FAA:  ADDWFC 03,W
06FAC:  MOVWF  FEA
06FAE:  MOVFF  FEC,305
06FB2:  MOVF   FED,F
06FB4:  MOVFF  FEF,557
06FB8:  MOVLB  3
....................       payload_buff[19] = make8(global_sprinkler_queue[global_current_sprinkler_queue_location].start_time,0); 
06FBA:  MOVLB  4
06FBC:  MOVF   x29,W
06FBE:  MULLW  0E
06FC0:  MOVF   FF3,W
06FC2:  MOVLB  5
06FC4:  CLRF   x58
06FC6:  MOVWF  x57
06FC8:  MOVLW  9D
06FCA:  ADDWF  x57,W
06FCC:  MOVWF  FE9
06FCE:  MOVLW  03
06FD0:  ADDWFC x58,W
06FD2:  MOVWF  FEA
06FD4:  MOVFF  FEF,306
06FD8:  MOVFF  FEC,55A
06FDC:  MOVFF  FEC,55B
06FE0:  MOVFF  FEC,55C
06FE4:  MOVLB  3
....................       payload_buff[20] = make8(global_sprinkler_queue[global_current_sprinkler_queue_location].start_time,1); 
06FE6:  MOVLB  4
06FE8:  MOVF   x29,W
06FEA:  MULLW  0E
06FEC:  MOVF   FF3,W
06FEE:  MOVLB  5
06FF0:  CLRF   x58
06FF2:  MOVWF  x57
06FF4:  MOVLW  9D
06FF6:  ADDWF  x57,W
06FF8:  MOVWF  FE9
06FFA:  MOVLW  03
06FFC:  ADDWFC x58,W
06FFE:  MOVWF  FEA
07000:  MOVFF  FEF,559
07004:  MOVFF  FEC,307
07008:  MOVFF  FEC,55B
0700C:  MOVFF  FEC,55C
07010:  MOVLB  3
....................       payload_buff[21] = make8(global_sprinkler_queue[global_current_sprinkler_queue_location].start_time,2); 
07012:  MOVLB  4
07014:  MOVF   x29,W
07016:  MULLW  0E
07018:  MOVF   FF3,W
0701A:  MOVLB  5
0701C:  CLRF   x58
0701E:  MOVWF  x57
07020:  MOVLW  9D
07022:  ADDWF  x57,W
07024:  MOVWF  FE9
07026:  MOVLW  03
07028:  ADDWFC x58,W
0702A:  MOVWF  FEA
0702C:  MOVFF  FEF,559
07030:  MOVFF  FEC,55A
07034:  MOVFF  FEC,308
07038:  MOVFF  FEC,55C
0703C:  MOVLB  3
....................       payload_buff[22] = make8(global_sprinkler_queue[global_current_sprinkler_queue_location].start_time,3); 
0703E:  MOVLB  4
07040:  MOVF   x29,W
07042:  MULLW  0E
07044:  MOVF   FF3,W
07046:  MOVLB  5
07048:  CLRF   x58
0704A:  MOVWF  x57
0704C:  MOVLW  9D
0704E:  ADDWF  x57,W
07050:  MOVWF  FE9
07052:  MOVLW  03
07054:  ADDWFC x58,W
07056:  MOVWF  FEA
07058:  MOVFF  FEF,559
0705C:  MOVFF  FEC,55A
07060:  MOVFF  FEC,55B
07064:  MOVFF  FEC,309
07068:  MOVLB  3
....................    } 
0706A:  BRA    707C
0706C:  MOVLB  4
....................    else 
....................    { 
....................       payload_buff[17] = 0; 
0706E:  MOVLB  3
07070:  CLRF   x04
....................       payload_buff[18] = 0; 
07072:  CLRF   x05
....................       payload_buff[19] = 0; 
07074:  CLRF   x06
....................       payload_buff[20] = 0; 
07076:  CLRF   x07
....................       payload_buff[21] = 0; 
07078:  CLRF   x08
....................       payload_buff[22] = 0; 
0707A:  CLRF   x09
....................    } 
....................    enable_interrupts(INT_CCP4); 
0707C:  BSF    F7A.1
....................    // vbatt(no charging) 
....................    temp_u16 = get_vbatt(1); 
0707E:  MOVLW  01
07080:  MOVLB  5
07082:  MOVWF  x68
07084:  MOVLB  0
07086:  CALL   4236
0708A:  MOVFF  02,556
0708E:  MOVFF  01,555
....................    payload_buff[23] = make8(temp_u16, 0); 
07092:  MOVFF  555,30A
07096:  MOVLB  3
....................    payload_buff[24] = make8(temp_u16, 1); 
07098:  MOVFF  556,30B
0709C:  MOVLB  3
....................    generate_message_and_send(); 
0709E:  MOVLB  0
070A0:  CALL   61C8
070A4:  GOTO   7904 (RETURN)
.................... } 
.................... void send_update_sp_num_response(uint8_t command_id_in_response_to, uint16_t msg_seq) 
.................... { 
....................    prepare_prefix_and_payload(10); 
*
0671C:  MOVLW  0A
0671E:  MOVLB  5
06720:  MOVWF  x5D
06722:  MOVLB  0
06724:  CALL   5DB0
....................    payload_buff[4] = make8(msg_seq,0); 
06728:  MOVFF  553,2F7
0672C:  MOVLB  2
....................    payload_buff[5] = make8(msg_seq,1); 
0672E:  MOVFF  554,2F8
06732:  MOVLB  2
....................    payload_buff[6] = command_id_in_response_to; 
06734:  MOVFF  552,2F9
....................    payload_buff[7] = MSG_MOTE_UPDATE_SP_NUM_RESPONSE; 
06738:  MOVLW  95
0673A:  MOVWF  xFA
....................    payload_buff[8] = make8(global_sprinkler_num, 0); 
0673C:  MOVFF  95,2FB
06740:  MOVLB  2
....................    payload_buff[9] = make8(global_sprinkler_num, 1); 
06742:  MOVFF  96,2FC
06746:  MOVLB  2
....................    generate_message_and_send(); 
06748:  MOVLB  0
0674A:  RCALL  61C8
0674C:  GOTO   742E (RETURN)
.................... }        
.................... void send_read_eeprom_response(uint8_t command_id_in_response_to, uint16_t msg_seq, uint16_t eeprom_location, uint32_t eeprom_data)  
.................... { 
....................    prepare_prefix_and_payload(16); 
*
06BCC:  MOVLW  10
06BCE:  MOVLB  5
06BD0:  MOVWF  x5D
06BD2:  MOVLB  0
06BD4:  CALL   5DB0
....................    payload_buff[4] = make8(msg_seq,0);                                                    
06BD8:  MOVFF  555,2F7
06BDC:  MOVLB  2
....................    payload_buff[5] = make8(msg_seq,1); 
06BDE:  MOVFF  556,2F8
06BE2:  MOVLB  2
....................    payload_buff[6] = command_id_in_response_to; 
06BE4:  MOVFF  554,2F9
....................    payload_buff[7] = MSG_MOTE_EEPROM_READ_RESPONSE;  
06BE8:  MOVLW  97
06BEA:  MOVWF  xFA
....................    payload_buff[8] = make8(global_sprinkler_num, 0); 
06BEC:  MOVFF  95,2FB
06BF0:  MOVLB  2
....................    payload_buff[9] = make8(global_sprinkler_num, 1); 
06BF2:  MOVFF  96,2FC
06BF6:  MOVLB  2
....................    payload_buff[10] = make8(eeprom_location, 0); 
06BF8:  MOVFF  557,2FD
06BFC:  MOVLB  2
....................    payload_buff[11] = make8(eeprom_location, 1);   
06BFE:  MOVFF  558,2FE
06C02:  MOVLB  2
....................    payload_buff[12] = make8(eeprom_data, 0);                          
06C04:  MOVFF  559,2FF
06C08:  MOVLB  2
....................    payload_buff[13] = make8(eeprom_data, 1);   
06C0A:  MOVFF  55A,300
06C0E:  MOVLB  3
....................    payload_buff[14] = make8(eeprom_data, 2);     
06C10:  MOVFF  55B,301
06C14:  MOVLB  3
....................    payload_buff[15] = make8(eeprom_data, 3);   
06C16:  MOVFF  55C,302
06C1A:  MOVLB  3
....................    generate_message_and_send();    
06C1C:  MOVLB  0
06C1E:  CALL   61C8
06C22:  GOTO   77A0 (RETURN)
.................... }                
.................... void send_pressure_xdcr_msg(uint8_t command_id_in_response_to, uint16_t msg_seq)    
.................... {                    
....................    prepare_prefix_and_payload(12); 
....................    payload_buff[4] = make8(msg_seq,0);                                                    
....................    payload_buff[5] = make8(msg_seq,1);       
....................    payload_buff[6] = command_id_in_response_to;                    
....................    payload_buff[7] = MSG_MOTE_XDCR_READ_MSG;           
....................    payload_buff[8] = make8(global_sprinkler_num, 0);    
....................    payload_buff[9] = make8(global_sprinkler_num, 1); 
....................    payload_buff[10] = make8(global_xdcr_output, 0);                  
....................    payload_buff[11] = make8(global_xdcr_output, 1);    
....................    generate_message_and_send();                               
.................... }        
.................... void send_ack(uint8_t command_id_in_response_to, uint16_t msg_seq) 
.................... { 
....................    prepare_prefix_and_payload(8); 
*
066F6:  MOVLW  08
066F8:  MOVLB  5
066FA:  MOVWF  x5D
066FC:  MOVLB  0
066FE:  CALL   5DB0
....................    payload_buff[4] = make8(msg_seq,0); 
06702:  MOVFF  553,2F7
06706:  MOVLB  2
....................    payload_buff[5] = make8(msg_seq,1); 
06708:  MOVFF  554,2F8
0670C:  MOVLB  2
....................    payload_buff[6] = command_id_in_response_to; 
0670E:  MOVFF  552,2F9
....................    payload_buff[7] = MSG_MOTE_ACK; 
06712:  MOVLW  80
06714:  MOVWF  xFA
....................    generate_message_and_send(); 
06716:  MOVLB  0
06718:  RCALL  61C8
0671A:  RETURN 0
.................... } 
.................... void send_nack(uint8_t command_id_in_response_to, uint16_t msg_seq, uint32_t nack_bitfield) 
.................... { 
....................    prepare_prefix_and_payload(12); 
*
06772:  MOVLW  0C
06774:  MOVLB  5
06776:  MOVWF  x5D
06778:  MOVLB  0
0677A:  CALL   5DB0
....................    payload_buff[4] = make8(msg_seq,0); 
0677E:  MOVFF  553,2F7
06782:  MOVLB  2
....................    payload_buff[5] = make8(msg_seq,1); 
06784:  MOVFF  554,2F8
06788:  MOVLB  2
....................    payload_buff[6] = command_id_in_response_to; 
0678A:  MOVFF  552,2F9
....................    payload_buff[7] = MSG_MOTE_NACK; 
0678E:  MOVLW  81
06790:  MOVWF  xFA
....................    payload_buff[8] = make8(nack_bitfield, 0); 
06792:  MOVFF  555,2FB
06796:  MOVLB  2
....................    payload_buff[9] = make8(nack_bitfield, 1); 
06798:  MOVFF  556,2FC
0679C:  MOVLB  2
....................    payload_buff[10] = make8(nack_bitfield, 2); 
0679E:  MOVFF  557,2FD
067A2:  MOVLB  2
....................    payload_buff[11] = make8(nack_bitfield, 3); 
067A4:  MOVFF  558,2FE
067A8:  MOVLB  2
....................    generate_message_and_send(); 
067AA:  MOVLB  0
067AC:  RCALL  61C8
067AE:  RETURN 0
.................... }                                        
....................  
.................... // unsolicted responses (only sent within CCP4 ISR) 
.................... void send_health_report_ISR(uint8_t command_id_in_response_to, uint16_t msg_seq) 
.................... { 
....................    uint16_t temp_u16; 
....................     
....................    prepare_prefix_and_payload_ISR(18); 
*
024AA:  MOVLW  12
024AC:  MOVLB  5
024AE:  MOVWF  x93
024B0:  MOVLB  0
024B2:  RCALL  23B2
....................    payload_buff[4] = make8(msg_seq,0); 
024B4:  MOVFF  58F,2F7
024B8:  MOVLB  2
....................    payload_buff[5] = make8(msg_seq,1); 
024BA:  MOVFF  590,2F8
024BE:  MOVLB  2
....................    payload_buff[6] = command_id_in_response_to; 
024C0:  MOVFF  58E,2F9
....................    payload_buff[7] = MSG_MOTE_HEALTH_REPORT; 
024C4:  MOVLW  91
024C6:  MOVWF  xFA
....................    payload_buff[8] = make8(global_sprinkler_num, 0); 
024C8:  MOVFF  95,2FB
024CC:  MOVLB  2
....................    payload_buff[9] = make8(global_sprinkler_num, 1); 
024CE:  MOVFF  96,2FC
024D2:  MOVLB  2
....................    payload_buff[10] = global_hardware_enabled; 
024D4:  MOVFF  A7,2FD
....................    payload_buff[11] = global_system_state; 
024D8:  MOVFF  505,2FE
....................  // vbatt(unchanged charge state) 
....................    temp_u16 = get_vbatt_ISR(0); 
024DC:  MOVLB  5
024DE:  CLRF   x93
024E0:  MOVLB  0
024E2:  RCALL  23F4
024E4:  MOVFF  02,592
024E8:  MOVFF  01,591
....................    payload_buff[12] = make8(temp_u16, 0); 
024EC:  MOVFF  591,2FF
024F0:  MOVLB  2
....................    payload_buff[13] = make8(temp_u16, 1); 
024F2:  MOVFF  592,300
024F6:  MOVLB  3
....................    // vbatt(no charging) 
....................    temp_u16 = get_vbatt_ISR(1); 
024F8:  MOVLW  01
024FA:  MOVLB  5
024FC:  MOVWF  x93
024FE:  MOVLB  0
02500:  RCALL  23F4
02502:  MOVFF  02,592
02506:  MOVFF  01,591
....................    payload_buff[14] = make8(temp_u16, 0); 
0250A:  MOVFF  591,301
0250E:  MOVLB  3
....................    payload_buff[15] = make8(temp_u16, 1); 
02510:  MOVFF  592,302
02514:  MOVLB  3
....................    payload_buff[16] = global_valve_movements_since_endstop; 
02516:  MOVFF  CF,303
....................    payload_buff[17] = global_mote_temperature; 
0251A:  MOVFF  36D,304
....................    generate_message_and_send_ISR(); 
0251E:  MOVLB  0
02520:  RCALL  244E
02522:  GOTO   2A50 (RETURN)
.................... } 
.................... void send_valve_report_ISR(uint8_t command_id_in_response_to, uint16_t msg_seq) 
.................... { 
....................    uint16_t temp_u16; 
....................    prepare_prefix_and_payload_ISR(28); 
*
02624:  MOVLW  1C
02626:  MOVLB  5
02628:  MOVWF  x93
0262A:  MOVLB  0
0262C:  RCALL  23B2
....................    payload_buff[4] = make8(msg_seq,0); 
0262E:  MOVFF  58F,2F7
02632:  MOVLB  2
....................    payload_buff[5] = make8(msg_seq,1); 
02634:  MOVFF  590,2F8
02638:  MOVLB  2
....................    payload_buff[6] = command_id_in_response_to; 
0263A:  MOVFF  58E,2F9
....................    payload_buff[7] = MSG_MOTE_VALVE_REPORT; 
0263E:  MOVLW  92
02640:  MOVWF  xFA
....................    payload_buff[8] = make8(global_sprinkler_num, 0); 
02642:  MOVFF  95,2FB
02646:  MOVLB  2
....................    payload_buff[9] = make8(global_sprinkler_num, 1); 
02648:  MOVFF  96,2FC
0264C:  MOVLB  2
....................    payload_buff[10] = make8(global_valve_position, 0); 
0264E:  MOVFF  C1,2FD
02652:  MOVLB  2
....................    payload_buff[11] = make8(global_valve_position, 1); 
02654:  MOVFF  C2,2FE
02658:  MOVLB  2
....................    payload_buff[12] = make8((global_valve_time_to_open_1024th << 4), 0); 
0265A:  MOVLB  0
0265C:  RLCF   xC7,W
0265E:  MOVLB  5
02660:  MOVWF  x93
02662:  MOVLB  0
02664:  RLCF   xC8,W
02666:  MOVLB  5
02668:  MOVWF  x94
0266A:  RLCF   x93,F
0266C:  RLCF   x94,F
0266E:  RLCF   x93,F
02670:  RLCF   x94,F
02672:  RLCF   x93,F
02674:  RLCF   x94,F
02676:  MOVLW  F0
02678:  ANDWF  x93,F
0267A:  MOVFF  593,2FF
0267E:  MOVLB  2
....................    payload_buff[13] = make8((global_valve_time_to_open_1024th << 4), 1); 
02680:  MOVLB  0
02682:  RLCF   xC7,W
02684:  MOVLB  5
02686:  MOVWF  x93
02688:  MOVLB  0
0268A:  RLCF   xC8,W
0268C:  MOVLB  5
0268E:  MOVWF  x94
02690:  RLCF   x93,F
02692:  RLCF   x94,F
02694:  RLCF   x93,F
02696:  RLCF   x94,F
02698:  RLCF   x93,F
0269A:  RLCF   x94,F
0269C:  MOVLW  F0
0269E:  ANDWF  x93,F
026A0:  MOVFF  594,300
026A4:  MOVLB  3
....................    payload_buff[14] = make8((global_valve_time_to_close_1024th << 4), 0); 
026A6:  MOVLB  0
026A8:  RLCF   xC5,W
026AA:  MOVLB  5
026AC:  MOVWF  x93
026AE:  MOVLB  0
026B0:  RLCF   xC6,W
026B2:  MOVLB  5
026B4:  MOVWF  x94
026B6:  RLCF   x93,F
026B8:  RLCF   x94,F
026BA:  RLCF   x93,F
026BC:  RLCF   x94,F
026BE:  RLCF   x93,F
026C0:  RLCF   x94,F
026C2:  MOVLW  F0
026C4:  ANDWF  x93,F
026C6:  MOVFF  593,301
026CA:  MOVLB  3
....................    payload_buff[15] = make8((global_valve_time_to_close_1024th << 4), 1); 
026CC:  MOVLB  0
026CE:  RLCF   xC5,W
026D0:  MOVLB  5
026D2:  MOVWF  x93
026D4:  MOVLB  0
026D6:  RLCF   xC6,W
026D8:  MOVLB  5
026DA:  MOVWF  x94
026DC:  RLCF   x93,F
026DE:  RLCF   x94,F
026E0:  RLCF   x93,F
026E2:  RLCF   x94,F
026E4:  RLCF   x93,F
026E6:  RLCF   x94,F
026E8:  MOVLW  F0
026EA:  ANDWF  x93,F
026EC:  MOVFF  594,302
026F0:  MOVLB  3
....................    payload_buff[16] = make8(global_valve_calibration_utc_time, 0); 
026F2:  MOVFF  CB,303
026F6:  MOVLB  3
....................    payload_buff[17] = make8(global_valve_calibration_utc_time, 1); 
026F8:  MOVFF  CC,304
026FC:  MOVLB  3
....................    payload_buff[18] = make8(global_valve_calibration_utc_time, 2); 
026FE:  MOVFF  CD,305
02702:  MOVLB  3
....................    payload_buff[19] = make8(global_valve_calibration_utc_time, 3); 
02704:  MOVFF  CE,306
02708:  MOVLB  3
....................    payload_buff[20] = make8(global_calibrate_fsr_valve_position, 0); 
0270A:  MOVFF  D0,307
0270E:  MOVLB  3
....................    payload_buff[21] = make8(global_calibrate_fsr_valve_position, 1); 
02710:  MOVFF  D1,308
02714:  MOVLB  3
....................    temp_u16 = convert_period_to_rpm_ISR(global_calibrate_fsr_period); 
02716:  MOVFF  D3,594
0271A:  MOVFF  D2,593
0271E:  MOVLB  0
02720:  BRA    25BA
02722:  MOVFF  02,592
02726:  MOVFF  01,591
....................    payload_buff[22] = make8(temp_u16, 0); 
0272A:  MOVFF  591,309
0272E:  MOVLB  3
....................    payload_buff[23] = make8(temp_u16, 1); 
02730:  MOVFF  592,30A
02734:  MOVLB  3
....................    payload_buff[24] = make8(global_calibrate_fsr_utc_time, 0); 
02736:  MOVFF  D4,30B
0273A:  MOVLB  3
....................    payload_buff[25] = make8(global_calibrate_fsr_utc_time, 1); 
0273C:  MOVFF  D5,30C
02740:  MOVLB  3
....................    payload_buff[26] = make8(global_calibrate_fsr_utc_time, 2); 
02742:  MOVFF  D6,30D
02746:  MOVLB  3
....................    payload_buff[27] = make8(global_calibrate_fsr_utc_time, 3); 
02748:  MOVFF  D7,30E
0274C:  MOVLB  3
....................    generate_message_and_send_ISR(); 
0274E:  MOVLB  0
02750:  RCALL  244E
02752:  GOTO   2A50 (RETURN)
.................... } 
.................... void send_join_msg_ISR(uint8_t command_id_in_response_to, uint16_t msg_seq) 
.................... { 
....................    prepare_prefix_and_payload_ISR(18); 
02756:  MOVLW  12
02758:  MOVLB  5
0275A:  MOVWF  x93
0275C:  MOVLB  0
0275E:  RCALL  23B2
....................    payload_buff[4] = make8(msg_seq,0); 
02760:  MOVFF  58F,2F7
02764:  MOVLB  2
....................    payload_buff[5] = make8(msg_seq,1); 
02766:  MOVFF  590,2F8
0276A:  MOVLB  2
....................    payload_buff[6] = command_id_in_response_to; 
0276C:  MOVFF  58E,2F9
....................    payload_buff[7] = MSG_MOTE_JOIN_MSG; 
02770:  MOVLW  94
02772:  MOVWF  xFA
....................    payload_buff[8] = make8(global_sprinkler_num, 0); 
02774:  MOVFF  95,2FB
02778:  MOVLB  2
....................    payload_buff[9] = make8(global_sprinkler_num, 1); 
0277A:  MOVFF  96,2FC
0277E:  MOVLB  2
....................    payload_buff[10] = global_hardware_enabled; 
02780:  MOVFF  A7,2FD
....................    payload_buff[11] = make8(global_rtc_time,0); 
02784:  MOVFF  85,2FE
02788:  MOVLB  2
....................    payload_buff[12] = make8(global_rtc_time,1); 
0278A:  MOVFF  86,2FF
0278E:  MOVLB  2
....................    payload_buff[13] = make8(global_rtc_time,2); 
02790:  MOVFF  87,300
02794:  MOVLB  3
....................    payload_buff[14] = make8(global_rtc_time,3);    
02796:  MOVFF  88,301
0279A:  MOVLB  3
....................    payload_buff[15] = global_previous_shutdown_cause; 
0279C:  MOVFF  4E,302
....................    payload_buff[16] = make8(FIRMWARE_VERSION,0); 
027A0:  MOVLW  14
027A2:  MOVWF  x03
....................    payload_buff[17] = make8(FIRMWARE_VERSION,1);   
027A4:  MOVLW  E3
027A6:  MOVWF  x04
....................    generate_message_and_send_ISR(); 
027A8:  MOVLB  0
027AA:  RCALL  244E
027AC:  GOTO   2A50 (RETURN)
.................... } 
.................... void send_gps_point_msg_ISR(uint8_t command_id_in_response_to, uint16_t msg_seq) 
.................... { 
....................    prepare_prefix_and_payload_ISR(23); 
027B0:  MOVLW  17
027B2:  MOVLB  5
027B4:  MOVWF  x93
027B6:  MOVLB  0
027B8:  RCALL  23B2
....................    payload_buff[4] = make8(msg_seq,0); 
027BA:  MOVFF  58F,2F7
027BE:  MOVLB  2
....................    payload_buff[5] = make8(msg_seq,1); 
027C0:  MOVFF  590,2F8
027C4:  MOVLB  2
....................    payload_buff[6] = command_id_in_response_to; 
027C6:  MOVFF  58E,2F9
....................    payload_buff[7] = MSG_MOTE_GPS_POINT_MSG; 
027CA:  MOVLW  96
027CC:  MOVWF  xFA
....................    payload_buff[8] = make8(global_sprinkler_num, 0); 
027CE:  MOVFF  95,2FB
027D2:  MOVLB  2
....................    payload_buff[9] = make8(global_sprinkler_num, 1); 
027D4:  MOVFF  96,2FC
027D8:  MOVLB  2
....................    generate_message_and_send_ISR(); 
027DA:  MOVLB  0
027DC:  RCALL  244E
027DE:  GOTO   2A50 (RETURN)
.................... }                  
.................... void send_pressure_xdcr_msg_ISR(uint8_t command_id_in_response_to, uint16_t msg_seq)    
.................... {                          
....................    prepare_prefix_and_payload_ISR(12);  
027E2:  MOVLW  0C
027E4:  MOVLB  5
027E6:  MOVWF  x93
027E8:  MOVLB  0
027EA:  RCALL  23B2
....................    payload_buff[4] = make8(msg_seq,0);                                                    
027EC:  MOVFF  58F,2F7
027F0:  MOVLB  2
....................    payload_buff[5] = make8(msg_seq,1);       
027F2:  MOVFF  590,2F8
027F6:  MOVLB  2
....................    payload_buff[6] = command_id_in_response_to;                    
027F8:  MOVFF  58E,2F9
....................    payload_buff[7] = MSG_MOTE_XDCR_READ_MSG;     
027FC:  MOVLW  98
027FE:  MOVWF  xFA
....................    payload_buff[8] = make8(global_sprinkler_num, 0);    
02800:  MOVFF  95,2FB
02804:  MOVLB  2
....................    payload_buff[9] = make8(global_sprinkler_num, 1);                        
02806:  MOVFF  96,2FC
0280A:  MOVLB  2
....................    payload_buff[10] = make8(global_xdcr_output, 0);                  
0280C:  MOVFF  4B,2FD
....................    payload_buff[11] = make8(global_xdcr_output, 1);       
02810:  MOVFF  4C,2FE
....................    generate_message_and_send_ISR();                               
02814:  MOVLB  0
02816:  RCALL  244E
02818:  GOTO   2A50 (RETURN)
.................... }  
.................... void send_error_msg_ISR(uint8_t command_id_in_response_to, uint16_t msg_seq) 
.................... { 
....................    prepare_prefix_and_payload_ISR(14); 
0281C:  MOVLW  0E
0281E:  MOVLB  5
02820:  MOVWF  x93
02822:  MOVLB  0
02824:  RCALL  23B2
....................    payload_buff[4] = make8(msg_seq,0); 
02826:  MOVFF  58F,2F7
0282A:  MOVLB  2
....................    payload_buff[5] = make8(msg_seq,1); 
0282C:  MOVFF  590,2F8
02830:  MOVLB  2
....................    payload_buff[6] = command_id_in_response_to; 
02832:  MOVFF  58E,2F9
....................    payload_buff[7] = MSG_MOTE_ERROR_MSG; 
02836:  MOVLW  A0
02838:  MOVWF  xFA
....................    payload_buff[8] = make8(global_sprinkler_num, 0); 
0283A:  MOVFF  95,2FB
0283E:  MOVLB  2
....................    payload_buff[9] = make8(global_sprinkler_num, 1); 
02840:  MOVFF  96,2FC
02844:  MOVLB  2
....................    payload_buff[10] = make8(global_error_message_bitfield,0); 
02846:  MOVFF  4F8,2FD
0284A:  MOVLB  2
....................    payload_buff[11] = make8(global_error_message_bitfield,1); 
0284C:  MOVFF  4F9,2FE
02850:  MOVLB  2
....................    payload_buff[12] = make8(global_error_message_bitfield,2); 
02852:  MOVFF  4FA,2FF
02856:  MOVLB  2
....................    payload_buff[13] = make8(global_error_message_bitfield,3); 
02858:  MOVFF  4FB,300
0285C:  MOVLB  3
....................    generate_message_and_send_ISR(); 
0285E:  MOVLB  0
02860:  RCALL  244E
02862:  GOTO   2A50 (RETURN)
.................... } 
....................  
.................... #include "periph.h"                                                       
.................... // This file contains all functions definitions for the LCD and XDCR 
.................... // The globals.h file is needed 
....................  
.................... ////////////////////LCD Functions Start///////////////////////////////////////// 
....................  
.................... //************************************************************** 
.................... // These routines communicate to the 16x2 LCD display via I2C. * 
.................... // Here are the HEX codes for the 32 display positions:        * 
.................... // Line 1   00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F    * 
.................... // Line 2   40 41 42 43 44 45 46 47 48 49 4A 4B 4C 4D 4E 4F    * 
.................... //************************************************************** 
....................  
.................... void LCD_init(void)    
.................... { 
....................    output_low(LCD_RESETn);                                
*
039E8:  BCF    F8C.2
....................    
....................    delay_ms(1); 
039EA:  MOVLW  14
039EC:  MOVWF  00
039EE:  DECFSZ 00,F
039F0:  BRA    39EE
039F2:  NOP   
....................     
....................    //setup_T0_int(T0_1MS); 
....................    //while (!TMR0IF); 
....................  
....................    output_high(LCD_RESETn); 
039F4:  BSF    F8C.2
....................    //setup_T0_int(T0_100MS); 
....................    //while (!TMR0IF); 
....................     
....................    delay_ms(100); 
039F6:  MOVLW  64
039F8:  MOVLB  5
039FA:  MOVWF  x64
039FC:  MOVLB  0
039FE:  RCALL  38C8
....................    i2c_start(); 
03A00:  BSF    FC5.1
03A02:  BTFSC  FC5.1
03A04:  BRA    3A02
....................     
....................    global_lcd_enabled = !i2c_write(LCD_ADDRESS);    // (0x7C)WRITE LCD address 
03A06:  BCF    xA7.0
03A08:  MOVLW  7C
03A0A:  MOVLB  5
03A0C:  MOVWF  x7C
03A0E:  MOVLB  0
03A10:  RCALL  38E4
03A12:  MOVF   01,W
03A14:  BNZ   3A18
03A16:  BSF    xA7.0
....................    if (!global_lcd_enabled) 
03A18:  BTFSC  xA7.0
03A1A:  BRA    3A24
....................    { 
....................       i2c_stop(); 
03A1C:  BSF    FC5.2
03A1E:  BTFSC  FC5.2
03A20:  BRA    3A1E
....................       return; 
03A22:  BRA    3E1A
....................    } 
....................  
....................    i2c_write(0x00);              // (0x00)Control byte 
03A24:  MOVLB  5
03A26:  CLRF   x7C
03A28:  MOVLB  0
03A2A:  RCALL  38E4
....................    i2c_write(0x38);              // (0x38)Function Set: 8 bits, 
03A2C:  MOVLW  38
03A2E:  MOVLB  5
03A30:  MOVWF  x7C
03A32:  MOVLB  0
03A34:  RCALL  38E4
....................    i2c_stop();                   //  use Instruction Table 0 
03A36:  BSF    FC5.2
03A38:  BTFSC  FC5.2
03A3A:  BRA    3A38
....................    delay_cycles(255); 
03A3C:  MOVLW  54
03A3E:  MOVWF  00
03A40:  DECFSZ 00,F
03A42:  BRA    3A40
03A44:  BRA    3A46
....................     
....................    i2c_start(); 
03A46:  BSF    FC5.0
03A48:  BTFSC  FC5.0
03A4A:  BRA    3A48
....................    i2c_write(LCD_ADDRESS);     // (0x7C)WRITE LCD address 
03A4C:  MOVLW  7C
03A4E:  MOVLB  5
03A50:  MOVWF  x7C
03A52:  MOVLB  0
03A54:  RCALL  38E4
....................    i2c_write(0x00);     // (0x00)Control byte 
03A56:  MOVLB  5
03A58:  CLRF   x7C
03A5A:  MOVLB  0
03A5C:  RCALL  38E4
....................    i2c_write(0x40);     // set CG address 0 
03A5E:  MOVLW  40
03A60:  MOVLB  5
03A62:  MOVWF  x7C
03A64:  MOVLB  0
03A66:  RCALL  38E4
....................    i2c_stop(); 
03A68:  BSF    FC5.2
03A6A:  BTFSC  FC5.2
03A6C:  BRA    3A6A
....................    delay_cycles(255); 
03A6E:  MOVLW  54
03A70:  MOVWF  00
03A72:  DECFSZ 00,F
03A74:  BRA    3A72
03A76:  BRA    3A78
....................    
....................    i2c_start();         // define special character  
03A78:  BSF    FC5.0
03A7A:  BTFSC  FC5.0
03A7C:  BRA    3A7A
....................    i2c_write(LCD_ADDRESS);     // WRITE LCD address 
03A7E:  MOVLW  7C
03A80:  MOVLB  5
03A82:  MOVWF  x7C
03A84:  MOVLB  0
03A86:  RCALL  38E4
....................    i2c_write(0x40);     // Datasend 
03A88:  MOVLW  40
03A8A:  MOVLB  5
03A8C:  MOVWF  x7C
03A8E:  MOVLB  0
03A90:  RCALL  38E4
....................     
.................... // special char 0 (LEV1) 
....................    i2c_write(0b00000); 
03A92:  MOVLB  5
03A94:  CLRF   x7C
03A96:  MOVLB  0
03A98:  RCALL  38E4
....................    i2c_write(0b00000); 
03A9A:  MOVLB  5
03A9C:  CLRF   x7C
03A9E:  MOVLB  0
03AA0:  RCALL  38E4
....................    i2c_write(0b00000); 
03AA2:  MOVLB  5
03AA4:  CLRF   x7C
03AA6:  MOVLB  0
03AA8:  RCALL  38E4
....................    i2c_write(0b00000); 
03AAA:  MOVLB  5
03AAC:  CLRF   x7C
03AAE:  MOVLB  0
03AB0:  RCALL  38E4
....................    i2c_write(0b00000); 
03AB2:  MOVLB  5
03AB4:  CLRF   x7C
03AB6:  MOVLB  0
03AB8:  RCALL  38E4
....................    i2c_write(0b00000); 
03ABA:  MOVLB  5
03ABC:  CLRF   x7C
03ABE:  MOVLB  0
03AC0:  RCALL  38E4
....................    i2c_write(0b00000); 
03AC2:  MOVLB  5
03AC4:  CLRF   x7C
03AC6:  MOVLB  0
03AC8:  RCALL  38E4
....................    i2c_write(0b11111); 
03ACA:  MOVLW  1F
03ACC:  MOVLB  5
03ACE:  MOVWF  x7C
03AD0:  MOVLB  0
03AD2:  RCALL  38E4
.................... // special char 1 (LEV2) 
....................    i2c_write(0b00000); 
03AD4:  MOVLB  5
03AD6:  CLRF   x7C
03AD8:  MOVLB  0
03ADA:  RCALL  38E4
....................    i2c_write(0b00000); 
03ADC:  MOVLB  5
03ADE:  CLRF   x7C
03AE0:  MOVLB  0
03AE2:  RCALL  38E4
....................    i2c_write(0b00000); 
03AE4:  MOVLB  5
03AE6:  CLRF   x7C
03AE8:  MOVLB  0
03AEA:  RCALL  38E4
....................    i2c_write(0b00000); 
03AEC:  MOVLB  5
03AEE:  CLRF   x7C
03AF0:  MOVLB  0
03AF2:  RCALL  38E4
....................    i2c_write(0b00000); 
03AF4:  MOVLB  5
03AF6:  CLRF   x7C
03AF8:  MOVLB  0
03AFA:  RCALL  38E4
....................    i2c_write(0b00000); 
03AFC:  MOVLB  5
03AFE:  CLRF   x7C
03B00:  MOVLB  0
03B02:  RCALL  38E4
....................    i2c_write(0b11111); 
03B04:  MOVLW  1F
03B06:  MOVLB  5
03B08:  MOVWF  x7C
03B0A:  MOVLB  0
03B0C:  RCALL  38E4
....................    i2c_write(0b11111); 
03B0E:  MOVLW  1F
03B10:  MOVLB  5
03B12:  MOVWF  x7C
03B14:  MOVLB  0
03B16:  RCALL  38E4
.................... // special char 2 (LEV4) 
....................    i2c_write(0b00000); 
03B18:  MOVLB  5
03B1A:  CLRF   x7C
03B1C:  MOVLB  0
03B1E:  RCALL  38E4
....................    i2c_write(0b00000); 
03B20:  MOVLB  5
03B22:  CLRF   x7C
03B24:  MOVLB  0
03B26:  RCALL  38E4
....................    i2c_write(0b00000); 
03B28:  MOVLB  5
03B2A:  CLRF   x7C
03B2C:  MOVLB  0
03B2E:  RCALL  38E4
....................    i2c_write(0b00000); 
03B30:  MOVLB  5
03B32:  CLRF   x7C
03B34:  MOVLB  0
03B36:  RCALL  38E4
....................    i2c_write(0b00000); 
03B38:  MOVLB  5
03B3A:  CLRF   x7C
03B3C:  MOVLB  0
03B3E:  RCALL  38E4
....................    i2c_write(0b11111); 
03B40:  MOVLW  1F
03B42:  MOVLB  5
03B44:  MOVWF  x7C
03B46:  MOVLB  0
03B48:  RCALL  38E4
....................    i2c_write(0b00000); 
03B4A:  MOVLB  5
03B4C:  CLRF   x7C
03B4E:  MOVLB  0
03B50:  RCALL  38E4
....................    i2c_write(0b00000); 
03B52:  MOVLB  5
03B54:  CLRF   x7C
03B56:  MOVLB  0
03B58:  RCALL  38E4
.................... // special char 3 (LEV5) 
....................    i2c_write(0b00000); 
03B5A:  MOVLB  5
03B5C:  CLRF   x7C
03B5E:  MOVLB  0
03B60:  RCALL  38E4
....................    i2c_write(0b00000); 
03B62:  MOVLB  5
03B64:  CLRF   x7C
03B66:  MOVLB  0
03B68:  RCALL  38E4
....................    i2c_write(0b00000); 
03B6A:  MOVLB  5
03B6C:  CLRF   x7C
03B6E:  MOVLB  0
03B70:  RCALL  38E4
....................    i2c_write(0b00000); 
03B72:  MOVLB  5
03B74:  CLRF   x7C
03B76:  MOVLB  0
03B78:  RCALL  38E4
....................    i2c_write(0b11111); 
03B7A:  MOVLW  1F
03B7C:  MOVLB  5
03B7E:  MOVWF  x7C
03B80:  MOVLB  0
03B82:  RCALL  38E4
....................    i2c_write(0b00000); 
03B84:  MOVLB  5
03B86:  CLRF   x7C
03B88:  MOVLB  0
03B8A:  RCALL  38E4
....................    i2c_write(0b00000); 
03B8C:  MOVLB  5
03B8E:  CLRF   x7C
03B90:  MOVLB  0
03B92:  RCALL  38E4
....................    i2c_write(0b00000); 
03B94:  MOVLB  5
03B96:  CLRF   x7C
03B98:  MOVLB  0
03B9A:  RCALL  38E4
.................... // special char 4 (LEV7) 
....................    i2c_write(0b00000); 
03B9C:  MOVLB  5
03B9E:  CLRF   x7C
03BA0:  MOVLB  0
03BA2:  RCALL  38E4
....................    i2c_write(0b00000); 
03BA4:  MOVLB  5
03BA6:  CLRF   x7C
03BA8:  MOVLB  0
03BAA:  RCALL  38E4
....................    i2c_write(0b11111); 
03BAC:  MOVLW  1F
03BAE:  MOVLB  5
03BB0:  MOVWF  x7C
03BB2:  MOVLB  0
03BB4:  RCALL  38E4
....................    i2c_write(0b00000); 
03BB6:  MOVLB  5
03BB8:  CLRF   x7C
03BBA:  MOVLB  0
03BBC:  RCALL  38E4
....................    i2c_write(0b00000); 
03BBE:  MOVLB  5
03BC0:  CLRF   x7C
03BC2:  MOVLB  0
03BC4:  RCALL  38E4
....................    i2c_write(0b00000); 
03BC6:  MOVLB  5
03BC8:  CLRF   x7C
03BCA:  MOVLB  0
03BCC:  RCALL  38E4
....................    i2c_write(0b00000); 
03BCE:  MOVLB  5
03BD0:  CLRF   x7C
03BD2:  MOVLB  0
03BD4:  RCALL  38E4
....................    i2c_write(0b00000); 
03BD6:  MOVLB  5
03BD8:  CLRF   x7C
03BDA:  MOVLB  0
03BDC:  RCALL  38E4
.................... // special char 5 (LEV8) 
....................    i2c_write(0b00000); 
03BDE:  MOVLB  5
03BE0:  CLRF   x7C
03BE2:  MOVLB  0
03BE4:  RCALL  38E4
....................    i2c_write(0b11111); 
03BE6:  MOVLW  1F
03BE8:  MOVLB  5
03BEA:  MOVWF  x7C
03BEC:  MOVLB  0
03BEE:  RCALL  38E4
....................    i2c_write(0b00000); 
03BF0:  MOVLB  5
03BF2:  CLRF   x7C
03BF4:  MOVLB  0
03BF6:  RCALL  38E4
....................    i2c_write(0b00000); 
03BF8:  MOVLB  5
03BFA:  CLRF   x7C
03BFC:  MOVLB  0
03BFE:  RCALL  38E4
....................    i2c_write(0b00000); 
03C00:  MOVLB  5
03C02:  CLRF   x7C
03C04:  MOVLB  0
03C06:  RCALL  38E4
....................    i2c_write(0b00000); 
03C08:  MOVLB  5
03C0A:  CLRF   x7C
03C0C:  MOVLB  0
03C0E:  RCALL  38E4
....................    i2c_write(0b00000); 
03C10:  MOVLB  5
03C12:  CLRF   x7C
03C14:  MOVLB  0
03C16:  RCALL  38E4
....................    i2c_write(0b00000); 
03C18:  MOVLB  5
03C1A:  CLRF   x7C
03C1C:  MOVLB  0
03C1E:  RCALL  38E4
.................... // special char 6 (LEV9) 
....................    i2c_write(0b11111); 
03C20:  MOVLW  1F
03C22:  MOVLB  5
03C24:  MOVWF  x7C
03C26:  MOVLB  0
03C28:  RCALL  38E4
....................    i2c_write(0b11111); 
03C2A:  MOVLW  1F
03C2C:  MOVLB  5
03C2E:  MOVWF  x7C
03C30:  MOVLB  0
03C32:  RCALL  38E4
....................    i2c_write(0b00000); 
03C34:  MOVLB  5
03C36:  CLRF   x7C
03C38:  MOVLB  0
03C3A:  RCALL  38E4
....................    i2c_write(0b00000); 
03C3C:  MOVLB  5
03C3E:  CLRF   x7C
03C40:  MOVLB  0
03C42:  RCALL  38E4
....................    i2c_write(0b00000); 
03C44:  MOVLB  5
03C46:  CLRF   x7C
03C48:  MOVLB  0
03C4A:  RCALL  38E4
....................    i2c_write(0b00000); 
03C4C:  MOVLB  5
03C4E:  CLRF   x7C
03C50:  MOVLB  0
03C52:  RCALL  38E4
....................    i2c_write(0b00000); 
03C54:  MOVLB  5
03C56:  CLRF   x7C
03C58:  MOVLB  0
03C5A:  RCALL  38E4
....................    i2c_write(0b00000); 
03C5C:  MOVLB  5
03C5E:  CLRF   x7C
03C60:  MOVLB  0
03C62:  RCALL  38E4
....................    // special char 7 (BIGBOX) 
....................    i2c_write(0b11111); 
03C64:  MOVLW  1F
03C66:  MOVLB  5
03C68:  MOVWF  x7C
03C6A:  MOVLB  0
03C6C:  RCALL  38E4
....................    i2c_write(0b11111); 
03C6E:  MOVLW  1F
03C70:  MOVLB  5
03C72:  MOVWF  x7C
03C74:  MOVLB  0
03C76:  RCALL  38E4
....................    i2c_write(0b11111); 
03C78:  MOVLW  1F
03C7A:  MOVLB  5
03C7C:  MOVWF  x7C
03C7E:  MOVLB  0
03C80:  RCALL  38E4
....................    i2c_write(0b11111); 
03C82:  MOVLW  1F
03C84:  MOVLB  5
03C86:  MOVWF  x7C
03C88:  MOVLB  0
03C8A:  RCALL  38E4
....................    i2c_write(0b11111); 
03C8C:  MOVLW  1F
03C8E:  MOVLB  5
03C90:  MOVWF  x7C
03C92:  MOVLB  0
03C94:  RCALL  38E4
....................    i2c_write(0b11111); 
03C96:  MOVLW  1F
03C98:  MOVLB  5
03C9A:  MOVWF  x7C
03C9C:  MOVLB  0
03C9E:  RCALL  38E4
....................    i2c_write(0b11111); 
03CA0:  MOVLW  1F
03CA2:  MOVLB  5
03CA4:  MOVWF  x7C
03CA6:  MOVLB  0
03CA8:  RCALL  38E4
....................    i2c_write(0b00000);  
03CAA:  MOVLB  5
03CAC:  CLRF   x7C
03CAE:  MOVLB  0
03CB0:  RCALL  38E4
....................   
....................    i2c_stop();  
03CB2:  BSF    FC5.2
03CB4:  BTFSC  FC5.2
03CB6:  BRA    3CB4
....................  
....................    i2c_start(); 
03CB8:  BSF    FC5.0
03CBA:  BTFSC  FC5.0
03CBC:  BRA    3CBA
....................    i2c_write(0x00);              // (0x00)Control byte 
03CBE:  MOVLB  5
03CC0:  CLRF   x7C
03CC2:  MOVLB  0
03CC4:  RCALL  38E4
....................    i2c_write(0x38);              // (0x38)Function Set: 8 bits, 
03CC6:  MOVLW  38
03CC8:  MOVLB  5
03CCA:  MOVWF  x7C
03CCC:  MOVLB  0
03CCE:  RCALL  38E4
....................    i2c_stop();                   //  use Instruction Table 0 
03CD0:  BSF    FC5.2
03CD2:  BTFSC  FC5.2
03CD4:  BRA    3CD2
....................     
....................    i2c_stop();  
03CD6:  BSF    FC5.2
03CD8:  BTFSC  FC5.2
03CDA:  BRA    3CD8
....................    delay_cycles(255); 
03CDC:  MOVLW  54
03CDE:  MOVWF  00
03CE0:  DECFSZ 00,F
03CE2:  BRA    3CE0
03CE4:  BRA    3CE6
....................     
....................    i2c_start();                             
03CE6:  BSF    FC5.0
03CE8:  BTFSC  FC5.0
03CEA:  BRA    3CE8
....................    i2c_write(LCD_ADDRESS);     // (0x7C)WRITE LCD address 
03CEC:  MOVLW  7C
03CEE:  MOVLB  5
03CF0:  MOVWF  x7C
03CF2:  MOVLB  0
03CF4:  RCALL  38E4
....................    i2c_write(0x00);     // (0x00)Control byte 
03CF6:  MOVLB  5
03CF8:  CLRF   x7C
03CFA:  MOVLB  0
03CFC:  RCALL  38E4
....................    i2c_write(0x38);     // (0x38)Function Set: 8 bits, use Instruction Table 0 
03CFE:  MOVLW  38
03D00:  MOVLB  5
03D02:  MOVWF  x7C
03D04:  MOVLB  0
03D06:  RCALL  38E4
.................... //   delay_ms(40); 
....................    delay_cycles(255); 
03D08:  MOVLW  54
03D0A:  MOVWF  00
03D0C:  DECFSZ 00,F
03D0E:  BRA    3D0C
03D10:  BRA    3D12
....................    i2c_write(0x39);     // (0x39)Function Set: 8 bits, use Instruction Table 1 
03D12:  MOVLW  39
03D14:  MOVLB  5
03D16:  MOVWF  x7C
03D18:  MOVLB  0
03D1A:  RCALL  38E4
.................... //   delay_ms(40); 
....................    delay_cycles(255); 
03D1C:  MOVLW  54
03D1E:  MOVWF  00
03D20:  DECFSZ 00,F
03D22:  BRA    3D20
03D24:  BRA    3D26
....................    i2c_write(0x14);     // (0x14)Internal OSC frequency 
03D26:  MOVLW  14
03D28:  MOVLB  5
03D2A:  MOVWF  x7C
03D2C:  MOVLB  0
03D2E:  RCALL  38E4
....................    i2c_write(0x74);     // (0x78 recommended, JG prefers 0x74)Contrast set 
03D30:  MOVLW  74
03D32:  MOVLB  5
03D34:  MOVWF  x7C
03D36:  MOVLB  0
03D38:  RCALL  38E4
....................    i2c_write(0x5E);     // (0x5E)ICON display ON, booster ON 
03D3A:  MOVLW  5E
03D3C:  MOVLB  5
03D3E:  MOVWF  x7C
03D40:  MOVLB  0
03D42:  RCALL  38E4
....................    i2c_write(0x6D);     // (0x6D)Follower circuit ON 
03D44:  MOVLW  6D
03D46:  MOVLB  5
03D48:  MOVWF  x7C
03D4A:  MOVLB  0
03D4C:  RCALL  38E4
.................... //   delay_ms(200); 
....................    delay_cycles(255); 
03D4E:  MOVLW  54
03D50:  MOVWF  00
03D52:  DECFSZ 00,F
03D54:  BRA    3D52
03D56:  BRA    3D58
....................    i2c_write(0x0C);     // (0x0C)Entire display ON;  
03D58:  MOVLW  0C
03D5A:  MOVLB  5
03D5C:  MOVWF  x7C
03D5E:  MOVLB  0
03D60:  RCALL  38E4
....................                         // (0x0F)Entire display ON/blink at cursor 
....................    i2c_write(0x01);     // (0x01)Clear display 
03D62:  MOVLW  01
03D64:  MOVLB  5
03D66:  MOVWF  x7C
03D68:  MOVLB  0
03D6A:  RCALL  38E4
....................    delay_ms(40); 
03D6C:  MOVLW  28
03D6E:  MOVLB  5
03D70:  MOVWF  x64
03D72:  MOVLB  0
03D74:  RCALL  38C8
....................    i2c_write(0x06);     // (0x06)Entry Mode Set 
03D76:  MOVLW  06
03D78:  MOVLB  5
03D7A:  MOVWF  x7C
03D7C:  MOVLB  0
03D7E:  RCALL  38E4
.................... //   delay_ms(40); 
....................    delay_cycles(255); 
03D80:  MOVLW  54
03D82:  MOVWF  00
03D84:  DECFSZ 00,F
03D86:  BRA    3D84
03D88:  BRA    3D8A
....................    i2c_write(0x38); 
03D8A:  MOVLW  38
03D8C:  MOVLB  5
03D8E:  MOVWF  x7C
03D90:  MOVLB  0
03D92:  RCALL  38E4
.................... //   delay_ms(40); 
....................    delay_cycles(255); 
03D94:  MOVLW  54
03D96:  MOVWF  00
03D98:  DECFSZ 00,F
03D9A:  BRA    3D98
03D9C:  BRA    3D9E
....................    i2c_stop(); 
03D9E:  BSF    FC5.2
03DA0:  BTFSC  FC5.2
03DA2:  BRA    3DA0
....................     
....................  
....................    i2c_start(); 
03DA4:  BSF    FC5.0
03DA6:  BTFSC  FC5.0
03DA8:  BRA    3DA6
....................    i2c_write(LCD_ADDRESS);     // (0x7C)WRITE LCD address 
03DAA:  MOVLW  7C
03DAC:  MOVLB  5
03DAE:  MOVWF  x7C
03DB0:  MOVLB  0
03DB2:  RCALL  38E4
....................    i2c_write(0x00);     // (0x00)Control byte 
03DB4:  MOVLB  5
03DB6:  CLRF   x7C
03DB8:  MOVLB  0
03DBA:  RCALL  38E4
....................    i2c_write(0x38);     // (0x38)Function Set: 8 bits, 
03DBC:  MOVLW  38
03DBE:  MOVLB  5
03DC0:  MOVWF  x7C
03DC2:  MOVLB  0
03DC4:  RCALL  38E4
....................                         //  use Instruction Table 0 
....................    i2c_write(0x18);     // Clear any shift 
03DC6:  MOVLW  18
03DC8:  MOVLB  5
03DCA:  MOVWF  x7C
03DCC:  MOVLB  0
03DCE:  RCALL  38E4
....................    i2c_write(0x20);     // CGRAM = 0 
03DD0:  MOVLW  20
03DD2:  MOVLB  5
03DD4:  MOVWF  x7C
03DD6:  MOVLB  0
03DD8:  RCALL  38E4
....................    // JG Jan 30 2015 
....................    i2c_write(0x38); 
03DDA:  MOVLW  38
03DDC:  MOVLB  5
03DDE:  MOVWF  x7C
03DE0:  MOVLB  0
03DE2:  RCALL  38E4
....................     
....................    i2c_stop(); 
03DE4:  BSF    FC5.2
03DE6:  BTFSC  FC5.2
03DE8:  BRA    3DE6
....................     
....................    strcpy (global_temp_line_buff, "                "); 
03DEA:  CLRF   FEA
03DEC:  MOVLW  70
03DEE:  MOVWF  FE9
03DF0:  MOVLW  00
03DF2:  CALL   04CA
03DF6:  TBLRD*-
03DF8:  TBLRD*+
03DFA:  MOVF   FF5,W
03DFC:  MOVWF  FEE
03DFE:  IORLW  00
03E00:  BNZ   3DF8
....................    LCD_line1(global_temp_line_buff); 
03E02:  MOVLB  5
03E04:  CLRF   x64
03E06:  MOVLW  70
03E08:  MOVWF  x63
03E0A:  MOVLB  0
03E0C:  RCALL  3932
....................    LCD_line2(global_temp_line_buff); 
03E0E:  MOVLB  5
03E10:  CLRF   x64
03E12:  MOVLW  70
03E14:  MOVWF  x63
03E16:  MOVLB  0
03E18:  RCALL  398C
....................  
....................    return; 
03E1A:  RETURN 0
.................... } 
....................  
.................... void LCD_line1(unsigned char *text) 
.................... { 
....................    uint8_t  n; 
....................  
....................    if (!global_lcd_enabled) return;   
*
03932:  BTFSS  xA7.0
03934:  BRA    398A
....................    LCD_position(0x00);   // Move to start of first line 
03936:  MOVLB  5
03938:  CLRF   x7A
0393A:  MOVLB  0
0393C:  RCALL  3900
....................    i2c_start(); 
0393E:  BSF    FC5.0
03940:  BTFSC  FC5.0
03942:  BRA    3940
....................    i2c_write(LCD_ADDRESS);   // WRITE LCD address 
03944:  MOVLW  7C
03946:  MOVLB  5
03948:  MOVWF  x7C
0394A:  MOVLB  0
0394C:  RCALL  38E4
....................    i2c_write(0x40);    // Datasend 
0394E:  MOVLW  40
03950:  MOVLB  5
03952:  MOVWF  x7C
03954:  MOVLB  0
03956:  RCALL  38E4
....................    for(n=0;n<16;n++) 
03958:  MOVLB  5
0395A:  CLRF   x65
0395C:  MOVF   x65,W
0395E:  SUBLW  0F
03960:  BNC   3982
....................    { 
....................       i2c_write(*text); 
03962:  MOVFF  564,03
03966:  MOVFF  563,FE9
0396A:  MOVFF  564,FEA
0396E:  MOVFF  FEF,57C
03972:  MOVLB  0
03974:  RCALL  38E4
....................       ++text; 
03976:  MOVLB  5
03978:  INCF   x63,F
0397A:  BTFSC  FD8.2
0397C:  INCF   x64,F
0397E:  INCF   x65,F
03980:  BRA    395C
....................    } 
....................    i2c_stop(); 
03982:  BSF    FC5.2
03984:  BTFSC  FC5.2
03986:  BRA    3984
03988:  MOVLB  0
0398A:  RETURN 0
.................... } 
....................  
.................... void LCD_line2(unsigned char *text) 
.................... { 
....................    uint8_t  n; 
....................     
....................    if (!global_lcd_enabled) return; 
0398C:  BTFSS  xA7.0
0398E:  BRA    39E6
....................    LCD_position(0x40);   // Move to start of second line 
03990:  MOVLW  40
03992:  MOVLB  5
03994:  MOVWF  x7A
03996:  MOVLB  0
03998:  RCALL  3900
....................    i2c_start(); 
0399A:  BSF    FC5.0
0399C:  BTFSC  FC5.0
0399E:  BRA    399C
....................    i2c_write(LCD_ADDRESS);   // WRITE LCD address 
039A0:  MOVLW  7C
039A2:  MOVLB  5
039A4:  MOVWF  x7C
039A6:  MOVLB  0
039A8:  RCALL  38E4
....................    i2c_write(0x40);    // Datasend 
039AA:  MOVLW  40
039AC:  MOVLB  5
039AE:  MOVWF  x7C
039B0:  MOVLB  0
039B2:  RCALL  38E4
....................    for(n=0;n<16;n++) 
039B4:  MOVLB  5
039B6:  CLRF   x65
039B8:  MOVF   x65,W
039BA:  SUBLW  0F
039BC:  BNC   39DE
....................    { 
....................       i2c_write(*text); 
039BE:  MOVFF  564,03
039C2:  MOVFF  563,FE9
039C6:  MOVFF  564,FEA
039CA:  MOVFF  FEF,57C
039CE:  MOVLB  0
039D0:  RCALL  38E4
....................       ++text; 
039D2:  MOVLB  5
039D4:  INCF   x63,F
039D6:  BTFSC  FD8.2
039D8:  INCF   x64,F
039DA:  INCF   x65,F
039DC:  BRA    39B8
....................    } 
....................    i2c_stop(); 
039DE:  BSF    FC5.2
039E0:  BTFSC  FC5.2
039E2:  BRA    39E0
039E4:  MOVLB  0
039E6:  RETURN 0
.................... } 
....................  
.................... void LCD_place_text(unsigned char *text, int1 row, uint8_t col, uint8_t length) 
.................... { 
....................    //places text at a particular position (row (0 or 1), col (0-15)). 
....................    //not much error checking (for speed) on row/col or length (don't cause seg fault) 
....................     
....................    uint8_t n; 
....................     
....................    if (!global_lcd_enabled) return; 
*
067B0:  BTFSS  xA7.0
067B2:  BRA    6836
....................    if (col < 16) 
067B4:  MOVLB  5
067B6:  MOVF   x76,W
067B8:  SUBLW  0F
067BA:  BNC   6834
....................    { 
....................       if (row == 0) LCD_position(col);   //set LCD position (row,col) 
067BC:  MOVF   x75,F
067BE:  BNZ   67CE
067C0:  MOVFF  576,57A
067C4:  MOVLB  0
067C6:  CALL   3900
067CA:  BRA    67DC
067CC:  MOVLB  5
....................       else LCD_position(0x40 + col); 
067CE:  MOVLW  40
067D0:  ADDWF  x76,W
067D2:  MOVWF  x79
067D4:  MOVWF  x7A
067D6:  MOVLB  0
067D8:  CALL   3900
....................        
....................       i2c_start(); 
067DC:  BSF    FC5.0
067DE:  BTFSC  FC5.0
067E0:  BRA    67DE
....................       i2c_write(LCD_ADDRESS);   // WRITE LCD address 
067E2:  MOVLW  7C
067E4:  MOVLB  5
067E6:  MOVWF  x7C
067E8:  MOVLB  0
067EA:  CALL   38E4
....................       i2c_write(0x40);    // Datasend 
067EE:  MOVLW  40
067F0:  MOVLB  5
067F2:  MOVWF  x7C
067F4:  MOVLB  0
067F6:  CALL   38E4
....................       for(n = 0; ((n < length) && ((n + col) < 16)); n++) 
067FA:  MOVLB  5
067FC:  CLRF   x78
067FE:  MOVF   x77,W
06800:  SUBWF  x78,W
06802:  BC    682E
06804:  MOVF   x76,W
06806:  ADDWF  x78,W
06808:  SUBLW  0F
0680A:  BNC   682E
....................       { 
....................         i2c_write(*text); 
0680C:  MOVFF  574,03
06810:  MOVFF  573,FE9
06814:  MOVFF  574,FEA
06818:  MOVFF  FEF,57C
0681C:  MOVLB  0
0681E:  CALL   38E4
....................         ++text; 
06822:  MOVLB  5
06824:  INCF   x73,F
06826:  BTFSC  FD8.2
06828:  INCF   x74,F
0682A:  INCF   x78,F
0682C:  BRA    67FE
....................       } 
....................       i2c_stop(); 
0682E:  BSF    FC5.2
06830:  BTFSC  FC5.2
06832:  BRA    6830
06834:  MOVLB  0
....................    } 
06836:  RETURN 0
.................... } 
....................  
.................... void LCD_place_char(char ascii, int1 row, uint8_t col) 
.................... { 
....................    //places a char at a particular position (row (0 or 1), col (0-15)). 
....................    //no error checking (for speed) on row/col (don't cause seg fault) 
....................     
....................    if (!global_lcd_enabled) return; 
*
04BB4:  BTFSS  xA7.0
04BB6:  BRA    4BE6
....................    if (col < 16) 
04BB8:  MOVLB  5
04BBA:  MOVF   x59,W
04BBC:  SUBLW  0F
04BBE:  BNC   4BE8
....................    { 
....................       if (row == 0) LCD_position(col);   //set LCD position (row,col) 
04BC0:  MOVF   x58,F
04BC2:  BNZ   4BD2
04BC4:  MOVFF  559,57A
04BC8:  MOVLB  0
04BCA:  CALL   3900
04BCE:  BRA    4BE0
04BD0:  MOVLB  5
....................       else LCD_position(0x40 + col); 
04BD2:  MOVLW  40
04BD4:  ADDWF  x59,W
04BD6:  MOVWF  x5A
04BD8:  MOVWF  x7A
04BDA:  MOVLB  0
04BDC:  CALL   3900
....................        
....................       LCD_char(ascii); 
04BE0:  MOVFF  557,55A
04BE4:  BRA    4B80
04BE6:  MOVLB  5
....................    } 
04BE8:  MOVLB  0
04BEA:  RETURN 0
.................... } 
....................  
.................... void LCD_place_uint8(uint8_t num, int1 row, uint8_t col, uint8_t length) 
.................... { 
....................    uint8_t n;  
....................     
....................    if (!global_lcd_enabled) return;   
*
06912:  BTFSS  xA7.0
06914:  BRA    69A0
....................     
....................    if (length <= 3) 
06916:  MOVLB  5
06918:  MOVF   x67,W
0691A:  SUBLW  03
0691C:  BNC   69A2
....................    { 
....................       for (n = 0; n < 3; n++) 
0691E:  CLRF   x68
06920:  MOVF   x68,W
06922:  SUBLW  02
06924:  BNC   6966
....................       { 
....................          *(global_temp_line_buff + (2 - n)) = ('0' + (num%10)); 
06926:  MOVLW  02
06928:  BSF    FD8.0
0692A:  SUBFWB x68,W
0692C:  ADDLW  70
0692E:  MOVWF  01
06930:  CLRF   03
06932:  BTFSC  FD8.0
06934:  INCF   03,F
06936:  MOVWF  FE9
06938:  MOVFF  03,FEA
0693C:  MOVFF  564,56B
06940:  MOVLW  0A
06942:  MOVWF  x6C
06944:  MOVLB  0
06946:  RCALL  68E6
06948:  MOVF   00,W
0694A:  ADDLW  30
0694C:  MOVWF  FEF
....................          num/=10; 
0694E:  MOVFF  564,56B
06952:  MOVLW  0A
06954:  MOVLB  5
06956:  MOVWF  x6C
06958:  MOVLB  0
0695A:  RCALL  68E6
0695C:  MOVFF  01,564
06960:  MOVLB  5
06962:  INCF   x68,F
06964:  BRA    6920
....................       } 
....................       global_extra_lcd_ptr = global_temp_line_buff; 
06966:  MOVLB  0
06968:  CLRF   x82
0696A:  MOVLW  70
0696C:  MOVWF  x81
....................       for (n = length; n < 3; n++) 
0696E:  MOVFF  567,568
06972:  MOVLB  5
06974:  MOVF   x68,W
06976:  SUBLW  02
06978:  BNC   6988
....................       { 
....................          ++global_extra_lcd_ptr; 
0697A:  MOVLB  0
0697C:  INCF   x81,F
0697E:  BTFSC  FD8.2
06980:  INCF   x82,F
06982:  MOVLB  5
06984:  INCF   x68,F
06986:  BRA    6974
....................       } 
....................        
....................       LCD_place_text(global_extra_lcd_ptr,row, col, length); 
06988:  MOVFF  82,574
0698C:  MOVFF  81,573
06990:  MOVFF  565,575
06994:  MOVFF  566,576
06998:  MOVFF  567,577
0699C:  MOVLB  0
0699E:  RCALL  67B0
069A0:  MOVLB  5
....................    }    
069A2:  MOVLB  0
069A4:  RETURN 0
.................... } 
....................  
.................... void LCD_place_uint16(uint16_t num, int1 row, uint8_t col, uint8_t length) 
.................... { 
....................    uint8_t n;   
....................    char *global_temp_line_buff[5]; 
....................     
....................    if (!global_lcd_enabled) return;   
*
06838:  BTFSS  xA7.0
0683A:  BRA    68E0
....................     
....................    if (length <= 5) 
0683C:  MOVLB  5
0683E:  MOVF   x67,W
06840:  SUBLW  05
06842:  BNC   68E2
....................    { 
....................       for (n = 0; n < 5; n++) 
06844:  CLRF   x68
06846:  MOVF   x68,W
06848:  SUBLW  04
0684A:  BNC   68A4
....................       { 
....................          *(global_temp_line_buff + (4 - n)) = ('0' + (num%10)); 
0684C:  MOVLW  04
0684E:  BSF    FD8.0
06850:  SUBFWB x68,W
06852:  ADDLW  69
06854:  MOVWF  01
06856:  MOVLW  05
06858:  MOVWF  03
0685A:  BTFSC  FD8.0
0685C:  INCF   03,F
0685E:  MOVFF  01,FE9
06862:  MOVFF  03,FEA
06866:  MOVFF  564,576
0686A:  MOVFF  563,575
0686E:  CLRF   x78
06870:  MOVLW  0A
06872:  MOVWF  x77
06874:  MOVLB  0
06876:  CALL   4306
0687A:  MOVF   00,W
0687C:  ADDLW  30
0687E:  MOVWF  FEF
....................          num/=10; 
06880:  MOVFF  564,576
06884:  MOVFF  563,575
06888:  MOVLB  5
0688A:  CLRF   x78
0688C:  MOVLW  0A
0688E:  MOVWF  x77
06890:  MOVLB  0
06892:  CALL   4306
06896:  MOVFF  02,564
0689A:  MOVFF  01,563
0689E:  MOVLB  5
068A0:  INCF   x68,F
068A2:  BRA    6846
....................       } 
....................       global_extra_lcd_ptr = global_temp_line_buff; 
068A4:  MOVLW  05
068A6:  MOVLB  0
068A8:  MOVWF  x82
068AA:  MOVLW  69
068AC:  MOVWF  x81
....................       for (n = length; n < 5; n++) 
068AE:  MOVFF  567,568
068B2:  MOVLB  5
068B4:  MOVF   x68,W
068B6:  SUBLW  04
068B8:  BNC   68C8
....................       { 
....................          ++global_extra_lcd_ptr; 
068BA:  MOVLB  0
068BC:  INCF   x81,F
068BE:  BTFSC  FD8.2
068C0:  INCF   x82,F
068C2:  MOVLB  5
068C4:  INCF   x68,F
068C6:  BRA    68B4
....................       } 
....................        
....................       LCD_place_text(global_extra_lcd_ptr,row, col, length); 
068C8:  MOVFF  82,574
068CC:  MOVFF  81,573
068D0:  MOVFF  565,575
068D4:  MOVFF  566,576
068D8:  MOVFF  567,577
068DC:  MOVLB  0
068DE:  RCALL  67B0
068E0:  MOVLB  5
....................    }    
068E2:  MOVLB  0
068E4:  RETURN 0
.................... } 
....................  
.................... void LCD_place_uint32(uint32_t num, int1 row, uint8_t col, uint8_t length) 
.................... { 
....................    uint8_t n;   
....................     
....................    if (!global_lcd_enabled) return;   
*
069A6:  BTFSS  xA7.0
069A8:  BRA    6AC0
....................     
....................    if (length <= 10) 
069AA:  MOVLB  5
069AC:  MOVF   x5C,W
069AE:  SUBLW  0A
069B0:  BTFSS  FD8.0
069B2:  BRA    6AC2
....................    { 
....................       for (n = 0; n < 10; n++) 
069B4:  CLRF   x5D
069B6:  MOVF   x5D,W
069B8:  SUBLW  09
069BA:  BNC   6A86
....................       { 
....................          *(global_temp_line_buff + (9 - n)) = ('0' + (num%10)); 
069BC:  MOVLW  09
069BE:  BSF    FD8.0
069C0:  SUBFWB x5D,W
069C2:  ADDLW  70
069C4:  MOVWF  01
069C6:  CLRF   03
069C8:  BTFSC  FD8.0
069CA:  INCF   03,F
069CC:  MOVWF  x5E
069CE:  MOVFF  03,55F
069D2:  MOVFF  FEA,561
069D6:  MOVFF  FE9,560
069DA:  BSF    FD8.1
069DC:  MOVLW  05
069DE:  MOVWF  FEA
069E0:  MOVLW  62
069E2:  MOVWF  FE9
069E4:  CLRF   19
069E6:  BTFSC  FF2.7
069E8:  BSF    19.7
069EA:  BCF    FF2.7
069EC:  MOVFF  559,5A4
069F0:  MOVFF  558,5A3
069F4:  MOVFF  557,5A2
069F8:  MOVFF  556,5A1
069FC:  CLRF   xA8
069FE:  CLRF   xA7
06A00:  CLRF   xA6
06A02:  MOVLW  0A
06A04:  MOVWF  xA5
06A06:  MOVLB  0
06A08:  CALL   2526
06A0C:  BTFSC  19.7
06A0E:  BSF    FF2.7
06A10:  MOVFF  562,00
06A14:  MOVFF  563,01
06A18:  MOVFF  564,02
06A1C:  MOVFF  565,03
06A20:  MOVFF  561,FEA
06A24:  MOVFF  560,FE9
06A28:  MOVLW  30
06A2A:  ADDWF  00,F
06A2C:  MOVLW  00
06A2E:  ADDWFC 01,F
06A30:  ADDWFC 02,F
06A32:  ADDWFC 03,F
06A34:  MOVFF  55F,FEA
06A38:  MOVFF  55E,FE9
06A3C:  MOVFF  00,FEF
....................          num/=10; 
06A40:  BCF    FD8.1
06A42:  CLRF   19
06A44:  BTFSC  FF2.7
06A46:  BSF    19.7
06A48:  BCF    FF2.7
06A4A:  MOVFF  559,5A4
06A4E:  MOVFF  558,5A3
06A52:  MOVFF  557,5A2
06A56:  MOVFF  556,5A1
06A5A:  MOVLB  5
06A5C:  CLRF   xA8
06A5E:  CLRF   xA7
06A60:  CLRF   xA6
06A62:  MOVLW  0A
06A64:  MOVWF  xA5
06A66:  MOVLB  0
06A68:  CALL   2526
06A6C:  BTFSC  19.7
06A6E:  BSF    FF2.7
06A70:  MOVFF  03,559
06A74:  MOVFF  02,558
06A78:  MOVFF  01,557
06A7C:  MOVFF  00,556
06A80:  MOVLB  5
06A82:  INCF   x5D,F
06A84:  BRA    69B6
....................       } 
....................       global_extra_lcd_ptr = global_temp_line_buff; 
06A86:  MOVLB  0
06A88:  CLRF   x82
06A8A:  MOVLW  70
06A8C:  MOVWF  x81
....................       for (n = length; n < 10; n++) 
06A8E:  MOVFF  55C,55D
06A92:  MOVLB  5
06A94:  MOVF   x5D,W
06A96:  SUBLW  09
06A98:  BNC   6AA8
....................       { 
....................          ++global_extra_lcd_ptr; 
06A9A:  MOVLB  0
06A9C:  INCF   x81,F
06A9E:  BTFSC  FD8.2
06AA0:  INCF   x82,F
06AA2:  MOVLB  5
06AA4:  INCF   x5D,F
06AA6:  BRA    6A94
....................       } 
....................        
....................       LCD_place_text(global_extra_lcd_ptr,row, col, length); 
06AA8:  MOVFF  82,574
06AAC:  MOVFF  81,573
06AB0:  MOVFF  55A,575
06AB4:  MOVFF  55B,576
06AB8:  MOVFF  55C,577
06ABC:  MOVLB  0
06ABE:  RCALL  67B0
06AC0:  MOVLB  5
....................    }    
06AC2:  MOVLB  0
06AC4:  RETURN 0
.................... } 
....................  
.................... void LCD_clear(void) 
.................... { 
....................    if (!global_lcd_enabled) return; 
*
05C18:  BTFSS  xA7.0
05C1A:  BRA    5C50
....................     
....................    strcpy (global_temp_line_buff, "                "); 
05C1C:  CLRF   FEA
05C1E:  MOVLW  70
05C20:  MOVWF  FE9
05C22:  MOVLW  00
05C24:  CALL   04CA
05C28:  TBLRD*-
05C2A:  TBLRD*+
05C2C:  MOVF   FF5,W
05C2E:  MOVWF  FEE
05C30:  IORLW  00
05C32:  BNZ   5C2A
....................    LCD_line1(global_temp_line_buff); 
05C34:  MOVLB  5
05C36:  CLRF   x64
05C38:  MOVLW  70
05C3A:  MOVWF  x63
05C3C:  MOVLB  0
05C3E:  CALL   3932
....................    LCD_line2(global_temp_line_buff); 
05C42:  MOVLB  5
05C44:  CLRF   x64
05C46:  MOVLW  70
05C48:  MOVWF  x63
05C4A:  MOVLB  0
05C4C:  CALL   398C
05C50:  RETURN 0
.................... } 
....................  
.................... void LCD_clear_line1(void) 
.................... { 
....................    if (!global_lcd_enabled) return; 
....................     
....................    strcpy (global_temp_line_buff, "                "); 
....................    LCD_line1(global_temp_line_buff); 
.................... } 
....................  
.................... void LCD_clear_line2(void) 
.................... { 
....................    if (!global_lcd_enabled) return; 
....................     
....................    strcpy (global_temp_line_buff, "                "); 
....................    LCD_line2(global_temp_line_buff); 
.................... } 
....................  
.................... void LCD_position(int position) 
.................... { 
....................    if (!global_lcd_enabled) return; 
*
03900:  BTFSS  xA7.0
03902:  BRA    3930
....................    i2c_start();                             
03904:  BSF    FC5.0
03906:  BTFSC  FC5.0
03908:  BRA    3906
....................    i2c_write(LCD_ADDRESS);     // (0x7C)WRITE LCD address 
0390A:  MOVLW  7C
0390C:  MOVLB  5
0390E:  MOVWF  x7C
03910:  MOVLB  0
03912:  RCALL  38E4
....................    i2c_write(0x00);     // (0x00)Control byte 
03914:  MOVLB  5
03916:  CLRF   x7C
03918:  MOVLB  0
0391A:  RCALL  38E4
....................    i2c_write(0x80+position); //  
0391C:  MOVLW  80
0391E:  MOVLB  5
03920:  ADDWF  x7A,W
03922:  MOVWF  x7B
03924:  MOVWF  x7C
03926:  MOVLB  0
03928:  RCALL  38E4
....................    i2c_stop(); 
0392A:  BSF    FC5.2
0392C:  BTFSC  FC5.2
0392E:  BRA    392C
03930:  RETURN 0
.................... } 
....................  
.................... void LCD_char(char ascii)    
.................... { 
....................    if (!global_lcd_enabled) return; 
*
04B80:  BTFSS  xA7.0
04B82:  BRA    4BB0
....................    i2c_start();                             
04B84:  BSF    FC5.0
04B86:  BTFSC  FC5.0
04B88:  BRA    4B86
....................    i2c_write(LCD_ADDRESS);   // WRITE LCD address 
04B8A:  MOVLW  7C
04B8C:  MOVLB  5
04B8E:  MOVWF  x7C
04B90:  MOVLB  0
04B92:  CALL   38E4
....................    i2c_write(0x40);    // Datasend 
04B96:  MOVLW  40
04B98:  MOVLB  5
04B9A:  MOVWF  x7C
04B9C:  MOVLB  0
04B9E:  CALL   38E4
....................    i2c_write(ascii);    //  
04BA2:  MOVFF  55A,57C
04BA6:  CALL   38E4
....................    i2c_stop(); 
04BAA:  BSF    FC5.2
04BAC:  BTFSC  FC5.2
04BAE:  BRA    4BAC
04BB0:  GOTO   4BE6 (RETURN)
.................... } 
....................  
.................... void LCD_shutdown(void)    
.................... {        
....................  
....................    if (!global_lcd_enabled) return;   
*
094C0:  BTFSS  xA7.0
094C2:  BRA    9534
....................        
....................    output_low(LCD_RESETn); 
094C4:  BCF    F8C.2
....................    delay_ms(5); 
094C6:  MOVLW  67
094C8:  MOVWF  00
094CA:  DECFSZ 00,F
094CC:  BRA    94CA
094CE:  BRA    94D0
....................    output_high(LCD_RESETn); 
094D0:  BSF    F8C.2
....................     
....................    i2c_start();                             
094D2:  BSF    FC5.0
094D4:  BTFSC  FC5.0
094D6:  BRA    94D4
....................    i2c_write(LCD_ADDRESS);     // WRITE LCD address 
094D8:  MOVLW  7C
094DA:  MOVLB  5
094DC:  MOVWF  x7C
094DE:  MOVLB  0
094E0:  CALL   38E4
....................    i2c_write(0x00);     // Control byte 
094E4:  MOVLB  5
094E6:  CLRF   x7C
094E8:  MOVLB  0
094EA:  CALL   38E4
....................    i2c_write(0x39);     // Function Set: 8 bits, use Instruction Table 1 
094EE:  MOVLW  39
094F0:  MOVLB  5
094F2:  MOVWF  x7C
094F4:  MOVLB  0
094F6:  CALL   38E4
....................    i2c_write(0x52);     // ICON display OFF, booster OFF 
094FA:  MOVLW  52
094FC:  MOVLB  5
094FE:  MOVWF  x7C
09500:  MOVLB  0
09502:  CALL   38E4
....................    i2c_write(0x60);     // Follower circuit OFF 
09506:  MOVLW  60
09508:  MOVLB  5
0950A:  MOVWF  x7C
0950C:  MOVLB  0
0950E:  CALL   38E4
....................    i2c_write(0x08);     // Entire display OFF 
09512:  MOVLW  08
09514:  MOVLB  5
09516:  MOVWF  x7C
09518:  MOVLB  0
0951A:  CALL   38E4
....................    i2c_stop(); 
0951E:  BSF    FC5.2
09520:  BTFSC  FC5.2
09522:  BRA    9520
....................     
....................    output_low(LCD_RESETn); 
09524:  BCF    F8C.2
....................    delay_ms(5); 
09526:  MOVLW  67
09528:  MOVWF  00
0952A:  DECFSZ 00,F
0952C:  BRA    952A
0952E:  BRA    9530
....................    output_high(LCD_RESETn); 
09530:  BSF    F8C.2
....................    global_lcd_enabled = 0; 
09532:  BCF    xA7.0
09534:  GOTO   95BA (RETURN)
.................... } 
....................  
.................... void LCD_startup_splash(void) 
.................... {                               
....................    uint8_t n; 
....................     
....................    if (!global_lcd_enabled) return; 
....................     
....................    strcpy(global_temp_line_buff, "Jain Genesys    "); 
....................    for (n = 0; n < 16; n++) 
....................       { 
....................       LCD_place_text(global_temp_line_buff,0,(15-n),16); 
....................       setup_T0_int(T0_100MS); 
....................       while (!TMR0IF); 
....................       } 
....................    strcpy(global_temp_line_buff, "Version         ");    
....................    for (n = 0; n < 16; n++) 
....................    { 
....................       LCD_place_text(global_temp_line_buff,1,(15-n),16); 
....................       setup_T0_int(T0_100MS); 
....................       while (!TMR0IF); 
....................    }    
....................    strcpy(global_temp_line_buff, global_firmware_version_string); 
....................    LCD_place_text(global_temp_line_buff,1,8,4); 
....................    setup_T0_int(T0_2S); 
....................    while (!TMR0IF); 
....................    for (n = 0; n < 16; n++) 
....................    { 
....................       LCD_place_char(' ',0,(15-n)); 
....................       LCD_place_char(' ',1,(15-n)); 
....................       setup_T0_int(T0_100MS); 
....................       while (!TMR0IF);  
....................    }    
.................... } 
.................... /* 
.................... void LCD_display_battery_voltage(int1 lcd_line) 
.................... { 
....................    //Grabs and displays battery voltage on LCD 
....................    //Takes the LCD line that it should be displayed 
....................    //on as input. 
....................  
....................     
....................    uint8_t temp_bat_int_part = 0; 
....................    uint16_t temp_bat_fract_part = 0; 
....................    uint32_t temp_bat_both_part = 0; 
....................    char * digit_result; 
....................     
....................    if (!global_lcd_enabled) return; 
....................    //set line buffer to all spaces 
....................    char lcd_line_buff[17] = {' '}; 
....................     
....................    strcpy (lcd_line_buff, "Battery = ?.???V"); 
....................  
....................    // get the battery count (not charging) 
....................    // and convert it to a voltage 
....................    temp_bat_both_part = calc_vbatt(get_vbatt(1)); 
....................    temp_bat_fract_part = (uint16_t) (temp_bat_both_part); 
....................    temp_bat_int_part = (uint8_t) (temp_bat_both_part >> 16); 
....................    digit_result = word_to_4dig_new(temp_bat_fract_part); 
....................     
....................     
....................    if (digit_result != 0) 
....................    { 
....................       lcd_line_buff[10] = '0' + temp_bat_int_part; 
....................       lcd_line_buff[12] = digit_result[3]; 
....................       lcd_line_buff[13] = digit_result[2]; 
....................       lcd_line_buff[14] = digit_result[1]; 
....................    } 
....................    else 
....................    { 
....................       strcpy (lcd_line_buff, "Battery ERROR!  "); 
....................    } 
....................     
....................    if (lcd_line == 0) 
....................    { 
....................       LCD_line1(lcd_line_buff); 
....................    } 
....................    else if (lcd_line == 1) 
....................    { 
....................       LCD_line2(lcd_line_buff); 
....................    } 
.................... } 
....................  
.................... uint32_t LCD_battery_screen(uint16_t vRef) 
.................... { 
.................... //Puts the battery voltage on the LCD across both screens 
.................... // 
.................... } 
....................  
....................  
.................... void LCD_display_revision(int1 lcd_line) 
.................... { 
....................    if (!global_lcd_enabled) return; 
....................    strcpy (line2_buff, "Rev.            "); 
....................    tempo_u8 = make8(FIRMWARE_REV,1); 
....................    line2_buff[4] = hi2asc(tempo_u8); 
....................     
.................... #ifdef  WIP 
....................    line2_buff[4] += 0x20;     // lowercase if work in progress 
.................... #endif 
....................    line2_buff[5] = lo2asc(tempo_u8); 
....................    tempo_u8 = make8(FIRMWARE_REV,0); 
....................    line2_buff[6] = hi2asc(tempo_u8); 
....................    line2_buff[7] = lo2asc(tempo_u8); 
....................   
.................... } 
.................... */ 
....................  
.................... void LCD_display_priority_time_stacks(void) 
.................... {                                            
....................       if (!global_lcd_enabled) return;     
....................        
....................    disable_interrupts(GLOBAL); 
....................    LCD_place_uint8(global_current_priority_queue_location, 0, 0, 3);      
....................        
....................       if (global_current_priority_queue_location != 255) 
....................       {      
....................          LCD_place_uint8(global_priority_queue[global_current_priority_queue_location], 0, 4, 3); 
....................       } 
....................       else 
....................       {       
....................          strcpy (global_temp_line_buff, "   "); 
....................          LCD_place_text(global_temp_line_buff, 0, 4, 3); 
....................       } 
....................        
....................       LCD_place_uint8(global_current_time_queue_location, 0, 8, 3); 
....................        
....................       if (global_current_time_queue_location != 255) 
....................       { 
....................          LCD_place_uint8(global_priority_queue[global_current_time_queue_location], 0, 12, 3); 
....................       } 
....................       else 
....................       {       
....................          strcpy (global_temp_line_buff, "   "); 
....................          LCD_place_text(global_temp_line_buff, 0, 12, 3); 
....................       } 
....................       enable_interrupts(GLOBAL); 
.................... }  
....................  
.................... void LCD_display_priority_time_stacks_2(void) 
.................... { 
....................    uint8_t n; 
....................     
....................    disable_interrupts(INT_CCP4); 
....................    LCD_clear(); 
....................    for (n = 0; n < MAX_TIME_QUEUE_ITEMS; n++) 
....................    { 
....................       LCD_place_uint8(n,0,0,1); 
....................       LCD_place_uint8(global_time_queue[n].pq_priority,0,2,3);                       
....................       LCD_place_uint32(global_time_queue[n].time_to_execute,0,6,5); 
....................       LCD_place_uint8(global_current_time_queue_location, 0, 12, 3);        
....................       setup_T0_int(T0_250MS);                                                       
....................       while (!TMR0IF);     
....................    }                               
....................    enable_interrupts(INT_CCP4);                                  
.................... } 
....................  
.................... void LCD_display_priority_queue(void) 
.................... { 
....................    uint8_t n; 
....................     
....................    disable_interrupts(GLOBAL); 
....................    LCD_clear(); 
....................    for (n = 0; n < MAX_PRIORITY_QUEUE_ITEMS; n++) 
....................    { 
....................       LCD_place_uint8(n,0,0,2); 
....................       LCD_place_uint8(global_priority_queue[n],0,3,3); 
....................       LCD_place_uint8(global_current_priority_queue_location, 0, 7, 3); 
....................       if (global_priority_queue[n] != EMPTY_PRIORITY_QUEUE) 
....................          setup_T0_int(T0_1S); 
....................       while (!TMR0IF); 
....................    } 
....................    enable_interrupts(GLOBAL); 
.................... } 
....................                  
.................... void LCD_display_message_queue(void)  
.................... { 
....................    uint8_t n; 
....................    disable_interrupts(INT_CCP4); 
....................     
....................    for (n = global_current_message_queue_location; n != 255; n--) 
....................    {                                                                                                                          
....................       LCD_clear(); 
....................       LCD_place_uint8(n, 0, 0, 3);                                 
....................       LCD_place_uint32(global_message_queue[n].time_to_send, 0, 4, 10); 
....................       LCD_place_uint8(global_message_queue[n].message_type, 1, 0, 3); 
....................       LCD_place_uint16(global_message_queue[n].msg_seq, 1, 4, 5);  
....................       LCD_place_uint8(global_message_queue[n].attempt_num, 1, 10, 3);  
....................       while(input(SW1n)); 
....................    }                          
....................    LCD_clear(); 
....................    enable_interrupts(INT_CCP4);   
.................... }                                                                        
.................... void LCD_display_battery_voltage(int1 lcd_line) 
.................... {                                            
....................    if (!global_lcd_enabled) return;     
*
04D86:  BTFSS  xA7.0
04D88:  BRA    4DD6
....................  
....................    strcpy (global_temp_line_buff, "Vbatt =      V  "); 
04D8A:  CLRF   FEA
04D8C:  MOVLW  70
04D8E:  MOVWF  FE9
04D90:  MOVLW  00
04D92:  CALL   04EC
04D96:  TBLRD*-
04D98:  TBLRD*+
04D9A:  MOVF   FF5,W
04D9C:  MOVWF  FEE
04D9E:  IORLW  00
04DA0:  BNZ   4D98
....................    if (lcd_line == 0) LCD_line1(global_temp_line_buff); 
04DA2:  MOVLB  5
04DA4:  MOVF   x4B,F
04DA6:  BNZ   4DB8
04DA8:  CLRF   x64
04DAA:  MOVLW  70
04DAC:  MOVWF  x63
04DAE:  MOVLB  0
04DB0:  CALL   3932
04DB4:  BRA    4DC4
04DB6:  MOVLB  5
....................    else LCD_line2(global_temp_line_buff); 
04DB8:  CLRF   x64
04DBA:  MOVLW  70
04DBC:  MOVWF  x63
04DBE:  MOVLB  0
04DC0:  CALL   398C
....................    LCD_display_batt_voltage(lcd_line, 8, 2); 
04DC4:  MOVFF  54B,54C
04DC8:  MOVLW  08
04DCA:  MOVLB  5
04DCC:  MOVWF  x4D
04DCE:  MOVLW  02
04DD0:  MOVWF  x4E
04DD2:  MOVLB  0
04DD4:  RCALL  4BEC
04DD6:  GOTO   A2CA (RETURN)
.................... //   LCD_place_uint8((uint8_t)(battery_voltage>>16),lcd_line,8,1); 
.................... //   LCD_place_uint16((uint16_t)battery_voltage,lcd_line,10,4); 
.................... } 
....................  
.................... void LCD_display_batt_voltage(int1 lcd_line, uint8_t col, uint8_t precision) 
.................... { 
....................    // precision is the number of digits to the right of the decimal pt 
....................    // Valid values are 1, 2, 3 
....................    // The assumption is that there is a SINGLE digit preceeding the dp 
....................     
....................    if (!global_lcd_enabled) return; 
*
04BEC:  BTFSS  xA7.0
04BEE:  BRA    4D80
....................  
....................    if (col>15) 
04BF0:  MOVLB  5
04BF2:  MOVF   x4D,W
04BF4:  SUBLW  0F
04BF6:  BC    4BFE
....................       return; 
04BF8:  MOVLB  0
04BFA:  BRA    4D80
04BFC:  MOVLB  5
....................    if (precision > 3) 
04BFE:  MOVF   x4E,W
04C00:  SUBLW  03
04C02:  BC    4C08
....................       precision = 3;   
04C04:  MOVLW  03
04C06:  MOVWF  x4E
....................     
....................    if ((precision == 3) && (col > 11)) 
04C08:  MOVF   x4E,W
04C0A:  SUBLW  03
04C0C:  BNZ   4C16
04C0E:  MOVF   x4D,W
04C10:  SUBLW  0B
04C12:  BC    4C16
....................       precision--; 
04C14:  DECF   x4E,F
....................    if ((precision == 2) && (col > 12)) 
04C16:  MOVF   x4E,W
04C18:  SUBLW  02
04C1A:  BNZ   4C24
04C1C:  MOVF   x4D,W
04C1E:  SUBLW  0C
04C20:  BC    4C24
....................       precision--; 
04C22:  DECF   x4E,F
....................    if ((precision == 1) && (col > 13)) 
04C24:  DECFSZ x4E,W
04C26:  BRA    4C30
04C28:  MOVF   x4D,W
04C2A:  SUBLW  0D
04C2C:  BC    4C30
....................       precision--; 
04C2E:  DECF   x4E,F
....................        
....................    uint16_t battery_voltage_BCD = calc_vbatt_BCD(get_vbatt(1)); 
....................  
....................    uint8_t volts = '0' + (uint8_t)(battery_voltage_BCD >> 12); 
....................    uint8_t tenths = '0' + (uint8_t)((battery_voltage_BCD & 0x0F00) >> 8); 
....................    uint8_t hundredths = '0' + (uint8_t)((battery_voltage_BCD & 0x00F0) >> 4); 
....................    uint8_t thousandths = '0' + (uint8_t)(battery_voltage_BCD & 0x000F); 
04C30:  MOVLW  01
04C32:  MOVWF  x68
04C34:  MOVLB  0
04C36:  CALL   4236
04C3A:  MOVFF  02,556
04C3E:  MOVFF  01,555
04C42:  MOVFF  02,558
04C46:  MOVFF  01,557
04C4A:  BRA    4992
04C4C:  MOVFF  02,550
04C50:  MOVFF  01,54F
04C54:  MOVLB  5
04C56:  SWAPF  x50,W
04C58:  MOVWF  02
04C5A:  CLRF   03
04C5C:  MOVLW  0F
04C5E:  ANDWF  02,F
04C60:  MOVF   02,W
04C62:  ADDLW  30
04C64:  MOVWF  x51
04C66:  CLRF   x55
04C68:  MOVF   x50,W
04C6A:  ANDLW  0F
04C6C:  MOVWF  x56
04C6E:  CLRF   03
04C70:  ADDLW  30
04C72:  MOVWF  x52
04C74:  MOVF   x4F,W
04C76:  ANDLW  F0
04C78:  MOVWF  x55
04C7A:  CLRF   x56
04C7C:  RRCF   x56,W
04C7E:  MOVWF  03
04C80:  RRCF   x55,W
04C82:  MOVWF  02
04C84:  RRCF   03,F
04C86:  RRCF   02,F
04C88:  RRCF   03,F
04C8A:  RRCF   02,F
04C8C:  RRCF   03,F
04C8E:  RRCF   02,F
04C90:  MOVLW  0F
04C92:  ANDWF  03,F
04C94:  MOVF   02,W
04C96:  ADDLW  30
04C98:  MOVWF  x53
04C9A:  MOVF   x4F,W
04C9C:  ANDLW  0F
04C9E:  MOVWF  00
04CA0:  MOVF   00,W
04CA2:  ADDLW  30
04CA4:  MOVWF  x54
....................    
....................    switch (precision) 
04CA6:  MOVF   x4E,W
04CA8:  XORLW  00
04CAA:  MOVLB  0
04CAC:  BZ    4CB8
04CAE:  XORLW  01
04CB0:  BZ    4CC6
04CB2:  XORLW  03
04CB4:  BZ    4CE0
04CB6:  BRA    4D04
....................    { 
....................       case 0: 
....................          if (tenths > '5') 
04CB8:  MOVLB  5
04CBA:  MOVF   x52,W
04CBC:  SUBLW  35
04CBE:  BC    4CC2
....................             volts++; 
04CC0:  INCF   x51,F
....................          break; 
04CC2:  MOVLB  0
04CC4:  BRA    4D04
....................        
....................       case 1: 
....................          if (hundredths > '5') 
04CC6:  MOVLB  5
04CC8:  MOVF   x53,W
04CCA:  SUBLW  35
04CCC:  BC    4CD0
....................             tenths++; 
04CCE:  INCF   x52,F
....................          if (tenths > '9' ) 
04CD0:  MOVF   x52,W
04CD2:  SUBLW  39
04CD4:  BC    4CDC
....................          { 
....................             volts++; 
04CD6:  INCF   x51,F
....................             tenths = '0'; 
04CD8:  MOVLW  30
04CDA:  MOVWF  x52
....................          } 
....................          break; 
04CDC:  MOVLB  0
04CDE:  BRA    4D04
....................  
....................       case 2: 
....................          if (thousandths > '5') 
04CE0:  MOVLB  5
04CE2:  MOVF   x54,W
04CE4:  SUBLW  35
04CE6:  BC    4CEA
....................             hundredths++; 
04CE8:  INCF   x53,F
....................          if (hundredths > '9') 
04CEA:  MOVF   x53,W
04CEC:  SUBLW  39
04CEE:  BC    4CF6
....................          { 
....................             tenths++; 
04CF0:  INCF   x52,F
....................             hundredths = '0'; 
04CF2:  MOVLW  30
04CF4:  MOVWF  x53
....................          } 
....................          if (tenths > '9') 
04CF6:  MOVF   x52,W
04CF8:  SUBLW  39
04CFA:  BC    4D02
....................          { 
....................             volts++; 
04CFC:  INCF   x51,F
....................             tenths = '0'; 
04CFE:  MOVLW  30
04D00:  MOVWF  x52
....................          }          
....................          break; 
04D02:  MOVLB  0
....................    } 
....................    
....................    LCD_place_char (volts, lcd_line, col++); 
04D04:  MOVLB  5
04D06:  MOVF   x4D,W
04D08:  INCF   x4D,F
04D0A:  MOVWF  x55
04D0C:  MOVFF  551,557
04D10:  MOVFF  54C,558
04D14:  MOVWF  x59
04D16:  MOVLB  0
04D18:  RCALL  4BB4
....................     
....................    if (precision) 
04D1A:  MOVLB  5
04D1C:  MOVF   x4E,F
04D1E:  BZ    4D82
....................    { 
....................       LCD_place_char ('.', lcd_line, col++); 
04D20:  MOVF   x4D,W
04D22:  INCF   x4D,F
04D24:  MOVWF  x55
04D26:  MOVLW  2E
04D28:  MOVWF  x57
04D2A:  MOVFF  54C,558
04D2E:  MOVFF  555,559
04D32:  MOVLB  0
04D34:  RCALL  4BB4
....................       LCD_place_char (tenths, lcd_line, col++); 
04D36:  MOVLB  5
04D38:  MOVF   x4D,W
04D3A:  INCF   x4D,F
04D3C:  MOVWF  x55
04D3E:  MOVFF  552,557
04D42:  MOVFF  54C,558
04D46:  MOVWF  x59
04D48:  MOVLB  0
04D4A:  RCALL  4BB4
....................         
....................       if (precision > 1) 
04D4C:  MOVLB  5
04D4E:  MOVF   x4E,W
04D50:  SUBLW  01
04D52:  BC    4D6A
....................          LCD_place_char (hundredths, lcd_line, col++); 
04D54:  MOVF   x4D,W
04D56:  INCF   x4D,F
04D58:  MOVWF  x55
04D5A:  MOVFF  553,557
04D5E:  MOVFF  54C,558
04D62:  MOVWF  x59
04D64:  MOVLB  0
04D66:  RCALL  4BB4
04D68:  MOVLB  5
....................       if (precision > 2) 
04D6A:  MOVF   x4E,W
04D6C:  SUBLW  02
04D6E:  BC    4D82
....................          LCD_place_char (thousandths, lcd_line, col); 
04D70:  MOVFF  554,557
04D74:  MOVFF  54C,558
04D78:  MOVFF  54D,559
04D7C:  MOVLB  0
04D7E:  RCALL  4BB4
04D80:  MOVLB  5
....................    } 
04D82:  MOVLB  0
04D84:  RETURN 0
.................... }     
....................   
.................... void LCD_display_vgen(int1 lcd_line, uint8_t col, uint8_t precision) 
.................... { 
....................    // precision is the number of digits to the right of the decimal pt 
....................    // Valid values are 1, 2, 3 
....................    // The assumption is that there are 2 digits preceding the decimpal point 
....................     
....................    if (!global_lcd_enabled) return; 
*
084F0:  BTFSS  xA7.0
084F2:  BRA    86DC
....................  
....................    if (col>15) 
084F4:  MOVLB  5
084F6:  MOVF   x4D,W
084F8:  SUBLW  0F
084FA:  BC    8502
....................       return; 
084FC:  MOVLB  0
084FE:  BRA    86DC
08500:  MOVLB  5
....................    if (precision > 3) 
08502:  MOVF   x4E,W
08504:  SUBLW  03
08506:  BC    850C
....................       precision = 3;   
08508:  MOVLW  03
0850A:  MOVWF  x4E
....................     
....................    if ((precision == 3) && (col > 10)) 
0850C:  MOVF   x4E,W
0850E:  SUBLW  03
08510:  BNZ   851A
08512:  MOVF   x4D,W
08514:  SUBLW  0A
08516:  BC    851A
....................       precision--; 
08518:  DECF   x4E,F
....................    if ((precision == 2) && (col > 11)) 
0851A:  MOVF   x4E,W
0851C:  SUBLW  02
0851E:  BNZ   8528
08520:  MOVF   x4D,W
08522:  SUBLW  0B
08524:  BC    8528
....................       precision--; 
08526:  DECF   x4E,F
....................    if ((precision == 1) && (col > 12)) 
08528:  DECFSZ x4E,W
0852A:  BRA    8534
0852C:  MOVF   x4D,W
0852E:  SUBLW  0C
08530:  BC    8534
....................       precision--; 
08532:  DECF   x4E,F
....................        
....................    uint16_t vgen_BCD = calc_vgen_BCD(get_vgen(0)); 
....................  
....................    uint8_t tens = '0' + (uint8_t)(vgen_BCD >> 12)/10; 
....................    uint8_t volts = '0' + (uint8_t)(vgen_BCD >> 12)%10; 
....................    uint8_t tenths = '0' + (uint8_t)((vgen_BCD & 0x0F00) >> 8); 
....................    uint8_t hundredths = '0' + (uint8_t)((vgen_BCD & 0x00F0) >> 4); 
....................    uint8_t thousandths = '0' + (uint8_t)(vgen_BCD & 0x000F); 
08534:  CLRF   x57
08536:  MOVLB  0
08538:  CALL   4290
0853C:  MOVFF  02,557
08540:  MOVFF  01,556
08544:  MOVFF  02,559
08548:  MOVFF  01,558
0854C:  BRA    82EA
0854E:  MOVFF  02,550
08552:  MOVFF  01,54F
08556:  MOVLB  5
08558:  SWAPF  x50,W
0855A:  MOVWF  02
0855C:  CLRF   03
0855E:  MOVLW  0F
08560:  ANDWF  02,F
08562:  MOVFF  02,557
08566:  MOVFF  02,56B
0856A:  MOVLW  0A
0856C:  MOVWF  x6C
0856E:  MOVLB  0
08570:  CALL   68E6
08574:  MOVF   01,W
08576:  ADDLW  30
08578:  MOVLB  5
0857A:  MOVWF  x51
0857C:  SWAPF  x50,W
0857E:  MOVWF  02
08580:  CLRF   03
08582:  MOVLW  0F
08584:  ANDWF  02,F
08586:  MOVFF  02,557
0858A:  MOVFF  02,56B
0858E:  MOVLW  0A
08590:  MOVWF  x6C
08592:  MOVLB  0
08594:  CALL   68E6
08598:  MOVF   00,W
0859A:  ADDLW  30
0859C:  MOVLB  5
0859E:  MOVWF  x52
085A0:  CLRF   x56
085A2:  MOVF   x50,W
085A4:  ANDLW  0F
085A6:  MOVWF  x57
085A8:  CLRF   03
085AA:  ADDLW  30
085AC:  MOVWF  x53
085AE:  MOVF   x4F,W
085B0:  ANDLW  F0
085B2:  MOVWF  x56
085B4:  CLRF   x57
085B6:  RRCF   x57,W
085B8:  MOVWF  03
085BA:  RRCF   x56,W
085BC:  MOVWF  02
085BE:  RRCF   03,F
085C0:  RRCF   02,F
085C2:  RRCF   03,F
085C4:  RRCF   02,F
085C6:  RRCF   03,F
085C8:  RRCF   02,F
085CA:  MOVLW  0F
085CC:  ANDWF  03,F
085CE:  MOVF   02,W
085D0:  ADDLW  30
085D2:  MOVWF  x54
085D4:  MOVF   x4F,W
085D6:  ANDLW  0F
085D8:  MOVWF  00
085DA:  MOVF   00,W
085DC:  ADDLW  30
085DE:  MOVWF  x55
....................    
....................    switch (precision) 
085E0:  MOVF   x4E,W
085E2:  XORLW  00
085E4:  MOVLB  0
085E6:  BZ    85F2
085E8:  XORLW  01
085EA:  BZ    8600
085EC:  XORLW  03
085EE:  BZ    861A
085F0:  BRA    863E
....................    { 
....................       case 0: 
....................          if (tenths > '5') 
085F2:  MOVLB  5
085F4:  MOVF   x53,W
085F6:  SUBLW  35
085F8:  BC    85FC
....................             volts++; 
085FA:  INCF   x52,F
....................          break; 
085FC:  MOVLB  0
085FE:  BRA    863E
....................        
....................       case 1: 
....................          if (hundredths > '5') 
08600:  MOVLB  5
08602:  MOVF   x54,W
08604:  SUBLW  35
08606:  BC    860A
....................             tenths++; 
08608:  INCF   x53,F
....................          if (tenths > '9' ) 
0860A:  MOVF   x53,W
0860C:  SUBLW  39
0860E:  BC    8616
....................          { 
....................             volts++; 
08610:  INCF   x52,F
....................             tenths = '0'; 
08612:  MOVLW  30
08614:  MOVWF  x53
....................          } 
....................          break; 
08616:  MOVLB  0
08618:  BRA    863E
....................  
....................       case 2: 
....................          if (thousandths > '5') 
0861A:  MOVLB  5
0861C:  MOVF   x55,W
0861E:  SUBLW  35
08620:  BC    8624
....................             hundredths++; 
08622:  INCF   x54,F
....................          if (hundredths > '9') 
08624:  MOVF   x54,W
08626:  SUBLW  39
08628:  BC    8630
....................          { 
....................             tenths++; 
0862A:  INCF   x53,F
....................             hundredths = '0'; 
0862C:  MOVLW  30
0862E:  MOVWF  x54
....................          } 
....................          if (tenths > '9') 
08630:  MOVF   x53,W
08632:  SUBLW  39
08634:  BC    863C
....................          { 
....................             volts++; 
08636:  INCF   x52,F
....................             tenths = '0'; 
08638:  MOVLW  30
0863A:  MOVWF  x53
....................          }          
....................          break; 
0863C:  MOVLB  0
....................    } 
....................    
....................    LCD_place_char (tens, lcd_line, col++); 
0863E:  MOVLB  5
08640:  MOVF   x4D,W
08642:  INCF   x4D,F
08644:  MOVWF  x56
08646:  MOVFF  551,557
0864A:  MOVFF  54C,558
0864E:  MOVWF  x59
08650:  MOVLB  0
08652:  CALL   4BB4
....................    LCD_place_char (volts, lcd_line, col++); 
08656:  MOVLB  5
08658:  MOVF   x4D,W
0865A:  INCF   x4D,F
0865C:  MOVWF  x56
0865E:  MOVFF  552,557
08662:  MOVFF  54C,558
08666:  MOVWF  x59
08668:  MOVLB  0
0866A:  CALL   4BB4
....................     
....................    if (precision) 
0866E:  MOVLB  5
08670:  MOVF   x4E,F
08672:  BZ    86DE
....................    { 
....................       LCD_place_char ('.', lcd_line, col++); 
08674:  MOVF   x4D,W
08676:  INCF   x4D,F
08678:  MOVWF  x56
0867A:  MOVLW  2E
0867C:  MOVWF  x57
0867E:  MOVFF  54C,558
08682:  MOVFF  556,559
08686:  MOVLB  0
08688:  CALL   4BB4
....................       LCD_place_char (tenths, lcd_line, col++); 
0868C:  MOVLB  5
0868E:  MOVF   x4D,W
08690:  INCF   x4D,F
08692:  MOVWF  x56
08694:  MOVFF  553,557
08698:  MOVFF  54C,558
0869C:  MOVWF  x59
0869E:  MOVLB  0
086A0:  CALL   4BB4
....................         
....................       if (precision > 1) 
086A4:  MOVLB  5
086A6:  MOVF   x4E,W
086A8:  SUBLW  01
086AA:  BC    86C4
....................          LCD_place_char (hundredths, lcd_line, col++); 
086AC:  MOVF   x4D,W
086AE:  INCF   x4D,F
086B0:  MOVWF  x56
086B2:  MOVFF  554,557
086B6:  MOVFF  54C,558
086BA:  MOVWF  x59
086BC:  MOVLB  0
086BE:  CALL   4BB4
086C2:  MOVLB  5
....................       if (precision > 2) 
086C4:  MOVF   x4E,W
086C6:  SUBLW  02
086C8:  BC    86DE
....................          LCD_place_char (thousandths, lcd_line, col); 
086CA:  MOVFF  555,557
086CE:  MOVFF  54C,558
086D2:  MOVFF  54D,559
086D6:  MOVLB  0
086D8:  CALL   4BB4
086DC:  MOVLB  5
....................    } 
086DE:  MOVLB  0
086E0:  GOTO   8CB0 (RETURN)
.................... }     
....................  
.................... void LCD_display_shutdown_cause(int1 lcd_line)            
.................... {                    
....................    if (!global_lcd_enabled) return;     
*
04DDA:  BTFSS  xA7.0
04DDC:  BRA    4E30
....................     
....................    strcpy (global_temp_line_buff, "Shtdwn Cause:   "); 
04DDE:  CLRF   FEA
04DE0:  MOVLW  70
04DE2:  MOVWF  FE9
04DE4:  MOVLW  00
04DE6:  CALL   050E
04DEA:  TBLRD*-
04DEC:  TBLRD*+
04DEE:  MOVF   FF5,W
04DF0:  MOVWF  FEE
04DF2:  IORLW  00
04DF4:  BNZ   4DEC
....................    global_temp_line_buff[14] = hi2asc(global_previous_shutdown_cause); 
04DF6:  MOVFF  4E,564
04DFA:  CALL   3276
04DFE:  MOVFF  01,7E
....................    global_temp_line_buff[15] = lo2asc(global_previous_shutdown_cause); 
04E02:  MOVFF  4E,564
04E06:  CALL   3296
04E0A:  MOVFF  01,7F
....................    if (lcd_line == 0) LCD_line1(global_temp_line_buff); 
04E0E:  MOVLB  5
04E10:  MOVF   x4B,F
04E12:  BNZ   4E24
04E14:  CLRF   x64
04E16:  MOVLW  70
04E18:  MOVWF  x63
04E1A:  MOVLB  0
04E1C:  CALL   3932
04E20:  BRA    4E30
04E22:  MOVLB  5
....................    else LCD_line2(global_temp_line_buff); 
04E24:  CLRF   x64
04E26:  MOVLW  70
04E28:  MOVWF  x63
04E2A:  MOVLB  0
04E2C:  CALL   398C
04E30:  GOTO   A2D6 (RETURN)
.................... } 
....................                                      
.................... void LCD_update_diplay(void)            
*
086E4:  MOVLW  20
086E6:  MOVLB  5
086E8:  MOVWF  x4B
.................... {                                       
....................    // char for displaying mote state    
....................    char state_char = ' ';                 
....................        
....................    switch(global_lcd_page_number)       
086EA:  MOVLB  0
086EC:  MOVF   x84,W
086EE:  XORLW  01
086F0:  BZ    8706
086F2:  XORLW  03
086F4:  BTFSC  FD8.2
086F6:  BRA    888C
086F8:  XORLW  01
086FA:  BTFSC  FD8.2
086FC:  BRA    8B12
086FE:  XORLW  07
08700:  BTFSC  FD8.2
08702:  BRA    8CB4
08704:  BRA    8D50
....................    {     
....................       // display screen 1     
....................       case 1:                                    
....................          // This is where you should put the stuff that doesn't need to be updated all the time 
....................          // last update was skipped, clear screen and fill screen         
....................          if (global_skip_lcd_update_count == 1) 
08706:  DECFSZ x83,W
08708:  BRA    875C
....................          { 
....................             LCD_clear();                                         
0870A:  CALL   5C18
....................             global_skip_lcd_update_count = 0;   
0870E:  CLRF   x83
....................             strcpy (global_temp_line_buff, "v      r    t   "); 
08710:  CLRF   FEA
08712:  MOVLW  70
08714:  MOVWF  FE9
08716:  MOVLW  00
08718:  CALL   0530
0871C:  TBLRD*-
0871E:  TBLRD*+
08720:  MOVF   FF5,W
08722:  MOVWF  FEE
08724:  IORLW  00
08726:  BNZ   871E
....................             LCD_line1(global_temp_line_buff);            
08728:  MOVLB  5
0872A:  CLRF   x64
0872C:  MOVLW  70
0872E:  MOVWF  x63
08730:  MOVLB  0
08732:  CALL   3932
....................             strcpy (global_temp_line_buff, "c      q    a   "); 
08736:  CLRF   FEA
08738:  MOVLW  70
0873A:  MOVWF  FE9
0873C:  MOVLW  00
0873E:  CALL   0552
08742:  TBLRD*-
08744:  TBLRD*+
08746:  MOVF   FF5,W
08748:  MOVWF  FEE
0874A:  IORLW  00
0874C:  BNZ   8744
....................             LCD_line2(global_temp_line_buff);    
0874E:  MOVLB  5
08750:  CLRF   x64
08752:  MOVLW  70
08754:  MOVWF  x63
08756:  MOVLB  0
08758:  CALL   398C
....................          }                                                  
....................                                 
....................          // This is where you put what you want on the screen                                        
....................          // v indicates Valve position 
....................          // r indicates speed of rotation Rpm 
....................          // t indicates message Type 
....................          // c indicates real-time Clock in seconds 
....................          // q indicates message Queue location 
....................          // a indicates Attempt_num 
....................          LCD_place_uint16(global_valve_position, 0, 1, 5); 
0875C:  MOVFF  C2,564
08760:  MOVFF  C1,563
08764:  MOVLB  5
08766:  CLRF   x65
08768:  MOVLW  01
0876A:  MOVWF  x66
0876C:  MOVLW  05
0876E:  MOVWF  x67
08770:  MOVLB  0
08772:  CALL   6838
....................          if (read_system_state() != SYSTEM_IDLE) 
08776:  CALL   1F02
0877A:  MOVF   01,W
0877C:  SUBLW  03
0877E:  BZ    879C
....................          { 
....................             LCD_place_uint16(global_current_rpm,0,8,3); 
08780:  MOVFF  AB,564
08784:  MOVFF  AA,563
08788:  MOVLB  5
0878A:  CLRF   x65
0878C:  MOVLW  08
0878E:  MOVWF  x66
08790:  MOVLW  03
08792:  MOVWF  x67
08794:  MOVLB  0
08796:  CALL   6838
....................          } 
0879A:  BRA    87D2
....................          else 
....................          { 
....................             LCD_place_char('*',0,8); 
0879C:  MOVLW  2A
0879E:  MOVLB  5
087A0:  MOVWF  x57
087A2:  CLRF   x58
087A4:  MOVLW  08
087A6:  MOVWF  x59
087A8:  MOVLB  0
087AA:  CALL   4BB4
....................             LCD_place_char('*',0,9); 
087AE:  MOVLW  2A
087B0:  MOVLB  5
087B2:  MOVWF  x57
087B4:  CLRF   x58
087B6:  MOVLW  09
087B8:  MOVWF  x59
087BA:  MOVLB  0
087BC:  CALL   4BB4
....................             LCD_place_char('*',0,10); 
087C0:  MOVLW  2A
087C2:  MOVLB  5
087C4:  MOVWF  x57
087C6:  CLRF   x58
087C8:  MOVLW  0A
087CA:  MOVWF  x59
087CC:  MOVLB  0
087CE:  CALL   4BB4
....................          }  
....................            
....................          LCD_place_uint32(global_rtc_time, 1,1,5);                      
087D2:  MOVFF  88,559
087D6:  MOVFF  87,558
087DA:  MOVFF  86,557
087DE:  MOVFF  85,556
087E2:  MOVLW  01
087E4:  MOVLB  5
087E6:  MOVWF  x5A
087E8:  MOVWF  x5B
087EA:  MOVLW  05
087EC:  MOVWF  x5C
087EE:  MOVLB  0
087F0:  CALL   69A6
....................          //LCD_place_uint16(global_xdcr_output, 1, 8, 5);                 
....................          //LCD_place_uint32(global_utc_time, 1,1,10);           
....................                                                                                       
....................          LCD_place_uint8(global_current_message_queue_location, 1, 8, 3); 
087F4:  MOVFF  4F7,564
087F8:  MOVLW  01
087FA:  MOVLB  5
087FC:  MOVWF  x65
087FE:  MOVLW  08
08800:  MOVWF  x66
08802:  MOVLW  03
08804:  MOVWF  x67
08806:  MOVLB  0
08808:  CALL   6912
....................          if (global_current_message_queue_location != 255) 
0880C:  MOVLB  4
0880E:  INCFSZ xF7,W
08810:  BRA    8814
08812:  BRA    888A
....................          {                              
....................             LCD_place_uint8(global_message_queue[global_current_message_queue_location].message_type,0,13,3); 
08814:  MOVF   xF7,W
08816:  MULLW  08
08818:  MOVF   FF3,W
0881A:  MOVLB  5
0881C:  CLRF   x4D
0881E:  MOVWF  x4C
08820:  MOVLW  04
08822:  ADDWF  x4C,W
08824:  MOVWF  01
08826:  MOVLW  00
08828:  ADDWFC x4D,W
0882A:  MOVWF  03
0882C:  MOVF   01,W
0882E:  ADDLW  A7
08830:  MOVWF  FE9
08832:  MOVLW  04
08834:  ADDWFC 03,W
08836:  MOVWF  FEA
08838:  MOVFF  FEF,564
0883C:  CLRF   x65
0883E:  MOVLW  0D
08840:  MOVWF  x66
08842:  MOVLW  03
08844:  MOVWF  x67
08846:  MOVLB  0
08848:  CALL   6912
....................             LCD_place_uint8(global_message_queue[global_current_message_queue_location].attempt_num,1,13,3); 
0884C:  MOVLB  4
0884E:  MOVF   xF7,W
08850:  MULLW  08
08852:  MOVF   FF3,W
08854:  MOVLB  5
08856:  CLRF   x4D
08858:  MOVWF  x4C
0885A:  MOVLW  07
0885C:  ADDWF  x4C,W
0885E:  MOVWF  01
08860:  MOVLW  00
08862:  ADDWFC x4D,W
08864:  MOVWF  03
08866:  MOVF   01,W
08868:  ADDLW  A7
0886A:  MOVWF  FE9
0886C:  MOVLW  04
0886E:  ADDWFC 03,W
08870:  MOVWF  FEA
08872:  MOVFF  FEF,564
08876:  MOVLW  01
08878:  MOVWF  x65
0887A:  MOVLW  0D
0887C:  MOVWF  x66
0887E:  MOVLW  03
08880:  MOVWF  x67
08882:  MOVLB  0
08884:  CALL   6912
08888:  MOVLB  4
....................          }    
....................                 
....................       break;  
0888A:  BRA    8D56
....................       // display screen 2  
....................       case 2:               
....................          // This is where you should put the stuff that doesn't need to be updated all the time 
....................          // last update was skipped, clear screen and fill screen         
....................          if (global_skip_lcd_update_count == 1)   
0888C:  DECFSZ x83,W
0888E:  BRA    88E2
....................          {                                         
....................             LCD_clear();                                         
08890:  CALL   5C18
....................             global_skip_lcd_update_count = 0; 
08894:  CLRF   x83
....................             strcpy (global_temp_line_buff, "m       n     * "); 
08896:  CLRF   FEA
08898:  MOVLW  70
0889A:  MOVWF  FE9
0889C:  MOVLW  00
0889E:  CALL   0574
088A2:  TBLRD*-
088A4:  TBLRD*+
088A6:  MOVF   FF5,W
088A8:  MOVWF  FEE
088AA:  IORLW  00
088AC:  BNZ   88A4
....................             LCD_line1(global_temp_line_buff);            
088AE:  MOVLB  5
088B0:  CLRF   x64
088B2:  MOVLW  70
088B4:  MOVWF  x63
088B6:  MOVLB  0
088B8:  CALL   3932
....................             strcpy (global_temp_line_buff, "p       .       "); 
088BC:  CLRF   FEA
088BE:  MOVLW  70
088C0:  MOVWF  FE9
088C2:  MOVLW  00
088C4:  CALL   0596
088C8:  TBLRD*-
088CA:  TBLRD*+
088CC:  MOVF   FF5,W
088CE:  MOVWF  FEE
088D0:  IORLW  00
088D2:  BNZ   88CA
....................             LCD_line2(global_temp_line_buff);    
088D4:  MOVLB  5
088D6:  CLRF   x64
088D8:  MOVLW  70
088DA:  MOVWF  x63
088DC:  MOVLB  0
088DE:  CALL   398C
....................          }                                                       
....................                     
....................          // This is the place where you put what you want onto the screen 
....................          // m indicates Mote ID (hex) 
....................          // n indicates Net ID (hex) 
....................          // * indicates mote state (Booting, Idle, Searching, 
....................          //                         Negotiating, Connected, 
....................          //                         Operational, Disconnected, 
....................          //                         Radio test, Promiscuous Listen) 
....................          // p indicates sprinkler Position (2 digit pivot#, 3 digit location) 
....................          // . is the decimal pt in the battery voltage (2 decimal precision) 
....................          // final 4 places are for Firmware Rev 1st char A-F (e.g. A123) 
....................          // last four characters of line 2 is the hex firmware 
....................          //  revision, e.g. D308    
....................           
....................          // place the mac address on the LCD 
....................          global_temp_line_buff[0] = hi2asc(macaddr_rcvd[5]); 
088E2:  MOVFF  A4,564
088E6:  CALL   3276
088EA:  MOVFF  01,70
....................          global_temp_line_buff[1] = lo2asc(macaddr_rcvd[5]); 
088EE:  MOVFF  A4,564
088F2:  CALL   3296
088F6:  MOVFF  01,71
....................          global_temp_line_buff[2] = hi2asc(macaddr_rcvd[6]); 
088FA:  MOVFF  A5,564
088FE:  CALL   3276
08902:  MOVFF  01,72
....................          global_temp_line_buff[3] = lo2asc(macaddr_rcvd[6]); 
08906:  MOVFF  A5,564
0890A:  CALL   3296
0890E:  MOVFF  01,73
....................          global_temp_line_buff[4] = hi2asc(macaddr_rcvd[7]); 
08912:  MOVFF  A6,564
08916:  CALL   3276
0891A:  MOVFF  01,74
....................          global_temp_line_buff[5] = lo2asc(macaddr_rcvd[7]); 
0891E:  MOVFF  A6,564
08922:  CALL   3296
08926:  MOVFF  01,75
....................          LCD_place_text(global_temp_line_buff,0,1,6);  
0892A:  MOVLB  5
0892C:  CLRF   x74
0892E:  MOVLW  70
08930:  MOVWF  x73
08932:  CLRF   x75
08934:  MOVLW  01
08936:  MOVWF  x76
08938:  MOVLW  06
0893A:  MOVWF  x77
0893C:  MOVLB  0
0893E:  CALL   67B0
....................                                 
....................          // place the network id on the LCD                        
....................          global_temp_line_buff[0] = hi2asc(make8(network_id_rcvd,1)); 
08942:  MOVFF  368,54C
08946:  MOVFF  368,564
0894A:  CALL   3276
0894E:  MOVFF  01,70
....................          global_temp_line_buff[1] = lo2asc(make8(network_id_rcvd,1)); 
08952:  MOVFF  368,54C
08956:  MOVFF  368,564
0895A:  CALL   3296
0895E:  MOVFF  01,71
....................          global_temp_line_buff[2] = hi2asc(make8(network_id_rcvd,0)); 
08962:  MOVFF  367,54C
08966:  MOVFF  367,564
0896A:  CALL   3276
0896E:  MOVFF  01,72
....................          global_temp_line_buff[3] = lo2asc(make8(network_id_rcvd,0)); 
08972:  MOVFF  367,54C
08976:  MOVFF  367,564
0897A:  CALL   3296
0897E:  MOVFF  01,73
....................          LCD_place_text(global_temp_line_buff,0,9,4);        
08982:  MOVLB  5
08984:  CLRF   x74
08986:  MOVLW  70
08988:  MOVWF  x73
0898A:  CLRF   x75
0898C:  MOVLW  09
0898E:  MOVWF  x76
08990:  MOVLW  04
08992:  MOVWF  x77
08994:  MOVLB  0
08996:  CALL   67B0
....................           
....................          // put the mote state on the LCD       
....................          switch (global_mote_state) 
0899A:  MOVLB  5
0899C:  MOVF   x04,W
0899E:  XORLW  00
089A0:  MOVLB  0
089A2:  BZ    89C6
089A4:  XORLW  01
089A6:  BZ    89CE
089A8:  XORLW  03
089AA:  BZ    89D6
089AC:  XORLW  01
089AE:  BZ    89DE
089B0:  XORLW  07
089B2:  BZ    89E6
089B4:  XORLW  01
089B6:  BZ    89EE
089B8:  XORLW  03
089BA:  BZ    89F6
089BC:  XORLW  01
089BE:  BZ    89FE
089C0:  XORLW  0F
089C2:  BZ    8A06
089C4:  BRA    8A10
....................          {               
....................             case MOTESTATE_INIT: 
....................                // booting 
....................                state_char = 'B'; 
089C6:  MOVLW  42
089C8:  MOVLB  5
089CA:  MOVWF  x4B
....................                break;   
089CC:  BRA    8A16
....................             case MOTESTATE_IDLE: 
....................                state_char = 'I'; 
089CE:  MOVLW  49
089D0:  MOVLB  5
089D2:  MOVWF  x4B
....................                break;  
089D4:  BRA    8A16
....................             case MOTESTATE_SEARCHING: 
....................                state_char = 'S'; 
089D6:  MOVLW  53
089D8:  MOVLB  5
089DA:  MOVWF  x4B
....................                break;      
089DC:  BRA    8A16
....................             case MOTESTATE_NEGOTIATING: 
....................                state_char = 'N'; 
089DE:  MOVLW  4E
089E0:  MOVLB  5
089E2:  MOVWF  x4B
....................                break; 
089E4:  BRA    8A16
....................             case MOTESTATE_CONNECTED: 
....................                state_char = 'C'; 
089E6:  MOVLW  43
089E8:  MOVLB  5
089EA:  MOVWF  x4B
....................                break;  
089EC:  BRA    8A16
....................             case MOTESTATE_OPERATIONAL: 
....................                state_char = 'O'; 
089EE:  MOVLW  4F
089F0:  MOVLB  5
089F2:  MOVWF  x4B
....................                break;  
089F4:  BRA    8A16
....................             case MOTESTATE_DISCONNECTED: 
....................                state_char = 'D'; 
089F6:  MOVLW  44
089F8:  MOVLB  5
089FA:  MOVWF  x4B
....................                break;   
089FC:  BRA    8A16
....................             case MOTESTATE_RADIOTEST: 
....................                state_char = 'R'; 
089FE:  MOVLW  52
08A00:  MOVLB  5
08A02:  MOVWF  x4B
....................                break;   
08A04:  BRA    8A16
....................             case MOTESTATE_PROMISCUOUS: 
....................                state_char = 'P'; 
08A06:  MOVLW  50
08A08:  MOVLB  5
08A0A:  MOVWF  x4B
....................                break;  
08A0C:  BRA    8A16
08A0E:  MOVLB  0
....................             default: 
....................                state_char = '*'; 
08A10:  MOVLW  2A
08A12:  MOVLB  5
08A14:  MOVWF  x4B
....................                break;    
....................          }                      
....................          LCD_place_char(state_char, 0, 15);           
08A16:  MOVFF  54B,557
08A1A:  CLRF   x58
08A1C:  MOVLW  0F
08A1E:  MOVWF  x59
08A20:  MOVLB  0
08A22:  CALL   4BB4
....................                   
....................          // put the sprinkler position??? on the LCD                              
....................          strcpy(global_temp_line_buff, "***"); 
08A26:  CLRF   FEA
08A28:  MOVLW  70
08A2A:  MOVWF  FE9
08A2C:  MOVLW  00
08A2E:  CALL   05B8
08A32:  TBLRD*-
08A34:  TBLRD*+
08A36:  MOVF   FF5,W
08A38:  MOVWF  FEE
08A3A:  IORLW  00
08A3C:  BNZ   8A34
....................          if (state_char == 'O') 
08A3E:  MOVLB  5
08A40:  MOVF   x4B,W
08A42:  SUBLW  4F
08A44:  BNZ   8A72
....................             LCD_place_uint8((uint8_t)(network_id_rcvd - NETWORK_ID_DEF), 1, 1, 2); 
08A46:  MOVLW  CD
08A48:  MOVLB  3
08A4A:  SUBWF  x67,W
08A4C:  MOVWF  00
08A4E:  MOVLW  04
08A50:  SUBWFB x68,W
08A52:  MOVWF  03
08A54:  MOVFF  00,54C
08A58:  MOVLB  5
08A5A:  MOVFF  00,564
08A5E:  MOVLW  01
08A60:  MOVWF  x65
08A62:  MOVWF  x66
08A64:  MOVLW  02
08A66:  MOVWF  x67
08A68:  MOVLB  0
08A6A:  CALL   6912
08A6E:  BRA    8A88
08A70:  MOVLB  5
....................          else 
....................             LCD_place_text(global_temp_line_buff,1,1,2); 
08A72:  CLRF   x74
08A74:  MOVLW  70
08A76:  MOVWF  x73
08A78:  MOVLW  01
08A7A:  MOVWF  x75
08A7C:  MOVWF  x76
08A7E:  MOVLW  02
08A80:  MOVWF  x77
08A82:  MOVLB  0
08A84:  CALL   67B0
....................                                        
....................          // put the sprinkler number on the LCD 
....................          if (global_sprinkler_num > 999) 
08A88:  MOVF   x96,W
08A8A:  SUBLW  02
08A8C:  BC    8AB2
08A8E:  XORLW  FF
08A90:  BNZ   8A98
08A92:  MOVF   x95,W
08A94:  SUBLW  E7
08A96:  BC    8AB2
....................             LCD_place_text(global_temp_line_buff,1,3,3); 
08A98:  MOVLB  5
08A9A:  CLRF   x74
08A9C:  MOVLW  70
08A9E:  MOVWF  x73
08AA0:  MOVLW  01
08AA2:  MOVWF  x75
08AA4:  MOVLW  03
08AA6:  MOVWF  x76
08AA8:  MOVWF  x77
08AAA:  MOVLB  0
08AAC:  CALL   67B0
08AB0:  BRA    8ACC
....................          else 
....................             LCD_place_uint16(global_sprinkler_num, 1, 3, 3); 
08AB2:  MOVFF  96,564
08AB6:  MOVFF  95,563
08ABA:  MOVLW  01
08ABC:  MOVLB  5
08ABE:  MOVWF  x65
08AC0:  MOVLW  03
08AC2:  MOVWF  x66
08AC4:  MOVWF  x67
08AC6:  MOVLB  0
08AC8:  CALL   6838
....................           
....................          // put the battery voltage on the LCD 
....................          LCD_display_batt_voltage(1, 7, 2);                 
08ACC:  MOVLW  01
08ACE:  MOVLB  5
08AD0:  MOVWF  x4C
08AD2:  MOVLW  07
08AD4:  MOVWF  x4D
08AD6:  MOVLW  02
08AD8:  MOVWF  x4E
08ADA:  MOVLB  0
08ADC:  CALL   4BEC
....................           
....................          // put the firmware version on the LCD 
....................          strcpy(global_temp_line_buff, global_firmware_version_string);       
08AE0:  CLRF   FEA
08AE2:  MOVLW  70
08AE4:  MOVWF  FE9
08AE6:  CLRF   FE2
08AE8:  MOVLW  4F
08AEA:  MOVWF  FE1
08AEC:  MOVF   FE7,F
08AEE:  MOVFF  FE6,FEE
08AF2:  BNZ   8AEC
....................          LCD_place_text(global_temp_line_buff,1,12,4);   
08AF4:  MOVLB  5
08AF6:  CLRF   x74
08AF8:  MOVLW  70
08AFA:  MOVWF  x73
08AFC:  MOVLW  01
08AFE:  MOVWF  x75
08B00:  MOVLW  0C
08B02:  MOVWF  x76
08B04:  MOVLW  04
08B06:  MOVWF  x77
08B08:  MOVLB  0
08B0A:  CALL   67B0
....................                                                              
....................          break;         
08B0E:  MOVLB  4
08B10:  BRA    8D56
....................        
....................       // another screen 
....................       case 3: 
....................         
....................          if (global_skip_lcd_update_count == 1)   
08B12:  DECFSZ x83,W
08B14:  BRA    8B68
....................          {                                         
....................             LCD_clear();                                         
08B16:  CALL   5C18
....................             global_skip_lcd_update_count = 0; 
08B1A:  CLRF   x83
....................             strcpy (global_temp_line_buff, "br    ch    mp  "); 
08B1C:  CLRF   FEA
08B1E:  MOVLW  70
08B20:  MOVWF  FE9
08B22:  MOVLW  00
08B24:  CALL   05CC
08B28:  TBLRD*-
08B2A:  TBLRD*+
08B2C:  MOVF   FF5,W
08B2E:  MOVWF  FEE
08B30:  IORLW  00
08B32:  BNZ   8B2A
....................             LCD_line1(global_temp_line_buff);            
08B34:  MOVLB  5
08B36:  CLRF   x64
08B38:  MOVLW  70
08B3A:  MOVWF  x63
08B3C:  MOVLB  0
08B3E:  CALL   3932
....................             strcpy (global_temp_line_buff, "r   /    vg  .  "); 
08B42:  CLRF   FEA
08B44:  MOVLW  70
08B46:  MOVWF  FE9
08B48:  MOVLW  00
08B4A:  CALL   05EE
08B4E:  TBLRD*-
08B50:  TBLRD*+
08B52:  MOVF   FF5,W
08B54:  MOVWF  FEE
08B56:  IORLW  00
08B58:  BNZ   8B50
....................             LCD_line2(global_temp_line_buff);    
08B5A:  MOVLB  5
08B5C:  CLRF   x64
08B5E:  MOVLW  70
08B60:  MOVWF  x63
08B62:  MOVLB  0
08B64:  CALL   398C
....................          }                                                       
....................                     
....................          // This is the place where you put what you want onto the screen 
....................          // br indicates BRaking duty cycle (0-400) 
....................          // ch indicates CHarging duty cycle (0-400) 
....................          // mp indicates MPpc setting (2-digit HEX) 
....................          // r.../... indicates measured RPM / target RMP 
....................          // vg indicates detected voltage from generator 00.00 
....................           
....................          LCD_place_uint16(global_brake_duty,0,2,3);  
08B68:  MOVFF  B3,564
08B6C:  MOVFF  B2,563
08B70:  MOVLB  5
08B72:  CLRF   x65
08B74:  MOVLW  02
08B76:  MOVWF  x66
08B78:  MOVLW  03
08B7A:  MOVWF  x67
08B7C:  MOVLB  0
08B7E:  CALL   6838
....................          LCD_place_uint16(global_charge_duty,0,8,3); 
08B82:  MOVFF  B5,564
08B86:  MOVFF  B4,563
08B8A:  MOVLB  5
08B8C:  CLRF   x65
08B8E:  MOVLW  08
08B90:  MOVWF  x66
08B92:  MOVLW  03
08B94:  MOVWF  x67
08B96:  MOVLB  0
08B98:  CALL   6838
....................          LCD_place_char(hi2asc(global_mppc_value),0,14); 
08B9C:  MOVFF  BA,564
08BA0:  CALL   3276
08BA4:  MOVFF  01,54C
08BA8:  MOVFF  01,557
08BAC:  MOVLB  5
08BAE:  CLRF   x58
08BB0:  MOVLW  0E
08BB2:  MOVWF  x59
08BB4:  MOVLB  0
08BB6:  CALL   4BB4
....................          LCD_place_char(lo2asc(global_mppc_value),0,15); 
08BBA:  MOVFF  BA,564
08BBE:  CALL   3296
08BC2:  MOVFF  01,54C
08BC6:  MOVFF  01,557
08BCA:  MOVLB  5
08BCC:  CLRF   x58
08BCE:  MOVLW  0F
08BD0:  MOVWF  x59
08BD2:  MOVLB  0
08BD4:  CALL   4BB4
....................           
....................          // do not report measured RPM if it is not being measured 
....................          if (read_system_state() != SYSTEM_IDLE) 
08BD8:  CALL   1F02
08BDC:  MOVF   01,W
08BDE:  SUBLW  03
08BE0:  BZ    8BFE
....................          { 
....................             LCD_place_uint16(global_current_rpm,1,1,3); 
08BE2:  MOVFF  AB,564
08BE6:  MOVFF  AA,563
08BEA:  MOVLW  01
08BEC:  MOVLB  5
08BEE:  MOVWF  x65
08BF0:  MOVWF  x66
08BF2:  MOVLW  03
08BF4:  MOVWF  x67
08BF6:  MOVLB  0
08BF8:  CALL   6838
....................          } 
08BFC:  BRA    8C38
....................          else 
....................          { 
....................             LCD_place_char('*',1,1); 
08BFE:  MOVLW  2A
08C00:  MOVLB  5
08C02:  MOVWF  x57
08C04:  MOVLW  01
08C06:  MOVWF  x58
08C08:  MOVWF  x59
08C0A:  MOVLB  0
08C0C:  CALL   4BB4
....................             LCD_place_char('*',1,2); 
08C10:  MOVLW  2A
08C12:  MOVLB  5
08C14:  MOVWF  x57
08C16:  MOVLW  01
08C18:  MOVWF  x58
08C1A:  MOVLW  02
08C1C:  MOVWF  x59
08C1E:  MOVLB  0
08C20:  CALL   4BB4
....................             LCD_place_char('*',1,3); 
08C24:  MOVLW  2A
08C26:  MOVLB  5
08C28:  MOVWF  x57
08C2A:  MOVLW  01
08C2C:  MOVWF  x58
08C2E:  MOVLW  03
08C30:  MOVWF  x59
08C32:  MOVLB  0
08C34:  CALL   4BB4
....................          } 
....................           
....................          // do not report target RPM if there is no target 
....................          if ((global_control_loop_mechanism == NO_RPM_CONTROL) || \ 
....................              (global_control_loop_mechanism == NO_RPM_CONTROL_DYN_MPPC)) 
08C38:  MOVF   xC0,W
08C3A:  SUBLW  05
08C3C:  BZ    8C44
08C3E:  MOVF   xC0,W
08C40:  SUBLW  06
08C42:  BNZ   8C82
....................          { 
....................             LCD_place_char('*',1,5); 
08C44:  MOVLW  2A
08C46:  MOVLB  5
08C48:  MOVWF  x57
08C4A:  MOVLW  01
08C4C:  MOVWF  x58
08C4E:  MOVLW  05
08C50:  MOVWF  x59
08C52:  MOVLB  0
08C54:  CALL   4BB4
....................             LCD_place_char('*',1,6); 
08C58:  MOVLW  2A
08C5A:  MOVLB  5
08C5C:  MOVWF  x57
08C5E:  MOVLW  01
08C60:  MOVWF  x58
08C62:  MOVLW  06
08C64:  MOVWF  x59
08C66:  MOVLB  0
08C68:  CALL   4BB4
....................             LCD_place_char('*',1,7); 
08C6C:  MOVLW  2A
08C6E:  MOVLB  5
08C70:  MOVWF  x57
08C72:  MOVLW  01
08C74:  MOVWF  x58
08C76:  MOVLW  07
08C78:  MOVWF  x59
08C7A:  MOVLB  0
08C7C:  CALL   4BB4
....................          } 
08C80:  BRA    8C9E
....................          else 
....................          { 
....................             LCD_place_uint16(global_rpm_set_value,1,5,3); 
08C82:  MOVFF  AD,564
08C86:  MOVFF  AC,563
08C8A:  MOVLW  01
08C8C:  MOVLB  5
08C8E:  MOVWF  x65
08C90:  MOVLW  05
08C92:  MOVWF  x66
08C94:  MOVLW  03
08C96:  MOVWF  x67
08C98:  MOVLB  0
08C9A:  CALL   6838
....................          } 
....................           
....................          // put the vgen voltage on the LCD 
....................  
....................          LCD_display_vgen(1, 11, 2); 
08C9E:  MOVLW  01
08CA0:  MOVLB  5
08CA2:  MOVWF  x4C
08CA4:  MOVLW  0B
08CA6:  MOVWF  x4D
08CA8:  MOVLW  02
08CAA:  MOVWF  x4E
08CAC:  MOVLB  0
08CAE:  BRA    84F0
....................  
....................       break; 
08CB0:  MOVLB  4
08CB2:  BRA    8D56
....................        
....................       // extra screen 
....................       case 4: 
....................          if (global_skip_lcd_update_count == 1) 
08CB4:  DECFSZ x83,W
08CB6:  BRA    8D0A
....................          {                                         
....................             LCD_clear();                                         
08CB8:  CALL   5C18
....................             global_skip_lcd_update_count = 0; 
08CBC:  CLRF   x83
....................             strcpy (global_temp_line_buff, "system state    "); 
08CBE:  CLRF   FEA
08CC0:  MOVLW  70
08CC2:  MOVWF  FE9
08CC4:  MOVLW  00
08CC6:  CALL   0610
08CCA:  TBLRD*-
08CCC:  TBLRD*+
08CCE:  MOVF   FF5,W
08CD0:  MOVWF  FEE
08CD2:  IORLW  00
08CD4:  BNZ   8CCC
....................             LCD_line1(global_temp_line_buff);            
08CD6:  MOVLB  5
08CD8:  CLRF   x64
08CDA:  MOVLW  70
08CDC:  MOVWF  x63
08CDE:  MOVLB  0
08CE0:  CALL   3932
....................             strcpy (global_temp_line_buff, "                "); 
08CE4:  CLRF   FEA
08CE6:  MOVLW  70
08CE8:  MOVWF  FE9
08CEA:  MOVLW  00
08CEC:  CALL   04CA
08CF0:  TBLRD*-
08CF2:  TBLRD*+
08CF4:  MOVF   FF5,W
08CF6:  MOVWF  FEE
08CF8:  IORLW  00
08CFA:  BNZ   8CF2
....................             LCD_line2(global_temp_line_buff);    
08CFC:  MOVLB  5
08CFE:  CLRF   x64
08D00:  MOVLW  70
08D02:  MOVWF  x63
08D04:  MOVLB  0
08D06:  CALL   398C
....................          }     
....................             LCD_place_uint8(read_system_state(),0,13,3);  
08D0A:  CALL   1F02
08D0E:  MOVFF  01,54C
08D12:  MOVFF  01,564
08D16:  MOVLB  5
08D18:  CLRF   x65
08D1A:  MOVLW  0D
08D1C:  MOVWF  x66
08D1E:  MOVLW  03
08D20:  MOVWF  x67
08D22:  MOVLB  0
08D24:  CALL   6912
....................             LCD_place_uint32(global_last_rpm_value_time,1,0,10);  
08D28:  MOVFF  B1,559
08D2C:  MOVFF  B0,558
08D30:  MOVFF  AF,557
08D34:  MOVFF  AE,556
08D38:  MOVLW  01
08D3A:  MOVLB  5
08D3C:  MOVWF  x5A
08D3E:  CLRF   x5B
08D40:  MOVLW  0A
08D42:  MOVWF  x5C
08D44:  MOVLB  0
08D46:  CALL   69A6
....................          break;    
08D4A:  MOVLB  4
08D4C:  BRA    8D56
08D4E:  MOVLB  0
....................                                                                        
....................       // if somehow global_lcd_page_number get incremented above the last page, clear the LCD    
....................       default: 
....................          LCD_clear();                
08D50:  CALL   5C18
....................       break;     
08D54:  MOVLB  4
....................    }                                              
08D56:  MOVLB  0
08D58:  GOTO   ABC2 (RETURN)
.................... }       
....................  
....................                                                                                                    
.................... void XDCR_init(void) 
.................... { 
....................    i2c_start(); 
....................  
....................    global_xcdr_type1_enabled = !i2c_write(XDCR_ADDRESS);    // (0x48) WRITE LCD address? 
....................    if (!global_xcdr_type1_enabled) 
....................    { 
....................       i2c_stop();                                     
....................       delay_cycles(255); 
....................       output_low(XDCR_PWR);   
....................       return;                             
....................    }                              
....................    //i2c_write(0b00000000);                                    
....................    i2c_write(0x00);  
....................    i2c_stop();            
....................    // set up the ADC here 
.................... }     
....................                
.................... void adc_XDCR_init(void) 
*
03860:  MOVLB  5
03862:  CLRF   x4D
03864:  CLRF   x4C
.................... {    
....................    uint8_t n; 
....................    uint16_t xdcr_output_sum = 0; 
....................     
....................    // turn on pullup resisitor on xdcr line (so you can check if it's connected)                     
....................    port_b_pullups(PORTB_PULLUPS_WITH_XDCR);   
03866:  MOVLW  32
03868:  MOVWF  F61
....................     
....................    // turn on XDCR and wait 100ms for the adc to settle (really only 25ms or so is needed) 
....................    output_high(XDCR_PWR);       
0386A:  BSF    F8B.5
....................    setup_T0_int(T0_100MS);                                     
0386C:  MOVLW  FE
0386E:  MOVWF  x69
03870:  MOVLW  7A
03872:  MOVWF  x68
03874:  MOVLB  0
03876:  RCALL  3844
....................    while(!TMR0IF);           
03878:  BTFSS  FF2.2
0387A:  BRA    3878
....................               
....................    // turn on ADC                   
....................    ADON = TRUE;                
0387C:  BSF    FC2.0
....................                                    
....................    // set adc to V_EXTRA_IO_1 (pin 7 on header going "across river") 
....................    set_adc_channel(ADC_XDCR);       
0387E:  MOVLW  34
03880:  MOVWF  01
03882:  MOVF   FC2,W
03884:  ANDLW  83
03886:  IORWF  01,W
03888:  MOVWF  FC2
....................  
....................    // sum up 8 samples from the adc (.3 ms/sample @ 250Khz clock)                                                                                                                                                                            
....................    for (n = 0; n < 8; n++) 
0388A:  MOVLB  5
0388C:  CLRF   x4B
0388E:  MOVF   x4B,W
03890:  SUBLW  07
03892:  BNC   38A6
....................    {                                                                                                                                                                                                         
....................       xdcr_output_sum += read_adc(); 
03894:  BSF    FC2.1
03896:  BTFSC  FC2.1
03898:  BRA    3896
0389A:  MOVF   FC3,W
0389C:  ADDWF  x4C,F
0389E:  MOVF   FC4,W
038A0:  ADDWFC x4D,F
038A2:  INCF   x4B,F
038A4:  BRA    388E
....................    }                     
....................         
....................    // turn off XDCR power 
....................    output_low(XDCR_PWR);  
038A6:  BCF    F8B.5
....................                                                     
....................    // turn off adc                                                                                          
....................    ADON = FALSE;             
038A8:  BCF    FC2.0
....................                                    
....................    if (xdcr_output_sum < XDCR_ADC_OFF_LIMIT) 
038AA:  MOVF   x4D,W
038AC:  SUBLW  13
038AE:  BNC   38BE
038B0:  BNZ   38B8
038B2:  MOVF   x4C,W
038B4:  SUBLW  87
038B6:  BNC   38BE
....................    { 
....................       global_xcdr_type1_enabled = TRUE;    
038B8:  MOVLB  0
038BA:  BSF    xA7.2
038BC:  MOVLB  5
....................    }                                             
....................                          
....................    // return pullups to normal state (without testing if XDCR is there)                            
....................    port_b_pullups(PORTB_PULLUPS);         
038BE:  MOVLW  12
038C0:  MOVWF  F61
038C2:  MOVLB  0
038C4:  GOTO   411C (RETURN)
.................... }                                     
....................  
.................... uint16_t XDCR_measure(void)                                          
.................... {                                          
....................    uint32_t temp_u32;                                           
....................      
....................    i2c_start(); 
....................                                                      
....................    // (0x49) READ ADC address?                 
....................    i2c_write(XDCR_ADDRESS + 1);    
....................                                      
....................    temp_u32 = make32(i2c_read(TRUE), i2c_read(TRUE), i2c_read(FALSE), 0); 
.................... //   LCD_clear();                     
.................... //   LCD_place_uint32(temp_u32,0,0,10);   
.................... //   global_skip_lcd_update_count = 5;               
....................                                       
....................    i2c_stop();                                                          
....................                                             
....................    if ((make8(temp_u32,3) & 0xC0) == 0xC0)  
....................    {                                 
....................       return 0xFFFF;        // saturated top of scale 
....................    }                                                                                     
....................    else if (!(make8(temp_u32,3) & 0xC0))                          
....................    {                                                                           
....................       return 0;             // saturated bottom of scale 
....................    }             
....................    else                                     
....................    {                                                                                                                                                                          
....................       temp_u32 = temp_u32<<2;           // ignore "Bit23 Sig" and "Bit22 MSB" 
.................... //      LCD_clear();                                     
.................... //      LCD_place_uint8(make8(temp_u32,1),1,0,3); 
.................... //     global_skip_lcd_update_count = 5;                                                                                   
....................       return make16(make8(temp_u32,3), make8(temp_u32,2));               
....................    }                                                               
.................... } 
....................  
.................... uint16_t adc_XDCR_measure()     
*
08252:  MOVLB  5
08254:  CLRF   x4D
08256:  CLRF   x4C
.................... {                           
....................    uint8_t n; 
....................    uint16_t adc_value = 0;                   
....................     
....................    // if the XDCR isn't connected, return 0 (really, you should never see 0 with adc noise)                      
....................    if (!global_xcdr_type1_enabled) return 0;        
08258:  MOVLB  0
0825A:  BTFSC  xA7.2
0825C:  BRA    8266
0825E:  MOVLW  00
08260:  MOVWF  01
08262:  MOVWF  02
08264:  BRA    82A4
....................     
....................    // turn on ADC         
....................    ADON = TRUE;                
08266:  BSF    FC2.0
....................                                    
....................    // set adc to V_EXTRA_IO_1 (pin 7 on header going "across river" 
....................    set_adc_channel(ADC_XDCR);       
08268:  MOVLW  34
0826A:  MOVWF  01
0826C:  MOVF   FC2,W
0826E:  ANDLW  83
08270:  IORWF  01,W
08272:  MOVWF  FC2
....................                                      
....................    // sum up 8 samples from the adc (.3 ms/sample @ 250Khz clock)                                                                                                                                                                              
....................    for (n=0; n<8; n++) 
08274:  MOVLB  5
08276:  CLRF   x4B
08278:  MOVF   x4B,W
0827A:  SUBLW  07
0827C:  BNC   8290
....................    {                                                                                                                                                                                                         
....................       adc_value += read_adc(); 
0827E:  BSF    FC2.1
08280:  BTFSC  FC2.1
08282:  BRA    8280
08284:  MOVF   FC3,W
08286:  ADDWF  x4C,F
08288:  MOVF   FC4,W
0828A:  ADDWFC x4D,F
0828C:  INCF   x4B,F
0828E:  BRA    8278
....................    }                     
....................                       
....................    // turn off XDCR power 
....................    output_low(XDCR_PWR);  
08290:  BCF    F8B.5
....................                 
....................    // turn off adc                                                                                          
....................    ADON = FALSE;             
08292:  BCF    FC2.0
....................                                                   
....................    // store XDCR output globally (not shifted)                                               
....................    global_xdcr_output = adc_value;         
08294:  MOVFF  54D,4C
08298:  MOVFF  54C,4B
....................                     
....................    // return the voltage shifted by 3 bits to scale from (0-1023) * 8 to 0-65535 or close enough     
....................    return global_xdcr_output;                     
0829C:  MOVFF  4B,01
082A0:  MOVFF  4C,02
082A4:  MOVLB  0
082A6:  GOTO   AB40 (RETURN)
.................... } 
....................  
....................  
.................... void  fixture_init()          
.................... { 
....................    uint8_t  resbyte;               
....................    resbyte = 0;                                                                                              
*
03FBC:  MOVLB  5
03FBE:  CLRF   x4B
....................     
....................    safeI2C_start();         
03FC0:  MOVLB  0
03FC2:  RCALL  3E1C
....................     
....................    resbyte += i2c_write(FIXTURE_DAC_ADDRESS);                 // FIXTURE DAC ADDRESS 
03FC4:  MOVLW  40
03FC6:  MOVLB  5
03FC8:  MOVWF  x7C
03FCA:  MOVLB  0
03FCC:  RCALL  38E4
03FCE:  MOVF   01,W
03FD0:  MOVLB  5
03FD2:  ADDWF  x4B,F
....................  
....................    resbyte += i2c_write (0x60);                // use internal reference 
03FD4:  MOVLW  60
03FD6:  MOVWF  x7C
03FD8:  MOVLB  0
03FDA:  RCALL  38E4
03FDC:  MOVF   01,W
03FDE:  MOVLB  5
03FE0:  ADDWF  x4B,F
....................    resbyte += i2c_write (0x00);                // set DAC to 0 
03FE2:  CLRF   x7C
03FE4:  MOVLB  0
03FE6:  RCALL  38E4
03FE8:  MOVF   01,W
03FEA:  MOVLB  5
03FEC:  ADDWF  x4B,F
....................    resbyte += i2c_write (0x00);                // low nibble not used (12 bit DAC) 
03FEE:  CLRF   x7C
03FF0:  MOVLB  0
03FF2:  RCALL  38E4
03FF4:  MOVF   01,W
03FF6:  MOVLB  5
03FF8:  ADDWF  x4B,F
....................     
....................    if (resbyte != 0) global_fixture_enabled = TRUE; 
03FFA:  MOVF   x4B,F
03FFC:  BZ    4004
03FFE:  MOVLB  0
04000:  BSF    xA7.4
04002:  MOVLB  5
....................    i2c_stop(); 
04004:  BSF    FC5.2
04006:  BTFSC  FC5.2
04008:  BRA    4006
....................     
....................    set_fixture_dac(NO_FIXTURE); 
0400A:  CLRF   x4D
0400C:  CLRF   x4C
0400E:  MOVLB  0
04010:  BRA    3F68
04012:  GOTO   4130 (RETURN)
.................... }                              
....................  
.................... #include "control.h"                      
.................... void setup_gen_rpm(void) 
.................... { 
....................    setup_timer_5(T5_ENABLE_SOSC | T5_EXTERNAL_SYNC | T5_DIV_BY_1); 
*
04214:  MOVLB  F
04216:  CLRF   x4D
04218:  MOVLW  8B
0421A:  MOVWF  x4E
....................    setup_ccp5(CCP_USE_TIMER5_AND_TIMER6 | CCP_CAPTURE_RE);  
0421C:  CLRF   x54
0421E:  MOVLW  05
04220:  MOVWF  x54
04222:  MOVLW  F3
04224:  ANDWF  x48,F
04226:  MOVLW  08
04228:  IORWF  x48,F
....................    clear_interrupt(INT_CCP5);     // insurance 
0422A:  BCF    F7B.2
....................  
....................    disable_interrupts(INT_TIMER5); 
0422C:  BCF    F7D.1
....................    enable_interrupts(INT_CCP5); 
0422E:  BSF    F7A.2
04230:  MOVLB  0
04232:  GOTO   A234 (RETURN)
.................... } 
....................  
.................... uint16_t calc_gen_rpm(void) 
.................... {   
....................    uint16_t current_rpm16; 
....................    uint32_t current_rpm32; 
....................     
....................       
....................    disable_interrupts(INT_CCP5);                 
*
04F14:  BCF    F7A.2
....................    current_rpm32 = global_last_rpm_value_time; 
04F16:  MOVFF  B1,559
04F1A:  MOVFF  B0,558
04F1E:  MOVFF  AF,557
04F22:  MOVFF  AE,556
....................    enable_interrupts(INT_CCP5);        
04F26:  BSF    F7A.2
....................                                             
....................    // if the last measurement of rpm was more than RPM_TIMEOUT seconds ago 
....................    if ((global_rtc_time - current_rpm32) > RPM_TIMEOUT)            
04F28:  MOVLB  5
04F2A:  MOVF   x56,W
04F2C:  MOVLB  0
04F2E:  SUBWF  x85,W
04F30:  MOVLB  5
04F32:  MOVWF  x5A
04F34:  MOVF   x57,W
04F36:  MOVLB  0
04F38:  SUBWFB x86,W
04F3A:  MOVLB  5
04F3C:  MOVWF  x5B
04F3E:  MOVF   x58,W
04F40:  MOVLB  0
04F42:  SUBWFB x87,W
04F44:  MOVLB  5
04F46:  MOVWF  x5C
04F48:  MOVF   x59,W
04F4A:  MOVLB  0
04F4C:  SUBWFB x88,W
04F4E:  MOVLB  5
04F50:  MOVWF  x5D
04F52:  MOVF   x5D,F
04F54:  BNZ   4F68
04F56:  MOVF   x5C,F
04F58:  BNZ   4F68
04F5A:  MOVF   x22,W
04F5C:  SUBWF  x5B,W
04F5E:  BNC   4F72
04F60:  BNZ   4F68
04F62:  MOVF   x5A,W
04F64:  SUBWF  x21,W
04F66:  BC    4F72
....................    {  
.................... #IFNDEF DISABLE_NO_SPIN_RECOVERY    
....................       if (global_valve_position <= VLV_NOT_SPIN_LIMIT) 
.................... #ENDIF 
....................       { 
....................          return 0;                                
04F68:  MOVLW  00
04F6A:  MOVWF  01
04F6C:  MOVWF  02
04F6E:  BRA    4FEE
....................       } 
....................  
.................... #IFNDEF DISABLE_MAG_DECOUPLING_RECOVERY 
....................       else if(global_valve_position >= VLV_MAGNETIC_COUPLING_LIMIT) 
....................       { 
....................          return 0-1; 
....................       } 
.................... #ENDIF 
....................    }  
04F70:  BRA    4FE8
....................     
....................    // otherwise, calculate rpms as usual 
....................    else 
....................    {  
....................       disable_interrupts(INT_CCP5); 
04F72:  BCF    F7A.2
....................       current_rpm32 = CCP_PER_RPM/(make32(0,0,make8(global_current_period,1), make8(global_current_period,0)));    
04F74:  MOVFF  A9,55A
04F78:  MOVFF  A8,55B
04F7C:  CLRF   x5F
04F7E:  CLRF   x5E
04F80:  MOVFF  A9,55D
04F84:  MOVFF  A8,55C
04F88:  BCF    FD8.1
04F8A:  CLRF   19
04F8C:  BTFSC  FF2.7
04F8E:  BSF    19.7
04F90:  BCF    FF2.7
04F92:  MOVLW  99
04F94:  MOVWF  xA4
04F96:  MOVWF  xA3
04F98:  MOVWF  xA2
04F9A:  MOVLW  9A
04F9C:  MOVWF  xA1
04F9E:  MOVFF  55F,5A8
04FA2:  MOVFF  55E,5A7
04FA6:  MOVFF  A9,5A6
04FAA:  MOVFF  A8,5A5
04FAE:  MOVLB  0
04FB0:  CALL   2526
04FB4:  BTFSC  19.7
04FB6:  BSF    FF2.7
04FB8:  MOVFF  03,559
04FBC:  MOVFF  02,558
04FC0:  MOVFF  01,557
04FC4:  MOVFF  00,556
....................       enable_interrupts(INT_CCP5); 
04FC8:  BSF    F7A.2
....................       current_rpm16 = make16(make8(current_rpm32,3), make8(current_rpm32,2)); 
04FCA:  MOVFF  559,555
04FCE:  MOVFF  558,554
....................       if (bit_test(current_rpm32, 15)) 
04FD2:  MOVLB  5
04FD4:  BTFSS  x57.7
04FD6:  BRA    4FDE
....................       { 
....................          current_rpm16++; 
04FD8:  INCF   x54,F
04FDA:  BTFSC  FD8.2
04FDC:  INCF   x55,F
....................       } 
....................       return current_rpm16; 
04FDE:  MOVFF  554,01
04FE2:  MOVFF  555,02
04FE6:  BRA    4FEE
....................    } 
....................    return 0; 
04FE8:  MOVLW  00
04FEA:  MOVWF  01
04FEC:  MOVWF  02
04FEE:  MOVLB  0
04FF0:  GOTO   5400 (RETURN)
.................... } 
....................  
.................... int1  is_brake_duty_valid(uint16_t value) 
.................... // returns true if valid range for brake duty cycle 
.................... { 
....................    if (value > MAX_BRK) return FALSE; 
*
070CC:  MOVLB  5
070CE:  MOVF   x55,W
070D0:  SUBLW  00
070D2:  BC    70E6
070D4:  XORLW  FF
070D6:  BNZ   70DE
070D8:  MOVF   x54,W
070DA:  SUBLW  90
070DC:  BC    70E6
070DE:  MOVLW  00
070E0:  MOVWF  01
070E2:  BRA    70EA
070E4:  BRA    70EA
....................    else if (value < NO_BRK) return FALSE; 
....................    else return TRUE;   
070E6:  MOVLW  01
070E8:  MOVWF  01
070EA:  MOVLB  0
070EC:  GOTO   798A (RETURN)
.................... } 
.................... int1  is_charge_duty_valid(uint16_t value) 
.................... // returns true if valid range for charge duty cycle 
.................... { 
....................    if (value > MAX_CHARGE) return FALSE; 
070F0:  MOVLB  5
070F2:  MOVF   x55,W
070F4:  SUBLW  00
070F6:  BC    710A
070F8:  XORLW  FF
070FA:  BNZ   7102
070FC:  MOVF   x54,W
070FE:  SUBLW  90
07100:  BC    710A
07102:  MOVLW  00
07104:  MOVWF  01
07106:  BRA    710E
07108:  BRA    710E
....................    else if (value < NO_CHARGE) return FALSE; 
....................    else return TRUE; 
0710A:  MOVLW  01
0710C:  MOVWF  01
0710E:  MOVLB  0
07110:  GOTO   79A8 (RETURN)
.................... } 
.................... int1  is_mppc_valid(uint8_t value) 
.................... // returns true if valid range for mppc 
.................... { 
....................    if (value > MAX_MPPC) return FALSE; 
....................    else if (value < NO_MPPC) return FALSE; 
07114:  MOVLB  5
07116:  MOVF   x52,W
07118:  SUBLW  06
0711A:  BNC   7124
0711C:  MOVLW  00
0711E:  MOVWF  01
07120:  BRA    7128
07122:  BRA    7128
....................    else return TRUE;        
07124:  MOVLW  01
07126:  MOVWF  01
07128:  MOVLB  0
0712A:  GOTO   79C2 (RETURN)
.................... } 
.................... int1  is_rpm_setting_valid(uint16_t value) 
.................... // returns true if valid range for rpm 
.................... { 
....................    if (value > MAX_RPM_SETTING) return FALSE; 
*
06C26:  MOVLB  5
06C28:  MOVF   x55,F
06C2A:  BNZ   6C32
06C2C:  MOVF   x54,W
06C2E:  SUBLW  FA
06C30:  BC    6C3A
06C32:  MOVLW  00
06C34:  MOVWF  01
06C36:  BRA    6C50
06C38:  BRA    6C50
....................    else if (value < MIN_RPM_SETTING) return FALSE; 
06C3A:  MOVF   x55,F
06C3C:  BNZ   6C4C
06C3E:  MOVF   x54,W
06C40:  SUBLW  09
06C42:  BNC   6C4C
06C44:  MOVLW  00
06C46:  MOVWF  01
06C48:  BRA    6C50
06C4A:  BRA    6C50
....................    else return TRUE;     
06C4C:  MOVLW  01
06C4E:  MOVWF  01
06C50:  MOVLB  0
06C52:  RETURN 0
.................... } 
.................... void  set_brake_duty(uint16_t value) 
.................... { 
....................    if (value == NO_BRK) 
*
05308:  MOVLB  5
0530A:  MOVF   x56,F
0530C:  BNZ   531A
0530E:  MOVF   x57,F
05310:  BNZ   531A
....................    { 
....................       setup_ccp1(CCP_OFF); 
05312:  MOVLW  F0
05314:  ANDWF  FBD,F
....................       output_high(BRK_CTRLn);    // no braking 
05316:  BSF    F8B.2
....................    } 
05318:  BRA    536A
....................    else if (value == MAX_BRK) 
0531A:  MOVF   x56,W
0531C:  SUBLW  90
0531E:  BNZ   532C
05320:  DECFSZ x57,W
05322:  BRA    532C
....................    { 
....................       setup_ccp1(CCP_OFF); 
05324:  MOVLW  F0
05326:  ANDWF  FBD,F
....................       output_low(BRK_CTRLn);     // maximum braking 
05328:  BCF    F8B.2
....................    } 
0532A:  BRA    536A
....................     
....................    else 
....................    {       
....................       setup_ccp1(CCP_USE_TIMER5_AND_TIMER6 | CCP_PWM_L_L | CCP_PULSE_STEERING_A); 
0532C:  BCF    F8B.2
0532E:  MOVLW  0F
05330:  MOVWF  FBD
05332:  CLRF   FB7
05334:  CLRF   FB6
05336:  MOVLW  01
05338:  MOVWF  FB9
0533A:  MOVLW  FC
0533C:  MOVLB  F
0533E:  ANDWF  x49,F
05340:  MOVLW  02
05342:  IORWF  x49,F
....................       // increase pwm duty1 for slower speed 
....................       CCP1CON |= (make8(value,0) & 0x03) << 4; 
05344:  MOVLB  5
05346:  MOVF   x56,W
05348:  ANDLW  03
0534A:  MOVWF  00
0534C:  SWAPF  00,F
0534E:  MOVLW  F0
05350:  ANDWF  00,F
05352:  MOVF   00,W
05354:  IORWF  FBD,F
....................       CCPR1L = make8((value>>2),0); 
05356:  RRCF   x57,W
05358:  MOVWF  x59
0535A:  RRCF   x56,W
0535C:  MOVWF  x58
0535E:  RRCF   x59,F
05360:  RRCF   x58,F
05362:  MOVLW  3F
05364:  ANDWF  x59,F
05366:  MOVFF  558,FBE
....................    } 
....................     
....................    global_brake_duty = value; 
0536A:  MOVFF  557,B3
0536E:  MOVFF  556,B2
05372:  MOVLB  0
05374:  RETURN 0
.................... } 
....................  
.................... void     set_charge_duty(uint16_t value) 
.................... { 
....................    if (value == NO_CHARGE) 
*
03EFA:  MOVLB  5
03EFC:  MOVF   x56,F
03EFE:  BNZ   3F0C
03F00:  MOVF   x57,F
03F02:  BNZ   3F0C
....................    { 
....................       setup_ccp2(CCP_OFF); 
03F04:  MOVLW  F0
03F06:  ANDWF  F66,F
....................       output_low(LTC3105_CTRL);     // lo for NO CHARGING 
03F08:  BCF    F8A.3
....................    } 
03F0A:  BRA    3F5C
....................    else if (value == MAX_CHARGE) 
03F0C:  MOVF   x56,W
03F0E:  SUBLW  90
03F10:  BNZ   3F1E
03F12:  DECFSZ x57,W
03F14:  BRA    3F1E
....................    { 
....................       setup_ccp2(CCP_OFF); 
03F16:  MOVLW  F0
03F18:  ANDWF  F66,F
....................       output_high(LTC3105_CTRL);    // maximum charging aggressiveness 
03F1A:  BSF    F8A.3
....................    } 
03F1C:  BRA    3F5C
....................     
....................    else 
....................    {    
....................       //setup_ccp2(CCP_USE_TIMER1_AND_TIMER2 | CCP_PWM_H_H | CCP_PULSE_STEERING_A); 
....................       setup_ccp2(CCP_USE_TIMER5_AND_TIMER6 | CCP_PWM_H_H | CCP_PULSE_STEERING_A); 
03F1E:  BCF    F8A.3
03F20:  MOVLW  0C
03F22:  MOVWF  F66
03F24:  CLRF   F65
03F26:  CLRF   F64
03F28:  MOVLW  01
03F2A:  MOVWF  F63
03F2C:  MOVLW  E7
03F2E:  MOVLB  F
03F30:  ANDWF  x49,F
03F32:  MOVLW  10
03F34:  IORWF  x49,F
....................       // increase pwm duty2 for slower speed 
....................       CCP2CON |= (make8(value,0) & 0x03) << 4; 
03F36:  MOVLB  5
03F38:  MOVF   x56,W
03F3A:  ANDLW  03
03F3C:  MOVWF  00
03F3E:  SWAPF  00,F
03F40:  MOVLW  F0
03F42:  ANDWF  00,F
03F44:  MOVF   00,W
03F46:  IORWF  F66,F
....................       CCPR2L = make8((value>>2),0); 
03F48:  RRCF   x57,W
03F4A:  MOVWF  x59
03F4C:  RRCF   x56,W
03F4E:  MOVWF  x58
03F50:  RRCF   x59,F
03F52:  RRCF   x58,F
03F54:  MOVLW  3F
03F56:  ANDWF  x59,F
03F58:  MOVFF  558,F67
....................    } 
....................    global_charge_duty = value; 
03F5C:  MOVFF  557,B5
03F60:  MOVFF  556,B4
03F64:  MOVLB  0
03F66:  RETURN 0
.................... }                   
....................  
.................... void set_mppc(uint8_t value) 
.................... { 
....................    // for large scale PCBs 
....................     
....................    safeI2C_start(); 
*
03E6E:  RCALL  3E1C
....................  
....................    safei2c_write(0x58);   // address 
03E70:  MOVLW  58
03E72:  MOVLB  5
03E74:  MOVWF  x55
03E76:  MOVLB  0
03E78:  RCALL  3E5A
....................    safei2c_write(0x00);   // Pot 0 command 
03E7A:  MOVLB  5
03E7C:  CLRF   x55
03E7E:  MOVLB  0
03E80:  RCALL  3E5A
....................    safei2c_write(value);  
03E82:  MOVFF  554,555
03E86:  RCALL  3E5A
....................    safei2c_write(0x10);   // Pot 1 command 
03E88:  MOVLW  10
03E8A:  MOVLB  5
03E8C:  MOVWF  x55
03E8E:  MOVLB  0
03E90:  RCALL  3E5A
....................    safei2c_write(value);  
03E92:  MOVFF  554,555
03E96:  RCALL  3E5A
....................    safei2c_write(0x60);   // Pot 2 command 
03E98:  MOVLW  60
03E9A:  MOVLB  5
03E9C:  MOVWF  x55
03E9E:  MOVLB  0
03EA0:  RCALL  3E5A
....................    safei2c_write(value);  
03EA2:  MOVFF  554,555
03EA6:  RCALL  3E5A
....................    safei2c_write(0x70);   // Pot 3 command 
03EA8:  MOVLW  70
03EAA:  MOVLB  5
03EAC:  MOVWF  x55
03EAE:  MOVLB  0
03EB0:  RCALL  3E5A
....................    safei2c_write(value);     
03EB2:  MOVFF  554,555
03EB6:  RCALL  3E5A
....................    i2c_stop(); 
03EB8:  BSF    FC5.2
03EBA:  BTFSC  FC5.2
03EBC:  BRA    3EBA
....................  
....................    // and connect all four pots 
....................    safeI2C_start(); 
03EBE:  RCALL  3E1C
....................     
....................    safei2c_write(0x58);  
03EC0:  MOVLW  58
03EC2:  MOVLB  5
03EC4:  MOVWF  x55
03EC6:  MOVLB  0
03EC8:  RCALL  3E5A
....................    safei2c_write(0x40);   // TCON0 
03ECA:  MOVLW  40
03ECC:  MOVLB  5
03ECE:  MOVWF  x55
03ED0:  MOVLB  0
03ED2:  RCALL  3E5A
....................    safei2c_write(0xff);   // Connect 0 and 1 
03ED4:  MOVLB  5
03ED6:  SETF   x55
03ED8:  MOVLB  0
03EDA:  RCALL  3E5A
....................    safei2c_write(0xa0);   // TCON1 
03EDC:  MOVLW  A0
03EDE:  MOVLB  5
03EE0:  MOVWF  x55
03EE2:  MOVLB  0
03EE4:  RCALL  3E5A
....................    safei2c_write(0xff);   // Connect 2 and 3 
03EE6:  MOVLB  5
03EE8:  SETF   x55
03EEA:  MOVLB  0
03EEC:  RCALL  3E5A
....................    i2c_stop(); 
03EEE:  BSF    FC5.2
03EF0:  BTFSC  FC5.2
03EF2:  BRA    3EF0
....................     
....................    global_mppc_value = value; 
03EF4:  MOVFF  554,BA
03EF8:  RETURN 0
.................... } 
....................  
.................... void  set_fixture_dac(uint16_t dac_value) 
.................... { 
....................    safeI2C_start(); 
*
03F68:  RCALL  3E1C
....................  
.................... //   fl_FIXTURE = !i2c_write(0x40);   // (0x40) Write FIXTURE DAC address 
.................... //   if (!fl_FIXTURE); 
.................... //   { 
.................... //      i2c_stop(); 
.................... //      return; 
.................... //   } 
....................     
....................    safei2c_write(0x40); 
03F6A:  MOVLW  40
03F6C:  MOVLB  5
03F6E:  MOVWF  x55
03F70:  MOVLB  0
03F72:  RCALL  3E5A
....................    safei2c_write(0x30); 
03F74:  MOVLW  30
03F76:  MOVLB  5
03F78:  MOVWF  x55
03F7A:  MOVLB  0
03F7C:  RCALL  3E5A
....................  
....................    dac_value <<= 4;        // shift 12 bit value so that MS bit is at bit15  
03F7E:  MOVLB  5
03F80:  RLCF   x4C,F
03F82:  RLCF   x4D,F
03F84:  RLCF   x4C,F
03F86:  RLCF   x4D,F
03F88:  RLCF   x4C,F
03F8A:  RLCF   x4D,F
03F8C:  RLCF   x4C,F
03F8E:  RLCF   x4D,F
03F90:  MOVLW  F0
03F92:  ANDWF  x4C,F
....................    safei2c_write (make8(dac_value,1));  
03F94:  MOVFF  54D,54E
03F98:  MOVFF  54D,555
03F9C:  MOVLB  0
03F9E:  RCALL  3E5A
....................    safei2c_write (make8(dac_value,0)); 
03FA0:  MOVFF  54C,54E
03FA4:  MOVFF  54C,555
03FA8:  RCALL  3E5A
....................    i2c_stop(); 
03FAA:  BSF    FC5.2
03FAC:  BTFSC  FC5.2
03FAE:  BRA    3FAC
....................     
....................    global_fixture_dac_value = dac_value; 
03FB0:  MOVFF  54D,BF
03FB4:  MOVFF  54C,BE
03FB8:  GOTO   4012 (RETURN)
.................... } 
....................  
.................... void adjust_brake_for_rpm(uint16_t rpm_set_value) 
.................... { 
....................    if (calc_gen_rpm() < rpm_set_value) 
....................    { 
....................       if (global_brake_duty != NO_BRK) 
....................       { 
....................          global_brake_duty--; 
....................       } 
....................       set_brake_duty(global_brake_duty); 
....................    } 
....................    else if (calc_gen_rpm() > rpm_set_value) 
....................    { 
....................       if (global_brake_duty != MAX_BRK) 
....................       { 
....................          global_brake_duty++; 
....................       } 
....................       set_brake_duty(global_brake_duty); 
....................    } 
.................... } 
....................  
.................... void adjust_brake_for_vgen(uint16_t vgen_set_value) 
.................... { 
....................    if (get_vgen(0) < vgen_set_value) 
....................    { 
....................       if (global_brake_duty != NO_BRK) 
....................       { 
....................          global_brake_duty--; 
....................       } 
....................       set_brake_duty(global_brake_duty); 
....................    } 
....................    else if (get_vgen(0) > vgen_set_value) 
....................    { 
....................       if (global_brake_duty != MAX_BRK) 
....................       { 
....................          global_brake_duty++; 
....................       } 
....................       set_brake_duty(global_brake_duty); 
....................    } 
.................... } 
....................  
....................     
.................... void adjust_fixture_for_rpm(uint16_t fixture_set_value) 
.................... { 
....................    if (calc_gen_rpm() < fixture_set_value) 
....................    { 
....................       if (global_fixture_dac_value != NO_FIXTURE) 
....................       { 
....................          global_fixture_dac_value--; 
....................       } 
....................       set_fixture_dac(global_fixture_dac_value); 
....................    } 
....................    else if (calc_gen_rpm() > fixture_set_value) 
....................    { 
....................       if (global_fixture_dac_value != MAX_FIXTURE) 
....................       { 
....................          global_fixture_dac_value++; 
....................       } 
....................       set_fixture_dac(global_fixture_dac_value); 
....................    } 
.................... }       
....................        
.................... void adjust_mppc(void) 
.................... { 
....................    static uint16_t last_vbatt_measurement = 0; 
....................    static uint16_t current_vbatt_measurement = 0; 
....................    static uint8_t last_mppc_value = 0; 
....................    static uint8_t last_last_mppc_value = 0; 
....................     
....................    // if the battery is full, exit 
....................     
....................     current_vbatt_measurement = get_vbatt(0); 
*
09D48:  MOVLB  5
09D4A:  CLRF   x68
09D4C:  MOVLB  0
09D4E:  CALL   4236
09D52:  MOVFF  02,53C
09D56:  MOVFF  01,53B
....................      
....................    // first time to initalize values 
....................    if ((last_vbatt_measurement == 0) || (last_mppc_value == 0)) 
09D5A:  MOVLB  5
09D5C:  MOVF   x39,F
09D5E:  BNZ   9D64
09D60:  MOVF   x3A,F
09D62:  BZ    9D68
09D64:  MOVF   x3D,F
09D66:  BNZ   9D74
....................    { 
....................       last_vbatt_measurement = current_vbatt_measurement; 
09D68:  MOVFF  53C,53A
09D6C:  MOVFF  53B,539
....................       last_mppc_value = global_mppc_value; 
09D70:  MOVFF  BA,53D
....................    } 
....................    last_last_mppc_value = last_mppc_value; 
09D74:  MOVFF  53D,53E
....................    last_mppc_value = global_mppc_value; 
09D78:  MOVFF  BA,53D
....................        
....................    if (last_vbatt_measurement < current_vbatt_measurement) 
09D7C:  MOVF   x3A,W
09D7E:  SUBWF  x3C,W
09D80:  BNC   9DD0
09D82:  BNZ   9D8A
09D84:  MOVF   x3B,W
09D86:  SUBWF  x39,W
09D88:  BC    9DD0
....................    { 
....................       if (last_last_mppc_value < global_mppc_value) 
09D8A:  MOVLB  0
09D8C:  MOVF   xBA,W
09D8E:  MOVLB  5
09D90:  SUBWF  x3E,W
09D92:  BC    9DA4
....................       { 
....................          if (global_mppc_value != MAX_MPPC) global_mppc_value+=5; 
09D94:  MOVLB  0
09D96:  INCFSZ xBA,W
09D98:  BRA    9D9C
09D9A:  BRA    9DA0
09D9C:  MOVLW  05
09D9E:  ADDWF  xBA,F
....................       } 
09DA0:  BRA    9DCC
09DA2:  MOVLB  5
....................       else if (last_last_mppc_value > global_mppc_value) 
09DA4:  MOVF   x3E,W
09DA6:  MOVLB  0
09DA8:  SUBWF  xBA,W
09DAA:  BC    9DB8
....................       { 
....................          if (global_mppc_value != NO_MPPC) global_mppc_value-=5; 
09DAC:  MOVF   xBA,W
09DAE:  SUBLW  07
09DB0:  BZ    9DB6
09DB2:  MOVLW  05
09DB4:  SUBWF  xBA,F
....................       } 
09DB6:  BRA    9DCC
....................       else 
....................       { 
....................          if (global_mppc_value == NO_MPPC) global_mppc_value++; 
09DB8:  MOVF   xBA,W
09DBA:  SUBLW  07
09DBC:  BNZ   9DC2
09DBE:  INCF   xBA,F
09DC0:  BRA    9DCC
....................          else if (global_mppc_value == MAX_MPPC) global_mppc_value--; 
09DC2:  INCFSZ xBA,W
09DC4:  BRA    9DCA
09DC6:  DECF   xBA,F
09DC8:  BRA    9DCC
....................          else global_mppc_value++; 
09DCA:  INCF   xBA,F
....................       } 
....................    } 
09DCC:  BRA    9E0E
09DCE:  MOVLB  5
....................    else 
....................    { 
....................       if (last_last_mppc_value > global_mppc_value) 
09DD0:  MOVF   x3E,W
09DD2:  MOVLB  0
09DD4:  SUBWF  xBA,W
09DD6:  BC    9DE2
....................       { 
....................          if (global_mppc_value != MAX_MPPC) global_mppc_value++; 
09DD8:  INCFSZ xBA,W
09DDA:  BRA    9DDE
09DDC:  BRA    9DE0
09DDE:  INCF   xBA,F
....................       } 
09DE0:  BRA    9E0E
....................       else if (last_last_mppc_value < global_mppc_value) 
09DE2:  MOVF   xBA,W
09DE4:  MOVLB  5
09DE6:  SUBWF  x3E,W
09DE8:  BC    9DF8
....................       { 
....................          if (global_mppc_value != NO_MPPC) global_mppc_value--; 
09DEA:  MOVLB  0
09DEC:  MOVF   xBA,W
09DEE:  SUBLW  07
09DF0:  BZ    9DF4
09DF2:  DECF   xBA,F
....................       } 
09DF4:  BRA    9E0E
09DF6:  MOVLB  5
....................       else 
....................       { 
....................          if (global_mppc_value == NO_MPPC) global_mppc_value++; 
09DF8:  MOVLB  0
09DFA:  MOVF   xBA,W
09DFC:  SUBLW  07
09DFE:  BNZ   9E04
09E00:  INCF   xBA,F
09E02:  BRA    9E0E
....................          else if (global_mppc_value == MAX_MPPC) global_mppc_value--; 
09E04:  INCFSZ xBA,W
09E06:  BRA    9E0C
09E08:  DECF   xBA,F
09E0A:  BRA    9E0E
....................          else global_mppc_value++; 
09E0C:  INCF   xBA,F
....................       } 
....................    } 
....................     
....................    last_vbatt_measurement = current_vbatt_measurement; 
09E0E:  MOVFF  53C,53A
09E12:  MOVFF  53B,539
....................    set_mppc(global_mppc_value); 
09E16:  MOVFF  BA,554
09E1A:  CALL   3E6E
....................    return; 
09E1E:  GOTO   AFD0 (RETURN)
.................... } 
....................  
.................... uint8_t calc_mppc_by_vgen(void) 
.................... { 
....................    int16_t mppc; 
....................    mppc = (((get_vgen(0) - 100) * 20)/100); 
*
04E90:  MOVLB  5
04E92:  CLRF   x57
04E94:  MOVLB  0
04E96:  CALL   4290
04E9A:  MOVFF  02,557
04E9E:  MOVFF  01,556
04EA2:  MOVLW  64
04EA4:  MOVLB  5
04EA6:  SUBWF  x56,F
04EA8:  MOVLW  00
04EAA:  SUBWFB x57,F
04EAC:  MOVFF  557,56B
04EB0:  MOVFF  556,56A
04EB4:  CLRF   x6D
04EB6:  MOVLW  14
04EB8:  MOVWF  x6C
04EBA:  MOVLB  0
04EBC:  RCALL  4970
04EBE:  MOVFF  02,557
04EC2:  MOVFF  01,556
04EC6:  MOVFF  02,576
04ECA:  MOVFF  01,575
04ECE:  MOVLB  5
04ED0:  CLRF   x78
04ED2:  MOVLW  64
04ED4:  MOVWF  x77
04ED6:  MOVLB  0
04ED8:  CALL   4306
04EDC:  MOVFF  02,555
04EE0:  MOVLB  5
04EE2:  MOVFF  01,554
....................    if (mppc < NO_MPPC) 
04EE6:  BTFSC  x55.7
04EE8:  BRA    4EF4
04EEA:  MOVF   x55,F
04EEC:  BNZ   4EFC
04EEE:  MOVF   x54,W
04EF0:  SUBLW  06
04EF2:  BNC   4EFC
....................    { 
....................       mppc = NO_MPPC; 
04EF4:  CLRF   x55
04EF6:  MOVLW  07
04EF8:  MOVWF  x54
....................    } 
04EFA:  BRA    4F0A
....................    else if (mppc > MAX_MPPC) 
04EFC:  BTFSC  x55.7
04EFE:  BRA    4F0A
04F00:  MOVF   x55,W
04F02:  SUBLW  00
04F04:  BC    4F0A
....................    { 
....................       mppc = MAX_MPPC; 
04F06:  CLRF   x55
04F08:  SETF   x54
....................    } 
....................    return mppc; 
04F0A:  MOVFF  554,01
04F0E:  MOVLB  0
04F10:  GOTO   53E0 (RETURN)
.................... } 
....................  
.................... void update_control_loop(void) 
.................... { 
.................... // Moves the brake duty and charge duty closer to their respective set points 
.................... // How quickly they move towards their set points depends on how far away they 
.................... //    are from the set points. 
....................  
....................    uint16_t rpm_difference, brake_duty_difference, charge_duty_difference; 
....................    uint8_t  duty_change, brake_duty_change, charge_duty_change; 
....................    static uint8_t  control_loop_cycles_to_next_update = 1; 
....................     
....................    /* 
....................    // if the sprinkler has no current commands, exit the control loop                   
....................    if (global_control_loop_mechanism == NO_SPRINKLER_CONTROL)  
....................    { 
....................       return; 
....................    } 
....................    */ 
....................     
....................    // set mppc to dynamic if in any other mode except test mode no rpm (with mppc hard set) 
....................    if (global_control_loop_mechanism != NO_RPM_CONTROL) 
*
053D8:  MOVF   xC0,W
053DA:  SUBLW  05
053DC:  BZ    53E4
....................    { 
....................       global_mppc_set_value = calc_mppc_by_vgen(); 
053DE:  BRA    4E90
053E0:  MOVFF  01,BB
....................    } 
....................    // set the mppc value              
....................    set_mppc(global_mppc_set_value);   
053E4:  MOVFF  BB,554
053E8:  CALL   3E6E
....................     
....................    // if it hasn't been enough cycles to update the control loop, exit 
....................    if (--control_loop_cycles_to_next_update > 0) 
053EC:  MOVLB  5
053EE:  DECF   x3F,F
053F0:  BZ    53F8
....................    { 
....................       return; 
053F2:  GOTO   5BA6
....................    } 
053F6:  BRA    53FC
....................    // otherwise, set it to the default of 1 
....................    else  
....................    { 
....................       control_loop_cycles_to_next_update = 1; 
053F8:  MOVLW  01
053FA:  MOVWF  x3F
....................    } 
....................     
....................    // grab the current rpm 
....................    global_current_rpm = calc_gen_rpm(); 
053FC:  MOVLB  0
053FE:  BRA    4F14
05400:  MOVFF  02,AB
05404:  MOVFF  01,AA
....................     
....................    // decide which regime we are in 
....................    switch (global_control_loop_mechanism) 
05408:  MOVF   xC0,W
0540A:  ADDLW  F6
0540C:  BTFSC  FD8.0
0540E:  GOTO   5BA4
05412:  ADDLW  0A
05414:  GOTO   5BAC
....................    { 
....................    // regular brake + charge rpm control 
....................    case BRAKE_AND_CHARGE: 
....................       // calculate the difference in rpm from set point 
....................       rpm_difference = abs((int16_t)global_current_rpm - (int16_t)global_rpm_set_value); 
05418:  MOVF   xAC,W
0541A:  SUBWF  xAA,W
0541C:  MOVLB  5
0541E:  MOVWF  x54
05420:  MOVLB  0
05422:  MOVF   xAD,W
05424:  SUBWFB xAB,W
05426:  MOVLB  5
05428:  MOVWF  x55
0542A:  MOVWF  03
0542C:  MOVF   x54,W
0542E:  BTFSS  x55.7
05430:  BRA    5442
05432:  MOVLW  00
05434:  BSF    FD8.0
05436:  SUBFWB x54,W
05438:  MOVWF  00
0543A:  MOVLW  00
0543C:  SUBFWB x55,W
0543E:  MOVWF  03
05440:  MOVF   00,W
05442:  MOVWF  x4B
05444:  MOVFF  03,54C
....................        
....................       // calulate how much to change the parameter (either brake or charge, just 
....................       //    reusing brake duty cycle for both) and how often to update based on  
....................       //    rpm difference from setpoint 
....................       if (rpm_difference >= 50)  
05448:  MOVF   x4C,F
0544A:  BNZ   5452
0544C:  MOVF   x4B,W
0544E:  SUBLW  31
05450:  BC    545C
....................       { 
....................          duty_change = 10; 
05452:  MOVLW  0A
05454:  MOVWF  x51
....................          control_loop_cycles_to_next_update = 5;               
05456:  MOVLW  05
05458:  MOVWF  x3F
....................       } 
0545A:  BRA    54A0
....................       else if (rpm_difference >= 25)  
0545C:  MOVF   x4C,F
0545E:  BNZ   5466
05460:  MOVF   x4B,W
05462:  SUBLW  18
05464:  BC    5470
....................       { 
....................          duty_change = 5; 
05466:  MOVLW  05
05468:  MOVWF  x51
....................          control_loop_cycles_to_next_update = 6; 
0546A:  MOVLW  06
0546C:  MOVWF  x3F
....................       } 
0546E:  BRA    54A0
....................       else if (rpm_difference >= 10) 
05470:  MOVF   x4C,F
05472:  BNZ   547A
05474:  MOVF   x4B,W
05476:  SUBLW  09
05478:  BC    5484
....................       { 
....................          duty_change = 4; 
0547A:  MOVLW  04
0547C:  MOVWF  x51
....................          control_loop_cycles_to_next_update = 7; 
0547E:  MOVLW  07
05480:  MOVWF  x3F
....................       } 
05482:  BRA    54A0
....................       else if (rpm_difference >= 5)  
05484:  MOVF   x4C,F
05486:  BNZ   548E
05488:  MOVF   x4B,W
0548A:  SUBLW  04
0548C:  BC    5498
....................       { 
....................          duty_change = 2; 
0548E:  MOVLW  02
05490:  MOVWF  x51
....................          control_loop_cycles_to_next_update = 8; 
05492:  MOVLW  08
05494:  MOVWF  x3F
....................       } 
05496:  BRA    54A0
.................... //      else if (rpm_difference >= 0)  
....................       else 
....................       {   
....................          duty_change = 1; 
05498:  MOVLW  01
0549A:  MOVWF  x51
....................          control_loop_cycles_to_next_update = 10; 
0549C:  MOVLW  0A
0549E:  MOVWF  x3F
....................       } 
....................        
....................       // Set point is lower than current value (increase braking force) 
....................       if (global_current_rpm > global_rpm_set_value)  
054A0:  MOVLB  0
054A2:  MOVF   xAD,W
054A4:  SUBWF  xAB,W
054A6:  BTFSS  FD8.0
054A8:  BRA    559C
054AA:  BNZ   54B4
054AC:  MOVF   xAA,W
054AE:  SUBWF  xAC,W
054B0:  BTFSC  FD8.0
054B2:  BRA    559C
....................       { 
....................          // if we are at max charge already, move to the braking 
....................          if (global_charge_duty == MAX_CHARGE) 
054B4:  MOVF   xB4,W
054B6:  SUBLW  90
054B8:  BNZ   5544
054BA:  DECFSZ xB5,W
054BC:  BRA    5544
....................          { 
....................             // if we are at max brake (and charge) and detecting a magnetic decoupling condition 
....................             if ((global_brake_duty == MAX_BRK) && (global_current_rpm == 0-1)) 
054BE:  MOVF   xB2,W
054C0:  SUBLW  90
054C2:  BNZ   54D2
054C4:  DECFSZ xB3,W
054C6:  BRA    54D2
054C8:  INCFSZ xAA,W
054CA:  BRA    54D2
054CC:  INCFSZ xAB,W
054CE:  BRA    54D2
....................             { 
.................... #IFNDEF DISABLE_MAG_DECOUPLING_RECOVERY 
....................              
....................                // start magnetic de-coupling fix 
....................                // set an error bit saying magnetic decoupling is detected 
....................                global_error_message_bitfield |= ERR_MSG_MAG_DECOUPLING; 
....................                // send error message 
....................                PUSH_MESSAGE_QUEUE_MACRO(MSG_MOTE_ERROR_MSG); 
....................                // push a MOVE_VALVE_MAG_DECOUPLING_RECOVERY event 
....................                PUSH_PRIORITY_QUEUE_MACRO(MOVE_VALVE_MAG_DECOUPLING_RECOVERY); 
.................... #ENDIF 
....................             } 
054D0:  BRA    5542
....................  
....................             // if we are at max brake (and charge) (no decoupling) send an error message 
....................             else if (global_brake_duty == MAX_BRK) 
054D2:  MOVF   xB2,W
054D4:  SUBLW  90
054D6:  BNZ   54F0
054D8:  DECFSZ xB3,W
054DA:  BRA    54F0
....................             { 
....................                // set an error bit saying rpm was too low to reach 
....................                global_error_message_bitfield |= ERR_MSG_RPM_TOO_LOW_TO_REACH; 
054DC:  MOVLB  4
054DE:  BSF    xF8.5
....................                // send error message 
....................                PUSH_MESSAGE_QUEUE_MACRO(MSG_MOTE_ERROR_MSG); 
054E0:  BCF    F7A.1
054E2:  MOVLW  A0
054E4:  MOVLB  5
054E6:  MOVWF  x54
054E8:  MOVLB  0
054EA:  RCALL  4FF4
054EC:  BSF    F7A.1
....................             } 
054EE:  BRA    5542
....................             // if we can't increase charge anymore, set it to max 
....................             else if ((global_brake_duty + duty_change) > MAX_CHARGE) 
054F0:  MOVLB  5
054F2:  MOVF   x51,W
054F4:  MOVLB  0
054F6:  ADDWF  xB2,W
054F8:  MOVLB  5
054FA:  MOVWF  x54
054FC:  MOVLW  00
054FE:  MOVLB  0
05500:  ADDWFC xB3,W
05502:  MOVLB  5
05504:  MOVWF  x55
05506:  SUBLW  00
05508:  BC    5524
0550A:  XORLW  FF
0550C:  BNZ   5514
0550E:  MOVF   x54,W
05510:  SUBLW  90
05512:  BC    5524
....................             { 
....................                set_brake_duty(MAX_BRK); 
05514:  MOVLW  01
05516:  MOVWF  x57
05518:  MOVLW  90
0551A:  MOVWF  x56
0551C:  MOVLB  0
0551E:  RCALL  5308
....................             } 
05520:  BRA    5542
05522:  MOVLB  5
....................             // increase braking as per normal 
....................             else 
....................             { 
....................                set_brake_duty(global_brake_duty + duty_change); 
05524:  MOVF   x51,W
05526:  MOVLB  0
05528:  ADDWF  xB2,W
0552A:  MOVLB  5
0552C:  MOVWF  x54
0552E:  MOVLW  00
05530:  MOVLB  0
05532:  ADDWFC xB3,W
05534:  MOVLB  5
05536:  MOVWF  x55
05538:  MOVWF  x57
0553A:  MOVFF  554,556
0553E:  MOVLB  0
05540:  RCALL  5308
....................             } 
....................          }   
05542:  BRA    559A
....................          // if we can't increase charge anymore, set it to max 
....................          else if ((global_charge_duty + duty_change) > MAX_CHARGE) 
05544:  MOVLB  5
05546:  MOVF   x51,W
05548:  MOVLB  0
0554A:  ADDWF  xB4,W
0554C:  MOVLB  5
0554E:  MOVWF  x54
05550:  MOVLW  00
05552:  MOVLB  0
05554:  ADDWFC xB5,W
05556:  MOVLB  5
05558:  MOVWF  x55
0555A:  SUBLW  00
0555C:  BC    557A
0555E:  XORLW  FF
05560:  BNZ   5568
05562:  MOVF   x54,W
05564:  SUBLW  90
05566:  BC    557A
....................          { 
....................             set_charge_duty(MAX_CHARGE); 
05568:  MOVLW  01
0556A:  MOVWF  x57
0556C:  MOVLW  90
0556E:  MOVWF  x56
05570:  MOVLB  0
05572:  CALL   3EFA
....................          } 
05576:  BRA    559A
05578:  MOVLB  5
....................         // increase charging as per normal 
....................         else 
....................         { 
....................             set_charge_duty(global_charge_duty + duty_change); 
0557A:  MOVF   x51,W
0557C:  MOVLB  0
0557E:  ADDWF  xB4,W
05580:  MOVLB  5
05582:  MOVWF  x54
05584:  MOVLW  00
05586:  MOVLB  0
05588:  ADDWFC xB5,W
0558A:  MOVLB  5
0558C:  MOVWF  x55
0558E:  MOVWF  x57
05590:  MOVFF  554,556
05594:  MOVLB  0
05596:  CALL   3EFA
....................         } 
....................       } 
0559A:  BRA    5686
....................       // Set point is higher than current value (increase braking force) 
....................       else if (global_current_rpm < global_rpm_set_value)  
0559C:  MOVF   xAB,W
0559E:  SUBWF  xAD,W
055A0:  BTFSS  FD8.0
055A2:  BRA    5686
055A4:  BNZ   55AE
055A6:  MOVF   xAC,W
055A8:  SUBWF  xAA,W
055AA:  BTFSC  FD8.0
055AC:  BRA    5686
....................       { 
....................          // if we are at min braking already, move to the charging 
....................          if (global_brake_duty == NO_BRK) 
055AE:  MOVF   xB2,F
055B0:  BNZ   5638
055B2:  MOVF   xB3,F
055B4:  BNZ   5638
....................          { 
....................             // if we are at min charge (and brake) and the rpms are 0  
....................             // (a not spinning condition) 
....................             if ((global_charge_duty == NO_CHARGE) && (global_current_rpm == 0)) 
055B6:  MOVF   xB4,F
055B8:  BNZ   55C8
055BA:  MOVF   xB5,F
055BC:  BNZ   55C8
055BE:  MOVF   xAA,F
055C0:  BNZ   55C8
055C2:  MOVF   xAB,F
055C4:  BNZ   55C8
....................             { 
.................... #IFNDEF DISABLE_NO_SPIN_RECOVERY             
....................                // start not spinning recovery 
....................                // set an error bit saying there isn't any spinning 
....................                global_error_message_bitfield |= ERR_MSG_NOT_SPINNING; 
....................                // send error message to manager 
....................                PUSH_MESSAGE_QUEUE_MACRO(MSG_MOTE_ERROR_MSG); 
....................                // push a MOVE_VALVE_NO_SPIN_RECOVERY event                
....................                PUSH_PRIORITY_QUEUE_MACRO(MOVE_VALVE_NO_SPIN_RECOVERY); 
.................... #ENDIF 
....................             } 
055C6:  BRA    5636
....................             // if we are at min charge (and brake) send an error message if 
....................             //    the bitfield bit isn't already sent (to avoid sending messages 
....................             //    all the time 
....................             else if (global_charge_duty == NO_CHARGE)  
055C8:  MOVF   xB4,F
055CA:  BNZ   55E4
055CC:  MOVF   xB5,F
055CE:  BNZ   55E4
....................             { 
....................                // set an error bit saying rpm was too high to reach 
....................                global_error_message_bitfield |= ERR_MSG_RPM_TOO_HIGH_TO_REACH; 
055D0:  MOVLB  4
055D2:  BSF    xF8.4
....................                // send error message to manager 
....................                PUSH_MESSAGE_QUEUE_MACRO(MSG_MOTE_ERROR_MSG); 
055D4:  BCF    F7A.1
055D6:  MOVLW  A0
055D8:  MOVLB  5
055DA:  MOVWF  x54
055DC:  MOVLB  0
055DE:  RCALL  4FF4
055E0:  BSF    F7A.1
....................             } 
055E2:  BRA    5636
....................             // if we can't decrease charge anymore, set it to min 
....................             // notice use of unsigned math here  
....................             else if ((global_charge_duty - duty_change) > MAX_CHARGE) 
055E4:  MOVLB  5
055E6:  MOVF   x51,W
055E8:  MOVLB  0
055EA:  SUBWF  xB4,W
055EC:  MOVLB  5
055EE:  MOVWF  x54
055F0:  MOVLW  00
055F2:  MOVLB  0
055F4:  SUBWFB xB5,W
055F6:  MOVLB  5
055F8:  MOVWF  x55
055FA:  SUBLW  00
055FC:  BC    5616
055FE:  XORLW  FF
05600:  BNZ   5608
05602:  MOVF   x54,W
05604:  SUBLW  90
05606:  BC    5616
....................             { 
....................                set_charge_duty(NO_CHARGE); 
05608:  CLRF   x57
0560A:  CLRF   x56
0560C:  MOVLB  0
0560E:  CALL   3EFA
....................             } 
05612:  BRA    5636
05614:  MOVLB  5
....................             // decrease charging as per normal 
....................             else 
....................             { 
....................                set_charge_duty(global_charge_duty - duty_change); 
05616:  MOVF   x51,W
05618:  MOVLB  0
0561A:  SUBWF  xB4,W
0561C:  MOVLB  5
0561E:  MOVWF  x54
05620:  MOVLW  00
05622:  MOVLB  0
05624:  SUBWFB xB5,W
05626:  MOVLB  5
05628:  MOVWF  x55
0562A:  MOVWF  x57
0562C:  MOVFF  554,556
05630:  MOVLB  0
05632:  CALL   3EFA
....................             } 
....................          }   
05636:  BRA    5686
....................          // if we can't decrease brake anymore, set it to min 
....................          // notice use of unsigned math here  
....................          else if ((global_brake_duty - duty_change) > MAX_BRK) 
05638:  MOVLB  5
0563A:  MOVF   x51,W
0563C:  MOVLB  0
0563E:  SUBWF  xB2,W
05640:  MOVLB  5
05642:  MOVWF  x54
05644:  MOVLW  00
05646:  MOVLB  0
05648:  SUBWFB xB3,W
0564A:  MOVLB  5
0564C:  MOVWF  x55
0564E:  SUBLW  00
05650:  BC    5668
05652:  XORLW  FF
05654:  BNZ   565C
05656:  MOVF   x54,W
05658:  SUBLW  90
0565A:  BC    5668
....................          { 
....................             set_brake_duty(NO_BRK); 
0565C:  CLRF   x57
0565E:  CLRF   x56
05660:  MOVLB  0
05662:  RCALL  5308
....................          } 
05664:  BRA    5686
05666:  MOVLB  5
....................         // decrease braking as per normal 
....................         else 
....................         { 
....................             set_brake_duty(global_brake_duty - duty_change); 
05668:  MOVF   x51,W
0566A:  MOVLB  0
0566C:  SUBWF  xB2,W
0566E:  MOVLB  5
05670:  MOVWF  x54
05672:  MOVLW  00
05674:  MOVLB  0
05676:  SUBWFB xB3,W
05678:  MOVLB  5
0567A:  MOVWF  x55
0567C:  MOVWF  x57
0567E:  MOVFF  554,556
05682:  MOVLB  0
05684:  RCALL  5308
....................         } 
....................       } 
....................       break; 
05686:  BRA    5BA4
....................        
....................    // RPM is only controlled by brake (when charger is turned off 
....................    case BRAKE_ONLY: 
....................    case BRAKE_AND_CHARGE_START: 
....................       // calculate the difference in rpm from set point 
....................       rpm_difference = abs((int16_t)global_current_rpm - (int16_t)global_rpm_set_value); 
05688:  MOVF   xAC,W
0568A:  SUBWF  xAA,W
0568C:  MOVLB  5
0568E:  MOVWF  x54
05690:  MOVLB  0
05692:  MOVF   xAD,W
05694:  SUBWFB xAB,W
05696:  MOVLB  5
05698:  MOVWF  x55
0569A:  MOVWF  03
0569C:  MOVF   x54,W
0569E:  BTFSS  x55.7
056A0:  BRA    56B2
056A2:  MOVLW  00
056A4:  BSF    FD8.0
056A6:  SUBFWB x54,W
056A8:  MOVWF  00
056AA:  MOVLW  00
056AC:  SUBFWB x55,W
056AE:  MOVWF  03
056B0:  MOVF   00,W
056B2:  MOVWF  x4B
056B4:  MOVFF  03,54C
....................        
....................       // calulate how much to change the parameter (either brake or charge, just 
....................       //    reusing brake duty cycle for both) and how often to update based on  
....................       //    rpm difference from setpoint 
....................       if (rpm_difference >= 50)  
056B8:  MOVF   x4C,F
056BA:  BNZ   56C2
056BC:  MOVF   x4B,W
056BE:  SUBLW  31
056C0:  BC    56CC
....................       { 
....................          duty_change = 15; 
056C2:  MOVLW  0F
056C4:  MOVWF  x51
....................          control_loop_cycles_to_next_update = 5; 
056C6:  MOVLW  05
056C8:  MOVWF  x3F
....................       } 
056CA:  BRA    5710
....................       else if (rpm_difference >= 25)  
056CC:  MOVF   x4C,F
056CE:  BNZ   56D6
056D0:  MOVF   x4B,W
056D2:  SUBLW  18
056D4:  BC    56E0
....................       { 
....................          duty_change = 10; 
056D6:  MOVLW  0A
056D8:  MOVWF  x51
....................          control_loop_cycles_to_next_update = 5; 
056DA:  MOVLW  05
056DC:  MOVWF  x3F
....................       } 
056DE:  BRA    5710
....................       else if (rpm_difference >= 10) 
056E0:  MOVF   x4C,F
056E2:  BNZ   56EA
056E4:  MOVF   x4B,W
056E6:  SUBLW  09
056E8:  BC    56F4
....................       { 
....................          duty_change = 5; 
056EA:  MOVLW  05
056EC:  MOVWF  x51
....................          control_loop_cycles_to_next_update = 7; 
056EE:  MOVLW  07
056F0:  MOVWF  x3F
....................       } 
056F2:  BRA    5710
....................       else if (rpm_difference >= 5)  
056F4:  MOVF   x4C,F
056F6:  BNZ   56FE
056F8:  MOVF   x4B,W
056FA:  SUBLW  04
056FC:  BC    5708
....................       { 
....................          duty_change = 2; 
056FE:  MOVLW  02
05700:  MOVWF  x51
....................          control_loop_cycles_to_next_update = 8; 
05702:  MOVLW  08
05704:  MOVWF  x3F
....................       } 
05706:  BRA    5710
.................... //      else if (rpm_difference >= 0)  
....................       else 
....................       {   
....................          duty_change = 1; 
05708:  MOVLW  01
0570A:  MOVWF  x51
....................          control_loop_cycles_to_next_update = 8; 
0570C:  MOVLW  08
0570E:  MOVWF  x3F
....................       } 
....................        
....................       // Set point is lower than current value (increase braking force) 
....................       if (global_current_rpm > global_rpm_set_value)  
05710:  MOVLB  0
05712:  MOVF   xAD,W
05714:  SUBWF  xAB,W
05716:  BNC   5794
05718:  BNZ   5720
0571A:  MOVF   xAA,W
0571C:  SUBWF  xAC,W
0571E:  BC    5794
....................       { 
....................       // if we are at max brake (and charge) and detecting a magnetic decoupling condition 
....................          if ((global_brake_duty == MAX_BRK) && (global_current_rpm == 0-1)) 
05720:  MOVF   xB2,W
05722:  SUBLW  90
05724:  BNZ   5734
05726:  DECFSZ xB3,W
05728:  BRA    5734
0572A:  INCFSZ xAA,W
0572C:  BRA    5734
0572E:  INCFSZ xAB,W
05730:  BRA    5734
....................          { 
.................... #IFNDEF DISABLE_MAG_DECOUPLING_RECOVERY          
....................             // start magnetic de-coupling fix 
....................             // set an error bit saying magnetic decoupling is detected 
....................             global_error_message_bitfield |= ERR_MSG_MAG_DECOUPLING; 
....................             // send error message 
....................             PUSH_MESSAGE_QUEUE_MACRO(MSG_MOTE_ERROR_MSG); 
....................             // push a MOVE_VALVE_MAG_DECOUPLING_RECOVERY event 
....................             PUSH_PRIORITY_QUEUE_MACRO(MOVE_VALVE_MAG_DECOUPLING_RECOVERY); 
.................... #ENDIF             
....................          } 
05732:  BRA    5792
....................          // if we are at max brake (and charge) send an error message 
....................          else if (global_brake_duty == MAX_BRK) 
05734:  MOVF   xB2,W
05736:  SUBLW  90
05738:  BNZ   5740
0573A:  DECFSZ xB3,W
0573C:  BRA    5740
....................          { 
.................... #IFNDEF DISABLE_MAG_DECOUPLING_RECOVERY          
....................             // set an error bit saying rpm was too low to reach 
....................             global_error_message_bitfield |= ERR_MSG_MAG_DECOUPLING; 
....................             // send error message 
....................             PUSH_MESSAGE_QUEUE_MACRO(MSG_MOTE_ERROR_MSG); 
.................... #ENDIF 
....................          } 
0573E:  BRA    5792
....................          // if we can't increase charge anymore, set it to max 
....................          else if ((global_brake_duty + duty_change) > MAX_CHARGE) 
05740:  MOVLB  5
05742:  MOVF   x51,W
05744:  MOVLB  0
05746:  ADDWF  xB2,W
05748:  MOVLB  5
0574A:  MOVWF  x54
0574C:  MOVLW  00
0574E:  MOVLB  0
05750:  ADDWFC xB3,W
05752:  MOVLB  5
05754:  MOVWF  x55
05756:  SUBLW  00
05758:  BC    5774
0575A:  XORLW  FF
0575C:  BNZ   5764
0575E:  MOVF   x54,W
05760:  SUBLW  90
05762:  BC    5774
....................          { 
....................             set_brake_duty(MAX_BRK); 
05764:  MOVLW  01
05766:  MOVWF  x57
05768:  MOVLW  90
0576A:  MOVWF  x56
0576C:  MOVLB  0
0576E:  RCALL  5308
....................          } 
05770:  BRA    5792
05772:  MOVLB  5
....................          // increase braking as per normal 
....................          else 
....................          { 
....................             set_brake_duty(global_brake_duty + duty_change); 
05774:  MOVF   x51,W
05776:  MOVLB  0
05778:  ADDWF  xB2,W
0577A:  MOVLB  5
0577C:  MOVWF  x54
0577E:  MOVLW  00
05780:  MOVLB  0
05782:  ADDWFC xB3,W
05784:  MOVLB  5
05786:  MOVWF  x55
05788:  MOVWF  x57
0578A:  MOVFF  554,556
0578E:  MOVLB  0
05790:  RCALL  5308
....................          } 
....................         
....................       } 
05792:  BRA    581E
....................       // Set point is higher than current value (increase braking force) 
....................       else if (global_current_rpm < global_rpm_set_value)  
05794:  MOVF   xAB,W
05796:  SUBWF  xAD,W
05798:  BNC   581E
0579A:  BNZ   57A2
0579C:  MOVF   xAC,W
0579E:  SUBWF  xAA,W
057A0:  BC    581E
....................       { 
....................           
....................          // if we are at min charge (and brake) and the rpms are 0  
....................          // (a not spinning condition) 
....................          if (global_brake_duty == NO_BRK && (global_current_rpm == 0)) 
057A2:  MOVF   xB2,F
057A4:  BNZ   57B4
057A6:  MOVF   xB3,F
057A8:  BNZ   57B4
057AA:  MOVF   xAA,F
057AC:  BNZ   57B4
057AE:  MOVF   xAB,F
057B0:  BNZ   57B4
....................          { 
.................... #IFNDEF DISABLE_NO_SPIN_RECOVERY        
....................             // start not spinning recovery 
....................             // set an error bit saying there isn't any spinning 
....................             global_error_message_bitfield |= ERR_MSG_NOT_SPINNING; 
....................             // send error message to manager 
....................             PUSH_MESSAGE_QUEUE_MACRO(MSG_MOTE_ERROR_MSG); 
....................             // push a MOVE_VALVE_NO_SPIN_RECOVERY event                
....................             PUSH_PRIORITY_QUEUE_MACRO(MOVE_VALVE_NO_SPIN_RECOVERY); 
.................... #ENDIF 
....................          } 
057B2:  BRA    581E
....................          // if we are at min braking already, move to the charging 
....................          else if (global_brake_duty == NO_BRK) 
057B4:  MOVF   xB2,F
057B6:  BNZ   57D0
057B8:  MOVF   xB3,F
057BA:  BNZ   57D0
....................          { 
....................             // if we are at min charge (and brake) send an error message if 
....................             //    the bitfield bit isn't already sent (to avoid sending messages 
....................             //    all the time 
....................     
....................             // set an error bit saying rpm was too high to reach 
....................             global_error_message_bitfield |= ERR_MSG_RPM_TOO_HIGH_TO_REACH; 
057BC:  MOVLB  4
057BE:  BSF    xF8.4
....................             // send error message to manager 
....................             PUSH_MESSAGE_QUEUE_MACRO(MSG_MOTE_ERROR_MSG);   
057C0:  BCF    F7A.1
057C2:  MOVLW  A0
057C4:  MOVLB  5
057C6:  MOVWF  x54
057C8:  MOVLB  0
057CA:  RCALL  4FF4
057CC:  BSF    F7A.1
....................          }   
057CE:  BRA    581E
....................          // if we can't decrease brake anymore, set it to min 
....................          // notice use of unsigned math here  
....................          else if ((global_brake_duty - duty_change) > MAX_BRK) 
057D0:  MOVLB  5
057D2:  MOVF   x51,W
057D4:  MOVLB  0
057D6:  SUBWF  xB2,W
057D8:  MOVLB  5
057DA:  MOVWF  x54
057DC:  MOVLW  00
057DE:  MOVLB  0
057E0:  SUBWFB xB3,W
057E2:  MOVLB  5
057E4:  MOVWF  x55
057E6:  SUBLW  00
057E8:  BC    5800
057EA:  XORLW  FF
057EC:  BNZ   57F4
057EE:  MOVF   x54,W
057F0:  SUBLW  90
057F2:  BC    5800
....................          { 
....................             set_brake_duty(NO_BRK); 
057F4:  CLRF   x57
057F6:  CLRF   x56
057F8:  MOVLB  0
057FA:  RCALL  5308
....................          } 
057FC:  BRA    581E
057FE:  MOVLB  5
....................         // decrease braking as per normal 
....................         else 
....................         { 
....................             set_brake_duty(global_brake_duty - duty_change); 
05800:  MOVF   x51,W
05802:  MOVLB  0
05804:  SUBWF  xB2,W
05806:  MOVLB  5
05808:  MOVWF  x54
0580A:  MOVLW  00
0580C:  MOVLB  0
0580E:  SUBWFB xB3,W
05810:  MOVLB  5
05812:  MOVWF  x55
05814:  MOVWF  x57
05816:  MOVFF  554,556
0581A:  MOVLB  0
0581C:  RCALL  5308
....................         } 
....................       } 
....................        
....................       // if we are in the brake only loop and want to turn off charger 
....................       if (global_control_loop_mechanism == BRAKE_ONLY) 
0581E:  MOVF   xC0,W
05820:  SUBLW  02
05822:  BNZ   586E
....................       { 
....................          // turn down charging until it is off (slowly) 
....................          if (global_charge_duty != NO_CHARGE) 
05824:  MOVF   xB4,F
05826:  BNZ   582C
05828:  MOVF   xB5,F
0582A:  BZ    586C
....................          { 
....................             // if gobal_charge_duty is 0-3 (note unsigned int math) 
....................             if ((global_charge_duty - 4) > MAX_CHARGE) 
0582C:  MOVLW  04
0582E:  SUBWF  xB4,W
05830:  MOVLB  5
05832:  MOVWF  x54
05834:  MOVLW  00
05836:  MOVLB  0
05838:  SUBWFB xB5,W
0583A:  MOVLB  5
0583C:  MOVWF  x55
0583E:  SUBLW  00
05840:  BC    5856
05842:  XORLW  FF
05844:  BNZ   584C
05846:  MOVF   x54,W
05848:  SUBLW  90
0584A:  BC    5856
....................             { 
....................                // set it to no charge 
....................                global_charge_duty = NO_CHARGE; 
0584C:  MOVLB  0
0584E:  CLRF   xB5
05850:  CLRF   xB4
....................             } 
05852:  BRA    5860
05854:  MOVLB  5
....................             else 
....................             { 
....................                // otherwise, decrement it by 4 
....................                global_charge_duty -= 4; 
05856:  MOVLW  04
05858:  MOVLB  0
0585A:  SUBWF  xB4,F
0585C:  MOVLW  00
0585E:  SUBWFB xB5,F
....................             } 
....................             // set lower charge amount. 
....................             set_charge_duty(global_charge_duty);  
05860:  MOVFF  B5,557
05864:  MOVFF  B4,556
05868:  CALL   3EFA
....................          } 
....................       } 
0586C:  BRA    58C6
....................       // if we are trying to turn the charger back on    
....................       else if (global_control_loop_mechanism == BRAKE_AND_CHARGE_START) 
0586E:  MOVF   xC0,F
05870:  BNZ   58C6
....................       {    
....................          // if gobal_charge_duty is almost completely on 
....................          if ((global_charge_duty + 4) >= MAX_CHARGE) 
05872:  MOVLW  04
05874:  ADDWF  xB4,W
05876:  MOVLB  5
05878:  MOVWF  x54
0587A:  MOVLW  00
0587C:  MOVLB  0
0587E:  ADDWFC xB5,W
05880:  MOVLB  5
05882:  MOVWF  x55
05884:  SUBLW  00
05886:  BC    58A2
05888:  XORLW  FF
0588A:  BNZ   5892
0588C:  MOVF   x54,W
0588E:  SUBLW  8F
05890:  BC    58A2
....................          { 
....................             // set it to max charge 
....................             global_charge_duty = MAX_CHARGE; 
05892:  MOVLW  01
05894:  MOVLB  0
05896:  MOVWF  xB5
05898:  MOVLW  90
0589A:  MOVWF  xB4
....................             // change control loop mechanism so it changes on next loop 
....................             global_control_loop_mechanism = BRAKE_AND_CHARGE; 
0589C:  MOVLW  01
0589E:  MOVWF  xC0
....................          } 
058A0:  BRA    58BA
....................          // if the braking has turned itself all the way off trying to compensate for 
....................          //    the charging turning on, switch over to the main control loop 
....................          else if(global_brake_duty == NO_BRK) 
058A2:  MOVLB  0
058A4:  MOVF   xB2,F
058A6:  BNZ   58B2
058A8:  MOVF   xB3,F
058AA:  BNZ   58B2
....................          { 
....................             // change control loop mechanism 
....................             global_control_loop_mechanism = BRAKE_AND_CHARGE; 
058AC:  MOVLW  01
058AE:  MOVWF  xC0
....................          } 
058B0:  BRA    58BA
....................          // otherwise, keep increasing the charge duty cycle. 
....................          else 
....................          { 
....................             // otherwise, decrement it by 4 
....................             global_charge_duty += 4; 
058B2:  MOVLW  04
058B4:  ADDWF  xB4,F
058B6:  MOVLW  00
058B8:  ADDWFC xB5,F
....................          } 
....................          // set higher charge amount. 
....................          set_charge_duty(global_charge_duty); 
058BA:  MOVFF  B5,557
058BE:  MOVFF  B4,556
058C2:  CALL   3EFA
....................       } 
....................       break; 
058C6:  BRA    5BA4
....................        
....................        
....................    // If in no rpm test mode 
....................    case NO_RPM_CONTROL_DYN_MPPC: 
....................    case NO_RPM_CONTROL: 
....................  
....................       // move things closer to the set values 
....................       // worst case senario 2.3 seconds to move 400 counts 
....................        
....................       // if difference is >= 200, move by 20  
....................       // if difference is >= 100, move by 10 
....................       // if difference is >= 50, move by 5 
....................       // if difference is >= 10, move by 2 
....................       // if difference is < 10, move by 1 
....................        
....................       brake_duty_difference = abs((int16_t)global_brake_duty - (int16_t)global_brake_duty_set_value); 
058C8:  MOVF   xB6,W
058CA:  SUBWF  xB2,W
058CC:  MOVLB  5
058CE:  MOVWF  x54
058D0:  MOVLB  0
058D2:  MOVF   xB7,W
058D4:  SUBWFB xB3,W
058D6:  MOVLB  5
058D8:  MOVWF  x55
058DA:  MOVWF  03
058DC:  MOVF   x54,W
058DE:  BTFSS  x55.7
058E0:  BRA    58F2
058E2:  MOVLW  00
058E4:  BSF    FD8.0
058E6:  SUBFWB x54,W
058E8:  MOVWF  00
058EA:  MOVLW  00
058EC:  SUBFWB x55,W
058EE:  MOVWF  03
058F0:  MOVF   00,W
058F2:  MOVWF  x4D
058F4:  MOVFF  03,54E
....................       charge_duty_difference = abs((int16_t)global_charge_duty - (int16_t)global_charge_duty_set_value); 
058F8:  MOVLB  0
058FA:  MOVF   xB8,W
058FC:  SUBWF  xB4,W
058FE:  MOVLB  5
05900:  MOVWF  x54
05902:  MOVLB  0
05904:  MOVF   xB9,W
05906:  SUBWFB xB5,W
05908:  MOVLB  5
0590A:  MOVWF  x55
0590C:  MOVWF  03
0590E:  MOVF   x54,W
05910:  BTFSS  x55.7
05912:  BRA    5924
05914:  MOVLW  00
05916:  BSF    FD8.0
05918:  SUBFWB x54,W
0591A:  MOVWF  00
0591C:  MOVLW  00
0591E:  SUBFWB x55,W
05920:  MOVWF  03
05922:  MOVF   00,W
05924:  MOVWF  x4F
05926:  MOVFF  03,550
....................        
....................       if (brake_duty_difference >= 200) brake_duty_change = 20; 
0592A:  MOVF   x4E,F
0592C:  BNZ   5934
0592E:  MOVF   x4D,W
05930:  SUBLW  C7
05932:  BC    593A
05934:  MOVLW  14
05936:  MOVWF  x52
05938:  BRA    5976
....................       else if (brake_duty_difference >= 100) brake_duty_change = 10; 
0593A:  MOVF   x4E,F
0593C:  BNZ   5944
0593E:  MOVF   x4D,W
05940:  SUBLW  63
05942:  BC    594A
05944:  MOVLW  0A
05946:  MOVWF  x52
05948:  BRA    5976
....................       else if (brake_duty_difference >= 50) brake_duty_change = 5; 
0594A:  MOVF   x4E,F
0594C:  BNZ   5954
0594E:  MOVF   x4D,W
05950:  SUBLW  31
05952:  BC    595A
05954:  MOVLW  05
05956:  MOVWF  x52
05958:  BRA    5976
....................       else if (brake_duty_difference >= 10) brake_duty_change = 2; 
0595A:  MOVF   x4E,F
0595C:  BNZ   5964
0595E:  MOVF   x4D,W
05960:  SUBLW  09
05962:  BC    596A
05964:  MOVLW  02
05966:  MOVWF  x52
05968:  BRA    5976
....................       else if (brake_duty_difference > 0) brake_duty_change = 1; 
0596A:  MOVF   x4D,F
0596C:  BNZ   5972
0596E:  MOVF   x4E,F
05970:  BZ    5976
05972:  MOVLW  01
05974:  MOVWF  x52
....................        
....................       if (global_brake_duty > global_brake_duty_set_value)  
05976:  MOVLB  0
05978:  MOVF   xB7,W
0597A:  SUBWF  xB3,W
0597C:  BNC   599E
0597E:  BNZ   5986
05980:  MOVF   xB2,W
05982:  SUBWF  xB6,W
05984:  BC    599E
....................       { 
....................          global_brake_duty-=brake_duty_change; 
05986:  MOVLB  5
05988:  MOVF   x52,W
0598A:  MOVLB  0
0598C:  SUBWF  xB2,F
0598E:  MOVLW  00
05990:  SUBWFB xB3,F
....................          set_brake_duty(global_brake_duty); 
05992:  MOVFF  B3,557
05996:  MOVFF  B2,556
0599A:  RCALL  5308
....................       } 
0599C:  BRA    59C2
....................       else if (global_brake_duty < global_brake_duty_set_value) 
0599E:  MOVF   xB3,W
059A0:  SUBWF  xB7,W
059A2:  BNC   59C2
059A4:  BNZ   59AC
059A6:  MOVF   xB6,W
059A8:  SUBWF  xB2,W
059AA:  BC    59C2
....................       { 
....................          global_brake_duty+=brake_duty_change; 
059AC:  MOVLB  5
059AE:  MOVF   x52,W
059B0:  MOVLB  0
059B2:  ADDWF  xB2,F
059B4:  MOVLW  00
059B6:  ADDWFC xB3,F
....................          set_brake_duty(global_brake_duty); 
059B8:  MOVFF  B3,557
059BC:  MOVFF  B2,556
059C0:  RCALL  5308
....................       } 
....................        
....................       if (charge_duty_difference >= 200) charge_duty_change = 20; 
059C2:  MOVLB  5
059C4:  MOVF   x50,F
059C6:  BNZ   59CE
059C8:  MOVF   x4F,W
059CA:  SUBLW  C7
059CC:  BC    59D4
059CE:  MOVLW  14
059D0:  MOVWF  x53
059D2:  BRA    5A10
....................       else if (charge_duty_difference >= 100) charge_duty_change = 10; 
059D4:  MOVF   x50,F
059D6:  BNZ   59DE
059D8:  MOVF   x4F,W
059DA:  SUBLW  63
059DC:  BC    59E4
059DE:  MOVLW  0A
059E0:  MOVWF  x53
059E2:  BRA    5A10
....................       else if (charge_duty_difference >= 50) charge_duty_change = 5; 
059E4:  MOVF   x50,F
059E6:  BNZ   59EE
059E8:  MOVF   x4F,W
059EA:  SUBLW  31
059EC:  BC    59F4
059EE:  MOVLW  05
059F0:  MOVWF  x53
059F2:  BRA    5A10
....................       else if (charge_duty_difference >= 10) charge_duty_change = 2; 
059F4:  MOVF   x50,F
059F6:  BNZ   59FE
059F8:  MOVF   x4F,W
059FA:  SUBLW  09
059FC:  BC    5A04
059FE:  MOVLW  02
05A00:  MOVWF  x53
05A02:  BRA    5A10
....................       else if (charge_duty_difference > 0) charge_duty_change = 1; 
05A04:  MOVF   x4F,F
05A06:  BNZ   5A0C
05A08:  MOVF   x50,F
05A0A:  BZ    5A10
05A0C:  MOVLW  01
05A0E:  MOVWF  x53
....................        
....................       if (global_charge_duty > global_charge_duty_set_value)  
05A10:  MOVLB  0
05A12:  MOVF   xB9,W
05A14:  SUBWF  xB5,W
05A16:  BNC   5A3A
05A18:  BNZ   5A20
05A1A:  MOVF   xB4,W
05A1C:  SUBWF  xB8,W
05A1E:  BC    5A3A
....................       { 
....................          global_charge_duty-=charge_duty_change; 
05A20:  MOVLB  5
05A22:  MOVF   x53,W
05A24:  MOVLB  0
05A26:  SUBWF  xB4,F
05A28:  MOVLW  00
05A2A:  SUBWFB xB5,F
....................          set_charge_duty(global_charge_duty); 
05A2C:  MOVFF  B5,557
05A30:  MOVFF  B4,556
05A34:  CALL   3EFA
....................       } 
05A38:  BRA    5A60
....................       else if (global_charge_duty < global_charge_duty_set_value) 
05A3A:  MOVF   xB5,W
05A3C:  SUBWF  xB9,W
05A3E:  BNC   5A60
05A40:  BNZ   5A48
05A42:  MOVF   xB8,W
05A44:  SUBWF  xB4,W
05A46:  BC    5A60
....................       { 
....................          global_charge_duty+=charge_duty_change; 
05A48:  MOVLB  5
05A4A:  MOVF   x53,W
05A4C:  MOVLB  0
05A4E:  ADDWF  xB4,F
05A50:  MOVLW  00
05A52:  ADDWFC xB5,F
....................          set_charge_duty(global_charge_duty); 
05A54:  MOVFF  B5,557
05A58:  MOVFF  B4,556
05A5C:  CALL   3EFA
....................       } 
....................       control_loop_cycles_to_next_update = 1; 
05A60:  MOVLW  01
05A62:  MOVLB  5
05A64:  MOVWF  x3F
....................       break; 
05A66:  MOVLB  0
05A68:  BRA    5BA4
....................    case NO_SPIN_RECOVERY: 
....................       // it's fixed! 
....................       // RPM is above the limit (10), RPM is not MAX (for decoupled condition) and valve is moving. 
....................       if ((global_current_rpm > NOT_SPINNING_MAG_DECOUPLING_RPM_FIXED) && (global_current_rpm !=(0-1)) && (!IS_VLV_COASTING)) 
05A6A:  MOVF   xAB,F
05A6C:  BNZ   5A78
05A6E:  MOVF   xAA,W
05A70:  MOVLB  5
05A72:  SUBWF  x1C,W
05A74:  BC    5AB2
05A76:  MOVLB  0
05A78:  INCFSZ xAA,W
05A7A:  BRA    5A86
05A7C:  INCFSZ xAB,W
05A7E:  BRA    5A86
05A80:  MOVLB  5
05A82:  BRA    5AB2
05A84:  MOVLB  0
05A86:  MOVF   F8D,F
05A88:  BTFSS  FD8.2
05A8A:  BRA    5A90
05A8C:  MOVLB  5
05A8E:  BRA    5AB2
....................       { 
....................          //stop the valve movement 
....................          disable_interrupts(INT_CCP3); 
05A90:  BCF    F7A.0
....................          global_valve_position_set_value = global_valve_position; 
05A92:  MOVFF  C2,C4
05A96:  MOVFF  C1,C3
....................          enable_interrupts(INT_CCP3); 
05A9A:  BSF    F7A.0
....................          // change control loop back to a normal mode 
....................          global_control_loop_mechanism = BRAKE_AND_CHARGE_START; 
05A9C:  CLRF   xC0
....................          // send a valve report to let people know of the new position 
....................          PUSH_MESSAGE_QUEUE_MACRO(MSG_MOTE_VALVE_REPORT); 
05A9E:  BCF    F7A.1
05AA0:  MOVLW  92
05AA2:  MOVLB  5
05AA4:  MOVWF  x54
05AA6:  MOVLB  0
05AA8:  CALL   4FF4
05AAC:  BSF    F7A.1
....................       } 
05AAE:  BRA    5B00
05AB0:  MOVLB  5
....................       // KINDA MESSY, FIX THIS LATER 
....................       // if the valve is within 5% of valve range (~2 seconds) of the position it's going, 
....................       //    control loop update position is slowed to 100x64ms or 6.4 seconds to give it time to react  
....................       else if ((!IS_VLV_COASTING) && ((global_valve_position_set_value - global_valve_position) < 0x0400)) 
05AB2:  MOVF   F8D,F
05AB4:  BZ    5AD4
05AB6:  MOVLB  0
05AB8:  MOVF   xC1,W
05ABA:  SUBWF  xC3,W
05ABC:  MOVLB  5
05ABE:  MOVWF  x54
05AC0:  MOVLB  0
05AC2:  MOVF   xC2,W
05AC4:  SUBWFB xC4,W
05AC6:  MOVLB  5
05AC8:  MOVWF  x55
05ACA:  SUBLW  03
05ACC:  BNC   5AD4
....................       { 
....................          control_loop_cycles_to_next_update = 100; 
05ACE:  MOVLW  64
05AD0:  MOVWF  x3F
....................       } 
05AD2:  BRA    5B02
....................       // it tried to move the valve a bunch and it didn't fix it :-/ 
....................       else if (IS_VLV_COASTING) 
05AD4:  MOVF   F8D,F
05AD6:  BNZ   5B02
....................       { 
....................          // set an error bit saying there isn't any spinning 
....................          global_error_message_bitfield |= ERR_MSG_MAG_NOT_SPIN_RECOVERY_FAILED; 
05AD8:  MOVLB  4
05ADA:  BSF    xF9.5
....................          // send error message to manager 
....................          PUSH_MESSAGE_QUEUE_MACRO(MSG_MOTE_ERROR_MSG); 
05ADC:  BCF    F7A.1
05ADE:  MOVLW  A0
05AE0:  MOVLB  5
05AE2:  MOVWF  x54
05AE4:  MOVLB  0
05AE6:  CALL   4FF4
05AEA:  BSF    F7A.1
....................          // stop the current sprinkler setting (also closes valve) and clear the queue 
....................          stop_current_spinkler_setting(); 
05AEC:  RCALL  5376
....................          clear_sprinkler_queue(); 
05AEE:  RCALL  53B0
....................          // send a valve report to let people know of the new position 
....................          PUSH_MESSAGE_QUEUE_MACRO(MSG_MOTE_VALVE_REPORT); 
05AF0:  BCF    F7A.1
05AF2:  MOVLW  92
05AF4:  MOVLB  5
05AF6:  MOVWF  x54
05AF8:  MOVLB  0
05AFA:  CALL   4FF4
05AFE:  BSF    F7A.1
05B00:  MOVLB  5
....................       } 
....................       break; 
05B02:  MOVLB  0
05B04:  BRA    5BA4
....................    case MAG_DECOUPLING_RECOVERY: 
....................       // it's fixed! 
....................       // RPM is above the limit (10), RPM is not MAX (for decoupled condition) and valve is moving. 
....................       if ((global_current_rpm > NOT_SPINNING_MAG_DECOUPLING_RPM_FIXED) && (global_current_rpm !=(0-1)) && (!IS_VLV_COASTING)) 
05B06:  MOVF   xAB,F
05B08:  BNZ   5B14
05B0A:  MOVF   xAA,W
05B0C:  MOVLB  5
05B0E:  SUBWF  x1C,W
05B10:  BC    5B50
05B12:  MOVLB  0
05B14:  INCFSZ xAA,W
05B16:  BRA    5B22
05B18:  INCFSZ xAB,W
05B1A:  BRA    5B22
05B1C:  MOVLB  5
05B1E:  BRA    5B50
05B20:  MOVLB  0
05B22:  MOVF   F8D,F
05B24:  BTFSS  FD8.2
05B26:  BRA    5B2C
05B28:  MOVLB  5
05B2A:  BRA    5B50
....................       { 
....................          //stop the valve movement 
....................          disable_interrupts(INT_CCP3); 
05B2C:  BCF    F7A.0
....................          global_valve_position_set_value = global_valve_position; 
05B2E:  MOVFF  C2,C4
05B32:  MOVFF  C1,C3
....................          enable_interrupts(INT_CCP3); 
05B36:  BSF    F7A.0
....................          // change control loop back to a normal mode 
....................          global_control_loop_mechanism = BRAKE_AND_CHARGE_START; 
05B38:  CLRF   xC0
....................          // send a valve report to let people know of the new position 
....................          PUSH_MESSAGE_QUEUE_MACRO(MSG_MOTE_VALVE_REPORT); 
05B3A:  BCF    F7A.1
05B3C:  MOVLW  92
05B3E:  MOVLB  5
05B40:  MOVWF  x54
05B42:  MOVLB  0
05B44:  CALL   4FF4
05B48:  BSF    F7A.1
....................          // put the control algorithm into a non-rpm controlled state (sort of an idle state) 
....................          global_control_loop_mechanism = BRAKE_AND_CHARGE_START; 
05B4A:  CLRF   xC0
....................       } 
05B4C:  BRA    5BA0
05B4E:  MOVLB  5
....................       // KINDA MESSY, FIX THIS LATER 
....................       // if the valve is within 5% of valve range (~2 seconds) of the position it's going, 
....................       //    control loop update position is slowed to 100x64ms or 6.4 seconds to give it time to react  
....................       else if ((!IS_VLV_COASTING) && ((global_valve_position - global_valve_position_set_value) < 0x0400)) 
05B50:  MOVF   F8D,F
05B52:  BZ    5B72
05B54:  MOVLB  0
05B56:  MOVF   xC3,W
05B58:  SUBWF  xC1,W
05B5A:  MOVLB  5
05B5C:  MOVWF  x54
05B5E:  MOVLB  0
05B60:  MOVF   xC4,W
05B62:  SUBWFB xC2,W
05B64:  MOVLB  5
05B66:  MOVWF  x55
05B68:  SUBLW  03
05B6A:  BNC   5B72
....................       { 
....................          control_loop_cycles_to_next_update = 100; 
05B6C:  MOVLW  64
05B6E:  MOVWF  x3F
....................       } 
05B70:  BRA    5BA2
....................       // it tried to move the valve a bunch and it didn't fix it :-/ 
....................       else if (IS_VLV_COASTING) 
05B72:  MOVF   F8D,F
05B74:  BNZ   5BA2
....................       { 
....................          // set an error bit saying there isn't any spinning 
....................          global_error_message_bitfield |= ERR_MSG_MAG_NOT_SPIN_RECOVERY_FAILED; 
05B76:  MOVLB  4
05B78:  BSF    xF9.5
....................          // send error message to manager 
....................          PUSH_MESSAGE_QUEUE_MACRO(MSG_MOTE_ERROR_MSG); 
05B7A:  BCF    F7A.1
05B7C:  MOVLW  A0
05B7E:  MOVLB  5
05B80:  MOVWF  x54
05B82:  MOVLB  0
05B84:  CALL   4FF4
05B88:  BSF    F7A.1
....................          // stop the current sprinkler setting (also closes valve) and clear the queue 
....................          stop_current_spinkler_setting(); 
05B8A:  CALL   5376
....................          clear_sprinkler_queue(); 
05B8E:  RCALL  53B0
....................          // send a valve report to let people know of the new position 
....................          PUSH_MESSAGE_QUEUE_MACRO(MSG_MOTE_VALVE_REPORT); 
05B90:  BCF    F7A.1
05B92:  MOVLW  92
05B94:  MOVLB  5
05B96:  MOVWF  x54
05B98:  MOVLB  0
05B9A:  CALL   4FF4
05B9E:  BSF    F7A.1
05BA0:  MOVLB  5
....................       } 
....................       break; 
05BA2:  MOVLB  0
05BA4:  MOVLB  5
....................    }      
....................    return; 
05BA6:  MOVLB  0
05BA8:  GOTO   A3DA (RETURN)
.................... } 
....................  
.................... void stop_current_spinkler_setting(void) 
.................... { 
....................    global_current_sprinkler_settings_end_time = 0-1; 
*
05376:  SETF   00
05378:  SETF   01
0537A:  SETF   02
0537C:  SETF   03
0537E:  MOVFF  03,42D
05382:  MOVFF  02,42C
05386:  MOVFF  01,42B
0538A:  MOVFF  00,42A
0538E:  CLRF   19
05390:  BTFSC  FF2.7
05392:  BSF    19.7
05394:  BCF    FF2.7
....................    PUSH_PRIORITY_QUEUE_ISR(OPEN_VALVE_UNKNOWN_STATE); 
05396:  MOVLW  3E
05398:  MOVLB  5
0539A:  MOVWF  xB7
0539C:  MOVLB  0
0539E:  CALL   082A
053A2:  BTFSC  19.7
053A4:  BSF    FF2.7
....................    global_rpm_set_value = 0; 
053A6:  CLRF   xAD
053A8:  CLRF   xAC
....................    //global_sprinkler_queue[global_current_sprinkler_queue_location].zone_num; 
....................    global_control_loop_mechanism = NO_RPM_CONTROL; 
053AA:  MOVLW  05
053AC:  MOVWF  xC0
053AE:  RETURN 0
.................... } 
.................... void stop_current_spinkler_setting_ISR(void) 
.................... { 
....................    global_current_sprinkler_settings_end_time = 0-1; 
*
02DE2:  SETF   00
02DE4:  SETF   01
02DE6:  SETF   02
02DE8:  SETF   03
02DEA:  MOVFF  03,42D
02DEE:  MOVFF  02,42C
02DF2:  MOVFF  01,42B
02DF6:  MOVFF  00,42A
02DFA:  CLRF   19
02DFC:  BTFSC  FF2.7
02DFE:  BSF    19.7
02E00:  BCF    FF2.7
....................    PUSH_PRIORITY_QUEUE_ISR_MACRO(OPEN_VALVE_UNKNOWN_STATE);           
02E02:  MOVLW  3E
02E04:  MOVLB  5
02E06:  MOVWF  xB7
02E08:  MOVLB  0
02E0A:  CALL   082A
02E0E:  BTFSC  19.7
02E10:  BSF    FF2.7
....................    global_rpm_set_value = 0; 
02E12:  CLRF   xAD
02E14:  CLRF   xAC
....................    //global_sprinkler_queue[global_current_sprinkler_queue_location].zone_num; 
....................    global_control_loop_mechanism = NO_RPM_CONTROL; 
02E16:  MOVLW  05
02E18:  MOVWF  xC0
02E1A:  GOTO   30BC (RETURN)
.................... }                                                         
....................  
.................... #include "valve.h"        
.................... void  comparator_setup(void) 
.................... { 
.................... // Sets up and enables the comparator for current limit detection when moving 
.................... //    valve 
....................     
....................    // turns off comparator 
....................    setup_comparator(NC_NC_NC_NC); 
*
08224:  CLRF   F77
08226:  MOVLW  04
08228:  MOVWF  F78
0822A:  MOVWF  F79
....................     
....................    // Sets up the DAC for a range of VDD-VSS 
....................    setup_DAC(DAC_VSS_VDD); 
0822C:  MOVLW  80
0822E:  MOVLB  F
08230:  MOVWF  x41
....................     
....................    // sets up an appropriate dac level depending on movement direction and  
....................    //    valve position 
....................    set_comp_dac_level(); 
08232:  MOVLB  0
08234:  BRA    80E6
....................     
....................    // delay for comparator to setup? 
....................    delay_cycles(5); 
08236:  BRA    8238
08238:  BRA    823A
0823A:  NOP   
....................     
....................    // CP1 compares VLV_I at its neg input to the DAC output 
....................    // CP2 off at power up and stays off 
....................    setup_comparator(CP1_A1_DAC); 
0823C:  CLRF   F77
0823E:  CLRF   F78
08240:  MOVLW  85
08242:  MOVWF  F79
08244:  MOVF   F92,W
08246:  IORLW  02
08248:  MOVWF  F92
0824A:  MOVF   F93,W
....................                                      
....................    // clear the comparator interrupt and enable it 
....................    clear_interrupt(INT_COMP); 
0824C:  BCF    FA1.6
....................    enable_interrupts(INT_COMP); 
0824E:  BSF    FA0.6
08250:  RETURN 0
.................... } 
....................  
.................... uint16_t calc_valve_movement_time(uint16_t current_location, uint16_t destination) 
.................... { 
.................... // calculates the amount of time it takes to make the move from  
.................... //    current location to destination and returns it in seconds (7.9 format) 
....................  
....................    uint32_t temp_u32; 
....................     
....................    // if valve is going to open 
....................    if (current_location < destination) 
....................    { 
....................       temp_u32 = ((uint32_t)(destination - current_location) * (uint32_t)(global_valve_time_to_open_1024th));  
....................    }   
....................    // if valve is going to close or not move at all 
....................    else if (current_location >= destination) 
....................    { 
....................       temp_u32 = ((uint32_t)(current_location - destination) * (uint32_t)(global_valve_time_to_close_1024th));  
....................    }   
....................     
....................    // now 8.24 format; convert to 16 bit 7.9 format (seconds) 
....................    if (bit_test(temp_u32,14)) 
....................    { 
....................       temp_u32 += 0x8000; 
....................    } 
....................    // return the time in 7.9 format (seconds) 
....................    return(uint16_t)(temp_u32 >> 15); 
.................... } 
....................  
.................... void set_comp_dac_level(void) 
.................... { 
.................... // sets the dac level for the comparator for different situations/vlv positions 
....................  
....................    // if valve is just begining to move and outside of the "almost close/opened" 
....................    //    regime.  DAC level is lowered to allow for more current draw. 
....................    if ((global_valve_time_in_motion_1024ths <= VLV_INIT_CURRENT_BOOST_TIME_1024THS)    \ 
....................       && (!(global_valve_position < VLV_NEAR_CLOSED_RANGE_MAX)) &&                     \ 
....................       (!(global_valve_position > VLV_NEAR_OPENED_RANGE_MAX))) 
*
080E6:  MOVF   xCA,W
080E8:  MOVLB  5
080EA:  SUBWF  x17,W
080EC:  BNC   8136
080EE:  BNZ   80FA
080F0:  MOVLB  0
080F2:  MOVF   xC9,W
080F4:  MOVLB  5
080F6:  SUBWF  x16,W
080F8:  BNC   8136
080FA:  MOVLB  0
080FC:  MOVF   xC2,W
080FE:  MOVLB  5
08100:  SUBWF  x07,W
08102:  BNC   8116
08104:  BNZ   8136
08106:  MOVF   x06,W
08108:  MOVLB  0
0810A:  SUBWF  xC1,W
0810C:  BTFSC  FD8.0
0810E:  BRA    8114
08110:  MOVLB  5
08112:  BRA    8136
08114:  MOVLB  5
08116:  MOVF   x09,W
08118:  MOVLB  0
0811A:  SUBWF  xC2,W
0811C:  BNC   8130
0811E:  BTFSC  FD8.2
08120:  BRA    8126
08122:  MOVLB  5
08124:  BRA    8136
08126:  MOVF   xC1,W
08128:  MOVLB  5
0812A:  SUBWF  x08,W
0812C:  BNC   8136
0812E:  MOVLB  0
....................    { 
....................       dac_write(DAC_LVL_INIT_CURRENT_BOOST); 
08130:  MOVFF  514,F40
....................    } 
08134:  BRA    821C
....................     
....................    // initial valve open (for a few seconds) 
....................    else if (read_system_state() == SYSTEM_CAL_VLV_1) 
08136:  MOVLB  0
08138:  CALL   1F02
0813C:  MOVF   01,W
0813E:  SUBLW  10
08140:  BNZ   8148
....................    { 
....................       dac_write(DAC_LVL_IN_MIDDLE); 
08142:  MOVFF  512,F40
....................    } 
08146:  BRA    821C
....................     
....................    // inital valve close (don't know where we are exactly) 
....................    else if (read_system_state() == SYSTEM_CAL_VLV_2) 
08148:  CALL   1F02
0814C:  MOVF   01,W
0814E:  SUBLW  11
08150:  BNZ   817A
....................    { 
....................       // normally, during this state, the valve position should be unknown 
....................  
....................       // if the valve is almost (or fully) open after the inital open push aka 
....................       //    it hit the open endstop 
....................       if (global_valve_position > VLV_NEAR_OPENED_RANGE_MAX) 
08152:  MOVLB  5
08154:  MOVF   x09,W
08156:  MOVLB  0
08158:  SUBWF  xC2,W
0815A:  BNC   8174
0815C:  BNZ   816E
0815E:  MOVF   xC1,W
08160:  MOVLB  5
08162:  SUBWF  x08,W
08164:  BTFSS  FD8.0
08166:  BRA    816C
08168:  MOVLB  0
0816A:  BRA    8174
0816C:  MOVLB  0
....................       { 
....................          dac_write(DAC_LVL_CLOSING_NEAR_OPENED); 
0816E:  MOVFF  50E,F40
....................       } 
08172:  BRA    8178
....................       // otherwise, position is unknown and will be assumed to be closing near 
....................       //    the closed endstop.  DAC level will be set as such to get a  
....................       //    consistent calibration 
....................       else 
....................       { 
....................          dac_write(DAC_LVL_CLOSING_NEAR_CLOSED); 
08174:  MOVFF  510,F40
....................       } 
....................    } 
08178:  BRA    821C
....................     
....................    // valve closing 
....................    else if (IS_VLV_CLOSING) 
0817A:  DECFSZ F8D,W
0817C:  BRA    81C8
....................    { 
....................       // valve is almost closed (or closed) and closing 
....................       if (global_valve_position < VLV_NEAR_CLOSED_RANGE_MAX) 
0817E:  MOVF   xC2,W
08180:  MOVLB  5
08182:  SUBWF  x07,W
08184:  BNC   819E
08186:  BNZ   8198
08188:  MOVF   x06,W
0818A:  MOVLB  0
0818C:  SUBWF  xC1,W
0818E:  BTFSS  FD8.0
08190:  BRA    8196
08192:  MOVLB  5
08194:  BRA    819E
08196:  MOVLB  5
....................       { 
....................          dac_write(DAC_LVL_CLOSING_NEAR_CLOSED); 
08198:  MOVFF  510,F40
....................       } 
0819C:  BRA    81C4
....................       // valve is almost open (or open) and closing 
....................       else if (global_valve_position > VLV_NEAR_OPENED_RANGE_MAX) 
0819E:  MOVF   x09,W
081A0:  MOVLB  0
081A2:  SUBWF  xC2,W
081A4:  BNC   81BE
081A6:  BNZ   81B8
081A8:  MOVF   xC1,W
081AA:  MOVLB  5
081AC:  SUBWF  x08,W
081AE:  BTFSS  FD8.0
081B0:  BRA    81B6
081B2:  MOVLB  0
081B4:  BRA    81BE
081B6:  MOVLB  0
....................       { 
....................          dac_write(DAC_LVL_CLOSING_NEAR_OPENED); 
081B8:  MOVFF  50E,F40
....................       } 
081BC:  BRA    81C2
....................       // valve is in the middle somewhere 
....................       else 
....................       { 
....................          dac_write(DAC_LVL_IN_MIDDLE); 
081BE:  MOVFF  512,F40
081C2:  MOVLB  5
....................       } 
....................    } 
081C4:  BRA    821E
081C6:  MOVLB  0
....................     
....................    // valve opening 
....................    else if (IS_VLV_OPENING) 
081C8:  MOVF   F8D,W
081CA:  SUBLW  02
081CC:  BNZ   8218
....................    { 
....................       // valve is almost closed (or closed) and opening 
....................       if (global_valve_position < VLV_NEAR_CLOSED_RANGE_MAX) 
081CE:  MOVF   xC2,W
081D0:  MOVLB  5
081D2:  SUBWF  x07,W
081D4:  BNC   81EE
081D6:  BNZ   81E8
081D8:  MOVF   x06,W
081DA:  MOVLB  0
081DC:  SUBWF  xC1,W
081DE:  BTFSS  FD8.0
081E0:  BRA    81E6
081E2:  MOVLB  5
081E4:  BRA    81EE
081E6:  MOVLB  5
....................       { 
....................          dac_write(DAC_LVL_OPENING_NEAR_CLOSED); 
081E8:  MOVFF  50C,F40
....................       } 
081EC:  BRA    8214
....................       // valve is almost open (or open) and opening 
....................       else if (global_valve_position > VLV_NEAR_OPENED_RANGE_MAX) 
081EE:  MOVF   x09,W
081F0:  MOVLB  0
081F2:  SUBWF  xC2,W
081F4:  BNC   820E
081F6:  BNZ   8208
081F8:  MOVF   xC1,W
081FA:  MOVLB  5
081FC:  SUBWF  x08,W
081FE:  BTFSS  FD8.0
08200:  BRA    8206
08202:  MOVLB  0
08204:  BRA    820E
08206:  MOVLB  0
....................       { 
....................          dac_write(DAC_LVL_OPENING_NEAR_OPENED); 
08208:  MOVFF  50A,F40
....................       } 
0820C:  BRA    8212
....................       // valve is in the middle somewhere 
....................       else 
....................       { 
....................          dac_write(DAC_LVL_IN_MIDDLE); 
0820E:  MOVFF  512,F40
08212:  MOVLB  5
....................       } 
....................    } 
08214:  BRA    821E
08216:  MOVLB  0
....................     
....................    // other cases (like if this accidentally gets called before valve is 
....................    //    actually moving, although it should get picked up by the initial  
....................    //    boost case 
....................    else 
....................    { 
....................       dac_write(DAC_LVL_IN_MIDDLE); 
08218:  MOVFF  512,F40
0821C:  MOVLB  5
....................    } 
0821E:  MOVLB  0
08220:  GOTO   8236 (RETURN)
.................... } 
....................  
....................  
.................... void set_comp_dac_level_ISR(void) 
.................... { 
.................... // sets the dac level for the comparator for different situations/vlv positions 
....................  
....................    // if valve is just begining to move and outside of the "almost close/opened" 
....................    //    regime.  DAC level is lowered to allow for more current draw. 
....................    if ((global_valve_time_in_motion_1024ths <= VLV_INIT_CURRENT_BOOST_TIME_1024THS) \ 
....................       && (!(global_valve_position < VLV_NEAR_CLOSED_RANGE_MAX)) &&            \ 
....................       (!(global_valve_position > VLV_NEAR_OPENED_RANGE_MAX))) 
*
01F0C:  MOVF   xCA,W
01F0E:  MOVLB  5
01F10:  SUBWF  x17,W
01F12:  BNC   1F5C
01F14:  BNZ   1F20
01F16:  MOVLB  0
01F18:  MOVF   xC9,W
01F1A:  MOVLB  5
01F1C:  SUBWF  x16,W
01F1E:  BNC   1F5C
01F20:  MOVLB  0
01F22:  MOVF   xC2,W
01F24:  MOVLB  5
01F26:  SUBWF  x07,W
01F28:  BNC   1F3C
01F2A:  BNZ   1F5C
01F2C:  MOVF   x06,W
01F2E:  MOVLB  0
01F30:  SUBWF  xC1,W
01F32:  BTFSC  FD8.0
01F34:  BRA    1F3A
01F36:  MOVLB  5
01F38:  BRA    1F5C
01F3A:  MOVLB  5
01F3C:  MOVF   x09,W
01F3E:  MOVLB  0
01F40:  SUBWF  xC2,W
01F42:  BNC   1F56
01F44:  BTFSC  FD8.2
01F46:  BRA    1F4C
01F48:  MOVLB  5
01F4A:  BRA    1F5C
01F4C:  MOVF   xC1,W
01F4E:  MOVLB  5
01F50:  SUBWF  x08,W
01F52:  BNC   1F5C
01F54:  MOVLB  0
....................    { 
....................       dac_write(DAC_LVL_INIT_CURRENT_BOOST); 
01F56:  MOVFF  514,F40
....................    } 
01F5A:  BRA    203E
....................     
....................    // initial valve open (for a few seconds) 
....................    else if (read_system_state() == SYSTEM_CAL_VLV_1) 
01F5C:  MOVLB  0
01F5E:  RCALL  1F02
01F60:  MOVF   01,W
01F62:  SUBLW  10
01F64:  BNZ   1F6C
....................    { 
....................       dac_write(DAC_LVL_IN_MIDDLE); 
01F66:  MOVFF  512,F40
....................    } 
01F6A:  BRA    203E
....................     
....................    // inital valve close (don't know where we are exactly) 
....................    else if (read_system_state() == SYSTEM_CAL_VLV_2) 
01F6C:  RCALL  1F02
01F6E:  MOVF   01,W
01F70:  SUBLW  11
01F72:  BNZ   1F9C
....................    { 
....................       // normally, during this state, the valve position should be unknown 
....................  
....................       // if the valve is almost (or fully) open after the inital open push aka 
....................       //    it hit the open endstop 
....................       if (global_valve_position > VLV_NEAR_OPENED_RANGE_MAX) 
01F74:  MOVLB  5
01F76:  MOVF   x09,W
01F78:  MOVLB  0
01F7A:  SUBWF  xC2,W
01F7C:  BNC   1F96
01F7E:  BNZ   1F90
01F80:  MOVF   xC1,W
01F82:  MOVLB  5
01F84:  SUBWF  x08,W
01F86:  BTFSS  FD8.0
01F88:  BRA    1F8E
01F8A:  MOVLB  0
01F8C:  BRA    1F96
01F8E:  MOVLB  0
....................       { 
....................          dac_write(DAC_LVL_CLOSING_NEAR_OPENED); 
01F90:  MOVFF  50E,F40
....................       } 
01F94:  BRA    1F9A
....................       // otherwise, position is unknown and will be assumed to be closing near 
....................       //    the closed endstop.  DAC level will be set as such to get a  
....................       //    consistent calibration 
....................       else 
....................       { 
....................          dac_write(DAC_LVL_CLOSING_NEAR_CLOSED); 
01F96:  MOVFF  510,F40
....................       } 
....................    } 
01F9A:  BRA    203E
....................     
....................    // valve closing 
....................    else if (IS_VLV_CLOSING) 
01F9C:  DECFSZ F8D,W
01F9E:  BRA    1FEA
....................    { 
....................       // valve is almost closed (or closed) and closing 
....................       if (global_valve_position < VLV_NEAR_CLOSED_RANGE_MAX) 
01FA0:  MOVF   xC2,W
01FA2:  MOVLB  5
01FA4:  SUBWF  x07,W
01FA6:  BNC   1FC0
01FA8:  BNZ   1FBA
01FAA:  MOVF   x06,W
01FAC:  MOVLB  0
01FAE:  SUBWF  xC1,W
01FB0:  BTFSS  FD8.0
01FB2:  BRA    1FB8
01FB4:  MOVLB  5
01FB6:  BRA    1FC0
01FB8:  MOVLB  5
....................       { 
....................          dac_write(DAC_LVL_CLOSING_NEAR_CLOSED); 
01FBA:  MOVFF  510,F40
....................       } 
01FBE:  BRA    1FE6
....................       // valve is almost open (or open) and closing 
....................       else if (global_valve_position > VLV_NEAR_OPENED_RANGE_MAX) 
01FC0:  MOVF   x09,W
01FC2:  MOVLB  0
01FC4:  SUBWF  xC2,W
01FC6:  BNC   1FE0
01FC8:  BNZ   1FDA
01FCA:  MOVF   xC1,W
01FCC:  MOVLB  5
01FCE:  SUBWF  x08,W
01FD0:  BTFSS  FD8.0
01FD2:  BRA    1FD8
01FD4:  MOVLB  0
01FD6:  BRA    1FE0
01FD8:  MOVLB  0
....................       { 
....................          dac_write(DAC_LVL_CLOSING_NEAR_OPENED); 
01FDA:  MOVFF  50E,F40
....................       } 
01FDE:  BRA    1FE4
....................       // valve is in the middle somewhere 
....................       else 
....................       { 
....................          dac_write(DAC_LVL_IN_MIDDLE); 
01FE0:  MOVFF  512,F40
01FE4:  MOVLB  5
....................       } 
....................    } 
01FE6:  BRA    2040
01FE8:  MOVLB  0
....................     
....................    // valve opening 
....................    else if (IS_VLV_OPENING) 
01FEA:  MOVF   F8D,W
01FEC:  SUBLW  02
01FEE:  BNZ   203A
....................    { 
....................       // valve is almost closed (or closed) and opening 
....................       if (global_valve_position < VLV_NEAR_CLOSED_RANGE_MAX) 
01FF0:  MOVF   xC2,W
01FF2:  MOVLB  5
01FF4:  SUBWF  x07,W
01FF6:  BNC   2010
01FF8:  BNZ   200A
01FFA:  MOVF   x06,W
01FFC:  MOVLB  0
01FFE:  SUBWF  xC1,W
02000:  BTFSS  FD8.0
02002:  BRA    2008
02004:  MOVLB  5
02006:  BRA    2010
02008:  MOVLB  5
....................       { 
....................          dac_write(DAC_LVL_OPENING_NEAR_CLOSED); 
0200A:  MOVFF  50C,F40
....................       } 
0200E:  BRA    2036
....................       // valve is almost open (or open) and opening 
....................       else if (global_valve_position > VLV_NEAR_OPENED_RANGE_MAX) 
02010:  MOVF   x09,W
02012:  MOVLB  0
02014:  SUBWF  xC2,W
02016:  BNC   2030
02018:  BNZ   202A
0201A:  MOVF   xC1,W
0201C:  MOVLB  5
0201E:  SUBWF  x08,W
02020:  BTFSS  FD8.0
02022:  BRA    2028
02024:  MOVLB  0
02026:  BRA    2030
02028:  MOVLB  0
....................       { 
....................          dac_write(DAC_LVL_OPENING_NEAR_OPENED); 
0202A:  MOVFF  50A,F40
....................       } 
0202E:  BRA    2034
....................       // valve is in the middle somewhere 
....................       else 
....................       { 
....................          dac_write(DAC_LVL_IN_MIDDLE); 
02030:  MOVFF  512,F40
02034:  MOVLB  5
....................       } 
....................    } 
02036:  BRA    2040
02038:  MOVLB  0
....................     
....................    // other cases (like if this accidentally gets called before valve is 
....................    //    actually moving, although it should get picked up by the initial  
....................    //    boost case 
....................    else 
....................    { 
....................       dac_write(DAC_LVL_IN_MIDDLE); 
0203A:  MOVFF  512,F40
0203E:  MOVLB  5
....................    } 
02040:  MOVLB  0
02042:  GOTO   21C0 (RETURN)
.................... } 
....................  
.................... int1 is_valve_position_valid(uint16_t value) 
.................... // returns true if valid range for valve 
.................... { 
....................    if (value > VLV_POSITION_OPENED) return FALSE; 
*
06750:  MOVLB  5
06752:  MOVF   x55,W
06754:  SUBLW  7F
06756:  BC    676A
06758:  XORLW  FF
0675A:  BNZ   6762
0675C:  MOVF   x54,W
0675E:  SUBLW  00
06760:  BC    676A
06762:  MOVLW  00
06764:  MOVWF  01
06766:  BRA    676E
06768:  BRA    676E
....................    else if (value < VLV_POSITION_CLOSED) return FALSE; 
....................    else return TRUE; 
0676A:  MOVLW  01
0676C:  MOVWF  01
0676E:  MOVLB  0
06770:  RETURN 0
.................... } 
....................  
.................... int1 is_valve_value_full_open_or_close(uint16_t value) 
.................... // return true if valve is either full open or vull close 
.................... { 
....................    if ((value == VLV_POSITION_OPENED) || (value == VLV_POSITION_CLOSED))  
*
070A8:  MOVLB  5
070AA:  MOVF   x54,F
070AC:  BNZ   70B4
070AE:  MOVF   x55,W
070B0:  SUBLW  80
070B2:  BZ    70BC
070B4:  MOVF   x54,F
070B6:  BNZ   70C4
070B8:  MOVF   x55,F
070BA:  BNZ   70C4
....................       return TRUE; 
070BC:  MOVLW  01
070BE:  MOVWF  01
070C0:  BRA    70C8
070C2:  BRA    70C8
....................    else return FALSE; 
070C4:  MOVLW  00
070C6:  MOVWF  01
070C8:  MOVLB  0
070CA:  RETURN 0
.................... } 
....................  
.................... #include "battery.h"                                                           
.................... // JG 
.................... uint16_t get_vbatt(int1 charge_state) 
*
04236:  MOVLB  5
04238:  CLRF   x6B
0423A:  CLRF   x6A
.................... { 
....................    /* Samples the V_EXT_REF to get the battery voltage 
....................     * and returns a uint16_t of the sum of 4 samples 
....................     * charge_state defines if you want the LTC3105 to be: 
....................     * 0 - original state 
....................     * 1 - not charging 
....................     */ 
....................                                                           
....................    uint8_t nn; 
....................    uint16_t v_batt_value = 0; 
....................    int1     tmp_RB3; 
....................    uint8_t  tmp_ccp2con; 
....................     
....................    // save state of RB3, which includes the LTC3105_CTRL line 
....................    tmp_ccp2con = CCP2CON;        
0423C:  MOVFF  F66,56D
....................     
....................    // save state of CCP2, which controls charging aggressiveness 
....................    // note that CCP2 will have control of the pin unless it is OFF 
....................    tmp_RB3 = LTC3105_CTRL_pinstate;  
04240:  BCF    x6C.0
04242:  BTFSC  F8A.3
04244:  BSF    x6C.0
....................     
....................    // turn on ADC 
....................    ADON = TRUE;          
04246:  BSF    FC2.0
....................     
....................    // set adc to VREF 
....................    set_adc_channel(V_EXT_REF); 
04248:  MOVLW  00
0424A:  MOVWF  01
0424C:  MOVF   FC2,W
0424E:  ANDLW  83
04250:  IORWF  01,W
04252:  MOVWF  FC2
....................     
....................    // alter the charge state if necessary 
....................    // charge state off 
....................    if (charge_state == 1) 
04254:  DECFSZ x68,W
04256:  BRA    425E
....................    { 
....................       setup_ccp2(CCP_OFF);    
04258:  MOVLW  F0
0425A:  ANDWF  F66,F
....................       output_low(LTC3105_CTRL); 
0425C:  BCF    F8A.3
....................    } 
....................     
....................    // sum up 4 samples from the adc 
....................    for (nn=0; nn<4; nn++) 
0425E:  CLRF   x69
04260:  MOVF   x69,W
04262:  SUBLW  03
04264:  BNC   4278
....................    { 
....................       v_batt_value += read_adc(); 
04266:  BSF    FC2.1
04268:  BTFSC  FC2.1
0426A:  BRA    4268
0426C:  MOVF   FC3,W
0426E:  ADDWF  x6A,F
04270:  MOVF   FC4,W
04272:  ADDWFC x6B,F
04274:  INCF   x69,F
04276:  BRA    4260
....................    } 
....................     
....................    // Now return charger to its previous state 
....................    LTC3105_CTRL_pinstate = tmp_RB3; 
04278:  BCF    F8A.3
0427A:  BTFSC  x6C.0
0427C:  BSF    F8A.3
....................    CCP2CON = tmp_ccp2con; 
0427E:  MOVFF  56D,F66
....................     
....................    // turn off adc 
....................    ADON = FALSE; 
04282:  BCF    FC2.0
....................     
....................    // return the voltage 
....................    return v_batt_value; 
04284:  MOVFF  56A,01
04288:  MOVFF  56B,02
0428C:  MOVLB  0
0428E:  RETURN 0
.................... } 
....................  
.................... uint16_t get_vbatt_ISR(int1 charge_state) 
*
023F4:  MOVLB  5
023F6:  CLRF   x96
023F8:  CLRF   x95
.................... { 
....................    /* Samples the V_EXT_REF to get the battery voltage 
....................     * and returns a uint16_t of the sum of 4 samples 
....................     * charge_state defines if you want the LTC3105 to be: 
....................     * 0 - original state 
....................     * 1 - not charging 
....................     */ 
....................      
....................    uint8_t nn; 
....................    uint16_t v_batt_value = 0; 
....................    int1     tmp_RB3; 
....................    uint8_t  tmp_ccp2con; 
....................     
....................    // save state of RB3, which includes the LTC3105_CTRL line 
....................    tmp_ccp2con = CCP2CON; 
023FA:  MOVFF  F66,598
....................     
....................    // save state of CCP2, which controls charging aggressiveness 
....................    // note that CCP2 will have control of the pin unless it is OFF 
....................    tmp_RB3 = LTC3105_CTRL_pinstate;  
023FE:  BCF    x97.0
02400:  BTFSC  F8A.3
02402:  BSF    x97.0
....................     
....................    // turn on ADC 
....................    ADON = TRUE;          
02404:  BSF    FC2.0
....................     
....................    // set adc to VREF 
....................    set_adc_channel(V_EXT_REF); 
02406:  MOVLW  00
02408:  MOVWF  01
0240A:  MOVF   FC2,W
0240C:  ANDLW  83
0240E:  IORWF  01,W
02410:  MOVWF  FC2
....................     
....................    // alter the charge state if necessary 
....................    // charge state off 
....................    if (charge_state == 1) 
02412:  DECFSZ x93,W
02414:  BRA    241C
....................    { 
....................       setup_ccp2(CCP_OFF);    
02416:  MOVLW  F0
02418:  ANDWF  F66,F
....................       output_low(LTC3105_CTRL); 
0241A:  BCF    F8A.3
....................    } 
....................     
....................    // sum up 4 samples from the adc 
....................    for (nn=0; nn<4; nn++) 
0241C:  CLRF   x94
0241E:  MOVF   x94,W
02420:  SUBLW  03
02422:  BNC   2436
....................    { 
....................       v_batt_value += read_adc(); 
02424:  BSF    FC2.1
02426:  BTFSC  FC2.1
02428:  BRA    2426
0242A:  MOVF   FC3,W
0242C:  ADDWF  x95,F
0242E:  MOVF   FC4,W
02430:  ADDWFC x96,F
02432:  INCF   x94,F
02434:  BRA    241E
....................    } 
....................     
....................    // Now return charger to its previous state 
....................    LTC3105_CTRL_pinstate = tmp_RB3; 
02436:  BCF    F8A.3
02438:  BTFSC  x97.0
0243A:  BSF    F8A.3
....................    CCP2CON = tmp_ccp2con; 
0243C:  MOVFF  598,F66
....................     
....................    // turn off adc 
....................    ADON = FALSE; 
02440:  BCF    FC2.0
....................     
....................    // return the voltage 
....................    return v_batt_value; 
02442:  MOVFF  595,01
02446:  MOVFF  596,02
0244A:  MOVLB  0
0244C:  RETURN 0
.................... } 
....................  
.................... uint16_t get_vgen(int1 charge_state) 
*
04290:  MOVLB  5
04292:  CLRF   x5A
04294:  CLRF   x59
.................... { 
....................    /* Samples the V_GEN to get the battery voltage 
....................     * and returns a uint16_t of the sum of 4 samples 
....................     * charge_state defines if you want the LTC3105 to be: 
....................     * 0 - original state 
....................     * 1 - not charging 
....................     */ 
....................      
....................    uint8_t nn; 
....................    uint16_t vgen_value = 0; 
....................    int1     tmp_RB3; 
....................    uint8_t  tmp_ccp2con; 
....................     
....................    // save state of RB3, which includes the LTC3105_CTRL line 
....................    tmp_ccp2con = CCP2CON; 
04296:  MOVFF  F66,55C
....................     
....................    // save state of CCP2, which controls charging aggressiveness 
....................    // note that CCP2 will have control of the pin unless it is OFF 
....................    tmp_RB3 = LTC3105_CTRL_pinstate;  
0429A:  BCF    x5B.0
0429C:  BTFSC  F8A.3
0429E:  BSF    x5B.0
....................     
....................    // turn on ADC 
....................    ADON = TRUE;          
042A0:  BSF    FC2.0
....................     
....................    // set adc to VREF 
....................    set_adc_channel(V_GEN); 
042A2:  MOVLW  30
042A4:  MOVWF  01
042A6:  MOVF   FC2,W
042A8:  ANDLW  83
042AA:  IORWF  01,W
042AC:  MOVWF  FC2
....................     
....................    // alter the charge state if necessary 
....................    // charge state off 
....................    if (charge_state == 1) 
042AE:  DECFSZ x57,W
042B0:  BRA    42B8
....................    { 
....................       setup_ccp2(CCP_OFF);    
042B2:  MOVLW  F0
042B4:  ANDWF  F66,F
....................       output_low(LTC3105_CTRL); 
042B6:  BCF    F8A.3
....................    } 
....................     
....................    // sum up 3 samples from the adc 
....................    for (nn=0; nn<3; nn++) 
042B8:  CLRF   x58
042BA:  MOVF   x58,W
042BC:  SUBLW  02
042BE:  BNC   42D2
....................    { 
....................       vgen_value += read_adc(); 
042C0:  BSF    FC2.1
042C2:  BTFSC  FC2.1
042C4:  BRA    42C2
042C6:  MOVF   FC3,W
042C8:  ADDWF  x59,F
042CA:  MOVF   FC4,W
042CC:  ADDWFC x5A,F
042CE:  INCF   x58,F
042D0:  BRA    42BA
....................    } 
....................     
....................    // Now return charger to its previous state 
....................    LTC3105_CTRL_pinstate = tmp_RB3; 
042D2:  BCF    F8A.3
042D4:  BTFSC  x5B.0
042D6:  BSF    F8A.3
....................    CCP2CON = tmp_ccp2con; 
042D8:  MOVFF  55C,F66
....................     
....................    // turn off adc 
....................    ADON = FALSE; 
042DC:  BCF    FC2.0
....................     
....................    // save vgen to global value 
....................    global_vgen = vgen_value; 
042DE:  MOVFF  55A,BD
042E2:  MOVFF  559,BC
....................     
....................    // return the voltage 
....................    return vgen_value; 
042E6:  MOVFF  559,01
042EA:  MOVFF  55A,02
042EE:  MOVLB  0
042F0:  RETURN 0
.................... } 
....................  
.................... uint16_t get_vgen_ISR(int1 charge_state) 
.................... { 
....................    /* Samples the V_GEN to get the battery voltage 
....................     * and returns a uint16_t of the sum of 4 samples 
....................     * charge_state defines if you want the LTC3105 to be: 
....................     * 0 - original state 
....................     * 1 - not charging 
....................     */ 
....................      
....................    uint8_t nn; 
....................    uint16_t vgen_value = 0; 
....................    int1     tmp_RB3; 
....................    uint8_t  tmp_ccp2con; 
....................     
....................    // save state of RB3, which includes the LTC3105_CTRL line 
....................    tmp_ccp2con = CCP2CON; 
....................     
....................    // save state of CCP2, which controls charging aggressiveness 
....................    // note that CCP2 will have control of the pin unless it is OFF 
....................    tmp_RB3 = LTC3105_CTRL_pinstate;  
....................     
....................    // turn on ADC 
....................    ADON = TRUE;          
....................     
....................    // set adc to VREF 
....................    set_adc_channel(V_GEN); 
....................     
....................    // alter the charge state if necessary 
....................    // charge state off 
....................    if (charge_state == 1) 
....................    { 
....................       setup_ccp2(CCP_OFF);    
....................       output_low(LTC3105_CTRL); 
....................    } 
....................     
....................    // sum up 3 samples from the adc 
....................    for (nn=0; nn<3; nn++) 
....................    { 
....................       vgen_value += read_adc(); 
....................    } 
....................     
....................    // Now return charger to its previous state 
....................    LTC3105_CTRL_pinstate = tmp_RB3; 
....................    CCP2CON = tmp_ccp2con; 
....................     
....................    // turn off adc 
....................    ADON = FALSE; 
....................     
....................    // save vgen to global value 
....................    global_vgen = vgen_value; 
....................     
....................    // return the voltage 
....................    return vgen_value; 
.................... } 
....................  
.................... uint16_t calc_vbatt_BCD(uint16_t vref_count) 
.................... { 
....................    /* Takes the voltage count as an input (summed from ADC) 
....................     * and outputs the battery integer and fractional as a single uint32_t 
....................     * It's output is BCD as follows: 
....................     * volts (.) tenths hundredths thousandths 
....................    */ 
....................    uint8_t volts, tenths, hundredths, thousandths; 
....................  
....................    uint32_t tempo_u32, frac_part; 
....................    uint16_t tempo_u16;   
....................     
....................    tempo_u32 = VAL32_FVR_BAT/vref_count;   // = 1 count in volts in 12.20 format 
*
04992:  MOVFF  558,569
04996:  MOVFF  557,568
0499A:  RCALL  479A
0499C:  MOVLW  9A
0499E:  MOVLB  5
049A0:  MOVWF  x6B
049A2:  MOVLW  99
049A4:  MOVWF  x6A
049A6:  MOVLW  19
049A8:  MOVWF  x69
049AA:  MOVLW  95
049AC:  MOVWF  x68
049AE:  MOVFF  03,56F
049B2:  MOVFF  02,56E
049B6:  MOVFF  01,56D
049BA:  MOVFF  00,56C
049BE:  MOVLB  0
049C0:  RCALL  47D0
049C2:  MOVFF  03,56B
049C6:  MOVFF  02,56A
049CA:  MOVFF  01,569
049CE:  MOVFF  00,568
049D2:  RCALL  492E
049D4:  MOVFF  03,560
049D8:  MOVFF  02,55F
049DC:  MOVFF  01,55E
049E0:  MOVFF  00,55D
049E4:  CLRF   19
049E6:  BTFSC  FF2.7
049E8:  BSF    19.7
049EA:  BCF    FF2.7
....................    tempo_u32 *= 1023;                        // bat voltage in 12.20 format 
049EC:  MOVFF  560,590
049F0:  MOVFF  55F,58F
049F4:  MOVFF  55E,58E
049F8:  MOVFF  55D,58D
049FC:  MOVLB  5
049FE:  CLRF   x94
04A00:  CLRF   x93
04A02:  MOVLW  03
04A04:  MOVWF  x92
04A06:  SETF   x91
04A08:  MOVLB  0
04A0A:  CALL   1A12
04A0E:  BTFSC  19.7
04A10:  BSF    FF2.7
04A12:  MOVFF  03,560
04A16:  MOVFF  02,55F
04A1A:  MOVFF  01,55E
04A1E:  MOVFF  00,55D
....................    tempo_u16 = (uint16_t)(tempo_u32 >> 8); 
04A22:  MOVFF  55F,566
04A26:  MOVFF  55E,565
....................                                              // bat voltage in 4.12 format 
....................    volts = (uint8_t)(tempo_u16 >> 12);       // 2 or 3.....    
04A2A:  MOVLB  5
04A2C:  SWAPF  x66,W
04A2E:  MOVWF  02
04A30:  MOVLW  0F
04A32:  ANDWF  02,F
04A34:  MOVFF  02,559
....................     
....................    frac_part = (uint32_t)(tempo_u16 & 0x0fff); 
04A38:  MOVF   x66,W
04A3A:  ANDLW  0F
04A3C:  MOVFF  565,561
04A40:  MOVWF  x62
04A42:  CLRF   x63
04A44:  CLRF   x64
04A46:  CLRF   19
04A48:  BTFSC  FF2.7
04A4A:  BSF    19.7
04A4C:  BCF    FF2.7
....................                                        // one count of frac_part is 1/4096 volt 
....................                                        // no rounding, full resolution 
....................    tempo_u32 = (frac_part * 1000);     // We ignore the mV rounding issue 
04A4E:  MOVFF  564,590
04A52:  MOVFF  563,58F
04A56:  MOVFF  562,58E
04A5A:  MOVFF  561,58D
04A5E:  CLRF   x94
04A60:  CLRF   x93
04A62:  MOVLW  03
04A64:  MOVWF  x92
04A66:  MOVLW  E8
04A68:  MOVWF  x91
04A6A:  MOVLB  0
04A6C:  CALL   1A12
04A70:  BTFSC  19.7
04A72:  BSF    FF2.7
04A74:  MOVFF  03,560
04A78:  MOVFF  02,55F
04A7C:  MOVFF  01,55E
04A80:  MOVFF  00,55D
....................                                        //  cuz battery measurement doesn't 
....................                                        //  support even mV resolution 
....................    tempo_u32 >>= 12; 
04A84:  MOVLB  5
04A86:  MOVFF  55E,55D
04A8A:  MOVFF  55F,55E
04A8E:  MOVFF  560,55F
04A92:  CLRF   x60
04A94:  RRCF   x60,F
04A96:  RRCF   x5F,F
04A98:  RRCF   x5E,F
04A9A:  RRCF   x5D,F
04A9C:  RRCF   x60,F
04A9E:  RRCF   x5F,F
04AA0:  RRCF   x5E,F
04AA2:  RRCF   x5D,F
04AA4:  RRCF   x60,F
04AA6:  RRCF   x5F,F
04AA8:  RRCF   x5E,F
04AAA:  RRCF   x5D,F
04AAC:  RRCF   x60,F
04AAE:  RRCF   x5F,F
04AB0:  RRCF   x5E,F
04AB2:  RRCF   x5D,F
04AB4:  MOVLW  0F
04AB6:  ANDWF  x60,F
....................    tempo_u16 = (uint16_t)(tempo_u32); 
04AB8:  MOVFF  55E,566
04ABC:  MOVFF  55D,565
....................    tenths = tempo_u16/100; 
04AC0:  MOVFF  566,576
04AC4:  MOVFF  565,575
04AC8:  CLRF   x78
04ACA:  MOVLW  64
04ACC:  MOVWF  x77
04ACE:  MOVLB  0
04AD0:  RCALL  4306
04AD2:  MOVFF  01,55A
....................    tempo_u16 -= (uint16_t)(tenths)*100; 
04AD6:  MOVLB  5
04AD8:  CLRF   x68
04ADA:  MOVFF  55A,567
04ADE:  MOVFF  568,56B
04AE2:  MOVFF  55A,56A
04AE6:  CLRF   x6D
04AE8:  MOVLW  64
04AEA:  MOVWF  x6C
04AEC:  MOVLB  0
04AEE:  RCALL  4970
04AF0:  MOVF   01,W
04AF2:  MOVLB  5
04AF4:  SUBWF  x65,F
04AF6:  MOVF   02,W
04AF8:  SUBWFB x66,F
....................    hundredths = tempo_u16/10; 
04AFA:  MOVFF  566,576
04AFE:  MOVFF  565,575
04B02:  CLRF   x78
04B04:  MOVLW  0A
04B06:  MOVWF  x77
04B08:  MOVLB  0
04B0A:  CALL   4306
04B0E:  MOVFF  01,55B
....................    thousandths = tempo_u16 % 10; 
04B12:  MOVFF  566,576
04B16:  MOVFF  565,575
04B1A:  MOVLB  5
04B1C:  CLRF   x78
04B1E:  MOVLW  0A
04B20:  MOVWF  x77
04B22:  MOVLB  0
04B24:  CALL   4306
04B28:  MOVFF  00,55C
04B2C:  MOVLB  5
....................  
....................    return ((uint16_t)(volts)*4096 + (uint16_t)(tenths)*256 + (uint16_t)(hundredths)*16 + (uint16_t)(thousandths)); 
04B2E:  CLRF   x68
04B30:  SWAPF  x59,W
04B32:  MOVWF  x68
04B34:  CLRF   x67
04B36:  MOVLW  F0
04B38:  ANDWF  x68,F
04B3A:  CLRF   x6A
04B3C:  MOVFF  55A,03
04B40:  MOVLW  00
04B42:  ADDWF  x67,F
04B44:  MOVF   x5A,W
04B46:  ADDWFC x68,F
04B48:  CLRF   x6A
04B4A:  RLCF   x5B,W
04B4C:  MOVWF  02
04B4E:  RLCF   x6A,W
04B50:  MOVWF  03
04B52:  RLCF   02,F
04B54:  RLCF   03,F
04B56:  RLCF   02,F
04B58:  RLCF   03,F
04B5A:  RLCF   02,F
04B5C:  RLCF   03,F
04B5E:  MOVLW  F0
04B60:  ANDWF  02,F
04B62:  MOVF   02,W
04B64:  ADDWF  x67,F
04B66:  MOVF   03,W
04B68:  ADDWFC x68,F
04B6A:  CLRF   03
04B6C:  MOVF   x5C,W
04B6E:  ADDWF  x67,W
04B70:  MOVWF  01
04B72:  MOVF   x68,W
04B74:  ADDWFC 03,F
04B76:  MOVFF  03,02
04B7A:  MOVLB  0
04B7C:  GOTO   4C4C (RETURN)
.................... } 
....................  
.................... uint16_t calc_vgen_BCD(uint16_t vref_count) 
.................... { 
....................    /* Takes the voltage count as an input (summed from ADC) 
....................     * and outputs the vgen integer and fractional as a single uint32_t 
....................     * It's output is BCD as follows: 
....................     * volts (.) tenths hundredths thousandths 
....................    */ 
....................    uint8_t volts, tenths, hundredths, thousandths; 
....................  
....................    uint32_t tempo_u32, frac_part; 
....................    uint16_t tempo_u16;   
....................  
....................    // First calculate a single count of the ADC in volts in 12.20 format? 
....................    tempo_u32 = VAL32_FVR_BAT/get_vbatt(0);   // = 1 count in volts in 12.20 format 
*
082EA:  MOVLB  5
082EC:  CLRF   x68
082EE:  MOVLB  0
082F0:  CALL   4236
082F4:  MOVFF  02,569
082F8:  MOVFF  01,568
082FC:  MOVLB  0
082FE:  CALL   479A
08302:  MOVLW  9A
08304:  MOVLB  5
08306:  MOVWF  x6B
08308:  MOVLW  99
0830A:  MOVWF  x6A
0830C:  MOVLW  19
0830E:  MOVWF  x69
08310:  MOVLW  95
08312:  MOVWF  x68
08314:  MOVFF  03,56F
08318:  MOVFF  02,56E
0831C:  MOVFF  01,56D
08320:  MOVFF  00,56C
08324:  MOVLB  0
08326:  CALL   47D0
0832A:  MOVFF  03,56B
0832E:  MOVFF  02,56A
08332:  MOVFF  01,569
08336:  MOVFF  00,568
0833A:  CALL   492E
0833E:  MOVFF  03,561
08342:  MOVFF  02,560
08346:  MOVFF  01,55F
0834A:  MOVFF  00,55E
0834E:  CLRF   19
08350:  BTFSC  FF2.7
08352:  BSF    19.7
08354:  BCF    FF2.7
....................    tempo_u32 *= vref_count;                  // vgen in 12.20 format 
08356:  MOVFF  561,590
0835A:  MOVFF  560,58F
0835E:  MOVFF  55F,58E
08362:  MOVFF  55E,58D
08366:  MOVLB  5
08368:  CLRF   x94
0836A:  CLRF   x93
0836C:  MOVFF  559,592
08370:  MOVFF  558,591
08374:  MOVLB  0
08376:  CALL   1A12
0837A:  BTFSC  19.7
0837C:  BSF    FF2.7
0837E:  MOVFF  03,561
08382:  MOVFF  02,560
08386:  MOVFF  01,55F
0838A:  MOVFF  00,55E
....................    tempo_u16 = (uint16_t)(tempo_u32 >> 8); 
0838E:  MOVFF  560,567
08392:  MOVFF  55F,566
....................                                              // bat voltage in 4.12 format 
....................    volts = (uint8_t)(tempo_u16 >> 12);       // 2 or 3.....    
08396:  MOVLB  5
08398:  SWAPF  x67,W
0839A:  MOVWF  02
0839C:  MOVLW  0F
0839E:  ANDWF  02,F
083A0:  MOVFF  02,55A
....................     
....................    frac_part = (uint32_t)(tempo_u16 & 0x0fff); 
083A4:  MOVF   x67,W
083A6:  ANDLW  0F
083A8:  MOVFF  566,562
083AC:  MOVWF  x63
083AE:  CLRF   x64
083B0:  CLRF   x65
083B2:  CLRF   19
083B4:  BTFSC  FF2.7
083B6:  BSF    19.7
083B8:  BCF    FF2.7
....................                                        // one count of frac_part is 1/4096 volt 
....................                                        // no rounding, full resolution 
....................    tempo_u32 = (frac_part * 1000);     // We ignore the mV rounding issue 
083BA:  MOVFF  565,590
083BE:  MOVFF  564,58F
083C2:  MOVFF  563,58E
083C6:  MOVFF  562,58D
083CA:  CLRF   x94
083CC:  CLRF   x93
083CE:  MOVLW  03
083D0:  MOVWF  x92
083D2:  MOVLW  E8
083D4:  MOVWF  x91
083D6:  MOVLB  0
083D8:  CALL   1A12
083DC:  BTFSC  19.7
083DE:  BSF    FF2.7
083E0:  MOVFF  03,561
083E4:  MOVFF  02,560
083E8:  MOVFF  01,55F
083EC:  MOVFF  00,55E
....................                                        //  cuz battery measurement doesn't 
....................                                        //  support even mV resolution 
....................    tempo_u32 >>= 12; 
083F0:  MOVLB  5
083F2:  MOVFF  55F,55E
083F6:  MOVFF  560,55F
083FA:  MOVFF  561,560
083FE:  CLRF   x61
08400:  RRCF   x61,F
08402:  RRCF   x60,F
08404:  RRCF   x5F,F
08406:  RRCF   x5E,F
08408:  RRCF   x61,F
0840A:  RRCF   x60,F
0840C:  RRCF   x5F,F
0840E:  RRCF   x5E,F
08410:  RRCF   x61,F
08412:  RRCF   x60,F
08414:  RRCF   x5F,F
08416:  RRCF   x5E,F
08418:  RRCF   x61,F
0841A:  RRCF   x60,F
0841C:  RRCF   x5F,F
0841E:  RRCF   x5E,F
08420:  MOVLW  0F
08422:  ANDWF  x61,F
....................    tempo_u16 = (uint16_t)(tempo_u32); 
08424:  MOVFF  55F,567
08428:  MOVFF  55E,566
....................    tenths = tempo_u16/100; 
0842C:  MOVFF  567,576
08430:  MOVFF  566,575
08434:  CLRF   x78
08436:  MOVLW  64
08438:  MOVWF  x77
0843A:  MOVLB  0
0843C:  CALL   4306
08440:  MOVFF  01,55B
....................    tempo_u16 -= (uint16_t)(tenths)*100; 
08444:  MOVLB  5
08446:  CLRF   x69
08448:  MOVFF  55B,568
0844C:  MOVFF  569,56B
08450:  MOVFF  55B,56A
08454:  CLRF   x6D
08456:  MOVLW  64
08458:  MOVWF  x6C
0845A:  MOVLB  0
0845C:  CALL   4970
08460:  MOVF   01,W
08462:  MOVLB  5
08464:  SUBWF  x66,F
08466:  MOVF   02,W
08468:  SUBWFB x67,F
....................    hundredths = tempo_u16/10; 
0846A:  MOVFF  567,576
0846E:  MOVFF  566,575
08472:  CLRF   x78
08474:  MOVLW  0A
08476:  MOVWF  x77
08478:  MOVLB  0
0847A:  CALL   4306
0847E:  MOVFF  01,55C
....................    thousandths = tempo_u16 % 10; 
08482:  MOVFF  567,576
08486:  MOVFF  566,575
0848A:  MOVLB  5
0848C:  CLRF   x78
0848E:  MOVLW  0A
08490:  MOVWF  x77
08492:  MOVLB  0
08494:  CALL   4306
08498:  MOVFF  00,55D
0849C:  MOVLB  5
....................  
....................    return ((uint16_t)(volts)*4096 + (uint16_t)(tenths)*256 + (uint16_t)(hundredths)*16 + (uint16_t)(thousandths)); 
0849E:  CLRF   x69
084A0:  SWAPF  x5A,W
084A2:  MOVWF  x69
084A4:  CLRF   x68
084A6:  MOVLW  F0
084A8:  ANDWF  x69,F
084AA:  CLRF   x6B
084AC:  MOVFF  55B,03
084B0:  MOVLW  00
084B2:  ADDWF  x68,F
084B4:  MOVF   x5B,W
084B6:  ADDWFC x69,F
084B8:  CLRF   x6B
084BA:  RLCF   x5C,W
084BC:  MOVWF  02
084BE:  RLCF   x6B,W
084C0:  MOVWF  03
084C2:  RLCF   02,F
084C4:  RLCF   03,F
084C6:  RLCF   02,F
084C8:  RLCF   03,F
084CA:  RLCF   02,F
084CC:  RLCF   03,F
084CE:  MOVLW  F0
084D0:  ANDWF  02,F
084D2:  MOVF   02,W
084D4:  ADDWF  x68,F
084D6:  MOVF   03,W
084D8:  ADDWFC x69,F
084DA:  CLRF   03
084DC:  MOVF   x5D,W
084DE:  ADDWF  x68,W
084E0:  MOVWF  01
084E2:  MOVF   x69,W
084E4:  ADDWFC 03,F
084E6:  MOVFF  03,02
084EA:  MOVLB  0
084EC:  GOTO   854E (RETURN)
.................... } 
....................  
.................... uint32_t calc_vbatt(uint16_t vref_count) 
.................... { 
....................    /* Takes the voltage count as an input (summed from ADC) 
....................     * and outputs the battery integer and fractional as a single uint32_t 
....................     * It's output is (in binary) 00000000IIIIIIIIFFFFFFFFFFFFFFFF 
....................     * Where the first 8 bits are 0, the next 8 represent the integer 
....................     * part of the battery, and the next 16 are the fractional part 
....................     */ 
....................    uint32_t tempo_u32, frac_part; 
....................    uint16_t tempo_u16; 
....................     
....................    uint16_t    bat_frac_part;    // in units of .1mV      
....................    uint8_t     bat_int_part; 
....................     
....................    tempo_u32 = VAL32_FVR_BAT/vref_count;   // = 1 count in volts in 12.20 format 
....................    tempo_u32 *= 1023;                        // bat voltage in 12.20 format 
....................    tempo_u16 = (uint16_t)(tempo_u32 >> 8); 
....................                                              // bat voltage in 4.12 format 
....................                                               
....................    //This stores the integer part shifted into the final result                                     
....................    bat_int_part = (uint8_t)(tempo_u16 >> 12);      // 2 or 3..... 
....................    frac_part = (uint32_t)(tempo_u16 & 0x0fff); 
....................                                        // one count of frac_part is 1/4096 volt 
....................    tempo_u32 = (frac_part * 10000);    // 
....................    tempo_u32 >>= 12; // divide by 4096. temp32 now = frac part (0 to 9999) 
....................    bat_frac_part = (uint16_t)(tempo_u32); 
....................     
....................    return ((((uint32_t)bat_int_part) << 16) | (bat_frac_part)); 
....................    //return (uint32_t)bat_frac_part; 
.................... } 
....................  
.................... void check_and_deal_with_battery(void) 
.................... // checks the battery voltage (charging and not charging) and decides to turn on 
.................... // charger/off charger send a warning, or send a warning and shutdown. 
.................... { 
....................    uint16_t batt_chrg, batt_no_chrg; 
....................     
....................    // if the valve is not moving (otherwise, abort) 
....................    if (IS_VLV_COASTING) 
*
09270:  MOVF   F8D,F
09272:  BTFSS  FD8.2
09274:  BRA    9386
....................    { 
....................       // grab a fresh battery reading 
....................       batt_chrg = get_vbatt(0); 
09276:  MOVLB  5
09278:  CLRF   x68
0927A:  MOVLB  0
0927C:  CALL   4236
09280:  MOVFF  02,54C
09284:  MOVFF  01,54B
....................       batt_no_chrg = get_vbatt(1); 
09288:  MOVLW  01
0928A:  MOVLB  5
0928C:  MOVWF  x68
0928E:  MOVLB  0
09290:  CALL   4236
09294:  MOVFF  02,54E
09298:  MOVFF  01,54D
....................        
....................       // if the battery is dead and system needs to be shutdown 
....................       if (batt_no_chrg > BATTERY_DEAD) 
0929C:  MOVLB  5
0929E:  MOVF   x4E,W
092A0:  SUBLW  05
092A2:  BC    9318
092A4:  XORLW  FF
092A6:  BNZ   92AE
092A8:  MOVF   x4D,W
092AA:  SUBLW  65
092AC:  BC    9318
....................       { 
....................          global_control_loop_mechanism = BRAKE_AND_CHARGE_START; 
092AE:  MOVLB  0
092B0:  CLRF   xC0
....................          // set the error bitfield and message 
....................          global_error_message_bitfield |= ERR_MSG_BATT_DEAD_SLEEP; 
092B2:  MOVLB  4
092B4:  BSF    xF9.0
....................          PUSH_MESSAGE_QUEUE_MACRO(MSG_MOTE_ERROR_MSG); 
092B6:  BCF    F7A.1
092B8:  MOVLW  A0
092BA:  MOVLB  5
092BC:  MOVWF  x54
092BE:  MOVLB  0
092C0:  CALL   4FF4
092C4:  BSF    F7A.1
....................          // set the shutdown message and schedule a shutdown 
....................          global_shutdown_cause = ERR_BATT_DEAD_SLEEP;  
092C6:  MOVLW  0C
092C8:  MOVWF  4D
....................          PUSH_PRIORITY_QUEUE(OPEN_VALVE_UNKNOWN_STATE);   
092CA:  MOVLW  3E
092CC:  MOVLB  5
092CE:  MOVWF  x52
092D0:  MOVLB  0
092D2:  CALL   46CA
....................          PUSH_TIME_QUEUE(global_rtc_time + 10, SHUTDOWN_SYSTEM);   
092D6:  MOVLW  0A
092D8:  ADDWF  x85,W
092DA:  MOVLB  5
092DC:  MOVWF  x4F
092DE:  MOVLW  00
092E0:  MOVLB  0
092E2:  ADDWFC x86,W
092E4:  MOVLB  5
092E6:  MOVWF  x50
092E8:  MOVLW  00
092EA:  MOVLB  0
092EC:  ADDWFC x87,W
092EE:  MOVLB  5
092F0:  MOVWF  x51
092F2:  MOVLW  00
092F4:  MOVLB  0
092F6:  ADDWFC x88,W
092F8:  MOVLB  5
092FA:  MOVWF  x52
092FC:  MOVWF  x59
092FE:  MOVFF  551,558
09302:  MOVFF  550,557
09306:  MOVFF  54F,556
0930A:  MOVLW  F1
0930C:  MOVWF  x5A
0930E:  MOVLB  0
09310:  CALL   4422
....................       } 
09314:  BRA    9386
09316:  MOVLB  5
....................       // if the battery is almost dead and the manager needs a warning 
....................       else if (batt_no_chrg > BATTERY_WARN) 
09318:  MOVF   x4E,W
0931A:  SUBLW  05
0931C:  BC    9344
0931E:  XORLW  FF
09320:  BNZ   9328
09322:  MOVF   x4D,W
09324:  SUBLW  30
09326:  BC    9344
....................       { 
....................          global_control_loop_mechanism = BRAKE_AND_CHARGE_START; 
09328:  MOVLB  0
0932A:  CLRF   xC0
....................          // set the error bitfield and message 
....................          global_error_message_bitfield |= ERR_MSG_BATT_LOW_WARN; 
0932C:  MOVLB  4
0932E:  BSF    xF8.7
....................          PUSH_MESSAGE_QUEUE_MACRO(MSG_MOTE_ERROR_MSG); 
09330:  BCF    F7A.1
09332:  MOVLW  A0
09334:  MOVLB  5
09336:  MOVWF  x54
09338:  MOVLB  0
0933A:  CALL   4FF4
0933E:  BSF    F7A.1
....................       } 
09340:  BRA    9386
09342:  MOVLB  5
....................       // if the battery charging needs to be turned off (is in brake + charge control) 
....................       else if ((batt_chrg < BATTERY_STOP_CHARGING) &&                              \ 
....................          (global_control_loop_mechanism == BRAKE_AND_CHARGE)) 
09344:  MOVF   x4C,W
09346:  SUBLW  05
09348:  BNC   9366
0934A:  BNZ   9352
0934C:  MOVF   x4B,W
0934E:  SUBLW  79
09350:  BNC   9366
09352:  MOVLB  0
09354:  DECFSZ xC0,W
09356:  BRA    935A
09358:  BRA    935E
0935A:  MOVLB  5
0935C:  BRA    9366
....................       { 
....................          global_control_loop_mechanism = BRAKE_ONLY; 
0935E:  MOVLW  02
09360:  MOVWF  xC0
....................       } 
09362:  BRA    9386
09364:  MOVLB  5
....................       // if the battery charging needs to be turned on (is in brake only control) 
....................       else if ((batt_no_chrg > BATTERY_START_CHARGING) &&                     \ 
....................          (global_control_loop_mechanism == BRAKE_ONLY)) 
09366:  MOVF   x4E,W
09368:  SUBLW  04
0936A:  BC    9388
0936C:  XORLW  FF
0936E:  BNZ   9376
09370:  MOVF   x4D,W
09372:  SUBLW  D2
09374:  BC    9388
09376:  MOVLB  0
09378:  MOVF   xC0,W
0937A:  SUBLW  02
0937C:  BTFSC  FD8.2
0937E:  BRA    9384
09380:  MOVLB  5
09382:  BRA    9388
....................       { 
....................          global_control_loop_mechanism = BRAKE_AND_CHARGE_START; 
09384:  CLRF   xC0
09386:  MOVLB  5
....................       } 
....................    } 
09388:  MOVLB  0
0938A:  GOTO   AFD0 (RETURN)
.................... } 
....................           
....................  
....................  
....................  
....................  
.................... #include "stacks_queues.h"   
.................... void clear_priority_queue() 
.................... { 
....................    uint8_t n; 
....................     
....................    for (n = 0; n < MAX_PRIORITY_QUEUE_ITEMS; n++) 
*
04142:  MOVLB  5
04144:  CLRF   x4B
04146:  MOVF   x4B,W
04148:  SUBLW  13
0414A:  BNC   4160
....................    { 
....................       global_priority_queue[n] = EMPTY_PRIORITY_QUEUE; 
0414C:  CLRF   03
0414E:  MOVF   x4B,W
04150:  ADDLW  6E
04152:  MOVWF  FE9
04154:  MOVLW  03
04156:  ADDWFC 03,W
04158:  MOVWF  FEA
0415A:  CLRF   FEF
0415C:  INCF   x4B,F
0415E:  BRA    4146
....................    } 
04160:  MOVLB  0
04162:  GOTO   A224 (RETURN)
.................... } 
....................  
.................... uint8_t pop_priority_queue() 
.................... // Checks the priority queue and returns the current item to execute 
.................... { 
....................    uint8_t priority_queue_command_to_execute; 
....................     
....................    //no items in the queue (current location is 0-1) 
....................    if (global_current_priority_queue_location == 255) 
*
05BDA:  MOVLB  3
05BDC:  INCFSZ x82,W
05BDE:  BRA    5BE8
....................    { 
....................       return EMPTY_PRIORITY_QUEUE; 
05BE0:  MOVLW  00
05BE2:  MOVWF  01
05BE4:  BRA    5C12
....................    } 
05BE6:  BRA    5C12
....................    else 
....................    { 
....................       //save the current command to execute 
....................       priority_queue_command_to_execute = global_priority_queue[global_current_priority_queue_location]; 
05BE8:  CLRF   03
05BEA:  MOVF   x82,W
05BEC:  ADDLW  6E
05BEE:  MOVWF  FE9
05BF0:  MOVLW  03
05BF2:  ADDWFC 03,W
05BF4:  MOVWF  FEA
05BF6:  MOVFF  FEF,54B
....................       //erase the current command and decrement the current queue location 
....................       global_priority_queue[global_current_priority_queue_location] = 0; 
05BFA:  CLRF   03
05BFC:  MOVF   x82,W
05BFE:  ADDLW  6E
05C00:  MOVWF  FE9
05C02:  MOVLW  03
05C04:  ADDWFC 03,W
05C06:  MOVWF  FEA
05C08:  CLRF   FEF
....................       global_current_priority_queue_location--; 
05C0A:  DECF   x82,F
....................       //return the command to execute 
....................       return priority_queue_command_to_execute; 
05C0C:  MOVFF  54B,01
05C10:  MOVLB  3
....................    } 
05C12:  MOVLB  0
05C14:  GOTO   A3E2 (RETURN)
.................... } 
....................  
.................... int1 push_priority_queue(uint8_t new_priority_queue_item) 
.................... // pushes a new item into the priority queue and sorts it. 
.................... // returns 1 if everything is good, 0 if queue is full 
.................... { 
....................    uint8_t n; 
....................    
....................    //if queue is full, return 0 
....................    if (global_current_priority_queue_location == (MAX_PRIORITY_QUEUE_ITEMS - 1)) 
*
046CA:  MOVLB  3
046CC:  MOVF   x82,W
046CE:  SUBLW  13
046D0:  BNZ   46D8
....................    { 
....................       return 0; 
046D2:  MOVLW  00
046D4:  MOVWF  01
046D6:  BRA    478C
....................    } 
....................     
....................    //increment the queue location and 
....................    //set the new item at the top of the queue (will be sorted in a sec) 
....................    global_current_priority_queue_location++; 
046D8:  INCF   x82,F
....................    global_priority_queue[global_current_priority_queue_location] = new_priority_queue_item; 
046DA:  CLRF   03
046DC:  MOVF   x82,W
046DE:  ADDLW  6E
046E0:  MOVWF  FE9
046E2:  MOVLW  03
046E4:  ADDWFC 03,W
046E6:  MOVWF  FEA
046E8:  MOVFF  552,FEF
....................     
....................    //starting at the new current queue location, sort through the queue 
....................    //until the new item is in the right place 
....................    for (n = global_current_priority_queue_location; n > 0; n--) 
046EC:  MOVFF  382,553
046F0:  MOVLB  5
046F2:  MOVF   x53,F
046F4:  BZ    4786
....................    { 
....................       //if queue items are not sorted properly 
....................       if (global_priority_queue[n] > global_priority_queue[n-1]) 
046F6:  CLRF   03
046F8:  MOVF   x53,W
046FA:  ADDLW  6E
046FC:  MOVWF  FE9
046FE:  MOVLW  03
04700:  ADDWFC 03,W
04702:  MOVWF  FEA
04704:  MOVFF  FEF,554
04708:  MOVLW  01
0470A:  SUBWF  x53,W
0470C:  CLRF   03
0470E:  ADDLW  6E
04710:  MOVWF  FE9
04712:  MOVLW  03
04714:  ADDWFC 03,W
04716:  MOVWF  FEA
04718:  MOVF   FEF,W
0471A:  SUBWF  x54,W
0471C:  BZ    4778
0471E:  BNC   4778
....................       { 
....................          //do a swap reusing new queue item variable as a temp 
....................          new_priority_queue_item = global_priority_queue[n]; 
04720:  CLRF   03
04722:  MOVF   x53,W
04724:  ADDLW  6E
04726:  MOVWF  FE9
04728:  MOVLW  03
0472A:  ADDWFC 03,W
0472C:  MOVWF  FEA
0472E:  MOVFF  FEF,552
....................          global_priority_queue[n] = global_priority_queue[n-1]; 
04732:  CLRF   03
04734:  MOVF   x53,W
04736:  ADDLW  6E
04738:  MOVWF  01
0473A:  MOVLW  03
0473C:  ADDWFC 03,F
0473E:  MOVFF  03,555
04742:  MOVLW  01
04744:  SUBWF  x53,W
04746:  CLRF   03
04748:  ADDLW  6E
0474A:  MOVWF  FE9
0474C:  MOVLW  03
0474E:  ADDWFC 03,W
04750:  MOVWF  FEA
04752:  MOVFF  FEF,556
04756:  MOVFF  555,FEA
0475A:  MOVFF  01,FE9
0475E:  MOVFF  556,FEF
....................          global_priority_queue[n-1] = new_priority_queue_item; 
04762:  MOVLW  01
04764:  SUBWF  x53,W
04766:  CLRF   03
04768:  ADDLW  6E
0476A:  MOVWF  FE9
0476C:  MOVLW  03
0476E:  ADDWFC 03,W
04770:  MOVWF  FEA
04772:  MOVFF  552,FEF
....................       } 
04776:  BRA    4782
....................       //item is in the proper place (assuming queue always sorted properly) 
....................       else 
....................       { 
....................          return 1; 
04778:  MOVLW  01
0477A:  MOVWF  01
0477C:  MOVLB  3
0477E:  BRA    478C
04780:  MOVLB  5
....................       } 
04782:  DECF   x53,F
04784:  BRA    46F2
....................    } 
....................    return 1; 
04786:  MOVLW  01
04788:  MOVWF  01
0478A:  MOVLB  3
0478C:  MOVLB  0
0478E:  RETURN 0
.................... } 
....................  
.................... void push_priority_queue_ISR(uint8_t new_priority_queue_item) 
.................... // pushes a new item into the priority queue and sorts it. 
.................... // returns 1 if everything is good, 0 if queue is full 
.................... { 
....................    uint8_t n; 
....................    
....................    //if queue is full, return 0 
....................    if (global_current_priority_queue_location == (MAX_PRIORITY_QUEUE_ITEMS - 1)) 
*
0082A:  MOVLB  3
0082C:  MOVF   x82,W
0082E:  SUBLW  13
00830:  BNZ   0834
....................    { 
....................       return; 
00832:  BRA    08D8
....................    } 
....................     
....................    //increment the queue location and 
....................    //set the new item at the top of the queue (will be sorted in a sec) 
....................    global_current_priority_queue_location++; 
00834:  INCF   x82,F
....................    global_priority_queue[global_current_priority_queue_location] = new_priority_queue_item; 
00836:  CLRF   03
00838:  MOVF   x82,W
0083A:  ADDLW  6E
0083C:  MOVWF  FE9
0083E:  MOVLW  03
00840:  ADDWFC 03,W
00842:  MOVWF  FEA
00844:  MOVFF  5B7,FEF
....................     
....................    //starting at the new current queue location, sort through the queue 
....................    //until the new item is in the right place 
....................    for (n = global_current_priority_queue_location; n > 0; n--) 
00848:  MOVFF  382,5B8
0084C:  MOVLB  5
0084E:  MOVF   xB8,F
00850:  BZ    08D6
....................    { 
....................       //if queue items are not sorted properly 
....................       if (global_priority_queue[n] > global_priority_queue[n-1]) 
00852:  CLRF   03
00854:  MOVF   xB8,W
00856:  ADDLW  6E
00858:  MOVWF  FE9
0085A:  MOVLW  03
0085C:  ADDWFC 03,W
0085E:  MOVWF  FEA
00860:  MOVFF  FEF,5B9
00864:  MOVLW  01
00866:  SUBWF  xB8,W
00868:  CLRF   03
0086A:  ADDLW  6E
0086C:  MOVWF  FE9
0086E:  MOVLW  03
00870:  ADDWFC 03,W
00872:  MOVWF  FEA
00874:  MOVF   FEF,W
00876:  SUBWF  xB9,W
00878:  BZ    08D2
0087A:  BNC   08D2
....................       { 
....................          //do a swap reusing new queue item variable as a temp 
....................          new_priority_queue_item = global_priority_queue[n]; 
0087C:  CLRF   03
0087E:  MOVF   xB8,W
00880:  ADDLW  6E
00882:  MOVWF  FE9
00884:  MOVLW  03
00886:  ADDWFC 03,W
00888:  MOVWF  FEA
0088A:  MOVFF  FEF,5B7
....................          global_priority_queue[n] = global_priority_queue[n-1]; 
0088E:  CLRF   03
00890:  MOVF   xB8,W
00892:  ADDLW  6E
00894:  MOVWF  01
00896:  MOVLW  03
00898:  ADDWFC 03,F
0089A:  MOVFF  03,5BA
0089E:  MOVLW  01
008A0:  SUBWF  xB8,W
008A2:  CLRF   03
008A4:  ADDLW  6E
008A6:  MOVWF  FE9
008A8:  MOVLW  03
008AA:  ADDWFC 03,W
008AC:  MOVWF  FEA
008AE:  MOVFF  FEF,5BB
008B2:  MOVFF  5BA,FEA
008B6:  MOVFF  01,FE9
008BA:  MOVFF  5BB,FEF
....................          global_priority_queue[n-1] = new_priority_queue_item; 
008BE:  MOVLW  01
008C0:  SUBWF  xB8,W
008C2:  CLRF   03
008C4:  ADDLW  6E
008C6:  MOVWF  FE9
008C8:  MOVLW  03
008CA:  ADDWFC 03,W
008CC:  MOVWF  FEA
008CE:  MOVFF  5B7,FEF
....................       } 
008D2:  DECF   xB8,F
008D4:  BRA    084E
008D6:  MOVLB  3
....................    } 
....................    return;  
008D8:  MOVLB  0
008DA:  RETURN 0
.................... } 
....................  
.................... void clear_time_queue() 
.................... { 
....................    uint8_t n; 
....................     
....................    for (n = 0; n < MAX_TIME_QUEUE_ITEMS; n++) 
*
04166:  MOVLB  5
04168:  CLRF   x4B
0416A:  MOVF   x4B,W
0416C:  SUBLW  04
0416E:  BNC   41C0
....................    { 
....................       global_time_queue[n].pq_priority = 0; 
04170:  MOVF   x4B,W
04172:  MULLW  05
04174:  MOVF   FF3,W
04176:  CLRF   x4D
04178:  MOVWF  x4C
0417A:  MOVLW  04
0417C:  ADDWF  x4C,W
0417E:  MOVWF  01
04180:  MOVLW  00
04182:  ADDWFC x4D,W
04184:  MOVWF  03
04186:  MOVF   01,W
04188:  ADDLW  83
0418A:  MOVWF  FE9
0418C:  MOVLW  03
0418E:  ADDWFC 03,W
04190:  MOVWF  FEA
04192:  CLRF   FEF
....................       global_time_queue[n].time_to_execute = 0; 
04194:  MOVF   x4B,W
04196:  MULLW  05
04198:  MOVF   FF3,W
0419A:  CLRF   x4D
0419C:  MOVWF  x4C
0419E:  MOVLW  83
041A0:  ADDWF  x4C,W
041A2:  MOVWF  FE9
041A4:  MOVLW  03
041A6:  ADDWFC x4D,W
041A8:  MOVWF  FEA
041AA:  MOVF   FEE,F
041AC:  MOVF   FEE,F
041AE:  CLRF   FEC
041B0:  MOVF   FED,F
041B2:  CLRF   FEF
041B4:  MOVF   FED,F
041B6:  CLRF   FEF
041B8:  MOVF   FED,F
041BA:  CLRF   FEF
041BC:  INCF   x4B,F
041BE:  BRA    416A
....................    } 
041C0:  MOVLB  0
041C2:  GOTO   A228 (RETURN)
.................... } 
....................  
.................... int1 pop_time_queue() 
.................... // Checks the time queue and sends the item to execute to the priority queue 
.................... { 
....................    struct TimeQueueItem time_queue_command_to_execute; 
....................     
....................    //no items in the queue (current location is 0-1) 
....................    if (global_current_time_queue_location == (0-1)) 
....................    { 
....................       return EMPTY_TIME_QUEUE; 
....................    } 
....................    else 
....................    { 
....................       //save the current command to execute 
....................       time_queue_command_to_execute.pq_priority = global_time_queue[global_current_time_queue_location].pq_priority; 
....................        
....................       //erase the current command and decrement the current queue location 
....................       global_time_queue[global_current_time_queue_location].pq_priority = 0; 
....................       global_time_queue[global_current_time_queue_location].time_to_execute = 0; 
....................       global_current_time_queue_location--; 
....................        
....................       //send queue item to the priority queue and return the result from adding it to the PQ 
....................       return push_priority_queue(time_queue_command_to_execute.pq_priority); 
....................    } 
.................... } 
....................  
.................... void pop_time_queue_ISR() 
.................... // Checks the time queue and sends the item to execute to the priority queue 
.................... { 
....................    uint8_t priority; 
....................     
....................    //no items in the queue (current location is 0-1) 
....................    if (global_current_time_queue_location == 255) 
*
021CC:  MOVLB  3
021CE:  INCFSZ x9C,W
021D0:  BRA    21D6
....................    { 
....................       return; 
021D2:  BRA    226E
....................    } 
021D4:  BRA    226E
....................    else 
....................    { 
....................       //save the current command to execute 
....................       priority = global_time_queue[global_current_time_queue_location].pq_priority; 
021D6:  MOVF   x9C,W
021D8:  MULLW  05
021DA:  MOVF   FF3,W
021DC:  MOVLB  5
021DE:  CLRF   x85
021E0:  MOVWF  x84
021E2:  MOVLW  04
021E4:  ADDWF  x84,W
021E6:  MOVWF  01
021E8:  MOVLW  00
021EA:  ADDWFC x85,W
021EC:  MOVWF  03
021EE:  MOVF   01,W
021F0:  ADDLW  83
021F2:  MOVWF  FE9
021F4:  MOVLW  03
021F6:  ADDWFC 03,W
021F8:  MOVWF  FEA
021FA:  MOVFF  FEF,583
....................        
....................       //erase the current command and decrement the current queue location 
....................       global_time_queue[global_current_time_queue_location].pq_priority = 0; 
021FE:  MOVLB  3
02200:  MOVF   x9C,W
02202:  MULLW  05
02204:  MOVF   FF3,W
02206:  MOVLB  5
02208:  CLRF   x85
0220A:  MOVWF  x84
0220C:  MOVLW  04
0220E:  ADDWF  x84,W
02210:  MOVWF  01
02212:  MOVLW  00
02214:  ADDWFC x85,W
02216:  MOVWF  03
02218:  MOVF   01,W
0221A:  ADDLW  83
0221C:  MOVWF  FE9
0221E:  MOVLW  03
02220:  ADDWFC 03,W
02222:  MOVWF  FEA
02224:  CLRF   FEF
....................       global_time_queue[global_current_time_queue_location].time_to_execute = 0; 
02226:  MOVLB  3
02228:  MOVF   x9C,W
0222A:  MULLW  05
0222C:  MOVF   FF3,W
0222E:  MOVLB  5
02230:  CLRF   x85
02232:  MOVWF  x84
02234:  MOVLW  83
02236:  ADDWF  x84,W
02238:  MOVWF  FE9
0223A:  MOVLW  03
0223C:  ADDWFC x85,W
0223E:  MOVWF  FEA
02240:  MOVF   FEE,F
02242:  MOVF   FEE,F
02244:  CLRF   FEC
02246:  MOVF   FED,F
02248:  CLRF   FEF
0224A:  MOVF   FED,F
0224C:  CLRF   FEF
0224E:  MOVF   FED,F
02250:  CLRF   FEF
....................       global_current_time_queue_location--; 
02252:  MOVLB  3
02254:  DECF   x9C,F
02256:  CLRF   19
02258:  BTFSC  FF2.7
0225A:  BSF    19.7
0225C:  BCF    FF2.7
....................        
....................       //send queue item to the priority queue and return the result from adding it to the PQ 
....................       push_priority_queue_ISR(priority); 
0225E:  MOVFF  583,5B7
02262:  MOVLB  0
02264:  CALL   082A
02268:  BTFSC  19.7
0226A:  BSF    FF2.7
....................       return; 
0226C:  MOVLB  3
....................    } 
0226E:  MOVLB  0
02270:  GOTO   2EC0 (RETURN)
.................... } 
....................  
.................... int1 push_time_queue(uint32_t time_to_execute, uint8_t priority) 
.................... // pushes a new item into the time queue and sorts it (by time). 
.................... // returns 1 if everything is good, 0 if queue is full 
.................... { 
....................    uint8_t n; 
....................       
....................    //if queue is full, return 0 
....................    if (global_current_time_queue_location == (MAX_TIME_QUEUE_ITEMS - 1)) 
*
04422:  MOVLB  3
04424:  MOVF   x9C,W
04426:  SUBLW  04
04428:  BNZ   4430
....................    { 
....................       return 0; 
0442A:  MOVLW  00
0442C:  MOVWF  01
0442E:  BRA    466C
....................    } 
....................     
....................    // increment the time queue location and 
....................    // set the new item at the top of the queue (will be sorted in a sec) 
....................    global_current_time_queue_location++; 
04430:  INCF   x9C,F
....................    global_time_queue[global_current_time_queue_location].pq_priority = priority; 
04432:  MOVF   x9C,W
04434:  MULLW  05
04436:  MOVF   FF3,W
04438:  MOVLB  5
0443A:  CLRF   x5D
0443C:  MOVWF  x5C
0443E:  MOVLW  04
04440:  ADDWF  x5C,W
04442:  MOVWF  01
04444:  MOVLW  00
04446:  ADDWFC x5D,W
04448:  MOVWF  03
0444A:  MOVF   01,W
0444C:  ADDLW  83
0444E:  MOVWF  FE9
04450:  MOVLW  03
04452:  ADDWFC 03,W
04454:  MOVWF  FEA
04456:  MOVFF  55A,FEF
....................    global_time_queue[global_current_time_queue_location].time_to_execute = time_to_execute; 
0445A:  MOVLB  3
0445C:  MOVF   x9C,W
0445E:  MULLW  05
04460:  MOVF   FF3,W
04462:  MOVLB  5
04464:  CLRF   x5D
04466:  MOVWF  x5C
04468:  MOVLW  83
0446A:  ADDWF  x5C,W
0446C:  MOVWF  FE9
0446E:  MOVLW  03
04470:  ADDWFC x5D,W
04472:  MOVWF  FEA
04474:  MOVFF  556,FEF
04478:  MOVFF  557,FEC
0447C:  MOVFF  558,FEC
04480:  MOVFF  559,FEC
....................     
....................    //starting at the new current queue location, sort through the queue 
....................    //until the new item is in the right place 
....................    for (n = global_current_time_queue_location; n > 0; n--) 
04484:  MOVFF  39C,55B
04488:  MOVF   x5B,F
0448A:  BTFSC  FD8.2
0448C:  BRA    4666
....................    { 
....................       //if queue items are not sorted properly 
....................       if (global_time_queue[n].time_to_execute > global_time_queue[n-1].time_to_execute) 
0448E:  MOVF   x5B,W
04490:  MULLW  05
04492:  MOVF   FF3,W
04494:  CLRF   x5D
04496:  MOVWF  x5C
04498:  MOVLW  83
0449A:  ADDWF  x5C,W
0449C:  MOVWF  FE9
0449E:  MOVLW  03
044A0:  ADDWFC x5D,W
044A2:  MOVWF  FEA
044A4:  MOVFF  FEF,55E
044A8:  MOVFF  FEC,55F
044AC:  MOVFF  FEC,560
044B0:  MOVFF  FEC,561
044B4:  MOVLW  01
044B6:  SUBWF  x5B,W
044B8:  MULLW  05
044BA:  MOVF   FF3,W
044BC:  CLRF   x63
044BE:  MOVWF  x62
044C0:  MOVLW  83
044C2:  ADDWF  x62,W
044C4:  MOVWF  FE9
044C6:  MOVLW  03
044C8:  ADDWFC x63,W
044CA:  MOVWF  FEA
044CC:  MOVFF  FEF,00
044D0:  MOVFF  FEC,01
044D4:  MOVFF  FEC,02
044D8:  MOVFF  FEC,03
044DC:  MOVF   03,W
044DE:  SUBWF  x61,W
044E0:  BTFSS  FD8.0
044E2:  BRA    4658
044E4:  BNZ   4502
044E6:  MOVF   02,W
044E8:  SUBWF  x60,W
044EA:  BTFSS  FD8.0
044EC:  BRA    4658
044EE:  BNZ   4502
044F0:  MOVF   01,W
044F2:  SUBWF  x5F,W
044F4:  BTFSS  FD8.0
044F6:  BRA    4658
044F8:  BNZ   4502
044FA:  MOVF   x5E,W
044FC:  SUBWF  00,W
044FE:  BTFSC  FD8.0
04500:  BRA    4658
....................       { 
....................          //do a swap reusing new queue item variable as a temp 
....................          priority = global_time_queue[n].pq_priority; 
04502:  MOVF   x5B,W
04504:  MULLW  05
04506:  MOVF   FF3,W
04508:  CLRF   x5D
0450A:  MOVWF  x5C
0450C:  MOVLW  04
0450E:  ADDWF  x5C,W
04510:  MOVWF  01
04512:  MOVLW  00
04514:  ADDWFC x5D,W
04516:  MOVWF  03
04518:  MOVF   01,W
0451A:  ADDLW  83
0451C:  MOVWF  FE9
0451E:  MOVLW  03
04520:  ADDWFC 03,W
04522:  MOVWF  FEA
04524:  MOVFF  FEF,55A
....................          global_time_queue[n].pq_priority = global_time_queue[n-1].pq_priority; 
04528:  MOVF   x5B,W
0452A:  MULLW  05
0452C:  MOVF   FF3,W
0452E:  CLRF   x5D
04530:  MOVWF  x5C
04532:  MOVLW  04
04534:  ADDWF  x5C,W
04536:  MOVWF  01
04538:  MOVLW  00
0453A:  ADDWFC x5D,W
0453C:  MOVWF  03
0453E:  MOVF   01,W
04540:  ADDLW  83
04542:  MOVWF  01
04544:  MOVLW  03
04546:  ADDWFC 03,F
04548:  MOVFF  01,55C
0454C:  MOVFF  03,55D
04550:  MOVLW  01
04552:  SUBWF  x5B,W
04554:  MULLW  05
04556:  MOVF   FF3,W
04558:  CLRF   x5F
0455A:  MOVWF  x5E
0455C:  MOVLW  04
0455E:  ADDWF  x5E,W
04560:  MOVWF  01
04562:  MOVLW  00
04564:  ADDWFC x5F,W
04566:  MOVWF  03
04568:  MOVF   01,W
0456A:  ADDLW  83
0456C:  MOVWF  FE9
0456E:  MOVLW  03
04570:  ADDWFC 03,W
04572:  MOVWF  FEA
04574:  MOVFF  FEF,55E
04578:  MOVFF  55D,FEA
0457C:  MOVFF  55C,FE9
04580:  MOVFF  55E,FEF
....................          global_time_queue[n-1].pq_priority = priority; 
04584:  MOVLW  01
04586:  SUBWF  x5B,W
04588:  MULLW  05
0458A:  MOVF   FF3,W
0458C:  CLRF   x5D
0458E:  MOVWF  x5C
04590:  MOVLW  04
04592:  ADDWF  x5C,W
04594:  MOVWF  01
04596:  MOVLW  00
04598:  ADDWFC x5D,W
0459A:  MOVWF  03
0459C:  MOVF   01,W
0459E:  ADDLW  83
045A0:  MOVWF  FE9
045A2:  MOVLW  03
045A4:  ADDWFC 03,W
045A6:  MOVWF  FEA
045A8:  MOVFF  55A,FEF
....................          time_to_execute = global_time_queue[n].time_to_execute; 
045AC:  MOVF   x5B,W
045AE:  MULLW  05
045B0:  MOVF   FF3,W
045B2:  CLRF   x5D
045B4:  MOVWF  x5C
045B6:  MOVLW  83
045B8:  ADDWF  x5C,W
045BA:  MOVWF  FE9
045BC:  MOVLW  03
045BE:  ADDWFC x5D,W
045C0:  MOVWF  FEA
045C2:  MOVFF  FEF,556
045C6:  MOVFF  FEC,557
045CA:  MOVFF  FEC,558
045CE:  MOVFF  FEC,559
....................          global_time_queue[n].time_to_execute = global_time_queue[n-1].time_to_execute; 
045D2:  MOVF   x5B,W
045D4:  MULLW  05
045D6:  MOVF   FF3,W
045D8:  CLRF   x5D
045DA:  MOVWF  x5C
045DC:  MOVLW  83
045DE:  ADDWF  x5C,W
045E0:  MOVWF  01
045E2:  MOVLW  03
045E4:  ADDWFC x5D,W
045E6:  MOVWF  03
045E8:  MOVFF  01,55E
045EC:  MOVWF  x5F
045EE:  MOVLW  01
045F0:  SUBWF  x5B,W
045F2:  MULLW  05
045F4:  MOVF   FF3,W
045F6:  CLRF   x61
045F8:  MOVWF  x60
045FA:  MOVLW  83
045FC:  ADDWF  x60,W
045FE:  MOVWF  FE9
04600:  MOVLW  03
04602:  ADDWFC x61,W
04604:  MOVWF  FEA
04606:  MOVFF  FEF,00
0460A:  MOVFF  FEC,01
0460E:  MOVFF  FEC,02
04612:  MOVFF  FEC,03
04616:  MOVFF  55F,FEA
0461A:  MOVFF  55E,FE9
0461E:  MOVFF  00,FEF
04622:  MOVFF  01,FEC
04626:  MOVFF  02,FEC
0462A:  MOVFF  03,FEC
....................          global_time_queue[n-1].time_to_execute = time_to_execute; 
0462E:  MOVLW  01
04630:  SUBWF  x5B,W
04632:  MULLW  05
04634:  MOVF   FF3,W
04636:  CLRF   x5D
04638:  MOVWF  x5C
0463A:  MOVLW  83
0463C:  ADDWF  x5C,W
0463E:  MOVWF  FE9
04640:  MOVLW  03
04642:  ADDWFC x5D,W
04644:  MOVWF  FEA
04646:  MOVFF  556,FEF
0464A:  MOVFF  557,FEC
0464E:  MOVFF  558,FEC
04652:  MOVFF  559,FEC
....................           
....................       } 
04656:  BRA    4662
....................       //item is in the proper place (assuming queue always sorted properly) 
....................       else 
....................       { 
....................          return 1; 
04658:  MOVLW  01
0465A:  MOVWF  01
0465C:  MOVLB  3
0465E:  BRA    466C
04660:  MOVLB  5
....................       } 
04662:  DECF   x5B,F
04664:  BRA    4488
....................    } 
....................    return 1; 
04666:  MOVLW  01
04668:  MOVWF  01
0466A:  MOVLB  3
0466C:  MOVLB  0
0466E:  RETURN 0
.................... } 
....................  
.................... void push_time_queue_ISR(uint32_t time_to_execute, uint8_t priority) 
.................... // pushes a new item into the time queue and sorts it (by time). 
.................... // returns 1 if everything is good, 0 if queue is full 
.................... { 
....................    uint8_t n; 
....................       
....................    //if queue is full, return 0 
....................    if (global_current_time_queue_location == (MAX_TIME_QUEUE_ITEMS - 1)) 
*
017D8:  MOVLB  3
017DA:  MOVF   x9C,W
017DC:  SUBLW  04
017DE:  BNZ   17E2
....................    { 
....................       return; 
017E0:  BRA    1A0E
....................    } 
....................     
....................    // increment the time queue location and 
....................    // set the new item at the top of the queue (will be sorted in a sec) 
....................    global_current_time_queue_location++; 
017E2:  INCF   x9C,F
....................    global_time_queue[global_current_time_queue_location].pq_priority = priority; 
017E4:  MOVF   x9C,W
017E6:  MULLW  05
017E8:  MOVF   FF3,W
017EA:  MOVLB  5
017EC:  CLRF   xC2
017EE:  MOVWF  xC1
017F0:  MOVLW  04
017F2:  ADDWF  xC1,W
017F4:  MOVWF  01
017F6:  MOVLW  00
017F8:  ADDWFC xC2,W
017FA:  MOVWF  03
017FC:  MOVF   01,W
017FE:  ADDLW  83
01800:  MOVWF  FE9
01802:  MOVLW  03
01804:  ADDWFC 03,W
01806:  MOVWF  FEA
01808:  MOVFF  5BF,FEF
....................    global_time_queue[global_current_time_queue_location].time_to_execute = time_to_execute; 
0180C:  MOVLB  3
0180E:  MOVF   x9C,W
01810:  MULLW  05
01812:  MOVF   FF3,W
01814:  MOVLB  5
01816:  CLRF   xC2
01818:  MOVWF  xC1
0181A:  MOVLW  83
0181C:  ADDWF  xC1,W
0181E:  MOVWF  FE9
01820:  MOVLW  03
01822:  ADDWFC xC2,W
01824:  MOVWF  FEA
01826:  MOVFF  5BB,FEF
0182A:  MOVFF  5BC,FEC
0182E:  MOVFF  5BD,FEC
01832:  MOVFF  5BE,FEC
....................        
....................    //starting at the new current queue location, sort through the queue 
....................    //until the new item is in the right place 
....................    for (n = global_current_time_queue_location; n > 0; n--) 
01836:  MOVFF  39C,5C0
0183A:  MOVF   xC0,F
0183C:  BTFSC  FD8.2
0183E:  BRA    1A0C
....................    { 
....................       //if queue items are not sorted properly 
....................       if (global_time_queue[n].time_to_execute > global_time_queue[n-1].time_to_execute) 
01840:  MOVF   xC0,W
01842:  MULLW  05
01844:  MOVF   FF3,W
01846:  CLRF   xC2
01848:  MOVWF  xC1
0184A:  MOVLW  83
0184C:  ADDWF  xC1,W
0184E:  MOVWF  FE9
01850:  MOVLW  03
01852:  ADDWFC xC2,W
01854:  MOVWF  FEA
01856:  MOVFF  FEF,5C3
0185A:  MOVFF  FEC,5C4
0185E:  MOVFF  FEC,5C5
01862:  MOVFF  FEC,5C6
01866:  MOVLW  01
01868:  SUBWF  xC0,W
0186A:  MULLW  05
0186C:  MOVF   FF3,W
0186E:  CLRF   xC8
01870:  MOVWF  xC7
01872:  MOVLW  83
01874:  ADDWF  xC7,W
01876:  MOVWF  FE9
01878:  MOVLW  03
0187A:  ADDWFC xC8,W
0187C:  MOVWF  FEA
0187E:  MOVFF  FEF,00
01882:  MOVFF  FEC,01
01886:  MOVFF  FEC,02
0188A:  MOVFF  FEC,03
0188E:  MOVF   03,W
01890:  SUBWF  xC6,W
01892:  BTFSS  FD8.0
01894:  BRA    1A08
01896:  BNZ   18B4
01898:  MOVF   02,W
0189A:  SUBWF  xC5,W
0189C:  BTFSS  FD8.0
0189E:  BRA    1A08
018A0:  BNZ   18B4
018A2:  MOVF   01,W
018A4:  SUBWF  xC4,W
018A6:  BTFSS  FD8.0
018A8:  BRA    1A08
018AA:  BNZ   18B4
018AC:  MOVF   xC3,W
018AE:  SUBWF  00,W
018B0:  BTFSC  FD8.0
018B2:  BRA    1A08
....................       { 
....................          //do a swap reusing new queue item variable as a temp 
....................          priority = global_time_queue[n].pq_priority; 
018B4:  MOVF   xC0,W
018B6:  MULLW  05
018B8:  MOVF   FF3,W
018BA:  CLRF   xC2
018BC:  MOVWF  xC1
018BE:  MOVLW  04
018C0:  ADDWF  xC1,W
018C2:  MOVWF  01
018C4:  MOVLW  00
018C6:  ADDWFC xC2,W
018C8:  MOVWF  03
018CA:  MOVF   01,W
018CC:  ADDLW  83
018CE:  MOVWF  FE9
018D0:  MOVLW  03
018D2:  ADDWFC 03,W
018D4:  MOVWF  FEA
018D6:  MOVFF  FEF,5BF
....................          global_time_queue[n].pq_priority = global_time_queue[n-1].pq_priority; 
018DA:  MOVF   xC0,W
018DC:  MULLW  05
018DE:  MOVF   FF3,W
018E0:  CLRF   xC2
018E2:  MOVWF  xC1
018E4:  MOVLW  04
018E6:  ADDWF  xC1,W
018E8:  MOVWF  01
018EA:  MOVLW  00
018EC:  ADDWFC xC2,W
018EE:  MOVWF  03
018F0:  MOVF   01,W
018F2:  ADDLW  83
018F4:  MOVWF  01
018F6:  MOVLW  03
018F8:  ADDWFC 03,F
018FA:  MOVFF  01,5C1
018FE:  MOVFF  03,5C2
01902:  MOVLW  01
01904:  SUBWF  xC0,W
01906:  MULLW  05
01908:  MOVF   FF3,W
0190A:  CLRF   xC4
0190C:  MOVWF  xC3
0190E:  MOVLW  04
01910:  ADDWF  xC3,W
01912:  MOVWF  01
01914:  MOVLW  00
01916:  ADDWFC xC4,W
01918:  MOVWF  03
0191A:  MOVF   01,W
0191C:  ADDLW  83
0191E:  MOVWF  FE9
01920:  MOVLW  03
01922:  ADDWFC 03,W
01924:  MOVWF  FEA
01926:  MOVFF  FEF,5C3
0192A:  MOVFF  5C2,FEA
0192E:  MOVFF  5C1,FE9
01932:  MOVFF  5C3,FEF
....................          global_time_queue[n-1].pq_priority = priority; 
01936:  MOVLW  01
01938:  SUBWF  xC0,W
0193A:  MULLW  05
0193C:  MOVF   FF3,W
0193E:  CLRF   xC2
01940:  MOVWF  xC1
01942:  MOVLW  04
01944:  ADDWF  xC1,W
01946:  MOVWF  01
01948:  MOVLW  00
0194A:  ADDWFC xC2,W
0194C:  MOVWF  03
0194E:  MOVF   01,W
01950:  ADDLW  83
01952:  MOVWF  FE9
01954:  MOVLW  03
01956:  ADDWFC 03,W
01958:  MOVWF  FEA
0195A:  MOVFF  5BF,FEF
....................          time_to_execute = global_time_queue[n].time_to_execute; 
0195E:  MOVF   xC0,W
01960:  MULLW  05
01962:  MOVF   FF3,W
01964:  CLRF   xC2
01966:  MOVWF  xC1
01968:  MOVLW  83
0196A:  ADDWF  xC1,W
0196C:  MOVWF  FE9
0196E:  MOVLW  03
01970:  ADDWFC xC2,W
01972:  MOVWF  FEA
01974:  MOVFF  FEF,5BB
01978:  MOVFF  FEC,5BC
0197C:  MOVFF  FEC,5BD
01980:  MOVFF  FEC,5BE
....................          global_time_queue[n].time_to_execute = global_time_queue[n-1].time_to_execute; 
01984:  MOVF   xC0,W
01986:  MULLW  05
01988:  MOVF   FF3,W
0198A:  CLRF   xC2
0198C:  MOVWF  xC1
0198E:  MOVLW  83
01990:  ADDWF  xC1,W
01992:  MOVWF  01
01994:  MOVLW  03
01996:  ADDWFC xC2,W
01998:  MOVWF  03
0199A:  MOVFF  01,5C3
0199E:  MOVWF  xC4
019A0:  MOVLW  01
019A2:  SUBWF  xC0,W
019A4:  MULLW  05
019A6:  MOVF   FF3,W
019A8:  CLRF   xC6
019AA:  MOVWF  xC5
019AC:  MOVLW  83
019AE:  ADDWF  xC5,W
019B0:  MOVWF  FE9
019B2:  MOVLW  03
019B4:  ADDWFC xC6,W
019B6:  MOVWF  FEA
019B8:  MOVFF  FEF,00
019BC:  MOVFF  FEC,01
019C0:  MOVFF  FEC,02
019C4:  MOVFF  FEC,03
019C8:  MOVFF  5C4,FEA
019CC:  MOVFF  5C3,FE9
019D0:  MOVFF  00,FEF
019D4:  MOVFF  01,FEC
019D8:  MOVFF  02,FEC
019DC:  MOVFF  03,FEC
....................          global_time_queue[n-1].time_to_execute = time_to_execute; 
019E0:  MOVLW  01
019E2:  SUBWF  xC0,W
019E4:  MULLW  05
019E6:  MOVF   FF3,W
019E8:  CLRF   xC2
019EA:  MOVWF  xC1
019EC:  MOVLW  83
019EE:  ADDWF  xC1,W
019F0:  MOVWF  FE9
019F2:  MOVLW  03
019F4:  ADDWFC xC2,W
019F6:  MOVWF  FEA
019F8:  MOVFF  5BB,FEF
019FC:  MOVFF  5BC,FEC
01A00:  MOVFF  5BD,FEC
01A04:  MOVFF  5BE,FEC
....................           
....................       } 
01A08:  DECF   xC0,F
01A0A:  BRA    183A
01A0C:  MOVLB  3
....................    } 
....................    return; 
01A0E:  MOVLB  0
01A10:  RETURN 0
.................... } 
....................  
.................... void allocate_command_queue(void) 
.................... { 
....................    // allocate the memory for the command queue sprinkler zone settings (can't 
....................    //    easily make a struct array inside a struct in c.) 
....................  
....................    uint8_t n; 
....................     
....................    for (n = 0; n < MAX_COMMAND_QUEUE_ITEMS; n++) 
....................    { 
....................       global_command_queue[n].sprinkler_settings =                            \ 
....................       (struct SprinklerZoneSettingsItem*)                                     \ 
....................       malloc(sizeof (struct SprinklerZoneSettingsItem) * MAX_NUM_SPRINKLER_ZONES); 
....................    } 
.................... } 
....................  
.................... void clear_command_queue(void) 
.................... { 
....................    // clears out the command queue and sets the start times to 0-1 
....................    uint8_t n; 
....................     
....................    // clear the queue compeleted and fill with zeros 
....................    memset(global_command_queue, 0, sizeof global_command_queue); 
....................     
....................    // sets start times to 0-1 (for unsigned int) 
....................    for (n = 0; n < MAX_COMMAND_QUEUE_ITEMS; n++) 
....................    { 
....................       global_command_queue[n].start_time = 0-1; 
....................    } 
....................     
....................    // set the queue location to 0-1 which signifies that there isn't anything 
....................    //    in the queue 
....................    global_current_command_queue_location = 0-1; 
.................... } 
....................  
.................... int1 push_command_queue(struct CommandQueueItem new_command_queue_item) 
.................... // pushes a new item into the command queue and sorts it (by time). 
.................... // returns 1 if everything is good, 0 if queue is full 
.................... { 
....................    uint8_t n; 
....................     
....................    //if queue is full, return 0 
....................    if (global_current_command_queue_location == (MAX_COMMAND_QUEUE_ITEMS - 1)) 
....................    { 
....................       return 0; 
....................    } 
....................     
....................    // increment the command queue location and 
....................    // set the new item at the top of the queue (will be sorted in a sec) 
....................    global_current_command_queue_location++; 
....................    global_command_queue[global_current_command_queue_location] = new_command_queue_item; 
....................     
....................    //starting at the new current queue location, sort through the queue 
....................    //until the new item is in the right place 
....................    for (n = global_current_command_queue_location; n > 0; n--) 
....................    { 
....................       //if queue items are not sorted properly 
....................       if (global_command_queue[n].start_time > global_command_queue[n-1].start_time) 
....................       { 
....................          //do a swap reusing new queue item variable as a temp 
....................          new_command_queue_item = global_time_queue[n]; 
....................          global_time_queue[n] = global_time_queue[n-1]; 
....................          global_time_queue[n-1] = new_command_queue_item; 
....................       } 
....................       //item is in the proper place (assuming queue always sorted properly) 
....................       else 
....................       { 
....................          return 1; 
....................       } 
....................    } 
....................    return 1; 
.................... } 
....................  
.................... void pop_command_queue_ISR() 
.................... // pops a new item off the command queue and sorts it (by time). 
.................... // returns 1 if everything is good, 0 if queue is full 
.................... { 
....................    uint8_t n; 
....................    struct commandQueueItem new_command_queue_item; 
....................     
....................    //if queue is empty, return 0 
....................    if (global_current_command_queue_location == 255) 
....................    { 
....................       return; 
....................    } 
....................     
....................     
....................    // increment the command queue location and 
....................    // set the new item at the top of the queue (will be sorted in a sec) 
....................    global_current_command_queue_location++; 
....................    global_command_queue[global_current_command_queue_location] = new_command_queue_item; 
....................     
....................    //starting at the new current queue location, sort through the queue 
....................    //until the new item is in the right place 
....................    for (n = global_current_command_queue_location; n > 0; n--) 
....................    { 
....................       //if queue items are not sorted properly 
....................       if (global_command_queue[n].start_time > global_command_queue[n-1].start_time) 
....................       { 
....................          //do a swap reusing new queue item variable as a temp 
....................          new_command_queue_item = global_time_queue[n]; 
....................          global_time_queue[n] = global_time_queue[n-1]; 
....................          global_time_queue[n-1] = new_command_queue_item; 
....................       } 
....................       //item is in the proper place (assuming queue always sorted properly) 
....................       else 
....................       { 
....................          return; 
....................       } 
....................    } 
....................    return; 
.................... } 
.................... void clear_sprinkler_queue() 
.................... { 
....................    disable_interrupts(INT_CCP4); 
*
053B0:  BCF    F7A.1
....................    memset(&global_sprinkler_queue, EMPTY_SPINKLER_QUEUE, sizeof(global_sprinkler_queue)); 
053B2:  MOVLW  03
053B4:  MOVWF  FEA
053B6:  MOVLW  9D
053B8:  MOVWF  FE9
053BA:  CLRF   00
053BC:  CLRF   02
053BE:  MOVLW  8C
053C0:  MOVWF  01
053C2:  CALL   2274
....................    global_current_sprinkler_queue_location = 0-1; 
053C6:  MOVLB  4
053C8:  SETF   x29
....................    global_rpm_set_value = 0; 
053CA:  MOVLB  0
053CC:  CLRF   xAD
053CE:  CLRF   xAC
....................    global_control_loop_mechanism = NO_RPM_CONTROL; 
053D0:  MOVLW  05
053D2:  MOVWF  xC0
....................    enable_interrupts(INT_CCP4); 
053D4:  BSF    F7A.1
053D6:  RETURN 0
.................... } 
....................  
.................... void push_sprinkler_queue(uint32_t start_time,uint32_t end_time,uint16_t vlv_open_amount,uint16_t spin_rate,uint8_t zone_num, uint8_t control_loop_mechanism) 
.................... // pushes a new item into the sprinkler queue and sorts it (by start time). 
.................... // returns 1 if everything is good, 0 if queue is full 
.................... { 
....................    uint8_t n; 
....................    struct SprinklerQueueItem temp_sprinkler_queue_item; 
....................     
....................    // disable CCP4 interrupt (RTC timer) 
....................    disable_interrupts(INT_CCP4); 
*
06C54:  BCF    F7A.1
....................           
....................    //if queue is full, return 0 
....................    if (global_current_sprinkler_queue_location == (MAX_SPRINKLER_QUEUE_ITEMS - 1)) 
06C56:  MOVLB  4
06C58:  MOVF   x29,W
06C5A:  SUBLW  09
06C5C:  BNZ   6C62
....................    { 
....................       enable_interrupts(INT_CCP4); 
06C5E:  BSF    F7A.1
....................       return; 
06C60:  BRA    6E8E
....................    } 
....................     
....................    // increment the sprinkler queue location and 
....................    // set the new item at the top of the queue (will be sorted in a sec) 
....................    global_current_sprinkler_queue_location++; 
06C62:  INCF   x29,F
....................    global_sprinkler_queue[global_current_sprinkler_queue_location].start_time = start_time; 
06C64:  MOVF   x29,W
06C66:  MULLW  0E
06C68:  MOVF   FF3,W
06C6A:  MOVLB  5
06C6C:  CLRF   x7C
06C6E:  MOVWF  x7B
06C70:  MOVLW  9D
06C72:  ADDWF  x7B,W
06C74:  MOVWF  FE9
06C76:  MOVLW  03
06C78:  ADDWFC x7C,W
06C7A:  MOVWF  FEA
06C7C:  MOVFF  55E,FEF
06C80:  MOVFF  55F,FEC
06C84:  MOVFF  560,FEC
06C88:  MOVFF  561,FEC
....................    global_sprinkler_queue[global_current_sprinkler_queue_location].end_time = end_time; 
06C8C:  MOVLB  4
06C8E:  MOVF   x29,W
06C90:  MULLW  0E
06C92:  MOVF   FF3,W
06C94:  MOVLB  5
06C96:  CLRF   x7C
06C98:  MOVWF  x7B
06C9A:  MOVLW  04
06C9C:  ADDWF  x7B,W
06C9E:  MOVWF  01
06CA0:  MOVLW  00
06CA2:  ADDWFC x7C,W
06CA4:  MOVWF  03
06CA6:  MOVF   01,W
06CA8:  ADDLW  9D
06CAA:  MOVWF  FE9
06CAC:  MOVLW  03
06CAE:  ADDWFC 03,W
06CB0:  MOVWF  FEA
06CB2:  MOVFF  562,FEF
06CB6:  MOVFF  563,FEC
06CBA:  MOVFF  564,FEC
06CBE:  MOVFF  565,FEC
....................    global_sprinkler_queue[global_current_sprinkler_queue_location].vlv_open_amount = vlv_open_amount; 
06CC2:  MOVLB  4
06CC4:  MOVF   x29,W
06CC6:  MULLW  0E
06CC8:  MOVF   FF3,W
06CCA:  MOVLB  5
06CCC:  CLRF   x7C
06CCE:  MOVWF  x7B
06CD0:  MOVLW  08
06CD2:  ADDWF  x7B,W
06CD4:  MOVWF  01
06CD6:  MOVLW  00
06CD8:  ADDWFC x7C,W
06CDA:  MOVWF  03
06CDC:  MOVF   01,W
06CDE:  ADDLW  9D
06CE0:  MOVWF  FE9
06CE2:  MOVLW  03
06CE4:  ADDWFC 03,W
06CE6:  MOVWF  FEA
06CE8:  MOVFF  567,FEC
06CEC:  MOVF   FED,F
06CEE:  MOVFF  566,FEF
....................    global_sprinkler_queue[global_current_sprinkler_queue_location].spin_rate = spin_rate; 
06CF2:  MOVLB  4
06CF4:  MOVF   x29,W
06CF6:  MULLW  0E
06CF8:  MOVF   FF3,W
06CFA:  MOVLB  5
06CFC:  CLRF   x7C
06CFE:  MOVWF  x7B
06D00:  MOVLW  0A
06D02:  ADDWF  x7B,W
06D04:  MOVWF  01
06D06:  MOVLW  00
06D08:  ADDWFC x7C,W
06D0A:  MOVWF  03
06D0C:  MOVF   01,W
06D0E:  ADDLW  9D
06D10:  MOVWF  FE9
06D12:  MOVLW  03
06D14:  ADDWFC 03,W
06D16:  MOVWF  FEA
06D18:  MOVFF  569,FEC
06D1C:  MOVF   FED,F
06D1E:  MOVFF  568,FEF
....................    global_sprinkler_queue[global_current_sprinkler_queue_location].zone_num = zone_num; 
06D22:  MOVLB  4
06D24:  MOVF   x29,W
06D26:  MULLW  0E
06D28:  MOVF   FF3,W
06D2A:  MOVLB  5
06D2C:  CLRF   x7C
06D2E:  MOVWF  x7B
06D30:  MOVLW  0C
06D32:  ADDWF  x7B,W
06D34:  MOVWF  01
06D36:  MOVLW  00
06D38:  ADDWFC x7C,W
06D3A:  MOVWF  03
06D3C:  MOVF   01,W
06D3E:  ADDLW  9D
06D40:  MOVWF  FE9
06D42:  MOVLW  03
06D44:  ADDWFC 03,W
06D46:  MOVWF  FEA
06D48:  MOVFF  56A,FEF
....................    global_sprinkler_queue[global_current_sprinkler_queue_location].control_loop_mechanism = control_loop_mechanism; 
06D4C:  MOVLB  4
06D4E:  MOVF   x29,W
06D50:  MULLW  0E
06D52:  MOVF   FF3,W
06D54:  MOVLB  5
06D56:  CLRF   x7C
06D58:  MOVWF  x7B
06D5A:  MOVLW  0D
06D5C:  ADDWF  x7B,W
06D5E:  MOVWF  01
06D60:  MOVLW  00
06D62:  ADDWFC x7C,W
06D64:  MOVWF  03
06D66:  MOVF   01,W
06D68:  ADDLW  9D
06D6A:  MOVWF  FE9
06D6C:  MOVLW  03
06D6E:  ADDWFC 03,W
06D70:  MOVWF  FEA
06D72:  MOVFF  56B,FEF
....................     
....................     
....................    //starting at the new current queue location, sort through the queue 
....................    //until the new item is in the right place 
....................    for (n = global_current_sprinkler_queue_location; n > 0; n--) 
06D76:  MOVFF  429,56C
06D7A:  MOVF   x6C,F
06D7C:  BTFSC  FD8.2
06D7E:  BRA    6E8A
....................    { 
....................       //if queue items are not sorted properly 
....................       if (global_sprinkler_queue[n].start_time > global_sprinkler_queue[n-1].start_time) 
06D80:  MOVF   x6C,W
06D82:  MULLW  0E
06D84:  MOVF   FF3,W
06D86:  CLRF   x7C
06D88:  MOVWF  x7B
06D8A:  MOVLW  9D
06D8C:  ADDWF  x7B,W
06D8E:  MOVWF  FE9
06D90:  MOVLW  03
06D92:  ADDWFC x7C,W
06D94:  MOVWF  FEA
06D96:  MOVFF  FEF,57D
06D9A:  MOVFF  FEC,57E
06D9E:  MOVFF  FEC,57F
06DA2:  MOVFF  FEC,580
06DA6:  MOVLW  01
06DA8:  SUBWF  x6C,W
06DAA:  MULLW  0E
06DAC:  MOVF   FF3,W
06DAE:  CLRF   x82
06DB0:  MOVWF  x81
06DB2:  MOVLW  9D
06DB4:  ADDWF  x81,W
06DB6:  MOVWF  FE9
06DB8:  MOVLW  03
06DBA:  ADDWFC x82,W
06DBC:  MOVWF  FEA
06DBE:  MOVFF  FEF,00
06DC2:  MOVFF  FEC,01
06DC6:  MOVFF  FEC,02
06DCA:  MOVFF  FEC,03
06DCE:  MOVF   03,W
06DD0:  SUBWF  x80,W
06DD2:  BNC   6E7E
06DD4:  BNZ   6DEC
06DD6:  MOVF   02,W
06DD8:  SUBWF  x7F,W
06DDA:  BNC   6E7E
06DDC:  BNZ   6DEC
06DDE:  MOVF   01,W
06DE0:  SUBWF  x7E,W
06DE2:  BNC   6E7E
06DE4:  BNZ   6DEC
06DE6:  MOVF   x7D,W
06DE8:  SUBWF  00,W
06DEA:  BC    6E7E
....................       { 
....................          //do a swap reusing new queue item variable as a temp 
....................          memcpy(&temp_sprinkler_queue_item, &global_sprinkler_queue[n], sizeof(&temp_sprinkler_queue_item)); 
06DEC:  MOVF   x6C,W
06DEE:  MULLW  0E
06DF0:  MOVF   FF3,W
06DF2:  CLRF   03
06DF4:  ADDLW  9D
06DF6:  MOVWF  01
06DF8:  MOVLW  03
06DFA:  ADDWFC 03,F
06DFC:  MOVFF  03,FE2
06E00:  MOVFF  01,FE1
06E04:  MOVFF  FE6,56D
06E08:  MOVFF  FE6,56E
....................          memcpy(&global_sprinkler_queue[n], &global_sprinkler_queue[n-1], sizeof(&global_sprinkler_queue[n])); 
06E0C:  MOVF   x6C,W
06E0E:  MULLW  0E
06E10:  MOVF   FF3,W
06E12:  CLRF   03
06E14:  ADDLW  9D
06E16:  MOVWF  01
06E18:  MOVLW  03
06E1A:  ADDWFC 03,F
06E1C:  MOVFF  01,57B
06E20:  MOVFF  03,57C
06E24:  MOVLW  01
06E26:  SUBWF  x6C,W
06E28:  MULLW  0E
06E2A:  MOVF   FF3,W
06E2C:  CLRF   03
06E2E:  ADDLW  9D
06E30:  MOVWF  01
06E32:  MOVLW  03
06E34:  ADDWFC 03,F
06E36:  MOVFF  01,57D
06E3A:  MOVFF  03,57E
06E3E:  MOVFF  57C,FEA
06E42:  MOVFF  57B,FE9
06E46:  MOVFF  03,FE2
06E4A:  MOVFF  01,FE1
06E4E:  MOVLW  02
06E50:  MOVWF  01
06E52:  MOVFF  FE6,FEE
06E56:  DECFSZ 01,F
06E58:  BRA    6E52
....................          memcpy(&global_sprinkler_queue[n-1], &temp_sprinkler_queue_item, sizeof(&global_sprinkler_queue[n-1])); 
06E5A:  MOVLW  01
06E5C:  SUBWF  x6C,W
06E5E:  MULLW  0E
06E60:  MOVF   FF3,W
06E62:  CLRF   03
06E64:  ADDLW  9D
06E66:  MOVWF  01
06E68:  MOVLW  03
06E6A:  ADDWFC 03,F
06E6C:  MOVFF  03,FEA
06E70:  MOVFF  01,FE9
06E74:  MOVFF  56D,FEE
06E78:  MOVFF  56E,FEE
....................           
....................       } 
06E7C:  BRA    6E86
....................       //item is in the proper place (assuming queue always sorted properly) 
....................       else 
....................       { 
....................          enable_interrupts(INT_CCP4); 
06E7E:  BSF    F7A.1
....................          return; 
06E80:  MOVLB  4
06E82:  BRA    6E8E
06E84:  MOVLB  5
....................       } 
06E86:  DECF   x6C,F
06E88:  BRA    6D7A
....................    } 
....................    enable_interrupts(INT_CCP4); 
06E8A:  BSF    F7A.1
06E8C:  MOVLB  4
....................    return; 
06E8E:  MOVLB  0
06E90:  RETURN 0
.................... } 
....................  
.................... void pop_sprinkler_queue_ISR(void) 
.................... // Checks the sprinkler queue and sets the sprinkler settings of the item on the top of the queue 
.................... { 
....................    //no items in the queue (current location is 0-1) 
....................    if (global_current_sprinkler_queue_location == 255) 
*
02BD8:  MOVLB  4
02BDA:  INCFSZ x29,W
02BDC:  BRA    2BE2
....................    { 
....................       return; 
02BDE:  BRA    2DDC
....................    } 
02BE0:  BRA    2DDC
....................    // pop top item off queue and onto actual settings 
....................    else 
....................    { 
....................       //erase the current command start time (only important thing) and decrement the current queue location 
....................       global_sprinkler_queue[global_current_sprinkler_queue_location].start_time = 0-1; 
02BE2:  MOVF   x29,W
02BE4:  MULLW  0E
02BE6:  MOVF   FF3,W
02BE8:  MOVLB  5
02BEA:  CLRF   x84
02BEC:  MOVWF  x83
02BEE:  MOVLW  9D
02BF0:  ADDWF  x83,W
02BF2:  MOVWF  FE9
02BF4:  MOVLW  03
02BF6:  ADDWFC x84,W
02BF8:  MOVWF  FEA
02BFA:  SETF   00
02BFC:  SETF   01
02BFE:  SETF   02
02C00:  SETF   03
02C02:  MOVFF  00,FEF
02C06:  MOVFF  01,FEC
02C0A:  MOVFF  02,FEC
02C0E:  MOVFF  03,FEC
....................       global_current_sprinkler_settings_end_time = global_sprinkler_queue[global_current_sprinkler_queue_location].end_time; 
02C12:  MOVLB  4
02C14:  MOVF   x29,W
02C16:  MULLW  0E
02C18:  MOVF   FF3,W
02C1A:  MOVLB  5
02C1C:  CLRF   x84
02C1E:  MOVWF  x83
02C20:  MOVLW  04
02C22:  ADDWF  x83,W
02C24:  MOVWF  01
02C26:  MOVLW  00
02C28:  ADDWFC x84,W
02C2A:  MOVWF  03
02C2C:  MOVF   01,W
02C2E:  ADDLW  9D
02C30:  MOVWF  FE9
02C32:  MOVLW  03
02C34:  ADDWFC 03,W
02C36:  MOVWF  FEA
02C38:  MOVFF  FEF,42A
02C3C:  MOVFF  FEC,42B
02C40:  MOVFF  FEC,42C
02C44:  MOVFF  FEC,42D
....................       global_sprinkler_queue[global_current_sprinkler_queue_location].end_time = 0; 
02C48:  MOVLB  4
02C4A:  MOVF   x29,W
02C4C:  MULLW  0E
02C4E:  MOVF   FF3,W
02C50:  MOVLB  5
02C52:  CLRF   x84
02C54:  MOVWF  x83
02C56:  MOVLW  04
02C58:  ADDWF  x83,W
02C5A:  MOVWF  01
02C5C:  MOVLW  00
02C5E:  ADDWFC x84,W
02C60:  MOVWF  03
02C62:  MOVF   01,W
02C64:  ADDLW  9D
02C66:  MOVWF  FE9
02C68:  MOVLW  03
02C6A:  ADDWFC 03,W
02C6C:  MOVWF  FEA
02C6E:  MOVF   FEE,F
02C70:  MOVF   FEE,F
02C72:  CLRF   FEC
02C74:  MOVF   FED,F
02C76:  CLRF   FEF
02C78:  MOVF   FED,F
02C7A:  CLRF   FEF
02C7C:  MOVF   FED,F
02C7E:  CLRF   FEF
....................       global_valve_position_set_value = global_sprinkler_queue[global_current_sprinkler_queue_location].vlv_open_amount; 
02C80:  MOVLB  4
02C82:  MOVF   x29,W
02C84:  MULLW  0E
02C86:  MOVF   FF3,W
02C88:  MOVLB  5
02C8A:  CLRF   x84
02C8C:  MOVWF  x83
02C8E:  MOVLW  08
02C90:  ADDWF  x83,W
02C92:  MOVWF  01
02C94:  MOVLW  00
02C96:  ADDWFC x84,W
02C98:  MOVWF  03
02C9A:  MOVF   01,W
02C9C:  ADDLW  9D
02C9E:  MOVWF  FE9
02CA0:  MOVLW  03
02CA2:  ADDWFC 03,W
02CA4:  MOVWF  FEA
02CA6:  MOVFF  FEC,C4
02CAA:  MOVF   FED,F
02CAC:  MOVFF  FEF,C3
....................       global_sprinkler_queue[global_current_sprinkler_queue_location].vlv_open_amount = 0; 
02CB0:  MOVLB  4
02CB2:  MOVF   x29,W
02CB4:  MULLW  0E
02CB6:  MOVF   FF3,W
02CB8:  MOVLB  5
02CBA:  CLRF   x84
02CBC:  MOVWF  x83
02CBE:  MOVLW  08
02CC0:  ADDWF  x83,W
02CC2:  MOVWF  01
02CC4:  MOVLW  00
02CC6:  ADDWFC x84,W
02CC8:  MOVWF  03
02CCA:  MOVF   01,W
02CCC:  ADDLW  9D
02CCE:  MOVWF  FE9
02CD0:  MOVLW  03
02CD2:  ADDWFC 03,W
02CD4:  MOVWF  FEA
02CD6:  CLRF   FEC
02CD8:  MOVF   FED,F
02CDA:  CLRF   FEF
....................       push_time_queue_ISR(global_rtc_time + 3, MOVE_VALVE); 
02CDC:  MOVLW  03
02CDE:  MOVLB  0
02CE0:  ADDWF  x85,W
02CE2:  MOVLB  5
02CE4:  MOVWF  x83
02CE6:  MOVLW  00
02CE8:  MOVLB  0
02CEA:  ADDWFC x86,W
02CEC:  MOVLB  5
02CEE:  MOVWF  x84
02CF0:  MOVLW  00
02CF2:  MOVLB  0
02CF4:  ADDWFC x87,W
02CF6:  MOVLB  5
02CF8:  MOVWF  x85
02CFA:  MOVLW  00
02CFC:  MOVLB  0
02CFE:  ADDWFC x88,W
02D00:  MOVLB  5
02D02:  MOVWF  x86
02D04:  CLRF   19
02D06:  BTFSC  FF2.7
02D08:  BSF    19.7
02D0A:  BCF    FF2.7
02D0C:  MOVWF  xBE
02D0E:  MOVFF  585,5BD
02D12:  MOVFF  584,5BC
02D16:  MOVFF  583,5BB
02D1A:  MOVLW  40
02D1C:  MOVWF  xBF
02D1E:  MOVLB  0
02D20:  CALL   17D8
02D24:  BTFSC  19.7
02D26:  BSF    FF2.7
....................       global_rpm_set_value = global_sprinkler_queue[global_current_sprinkler_queue_location].spin_rate; 
02D28:  MOVLB  4
02D2A:  MOVF   x29,W
02D2C:  MULLW  0E
02D2E:  MOVF   FF3,W
02D30:  MOVLB  5
02D32:  CLRF   x84
02D34:  MOVWF  x83
02D36:  MOVLW  0A
02D38:  ADDWF  x83,W
02D3A:  MOVWF  01
02D3C:  MOVLW  00
02D3E:  ADDWFC x84,W
02D40:  MOVWF  03
02D42:  MOVF   01,W
02D44:  ADDLW  9D
02D46:  MOVWF  FE9
02D48:  MOVLW  03
02D4A:  ADDWFC 03,W
02D4C:  MOVWF  FEA
02D4E:  MOVFF  FEC,AD
02D52:  MOVF   FED,F
02D54:  MOVFF  FEF,AC
....................       global_sprinkler_queue[global_current_sprinkler_queue_location].spin_rate = 0; 
02D58:  MOVLB  4
02D5A:  MOVF   x29,W
02D5C:  MULLW  0E
02D5E:  MOVF   FF3,W
02D60:  MOVLB  5
02D62:  CLRF   x84
02D64:  MOVWF  x83
02D66:  MOVLW  0A
02D68:  ADDWF  x83,W
02D6A:  MOVWF  01
02D6C:  MOVLW  00
02D6E:  ADDWFC x84,W
02D70:  MOVWF  03
02D72:  MOVF   01,W
02D74:  ADDLW  9D
02D76:  MOVWF  FE9
02D78:  MOVLW  03
02D7A:  ADDWFC 03,W
02D7C:  MOVWF  FEA
02D7E:  CLRF   FEC
02D80:  MOVF   FED,F
02D82:  CLRF   FEF
....................       //global_sprinkler_queue[global_current_sprinkler_queue_location].zone_num; 
....................       global_control_loop_mechanism = global_sprinkler_queue[global_current_sprinkler_queue_location].control_loop_mechanism; 
02D84:  MOVLB  4
02D86:  MOVF   x29,W
02D88:  MULLW  0E
02D8A:  MOVF   FF3,W
02D8C:  MOVLB  5
02D8E:  CLRF   x84
02D90:  MOVWF  x83
02D92:  MOVLW  0D
02D94:  ADDWF  x83,W
02D96:  MOVWF  01
02D98:  MOVLW  00
02D9A:  ADDWFC x84,W
02D9C:  MOVWF  03
02D9E:  MOVF   01,W
02DA0:  ADDLW  9D
02DA2:  MOVWF  FE9
02DA4:  MOVLW  03
02DA6:  ADDWFC 03,W
02DA8:  MOVWF  FEA
02DAA:  MOVFF  FEF,C0
....................       global_sprinkler_queue[global_current_sprinkler_queue_location].control_loop_mechanism = NO_RPM_CONTROL_DYN_MPPC; 
02DAE:  MOVLB  4
02DB0:  MOVF   x29,W
02DB2:  MULLW  0E
02DB4:  MOVF   FF3,W
02DB6:  MOVLB  5
02DB8:  CLRF   x84
02DBA:  MOVWF  x83
02DBC:  MOVLW  0D
02DBE:  ADDWF  x83,W
02DC0:  MOVWF  01
02DC2:  MOVLW  00
02DC4:  ADDWFC x84,W
02DC6:  MOVWF  03
02DC8:  MOVF   01,W
02DCA:  ADDLW  9D
02DCC:  MOVWF  FE9
02DCE:  MOVLW  03
02DD0:  ADDWFC 03,W
02DD2:  MOVWF  FEA
02DD4:  MOVLW  06
02DD6:  MOVWF  FEF
....................       global_current_sprinkler_queue_location--; 
02DD8:  MOVLB  4
02DDA:  DECF   x29,F
....................        
....................       return; 
....................    } 
02DDC:  MOVLB  0
02DDE:  GOTO   3022 (RETURN)
.................... } 
....................  
.................... void clear_message_queue(void) 
.................... { 
....................    // disable conflicting interrupts 
....................    disable_interrupts(INT_CCP4);     
*
041C6:  BCF    F7A.1
....................    memset(&global_message_queue, EMPTY_MESSAGE_QUEUE, sizeof(global_message_queue)); 
041C8:  MOVLW  04
041CA:  MOVWF  FEA
041CC:  MOVLW  A7
041CE:  MOVWF  FE9
041D0:  CLRF   00
041D2:  CLRF   02
041D4:  MOVLW  50
041D6:  MOVWF  01
041D8:  CALL   2274
....................    // disable conflicting interrupts 
....................    disable_interrupts(INT_CCP4); 
041DC:  BCF    F7A.1
041DE:  GOTO   A22C (RETURN)
.................... } 
....................  
.................... void pop_message_queue_and_send_ISR(void)  
.................... // Sends the top of the message queue out, re-adds it to the message stack with a 
.................... //    later send time (and attempt number) and sorts it properly.  Since this is 
.................... //    only called out of CCP4, all functions are ISR functions 
.................... {                       
....................     
....................    uint8_t n;                                                    
....................    struct MessageQueueItem temp_message_queue_item;        
....................  
....................    // no items in the queue (current location is 0-1) 
....................    if (global_current_message_queue_location == 255) 
*
02866:  MOVLB  4
02868:  INCFSZ xF7,W
0286A:  BRA    2870
....................    { 
....................       return;   
0286C:  BRA    2BD2
....................    } 
0286E:  BRA    2BD2
....................    else 
....................    {              
....................       // If it has met or exceeded the maximum number of attempts, delete it off the queue, 
....................       //    set an error bit, and queue an error message. Attempt num is counted from 0 
....................       if (global_message_queue[global_current_message_queue_location].attempt_num >= (MAX_UNSOLICITED_MESSAGE_ATTEMPTS)) 
02870:  MOVF   xF7,W
02872:  MULLW  08
02874:  MOVF   FF3,W
02876:  MOVLB  5
02878:  CLRF   x8D
0287A:  MOVWF  x8C
0287C:  MOVLW  07
0287E:  ADDWF  x8C,W
02880:  MOVWF  01
02882:  MOVLW  00
02884:  ADDWFC x8D,W
02886:  MOVWF  03
02888:  MOVF   01,W
0288A:  ADDLW  A7
0288C:  MOVWF  FE9
0288E:  MOVLW  04
02890:  ADDWFC 03,W
02892:  MOVWF  FEA
02894:  MOVF   FEF,W
02896:  SUBLW  02
02898:  BC    28BA
....................       { 
....................          remove_message_queue_item_ISR(mote_msgSEQ); 
0289A:  MOVFF  366,58D
0289E:  MOVFF  365,58C
028A2:  MOVLB  0
028A4:  BRA    228E
....................          // set an error bit saying a message was missed 
....................          global_error_message_bitfield |= ERR_MSG_UNSOLICITED_MESSAGE_NOT_ACKD; 
028A6:  MOVLB  4
028A8:  BSF    xF8.0
....................          push_message_queue_ISR(MSG_MOTE_ERROR_MSG); 
028AA:  MOVLW  A0
028AC:  MOVLB  5
028AE:  MOVWF  x9F
028B0:  MOVLB  0
028B2:  CALL   0C26
....................       } 
028B6:  BRA    2BD0
028B8:  MOVLB  5
....................       // regular message (not @ max attempts)    
....................       else 
....................       {                
....................          // what message type?  
....................          // resend with unsolicited (0x00 identifier) and it's current message seq 
....................          switch(global_message_queue[global_current_message_queue_location].message_type) 
028BA:  MOVLB  4
028BC:  MOVF   xF7,W
028BE:  MULLW  08
028C0:  MOVF   FF3,W
028C2:  MOVLB  5
028C4:  CLRF   x8D
028C6:  MOVWF  x8C
028C8:  MOVLW  04
028CA:  ADDWF  x8C,W
028CC:  MOVWF  01
028CE:  MOVLW  00
028D0:  ADDWFC x8D,W
028D2:  MOVWF  03
028D4:  MOVF   01,W
028D6:  ADDLW  A7
028D8:  MOVWF  FE9
028DA:  MOVLW  04
028DC:  ADDWFC 03,W
028DE:  MOVWF  FEA
028E0:  MOVF   FEF,W
028E2:  XORLW  91
028E4:  MOVLB  0
028E6:  BZ    2902
028E8:  XORLW  03
028EA:  BZ    293A
028EC:  XORLW  06
028EE:  BZ    2972
028F0:  XORLW  02
028F2:  BZ    29AA
028F4:  XORLW  0E
028F6:  BTFSC  FD8.2
028F8:  BRA    29E2
028FA:  XORLW  38
028FC:  BTFSC  FD8.2
028FE:  BRA    2A1A
02900:  BRA    2A50
....................          { 
....................             case MSG_MOTE_HEALTH_REPORT: 
....................                send_health_report_ISR(MSG_MOTE_UNSOLICITED, global_message_queue[global_current_message_queue_location].msg_seq); 
02902:  MOVLB  4
02904:  MOVF   xF7,W
02906:  MULLW  08
02908:  MOVF   FF3,W
0290A:  MOVLB  5
0290C:  CLRF   x8D
0290E:  MOVWF  x8C
02910:  MOVLW  05
02912:  ADDWF  x8C,W
02914:  MOVWF  01
02916:  MOVLW  00
02918:  ADDWFC x8D,W
0291A:  MOVWF  03
0291C:  MOVF   01,W
0291E:  ADDLW  A7
02920:  MOVWF  FE9
02922:  MOVLW  04
02924:  ADDWFC 03,W
02926:  MOVWF  FEA
02928:  MOVFF  FEC,590
0292C:  MOVF   FED,F
0292E:  MOVFF  FEF,58F
02932:  CLRF   x8E
02934:  MOVLB  0
02936:  BRA    24AA
....................                break;                                                                           
02938:  BRA    2A50
....................             case MSG_MOTE_VALVE_REPORT:    
....................                send_valve_report_ISR(MSG_MOTE_UNSOLICITED, global_message_queue[global_current_message_queue_location].msg_seq); 
0293A:  MOVLB  4
0293C:  MOVF   xF7,W
0293E:  MULLW  08
02940:  MOVF   FF3,W
02942:  MOVLB  5
02944:  CLRF   x8D
02946:  MOVWF  x8C
02948:  MOVLW  05
0294A:  ADDWF  x8C,W
0294C:  MOVWF  01
0294E:  MOVLW  00
02950:  ADDWFC x8D,W
02952:  MOVWF  03
02954:  MOVF   01,W
02956:  ADDLW  A7
02958:  MOVWF  FE9
0295A:  MOVLW  04
0295C:  ADDWFC 03,W
0295E:  MOVWF  FEA
02960:  MOVFF  FEC,590
02964:  MOVF   FED,F
02966:  MOVFF  FEF,58F
0296A:  CLRF   x8E
0296C:  MOVLB  0
0296E:  BRA    2624
....................                break; 
02970:  BRA    2A50
....................             case MSG_MOTE_JOIN_MSG: 
....................                send_join_msg_ISR(MSG_MOTE_UNSOLICITED, global_message_queue[global_current_message_queue_location].msg_seq); 
02972:  MOVLB  4
02974:  MOVF   xF7,W
02976:  MULLW  08
02978:  MOVF   FF3,W
0297A:  MOVLB  5
0297C:  CLRF   x8D
0297E:  MOVWF  x8C
02980:  MOVLW  05
02982:  ADDWF  x8C,W
02984:  MOVWF  01
02986:  MOVLW  00
02988:  ADDWFC x8D,W
0298A:  MOVWF  03
0298C:  MOVF   01,W
0298E:  ADDLW  A7
02990:  MOVWF  FE9
02992:  MOVLW  04
02994:  ADDWFC 03,W
02996:  MOVWF  FEA
02998:  MOVFF  FEC,590
0299C:  MOVF   FED,F
0299E:  MOVFF  FEF,58F
029A2:  CLRF   x8E
029A4:  MOVLB  0
029A6:  BRA    2756
....................                break; 
029A8:  BRA    2A50
....................             case MSG_MOTE_GPS_POINT_MSG: 
....................                send_gps_point_msg_ISR(MSG_MOTE_UNSOLICITED, global_message_queue[global_current_message_queue_location].msg_seq); 
029AA:  MOVLB  4
029AC:  MOVF   xF7,W
029AE:  MULLW  08
029B0:  MOVF   FF3,W
029B2:  MOVLB  5
029B4:  CLRF   x8D
029B6:  MOVWF  x8C
029B8:  MOVLW  05
029BA:  ADDWF  x8C,W
029BC:  MOVWF  01
029BE:  MOVLW  00
029C0:  ADDWFC x8D,W
029C2:  MOVWF  03
029C4:  MOVF   01,W
029C6:  ADDLW  A7
029C8:  MOVWF  FE9
029CA:  MOVLW  04
029CC:  ADDWFC 03,W
029CE:  MOVWF  FEA
029D0:  MOVFF  FEC,590
029D4:  MOVF   FED,F
029D6:  MOVFF  FEF,58F
029DA:  CLRF   x8E
029DC:  MOVLB  0
029DE:  BRA    27B0
....................                break;                                         
029E0:  BRA    2A50
....................             case MSG_MOTE_XDCR_READ_MSG:                                                    
....................                send_pressure_xdcr_msg_ISR(MSG_MOTE_UNSOLICITED, global_message_queue[global_current_message_queue_location].msg_seq); 
029E2:  MOVLB  4
029E4:  MOVF   xF7,W
029E6:  MULLW  08
029E8:  MOVF   FF3,W
029EA:  MOVLB  5
029EC:  CLRF   x8D
029EE:  MOVWF  x8C
029F0:  MOVLW  05
029F2:  ADDWF  x8C,W
029F4:  MOVWF  01
029F6:  MOVLW  00
029F8:  ADDWFC x8D,W
029FA:  MOVWF  03
029FC:  MOVF   01,W
029FE:  ADDLW  A7
02A00:  MOVWF  FE9
02A02:  MOVLW  04
02A04:  ADDWFC 03,W
02A06:  MOVWF  FEA
02A08:  MOVFF  FEC,590
02A0C:  MOVF   FED,F
02A0E:  MOVFF  FEF,58F
02A12:  CLRF   x8E
02A14:  MOVLB  0
02A16:  BRA    27E2
....................                break; 
02A18:  BRA    2A50
....................             case MSG_MOTE_ERROR_MSG:       
....................                send_error_msg_ISR(MSG_MOTE_UNSOLICITED, global_message_queue[global_current_message_queue_location].msg_seq); 
02A1A:  MOVLB  4
02A1C:  MOVF   xF7,W
02A1E:  MULLW  08
02A20:  MOVF   FF3,W
02A22:  MOVLB  5
02A24:  CLRF   x8D
02A26:  MOVWF  x8C
02A28:  MOVLW  05
02A2A:  ADDWF  x8C,W
02A2C:  MOVWF  01
02A2E:  MOVLW  00
02A30:  ADDWFC x8D,W
02A32:  MOVWF  03
02A34:  MOVF   01,W
02A36:  ADDLW  A7
02A38:  MOVWF  FE9
02A3A:  MOVLW  04
02A3C:  ADDWFC 03,W
02A3E:  MOVWF  FEA
02A40:  MOVFF  FEC,590
02A44:  MOVF   FED,F
02A46:  MOVFF  FEF,58F
02A4A:  CLRF   x8E
02A4C:  MOVLB  0
02A4E:  BRA    281C
....................                break; 
....................          } 
....................          // increment attempt number and reschedule it to send at a later time (if not ack'd) 
....................          global_message_queue[global_current_message_queue_location].attempt_num++; 
02A50:  MOVLB  4
02A52:  MOVF   xF7,W
02A54:  MULLW  08
02A56:  MOVF   FF3,W
02A58:  MOVLB  5
02A5A:  CLRF   x8D
02A5C:  MOVWF  x8C
02A5E:  MOVLW  07
02A60:  ADDWF  x8C,W
02A62:  MOVWF  01
02A64:  MOVLW  00
02A66:  ADDWFC x8D,W
02A68:  MOVWF  03
02A6A:  MOVF   01,W
02A6C:  ADDLW  A7
02A6E:  MOVWF  FE9
02A70:  MOVLW  04
02A72:  ADDWFC 03,W
02A74:  MOVWF  FEA
02A76:  INCF   FEF,F
....................          global_message_queue[global_current_message_queue_location].time_to_send+=MESSAGE_RESEND_WAIT_PERIOD; 
02A78:  MOVLB  4
02A7A:  MOVF   xF7,W
02A7C:  MULLW  08
02A7E:  MOVF   FF3,W
02A80:  MOVLB  5
02A82:  CLRF   x8D
02A84:  MOVWF  x8C
02A86:  MOVLW  A7
02A88:  ADDWF  x8C,W
02A8A:  MOVWF  FE9
02A8C:  MOVLW  04
02A8E:  ADDWFC x8D,W
02A90:  MOVWF  FEA
02A92:  MOVLW  3C
02A94:  ADDWF  FEF,W
02A96:  MOVWF  00
02A98:  MOVLW  00
02A9A:  ADDWFC FEC,W
02A9C:  MOVWF  01
02A9E:  MOVLW  00
02AA0:  ADDWFC FEC,W
02AA2:  MOVWF  02
02AA4:  MOVLW  00
02AA6:  ADDWFC FEC,W
02AA8:  MOVF   FED,F
02AAA:  MOVF   FED,F
02AAC:  MOVF   FED,F
02AAE:  MOVFF  00,FEF
02AB2:  MOVFF  01,FEC
02AB6:  MOVFF  02,FEC
02ABA:  MOVWF  FEC
....................           
....................          // starting at the current queue location, sort through the queue 
....................          //    until the item is in the right place 
....................          for (n = global_current_message_queue_location; n > 0; n--)                  
02ABC:  MOVFF  4F7,583
02AC0:  MOVF   x83,F
02AC2:  BTFSC  FD8.2
02AC4:  BRA    2BCE
....................          { 
....................             //if queue items are not sorted properly 
....................             if (global_message_queue[n].time_to_send > global_message_queue[n-1].time_to_send) 
02AC6:  MOVF   x83,W
02AC8:  MULLW  08
02ACA:  MOVF   FF3,W
02ACC:  CLRF   x8D
02ACE:  MOVWF  x8C
02AD0:  MOVLW  A7
02AD2:  ADDWF  x8C,W
02AD4:  MOVWF  FE9
02AD6:  MOVLW  04
02AD8:  ADDWFC x8D,W
02ADA:  MOVWF  FEA
02ADC:  MOVFF  FEF,58E
02AE0:  MOVFF  FEC,58F
02AE4:  MOVFF  FEC,590
02AE8:  MOVFF  FEC,591
02AEC:  MOVLW  01
02AEE:  SUBWF  x83,W
02AF0:  MULLW  08
02AF2:  MOVF   FF3,W
02AF4:  CLRF   x93
02AF6:  MOVWF  x92
02AF8:  MOVLW  A7
02AFA:  ADDWF  x92,W
02AFC:  MOVWF  FE9
02AFE:  MOVLW  04
02B00:  ADDWFC x93,W
02B02:  MOVWF  FEA
02B04:  MOVFF  FEF,00
02B08:  MOVFF  FEC,01
02B0C:  MOVFF  FEC,02
02B10:  MOVFF  FEC,03
02B14:  MOVF   03,W
02B16:  SUBWF  x91,W
02B18:  BNC   2BC4
02B1A:  BNZ   2B32
02B1C:  MOVF   02,W
02B1E:  SUBWF  x90,W
02B20:  BNC   2BC4
02B22:  BNZ   2B32
02B24:  MOVF   01,W
02B26:  SUBWF  x8F,W
02B28:  BNC   2BC4
02B2A:  BNZ   2B32
02B2C:  MOVF   x8E,W
02B2E:  SUBWF  00,W
02B30:  BC    2BC4
....................             { 
....................                //do a swap 
....................                memcpy(&temp_message_queue_item, &global_message_queue[n], sizeof(&temp_message_queue_item)); 
02B32:  MOVF   x83,W
02B34:  MULLW  08
02B36:  MOVF   FF3,W
02B38:  CLRF   03
02B3A:  ADDLW  A7
02B3C:  MOVWF  01
02B3E:  MOVLW  04
02B40:  ADDWFC 03,F
02B42:  MOVFF  03,FE2
02B46:  MOVFF  01,FE1
02B4A:  MOVFF  FE6,584
02B4E:  MOVFF  FE6,585
....................                memcpy(&global_message_queue[n], &global_message_queue[n-1], sizeof(&global_message_queue[n])); 
02B52:  MOVF   x83,W
02B54:  MULLW  08
02B56:  MOVF   FF3,W
02B58:  CLRF   03
02B5A:  ADDLW  A7
02B5C:  MOVWF  01
02B5E:  MOVLW  04
02B60:  ADDWFC 03,F
02B62:  MOVFF  01,58C
02B66:  MOVFF  03,58D
02B6A:  MOVLW  01
02B6C:  SUBWF  x83,W
02B6E:  MULLW  08
02B70:  MOVF   FF3,W
02B72:  CLRF   03
02B74:  ADDLW  A7
02B76:  MOVWF  01
02B78:  MOVLW  04
02B7A:  ADDWFC 03,F
02B7C:  MOVFF  01,58E
02B80:  MOVFF  03,58F
02B84:  MOVFF  58D,FEA
02B88:  MOVFF  58C,FE9
02B8C:  MOVFF  03,FE2
02B90:  MOVFF  01,FE1
02B94:  MOVLW  02
02B96:  MOVWF  01
02B98:  MOVFF  FE6,FEE
02B9C:  DECFSZ 01,F
02B9E:  BRA    2B98
....................                memcpy(&global_message_queue[n-1], &temp_message_queue_item, sizeof(&global_message_queue[n-1])); 
02BA0:  MOVLW  01
02BA2:  SUBWF  x83,W
02BA4:  MULLW  08
02BA6:  MOVF   FF3,W
02BA8:  CLRF   03
02BAA:  ADDLW  A7
02BAC:  MOVWF  01
02BAE:  MOVLW  04
02BB0:  ADDWFC 03,F
02BB2:  MOVFF  03,FEA
02BB6:  MOVFF  01,FE9
02BBA:  MOVFF  584,FEE
02BBE:  MOVFF  585,FEE
....................             } 
02BC2:  BRA    2BCA
....................             //item is in the proper place (assuming queue always sorted properly) 
....................             else 
....................             { 
....................                return; 
02BC4:  MOVLB  4
02BC6:  BRA    2BD2
02BC8:  MOVLB  5
....................             } 
02BCA:  DECF   x83,F
02BCC:  BRA    2AC0
02BCE:  MOVLB  0
02BD0:  MOVLB  4
....................          } 
....................       } 
....................    } 
02BD2:  MOVLB  0
02BD4:  GOTO   2F3C (RETURN)
.................... } 
....................                                        
.................... void push_message_queue(uint8_t message_type) 
.................... // pushes a new item (attempt 0) into the message queue and sorts it. 
.................... // returns 1 if everything is good, 0 if queue is full 
.................... {                 
....................    uint8_t n; 
....................    struct MessageQueueItem temp_message_queue_item;                             
....................     
....................    //if queue is full, return 0                                                      
....................    if (global_current_message_queue_location == (MAX_MESSAGE_QUEUE_ITEMS - 1)) 
*
04FF4:  MOVLB  4
04FF6:  MOVF   xF7,W
04FF8:  SUBLW  09
04FFA:  BNZ   4FFE
....................    {                                             
....................       return;    
04FFC:  BRA    5304
....................    } 
....................                  
....................                                                                                                  
....................    // if you're trying to add an error message...                    
....................    if (message_type == MSG_MOTE_ERROR_MSG) 
04FFE:  MOVLB  5
05000:  MOVF   x54,W
05002:  SUBLW  A0
05004:  BTFSS  FD8.2
05006:  BRA    5138
....................    { 
....................       // check to see if it is the same as the last error message added and if it has happened too recently to resend 
....................       if ((global_error_message_bitfield == last_error_message_sent_bitfield) && ((global_rtc_time - last_error_message_sent_rtc_time) < ERR_MESSAGE_WAIT_PERIOD)) 
05008:  MOVLB  4
0500A:  MOVF   xFC,W
0500C:  SUBWF  xF8,W
0500E:  BNZ   507C
05010:  MOVF   xFD,W
05012:  SUBWF  xF9,W
05014:  BNZ   507C
05016:  MOVF   xFE,W
05018:  SUBWF  xFA,W
0501A:  BNZ   507C
0501C:  MOVF   xFF,W
0501E:  SUBWF  xFB,W
05020:  BNZ   507C
05022:  MOVLB  5
05024:  MOVF   x00,W
05026:  MOVLB  0
05028:  SUBWF  x85,W
0502A:  MOVLB  5
0502C:  MOVWF  x5E
0502E:  MOVF   x01,W
05030:  MOVLB  0
05032:  SUBWFB x86,W
05034:  MOVLB  5
05036:  MOVWF  x5F
05038:  MOVF   x02,W
0503A:  MOVLB  0
0503C:  SUBWFB x87,W
0503E:  MOVLB  5
05040:  MOVWF  x60
05042:  MOVF   x03,W
05044:  MOVLB  0
05046:  SUBWFB x88,W
05048:  MOVLB  5
0504A:  MOVWF  x61
0504C:  MOVF   x61,F
0504E:  BTFSC  FD8.2
05050:  BRA    5056
05052:  MOVLB  4
05054:  BRA    507C
05056:  MOVF   x60,F
05058:  BTFSC  FD8.2
0505A:  BRA    5060
0505C:  MOVLB  4
0505E:  BRA    507C
05060:  MOVF   x5F,F
05062:  BTFSC  FD8.2
05064:  BRA    506A
05066:  MOVLB  4
05068:  BRA    507C
0506A:  MOVF   x5E,W
0506C:  SUBLW  3B
0506E:  BTFSC  FD8.0
05070:  BRA    5076
05072:  MOVLB  4
05074:  BRA    507C
....................       {         
....................          return; 
05076:  MOVLB  4
05078:  BRA    5304
....................       } 
0507A:  BRA    509C
....................       else 
....................       { 
....................          // save the error message bitfield and send time for future comparing and rejecting of duplicate messages 
....................          last_error_message_sent_bitfield = global_error_message_bitfield; 
0507C:  MOVFF  4FB,4FF
05080:  MOVFF  4FA,4FE
05084:  MOVFF  4F9,4FD
05088:  MOVFF  4F8,4FC
....................          last_error_message_sent_rtc_time = global_rtc_time; 
0508C:  MOVFF  88,503
05090:  MOVFF  87,502
05094:  MOVFF  86,501
05098:  MOVFF  85,500
....................       }                              
....................       // look through the current queue 
....................       for (n = global_current_message_queue_location; ((n > 0) && (n != 255)); n--) 
0509C:  MOVFF  4F7,555
050A0:  MOVLB  5
050A2:  MOVF   x55,F
050A4:  BZ    5138
050A6:  INCFSZ x55,W
050A8:  BRA    50AC
050AA:  BRA    5138
....................       { 
....................          // if there is already another error message on the queue, replace it 
....................          if (global_message_queue[n].message_type == MSG_MOTE_ERROR_MSG) 
050AC:  MOVF   x55,W
050AE:  MULLW  08
050B0:  MOVF   FF3,W
050B2:  CLRF   x5F
050B4:  MOVWF  x5E
050B6:  MOVLW  04
050B8:  ADDWF  x5E,W
050BA:  MOVWF  01
050BC:  MOVLW  00
050BE:  ADDWFC x5F,W
050C0:  MOVWF  03
050C2:  MOVF   01,W
050C4:  ADDLW  A7
050C6:  MOVWF  FE9
050C8:  MOVLW  04
050CA:  ADDWFC 03,W
050CC:  MOVWF  FEA
050CE:  MOVF   FEF,W
050D0:  SUBLW  A0
050D2:  BNZ   5134
....................          { 
....................             // increase the mote sequence number (new message) 
....................             // the ack from the previous one will basically get ignored 
....................             global_message_queue[n].msg_seq = ++mote_msgSEQ; 
050D4:  MOVF   x55,W
050D6:  MULLW  08
050D8:  MOVF   FF3,W
050DA:  CLRF   x5F
050DC:  MOVWF  x5E
050DE:  MOVLW  05
050E0:  ADDWF  x5E,W
050E2:  MOVWF  01
050E4:  MOVLW  00
050E6:  ADDWFC x5F,W
050E8:  MOVWF  03
050EA:  MOVF   01,W
050EC:  ADDLW  A7
050EE:  MOVWF  FE9
050F0:  MOVLW  04
050F2:  ADDWFC 03,W
050F4:  MOVWF  FEA
050F6:  MOVLB  3
050F8:  INCF   x65,F
050FA:  BTFSC  FD8.2
050FC:  INCF   x66,F
050FE:  MOVFF  366,FEC
05102:  MOVF   FED,F
05104:  MOVFF  365,FEF
....................             // reset the attempts to 0 (new message) 
....................             global_message_queue[n].attempt_num = 0;      
05108:  MOVLB  5
0510A:  MOVF   x55,W
0510C:  MULLW  08
0510E:  MOVF   FF3,W
05110:  CLRF   x5F
05112:  MOVWF  x5E
05114:  MOVLW  07
05116:  ADDWF  x5E,W
05118:  MOVWF  01
0511A:  MOVLW  00
0511C:  ADDWFC x5F,W
0511E:  MOVWF  03
05120:  MOVF   01,W
05122:  ADDLW  A7
05124:  MOVWF  FE9
05126:  MOVLW  04
05128:  ADDWFC 03,W
0512A:  MOVWF  FEA
0512C:  CLRF   FEF
....................             return; 
0512E:  MOVLB  4
05130:  BRA    5304
05132:  MOVLB  5
....................          } 
05134:  DECF   x55,F
05136:  BRA    50A2
....................       } 
....................    } 
....................       
....................    // increment the queue location and mote message sequence (always first attempt 
....................    //    at a message in this routine 
....................    global_current_message_queue_location++; 
05138:  MOVLB  4
0513A:  INCF   xF7,F
....................    mote_msgSEQ++; 
0513C:  MOVLB  3
0513E:  INCF   x65,F
05140:  BTFSC  FD8.2
05142:  INCF   x66,F
....................     
....................    //set the new item at the top of the queue (will be sorted in a sec) 
....................    global_message_queue[global_current_message_queue_location].time_to_send = global_rtc_time; 
05144:  MOVLB  4
05146:  MOVF   xF7,W
05148:  MULLW  08
0514A:  MOVF   FF3,W
0514C:  MOVLB  5
0514E:  CLRF   x5F
05150:  MOVWF  x5E
05152:  MOVLW  A7
05154:  ADDWF  x5E,W
05156:  MOVWF  FE9
05158:  MOVLW  04
0515A:  ADDWFC x5F,W
0515C:  MOVWF  FEA
0515E:  MOVFF  85,FEF
05162:  MOVFF  86,FEC
05166:  MOVFF  87,FEC
0516A:  MOVFF  88,FEC
....................    global_message_queue[global_current_message_queue_location].message_type = message_type; 
0516E:  MOVLB  4
05170:  MOVF   xF7,W
05172:  MULLW  08
05174:  MOVF   FF3,W
05176:  MOVLB  5
05178:  CLRF   x5F
0517A:  MOVWF  x5E
0517C:  MOVLW  04
0517E:  ADDWF  x5E,W
05180:  MOVWF  01
05182:  MOVLW  00
05184:  ADDWFC x5F,W
05186:  MOVWF  03
05188:  MOVF   01,W
0518A:  ADDLW  A7
0518C:  MOVWF  FE9
0518E:  MOVLW  04
05190:  ADDWFC 03,W
05192:  MOVWF  FEA
05194:  MOVFF  554,FEF
....................    global_message_queue[global_current_message_queue_location].msg_seq = mote_msgSEQ; 
05198:  MOVLB  4
0519A:  MOVF   xF7,W
0519C:  MULLW  08
0519E:  MOVF   FF3,W
051A0:  MOVLB  5
051A2:  CLRF   x5F
051A4:  MOVWF  x5E
051A6:  MOVLW  05
051A8:  ADDWF  x5E,W
051AA:  MOVWF  01
051AC:  MOVLW  00
051AE:  ADDWFC x5F,W
051B0:  MOVWF  03
051B2:  MOVF   01,W
051B4:  ADDLW  A7
051B6:  MOVWF  FE9
051B8:  MOVLW  04
051BA:  ADDWFC 03,W
051BC:  MOVWF  FEA
051BE:  MOVFF  366,FEC
051C2:  MOVF   FED,F
051C4:  MOVFF  365,FEF
....................    global_message_queue[global_current_message_queue_location].attempt_num = 0;    
051C8:  MOVLB  4
051CA:  MOVF   xF7,W
051CC:  MULLW  08
051CE:  MOVF   FF3,W
051D0:  MOVLB  5
051D2:  CLRF   x5F
051D4:  MOVWF  x5E
051D6:  MOVLW  07
051D8:  ADDWF  x5E,W
051DA:  MOVWF  01
051DC:  MOVLW  00
051DE:  ADDWFC x5F,W
051E0:  MOVWF  03
051E2:  MOVF   01,W
051E4:  ADDLW  A7
051E6:  MOVWF  FE9
051E8:  MOVLW  04
051EA:  ADDWFC 03,W
051EC:  MOVWF  FEA
051EE:  CLRF   FEF
....................           
....................    //starting at the new current queue location, sort through the queue 
....................    //until the new item is in the right place 
....................    for (n = global_current_message_queue_location; n > 0; n--)                    
051F0:  MOVFF  4F7,555
051F4:  MOVF   x55,F
051F6:  BTFSC  FD8.2
051F8:  BRA    5302
....................    {                                                
....................       //if queue items are not sorted properly 
....................       if (global_message_queue[n].time_to_send > global_message_queue[n-1].time_to_send) 
051FA:  MOVF   x55,W
051FC:  MULLW  08
051FE:  MOVF   FF3,W
05200:  CLRF   x5F
05202:  MOVWF  x5E
05204:  MOVLW  A7
05206:  ADDWF  x5E,W
05208:  MOVWF  FE9
0520A:  MOVLW  04
0520C:  ADDWFC x5F,W
0520E:  MOVWF  FEA
05210:  MOVFF  FEF,560
05214:  MOVFF  FEC,561
05218:  MOVFF  FEC,562
0521C:  MOVFF  FEC,563
05220:  MOVLW  01
05222:  SUBWF  x55,W
05224:  MULLW  08
05226:  MOVF   FF3,W
05228:  CLRF   x65
0522A:  MOVWF  x64
0522C:  MOVLW  A7
0522E:  ADDWF  x64,W
05230:  MOVWF  FE9
05232:  MOVLW  04
05234:  ADDWFC x65,W
05236:  MOVWF  FEA
05238:  MOVFF  FEF,00
0523C:  MOVFF  FEC,01
05240:  MOVFF  FEC,02
05244:  MOVFF  FEC,03
05248:  MOVF   03,W
0524A:  SUBWF  x63,W
0524C:  BNC   52F8
0524E:  BNZ   5266
05250:  MOVF   02,W
05252:  SUBWF  x62,W
05254:  BNC   52F8
05256:  BNZ   5266
05258:  MOVF   01,W
0525A:  SUBWF  x61,W
0525C:  BNC   52F8
0525E:  BNZ   5266
05260:  MOVF   x60,W
05262:  SUBWF  00,W
05264:  BC    52F8
....................       { 
....................          //do a swap 
....................          memcpy(&temp_message_queue_item, &global_message_queue[n], sizeof(&temp_message_queue_item)); 
05266:  MOVF   x55,W
05268:  MULLW  08
0526A:  MOVF   FF3,W
0526C:  CLRF   03
0526E:  ADDLW  A7
05270:  MOVWF  01
05272:  MOVLW  04
05274:  ADDWFC 03,F
05276:  MOVFF  03,FE2
0527A:  MOVFF  01,FE1
0527E:  MOVFF  FE6,556
05282:  MOVFF  FE6,557
....................          memcpy(&global_message_queue[n], &global_message_queue[n-1], sizeof(&global_message_queue[n])); 
05286:  MOVF   x55,W
05288:  MULLW  08
0528A:  MOVF   FF3,W
0528C:  CLRF   03
0528E:  ADDLW  A7
05290:  MOVWF  01
05292:  MOVLW  04
05294:  ADDWFC 03,F
05296:  MOVFF  01,55E
0529A:  MOVFF  03,55F
0529E:  MOVLW  01
052A0:  SUBWF  x55,W
052A2:  MULLW  08
052A4:  MOVF   FF3,W
052A6:  CLRF   03
052A8:  ADDLW  A7
052AA:  MOVWF  01
052AC:  MOVLW  04
052AE:  ADDWFC 03,F
052B0:  MOVFF  01,560
052B4:  MOVFF  03,561
052B8:  MOVFF  55F,FEA
052BC:  MOVFF  55E,FE9
052C0:  MOVFF  03,FE2
052C4:  MOVFF  01,FE1
052C8:  MOVLW  02
052CA:  MOVWF  01
052CC:  MOVFF  FE6,FEE
052D0:  DECFSZ 01,F
052D2:  BRA    52CC
....................          memcpy(&global_message_queue[n-1], &temp_message_queue_item, sizeof(&global_message_queue[n-1])); 
052D4:  MOVLW  01
052D6:  SUBWF  x55,W
052D8:  MULLW  08
052DA:  MOVF   FF3,W
052DC:  CLRF   03
052DE:  ADDLW  A7
052E0:  MOVWF  01
052E2:  MOVLW  04
052E4:  ADDWFC 03,F
052E6:  MOVFF  03,FEA
052EA:  MOVFF  01,FE9
052EE:  MOVFF  556,FEE
052F2:  MOVFF  557,FEE
....................       } 
052F6:  BRA    52FE
....................       //item is in the proper place (assuming queue always sorted properly) 
....................       else    
....................       {    
....................          return; 
052F8:  MOVLB  4
052FA:  BRA    5304
052FC:  MOVLB  5
....................       } 
052FE:  DECF   x55,F
05300:  BRA    51F4
05302:  MOVLB  4
....................    }     
....................    return; 
05304:  MOVLB  0
05306:  RETURN 0
.................... }                        
....................  
.................... void push_message_queue_ISR(uint8_t message_type) 
.................... // pushes a new item (attempt 0) into the message queue and sorts it. 
.................... // returns 1 if everything is good, 0 if queue is full 
.................... // message queue ISR only gets called in the pop message queue ISR so it's only resends of messages 
.................... //    (don't have to worry about error messages getting screwed up because of duplicate rejection logic) 
.................... { 
....................    uint8_t n; 
....................    struct MessageQueueItem temp_message_queue_item; 
....................    
....................    //if queue is full, return 0 
....................    if (global_current_message_queue_location == (MAX_MESSAGE_QUEUE_ITEMS - 1)) 
*
00C26:  MOVLB  4
00C28:  MOVF   xF7,W
00C2A:  SUBLW  09
00C2C:  BNZ   0C30
....................    { 
....................       return; 
00C2E:  BRA    0E9E
....................    } 
....................     
....................    // if you're trying to add an error message... 
....................    if (message_type == MSG_MOTE_ERROR_MSG) 
00C30:  MOVLB  5
00C32:  MOVF   x9F,W
00C34:  SUBLW  A0
00C36:  BNZ   0CD2
....................    { 
....................       // look through the current queue 
....................       for (n = global_current_message_queue_location; ((n > 0) && (n != 255)); n--) 
00C38:  MOVFF  4F7,5A0
00C3C:  MOVF   xA0,F
00C3E:  BZ    0CD2
00C40:  INCFSZ xA0,W
00C42:  BRA    0C46
00C44:  BRA    0CD2
....................       { 
....................          // if there is already another error message on the queue, replace it 
....................          if (global_message_queue[n].message_type == MSG_MOTE_ERROR_MSG) 
00C46:  MOVF   xA0,W
00C48:  MULLW  08
00C4A:  MOVF   FF3,W
00C4C:  CLRF   xAA
00C4E:  MOVWF  xA9
00C50:  MOVLW  04
00C52:  ADDWF  xA9,W
00C54:  MOVWF  01
00C56:  MOVLW  00
00C58:  ADDWFC xAA,W
00C5A:  MOVWF  03
00C5C:  MOVF   01,W
00C5E:  ADDLW  A7
00C60:  MOVWF  FE9
00C62:  MOVLW  04
00C64:  ADDWFC 03,W
00C66:  MOVWF  FEA
00C68:  MOVF   FEF,W
00C6A:  SUBLW  A0
00C6C:  BNZ   0CCE
....................          { 
....................             // increase the mote sequence number (new message) 
....................             // the ack from the previous one will basically get ignored 
....................             global_message_queue[n].msg_seq = ++mote_msgSEQ; 
00C6E:  MOVF   xA0,W
00C70:  MULLW  08
00C72:  MOVF   FF3,W
00C74:  CLRF   xAA
00C76:  MOVWF  xA9
00C78:  MOVLW  05
00C7A:  ADDWF  xA9,W
00C7C:  MOVWF  01
00C7E:  MOVLW  00
00C80:  ADDWFC xAA,W
00C82:  MOVWF  03
00C84:  MOVF   01,W
00C86:  ADDLW  A7
00C88:  MOVWF  FE9
00C8A:  MOVLW  04
00C8C:  ADDWFC 03,W
00C8E:  MOVWF  FEA
00C90:  MOVLB  3
00C92:  INCF   x65,F
00C94:  BTFSC  FD8.2
00C96:  INCF   x66,F
00C98:  MOVFF  366,FEC
00C9C:  MOVF   FED,F
00C9E:  MOVFF  365,FEF
....................             // reset the attempts to 0 (new message) 
....................             global_message_queue[n].attempt_num = 0; 
00CA2:  MOVLB  5
00CA4:  MOVF   xA0,W
00CA6:  MULLW  08
00CA8:  MOVF   FF3,W
00CAA:  CLRF   xAA
00CAC:  MOVWF  xA9
00CAE:  MOVLW  07
00CB0:  ADDWF  xA9,W
00CB2:  MOVWF  01
00CB4:  MOVLW  00
00CB6:  ADDWFC xAA,W
00CB8:  MOVWF  03
00CBA:  MOVF   01,W
00CBC:  ADDLW  A7
00CBE:  MOVWF  FE9
00CC0:  MOVLW  04
00CC2:  ADDWFC 03,W
00CC4:  MOVWF  FEA
00CC6:  CLRF   FEF
....................             return; 
00CC8:  MOVLB  4
00CCA:  BRA    0E9E
00CCC:  MOVLB  5
....................          } 
00CCE:  DECF   xA0,F
00CD0:  BRA    0C3C
....................       } 
....................    } 
....................     
....................    // increment the queue location and mote message sequence (always first attempt 
....................    //    at a message in this routine 
....................    global_current_message_queue_location++; 
00CD2:  MOVLB  4
00CD4:  INCF   xF7,F
....................    mote_msgSEQ++; 
00CD6:  MOVLB  3
00CD8:  INCF   x65,F
00CDA:  BTFSC  FD8.2
00CDC:  INCF   x66,F
....................     
....................    //set the new item at the top of the queue (will be sorted in a sec) 
....................    global_message_queue[global_current_message_queue_location].time_to_send = global_rtc_time; 
00CDE:  MOVLB  4
00CE0:  MOVF   xF7,W
00CE2:  MULLW  08
00CE4:  MOVF   FF3,W
00CE6:  MOVLB  5
00CE8:  CLRF   xAA
00CEA:  MOVWF  xA9
00CEC:  MOVLW  A7
00CEE:  ADDWF  xA9,W
00CF0:  MOVWF  FE9
00CF2:  MOVLW  04
00CF4:  ADDWFC xAA,W
00CF6:  MOVWF  FEA
00CF8:  MOVFF  85,FEF
00CFC:  MOVFF  86,FEC
00D00:  MOVFF  87,FEC
00D04:  MOVFF  88,FEC
....................    global_message_queue[global_current_message_queue_location].message_type = message_type; 
00D08:  MOVLB  4
00D0A:  MOVF   xF7,W
00D0C:  MULLW  08
00D0E:  MOVF   FF3,W
00D10:  MOVLB  5
00D12:  CLRF   xAA
00D14:  MOVWF  xA9
00D16:  MOVLW  04
00D18:  ADDWF  xA9,W
00D1A:  MOVWF  01
00D1C:  MOVLW  00
00D1E:  ADDWFC xAA,W
00D20:  MOVWF  03
00D22:  MOVF   01,W
00D24:  ADDLW  A7
00D26:  MOVWF  FE9
00D28:  MOVLW  04
00D2A:  ADDWFC 03,W
00D2C:  MOVWF  FEA
00D2E:  MOVFF  59F,FEF
....................    global_message_queue[global_current_message_queue_location].msg_seq = mote_msgSEQ; 
00D32:  MOVLB  4
00D34:  MOVF   xF7,W
00D36:  MULLW  08
00D38:  MOVF   FF3,W
00D3A:  MOVLB  5
00D3C:  CLRF   xAA
00D3E:  MOVWF  xA9
00D40:  MOVLW  05
00D42:  ADDWF  xA9,W
00D44:  MOVWF  01
00D46:  MOVLW  00
00D48:  ADDWFC xAA,W
00D4A:  MOVWF  03
00D4C:  MOVF   01,W
00D4E:  ADDLW  A7
00D50:  MOVWF  FE9
00D52:  MOVLW  04
00D54:  ADDWFC 03,W
00D56:  MOVWF  FEA
00D58:  MOVFF  366,FEC
00D5C:  MOVF   FED,F
00D5E:  MOVFF  365,FEF
....................    global_message_queue[global_current_message_queue_location].attempt_num = 0; 
00D62:  MOVLB  4
00D64:  MOVF   xF7,W
00D66:  MULLW  08
00D68:  MOVF   FF3,W
00D6A:  MOVLB  5
00D6C:  CLRF   xAA
00D6E:  MOVWF  xA9
00D70:  MOVLW  07
00D72:  ADDWF  xA9,W
00D74:  MOVWF  01
00D76:  MOVLW  00
00D78:  ADDWFC xAA,W
00D7A:  MOVWF  03
00D7C:  MOVF   01,W
00D7E:  ADDLW  A7
00D80:  MOVWF  FE9
00D82:  MOVLW  04
00D84:  ADDWFC 03,W
00D86:  MOVWF  FEA
00D88:  CLRF   FEF
....................     
....................    //starting at the new current queue location, sort through the queue 
....................    //until the new item is in the right place 
....................    for (n = global_current_message_queue_location; n > 0; n--) 
00D8A:  MOVFF  4F7,5A0
00D8E:  MOVF   xA0,F
00D90:  BTFSC  FD8.2
00D92:  BRA    0E9C
....................    { 
....................       //if queue items are not sorted properly 
....................       if (global_message_queue[n].time_to_send > global_message_queue[n-1].time_to_send) 
00D94:  MOVF   xA0,W
00D96:  MULLW  08
00D98:  MOVF   FF3,W
00D9A:  CLRF   xAA
00D9C:  MOVWF  xA9
00D9E:  MOVLW  A7
00DA0:  ADDWF  xA9,W
00DA2:  MOVWF  FE9
00DA4:  MOVLW  04
00DA6:  ADDWFC xAA,W
00DA8:  MOVWF  FEA
00DAA:  MOVFF  FEF,5AB
00DAE:  MOVFF  FEC,5AC
00DB2:  MOVFF  FEC,5AD
00DB6:  MOVFF  FEC,5AE
00DBA:  MOVLW  01
00DBC:  SUBWF  xA0,W
00DBE:  MULLW  08
00DC0:  MOVF   FF3,W
00DC2:  CLRF   xB0
00DC4:  MOVWF  xAF
00DC6:  MOVLW  A7
00DC8:  ADDWF  xAF,W
00DCA:  MOVWF  FE9
00DCC:  MOVLW  04
00DCE:  ADDWFC xB0,W
00DD0:  MOVWF  FEA
00DD2:  MOVFF  FEF,00
00DD6:  MOVFF  FEC,01
00DDA:  MOVFF  FEC,02
00DDE:  MOVFF  FEC,03
00DE2:  MOVF   03,W
00DE4:  SUBWF  xAE,W
00DE6:  BNC   0E92
00DE8:  BNZ   0E00
00DEA:  MOVF   02,W
00DEC:  SUBWF  xAD,W
00DEE:  BNC   0E92
00DF0:  BNZ   0E00
00DF2:  MOVF   01,W
00DF4:  SUBWF  xAC,W
00DF6:  BNC   0E92
00DF8:  BNZ   0E00
00DFA:  MOVF   xAB,W
00DFC:  SUBWF  00,W
00DFE:  BC    0E92
....................       { 
....................          //do a swap 
....................          memcpy(&temp_message_queue_item, &global_message_queue[n], sizeof(&temp_message_queue_item)); 
00E00:  MOVF   xA0,W
00E02:  MULLW  08
00E04:  MOVF   FF3,W
00E06:  CLRF   03
00E08:  ADDLW  A7
00E0A:  MOVWF  01
00E0C:  MOVLW  04
00E0E:  ADDWFC 03,F
00E10:  MOVFF  03,FE2
00E14:  MOVFF  01,FE1
00E18:  MOVFF  FE6,5A1
00E1C:  MOVFF  FE6,5A2
....................          memcpy(&global_message_queue[n], &global_message_queue[n-1], sizeof(&global_message_queue[n])); 
00E20:  MOVF   xA0,W
00E22:  MULLW  08
00E24:  MOVF   FF3,W
00E26:  CLRF   03
00E28:  ADDLW  A7
00E2A:  MOVWF  01
00E2C:  MOVLW  04
00E2E:  ADDWFC 03,F
00E30:  MOVFF  01,5A9
00E34:  MOVFF  03,5AA
00E38:  MOVLW  01
00E3A:  SUBWF  xA0,W
00E3C:  MULLW  08
00E3E:  MOVF   FF3,W
00E40:  CLRF   03
00E42:  ADDLW  A7
00E44:  MOVWF  01
00E46:  MOVLW  04
00E48:  ADDWFC 03,F
00E4A:  MOVFF  01,5AB
00E4E:  MOVFF  03,5AC
00E52:  MOVFF  5AA,FEA
00E56:  MOVFF  5A9,FE9
00E5A:  MOVFF  03,FE2
00E5E:  MOVFF  01,FE1
00E62:  MOVLW  02
00E64:  MOVWF  01
00E66:  MOVFF  FE6,FEE
00E6A:  DECFSZ 01,F
00E6C:  BRA    0E66
....................          memcpy(&global_message_queue[n-1], &temp_message_queue_item, sizeof(&global_message_queue[n-1])); 
00E6E:  MOVLW  01
00E70:  SUBWF  xA0,W
00E72:  MULLW  08
00E74:  MOVF   FF3,W
00E76:  CLRF   03
00E78:  ADDLW  A7
00E7A:  MOVWF  01
00E7C:  MOVLW  04
00E7E:  ADDWFC 03,F
00E80:  MOVFF  03,FEA
00E84:  MOVFF  01,FE9
00E88:  MOVFF  5A1,FEE
00E8C:  MOVFF  5A2,FEE
....................       } 
00E90:  BRA    0E98
....................       //item is in the proper place (assuming queue always sorted properly) 
....................       else 
....................       { 
....................          return; 
00E92:  MOVLB  4
00E94:  BRA    0E9E
00E96:  MOVLB  5
....................       } 
00E98:  DECF   xA0,F
00E9A:  BRA    0D8E
00E9C:  MOVLB  4
....................    } 
....................    return; 
00E9E:  MOVLB  0
00EA0:  RETURN 0
.................... } 
....................  
.................... void remove_message_queue_item(uint16_t msg_seq) 
.................... { 
.................... // Finds the message with the passed msg_seq and removes it from the queue, 
.................... //    shifting all other messages in the queue up 
.................... // Returns 1 if message removed, 0 if not found 
.................... // This function is ONLY run as a result of an ack'd unsolicted message                      
....................  
....................    uint8_t n, m; 
....................     
....................    // no items in the queue (current location is 0-1) 
....................    if (global_current_message_queue_location == 255) 
*
05C52:  MOVLB  4
05C54:  INCFSZ xF7,W
05C56:  BRA    5C5A
....................    {   
....................  
....................       return;   
05C58:  BRA    5DAA
....................    } 
....................     
....................    // search through the message queue from 0 to the current top of queue 
....................    for (n = 0; n <= global_current_message_queue_location; n++) 
05C5A:  MOVLB  5
05C5C:  CLRF   x54
05C5E:  MOVF   x54,W
05C60:  MOVLB  4
05C62:  SUBWF  xF7,W
05C64:  BTFSS  FD8.0
05C66:  BRA    5DAA
....................    { 
....................       // if you find the matching message 
....................       if (global_message_queue[n].msg_seq == msg_seq) 
05C68:  MOVLB  5
05C6A:  MOVF   x54,W
05C6C:  MULLW  08
05C6E:  MOVF   FF3,W
05C70:  CLRF   x57
05C72:  MOVWF  x56
05C74:  MOVLW  05
05C76:  ADDWF  x56,W
05C78:  MOVWF  01
05C7A:  MOVLW  00
05C7C:  ADDWFC x57,W
05C7E:  MOVWF  03
05C80:  MOVF   01,W
05C82:  ADDLW  A7
05C84:  MOVWF  FE9
05C86:  MOVLW  04
05C88:  ADDWFC 03,W
05C8A:  MOVWF  FEA
05C8C:  MOVFF  FEC,557
05C90:  MOVF   FED,F
05C92:  MOVFF  FEF,556
05C96:  MOVF   x52,W
05C98:  SUBWF  x56,W
05C9A:  BTFSS  FD8.2
05C9C:  BRA    5DA4
05C9E:  MOVF   x53,W
05CA0:  SUBWF  x57,W
05CA2:  BTFSS  FD8.2
05CA4:  BRA    5DA4
....................       { 
....................          // since this is only run from ack'd messages, we can assume this 
....................          //    means the error message was recieved and we can clear the error 
....................          //    bitfield 
....................          if (global_message_queue[n].message_type == MSG_MOTE_ERROR_MSG) 
05CA6:  MOVF   x54,W
05CA8:  MULLW  08
05CAA:  MOVF   FF3,W
05CAC:  CLRF   x57
05CAE:  MOVWF  x56
05CB0:  MOVLW  04
05CB2:  ADDWF  x56,W
05CB4:  MOVWF  01
05CB6:  MOVLW  00
05CB8:  ADDWFC x57,W
05CBA:  MOVWF  03
05CBC:  MOVF   01,W
05CBE:  ADDLW  A7
05CC0:  MOVWF  FE9
05CC2:  MOVLW  04
05CC4:  ADDWFC 03,W
05CC6:  MOVWF  FEA
05CC8:  MOVF   FEF,W
05CCA:  SUBLW  A0
05CCC:  BNZ   5CDA
....................          { 
....................             global_error_message_bitfield = 0; 
05CCE:  MOVLB  4
05CD0:  CLRF   xFB
05CD2:  CLRF   xFA
05CD4:  CLRF   xF9
05CD6:  CLRF   xF8
05CD8:  MOVLB  5
....................          } 
....................          // shift everything over 1 place starting by overwriting the item 
....................          //    to remove and ending by copying the top of the queue to the next item 
....................          for (m = n; m < (MAX_MESSAGE_QUEUE_ITEMS - 1); m++) 
05CDA:  MOVFF  554,555
05CDE:  MOVF   x55,W
05CE0:  SUBLW  08
05CE2:  BNC   5D6A
....................          { 
....................             memcpy(&global_message_queue[n], global_message_queue[n+1], sizeof(&global_message_queue[n])); 
05CE4:  MOVF   x54,W
05CE6:  MULLW  08
05CE8:  MOVF   FF3,W
05CEA:  CLRF   03
05CEC:  ADDLW  A7
05CEE:  MOVWF  01
05CF0:  MOVLW  04
05CF2:  ADDWFC 03,F
05CF4:  MOVFF  01,556
05CF8:  MOVFF  03,557
05CFC:  MOVLW  01
05CFE:  ADDWF  x54,W
05D00:  MULLW  08
05D02:  MOVF   FF3,W
05D04:  CLRF   03
05D06:  ADDLW  A7
05D08:  MOVWF  FE9
05D0A:  MOVLW  04
05D0C:  ADDWFC 03,W
05D0E:  MOVWF  FEA
05D10:  MOVF   FEE,F
05D12:  MOVF   FEE,F
05D14:  MOVF   FEE,F
05D16:  MOVF   FEE,F
05D18:  MOVF   FEE,F
05D1A:  MOVF   FEE,F
05D1C:  MOVFF  FEC,55F
05D20:  MOVF   FED,F
05D22:  MOVFF  FEF,55E
05D26:  MOVF   FED,F
05D28:  MOVFF  FEF,55D
05D2C:  MOVF   FED,F
05D2E:  MOVFF  FEF,55C
05D32:  MOVF   FED,F
05D34:  MOVFF  FEF,55B
05D38:  MOVF   FED,F
05D3A:  MOVFF  FEF,55A
05D3E:  MOVF   FED,F
05D40:  MOVFF  FEF,559
05D44:  MOVF   FED,F
05D46:  MOVFF  FEF,558
05D4A:  MOVFF  557,FEA
05D4E:  MOVFF  01,FE9
05D52:  MOVFF  559,FE2
05D56:  MOVFF  558,FE1
05D5A:  MOVLW  02
05D5C:  MOVWF  01
05D5E:  MOVFF  FE6,FEE
05D62:  DECFSZ 01,F
05D64:  BRA    5D5E
05D66:  INCF   x55,F
05D68:  BRA    5CDE
....................          } 
....................          // clear out the last item 
....................          memset(&global_message_queue[global_current_message_queue_location],EMPTY_MESSAGE_QUEUE,sizeof(&global_message_queue[global_current_message_queue_location])); 
05D6A:  MOVLB  4
05D6C:  MOVF   xF7,W
05D6E:  MULLW  08
05D70:  MOVF   FF3,W
05D72:  CLRF   03
05D74:  ADDLW  A7
05D76:  MOVWF  01
05D78:  MOVLW  04
05D7A:  ADDWFC 03,F
05D7C:  MOVFF  01,556
05D80:  MOVLB  5
05D82:  MOVFF  03,557
05D86:  MOVFF  03,FEA
05D8A:  MOVFF  01,FE9
05D8E:  CLRF   00
05D90:  CLRF   02
05D92:  MOVLW  02
05D94:  MOVWF  01
05D96:  MOVLB  0
05D98:  CALL   2274
....................          // decrement the message queue current position 
....................          global_current_message_queue_location--;  
05D9C:  MOVLB  4
05D9E:  DECF   xF7,F
....................          return; 
05DA0:  BRA    5DAA
05DA2:  MOVLB  5
....................       } 
05DA4:  INCF   x54,F
05DA6:  BRA    5C5E
05DA8:  MOVLB  4
....................    } 
....................    return;                      
05DAA:  MOVLB  0
05DAC:  GOTO   718E (RETURN)
.................... } 
....................  
.................... void remove_message_queue_item_ISR(uint16_t msg_seq) 
.................... { 
.................... // Finds the message with the passed msg_seq and removes it from the queue, 
.................... //    shifting all other messages in the queue up 
.................... // Returns 1 if message removed, 0 if not found 
.................... // This function is ONLY run as a result of a message not getting ack'd after 
.................... //    being resent numerous times 
....................  
....................    uint8_t n, m; 
....................  
....................    // no items in the queue (current location is 0-1) 
....................    if (global_current_message_queue_location == 255) 
*
0228E:  MOVLB  4
02290:  INCFSZ xF7,W
02292:  BRA    2296
....................    { 
....................       return;   
02294:  BRA    23AC
....................    } 
....................     
....................    // search through the message queue from 0 to the current top of queue 
....................    for (n = 0; n <= global_current_message_queue_location; n++) 
02296:  MOVLB  5
02298:  CLRF   x8E
0229A:  MOVF   x8E,W
0229C:  MOVLB  4
0229E:  SUBWF  xF7,W
022A0:  BTFSS  FD8.0
022A2:  BRA    23AC
....................    { 
....................       // if you find the matching message 
....................       if (global_message_queue[n].msg_seq == msg_seq) 
022A4:  MOVLB  5
022A6:  MOVF   x8E,W
022A8:  MULLW  08
022AA:  MOVF   FF3,W
022AC:  CLRF   x91
022AE:  MOVWF  x90
022B0:  MOVLW  05
022B2:  ADDWF  x90,W
022B4:  MOVWF  01
022B6:  MOVLW  00
022B8:  ADDWFC x91,W
022BA:  MOVWF  03
022BC:  MOVF   01,W
022BE:  ADDLW  A7
022C0:  MOVWF  FE9
022C2:  MOVLW  04
022C4:  ADDWFC 03,W
022C6:  MOVWF  FEA
022C8:  MOVFF  FEC,591
022CC:  MOVF   FED,F
022CE:  MOVFF  FEF,590
022D2:  MOVF   x8C,W
022D4:  SUBWF  x90,W
022D6:  BNZ   23A6
022D8:  MOVF   x8D,W
022DA:  SUBWF  x91,W
022DC:  BNZ   23A6
....................       { 
....................          // shift everything over 1 place starting by overwriting the item 
....................          //    to remove and ending by copying the top of the queue to the next item 
....................          for (m = n; m < (MAX_MESSAGE_QUEUE_ITEMS - 1); m++) 
022DE:  MOVFF  58E,58F
022E2:  MOVF   x8F,W
022E4:  SUBLW  08
022E6:  BNC   236E
....................          { 
....................             memcpy(&global_message_queue[n], global_message_queue[n+1], sizeof(&global_message_queue[n])); 
022E8:  MOVF   x8E,W
022EA:  MULLW  08
022EC:  MOVF   FF3,W
022EE:  CLRF   03
022F0:  ADDLW  A7
022F2:  MOVWF  01
022F4:  MOVLW  04
022F6:  ADDWFC 03,F
022F8:  MOVFF  01,590
022FC:  MOVFF  03,591
02300:  MOVLW  01
02302:  ADDWF  x8E,W
02304:  MULLW  08
02306:  MOVF   FF3,W
02308:  CLRF   03
0230A:  ADDLW  A7
0230C:  MOVWF  FE9
0230E:  MOVLW  04
02310:  ADDWFC 03,W
02312:  MOVWF  FEA
02314:  MOVF   FEE,F
02316:  MOVF   FEE,F
02318:  MOVF   FEE,F
0231A:  MOVF   FEE,F
0231C:  MOVF   FEE,F
0231E:  MOVF   FEE,F
02320:  MOVFF  FEC,599
02324:  MOVF   FED,F
02326:  MOVFF  FEF,598
0232A:  MOVF   FED,F
0232C:  MOVFF  FEF,597
02330:  MOVF   FED,F
02332:  MOVFF  FEF,596
02336:  MOVF   FED,F
02338:  MOVFF  FEF,595
0233C:  MOVF   FED,F
0233E:  MOVFF  FEF,594
02342:  MOVF   FED,F
02344:  MOVFF  FEF,593
02348:  MOVF   FED,F
0234A:  MOVFF  FEF,592
0234E:  MOVFF  591,FEA
02352:  MOVFF  01,FE9
02356:  MOVFF  593,FE2
0235A:  MOVFF  592,FE1
0235E:  MOVLW  02
02360:  MOVWF  01
02362:  MOVFF  FE6,FEE
02366:  DECFSZ 01,F
02368:  BRA    2362
0236A:  INCF   x8F,F
0236C:  BRA    22E2
....................          } 
....................          // clear out the last item 
....................          memset(&global_message_queue[global_current_message_queue_location],EMPTY_MESSAGE_QUEUE,sizeof(&global_message_queue[global_current_message_queue_location])); 
0236E:  MOVLB  4
02370:  MOVF   xF7,W
02372:  MULLW  08
02374:  MOVF   FF3,W
02376:  CLRF   03
02378:  ADDLW  A7
0237A:  MOVWF  01
0237C:  MOVLW  04
0237E:  ADDWFC 03,F
02380:  MOVFF  01,590
02384:  MOVLB  5
02386:  MOVFF  03,591
0238A:  MOVFF  03,FEA
0238E:  MOVFF  01,FE9
02392:  CLRF   00
02394:  CLRF   02
02396:  MOVLW  02
02398:  MOVWF  01
0239A:  MOVLB  0
0239C:  RCALL  2274
....................          // decrement the message queue current position 
....................          global_current_message_queue_location--; 
0239E:  MOVLB  4
023A0:  DECF   xF7,F
....................          return; 
023A2:  BRA    23AC
023A4:  MOVLB  5
....................       } 
023A6:  INCF   x8E,F
023A8:  BRA    229A
023AA:  MOVLB  4
....................    } 
....................    return; 
023AC:  MOVLB  0
023AE:  GOTO   28A6 (RETURN)
.................... } 
....................     
....................  
.................... #include "util.h" 
.................... /* This file contains all utility functions 
....................  * 
....................  * 
....................  */ 
....................  
.................... /****************************************/ 
.................... void flash_leds(uint8_t num_of_flashes)                           
.................... { 
....................    uint8_t  n; 
....................     
....................    for (n = 0; n < num_of_flashes; n++) 
....................    { 
....................       LED1_ON 
....................       LED2_ON 
....................       setup_T0_int(T0_50MS); 
....................       while (!TMR0IF); 
....................        
....................       LED1_OFF    
....................       LED2_OFF                       
....................       if (n == (num_of_flashes - 1)) 
....................       { 
....................          return; 
....................       } 
....................       setup_T0_int(T0_50MS); 
....................       while (!TMR0IF);  
....................    }       
.................... } 
.................... void flash_leds_ISR(uint8_t num_of_flashes) 
.................... { 
....................    uint8_t  n; 
....................     
....................    for (n = 0; n < num_of_flashes; n++) 
....................    { 
....................       LED1_ON 
....................       LED2_ON 
....................       setup_T4_int(T4_64MS); 
....................       while (!TMR4IF); 
....................       LED1_OFF 
....................       LED2_OFF 
....................       setup_T4_int(T4_64MS); 
....................       while (!TMR4IF); 
....................    }       
.................... } 
....................  
....................  
.................... void flash_led_1(uint8_t num_of_flashes) 
.................... { 
....................    uint8_t  n; 
....................     
....................    for (n = 0; n < num_of_flashes; n++) 
....................    { 
....................       LED1_ON 
....................       setup_T0_int(T0_100MS); 
....................       while (!TMR0IF); 
....................        
....................       LED1_OFF 
....................       setup_T0_int(T0_100MS); 
....................       while (!TMR0IF);  
....................    }       
.................... } 
....................  
.................... void flash_led_2(uint8_t num_of_flashes) 
.................... { 
....................    uint8_t  n; 
....................     
....................    for (n = 0; n < num_of_flashes; n++) 
*
082AA:  MOVLB  5
082AC:  CLRF   x4C
082AE:  MOVF   x4B,W
082B0:  SUBWF  x4C,W
082B2:  BC    82E4
....................    { 
....................       LED2_ON 
082B4:  BCF    F89.2
....................       setup_T0_int(T0_100MS); 
082B6:  MOVLW  FE
082B8:  MOVWF  x69
082BA:  MOVLW  7A
082BC:  MOVWF  x68
082BE:  MOVLB  0
082C0:  CALL   3844
....................       while (!TMR0IF); 
082C4:  BTFSS  FF2.2
082C6:  BRA    82C4
....................        
....................       LED2_OFF 
082C8:  BSF    F89.2
....................       setup_T0_int(T0_100MS); 
082CA:  MOVLW  FE
082CC:  MOVLB  5
082CE:  MOVWF  x69
082D0:  MOVLW  7A
082D2:  MOVWF  x68
082D4:  MOVLB  0
082D6:  CALL   3844
....................       while (!TMR0IF);  
082DA:  BTFSS  FF2.2
082DC:  BRA    82DA
082DE:  MOVLB  5
082E0:  INCF   x4C,F
082E2:  BRA    82AE
....................    }       
082E4:  MOVLB  0
082E6:  GOTO   ABAA (RETURN)
.................... } 
....................  
.................... void happy_lites(void) 
.................... { 
.................... // blink the two leds in a fashion to let the operator know, e.g., 
.................... // that the SW1-initiated search process was successful 
....................    uint8_t  n; 
....................     
....................    for (n=0; n<4; n++) 
*
04E34:  MOVLB  5
04E36:  CLRF   x63
04E38:  MOVF   x63,W
04E3A:  SUBLW  03
04E3C:  BNC   4E7E
....................    { 
....................       LED1_ON 
04E3E:  BCF    F62.4
04E40:  MOVLW  E7
04E42:  MOVWF  F93
04E44:  BCF    F8A.4
....................        
....................       setup_T0_int(T0_250MS); 
04E46:  MOVLW  FC
04E48:  MOVWF  x69
04E4A:  MOVLW  30
04E4C:  MOVWF  x68
04E4E:  MOVLB  0
04E50:  CALL   3844
....................       while (!TMR0IF); 
04E54:  BTFSS  FF2.2
04E56:  BRA    4E54
....................        
....................       LED1_OFF 
04E58:  MOVLW  F7
04E5A:  MOVWF  F93
04E5C:  BSF    FF2.3
04E5E:  BSF    F62.4
....................       LED2_ON 
04E60:  BCF    F89.2
....................        
....................       setup_T0_int(T0_250MS); 
04E62:  MOVLW  FC
04E64:  MOVLB  5
04E66:  MOVWF  x69
04E68:  MOVLW  30
04E6A:  MOVWF  x68
04E6C:  MOVLB  0
04E6E:  CALL   3844
....................       while (!TMR0IF); 
04E72:  BTFSS  FF2.2
04E74:  BRA    4E72
....................        
....................       LED2_OFF 
04E76:  BSF    F89.2
04E78:  MOVLB  5
04E7A:  INCF   x63,F
04E7C:  BRA    4E38
....................    } 
04E7E:  MOVLB  0
04E80:  RETURN 0
.................... } 
....................  
.................... char *word_to_4dig_new (uint16_t xword) 
.................... { 
....................    /* Takes a uint16 and converts it to a 4 digit result 
....................     * that is stored in a static char pointer 
....................     */ 
....................      
....................    uint16_t temp_u16; 
....................    static char result[4]; 
....................    ldiv_t      lidiv_temp; 
....................    div_t       idiv_temp; 
....................     
....................    if (xword > 9999) 
....................       return 0; 
....................    else 
....................    {    
....................       lidiv_temp=ldiv(xword,1000); 
....................       result[3] = '0' + lidiv_temp.quot; 
....................       temp_u16 = lidiv_temp.rem; 
....................       lidiv_temp=ldiv(temp_u16,(uint16_t)(100)); 
....................       result[2] = '0' + lidiv_temp.quot; 
....................       idiv_temp = div((uint8_t)(lidiv_temp.rem),10); 
....................       result[1] = '0' + idiv_temp.quot; 
....................       result[0] = '0' + idiv_temp.rem; 
....................       return result; 
....................    } 
.................... } 
....................  
.................... // this routine ain't done yet 
.................... uint16_t convert_rpm_to_period(uint16_t rpm) 
.................... { 
....................    uint16_t period; 
....................    return period; 
.................... } 
.................... uint16_t convert_period_to_rpm(uint16_t period) 
.................... { 
....................    uint32_t rpm_32; 
....................    uint16_t rpm_16; 
....................     
....................    rpm_32 = CCP_PER_RPM/(make32(0,0,make8(period,1), make8(period,0))); 
*
05DF2:  MOVFF  558,55F
05DF6:  MOVFF  557,560
05DFA:  MOVLB  5
05DFC:  CLRF   x64
05DFE:  CLRF   x63
05E00:  MOVFF  558,562
05E04:  MOVFF  557,561
05E08:  BCF    FD8.1
05E0A:  CLRF   19
05E0C:  BTFSC  FF2.7
05E0E:  BSF    19.7
05E10:  BCF    FF2.7
05E12:  MOVLW  99
05E14:  MOVWF  xA4
05E16:  MOVWF  xA3
05E18:  MOVWF  xA2
05E1A:  MOVLW  9A
05E1C:  MOVWF  xA1
05E1E:  MOVFF  564,5A8
05E22:  MOVFF  563,5A7
05E26:  MOVFF  558,5A6
05E2A:  MOVFF  557,5A5
05E2E:  MOVLB  0
05E30:  CALL   2526
05E34:  BTFSC  19.7
05E36:  BSF    FF2.7
05E38:  MOVFF  03,55C
05E3C:  MOVFF  02,55B
05E40:  MOVFF  01,55A
05E44:  MOVFF  00,559
....................    rpm_16 = make16(make8(rpm_32,3), make8(rpm_32,2)); 
05E48:  MOVFF  55C,55E
05E4C:  MOVFF  55B,55D
....................    if (bit_test(rpm_32, 15)) rpm_16++;  
05E50:  MOVLB  5
05E52:  BTFSS  x5A.7
05E54:  BRA    5E5C
05E56:  INCF   x5D,F
05E58:  BTFSC  FD8.2
05E5A:  INCF   x5E,F
....................    return rpm_16; 
05E5C:  MOVFF  55D,01
05E60:  MOVFF  55E,02
05E64:  MOVLB  0
05E66:  RETURN 0
.................... } 
.................... uint16_t convert_period_to_rpm_ISR(uint16_t period) 
.................... { 
....................    uint32_t rpm_32; 
....................    uint16_t rpm_16; 
....................     
....................    rpm_32 = CCP_PER_RPM/(make32(0,0,make8(period,1), make8(period,0))); 
*
025BA:  MOVFF  594,59B
025BE:  MOVFF  593,59C
025C2:  MOVLB  5
025C4:  CLRF   xA0
025C6:  CLRF   x9F
025C8:  MOVFF  594,59E
025CC:  MOVFF  593,59D
025D0:  BCF    FD8.1
025D2:  MOVLW  99
025D4:  MOVWF  xA4
025D6:  MOVWF  xA3
025D8:  MOVWF  xA2
025DA:  MOVLW  9A
025DC:  MOVWF  xA1
025DE:  MOVFF  5A0,5A8
025E2:  MOVFF  59F,5A7
025E6:  MOVFF  594,5A6
025EA:  MOVFF  593,5A5
025EE:  MOVLB  0
025F0:  RCALL  2526
025F2:  MOVFF  03,598
025F6:  MOVFF  02,597
025FA:  MOVFF  01,596
025FE:  MOVFF  00,595
....................    rpm_16 = make16(make8(rpm_32,3), make8(rpm_32,2)); 
02602:  MOVFF  598,59A
02606:  MOVFF  597,599
....................    if (bit_test(rpm_32, 15)) rpm_16++;  
0260A:  MOVLB  5
0260C:  BTFSS  x96.7
0260E:  BRA    2616
02610:  INCF   x99,F
02612:  BTFSC  FD8.2
02614:  INCF   x9A,F
....................    return rpm_16; 
02616:  MOVFF  599,01
0261A:  MOVFF  59A,02
0261E:  MOVLB  0
02620:  GOTO   2722 (RETURN)
.................... } 
.................... uint8_t  hi2asc(uint8_t xbyte) 
.................... { 
....................    xbyte >>= 4; 
*
03276:  MOVLB  5
03278:  SWAPF  x64,F
0327A:  MOVLW  0F
0327C:  ANDWF  x64,F
....................    if (xbyte < 0x0A) 
0327E:  MOVF   x64,W
03280:  SUBLW  09
03282:  BNC   328A
....................       xbyte += 0x30; 
03284:  MOVLW  30
03286:  ADDWF  x64,F
03288:  BRA    328E
....................    else 
....................       xbyte += 0x37; 
0328A:  MOVLW  37
0328C:  ADDWF  x64,F
....................    return xbyte; 
0328E:  MOVFF  564,01
03292:  MOVLB  0
03294:  RETURN 0
.................... } 
....................  
....................  
.................... uint8_t  lo2asc(uint8_t xbyte) 
.................... { 
....................    xbyte &= 0x0F; 
03296:  MOVLW  0F
03298:  MOVLB  5
0329A:  ANDWF  x64,F
....................    if (xbyte < 0x0A) 
0329C:  MOVF   x64,W
0329E:  SUBLW  09
032A0:  BNC   32A8
....................       xbyte += 0x30; 
032A2:  MOVLW  30
032A4:  ADDWF  x64,F
032A6:  BRA    32AC
....................    else 
....................       xbyte += 0x37; 
032A8:  MOVLW  37
032AA:  ADDWF  x64,F
....................    return xbyte; 
032AC:  MOVFF  564,01
032B0:  MOVLB  0
032B2:  RETURN 0
.................... } 
....................  
....................  
.................... void main() 
*
09F0C:  CLRF   FF8
09F0E:  BCF    FF0.7
09F10:  BCF    FF1.0
09F12:  BCF    FA2.3
09F14:  BCF    FA2.6
09F16:  BSF    F7C.0
09F18:  BCF    F7C.1
09F1A:  BSF    F7C.2
09F1C:  BSF    FD0.7
09F1E:  BSF    07.7
09F20:  BCF    FB8.3
09F22:  MOVLW  01
09F24:  MOVWF  FAF
09F26:  MOVLW  A6
09F28:  MOVWF  FAC
09F2A:  MOVLW  90
09F2C:  MOVWF  FAB
09F2E:  CLRF   4A
09F30:  CLRF   49
09F32:  CLRF   48
09F34:  CLRF   47
09F36:  CLRF   4C
09F38:  CLRF   4B
09F3A:  CLRF   4D
09F3C:  CLRF   4E
09F3E:  CLRF   54
09F40:  CLRF   55
09F42:  CLRF   59
09F44:  CLRF   58
09F46:  CLRF   57
09F48:  CLRF   56
09F4A:  CLRF   5D
09F4C:  CLRF   5C
09F4E:  CLRF   5B
09F50:  CLRF   5A
09F52:  CLRF   5F
09F54:  CLRF   5E
09F56:  CLRF   x61
09F58:  CLRF   x60
09F5A:  CLRF   x63
09F5C:  CLRF   x62
09F5E:  CLRF   x65
09F60:  CLRF   x64
09F62:  CLRF   x67
09F64:  CLRF   x66
09F66:  CLRF   x69
09F68:  CLRF   x68
09F6A:  CLRF   x6B
09F6C:  CLRF   x6A
09F6E:  CLRF   x6D
09F70:  CLRF   x6C
09F72:  CLRF   x6F
09F74:  CLRF   x6E
09F76:  CLRF   x83
09F78:  MOVLW  01
09F7A:  MOVWF  x84
09F7C:  CLRF   x88
09F7E:  CLRF   x87
09F80:  CLRF   x86
09F82:  CLRF   x85
09F84:  CLRF   x8C
09F86:  CLRF   x8B
09F88:  CLRF   x8A
09F8A:  CLRF   x89
09F8C:  CLRF   x90
09F8E:  CLRF   x8F
09F90:  CLRF   x8E
09F92:  CLRF   x8D
09F94:  CLRF   x94
09F96:  CLRF   x93
09F98:  CLRF   x92
09F9A:  CLRF   x91
09F9C:  CLRF   x96
09F9E:  CLRF   x95
09FA0:  CLRF   xA7
09FA2:  CLRF   xA9
09FA4:  CLRF   xA8
09FA6:  CLRF   xAD
09FA8:  MOVLW  64
09FAA:  MOVWF  xAC
09FAC:  CLRF   xB1
09FAE:  CLRF   xB0
09FB0:  CLRF   xAF
09FB2:  CLRF   xAE
09FB4:  CLRF   xB3
09FB6:  CLRF   xB2
09FB8:  MOVLW  01
09FBA:  MOVWF  xB5
09FBC:  MOVLW  90
09FBE:  MOVWF  xB4
09FC0:  CLRF   xB7
09FC2:  CLRF   xB6
09FC4:  MOVLW  01
09FC6:  MOVWF  xB9
09FC8:  MOVLW  90
09FCA:  MOVWF  xB8
09FCC:  MOVLW  64
09FCE:  MOVWF  xBA
09FD0:  MOVWF  xBB
09FD2:  CLRF   xBD
09FD4:  CLRF   xBC
09FD6:  CLRF   xBF
09FD8:  CLRF   xBE
09FDA:  CLRF   xC0
09FDC:  MOVLW  40
09FDE:  MOVWF  xC2
09FE0:  CLRF   xC1
09FE2:  MOVWF  xC4
09FE4:  CLRF   xC3
09FE6:  MOVLW  05
09FE8:  MOVWF  xC6
09FEA:  CLRF   xC5
09FEC:  MOVWF  xC8
09FEE:  CLRF   xC7
09FF0:  CLRF   xCA
09FF2:  CLRF   xC9
09FF4:  CLRF   xCE
09FF6:  CLRF   xCD
09FF8:  CLRF   xCC
09FFA:  CLRF   xCB
09FFC:  CLRF   xCF
09FFE:  MOVLW  20
0A000:  MOVWF  xD1
0A002:  CLRF   xD0
0A004:  SETF   xD3
0A006:  SETF   xD2
0A008:  CLRF   xD7
0A00A:  CLRF   xD6
0A00C:  CLRF   xD5
0A00E:  CLRF   xD4
0A010:  MOVLB  3
0A012:  CLRF   x51
0A014:  CLRF   x52
0A016:  CLRF   x5F
0A018:  CLRF   x62
0A01A:  CLRF   x63
0A01C:  CLRF   x64
0A01E:  CLRF   x66
0A020:  CLRF   x65
0A022:  MOVLW  04
0A024:  MOVWF  x68
0A026:  MOVLW  CD
0A028:  MOVWF  x67
0A02A:  CLRF   x6A
0A02C:  CLRF   x69
0A02E:  CLRF   x6B
0A030:  CLRF   x6C
0A032:  CLRF   x6D
0A034:  SETF   x82
0A036:  SETF   x9C
0A038:  MOVLB  4
0A03A:  SETF   x29
0A03C:  SETF   00
0A03E:  SETF   01
0A040:  SETF   02
0A042:  SETF   03
0A044:  MOVFF  03,42D
0A048:  MOVFF  02,42C
0A04C:  MOVFF  01,42B
0A050:  MOVFF  00,42A
0A054:  SETF   xA6
0A056:  SETF   xF7
0A058:  CLRF   xFB
0A05A:  CLRF   xFA
0A05C:  CLRF   xF9
0A05E:  CLRF   xF8
0A060:  CLRF   xFF
0A062:  CLRF   xFE
0A064:  CLRF   xFD
0A066:  CLRF   xFC
0A068:  MOVLB  5
0A06A:  CLRF   x03
0A06C:  CLRF   x02
0A06E:  CLRF   x01
0A070:  CLRF   x00
0A072:  SETF   x04
0A074:  SETF   x05
0A076:  MOVLW  10
0A078:  MOVWF  x07
0A07A:  CLRF   x06
0A07C:  MOVLW  70
0A07E:  MOVWF  x09
0A080:  CLRF   x08
0A082:  CLRF   x0B
0A084:  MOVLW  18
0A086:  MOVWF  x0A
0A088:  CLRF   x0D
0A08A:  MOVLW  14
0A08C:  MOVWF  x0C
0A08E:  CLRF   x0F
0A090:  MOVWF  x0E
0A092:  CLRF   x11
0A094:  MOVLW  18
0A096:  MOVWF  x10
0A098:  CLRF   x13
0A09A:  MOVLW  13
0A09C:  MOVWF  x12
0A09E:  CLRF   x15
0A0A0:  MOVWF  x14
0A0A2:  CLRF   x17
0A0A4:  MOVLW  1E
0A0A6:  MOVWF  x16
0A0A8:  MOVLW  40
0A0AA:  MOVWF  x19
0A0AC:  CLRF   x18
0A0AE:  MOVLW  70
0A0B0:  MOVWF  x1B
0A0B2:  CLRF   x1A
0A0B4:  MOVLW  08
0A0B6:  MOVWF  x1C
0A0B8:  MOVLW  50
0A0BA:  MOVWF  x1E
0A0BC:  CLRF   x1D
0A0BE:  MOVLW  10
0A0C0:  MOVWF  x20
0A0C2:  CLRF   x1F
0A0C4:  CLRF   x22
0A0C6:  MOVLW  02
0A0C8:  MOVWF  x21
0A0CA:  CLRF   x24
0A0CC:  MOVLW  78
0A0CE:  MOVWF  x23
0A0D0:  MOVLW  04
0A0D2:  MOVWF  x26
0A0D4:  MOVLW  B0
0A0D6:  MOVWF  x25
0A0D8:  CLRF   x27
0A0DA:  BCF    FB8.3
0A0DC:  MOVLW  01
0A0DE:  MOVWF  FAF
0A0E0:  MOVLW  A6
0A0E2:  MOVWF  FAC
0A0E4:  MOVLW  90
0A0E6:  MOVWF  FAB
0A0E8:  BCF    FCB.0
0A0EA:  BCF    FCB.1
0A0EC:  BCF    FCB.3
0A0EE:  MOVLW  06
0A0F0:  MOVWF  FC8
0A0F2:  MOVLW  28
0A0F4:  MOVWF  FC6
0A0F6:  BSF    FC7.7
0A0F8:  BCF    FC7.6
0A0FA:  CLRF   x3A
0A0FC:  CLRF   x39
0A0FE:  CLRF   x3C
0A100:  CLRF   x3B
0A102:  CLRF   x3D
0A104:  CLRF   x3E
0A106:  MOVLW  01
0A108:  MOVWF  x3F
0A10A:  CLRF   x45
0A10C:  CLRF   x44
0A10E:  CLRF   x47
0A110:  CLRF   x46
0A112:  MOVLB  F
0A114:  CLRF   x38
0A116:  CLRF   x39
0A118:  CLRF   x3A
0A11A:  CLRF   x3B
0A11C:  CLRF   x3C
0A11E:  MOVLB  1
0A120:  CLRF   x88
0A122:  CLRF   F77
0A124:  CLRF   F78
0A126:  CLRF   F79
0A128:  MOVLW  05
0A12A:  MOVWF  36
0A12C:  MOVLW  CB
0A12E:  MOVWF  35
0A130:  MOVLW  09
0A132:  MOVLB  5
0A134:  MOVWF  xCC
0A136:  MOVLW  69
0A138:  MOVWF  xCB
0A13A:  CLRF   xCE
0A13C:  CLRF   xCD
0A13E:  MOVLB  0
0A140:  BRA    A186
0A142:  DATA 02,00
0A144:  DATA 2F,00
0A146:  DATA 00,10
0A148:  DATA 00,37
0A14A:  DATA 44,55
0A14C:  DATA 53,54
0A14E:  DATA 4E,45
0A150:  DATA 54,57
0A152:  DATA 4F,52
0A154:  DATA 4B,53
0A156:  DATA 52,4F
0A158:  DATA 43,4B
0A15A:  DATA 05,00
0A15C:  DATA 4F,41
0A15E:  DATA 30,30
0A160:  DATA 30,00
0A162:  DATA 10,40
0A164:  DATA 97,00
0A166:  DATA 14,43
0A168:  DATA 6E,00
0A16A:  DATA 19,43
0A16C:  DATA 83,00
0A16E:  DATA 8C,43
0A170:  DATA 9D,00
0A172:  DATA 78,44
0A174:  DATA 2E,00
0A176:  DATA 50,44
0A178:  DATA A7,00
0A17A:  DATA 11,45
0A17C:  DATA 28,00
0A17E:  DATA 04,05
0A180:  DATA 40,00
0A182:  DATA 00,00
0A184:  DATA 00,00
0A186:  MOVLW  00
0A188:  MOVWF  FF8
0A18A:  MOVLW  A1
0A18C:  MOVWF  FF7
0A18E:  MOVLW  42
0A190:  MOVWF  FF6
0A192:  TBLRD*+
0A194:  MOVF   FF5,W
0A196:  MOVWF  00
0A198:  XORLW  00
0A19A:  BZ    A1C2
0A19C:  TBLRD*+
0A19E:  MOVF   FF5,W
0A1A0:  MOVWF  01
0A1A2:  BTFSC  FE8.7
0A1A4:  BRA    A1B0
0A1A6:  ANDLW  0F
0A1A8:  MOVWF  FEA
0A1AA:  TBLRD*+
0A1AC:  MOVF   FF5,W
0A1AE:  MOVWF  FE9
0A1B0:  BTFSC  01.6
0A1B2:  TBLRD*+
0A1B4:  BTFSS  01.6
0A1B6:  TBLRD*+
0A1B8:  MOVF   FF5,W
0A1BA:  MOVWF  FEE
0A1BC:  DCFSNZ 00,F
0A1BE:  BRA    A192
0A1C0:  BRA    A1B4
0A1C2:  CLRF   FF8
0A1C4:  MOVLB  5
0A1C6:  CLRF   x48
.................... {                                                          
....................    // priority queue item that is to be executed 
....................    uint8_t     priority_queue_item_to_execute = EMPTY_PRIORITY_QUEUE;     
....................    // valve setting that is stored when free spin rate is performed (so you can return to it afterwards) 
....................    uint16_t    pre_fsr_valve_setting;                                          
....................                                         
....................    // set system state to init 
....................    write_system_state(SYSTEM_INIT);               
0A1C8:  CLRF   x4B
0A1CA:  MOVLB  0
0A1CC:  CALL   3208
....................                 
....................    // initalize oscillator and timing of rs232, i2c, delay 
....................    osc_init();          
0A1D0:  GOTO   326A
....................  
....................    // initalize all variables (not really needed as they are initalized properly when CPU is rebooted)                                                         
....................    //vars_init();                   
....................     
....................    // store string version of firmware version in global_firmware_version_string                                                            
....................    global_firmware_version_string[0] = hi2asc(make8(FIRMWARE_VERSION,1)); 
0A1D4:  MOVLW  E3
0A1D6:  MOVLB  5
0A1D8:  MOVWF  x64
0A1DA:  MOVLB  0
0A1DC:  CALL   3276
0A1E0:  MOVFF  01,4F
....................    global_firmware_version_string[1] = lo2asc(make8(FIRMWARE_VERSION,1)); 
0A1E4:  MOVLW  E3
0A1E6:  MOVLB  5
0A1E8:  MOVWF  x64
0A1EA:  MOVLB  0
0A1EC:  CALL   3296
0A1F0:  MOVFF  01,50
....................    global_firmware_version_string[2] = hi2asc(make8(FIRMWARE_VERSION,0));       
0A1F4:  MOVLW  14
0A1F6:  MOVLB  5
0A1F8:  MOVWF  x64
0A1FA:  MOVLB  0
0A1FC:  CALL   3276
0A200:  MOVFF  01,51
....................    global_firmware_version_string[3] = lo2asc(make8(FIRMWARE_VERSION,0));    
0A204:  MOVLW  14
0A206:  MOVLB  5
0A208:  MOVWF  x64
0A20A:  MOVLB  0
0A20C:  CALL   3296
0A210:  MOVFF  01,52
....................  
....................    // grab all eeprom values (e.g. vlv cal, sprinkler number, vlv position) 
....................    read_all_eeprom_values();    
0A214:  GOTO   3482
....................     
....................    // load all changeable eeprom variables  
....................    read_all_eeprom_variables();         
0A218:  GOTO   35BA
....................                                 
....................    // initalize all periphs, timers, ccps, ints    
....................    periph_init(); 
0A21C:  GOTO   4016
....................                                      
....................    // clear queues     
....................    clear_priority_queue();                                  
0A220:  GOTO   4142
....................    clear_time_queue(); 
0A224:  GOTO   4166
....................    clear_message_queue();       
0A228:  GOTO   41C6
....................     
....................    // command queue is not needed/used yet as it is used in conjunction with the "modulation" scheme 
....................    //allocate_command_queue(); 
....................    //clear_command_queue(); 
....................     
....................    // startup rtc, turn on gen_rpm, enable dust chip (check for communication) 
....................    start_rtc();    
0A22C:  GOTO   41E2
....................    setup_gen_rpm();         
0A230:  GOTO   4214
....................    mote_init(); 
0A234:  GOTO   4416
....................                           
....................    // if cold start was done, reset mote    
....................    if (global_previous_shutdown_cause == COLD_RESTART_REQUEST) 
0A238:  MOVF   4E,W
0A23A:  SUBLW  0A
0A23C:  BNZ   A242
....................    { 
....................       mote_reset();           
0A23E:  CALL   4670
....................    }          
....................                           
....................    // DELETE?                              
....................    enable_interrupts(GLOBAL);                      
0A242:  MOVLW  C0
0A244:  IORWF  FF2,F
....................                                        
....................    // if SW1 is asserted during boot, trigger searching alogrithm                
....................    if (!input(SW1n))              
0A246:  BTFSC  F81.4
0A248:  BRA    A2BC
....................    {                                             
....................       // set the system state up for searching for a network (not run) 
....................       write_system_state(SYSTEM_SEARCHING_FOR_NETWORK); 
0A24A:  MOVLW  20
0A24C:  MOVLB  5
0A24E:  MOVWF  x4B
0A250:  MOVLB  0
0A252:  CALL   3208
....................       strcpy (global_temp_line_buff, "Setup Manager..."); 
0A256:  CLRF   FEA
0A258:  MOVLW  70
0A25A:  MOVWF  FE9
0A25C:  MOVLW  00
0A25E:  CALL   0632
0A262:  TBLRD*-
0A264:  TBLRD*+
0A266:  MOVF   FF5,W
0A268:  MOVWF  FEE
0A26A:  IORLW  00
0A26C:  BNZ   A264
....................       LCD_line1(global_temp_line_buff); 
0A26E:  MOVLB  5
0A270:  CLRF   x64
0A272:  MOVLW  70
0A274:  MOVWF  x63
0A276:  MOVLB  0
0A278:  CALL   3932
....................       strcpy (global_temp_line_buff, "  Release SW1   "); 
0A27C:  CLRF   FEA
0A27E:  MOVLW  70
0A280:  MOVWF  FE9
0A282:  MOVLW  00
0A284:  CALL   0654
0A288:  TBLRD*-
0A28A:  TBLRD*+
0A28C:  MOVF   FF5,W
0A28E:  MOVWF  FEE
0A290:  IORLW  00
0A292:  BNZ   A28A
....................       LCD_line2(global_temp_line_buff);      
0A294:  MOVLB  5
0A296:  CLRF   x64
0A298:  MOVLW  70
0A29A:  MOVWF  x63
0A29C:  MOVLB  0
0A29E:  CALL   398C
....................       // wait for switch release  
....................       while (!input(SW1n));       
0A2A2:  BTFSS  F81.4
0A2A4:  BRA    A2A2
....................       // delay lcd update for a tiny bit                                                                                                                              
....................       global_skip_lcd_update_count = 1; 
0A2A6:  MOVLW  01
0A2A8:  MOVWF  x83
....................       // first part of search alorithm sequence                                                                                       
....................       PUSH_PRIORITY_QUEUE_MACRO(SEARCH_FOR_STRONGEST_1);                  
0A2AA:  BCF    F7A.1
0A2AC:  MOVLW  B1
0A2AE:  MOVLB  5
0A2B0:  MOVWF  x52
0A2B2:  MOVLB  0
0A2B4:  CALL   46CA
0A2B8:  BSF    F7A.1
....................    }                                  
0A2BA:  BRA    A3B0
....................     
....................    // normal behavior, check mote status.  Join network if necessary.                                                                                                       
....................    else  
....................    {                                  
....................       // Fun startup splash screen (and clear startup screen) 
....................       //LCD_startup_splash();        
....................       //LCD_clear();                   
....................        
....................       // enable RB4 button press functionality       
....................       setup_rb4_int();         
0A2BC:  GOTO   4790
....................                                                                                     
....................       // dispaly battery voltage (line 0) and restart/shutdown cause (line 1) on screen for a second  
....................       LCD_display_battery_voltage(0);     
0A2C0:  MOVLB  5
0A2C2:  CLRF   x4B
0A2C4:  MOVLB  0
0A2C6:  GOTO   4D86
....................       LCD_display_shutdown_cause(1);             
0A2CA:  MOVLW  01
0A2CC:  MOVLB  5
0A2CE:  MOVWF  x4B
0A2D0:  MOVLB  0
0A2D2:  GOTO   4DDA
....................         
....................       // global_skip_lcd_update_count is our way of letting things stay on the lcd for a moment 
....................       //    You set it to the number of times to skip an LCD update + 1 
....................       //    e.g. setting it to 2 means things stay on the screen for 1-2 seconds and then they are cleared 
....................       //    e.g. setting it to 1 means things are cleared right away 
....................       //    e.g. setting it to 0 (or not setting it) means the LCD screen is just overwritten by LCD update 
....................       global_skip_lcd_update_count = 2;         
0A2D6:  MOVLW  02
0A2D8:  MOVWF  x83
....................        
....................       // all periphs should be initalized (except mote), so system should be ready to run         
....................       write_system_state(SYSTEM_INIT); 
0A2DA:  MOVLB  5
0A2DC:  CLRF   x4B
0A2DE:  MOVLB  0
0A2E0:  CALL   3208
....................                                        
....................       // flash the leds to help identify motes    
....................       happy_lites(); 
0A2E4:  CALL   4E34
....................        
....................       // check mote state. If it needs to connect, it will react as it should            
....................       PUSH_TIME_QUEUE_MACRO(global_rtc_time + 5, CHECK_MOTE_STATE);   
0A2E8:  BCF    F7A.1
0A2EA:  MOVLW  05
0A2EC:  ADDWF  x85,W
0A2EE:  MOVLB  5
0A2F0:  MOVWF  x4B
0A2F2:  MOVLW  00
0A2F4:  MOVLB  0
0A2F6:  ADDWFC x86,W
0A2F8:  MOVLB  5
0A2FA:  MOVWF  x4C
0A2FC:  MOVLW  00
0A2FE:  MOVLB  0
0A300:  ADDWFC x87,W
0A302:  MOVLB  5
0A304:  MOVWF  x4D
0A306:  MOVLW  00
0A308:  MOVLB  0
0A30A:  ADDWFC x88,W
0A30C:  MOVLB  5
0A30E:  MOVWF  x4E
0A310:  MOVWF  x59
0A312:  MOVFF  54D,558
0A316:  MOVFF  54C,557
0A31A:  MOVFF  54B,556
0A31E:  MOVLW  B4
0A320:  MOVWF  x5A
0A322:  MOVLB  0
0A324:  CALL   4422
0A328:  BSF    F7A.1
....................        
....................       // check mote info 
....................       PUSH_TIME_QUEUE_MACRO(global_rtc_time + 10, UPDATE_MOTE_NETWORK_INFO); 
0A32A:  BCF    F7A.1
0A32C:  MOVLW  0A
0A32E:  ADDWF  x85,W
0A330:  MOVLB  5
0A332:  MOVWF  x4B
0A334:  MOVLW  00
0A336:  MOVLB  0
0A338:  ADDWFC x86,W
0A33A:  MOVLB  5
0A33C:  MOVWF  x4C
0A33E:  MOVLW  00
0A340:  MOVLB  0
0A342:  ADDWFC x87,W
0A344:  MOVLB  5
0A346:  MOVWF  x4D
0A348:  MOVLW  00
0A34A:  MOVLB  0
0A34C:  ADDWFC x88,W
0A34E:  MOVLB  5
0A350:  MOVWF  x4E
0A352:  MOVWF  x59
0A354:  MOVFF  54D,558
0A358:  MOVFF  54C,557
0A35C:  MOVFF  54B,556
0A360:  MOVLW  A4
0A362:  MOVWF  x5A
0A364:  MOVLB  0
0A366:  CALL   4422
0A36A:  BSF    F7A.1
....................        
.................... #IFDEF OPEN_VALVE_TO_SETPT_AT_BOOT       
....................       PUSH_TIME_QUEUE_MACRO(global_rtc_time + 15, CLOSE_VALVE_UNKNOWN_STATE); 
0A36C:  BCF    F7A.1
0A36E:  MOVLW  0F
0A370:  ADDWF  x85,W
0A372:  MOVLB  5
0A374:  MOVWF  x4B
0A376:  MOVLW  00
0A378:  MOVLB  0
0A37A:  ADDWFC x86,W
0A37C:  MOVLB  5
0A37E:  MOVWF  x4C
0A380:  MOVLW  00
0A382:  MOVLB  0
0A384:  ADDWFC x87,W
0A386:  MOVLB  5
0A388:  MOVWF  x4D
0A38A:  MOVLW  00
0A38C:  MOVLB  0
0A38E:  ADDWFC x88,W
0A390:  MOVLB  5
0A392:  MOVWF  x4E
0A394:  MOVWF  x59
0A396:  MOVFF  54D,558
0A39A:  MOVFF  54C,557
0A39E:  MOVFF  54B,556
0A3A2:  MOVLW  3F
0A3A4:  MOVWF  x5A
0A3A6:  MOVLB  0
0A3A8:  CALL   4422
0A3AC:  BSF    F7A.1
.................... #ENDIF                                      
....................    // setup WDT for 1 second (plenty long for the control loop (~64ms)) to catch system lockups 
....................       setup_wdt(WDT_1S);                       
0A3AE:  BSF    FD1.0
....................    } 
....................                                                               
....................    // start the queue/control loop timer 
....................    setup_T2_int(T2_64MS);     
0A3B0:  MOVLB  5
0A3B2:  SETF   x4B
0A3B4:  MOVLB  0
0A3B6:  CALL   4E82
....................            
....................                 
....................    while(1)                    
....................    {                                                                                                             
.................... ////////////////////Start of Priority Queue Handling/////////////////////////// 
....................                                                                        
....................       // Timer 2 is used to signal the priority queue to check for another item 
....................       //    to execute. This is only done once every 64ms to NOT keep the  
....................       //    system in a state with the interrupts disabled all the time. 
....................       // Timer 2 is also used to time the control loop.  How often the set point 
....................       //    is re-evaluated and adjustments are made to the actual values is 
....................       //    controlled by control_loop_delay_cycles_left within update_control_loop() 
....................        
....................       // if it is time to check priority queue/control loop   
....................       if (TMR2IF)  
0A3BA:  BTFSS  F9E.1
0A3BC:  GOTO   AFD0
....................       {                              
....................          // reset the timer 2 queue loop interrupt 
....................          setup_T2_int(T2_64MS);          
0A3C0:  MOVLB  5
0A3C2:  SETF   x4B
0A3C4:  MOVLB  0
0A3C6:  CALL   4E82
....................           
....................          // restart the watchdog timer     
....................          restart_wdt();    
0A3CA:  CLRWDT
....................                              
....................          // update the control loop if the system isn't in the system wait (low-power) state 
....................          if (read_system_state() != SYSTEM_IDLE) update_control_loop();            
0A3CC:  CALL   1F02
0A3D0:  MOVF   01,W
0A3D2:  SUBLW  03
0A3D4:  BTFSS  FD8.2
0A3D6:  GOTO   53D8
....................  
....................          // Safely grab the next item in the priority queue to execute                 
....................          // All interrupts that can modify the queue need to be disabled to                             
....................          //    ensure memory is not corrupted.       
....................          disable_interrupts(INT_CCP4); 
0A3DA:  BCF    F7A.1
....................          disable_interrupts(INT_EXT2);        
0A3DC:  BCF    FF0.4
....................          priority_queue_item_to_execute = pop_priority_queue();    
0A3DE:  GOTO   5BDA
0A3E2:  MOVFF  01,548
....................          enable_interrupts(INT_EXT2);    
0A3E6:  BSF    FF0.4
....................          enable_interrupts(INT_CCP4);              
0A3E8:  BSF    F7A.1
....................                                                        
....................          // execute the priority queue item     
....................          switch (priority_queue_item_to_execute)                                
0A3EA:  MOVLB  5
0A3EC:  MOVF   x48,W
0A3EE:  XORLW  20
0A3F0:  MOVLB  0
0A3F2:  BTFSC  FD8.2
0A3F4:  BRA    A4FA
0A3F6:  XORLW  61
0A3F8:  BTFSC  FD8.2
0A3FA:  BRA    A53A
0A3FC:  XORLW  70
0A3FE:  BTFSC  FD8.2
0A400:  BRA    A582
0A402:  XORLW  03
0A404:  BTFSC  FD8.2
0A406:  BRA    A620
0A408:  XORLW  01
0A40A:  BTFSC  FD8.2
0A40C:  BRA    A644
0A40E:  XORLW  07
0A410:  BTFSC  FD8.2
0A412:  BRA    A66A
0A414:  XORLW  01
0A416:  BTFSC  FD8.2
0A418:  BRA    A68A
0A41A:  XORLW  03
0A41C:  BTFSC  FD8.2
0A41E:  BRA    A6AE
0A420:  XORLW  01
0A422:  BTFSC  FD8.2
0A424:  BRA    A7D8
0A426:  XORLW  0F
0A428:  BTFSC  FD8.2
0A42A:  BRA    A808
0A42C:  XORLW  01
0A42E:  BTFSC  FD8.2
0A430:  BRA    A868
0A432:  XORLW  05
0A434:  BTFSC  FD8.2
0A436:  BRA    A878
0A438:  XORLW  01
0A43A:  BTFSC  FD8.2
0A43C:  BRA    A898
0A43E:  XORLW  03
0A440:  BTFSC  FD8.2
0A442:  BRA    A8B8
0A444:  XORLW  01
0A446:  BTFSC  FD8.2
0A448:  BRA    A908
0A44A:  XORLW  7F
0A44C:  BTFSC  FD8.2
0A44E:  BRA    A956
0A450:  XORLW  10
0A452:  BTFSC  FD8.2
0A454:  BRA    AAF2
0A456:  XORLW  01
0A458:  BTFSC  FD8.2
0A45A:  BRA    AAF4
0A45C:  XORLW  04
0A45E:  BTFSC  FD8.2
0A460:  BRA    AAF6
0A462:  XORLW  03
0A464:  BTFSC  FD8.2
0A466:  BRA    AB3C
0A468:  XORLW  82
0A46A:  BTFSC  FD8.2
0A46C:  BRA    AB52
0A46E:  XORLW  14
0A470:  BTFSC  FD8.2
0A472:  GOTO   ABC4
0A476:  XORLW  D1
0A478:  BTFSC  FD8.2
0A47A:  GOTO   ABE6
0A47E:  XORLW  01
0A480:  BTFSC  FD8.2
0A482:  GOTO   AC1C
0A486:  XORLW  A4
0A488:  BTFSC  FD8.2
0A48A:  GOTO   AC6C
0A48E:  XORLW  01
0A490:  BTFSC  FD8.2
0A492:  GOTO   AC72
0A496:  XORLW  16
0A498:  BTFSC  FD8.2
0A49A:  GOTO   AC78
0A49E:  XORLW  07
0A4A0:  BTFSC  FD8.2
0A4A2:  GOTO   AC7E
0A4A6:  XORLW  05
0A4A8:  BTFSC  FD8.2
0A4AA:  GOTO   AC84
0A4AE:  XORLW  04
0A4B0:  BTFSC  FD8.2
0A4B2:  GOTO   AC8A
0A4B6:  XORLW  07
0A4B8:  BTFSC  FD8.2
0A4BA:  GOTO   ACC4
0A4BE:  XORLW  13
0A4C0:  BTFSC  FD8.2
0A4C2:  GOTO   ACCA
0A4C6:  XORLW  03
0A4C8:  BTFSC  FD8.2
0A4CA:  GOTO   AD50
0A4CE:  XORLW  01
0A4D0:  BTFSC  FD8.2
0A4D2:  GOTO   AD84
0A4D6:  XORLW  13
0A4D8:  BTFSC  FD8.2
0A4DA:  GOTO   ADB8
0A4DE:  XORLW  50
0A4E0:  BTFSC  FD8.2
0A4E2:  GOTO   ADBE
0A4E6:  XORLW  01
0A4E8:  BTFSC  FD8.2
0A4EA:  GOTO   AE64
0A4EE:  XORLW  F1
0A4F0:  BTFSC  FD8.2
0A4F2:  GOTO   AFD0
0A4F6:  GOTO   AFD0
....................          {                          
....................             // Decode a new packet and react/respond appropriately 
....................             case DEAL_WITH_NEW_PACKET:             
....................                // Display that you're dealing with a new packet 
....................                LCD_clear();                                  
0A4FA:  CALL   5C18
....................                strcpy (global_temp_line_buff, "Deal With Packet"); 
0A4FE:  CLRF   FEA
0A500:  MOVLW  70
0A502:  MOVWF  FE9
0A504:  MOVLW  00
0A506:  CALL   0676
0A50A:  TBLRD*-
0A50C:  TBLRD*+
0A50E:  MOVF   FF5,W
0A510:  MOVWF  FEE
0A512:  IORLW  00
0A514:  BNZ   A50C
....................                LCD_line1(global_temp_line_buff); 
0A516:  MOVLB  5
0A518:  CLRF   x64
0A51A:  MOVLW  70
0A51C:  MOVWF  x63
0A51E:  MOVLB  0
0A520:  CALL   3932
....................                global_skip_lcd_update_count = 2;      
0A524:  MOVLW  02
0A526:  MOVWF  x83
....................                                                   
....................                // disable ccp4 and mote interrupt so we don't overwrite payload_buff 
....................                //    or have colliding unsolicited messages 
....................                disable_interrupts(INT_CCP4); 
0A528:  BCF    F7A.1
....................                disable_interrupts(INT_EXT2_H2L); 
0A52A:  BCF    FF0.4
....................                deal_with_packet();  
0A52C:  GOTO   712E
....................                enable_interrupts(INT_EXT2_H2L);                        
0A530:  BSF    FF0.4
0A532:  BCF    FF1.4
....................                enable_interrupts(INT_CCP4); 
0A534:  BSF    F7A.1
....................                break; 
0A536:  GOTO   AFD0
....................                                                         
....................             case MOVE_VALVE_AT_BOOT: 
....................                // open valve slightly at bootup according to define "VLV_BOOT_SETPT" 
....................                // display message on screen  
....................                LCD_clear(); 
0A53A:  CALL   5C18
....................                strcpy (global_temp_line_buff, "VLV Init @ start"); 
0A53E:  CLRF   FEA
0A540:  MOVLW  70
0A542:  MOVWF  FE9
0A544:  MOVLW  00
0A546:  CALL   0698
0A54A:  TBLRD*-
0A54C:  TBLRD*+
0A54E:  MOVF   FF5,W
0A550:  MOVWF  FEE
0A552:  IORLW  00
0A554:  BNZ   A54C
....................                LCD_line1(global_temp_line_buff); 
0A556:  MOVLB  5
0A558:  CLRF   x64
0A55A:  MOVLW  70
0A55C:  MOVWF  x63
0A55E:  MOVLB  0
0A560:  CALL   3932
....................                global_skip_lcd_update_count = 2;   
0A564:  MOVLW  02
0A566:  MOVWF  x83
....................                 
....................                // set valve position to VLV_BOOT_SETPT on boot     
....................                global_valve_position_set_value = VLV_BOOT_SETPT;                            
0A568:  MOVLW  20
0A56A:  MOVWF  xC4
0A56C:  CLRF   xC3
....................                PUSH_PRIORITY_QUEUE_MACRO(MOVE_VALVE);  
0A56E:  BCF    F7A.1
0A570:  MOVLW  40
0A572:  MOVLB  5
0A574:  MOVWF  x52
0A576:  MOVLB  0
0A578:  CALL   46CA
0A57C:  BSF    F7A.1
....................                break; 
0A57E:  GOTO   AFD0
....................               
....................             // Start the somewhat convoluted calibrate valve routine 
....................             // 1. Open valve VLV_CAL_1_MOVEMENT w/ "starting current" 
....................             // 2. Close valve fully w/ current being "normal closing current" 
....................             // 3. Open valve fully w/ normal current regimes 
....................             // 4. Do free spin rate (not done in here at the moment, just skipped).  
....................             // 5. Close valve fully w/ normal current regimes 
....................             // 6. Send valve calibration response to mote    
....................             // steps and system states are handled in COMP and CCP3 ISR as well  
....................             //    as setting the calibration values      
....................             case CALIBRATE_VALVE_1:                      
....................                // Change system state: initial open for calibrate valve routine 
....................                write_system_state(SYSTEM_CAL_VLV_1);     
0A582:  MOVLW  10
0A584:  MOVLB  5
0A586:  MOVWF  x4B
0A588:  MOVLB  0
0A58A:  CALL   3208
....................                // display calibration routine on screen      
....................                LCD_clear();                          
0A58E:  CALL   5C18
....................                strcpy (global_temp_line_buff, "VLV Calibration "); 
0A592:  CLRF   FEA
0A594:  MOVLW  70
0A596:  MOVWF  FE9
0A598:  MOVLW  00
0A59A:  CALL   06BA
0A59E:  TBLRD*-
0A5A0:  TBLRD*+
0A5A2:  MOVF   FF5,W
0A5A4:  MOVWF  FEE
0A5A6:  IORLW  00
0A5A8:  BNZ   A5A0
....................                LCD_line1(global_temp_line_buff); 
0A5AA:  MOVLB  5
0A5AC:  CLRF   x64
0A5AE:  MOVLW  70
0A5B0:  MOVWF  x63
0A5B2:  MOVLB  0
0A5B4:  CALL   3932
....................                strcpy (global_temp_line_buff, "Begining........"); 
0A5B8:  CLRF   FEA
0A5BA:  MOVLW  70
0A5BC:  MOVWF  FE9
0A5BE:  MOVLW  00
0A5C0:  CALL   06DC
0A5C4:  TBLRD*-
0A5C6:  TBLRD*+
0A5C8:  MOVF   FF5,W
0A5CA:  MOVWF  FEE
0A5CC:  IORLW  00
0A5CE:  BNZ   A5C6
....................                LCD_line2(global_temp_line_buff); 
0A5D0:  MOVLB  5
0A5D2:  CLRF   x64
0A5D4:  MOVLW  70
0A5D6:  MOVWF  x63
0A5D8:  MOVLB  0
0A5DA:  CALL   398C
....................                global_skip_lcd_update_count = 2;   
0A5DE:  MOVLW  02
0A5E0:  MOVWF  x83
....................                // setup brakes and charging for valve calibration 
....................                // (maximum resistance with no RPM Control) 
....................                global_control_loop_mechanism = NO_RPM_CONTROL_DYN_MPPC; 
0A5E2:  MOVLW  06
0A5E4:  MOVWF  xC0
....................                global_charge_duty_set_value = MAX_CHARGE; 
0A5E6:  MOVLW  01
0A5E8:  MOVWF  xB9
0A5EA:  MOVLW  90
0A5EC:  MOVWF  xB8
....................                global_brake_duty_set_value = MAX_BRK; 
0A5EE:  MOVLW  01
0A5F0:  MOVWF  xB7
0A5F2:  MOVLW  90
0A5F4:  MOVWF  xB6
....................                // put values to default values (45 seconds open/close)                                
....................                global_valve_time_to_close_1024th = DEFAULT_VLV_TIME_TO_CLOSE;  
0A5F6:  MOVLW  05
0A5F8:  MOVWF  xC6
0A5FA:  CLRF   xC5
....................                global_valve_time_to_open_1024th = DEFAULT_VLV_TIME_TO_OPEN;               
0A5FC:  MOVWF  xC8
0A5FE:  CLRF   xC7
....................                // Set the global valve position to the default value (middle)                  
....................                // this gives the valve a reference point to open a little from 
....................                global_valve_position = VLV_PRECALIBRATION_POSITION; 
0A600:  MOVLW  40
0A602:  MOVWF  xC2
0A604:  CLRF   xC1
....................                // Set valve position slightly more open than it is and move valve 
....................                global_valve_position_set_value = (VLV_PRECALIBRATION_POSITION +                        \ 
....................                VLV_CAL_1_MOVEMENT); 
0A606:  MOVLW  60
0A608:  MOVWF  xC4
0A60A:  CLRF   xC3
....................                PUSH_PRIORITY_QUEUE_MACRO(MOVE_VALVE); 
0A60C:  BCF    F7A.1
0A60E:  MOVLW  40
0A610:  MOVLB  5
0A612:  MOVWF  x52
0A614:  MOVLB  0
0A616:  CALL   46CA
0A61A:  BSF    F7A.1
....................                break;                                                       
0A61C:  GOTO   AFD0
....................                 
....................             case CALIBRATE_VALVE_2:                                                                                                        
....................                // Change system state: fully closed 
....................                write_system_state(SYSTEM_CAL_VLV_2); 
0A620:  MOVLW  11
0A622:  MOVLB  5
0A624:  MOVWF  x4B
0A626:  MOVLB  0
0A628:  CALL   3208
....................                // set valve position target to fully closed and move valve 
....................                global_valve_position_set_value = VLV_POSITION_CLOSED; 
0A62C:  CLRF   xC4
0A62E:  CLRF   xC3
....................                PUSH_PRIORITY_QUEUE_MACRO(MOVE_VALVE);                                  
0A630:  BCF    F7A.1
0A632:  MOVLW  40
0A634:  MOVLB  5
0A636:  MOVWF  x52
0A638:  MOVLB  0
0A63A:  CALL   46CA
0A63E:  BSF    F7A.1
....................                break;    
0A640:  GOTO   AFD0
....................                 
....................             case CALIBRATE_VALVE_3: 
....................                // Change system state: fully closed to fully opened 
....................                write_system_state(SYSTEM_CAL_VLV_3); 
0A644:  MOVLW  12
0A646:  MOVLB  5
0A648:  MOVWF  x4B
0A64A:  MOVLB  0
0A64C:  CALL   3208
....................                // set valve position target to fully open and move valve 
....................                global_valve_position_set_value = VLV_POSITION_OPENED; 
0A650:  MOVLW  80
0A652:  MOVWF  xC4
0A654:  CLRF   xC3
....................                PUSH_PRIORITY_QUEUE_MACRO(MOVE_VALVE); 
0A656:  BCF    F7A.1
0A658:  MOVLW  40
0A65A:  MOVLB  5
0A65C:  MOVWF  x52
0A65E:  MOVLB  0
0A660:  CALL   46CA
0A664:  BSF    F7A.1
....................                break;      
0A666:  GOTO   AFD0
....................              
....................            case CALIBRATE_VALVE_4:  
....................                // Change system state: FSR (not used at the moment) 
....................                write_system_state(SYSTEM_CAL_VLV_4);  
0A66A:  MOVLW  13
0A66C:  MOVLB  5
0A66E:  MOVWF  x4B
0A670:  MOVLB  0
0A672:  CALL   3208
....................                // move to the next calibration stage 
....................                PUSH_PRIORITY_QUEUE_MACRO(CALIBRATE_VALVE_5); 
0A676:  BCF    F7A.1
0A678:  MOVLW  35
0A67A:  MOVLB  5
0A67C:  MOVWF  x52
0A67E:  MOVLB  0
0A680:  CALL   46CA
0A684:  BSF    F7A.1
....................                break;       
0A686:  GOTO   AFD0
....................                 
....................             case CALIBRATE_VALVE_5: 
....................                // Change system state: fully opened to fully closed 
....................                write_system_state(SYSTEM_CAL_VLV_5); 
0A68A:  MOVLW  14
0A68C:  MOVLB  5
0A68E:  MOVWF  x4B
0A690:  MOVLB  0
0A692:  CALL   3208
....................                // set valve position target to fully closed and move valve 
....................                global_valve_position_set_value = VLV_POSITION_CLOSED; 
0A696:  CLRF   xC4
0A698:  CLRF   xC3
....................                PUSH_PRIORITY_QUEUE_MACRO(MOVE_VALVE); 
0A69A:  BCF    F7A.1
0A69C:  MOVLW  40
0A69E:  MOVLB  5
0A6A0:  MOVWF  x52
0A6A2:  MOVLB  0
0A6A4:  CALL   46CA
0A6A8:  BSF    F7A.1
....................                break;      
0A6AA:  GOTO   AFD0
....................              
....................             case CALIBRATE_VALVE_6: 
....................                // Change system state: display calibration and send to manager 
....................                write_system_state(SYSTEM_CAL_VLV_6); 
0A6AE:  MOVLW  15
0A6B0:  MOVLB  5
0A6B2:  MOVWF  x4B
0A6B4:  MOVLB  0
0A6B6:  CALL   3208
....................                // display calibraion on screen 
....................                LCD_clear(); 
0A6BA:  CALL   5C18
....................                strcpy (global_temp_line_buff, "Close CCP=      "); 
0A6BE:  CLRF   FEA
0A6C0:  MOVLW  70
0A6C2:  MOVWF  FE9
0A6C4:  MOVLW  00
0A6C6:  CALL   06FE
0A6CA:  TBLRD*-
0A6CC:  TBLRD*+
0A6CE:  MOVF   FF5,W
0A6D0:  MOVWF  FEE
0A6D2:  IORLW  00
0A6D4:  BNZ   A6CC
....................                LCD_line1(global_temp_line_buff); 
0A6D6:  MOVLB  5
0A6D8:  CLRF   x64
0A6DA:  MOVLW  70
0A6DC:  MOVWF  x63
0A6DE:  MOVLB  0
0A6E0:  CALL   3932
....................                strcpy (global_temp_line_buff, "Open CCP =      "); 
0A6E4:  CLRF   FEA
0A6E6:  MOVLW  70
0A6E8:  MOVWF  FE9
0A6EA:  MOVLW  00
0A6EC:  CALL   0720
0A6F0:  TBLRD*-
0A6F2:  TBLRD*+
0A6F4:  MOVF   FF5,W
0A6F6:  MOVWF  FEE
0A6F8:  IORLW  00
0A6FA:  BNZ   A6F2
....................                LCD_line2(global_temp_line_buff); 
0A6FC:  MOVLB  5
0A6FE:  CLRF   x64
0A700:  MOVLW  70
0A702:  MOVWF  x63
0A704:  MOVLB  0
0A706:  CALL   398C
....................                LCD_place_uint16(global_valve_time_to_close_1024th,0,11,5); 
0A70A:  MOVFF  C6,564
0A70E:  MOVFF  C5,563
0A712:  MOVLB  5
0A714:  CLRF   x65
0A716:  MOVLW  0B
0A718:  MOVWF  x66
0A71A:  MOVLW  05
0A71C:  MOVWF  x67
0A71E:  MOVLB  0
0A720:  CALL   6838
....................                LCD_place_uint16(global_valve_time_to_open_1024th,1,11,5); 
0A724:  MOVFF  C8,564
0A728:  MOVFF  C7,563
0A72C:  MOVLW  01
0A72E:  MOVLB  5
0A730:  MOVWF  x65
0A732:  MOVLW  0B
0A734:  MOVWF  x66
0A736:  MOVLW  05
0A738:  MOVWF  x67
0A73A:  MOVLB  0
0A73C:  CALL   6838
....................                // put calibration stuff on screen for 4 seconds 
....................                global_skip_lcd_update_count = 5;      
0A740:  MOVLW  05
0A742:  MOVWF  x83
....................                // if valve calibration time is beyond limits, it triggers an error 
....................                //    and throws away the calibration, returning it to the run state. 
....................                if ((global_valve_time_to_close_1024th < ERROR_VLV_CAL_TIME_LO) || \ 
....................                   (global_valve_time_to_open_1024th < ERROR_VLV_CAL_TIME_LO)   || \ 
....................                   (global_valve_time_to_close_1024th > ERROR_VLV_CAL_TIME_HI)  || \ 
....................                   (global_valve_time_to_open_1024th > ERROR_VLV_CAL_TIME_HI)) 
0A744:  MOVF   xC6,W
0A746:  SUBLW  02
0A748:  BNC   A752
0A74A:  BNZ   A780
0A74C:  MOVF   xC5,W
0A74E:  SUBLW  ED
0A750:  BC    A780
0A752:  MOVF   xC8,W
0A754:  SUBLW  02
0A756:  BNC   A760
0A758:  BNZ   A780
0A75A:  MOVF   xC7,W
0A75C:  SUBLW  ED
0A75E:  BC    A780
0A760:  MOVF   xC6,W
0A762:  SUBLW  08
0A764:  BC    A770
0A766:  XORLW  FF
0A768:  BNZ   A780
0A76A:  MOVF   xC5,W
0A76C:  SUBLW  C4
0A76E:  BNC   A780
0A770:  MOVF   xC8,W
0A772:  SUBLW  08
0A774:  BC    A7A4
0A776:  XORLW  FF
0A778:  BNZ   A780
0A77A:  MOVF   xC7,W
0A77C:  SUBLW  C4
0A77E:  BC    A7A4
....................                { 
....................                   // reset valve calibration times to the defaults 
....................                   global_valve_time_to_open_1024th = DEFAULT_VLV_TIME_TO_OPEN; 
0A780:  MOVLW  05
0A782:  MOVWF  xC8
0A784:  CLRF   xC7
....................                   global_valve_time_to_close_1024th = DEFAULT_VLV_TIME_TO_CLOSE; 
0A786:  MOVWF  xC6
0A788:  CLRF   xC5
....................                   // change valve position to unknown 
....................                   global_valve_position = VLV_POSITION_UNKNOWN; 
0A78A:  SETF   xC2
0A78C:  SETF   xC1
....................                   // set the error bitfield and send an error 
....................                   global_error_message_bitfield |= ERR_MSG_VLV_CAL_FAIL; 
0A78E:  MOVLB  4
0A790:  BSF    xF9.1
....................                   PUSH_MESSAGE_QUEUE_MACRO(MSG_MOTE_ERROR_MSG); 
0A792:  BCF    F7A.1
0A794:  MOVLW  A0
0A796:  MOVLB  5
0A798:  MOVWF  x54
0A79A:  MOVLB  0
0A79C:  CALL   4FF4
0A7A0:  BSF    F7A.1
....................                } 
0A7A2:  BRA    A7C8
....................                // successful/valid calibration time 
....................                else 
....................                { 
....................                   // update the calibration time 
....................                   global_valve_calibration_utc_time = global_utc_time; 
0A7A4:  MOVFF  8C,CE
0A7A8:  MOVFF  8B,CD
0A7AC:  MOVFF  8A,CC
0A7B0:  MOVFF  89,CB
....................                   // store calibrations in eeprom 
....................                   store_vcal_eeprom_values(); 
0A7B4:  GOTO   8098
....................                   // send an unsolicited valve report to the manager 
....................                   PUSH_MESSAGE_QUEUE_MACRO(MSG_MOTE_VALVE_REPORT); 
0A7B8:  BCF    F7A.1
0A7BA:  MOVLW  92
0A7BC:  MOVLB  5
0A7BE:  MOVWF  x54
0A7C0:  MOVLB  0
0A7C2:  CALL   4FF4
0A7C6:  BSF    F7A.1
....................                } 
....................                // put system in run state 
....................                write_system_state(SYSTEM_RUN); 
0A7C8:  MOVLW  02
0A7CA:  MOVLB  5
0A7CC:  MOVWF  x4B
0A7CE:  MOVLB  0
0A7D0:  CALL   3208
....................                break;      
0A7D4:  GOTO   AFD0
....................                             
....................             // FSR IS LARGELY UNTESTED EVEN THOUGH IT'S BASICALLY ALL WRITTEN!                
....................             // move valve to position specified by calibrate FSR routine    
....................             case CALIBRATE_FSR_1: 
....................                // set system state                       
....................                write_system_state(SYSTEM_CAL_FSR_1);                                          
0A7D8:  MOVLW  18
0A7DA:  MOVLB  5
0A7DC:  MOVWF  x4B
0A7DE:  MOVLB  0
0A7E0:  CALL   3208
....................                // save the current valve, so we can return to it later 
....................                pre_fsr_valve_setting = global_valve_position;      
0A7E4:  MOVFF  C2,54A
0A7E8:  MOVFF  C1,549
....................                // move valve to the FSR position                          
....................                global_valve_position_set_value = global_calibrate_fsr_valve_position;  
0A7EC:  MOVFF  D1,C4
0A7F0:  MOVFF  D0,C3
....................                PUSH_PRIORITY_QUEUE_MACRO(MOVE_VALVE);                             
0A7F4:  BCF    F7A.1
0A7F6:  MOVLW  40
0A7F8:  MOVLB  5
0A7FA:  MOVWF  x52
0A7FC:  MOVLB  0
0A7FE:  CALL   46CA
0A802:  BSF    F7A.1
....................                break;          
0A804:  GOTO   AFD0
....................                                                                                          
....................             case CALIBRATE_FSR_2: 
....................                // set system state 
....................                write_system_state(SYSTEM_CAL_FSR_2);    
0A808:  MOVLW  19
0A80A:  MOVLB  5
0A80C:  MOVWF  x4B
0A80E:  MOVLB  0
0A810:  CALL   3208
....................                // disable ccp5 for a quick second 
....................                disable_interrupts(INT_CCP5); 
0A814:  BCF    F7A.2
....................                // actually measure the FSR and store it  
....................                global_calibrate_fsr_period = global_current_period;    
0A816:  MOVFF  A9,D3
0A81A:  MOVFF  A8,D2
....................                // restore ccp5 
....................                enable_interrupts(INT_CCP5);      
0A81E:  BSF    F7A.2
....................                // store the fsr calibration time 
....................                global_calibrate_fsr_utc_time = global_utc_time;    
0A820:  MOVFF  8C,D7
0A824:  MOVFF  8B,D6
0A828:  MOVFF  8A,D5
0A82C:  MOVFF  89,D4
....................                                      
....................                // move valve to the FSR position 
....................                global_valve_position_set_value = pre_fsr_valve_setting;   
0A830:  MOVFF  54A,C4
0A834:  MOVFF  549,C3
....................                PUSH_PRIORITY_QUEUE_MACRO(MOVE_VALVE);     
0A838:  BCF    F7A.1
0A83A:  MOVLW  40
0A83C:  MOVLB  5
0A83E:  MOVWF  x52
0A840:  MOVLB  0
0A842:  CALL   46CA
0A846:  BSF    F7A.1
....................                                                   
....................                PUSH_MESSAGE_QUEUE_MACRO(MSG_MOTE_VALVE_REPORT); 
0A848:  BCF    F7A.1
0A84A:  MOVLW  92
0A84C:  MOVLB  5
0A84E:  MOVWF  x54
0A850:  MOVLB  0
0A852:  CALL   4FF4
0A856:  BSF    F7A.1
....................                write_system_state(SYSTEM_RUN); 
0A858:  MOVLW  02
0A85A:  MOVLB  5
0A85C:  MOVWF  x4B
0A85E:  MOVLB  0
0A860:  CALL   3208
....................                break;                                   
0A864:  GOTO   AFD0
....................                 
....................             case CALIBRATE_FSR_3: 
....................                write_system_state(SYSTEM_CAL_FSR_3); 
0A868:  MOVLW  1A
0A86A:  MOVLB  5
0A86C:  MOVWF  x4B
0A86E:  MOVLB  0
0A870:  CALL   3208
....................                break;         
0A874:  GOTO   AFD0
....................             /*    
....................             case CALIBRATE_FSR_4: 
....................                write_system_state(SYSTEM_CAL_FSR_4); 
....................                LCD_clear(); 
....................                LCD_place_uint16(global_valve_position,0,0,5); 
....................                LCD_place_uint16(global_valve_time_to_close_1024th,0,6,5); 
....................                LCD_place_uint16(global_valve_time_to_open_1024th,0,11,5); 
....................                LCD_place_uint16(global_valve_position,1,0,5); 
....................                LCD_place_uint16(global_valve_position,1,11,5); 
....................                LCD_place_uint16(global_valve_position,1,11,5); 
....................                // put calibration stuff on screen for 4 seconds 
....................                global_skip_lcd_update_count = 5; 
....................                global_calibrate_fsr_utc_time 
....................                 
....................                write_system_state(SYSTEM_RUN); 
....................                break;          
....................                */             
....................                 
....................                 
....................             case MOVE_VALVE_MAG_DECOUPLING_RECOVERY: 
....................                // move the valve to VLV_MAGNETIC_COUPLING_FIX 
....................                global_valve_position_set_value = VLV_MAGNETIC_COUPLING_FIX; 
0A878:  MOVFF  520,C4
0A87C:  MOVFF  51F,C3
....................                PUSH_PRIORITY_QUEUE_MACRO(MOVE_VALVE); 
0A880:  BCF    F7A.1
0A882:  MOVLW  40
0A884:  MOVLB  5
0A886:  MOVWF  x52
0A888:  MOVLB  0
0A88A:  CALL   46CA
0A88E:  BSF    F7A.1
....................                // change control loop scheme  
....................                global_control_loop_mechanism = MAG_DECOUPLING_RECOVERY; 
0A890:  MOVLW  09
0A892:  MOVWF  xC0
....................                break; 
0A894:  GOTO   AFD0
....................                 
....................             case MOVE_VALVE_NO_SPIN_RECOVERY: 
....................                // move the valve to VLV_NOT_SPIN_FIX 
....................                global_valve_position_set_value = VLV_NOT_SPIN_FIX; 
0A898:  MOVFF  51B,C4
0A89C:  MOVFF  51A,C3
....................                PUSH_PRIORITY_QUEUE_MACRO(MOVE_VALVE); 
0A8A0:  BCF    F7A.1
0A8A2:  MOVLW  40
0A8A4:  MOVLB  5
0A8A6:  MOVWF  x52
0A8A8:  MOVLB  0
0A8AA:  CALL   46CA
0A8AE:  BSF    F7A.1
....................                // change control loop scheme 
....................                global_control_loop_mechanism = NO_SPIN_RECOVERY; 
0A8B0:  MOVLW  08
0A8B2:  MOVWF  xC0
....................                break; 
0A8B4:  GOTO   AFD0
....................                                                
....................             // Opens valve irrespective of the position. Used for shutting down the system (and leaving 
....................             //    the valve open) and for test purposes.  Added very quickly in Nebraska.                  
....................             case OPEN_VALVE_UNKNOWN_STATE:                             
....................                // clear out the time in motion 
....................                global_valve_time_in_motion_1024ths = 0;      
0A8B8:  CLRF   xCA
0A8BA:  CLRF   xC9
....................                 
....................                global_valve_position_set_value = VLV_POSITION_OPENED; 
0A8BC:  MOVLW  80
0A8BE:  MOVWF  xC4
0A8C0:  CLRF   xC3
....................                CCP_3 = global_valve_time_to_open_1024th;  
0A8C2:  MOVFF  C8,F5F
0A8C6:  MOVFF  C7,F5E
....................                // start the valve opening 
....................                mV_OPENm;          
0A8CA:  MOVLW  02
0A8CC:  MOVWF  F8D
....................                // setup/turn on the comparator interrupt (also sets up DAC) 
....................                comparator_setup(); 
0A8CE:  CALL   8224
....................                 
....................                // setup and enable CCP3 as well as it's respective timer 
....................                setup_ccp3(CCP_USE_TIMER1_AND_TIMER2 | CCP_COMPARE_RESET_TIMER); 
0A8D2:  MOVLW  0B
0A8D4:  MOVLB  F
0A8D6:  MOVWF  x5D
0A8D8:  CLRF   x5C
0A8DA:  CLRF   x5B
0A8DC:  MOVLW  01
0A8DE:  MOVWF  x5A
0A8E0:  MOVLW  3F
0A8E2:  ANDWF  x49,F
0A8E4:  MOVLW  00
0A8E6:  IORWF  x49,F
....................                setup_timer_1(T1_ENABLE_SOSC | T1_EXTERNAL_SYNC | T1_DIV_BY_1); 
0A8E8:  MOVLW  8B
0A8EA:  MOVWF  FCD
0A8EC:  CLRF   FCC
....................                set_timer1(0); 
0A8EE:  CLRF   FCF
0A8F0:  CLRF   FCE
....................                                                                           
....................                // clear any ccp3 interrupt and enable ccp3 interrupt 
....................                clear_interrupt(INT_CCP3);                
0A8F2:  BCF    F7B.0
....................                enable_interrupts(INT_CCP3);  
0A8F4:  BSF    F7A.0
....................                 
....................                // JG: previously there was no "break;" here.  Rather the 
....................                // following case was MOVE_VALVE. I believe this accomplishes 
....................                // the same thing. 
....................                PUSH_PRIORITY_QUEUE_MACRO(MOVE_VALVE); 
0A8F6:  BCF    F7A.1
0A8F8:  MOVLW  40
0A8FA:  MOVLB  5
0A8FC:  MOVWF  x52
0A8FE:  MOVLB  0
0A900:  CALL   46CA
0A904:  BSF    F7A.1
....................                break; 
0A906:  BRA    AFD0
....................  
....................              
....................             // Closes valve irrespective of the position. Used for shutting down the system (and leaving 
....................             //    the valve closed) and for test purposes. 
....................             case CLOSE_VALVE_UNKNOWN_STATE:                             
....................                // clear out the time in motion 
....................                global_valve_time_in_motion_1024ths = 0;      
0A908:  CLRF   xCA
0A90A:  CLRF   xC9
....................                 
....................                global_valve_position_set_value = VLV_POSITION_CLOSED; 
0A90C:  CLRF   xC4
0A90E:  CLRF   xC3
....................                CCP_3 = global_valve_time_to_open_1024th;  
0A910:  MOVFF  C8,F5F
0A914:  MOVFF  C7,F5E
....................                // start the valve opening 
....................                mV_CLOSEm;          
0A918:  MOVLW  01
0A91A:  MOVWF  F8D
....................                // setup/turn on the comparator interrupt (also sets up DAC) 
....................                comparator_setup(); 
0A91C:  CALL   8224
....................                 
....................                // setup and enable CCP3 as well as it's respective timer 
....................                setup_ccp3(CCP_USE_TIMER1_AND_TIMER2 | CCP_COMPARE_RESET_TIMER); 
0A920:  MOVLW  0B
0A922:  MOVLB  F
0A924:  MOVWF  x5D
0A926:  CLRF   x5C
0A928:  CLRF   x5B
0A92A:  MOVLW  01
0A92C:  MOVWF  x5A
0A92E:  MOVLW  3F
0A930:  ANDWF  x49,F
0A932:  MOVLW  00
0A934:  IORWF  x49,F
....................                setup_timer_1(T1_ENABLE_SOSC | T1_EXTERNAL_SYNC | T1_DIV_BY_1); 
0A936:  MOVLW  8B
0A938:  MOVWF  FCD
0A93A:  CLRF   FCC
....................                set_timer1(0); 
0A93C:  CLRF   FCF
0A93E:  CLRF   FCE
....................                                                                           
....................                // clear any ccp3 interrupt and enable ccp3 interrupt 
....................                clear_interrupt(INT_CCP3);                
0A940:  BCF    F7B.0
....................                enable_interrupts(INT_CCP3);    
0A942:  BSF    F7A.0
....................                PUSH_PRIORITY_QUEUE_MACRO(MOVE_VALVE); 
0A944:  BCF    F7A.1
0A946:  MOVLW  40
0A948:  MOVLB  5
0A94A:  MOVWF  x52
0A94C:  MOVLB  0
0A94E:  CALL   46CA
0A952:  BSF    F7A.1
....................                break;                                     
0A954:  BRA    AFD0
....................                                             
....................                                             
....................             case MOVE_VALVE:               
....................                // if the system is in the SYSTEM_IDLE state, bump it into the SYSTEM_RUN state. 
....................                if (read_system_state() == SYSTEM_IDLE) write_system_state(SYSTEM_RUN);      
0A956:  CALL   1F02
0A95A:  MOVF   01,W
0A95C:  SUBLW  03
0A95E:  BNZ   A96C
0A960:  MOVLW  02
0A962:  MOVLB  5
0A964:  MOVWF  x4B
0A966:  MOVLB  0
0A968:  CALL   3208
....................                                                       
....................                // if system is in an undesireable state, don't move the valve 
....................                //    and send an error message                                   
....................                // Undesirable states such as unkown or init 
.................... #IFNDEF OPEN_VALVE_TO_SETPT_AT_BOOT                
....................                if ((read_system_state() == SYSTEM_STATE_UNKNOWN)||            \ 
....................                   (read_system_state() == SYSTEM_INIT)) 
.................... #ELSE                          
....................                if (read_system_state() == SYSTEM_STATE_UNKNOWN) 
0A96C:  CALL   1F02
0A970:  INCFSZ 01,W
0A972:  BRA    A98C
.................... #ENDIF           
....................                { 
....................                   global_error_message_bitfield |= ERR_MSG_INCOMPATIBLE_STATE; 
0A974:  MOVLB  4
0A976:  BSF    xF8.1
....................                   PUSH_MESSAGE_QUEUE_MACRO(MSG_MOTE_ERROR_MSG); 
0A978:  BCF    F7A.1
0A97A:  MOVLW  A0
0A97C:  MOVLB  5
0A97E:  MOVWF  x54
0A980:  MOVLB  0
0A982:  CALL   4FF4
0A986:  BSF    F7A.1
....................                   break;           
0A988:  BRA    AFD0
....................                } 
0A98A:  BRA    AA00
....................  
....................                // Jack has changed this test to check if the valve calibration 
....................                //  is stale as per VLV_SECS_TO_STALE_CAL defined parameter 
....................                else if ((read_system_state() == SYSTEM_RUN) &&                \ 
....................                  ((global_utc_time-global_valve_calibration_utc_time)>VLV_SECS_TO_STALE_CAL)) 
0A98C:  CALL   1F02
0A990:  MOVF   01,W
0A992:  SUBLW  02
0A994:  BNZ   AA00
0A996:  MOVF   xCB,W
0A998:  SUBWF  x89,W
0A99A:  MOVLB  5
0A99C:  MOVWF  x4B
0A99E:  MOVLB  0
0A9A0:  MOVF   xCC,W
0A9A2:  SUBWFB x8A,W
0A9A4:  MOVLB  5
0A9A6:  MOVWF  x4C
0A9A8:  MOVLB  0
0A9AA:  MOVF   xCD,W
0A9AC:  SUBWFB x8B,W
0A9AE:  MOVLB  5
0A9B0:  MOVWF  x4D
0A9B2:  MOVLB  0
0A9B4:  MOVF   xCE,W
0A9B6:  SUBWFB x8C,W
0A9B8:  MOVLB  5
0A9BA:  MOVWF  x4E
0A9BC:  MOVF   x4E,F
0A9BE:  BNZ   A9EC
0A9C0:  MOVF   x4D,W
0A9C2:  SUBLW  00
0A9C4:  BTFSS  FD8.0
0A9C6:  BRA    A9CC
0A9C8:  MOVLB  0
0A9CA:  BRA    AA00
0A9CC:  XORLW  FF
0A9CE:  BNZ   A9EC
0A9D0:  MOVF   x4C,W
0A9D2:  SUBLW  50
0A9D4:  BTFSS  FD8.0
0A9D6:  BRA    A9DC
0A9D8:  MOVLB  0
0A9DA:  BRA    AA00
0A9DC:  XORLW  FF
0A9DE:  BNZ   A9EC
0A9E0:  MOVF   x4B,W
0A9E2:  SUBLW  80
0A9E4:  BTFSS  FD8.0
0A9E6:  BRA    A9EC
0A9E8:  MOVLB  0
0A9EA:  BRA    AA00
....................                { 
....................                   global_error_message_bitfield |= ERR_MSG_VLV_CAL_STALE; 
0A9EC:  MOVLB  4
0A9EE:  BSF    xF8.2
....................                   PUSH_MESSAGE_QUEUE_MACRO(MSG_MOTE_ERROR_MSG); 
0A9F0:  BCF    F7A.1
0A9F2:  MOVLW  A0
0A9F4:  MOVLB  5
0A9F6:  MOVWF  x54
0A9F8:  MOVLB  0
0A9FA:  CALL   4FF4
0A9FE:  BSF    F7A.1
.................... #IFNDEF ALLOW_VALVE_SET_WITH_STALE_CAL                   
....................                   break; 
.................... #ENDIF                   
....................                }  
....................  
.................... /* 
....................                // or if you're in the run state and the valve is uncalibrated 
....................                else if ((read_system_state() == SYSTEM_RUN) &&                \ 
....................                   (global_valve_position == VLV_POSITION_UNKNOWN)) 
....................                { 
....................                   global_error_message_bitfield |= ERR_MSG_VLV_NOT_CALIBRATED; 
....................                   PUSH_MESSAGE_QUEUE_MACRO(MSG_MOTE_ERROR_MSG); 
....................                   break; 
....................                } 
.................... */                                            
....................                // if valve movement is not needed (less than one millispan away 
....................                //    and in run state), break out of switch case 
....................                if ((read_system_state() == SYSTEM_RUN) &&                     \ 
....................                (((global_valve_position_set_value - global_valve_position) < 0x20) || \ 
....................                ((global_valve_position - global_valve_position_set_value) < 0x20))) 
0AA00:  CALL   1F02
0AA04:  MOVF   01,W
0AA06:  SUBLW  02
0AA08:  BNZ   AA54
0AA0A:  MOVF   xC1,W
0AA0C:  SUBWF  xC3,W
0AA0E:  MOVLB  5
0AA10:  MOVWF  x4B
0AA12:  MOVLB  0
0AA14:  MOVF   xC2,W
0AA16:  SUBWFB xC4,W
0AA18:  MOVLB  5
0AA1A:  MOVWF  x4C
0AA1C:  MOVF   x4C,F
0AA1E:  BNZ   AA26
0AA20:  MOVF   x4B,W
0AA22:  SUBLW  1F
0AA24:  BC    AA50
0AA26:  MOVLB  0
0AA28:  MOVF   xC3,W
0AA2A:  SUBWF  xC1,W
0AA2C:  MOVLB  5
0AA2E:  MOVWF  x4B
0AA30:  MOVLB  0
0AA32:  MOVF   xC4,W
0AA34:  SUBWFB xC2,W
0AA36:  MOVLB  5
0AA38:  MOVWF  x4C
0AA3A:  MOVF   x4C,F
0AA3C:  BTFSC  FD8.2
0AA3E:  BRA    AA44
0AA40:  MOVLB  0
0AA42:  BRA    AA54
0AA44:  MOVF   x4B,W
0AA46:  SUBLW  1F
0AA48:  BTFSC  FD8.0
0AA4A:  BRA    AA50
0AA4C:  MOVLB  0
0AA4E:  BRA    AA54
....................                {                
....................                   break;    
0AA50:  MOVLB  0
0AA52:  BRA    AFD0
....................                }              
....................                                        
....................                // clear out the time in motion 
....................                global_valve_time_in_motion_1024ths = 0;   
0AA54:  CLRF   xCA
0AA56:  CLRF   xC9
....................                 
....................                // increment the movements since hitting an endstop. Also, check if 
....................                // enough valve movements have happened to warrant a recalibration of 
....................                //    the position of the valve by going towards an endstop 
....................                if ((global_valve_movements_since_endstop++) > VLV_MOVES_BEFORE_RECAL) 
0AA58:  MOVF   xCF,W
0AA5A:  INCF   xCF,F
0AA5C:  SUBLW  19
0AA5E:  BC    AA62
....................                {                                
.................... #IFNDEF  DISABLE_RECAL_VLV                        
....................                   write_system_state(SYSTEM_RECAL_VLV_MOVES);                         
....................                   // quicker to go to the closed endstop. Start motion. 
....................                   if ((global_valve_position_set_value + global_valve_position) >\ 
....................                      VLV_POSITION_OPENED) 
....................                   { 
....................                      CCP_3 = global_valve_time_to_close_1024th; 
....................                      mV_CLOSEm;                                                                    
....................                   } 
....................                   // quicker to go to the open endstop. Start motion. 
....................                   else                           
....................                   { 
....................                      CCP_3 = global_valve_time_to_open_1024th; 
....................                      // don't go to the open endstop to avoid magnetic decoupling 
....................                      //mV_OPENm; 
....................                      mV_CLOSEm; 
....................                   } 
....................  #ENDIF 
....................                } 
0AA60:  BRA    AAC6
....................                 
....................                // regular valve move (without recalibration) 
....................                else 
....................                { 
....................                   // setup CCP3 and put the valve into motion based on target value 
....................                   if (global_valve_position_set_value > global_valve_position) 
0AA62:  MOVF   xC2,W
0AA64:  SUBWF  xC4,W
0AA66:  BNC   AA7E
0AA68:  BNZ   AA70
0AA6A:  MOVF   xC3,W
0AA6C:  SUBWF  xC1,W
0AA6E:  BC    AA7E
....................                   { 
....................                      CCP_3 = global_valve_time_to_open_1024th; 
0AA70:  MOVFF  C8,F5F
0AA74:  MOVFF  C7,F5E
....................                      mV_OPENm;  
0AA78:  MOVLW  02
0AA7A:  MOVWF  F8D
....................                   }                              
0AA7C:  BRA    AAC6
....................                   else if (global_valve_position_set_value < global_valve_position) 
0AA7E:  MOVF   xC4,W
0AA80:  SUBWF  xC2,W
0AA82:  BNC   AA9A
0AA84:  BNZ   AA8C
0AA86:  MOVF   xC1,W
0AA88:  SUBWF  xC3,W
0AA8A:  BC    AA9A
....................                   { 
....................                      CCP_3 = global_valve_time_to_close_1024th; 
0AA8C:  MOVFF  C6,F5F
0AA90:  MOVFF  C5,F5E
....................                      mV_CLOSEm; 
0AA94:  MOVLW  01
0AA96:  MOVWF  F8D
....................                   } 
0AA98:  BRA    AAC6
....................                   else if (global_valve_position_set_value == VLV_POSITION_OPENED) 
0AA9A:  MOVF   xC3,F
0AA9C:  BNZ   AAB2
0AA9E:  MOVF   xC4,W
0AAA0:  SUBLW  80
0AAA2:  BNZ   AAB2
....................                   { 
....................                      CCP_3 = global_valve_time_to_open_1024th; 
0AAA4:  MOVFF  C8,F5F
0AAA8:  MOVFF  C7,F5E
....................                      mV_OPENm;   
0AAAC:  MOVLW  02
0AAAE:  MOVWF  F8D
....................                   } 
0AAB0:  BRA    AAC6
....................                   else if (global_valve_position_set_value == VLV_POSITION_CLOSED) 
0AAB2:  MOVF   xC3,F
0AAB4:  BNZ   AAC6
0AAB6:  MOVF   xC4,F
0AAB8:  BNZ   AAC6
....................                   { 
....................                      CCP_3 = global_valve_time_to_close_1024th; 
0AABA:  MOVFF  C6,F5F
0AABE:  MOVFF  C5,F5E
....................                      mV_CLOSEm; 
0AAC2:  MOVLW  01
0AAC4:  MOVWF  F8D
....................                   }                  
....................                }    
....................                 
....................                // setup/turn on the comparator interrupt (also sets up DAC) 
....................                comparator_setup();                                          
0AAC6:  CALL   8224
....................                 
....................                // setup and enable CCP3 as well as it's respective timer 
....................                setup_ccp3(CCP_USE_TIMER1_AND_TIMER2 | CCP_COMPARE_RESET_TIMER); 
0AACA:  MOVLW  0B
0AACC:  MOVLB  F
0AACE:  MOVWF  x5D
0AAD0:  CLRF   x5C
0AAD2:  CLRF   x5B
0AAD4:  MOVLW  01
0AAD6:  MOVWF  x5A
0AAD8:  MOVLW  3F
0AADA:  ANDWF  x49,F
0AADC:  MOVLW  00
0AADE:  IORWF  x49,F
....................                setup_timer_1(T1_ENABLE_SOSC | T1_EXTERNAL_SYNC | T1_DIV_BY_1); 
0AAE0:  MOVLW  8B
0AAE2:  MOVWF  FCD
0AAE4:  CLRF   FCC
....................                set_timer1(0); 
0AAE6:  CLRF   FCF
0AAE8:  CLRF   FCE
....................                 
....................                // clear any ccp3 interrupt and enable ccp3 interrupt 
....................                clear_interrupt(INT_CCP3); 
0AAEA:  BCF    F7B.0
....................                enable_interrupts(INT_CCP3);            
0AAEC:  BSF    F7A.0
....................                break; 
0AAEE:  MOVLB  0
0AAF0:  BRA    AFD0
....................                 
....................             // Start GPS aquisition 
....................             case START_GPS_AQUISITION: 
....................                break; 
0AAF2:  BRA    AFD0
....................                                                      
....................             // Check GPS for lock 
....................             case CHECK_GPS_FOR_LOCK:     
....................                break;                    
0AAF4:  BRA    AFD0
....................                             
....................             case TAKE_XCDR_MESUREMENT_1: 
....................                // turn on XDCR power (must give ~50ms to settle) 
....................                output_high(XDCR_PWR);                     
0AAF6:  BSF    F8B.5
....................                // queue up the actual meaurement a second later.                    
....................                PUSH_TIME_QUEUE_MACRO(global_rtc_time + 1, TAKE_XCDR_MESUREMENT_2); 
0AAF8:  BCF    F7A.1
0AAFA:  MOVLW  01
0AAFC:  ADDWF  x85,W
0AAFE:  MOVLB  5
0AB00:  MOVWF  x4B
0AB02:  MOVLW  00
0AB04:  MOVLB  0
0AB06:  ADDWFC x86,W
0AB08:  MOVLB  5
0AB0A:  MOVWF  x4C
0AB0C:  MOVLW  00
0AB0E:  MOVLB  0
0AB10:  ADDWFC x87,W
0AB12:  MOVLB  5
0AB14:  MOVWF  x4D
0AB16:  MOVLW  00
0AB18:  MOVLB  0
0AB1A:  ADDWFC x88,W
0AB1C:  MOVLB  5
0AB1E:  MOVWF  x4E
0AB20:  MOVWF  x59
0AB22:  MOVFF  54D,558
0AB26:  MOVFF  54C,557
0AB2A:  MOVFF  54B,556
0AB2E:  MOVLW  56
0AB30:  MOVWF  x5A
0AB32:  MOVLB  0
0AB34:  CALL   4422
0AB38:  BSF    F7A.1
....................                break; 
0AB3A:  BRA    AFD0
....................                                                                                      
....................             case TAKE_XCDR_MESUREMENT_2:    
....................                // take the actual xdcr measurement via the adc (stores the result in global_xdcr_output)     
....................                adc_XDCR_measure();     
0AB3C:  GOTO   8252
....................                // add xdcr message to queue                       
....................                PUSH_MESSAGE_QUEUE_MACRO(MSG_MOTE_XDCR_READ_MSG);  
0AB40:  BCF    F7A.1
0AB42:  MOVLW  98
0AB44:  MOVLB  5
0AB46:  MOVWF  x54
0AB48:  MOVLB  0
0AB4A:  CALL   4FF4
0AB4E:  BSF    F7A.1
....................                break;                                             
0AB50:  BRA    AFD0
....................                                         
....................             // Update the LCD 
....................             // In the future, we're going to have "pages" controlled by the switch. 
....................             case LCD_UPDATE:           
....................                // instructed to skip this update (to show other things on screen)          
....................                 
....................                // disable button press interrupt while accessing shared global lcd variables 
.................... //               disable_interrupts(INT_RB);    
....................                 
....................                // check if long press has exceeded time limit and indicate 
....................                //  to user if so 
....................                 
....................                if (sw1_start_time && ((global_rtc_time - sw1_start_time) > SW1_ISR_LONG_PRESS_TIME)) 
0AB52:  MOVF   x91,F
0AB54:  BNZ   AB62
0AB56:  MOVF   x92,F
0AB58:  BNZ   AB62
0AB5A:  MOVF   x93,F
0AB5C:  BNZ   AB62
0AB5E:  MOVF   x94,F
0AB60:  BZ    ABB4
0AB62:  MOVF   x91,W
0AB64:  SUBWF  x85,W
0AB66:  MOVLB  5
0AB68:  MOVWF  x4B
0AB6A:  MOVLB  0
0AB6C:  MOVF   x92,W
0AB6E:  SUBWFB x86,W
0AB70:  MOVLB  5
0AB72:  MOVWF  x4C
0AB74:  MOVLB  0
0AB76:  MOVF   x93,W
0AB78:  SUBWFB x87,W
0AB7A:  MOVLB  5
0AB7C:  MOVWF  x4D
0AB7E:  MOVLB  0
0AB80:  MOVF   x94,W
0AB82:  SUBWFB x88,W
0AB84:  MOVLB  5
0AB86:  MOVWF  x4E
0AB88:  MOVF   x4E,F
0AB8A:  BNZ   ABA0
0AB8C:  MOVF   x4D,F
0AB8E:  BNZ   ABA0
0AB90:  MOVF   x4C,F
0AB92:  BNZ   ABA0
0AB94:  MOVF   x4B,W
0AB96:  SUBLW  05
0AB98:  BTFSS  FD8.0
0AB9A:  BRA    ABA0
0AB9C:  MOVLB  0
0AB9E:  BRA    ABB4
....................                { 
....................                   flash_led_2(4); 
0ABA0:  MOVLW  04
0ABA2:  MOVWF  x4B
0ABA4:  MOVLB  0
0ABA6:  GOTO   82AA
....................                   sw1_start_time = 0; 
0ABAA:  CLRF   x94
0ABAC:  CLRF   x93
0ABAE:  CLRF   x92
0ABB0:  CLRF   x91
....................                } 
0ABB2:  BRA    ABC2
....................  
....................                else if (global_skip_lcd_update_count > 1)   
0ABB4:  MOVF   x83,W
0ABB6:  SUBLW  01
0ABB8:  BC    ABBE
....................                {                   
....................                   global_skip_lcd_update_count--;     
0ABBA:  DECF   x83,F
....................                } 
0ABBC:  BRA    ABC2
....................                // either normal update or screen clear and update via function call (for multiple pages)     
....................                else                  
....................                {        
....................                   LCD_update_diplay();             
0ABBE:  GOTO   86E4
....................                } 
....................                 
....................                // disable button press interrupt while accessing shared global lcd variables 
.................... //               enable_interrupts(INT_RB);  
....................                  
....................                break;                                          
0ABC2:  BRA    AFD0
....................                 
....................             // recovers from an i2c bus collision interrupt 
....................             case BUSCOL_RESET:                    
....................                BCL1IF = FALSE; 
0ABC4:  BCF    FA1.3
....................                SSP1IF = TRUE; 
0ABC6:  BSF    F9E.3
....................                i2c_init(TRUE);             
0ABC8:  BCF    FCB.0
0ABCA:  BCF    FCB.1
0ABCC:  BCF    FCB.3
0ABCE:  MOVLW  06
0ABD0:  MOVWF  FC8
0ABD2:  MOVLW  28
0ABD4:  MOVWF  FC6
0ABD6:  BSF    FC7.7
0ABD8:  BCF    FC7.6
....................                if (global_lcd_enabled) LCD_init();   
0ABDA:  BTFSC  xA7.0
0ABDC:  CALL   39E8
....................                enable_interrupts(GLOBAL);          
0ABE0:  MOVLW  C0
0ABE2:  IORWF  FF2,F
....................                break;                                                    
0ABE4:  BRA    AFD0
....................                 
....................             // Reset the mote (triggers a wait for boot event) 
....................             case RESET_MOTE:      
....................                // display on screen what is happening 
....................                LCD_clear();             
0ABE6:  CALL   5C18
....................                strcpy (global_temp_line_buff, "Resetting Mote!!"); 
0ABEA:  CLRF   FEA
0ABEC:  MOVLW  70
0ABEE:  MOVWF  FE9
0ABF0:  MOVLW  00
0ABF2:  CALL   0742
0ABF6:  TBLRD*-
0ABF8:  TBLRD*+
0ABFA:  MOVF   FF5,W
0ABFC:  MOVWF  FEE
0ABFE:  IORLW  00
0AC00:  BNZ   ABF8
....................                LCD_line1(global_temp_line_buff); 
0AC02:  MOVLB  5
0AC04:  CLRF   x64
0AC06:  MOVLW  70
0AC08:  MOVWF  x63
0AC0A:  MOVLB  0
0AC0C:  CALL   3932
....................                global_skip_lcd_update_count = 2;    
0AC10:  MOVLW  02
0AC12:  MOVWF  x83
....................                // disable mote enabled flag 
....................                global_dust_enabled = 0;      
0AC14:  BCF    xA7.6
....................                // reset the mote    
....................                mote_reset();  
0AC16:  CALL   4670
....................                break;                            
0AC1A:  BRA    AFD0
....................              
....................             // Make sure the mote is responding to a boot or shutdown 
....................             case WAIT_FOR_BOOT_EVENT:     
....................                // if the mote didn't respond, set error, open valve, shutdown 
....................                if (global_dust_enabled == 0) 
0AC1C:  BTFSC  xA7.6
0AC1E:  BRA    AC6A
....................                {         
....................                   //  
....................                   LCD_clear();    
0AC20:  CALL   5C18
....................                   strcpy (global_temp_line_buff, "Mote is Dead    ");   
0AC24:  CLRF   FEA
0AC26:  MOVLW  70
0AC28:  MOVWF  FE9
0AC2A:  MOVLW  00
0AC2C:  CALL   0764
0AC30:  TBLRD*-
0AC32:  TBLRD*+
0AC34:  MOVF   FF5,W
0AC36:  MOVWF  FEE
0AC38:  IORLW  00
0AC3A:  BNZ   AC32
....................                   LCD_line1(global_temp_line_buff);                   
0AC3C:  MOVLB  5
0AC3E:  CLRF   x64
0AC40:  MOVLW  70
0AC42:  MOVWF  x63
0AC44:  MOVLB  0
0AC46:  CALL   3932
....................                   global_skip_lcd_update_count = 2;   
0AC4A:  MOVLW  02
0AC4C:  MOVWF  x83
....................                   // save shutdown cause and queue shutdown 
....................                   global_shutdown_cause = ERR_FAIL_ON_MOTE_RESET; 
0AC4E:  MOVLW  01
0AC50:  MOVWF  4D
....................  
....................                   PUSH_PRIORITY_QUEUE(OPEN_VALVE_UNKNOWN_STATE);   
0AC52:  MOVLW  3E
0AC54:  MOVLB  5
0AC56:  MOVWF  x52
0AC58:  MOVLB  0
0AC5A:  CALL   46CA
....................                   PUSH_PRIORITY_QUEUE(SHUTDOWN_SYSTEM); 
0AC5E:  MOVLW  F1
0AC60:  MOVLB  5
0AC62:  MOVWF  x52
0AC64:  MOVLB  0
0AC66:  CALL   46CA
....................                }            
....................                break; 
0AC6A:  BRA    AFD0
....................                 
....................             // Check the mote status and react appropriately 
....................             case CHECK_MOTE_STATE: 
....................                mote_state_check(); 
0AC6C:  GOTO   8D5C
....................                break; 
0AC70:  BRA    AFD0
....................                 
....................             case CHECK_MOTE_INFO: 
....................                mote_info_check(); 
0AC72:  GOTO   90C6
....................                break; 
0AC76:  BRA    AFD0
....................                
....................             case UPDATE_MOTE_TIME: 
....................                mote_time_update(); 
0AC78:  GOTO   9154
....................                break;    
0AC7C:  BRA    AFD0
....................                 
....................             case UPDATE_MOTE_NETWORK_INFO: 
....................                get_mote_net_info(); 
0AC7E:  GOTO   91E2
....................                break; 
0AC82:  BRA    AFD0
....................                 
....................             // Check's battery voltage, decides to charge, not charge, tell manager 
....................             // about a low voltage state, or to go to deep sleep 
....................             case CHECK_BATTERY_STATE: 
....................                /* 
....................                LCD_clear(); 
....................                LCD_display_battery_voltage(0); 
....................                LCD_place_uint16(get_vbatt(0),1,0,5); 
....................                global_skip_lcd_update_count = 2; 
....................                */         
....................                check_and_deal_with_battery(); 
0AC84:  GOTO   9270
....................                break; 
0AC88:  BRA    AFD0
....................  
....................             // Added by Jack 2017Feb13 
....................             case SEND_UNSOLICITED_FULL_REPORT: 
....................                send_full_report(MSG_MOTE_UNSOLICITED, global_message_queue[global_current_message_queue_location].msg_seq); 
0AC8A:  MOVLB  4
0AC8C:  MOVF   xF7,W
0AC8E:  MULLW  08
0AC90:  MOVF   FF3,W
0AC92:  MOVLB  5
0AC94:  CLRF   x4C
0AC96:  MOVWF  x4B
0AC98:  MOVLW  05
0AC9A:  ADDWF  x4B,W
0AC9C:  MOVWF  01
0AC9E:  MOVLW  00
0ACA0:  ADDWFC x4C,W
0ACA2:  MOVWF  03
0ACA4:  MOVF   01,W
0ACA6:  ADDLW  A7
0ACA8:  MOVWF  FE9
0ACAA:  MOVLW  04
0ACAC:  ADDWFC 03,W
0ACAE:  MOVWF  FEA
0ACB0:  MOVFF  FEC,554
0ACB4:  MOVF   FED,F
0ACB6:  MOVFF  FEF,553
0ACBA:  CLRF   x52
0ACBC:  MOVLB  0
0ACBE:  CALL   6222
....................                break; 
0ACC2:  BRA    AFD0
....................              
....................              
....................             // Query the mote for the temp and store it 
....................             case CHECK_MOTE_TEMP: 
....................                mote_temp_check(); 
0ACC4:  GOTO   938E
....................                /* 
....................                LCD_clear(); 
....................                strcpy (global_temp_line_buff, "Temp =         C");     
....................                LCD_line1(global_temp_line_buff); 
....................                LCD_place_uint8(global_mote_temperature,0,7,3); 
....................                global_skip_lcd_update_count = 2; 
....................                */ 
....................                break; 
0ACC8:  BRA    AFD0
....................                 
....................             // First part of the search for strongest algorithm 
....................             case SEARCH_FOR_STRONGEST_1: 
....................                LCD_clear(); 
0ACCA:  CALL   5C18
....................                strcpy (global_temp_line_buff, "Search Strong 1 "); 
0ACCE:  CLRF   FEA
0ACD0:  MOVLW  70
0ACD2:  MOVWF  FE9
0ACD4:  MOVLW  00
0ACD6:  CALL   0786
0ACDA:  TBLRD*-
0ACDC:  TBLRD*+
0ACDE:  MOVF   FF5,W
0ACE0:  MOVWF  FEE
0ACE2:  IORLW  00
0ACE4:  BNZ   ACDC
....................                LCD_line1(global_temp_line_buff); 
0ACE6:  MOVLB  5
0ACE8:  CLRF   x64
0ACEA:  MOVLW  70
0ACEC:  MOVWF  x63
0ACEE:  MOVLB  0
0ACF0:  CALL   3932
....................                global_skip_lcd_update_count = 2; 
0ACF4:  MOVLW  02
0ACF6:  MOVWF  x83
....................                // set the state of the system appropriately 
....................                global_system_state = SYSTEM_SEARCHING_FOR_NETWORK; 
0ACF8:  MOVLW  20
0ACFA:  MOVLB  5
0ACFC:  MOVWF  x05
....................                PUSH_PRIORITY_QUEUE_MACRO(RESET_MOTE); 
0ACFE:  BCF    F7A.1
0AD00:  MOVLW  11
0AD02:  MOVWF  x52
0AD04:  MOVLB  0
0AD06:  CALL   46CA
0AD0A:  BSF    F7A.1
....................                PUSH_TIME_QUEUE_MACRO((global_rtc_time + 10), SEARCH_FOR_STRONGEST_2); 
0AD0C:  BCF    F7A.1
0AD0E:  MOVLW  0A
0AD10:  ADDWF  x85,W
0AD12:  MOVLB  5
0AD14:  MOVWF  x4B
0AD16:  MOVLW  00
0AD18:  MOVLB  0
0AD1A:  ADDWFC x86,W
0AD1C:  MOVLB  5
0AD1E:  MOVWF  x4C
0AD20:  MOVLW  00
0AD22:  MOVLB  0
0AD24:  ADDWFC x87,W
0AD26:  MOVLB  5
0AD28:  MOVWF  x4D
0AD2A:  MOVLW  00
0AD2C:  MOVLB  0
0AD2E:  ADDWFC x88,W
0AD30:  MOVLB  5
0AD32:  MOVWF  x4E
0AD34:  MOVWF  x59
0AD36:  MOVFF  54D,558
0AD3A:  MOVFF  54C,557
0AD3E:  MOVFF  54B,556
0AD42:  MOVLW  B2
0AD44:  MOVWF  x5A
0AD46:  MOVLB  0
0AD48:  CALL   4422
0AD4C:  BSF    F7A.1
....................                break; 
0AD4E:  BRA    AFD0
....................                 
....................             // Second part of the search for strongest algorithm    
....................             case SEARCH_FOR_STRONGEST_2: 
....................                LCD_clear(); 
0AD50:  CALL   5C18
....................                strcpy (global_temp_line_buff, "Search Strong 2 "); 
0AD54:  CLRF   FEA
0AD56:  MOVLW  70
0AD58:  MOVWF  FE9
0AD5A:  MOVLW  00
0AD5C:  CALL   07A8
0AD60:  TBLRD*-
0AD62:  TBLRD*+
0AD64:  MOVF   FF5,W
0AD66:  MOVWF  FEE
0AD68:  IORLW  00
0AD6A:  BNZ   AD62
....................                LCD_line1(global_temp_line_buff); 
0AD6C:  MOVLB  5
0AD6E:  CLRF   x64
0AD70:  MOVLW  70
0AD72:  MOVWF  x63
0AD74:  MOVLB  0
0AD76:  CALL   3932
....................                global_skip_lcd_update_count = 2; 
0AD7A:  MOVLW  02
0AD7C:  MOVWF  x83
....................                search_for_strongest(); 
0AD7E:  GOTO   97A6
....................                break; 
0AD82:  BRA    AFD0
....................              
....................             // Initalizes a mote join 
....................             case INIT_JOIN: 
....................                LCD_clear(); 
0AD84:  CALL   5C18
....................                strcpy (global_temp_line_buff, "  Init Join     "); 
0AD88:  CLRF   FEA
0AD8A:  MOVLW  70
0AD8C:  MOVWF  FE9
0AD8E:  MOVLW  00
0AD90:  CALL   07CA
0AD94:  TBLRD*-
0AD96:  TBLRD*+
0AD98:  MOVF   FF5,W
0AD9A:  MOVWF  FEE
0AD9C:  IORLW  00
0AD9E:  BNZ   AD96
....................                LCD_line1(global_temp_line_buff); 
0ADA0:  MOVLB  5
0ADA2:  CLRF   x64
0ADA4:  MOVLW  70
0ADA6:  MOVWF  x63
0ADA8:  MOVLB  0
0ADAA:  CALL   3932
....................                global_skip_lcd_update_count = 2;   
0ADAE:  MOVLW  02
0ADB0:  MOVWF  x83
....................                initiate_join();                                      
0ADB2:  GOTO   9BCE
....................                break; 
0ADB6:  BRA    AFD0
....................              
....................             // not used anymore 
....................             case OPTIMIZE_MPPC: 
....................                adjust_mppc();   
0ADB8:  GOTO   9D48
....................                break;             
0ADBC:  BRA    AFD0
....................                 
....................             // resets the cpu (if all pending messages are sent)    
....................             case CPU_RESET: 
....................                // if the dust network is operational and the message queue is not empty (location at 255) 
....................                //    wait for the message to be ack'd/resent and reschedule the shutdown.  
....................                if ((global_dust_operational == TRUE) && (global_current_message_queue_location != 255)) 
0ADBE:  BTFSS  xA7.7
0ADC0:  BRA    AE14
0ADC2:  MOVLB  4
0ADC4:  INCFSZ xF7,W
0ADC6:  BRA    ADCE
0ADC8:  MOVLB  0
0ADCA:  BRA    AE14
0ADCC:  MOVLB  4
....................                { 
....................                   PUSH_TIME_QUEUE_MACRO((global_rtc_time + 10), CPU_RESET); 
0ADCE:  BCF    F7A.1
0ADD0:  MOVLW  0A
0ADD2:  MOVLB  0
0ADD4:  ADDWF  x85,W
0ADD6:  MOVLB  5
0ADD8:  MOVWF  x4B
0ADDA:  MOVLW  00
0ADDC:  MOVLB  0
0ADDE:  ADDWFC x86,W
0ADE0:  MOVLB  5
0ADE2:  MOVWF  x4C
0ADE4:  MOVLW  00
0ADE6:  MOVLB  0
0ADE8:  ADDWFC x87,W
0ADEA:  MOVLB  5
0ADEC:  MOVWF  x4D
0ADEE:  MOVLW  00
0ADF0:  MOVLB  0
0ADF2:  ADDWFC x88,W
0ADF4:  MOVLB  5
0ADF6:  MOVWF  x4E
0ADF8:  MOVWF  x59
0ADFA:  MOVFF  54D,558
0ADFE:  MOVFF  54C,557
0AE02:  MOVFF  54B,556
0AE06:  MOVLW  F0
0AE08:  MOVWF  x5A
0AE0A:  MOVLB  0
0AE0C:  CALL   4422
0AE10:  BSF    F7A.1
....................                } 
0AE12:  BRA    AE62
....................                // if the valve is moving, check again later 
....................                else if (!IS_VLV_COASTING) 
0AE14:  MOVF   F8D,F
0AE16:  BZ    AE5C
....................                {                       
....................                   PUSH_TIME_QUEUE_MACRO((global_rtc_time + 10), CPU_RESET); 
0AE18:  BCF    F7A.1
0AE1A:  MOVLW  0A
0AE1C:  ADDWF  x85,W
0AE1E:  MOVLB  5
0AE20:  MOVWF  x4B
0AE22:  MOVLW  00
0AE24:  MOVLB  0
0AE26:  ADDWFC x86,W
0AE28:  MOVLB  5
0AE2A:  MOVWF  x4C
0AE2C:  MOVLW  00
0AE2E:  MOVLB  0
0AE30:  ADDWFC x87,W
0AE32:  MOVLB  5
0AE34:  MOVWF  x4D
0AE36:  MOVLW  00
0AE38:  MOVLB  0
0AE3A:  ADDWFC x88,W
0AE3C:  MOVLB  5
0AE3E:  MOVWF  x4E
0AE40:  MOVWF  x59
0AE42:  MOVFF  54D,558
0AE46:  MOVFF  54C,557
0AE4A:  MOVFF  54B,556
0AE4E:  MOVLW  F0
0AE50:  MOVWF  x5A
0AE52:  MOVLB  0
0AE54:  CALL   4422
0AE58:  BSF    F7A.1
....................                } 
0AE5A:  BRA    AE62
....................                // All messages are sent 
....................                else 
....................                { 
....................                   // if it does, restart the entire system 
....................                   store_all_eeprom_values(); 
0AE5C:  CALL   9E22
....................                   reset_cpu(); 
0AE60:  RESET
....................                } 
....................                break; 
0AE62:  BRA    AFD0
....................                 
....................             // Shuts down the pic for a variety of reasons 
....................             case SHUTDOWN_SYSTEM:                
....................                // if the dust network is operational and the message queue is not empty (location at 255) 
....................                //    wait for the message to be ack'd/resent and reschedule the shutdown. 
....................                // I suppose this has potential to be problamatic, but the network should eventually show 
....................                //    up as non-operational in mote-check or get ack'd at some point, I would hope. 
....................                                                               
....................                global_brake_duty_set_value = NO_BRK; 
0AE64:  CLRF   xB7
0AE66:  CLRF   xB6
....................                global_charge_duty_set_value = NO_CHARGE; 
0AE68:  CLRF   xB9
0AE6A:  CLRF   xB8
....................                global_control_loop_mechanism = NO_RPM_CONTROL_DYN_MPPC; 
0AE6C:  MOVLW  06
0AE6E:  MOVWF  xC0
....................                 
....................                // if the system hasn't moved the brake and charge settings to 0, wait 
....................                if ((global_brake_duty != NO_BRK) || (global_charge_duty != NO_CHARGE)) 
0AE70:  MOVF   xB2,F
0AE72:  BNZ   AE80
0AE74:  MOVF   xB3,F
0AE76:  BNZ   AE80
0AE78:  MOVF   xB4,F
0AE7A:  BNZ   AE80
0AE7C:  MOVF   xB5,F
0AE7E:  BZ    AE84
....................                { 
....................                   break; 
0AE80:  BRA    AFD0
....................                }                
0AE82:  BRA    AFCE
....................                // if there are still messages to be sent and the mote is working, wait 
....................                else if ((global_dust_operational == TRUE) && (global_current_message_queue_location != 255)) 
0AE84:  BTFSS  xA7.7
0AE86:  BRA    AEDA
0AE88:  MOVLB  4
0AE8A:  INCFSZ xF7,W
0AE8C:  BRA    AE94
0AE8E:  MOVLB  0
0AE90:  BRA    AEDA
0AE92:  MOVLB  4
....................                {                                                 
....................                   PUSH_TIME_QUEUE_MACRO((global_rtc_time + 10), SHUTDOWN_SYSTEM); 
0AE94:  BCF    F7A.1
0AE96:  MOVLW  0A
0AE98:  MOVLB  0
0AE9A:  ADDWF  x85,W
0AE9C:  MOVLB  5
0AE9E:  MOVWF  x4B
0AEA0:  MOVLW  00
0AEA2:  MOVLB  0
0AEA4:  ADDWFC x86,W
0AEA6:  MOVLB  5
0AEA8:  MOVWF  x4C
0AEAA:  MOVLW  00
0AEAC:  MOVLB  0
0AEAE:  ADDWFC x87,W
0AEB0:  MOVLB  5
0AEB2:  MOVWF  x4D
0AEB4:  MOVLW  00
0AEB6:  MOVLB  0
0AEB8:  ADDWFC x88,W
0AEBA:  MOVLB  5
0AEBC:  MOVWF  x4E
0AEBE:  MOVWF  x59
0AEC0:  MOVFF  54D,558
0AEC4:  MOVFF  54C,557
0AEC8:  MOVFF  54B,556
0AECC:  MOVLW  F1
0AECE:  MOVWF  x5A
0AED0:  MOVLB  0
0AED2:  CALL   4422
0AED6:  BSF    F7A.1
....................                } 
0AED8:  BRA    AFCE
....................                // if the valve is moving, wait                           
....................                else if (!IS_VLV_COASTING) 
0AEDA:  MOVF   F8D,F
0AEDC:  BZ    AF22
....................                { 
....................                   PUSH_TIME_QUEUE_MACRO((global_rtc_time + 10), SHUTDOWN_SYSTEM); 
0AEDE:  BCF    F7A.1
0AEE0:  MOVLW  0A
0AEE2:  ADDWF  x85,W
0AEE4:  MOVLB  5
0AEE6:  MOVWF  x4B
0AEE8:  MOVLW  00
0AEEA:  MOVLB  0
0AEEC:  ADDWFC x86,W
0AEEE:  MOVLB  5
0AEF0:  MOVWF  x4C
0AEF2:  MOVLW  00
0AEF4:  MOVLB  0
0AEF6:  ADDWFC x87,W
0AEF8:  MOVLB  5
0AEFA:  MOVWF  x4D
0AEFC:  MOVLW  00
0AEFE:  MOVLB  0
0AF00:  ADDWFC x88,W
0AF02:  MOVLB  5
0AF04:  MOVWF  x4E
0AF06:  MOVWF  x59
0AF08:  MOVFF  54D,558
0AF0C:  MOVFF  54C,557
0AF10:  MOVFF  54B,556
0AF14:  MOVLW  F1
0AF16:  MOVWF  x5A
0AF18:  MOVLB  0
0AF1A:  CALL   4422
0AF1E:  BSF    F7A.1
....................                }                                 
0AF20:  BRA    AFCE
....................                // All messages are sent or system is shutting down due to no network connection  
....................                //    and system is in SYSTEM_RUN or SYSTEM_IDLE state  
....................                else if ((read_system_state() == SYSTEM_RUN) || ((read_system_state() == SYSTEM_IDLE))) 
0AF22:  CALL   1F02
0AF26:  MOVF   01,W
0AF28:  SUBLW  02
0AF2A:  BZ    AF36
0AF2C:  CALL   1F02
0AF30:  MOVF   01,W
0AF32:  SUBLW  03
0AF34:  BNZ   AF8C
....................                { 
....................                   // try to put the mote to sleep 
....................                   if (mote_sleep() == NO_ERR)          
0AF36:  GOTO   9E96
0AF3A:  MOVF   01,F
0AF3C:  BNZ   AF48
....................                   { 
....................                      // if it does, put the entire system to sleep 
....................                      store_all_eeprom_values(); 
0AF3E:  CALL   9E22
....................                      deep_sleep(); 
0AF42:  CALL   9538
....................                   } 
0AF46:  BRA    AF8A
....................                   // otherwise, try again in 10 seconds    
....................                   else 
....................                   { 
....................                      PUSH_TIME_QUEUE_MACRO((global_rtc_time + 10), SHUTDOWN_SYSTEM); 
0AF48:  BCF    F7A.1
0AF4A:  MOVLW  0A
0AF4C:  ADDWF  x85,W
0AF4E:  MOVLB  5
0AF50:  MOVWF  x4B
0AF52:  MOVLW  00
0AF54:  MOVLB  0
0AF56:  ADDWFC x86,W
0AF58:  MOVLB  5
0AF5A:  MOVWF  x4C
0AF5C:  MOVLW  00
0AF5E:  MOVLB  0
0AF60:  ADDWFC x87,W
0AF62:  MOVLB  5
0AF64:  MOVWF  x4D
0AF66:  MOVLW  00
0AF68:  MOVLB  0
0AF6A:  ADDWFC x88,W
0AF6C:  MOVLB  5
0AF6E:  MOVWF  x4E
0AF70:  MOVWF  x59
0AF72:  MOVFF  54D,558
0AF76:  MOVFF  54C,557
0AF7A:  MOVFF  54B,556
0AF7E:  MOVLW  F1
0AF80:  MOVWF  x5A
0AF82:  MOVLB  0
0AF84:  CALL   4422
0AF88:  BSF    F7A.1
....................                   } 
....................                } 
0AF8A:  BRA    AFCE
....................                // Anything else, just wait 
....................                else 
....................                { 
....................                   PUSH_TIME_QUEUE_MACRO((global_rtc_time + 10), SHUTDOWN_SYSTEM); 
0AF8C:  BCF    F7A.1
0AF8E:  MOVLW  0A
0AF90:  ADDWF  x85,W
0AF92:  MOVLB  5
0AF94:  MOVWF  x4B
0AF96:  MOVLW  00
0AF98:  MOVLB  0
0AF9A:  ADDWFC x86,W
0AF9C:  MOVLB  5
0AF9E:  MOVWF  x4C
0AFA0:  MOVLW  00
0AFA2:  MOVLB  0
0AFA4:  ADDWFC x87,W
0AFA6:  MOVLB  5
0AFA8:  MOVWF  x4D
0AFAA:  MOVLW  00
0AFAC:  MOVLB  0
0AFAE:  ADDWFC x88,W
0AFB0:  MOVLB  5
0AFB2:  MOVWF  x4E
0AFB4:  MOVWF  x59
0AFB6:  MOVFF  54D,558
0AFBA:  MOVFF  54C,557
0AFBE:  MOVFF  54B,556
0AFC2:  MOVLW  F1
0AFC4:  MOVWF  x5A
0AFC6:  MOVLB  0
0AFC8:  CALL   4422
0AFCC:  BSF    F7A.1
....................                } 
....................                break; 
0AFCE:  BRA    AFD0
....................                 
....................             // updates  
....................             // Default case (nothing to do)                
....................             case EMPTY_PRIORITY_QUEUE: 
....................                //LCD_place_uint32(global_rtc_time, 1, 0, 10); 
....................                break; 
....................          } 
....................           
....................       } 
0AFD0:  GOTO   A3BA
.................... ////////////////////End of Priority Queue Handling///////////////////////////// 
....................    // end of inifinite while loop 
....................    }    
.................... } 
....................  
....................  
.................... //#PRIORITY COMP, CCP5, EXT2, CCP3, CCP4, BUSCOL 
.................... #PRIORITY CCP5, COMP, CCP3, EXT2, TIMER0, CCP4, BUSCOL, INT_RB, EXT           
....................                                                                      
.................... #INT_RB          
.................... void RB_ISR(void)                                
0AFD4:  SLEEP 
.................... {                           
....................    // Setup in periph init to be called only when RB4 has changed state 
....................    // RB4 is connected to SW1n  
....................     
....................    // keeps track of when the switch was pressed so we can enable the long press functionality      
....................  
....................    if (!input(SW1n)) 
*
007EC:  BTFSC  F81.4
007EE:  BRA    0802
....................    { 
....................       sw1_start_time = global_rtc_time; 
007F0:  MOVFF  88,94
007F4:  MOVFF  87,93
007F8:  MOVFF  86,92
007FC:  MOVFF  85,91
....................       return; 
00800:  BRA    081C
....................    }            
....................     
....................    sw1_start_time = 0; 
00802:  CLRF   x94
00804:  CLRF   x93
00806:  CLRF   x92
00808:  CLRF   x91
....................    // if you're incrementing past the last page, reset to the first page   
....................    if (global_lcd_page_number == TOTAL_LCD_PAGES) 
0080A:  MOVF   x84,W
0080C:  SUBLW  04
0080E:  BNZ   0816
....................    {                                             
....................       global_lcd_page_number = 1;    
00810:  MOVLW  01
00812:  MOVWF  x84
....................    }      
00814:  BRA    0818
....................    // otherwise, just increment the page number 
....................    else     
....................    { 
....................       global_lcd_page_number++; 
00816:  INCF   x84,F
....................    }  
....................     
....................    // trigger a full LCD update (including the contstant parts of the lcd) 
....................    global_skip_lcd_update_count = 1;       
00818:  MOVLW  01
0081A:  MOVWF  x83
....................           
....................    return; 
....................     
....................     
....................        
....................    // not quite ready for prime time long press code (causes boot-looping, but is probably close) 
....................    // if SW1 is depressed (active), take note of the time  
....................     
.................... /*   
....................    if (!input(SW1n)) 
....................    { 
....................       sw1_start_time = global_rtc_time;   
....................    }                                  
....................    // when SW1 is coming back up  
....................    else                   
....................    {                                         
....................       // if the button has been pressed more than SW1_ISR_LONG_PRESS_TIME     
....................       //    do the long-press action 
....................       if ((global_rtc_time - sw1_start_time) > SW1_ISR_LONG_PRESS_TIME) 
....................       {                   
....................          // long-press action 
....................          flash_leds_ISR(2);  
....................       }         
....................                                            
....................       // if the button had been pressed less than SW1_ISR_LONG_PRESS_TIME, increment the page    
....................       else 
....................       {         
....................          // if you're incrementing past the last page, reset to the first page   
....................          if (global_lcd_page_number == TOTAL_LCD_PAGES) 
....................          {                                             
....................             global_lcd_page_number = 1;    
....................          }      
....................          // otherwie, just increment the page number 
....................          else     
....................          { 
....................             global_lcd_page_number++; 
....................          }  
....................                                             
....................          // trigger a full LCD update (including the contstant parts of the lcd) 
....................          global_skip_lcd_update_count = 1;                  
....................       } 
....................       return; 
....................    } 
....................  */ 
....................   
.................... } 
....................  
....................  
0081C:  BCF    FF2.0
0081E:  GOTO   00A0
.................... #INT_EXT HIGH   
.................... void vgen_wakeup_ISR(void) 
.................... { 
.................... // runs on wakeup from vgen int 
....................    reset_cpu();                  
00822:  RESET
.................... }                 
....................  
00824:  BCF    FF2.1
00826:  GOTO   015E
.................... #INT_BUSCOL 
.................... void BUSCOL_ISR(void)   
.................... {   
.................... // Catches and recovers from an i2c bus collision  
....................  
....................    // are reenabled in MAIN        
....................    disable_interrupts(GLOBAL); 
*
008DC:  BCF    FF2.6
008DE:  BCF    FF2.7
008E0:  BTFSC  FF2.7
008E2:  BRA    08DE
....................     
....................    // clear bus collision interrupt flag 
....................    BCL1IF = FALSE; 
008E4:  BCF    FA1.3
008E6:  CLRF   19
008E8:  BTFSC  FF2.7
008EA:  BSF    19.7
008EC:  BCF    FF2.7
....................     
....................    // schedule a bus collision reset 
....................    PUSH_PRIORITY_QUEUE_ISR_MACRO(BUSCOL_RESET); 
008EE:  MOVLW  C0
008F0:  MOVLB  5
008F2:  MOVWF  xB7
008F4:  MOVLB  0
008F6:  RCALL  082A
008F8:  BTFSC  19.7
008FA:  BSF    FF2.7
....................  
....................    // if the lcd is connected, reset it 
....................    if (global_lcd_enabled) 
008FC:  BTFSS  xA7.0
008FE:  BRA    090C
....................    {   
....................       output_low(LCD_RESETn); 
00900:  BCF    F8C.2
....................       delay_cycles(64);       // about 1 millisecond 
00902:  MOVLW  15
00904:  MOVWF  00
00906:  DECFSZ 00,F
00908:  BRA    0906
....................       output_high(LCD_RESETn); 
0090A:  BSF    F8C.2
....................    }    
....................     
....................    // send the stack pointer to position 1 (perhaps sort of dangerous) 
....................    STKPTR = 1; 
0090C:  MOVLW  01
0090E:  MOVWF  FFC
.................... } 
....................  
00910:  BCF    FA1.3
00912:  GOTO   00A0
.................... #INT_EXT2  
.................... void mote_interrupt(void) 
.................... {    
.................... // interrupt called when mote rts line gets asserted    
....................    uint8_t     tmp_oscccon, tmp_t2con, tmp_pr2, tmp_t0con; 
....................     
....................    // save the current oscillator setup 
....................    tmp_oscccon = OSCCON; 
*
017A8:  MOVFF  FD3,583
....................    tmp_t2con = T2CON; 
017AC:  MOVFF  FBA,584
....................    tmp_pr2 = PR2; 
017B0:  MOVFF  FBB,585
....................    tmp_t0con = T0CON; 
017B4:  MOVFF  FD5,586
....................     
....................    // start primary (3.8Mhz) crystal for UART communication 
....................    fosc_pri_ISR(); 
017B8:  GOTO   0916
....................     
....................    // disable int_ccp4 as (unsolicited) message queue can overwrite payload_buff 
....................    disable_interrupts(INT_CCP4); 
017BC:  BCF    F7A.1
....................                                    
....................    // recieve serial data, respond, and schedule deal with packet if necessary 
....................    deal_with_mote_ISR(); 
017BE:  BRA    1248
....................     
....................    // renable int_ccp4 as we're done touching payload_buff       
....................    enable_interrupts(INT_CCP4);   
017C0:  BSF    F7A.1
....................                                      
....................    // restore the current oscillator 
....................    OSCCON = tmp_oscccon; 
017C2:  MOVFF  583,FD3
....................    T2CON = tmp_t2con; 
017C6:  MOVFF  584,FBA
....................    T0CON = tmp_t0con; 
017CA:  MOVFF  586,FD5
....................    PR2 = tmp_PR2; 
017CE:  MOVFF  585,FBB
.................... } 
....................  
....................  
017D2:  BCF    FF0.1
017D4:  GOTO   00A0
.................... #INT_COMP 
.................... void comp1_ISR(void) 
.................... { 
.................... // ISR routine that is called when the comparator current limit is reached 
....................    uint16_t    temp16_frac; 
....................     
....................     // if comarator 1 is tripped (INT_COMP is triggered by comp 1 or 2) 
....................    if (C1OUT) 
*
01A6E:  BTFSS  F79.6
01A70:  BRA    1EFC
....................    {      
....................       // grab the extra time/2ndary osc ticks since the last 1024th interrupt   
....................       temp16_frac = get_timer1(); 
01A72:  MOVF   FCE,W
01A74:  MOVLB  5
01A76:  MOVWF  x83
01A78:  MOVFF  FCF,584
....................        
....................       if (global_system_state == SYSTEM_CAL_VLV_1) 
01A7C:  MOVF   x05,W
01A7E:  SUBLW  10
01A80:  BNZ   1AD6
....................       { 
....................          global_valve_position = VLV_POSITION_OPENED; 
01A82:  MOVLW  80
01A84:  MOVLB  0
01A86:  MOVWF  xC2
01A88:  CLRF   xC1
....................          // queue up the next stage of the calibration 
....................          push_time_queue_ISR(global_rtc_time + 3, CALIBRATE_VALVE_2); 
01A8A:  MOVLW  03
01A8C:  ADDWF  x85,W
01A8E:  MOVLB  5
01A90:  MOVWF  x85
01A92:  MOVLW  00
01A94:  MOVLB  0
01A96:  ADDWFC x86,W
01A98:  MOVLB  5
01A9A:  MOVWF  x86
01A9C:  MOVLW  00
01A9E:  MOVLB  0
01AA0:  ADDWFC x87,W
01AA2:  MOVLB  5
01AA4:  MOVWF  x87
01AA6:  MOVLW  00
01AA8:  MOVLB  0
01AAA:  ADDWFC x88,W
01AAC:  MOVLB  5
01AAE:  MOVWF  x88
01AB0:  CLRF   19
01AB2:  BTFSC  FF2.7
01AB4:  BSF    19.7
01AB6:  BCF    FF2.7
01AB8:  MOVWF  xBE
01ABA:  MOVFF  587,5BD
01ABE:  MOVFF  586,5BC
01AC2:  MOVFF  585,5BB
01AC6:  MOVLW  32
01AC8:  MOVWF  xBF
01ACA:  MOVLB  0
01ACC:  RCALL  17D8
01ACE:  BTFSC  19.7
01AD0:  BSF    FF2.7
....................       } 
01AD2:  BRA    1EE4
01AD4:  MOVLB  5
....................       // valve closing towards closing endstop pre-calibration 
....................       else if (global_system_state == SYSTEM_CAL_VLV_2) 
01AD6:  MOVF   x05,W
01AD8:  SUBLW  11
01ADA:  BNZ   1B2E
....................       { 
....................          global_valve_position = VLV_POSITION_CLOSED;  
01ADC:  MOVLB  0
01ADE:  CLRF   xC2
01AE0:  CLRF   xC1
....................          // queue up the next stage of the calibration 
....................          push_time_queue_ISR(global_rtc_time + 3, CALIBRATE_VALVE_3); 
01AE2:  MOVLW  03
01AE4:  ADDWF  x85,W
01AE6:  MOVLB  5
01AE8:  MOVWF  x85
01AEA:  MOVLW  00
01AEC:  MOVLB  0
01AEE:  ADDWFC x86,W
01AF0:  MOVLB  5
01AF2:  MOVWF  x86
01AF4:  MOVLW  00
01AF6:  MOVLB  0
01AF8:  ADDWFC x87,W
01AFA:  MOVLB  5
01AFC:  MOVWF  x87
01AFE:  MOVLW  00
01B00:  MOVLB  0
01B02:  ADDWFC x88,W
01B04:  MOVLB  5
01B06:  MOVWF  x88
01B08:  CLRF   19
01B0A:  BTFSC  FF2.7
01B0C:  BSF    19.7
01B0E:  BCF    FF2.7
01B10:  MOVWF  xBE
01B12:  MOVFF  587,5BD
01B16:  MOVFF  586,5BC
01B1A:  MOVFF  585,5BB
01B1E:  MOVLW  33
01B20:  MOVWF  xBF
01B22:  MOVLB  0
01B24:  RCALL  17D8
01B26:  BTFSC  19.7
01B28:  BSF    FF2.7
....................       } 
01B2A:  BRA    1EE4
01B2C:  MOVLB  5
....................       // valve opening fully from fully closed for calibration 
....................       else if (global_system_state == SYSTEM_CAL_VLV_3) 
01B2E:  MOVF   x05,W
01B30:  SUBLW  12
01B32:  BNZ   1C12
....................       { 
....................          // set the valve position to open 
....................          global_valve_position = VLV_POSITION_OPENED;  
01B34:  MOVLW  80
01B36:  MOVLB  0
01B38:  MOVWF  xC2
01B3A:  CLRF   xC1
....................          // recalculate the valve opening time for each 1024th 
....................          //    (valve movements (1024th) * the time it takes for each 1024th 
....................          //    + the extra time) divided by 1024 
....................          global_valve_time_to_open_1024th =                                   \ 
....................          ((((uint32_t) global_valve_time_in_motion_1024ths * (uint32_t) global_valve_time_to_open_1024th) \ 
....................          + temp16_frac) >> 10); 
01B3C:  MOVLB  5
01B3E:  CLRF   x88
01B40:  CLRF   x87
01B42:  MOVFF  CA,586
01B46:  MOVFF  C9,585
01B4A:  MOVFF  C7,00
01B4E:  MOVFF  C8,01
01B52:  CLRF   02
01B54:  CLRF   03
01B56:  MOVFF  03,58C
01B5A:  MOVFF  02,58B
01B5E:  MOVFF  C8,58A
01B62:  MOVFF  C7,589
01B66:  MOVFF  588,590
01B6A:  MOVFF  587,58F
01B6E:  MOVFF  CA,58E
01B72:  MOVFF  C9,58D
01B76:  MOVFF  03,594
01B7A:  MOVFF  02,593
01B7E:  MOVFF  C8,592
01B82:  MOVFF  C7,591
01B86:  MOVLB  0
01B88:  RCALL  1A12
01B8A:  MOVFF  03,588
01B8E:  MOVFF  02,587
01B92:  MOVFF  01,586
01B96:  MOVFF  00,585
01B9A:  MOVLB  5
01B9C:  MOVF   x83,W
01B9E:  ADDWF  x85,F
01BA0:  MOVF   x84,W
01BA2:  ADDWFC x86,F
01BA4:  MOVLW  00
01BA6:  ADDWFC x87,F
01BA8:  ADDWFC x88,F
01BAA:  RRCF   x88,W
01BAC:  MOVWF  02
01BAE:  RRCF   x87,W
01BB0:  MOVWF  01
01BB2:  RRCF   x86,W
01BB4:  MOVWF  00
01BB6:  RRCF   02,F
01BB8:  RRCF   01,F
01BBA:  RRCF   00,F
01BBC:  MOVFF  00,C7
01BC0:  MOVLB  0
01BC2:  MOVFF  01,C8
....................          // queue up the next stage of the calibration 
....................          push_time_queue_ISR(global_rtc_time + 3, CALIBRATE_VALVE_5); 
01BC6:  MOVLW  03
01BC8:  ADDWF  x85,W
01BCA:  MOVLB  5
01BCC:  MOVWF  x85
01BCE:  MOVLW  00
01BD0:  MOVLB  0
01BD2:  ADDWFC x86,W
01BD4:  MOVLB  5
01BD6:  MOVWF  x86
01BD8:  MOVLW  00
01BDA:  MOVLB  0
01BDC:  ADDWFC x87,W
01BDE:  MOVLB  5
01BE0:  MOVWF  x87
01BE2:  MOVLW  00
01BE4:  MOVLB  0
01BE6:  ADDWFC x88,W
01BE8:  MOVLB  5
01BEA:  MOVWF  x88
01BEC:  CLRF   19
01BEE:  BTFSC  FF2.7
01BF0:  BSF    19.7
01BF2:  BCF    FF2.7
01BF4:  MOVWF  xBE
01BF6:  MOVFF  587,5BD
01BFA:  MOVFF  586,5BC
01BFE:  MOVFF  585,5BB
01C02:  MOVLW  35
01C04:  MOVWF  xBF
01C06:  MOVLB  0
01C08:  RCALL  17D8
01C0A:  BTFSC  19.7
01C0C:  BSF    FF2.7
....................       } 
01C0E:  BRA    1EE4
01C10:  MOVLB  5
....................       // valve closing fully from fully open for calibration 
....................       else if (global_system_state == SYSTEM_CAL_VLV_5) 
01C12:  MOVF   x05,W
01C14:  SUBLW  14
01C16:  BNZ   1CF4
....................       { 
....................          global_valve_position = VLV_POSITION_CLOSED;  
01C18:  MOVLB  0
01C1A:  CLRF   xC2
01C1C:  CLRF   xC1
....................          // recalculate the valve closing time for each 1024th 
....................          //    (valve movements (1024th) * the time it takes for each 1024th 
....................          //    + the extra time) divided by 1024 
....................          global_valve_time_to_close_1024th =                                   \ 
....................          ((((uint32_t) global_valve_time_in_motion_1024ths * (uint32_t) global_valve_time_to_close_1024th) \ 
....................          + temp16_frac) >> 10); 
01C1E:  MOVLB  5
01C20:  CLRF   x88
01C22:  CLRF   x87
01C24:  MOVFF  CA,586
01C28:  MOVFF  C9,585
01C2C:  MOVFF  C5,00
01C30:  MOVFF  C6,01
01C34:  CLRF   02
01C36:  CLRF   03
01C38:  MOVFF  03,58C
01C3C:  MOVFF  02,58B
01C40:  MOVFF  C6,58A
01C44:  MOVFF  C5,589
01C48:  MOVFF  588,590
01C4C:  MOVFF  587,58F
01C50:  MOVFF  CA,58E
01C54:  MOVFF  C9,58D
01C58:  MOVFF  03,594
01C5C:  MOVFF  02,593
01C60:  MOVFF  C6,592
01C64:  MOVFF  C5,591
01C68:  MOVLB  0
01C6A:  RCALL  1A12
01C6C:  MOVFF  03,588
01C70:  MOVFF  02,587
01C74:  MOVFF  01,586
01C78:  MOVFF  00,585
01C7C:  MOVLB  5
01C7E:  MOVF   x83,W
01C80:  ADDWF  x85,F
01C82:  MOVF   x84,W
01C84:  ADDWFC x86,F
01C86:  MOVLW  00
01C88:  ADDWFC x87,F
01C8A:  ADDWFC x88,F
01C8C:  RRCF   x88,W
01C8E:  MOVWF  02
01C90:  RRCF   x87,W
01C92:  MOVWF  01
01C94:  RRCF   x86,W
01C96:  MOVWF  00
01C98:  RRCF   02,F
01C9A:  RRCF   01,F
01C9C:  RRCF   00,F
01C9E:  MOVFF  00,C5
01CA2:  MOVLB  0
01CA4:  MOVFF  01,C6
....................          // queue up the next stage of the calibration 
....................          push_time_queue_ISR(global_rtc_time + 3, CALIBRATE_VALVE_6); 
01CA8:  MOVLW  03
01CAA:  ADDWF  x85,W
01CAC:  MOVLB  5
01CAE:  MOVWF  x85
01CB0:  MOVLW  00
01CB2:  MOVLB  0
01CB4:  ADDWFC x86,W
01CB6:  MOVLB  5
01CB8:  MOVWF  x86
01CBA:  MOVLW  00
01CBC:  MOVLB  0
01CBE:  ADDWFC x87,W
01CC0:  MOVLB  5
01CC2:  MOVWF  x87
01CC4:  MOVLW  00
01CC6:  MOVLB  0
01CC8:  ADDWFC x88,W
01CCA:  MOVLB  5
01CCC:  MOVWF  x88
01CCE:  CLRF   19
01CD0:  BTFSC  FF2.7
01CD2:  BSF    19.7
01CD4:  BCF    FF2.7
01CD6:  MOVWF  xBE
01CD8:  MOVFF  587,5BD
01CDC:  MOVFF  586,5BC
01CE0:  MOVFF  585,5BB
01CE4:  MOVLW  36
01CE6:  MOVWF  xBF
01CE8:  MOVLB  0
01CEA:  RCALL  17D8
01CEC:  BTFSC  19.7
01CEE:  BSF    FF2.7
....................       } 
01CF0:  BRA    1EE4
01CF2:  MOVLB  5
....................       // we are doing a valve endstop detect that we have a known calibration for. 
....................       // We want to check the positional error (if we are too far away from the 
....................       // endstop in position when the endstop is detected).  This applies to  
....................       // normal moves as well as re-calibration moves. 
....................       else 
....................       { 
....................          // valve has closed/opened fully in preparation of a recalibration of  
....................          //    valve position.  Trigger a move valve to move to the pending valve 
....................          //    set position and set system status to run 
....................          if (global_system_state == SYSTEM_RECAL_VLV_MOVES) 
01CF4:  MOVF   x05,W
01CF6:  SUBLW  16
01CF8:  BNZ   1D4A
....................          { 
....................             push_time_queue_ISR(global_rtc_time + 3, MOVE_VALVE); 
01CFA:  MOVLW  03
01CFC:  MOVLB  0
01CFE:  ADDWF  x85,W
01D00:  MOVLB  5
01D02:  MOVWF  x85
01D04:  MOVLW  00
01D06:  MOVLB  0
01D08:  ADDWFC x86,W
01D0A:  MOVLB  5
01D0C:  MOVWF  x86
01D0E:  MOVLW  00
01D10:  MOVLB  0
01D12:  ADDWFC x87,W
01D14:  MOVLB  5
01D16:  MOVWF  x87
01D18:  MOVLW  00
01D1A:  MOVLB  0
01D1C:  ADDWFC x88,W
01D1E:  MOVLB  5
01D20:  MOVWF  x88
01D22:  CLRF   19
01D24:  BTFSC  FF2.7
01D26:  BSF    19.7
01D28:  BCF    FF2.7
01D2A:  MOVWF  xBE
01D2C:  MOVFF  587,5BD
01D30:  MOVFF  586,5BC
01D34:  MOVFF  585,5BB
01D38:  MOVLW  40
01D3A:  MOVWF  xBF
01D3C:  MOVLB  0
01D3E:  RCALL  17D8
01D40:  BTFSC  19.7
01D42:  BSF    FF2.7
....................             global_system_state = SYSTEM_RUN; 
01D44:  MOVLW  02
01D46:  MOVLB  5
01D48:  MOVWF  x05
....................          } 
....................          // valve is closing 
....................          if ((IS_VLV_CLOSING) && (global_system_state != SYSTEM_INIT)) 
01D4A:  DECFSZ F8D,W
01D4C:  BRA    1DE8
01D4E:  MOVF   x05,F
01D50:  BZ    1DE8
....................          { 
....................             // error checking if valve movement was longer or shorter than expected 
....................             // We accomplish this by seeing if the valve hit an endstop while it was 
....................             //    outside the VLV_NEAR_CLOSED_RANGE_MAX/VLV_NEAR_OPENED_RANGE_MAX 
....................             if (global_valve_position > VLV_NEAR_CLOSED_RANGE_MAX) 
01D52:  MOVF   x07,W
01D54:  MOVLB  0
01D56:  SUBWF  xC2,W
01D58:  BNC   1DC8
01D5A:  BNZ   1D6C
01D5C:  MOVF   xC1,W
01D5E:  MOVLB  5
01D60:  SUBWF  x06,W
01D62:  BTFSS  FD8.0
01D64:  BRA    1D6A
01D66:  MOVLB  0
01D68:  BRA    1DC8
01D6A:  MOVLB  0
....................             { 
....................                // put system into run mode (in case it's in valve cal routine) 
....................                global_system_state = SYSTEM_RUN; 
01D6C:  MOVLW  02
01D6E:  MOVLB  5
01D70:  MOVWF  x05
....................                // set valve to unknown position (uncalibrated) 
....................                global_valve_position = VLV_POSITION_UNKNOWN; 
01D72:  MOVLB  0
01D74:  SETF   xC2
01D76:  SETF   xC1
....................                // set the error bitfield and send an error 
....................                global_error_message_bitfield |= ERR_MSG_VLV_MOVE_FAIL; 
01D78:  MOVLB  4
01D7A:  BSF    xF9.2
....................                push_time_queue_ISR(global_rtc_time + 1, MSG_MOTE_ERROR_MSG); 
01D7C:  MOVLW  01
01D7E:  MOVLB  0
01D80:  ADDWF  x85,W
01D82:  MOVLB  5
01D84:  MOVWF  x85
01D86:  MOVLW  00
01D88:  MOVLB  0
01D8A:  ADDWFC x86,W
01D8C:  MOVLB  5
01D8E:  MOVWF  x86
01D90:  MOVLW  00
01D92:  MOVLB  0
01D94:  ADDWFC x87,W
01D96:  MOVLB  5
01D98:  MOVWF  x87
01D9A:  MOVLW  00
01D9C:  MOVLB  0
01D9E:  ADDWFC x88,W
01DA0:  MOVLB  5
01DA2:  MOVWF  x88
01DA4:  CLRF   19
01DA6:  BTFSC  FF2.7
01DA8:  BSF    19.7
01DAA:  BCF    FF2.7
01DAC:  MOVWF  xBE
01DAE:  MOVFF  587,5BD
01DB2:  MOVFF  586,5BC
01DB6:  MOVFF  585,5BB
01DBA:  MOVLW  A0
01DBC:  MOVWF  xBF
01DBE:  MOVLB  0
01DC0:  RCALL  17D8
01DC2:  BTFSC  19.7
01DC4:  BSF    FF2.7
....................             } 
01DC6:  BRA    1DE4
....................             // was an expected endstop, proceed as usual 
....................             else 
....................             { 
....................                global_valve_position = VLV_POSITION_CLOSED; 
01DC8:  CLRF   xC2
01DCA:  CLRF   xC1
01DCC:  CLRF   19
01DCE:  BTFSC  FF2.7
01DD0:  BSF    19.7
01DD2:  BCF    FF2.7
....................                PUSH_PRIORITY_QUEUE_ISR_MACRO(SEND_UNSOLICITED_FULL_REPORT);  
01DD4:  MOVLW  A5
01DD6:  MOVLB  5
01DD8:  MOVWF  xB7
01DDA:  MOVLB  0
01DDC:  CALL   082A
01DE0:  BTFSC  19.7
01DE2:  BSF    FF2.7
....................             } 
....................          } 
....................           
....................          // added to accomodate the move valve to set point at boot 
.................... #IFDEF OPEN_VALVE_TO_SETPT_AT_BOOT 
01DE4:  BRA    1EE4
01DE6:  MOVLB  5
....................          else if ((IS_VLV_CLOSING) && (global_system_state == SYSTEM_INIT)) 
01DE8:  DECFSZ F8D,W
01DEA:  BRA    1E46
01DEC:  MOVF   x05,F
01DEE:  BNZ   1E46
....................          { 
....................             global_system_state = SYSTEM_RUN; 
01DF0:  MOVLW  02
01DF2:  MOVWF  x05
....................             global_valve_position = VLV_POSITION_CLOSED; 
01DF4:  MOVLB  0
01DF6:  CLRF   xC2
01DF8:  CLRF   xC1
....................             push_time_queue_ISR(global_rtc_time + 3, MOVE_VALVE_AT_BOOT); 
01DFA:  MOVLW  03
01DFC:  ADDWF  x85,W
01DFE:  MOVLB  5
01E00:  MOVWF  x85
01E02:  MOVLW  00
01E04:  MOVLB  0
01E06:  ADDWFC x86,W
01E08:  MOVLB  5
01E0A:  MOVWF  x86
01E0C:  MOVLW  00
01E0E:  MOVLB  0
01E10:  ADDWFC x87,W
01E12:  MOVLB  5
01E14:  MOVWF  x87
01E16:  MOVLW  00
01E18:  MOVLB  0
01E1A:  ADDWFC x88,W
01E1C:  MOVLB  5
01E1E:  MOVWF  x88
01E20:  CLRF   19
01E22:  BTFSC  FF2.7
01E24:  BSF    19.7
01E26:  BCF    FF2.7
01E28:  MOVWF  xBE
01E2A:  MOVFF  587,5BD
01E2E:  MOVFF  586,5BC
01E32:  MOVFF  585,5BB
01E36:  MOVLW  41
01E38:  MOVWF  xBF
01E3A:  MOVLB  0
01E3C:  RCALL  17D8
01E3E:  BTFSC  19.7
01E40:  BSF    FF2.7
....................          } 
.................... #ENDIF 
01E42:  BRA    1EE4
01E44:  MOVLB  5
....................          // valve is opening 
....................          else if (IS_VLV_OPENING) 
01E46:  MOVF   F8D,W
01E48:  SUBLW  02
01E4A:  BNZ   1EE6
....................          { 
....................             // error checking if valve movement was longer or shorter than expected 
....................             // We accomplish this by seeing if the valve hit an endstop while it was 
....................             //    outside the VLV_NEAR_CLOSED_RANGE_MAX/VLV_NEAR_OPENED_RANGE_MAX 
....................             if (global_valve_position < VLV_NEAR_OPENED_RANGE_MAX) 
01E4C:  MOVLB  0
01E4E:  MOVF   xC2,W
01E50:  MOVLB  5
01E52:  SUBWF  x09,W
01E54:  BNC   1EC4
01E56:  BNZ   1E68
01E58:  MOVF   x08,W
01E5A:  MOVLB  0
01E5C:  SUBWF  xC1,W
01E5E:  BTFSS  FD8.0
01E60:  BRA    1E66
01E62:  MOVLB  5
01E64:  BRA    1EC4
01E66:  MOVLB  5
....................             { 
....................                // put system into run mode (in case it's in valve cal routine) 
....................                global_system_state = SYSTEM_RUN; 
01E68:  MOVLW  02
01E6A:  MOVWF  x05
....................                // set valve to unknown position (uncalibrated) 
....................                global_valve_position = VLV_POSITION_UNKNOWN; 
01E6C:  MOVLB  0
01E6E:  SETF   xC2
01E70:  SETF   xC1
....................                // set the error bitfield and send an error 
....................                global_error_message_bitfield |= ERR_MSG_VLV_MOVE_FAIL; 
01E72:  MOVLB  4
01E74:  BSF    xF9.2
....................                push_time_queue_ISR(global_rtc_time + 1, MSG_MOTE_ERROR_MSG); 
01E76:  MOVLW  01
01E78:  MOVLB  0
01E7A:  ADDWF  x85,W
01E7C:  MOVLB  5
01E7E:  MOVWF  x85
01E80:  MOVLW  00
01E82:  MOVLB  0
01E84:  ADDWFC x86,W
01E86:  MOVLB  5
01E88:  MOVWF  x86
01E8A:  MOVLW  00
01E8C:  MOVLB  0
01E8E:  ADDWFC x87,W
01E90:  MOVLB  5
01E92:  MOVWF  x87
01E94:  MOVLW  00
01E96:  MOVLB  0
01E98:  ADDWFC x88,W
01E9A:  MOVLB  5
01E9C:  MOVWF  x88
01E9E:  CLRF   19
01EA0:  BTFSC  FF2.7
01EA2:  BSF    19.7
01EA4:  BCF    FF2.7
01EA6:  MOVWF  xBE
01EA8:  MOVFF  587,5BD
01EAC:  MOVFF  586,5BC
01EB0:  MOVFF  585,5BB
01EB4:  MOVLW  A0
01EB6:  MOVWF  xBF
01EB8:  MOVLB  0
01EBA:  RCALL  17D8
01EBC:  BTFSC  19.7
01EBE:  BSF    FF2.7
....................             } 
01EC0:  BRA    1EE4
01EC2:  MOVLB  5
....................             // was an expected endstop, proceed as usual 
....................             else 
....................             { 
....................                global_valve_position = VLV_POSITION_OPENED;  
01EC4:  MOVLW  80
01EC6:  MOVLB  0
01EC8:  MOVWF  xC2
01ECA:  CLRF   xC1
01ECC:  CLRF   19
01ECE:  BTFSC  FF2.7
01ED0:  BSF    19.7
01ED2:  BCF    FF2.7
....................                PUSH_PRIORITY_QUEUE_ISR_MACRO(SEND_UNSOLICITED_FULL_REPORT);  
01ED4:  MOVLW  A5
01ED6:  MOVLB  5
01ED8:  MOVWF  xB7
01EDA:  MOVLB  0
01EDC:  CALL   082A
01EE0:  BTFSC  19.7
01EE2:  BSF    FF2.7
01EE4:  MOVLB  5
....................             } 
....................          } 
....................       } 
....................        
....................       // Update fixture setting 
....................  
....................                   
....................       // Turn off comparator and dac 
....................       setup_DAC(DAC_OFF); 
01EE6:  MOVLB  F
01EE8:  CLRF   x41
....................       setup_comparator(NC_NC_NC_NC); 
01EEA:  CLRF   F77
01EEC:  MOVLW  04
01EEE:  MOVWF  F78
01EF0:  MOVWF  F79
....................        
....................       // Turn off CCP3 interrupt      
....................       disable_interrupts(INT_CCP3); 
01EF2:  BCF    F7A.0
....................        
....................       // reset valve movements counter 
....................       global_valve_movements_since_endstop = 0; 
01EF4:  MOVLB  0
01EF6:  CLRF   xCF
....................        
....................       // turn off the motor 
....................       mV_COASTm; 
01EF8:  CLRF   F8D
....................  
....................       // put clock speed down to 250khz again 
....................       //fosc_250k_ISR();    
....................        
....................       // turn off comparator interrupt so it isn't triggered on stop 
....................       clear_interrupt(INT_COMP);      
01EFA:  BCF    FA1.6
....................    } 
.................... } 
....................  
....................  
.................... /* 
.................... #INT_TIMER0 
.................... void tmr0_ISR(void) 
.................... { 
.................... // may not be enabled during normal operation. 
.................... // Need only for IDLING situation (long winters...) wherein every 35minutes 
.................... //  we wake up and check the battery and set a flag if there is a very low 
.................... //  battery, which then tells the idle_sleep routine to go into deep_sleep. 
.................... // this needs work. 
.................... // 
.................... // We can know if we were idling by simply checking the OSCCON for 31250Hz 
.................... //  operation, which occurs ONLY during the long winter.... 
.................... // 
....................    if (cur_state == DEV_IDLE) 
....................    { 
....................    uint8_t  nn; 
....................    // this interrupt occurred during the sleep_idle state 
....................    // check the battery, if it is so low that we need to turn off the radio, 
....................    //  then be sure to set a flag to make that happen... 
....................    // Deep_Sleep may be the result 
....................       output_high(AUX_PWR); 
....................       ADON = TRUE;         // turn on ADC 
....................       delay_cycles(50);    // insurance 
....................       set_adc_channel(V_MEAS_REF);   
....................       VfvrAD = 0;   
....................       for (nn=0; nn<4; nn++) 
....................          VfvrAD += read_adc(); 
....................       ADON = FALSE; 
....................       output_low(AUX_PWR); 
....................       if (VfvrAD > FVR_NODUST) 
....................          fl_batNODUST = TRUE; 
....................    } 
....................    else 
....................    { 
....................    // any other TIMER0 activities we may want 
....................    } 
.................... } 
.................... */ 
....................  
....................                                                           
01EFC:  BCF    FA1.6
01EFE:  GOTO   00A0
.................... #INT_CCP3 HIGH 
.................... void ccp3_ISR(void) 
.................... { 
.................... // For use in timing valve motion 
.................... //    -Updates realtime position of valve 
.................... //    -Keeps track of valve movement time (in 1024th of full scale) 
.................... //    -Turns off valve movement when position is reached 
.................... //    -updates DAC level according to position and direction of movement 
.................... // May be used for other functionality if valve is not moving 
.................... // TMR1 dedicated to CCP3 
....................     
....................    //set_timer1(TIMER1_VLV_MOVE_INIT + get_timer1()); 
....................    //temp16_frac = get_timer1();             
....................           
....................    // If the valve is in motion (not in the braked or coast mode)  
....................    if (IS_VLV_CLOSING || IS_VLV_OPENING) 
*
02046:  DECFSZ F8D,W
02048:  BRA    204C
0204A:  BRA    2054
0204C:  MOVF   F8D,W
0204E:  SUBLW  02
02050:  BTFSS  FD8.2
02052:  BRA    21C6
....................    { 
....................       // add to the time in motion variable 
....................       global_valve_time_in_motion_1024ths++; 
02054:  INCF   xC9,F
02056:  BTFSC  FD8.2
02058:  INCF   xCA,F
....................        
....................       //check for valve movement timeout 
....................       if (global_valve_time_in_motion_1024ths > VALVE_TIMEOUT) 
0205A:  MOVF   xCA,W
0205C:  SUBLW  04
0205E:  BC    20C0
02060:  XORLW  FF
02062:  BNZ   206A
02064:  MOVF   xC9,W
02066:  SUBLW  DC
02068:  BC    20C0
....................       { 
....................          // turn off comparator interrupt so it isn't triggered on stop 
....................          disable_interrupts(INT_COMP); 
0206A:  BCF    FA0.6
....................                 
....................          // turn off valve movement 
....................          mV_COASTm; 
0206C:  CLRF   F8D
....................           
....................          // Error handling for valve motion timeout 
....................          // put system into run mode (in case it's in valve cal routine) 
....................          global_system_state = SYSTEM_RUN; 
0206E:  MOVLW  02
02070:  MOVLB  5
02072:  MOVWF  x05
....................          // set valve to unknown position (uncalibrated) 
....................          global_valve_position = VLV_POSITION_UNKNOWN; 
02074:  MOVLB  0
02076:  SETF   xC2
02078:  SETF   xC1
....................          // set the error bitfield and send an error 
....................          global_error_message_bitfield |= ERR_MSG_VLV_MOVE_FAIL; 
0207A:  MOVLB  4
0207C:  BSF    xF9.2
....................          push_time_queue_ISR(global_rtc_time + 1, MSG_MOTE_ERROR_MSG); 
0207E:  MOVLW  01
02080:  MOVLB  0
02082:  ADDWF  x85,W
02084:  MOVLB  5
02086:  MOVWF  xB7
02088:  MOVLW  00
0208A:  MOVLB  0
0208C:  ADDWFC x86,W
0208E:  MOVLB  5
02090:  MOVWF  xB8
02092:  MOVLW  00
02094:  MOVLB  0
02096:  ADDWFC x87,W
02098:  MOVLB  5
0209A:  MOVWF  xB9
0209C:  MOVLW  00
0209E:  MOVLB  0
020A0:  ADDWFC x88,W
020A2:  MOVLB  5
020A4:  MOVWF  xBA
020A6:  MOVWF  xBE
020A8:  MOVFF  5B9,5BD
020AC:  MOVFF  5B8,5BC
020B0:  MOVFF  5B7,5BB
020B4:  MOVLW  A0
020B6:  MOVWF  xBF
020B8:  MOVLB  0
020BA:  CALL   17D8
....................       } 
020BE:  BRA    21BA
....................        
....................       else if (IS_VLV_CLOSING) 
020C0:  DECFSZ F8D,W
020C2:  BRA    2114
....................       {   
....................          //set_timer1(TIMER1_VLV_MOVE_INIT); 
....................          // 0x20 is equal to one 'millispan' 
....................          if (global_valve_position >= 0x20) 
020C4:  MOVF   xC2,F
020C6:  BNZ   20CE
020C8:  MOVF   xC1,W
020CA:  SUBLW  1F
020CC:  BC    20D8
....................          { 
....................             global_valve_position -= 0x20;     
020CE:  MOVLW  20
020D0:  SUBWF  xC1,F
020D2:  MOVLW  00
020D4:  SUBWFB xC2,F
....................          } 
020D6:  BRA    20DC
....................          // valve is closed, unsigned int thing 
....................          else  
....................          { 
....................             global_valve_position = VLV_POSITION_CLOSED; 
020D8:  CLRF   xC2
020DA:  CLRF   xC1
....................          } 
....................           
....................          // if system is doing a valve recalibration, ignore valve set position 
....................          //    as it is storing the next valve position to move to 
....................          if (global_system_state == SYSTEM_RECAL_VLV_MOVES) 
020DC:  MOVLB  5
020DE:  MOVF   x05,W
020E0:  SUBLW  16
020E2:  BNZ   20E6
....................          { 
....................             break; 
....................          }                        
020E4:  BRA    2110
....................          // we have reached or exceeded the set value/target position and 
....................          //    we aren't trying to reach the endstop 
....................          else if ((global_valve_position <= global_valve_position_set_value)&&\ 
....................          (global_valve_position_set_value != VLV_POSITION_CLOSED)) 
020E6:  MOVLB  0
020E8:  MOVF   xC2,W
020EA:  SUBWF  xC4,W
020EC:  BNC   210E
020EE:  BNZ   20F6
020F0:  MOVF   xC1,W
020F2:  SUBWF  xC3,W
020F4:  BNC   210E
020F6:  MOVF   xC3,F
020F8:  BNZ   20FE
020FA:  MOVF   xC4,F
020FC:  BZ    210E
....................          { 
....................             // turn off comparator interrupt so it isn't triggered on stop 
....................             disable_interrupts(INT_COMP); 
020FE:  BCF    FA0.6
....................              
....................             // turn off valve movement 
....................             mV_COASTm; 
02100:  CLRF   F8D
....................             // update user with message to manager 
....................             PUSH_PRIORITY_QUEUE_ISR_MACRO(SEND_UNSOLICITED_FULL_REPORT);    
02102:  MOVLW  A5
02104:  MOVLB  5
02106:  MOVWF  xB7
02108:  MOVLB  0
0210A:  CALL   082A
0210E:  MOVLB  5
....................          } 
....................       } 
02110:  BRA    21BC
02112:  MOVLB  0
....................       else if (IS_VLV_OPENING) 
02114:  MOVF   F8D,W
02116:  SUBLW  02
02118:  BNZ   21BA
....................       {                   
....................          //0x20 is equal to one 'millispan' 
....................          global_valve_position += 0x20;       
0211A:  MOVLW  20
0211C:  ADDWF  xC1,F
0211E:  MOVLW  00
02120:  ADDWFC xC2,F
....................        
....................          if (global_valve_position > VLV_POSITION_OPENED) 
02122:  MOVF   xC2,W
02124:  SUBLW  7F
02126:  BC    2138
02128:  XORLW  FF
0212A:  BNZ   2132
0212C:  MOVF   xC1,W
0212E:  SUBLW  00
02130:  BC    2138
....................          { 
....................             global_valve_position = VLV_POSITION_OPENED;    
02132:  MOVLW  80
02134:  MOVWF  xC2
02136:  CLRF   xC1
....................          } 
....................           
....................          // if system is doing a valve recalibration, ignore valve set position 
....................          //    as it is storing the next valve position to move to 
....................          if (global_system_state == SYSTEM_RECAL_VLV_MOVES) 
02138:  MOVLB  5
0213A:  MOVF   x05,W
0213C:  SUBLW  16
0213E:  BNZ   2142
....................          { 
....................             break; 
....................          } 
02140:  BRA    21BC
....................          // we have reached or exceeded the set value/target position and 
....................          //    we aren't trying to reach the endstop 
....................          else if ((global_valve_position >= global_valve_position_set_value)&&\ 
....................          (global_valve_position_set_value != VLV_POSITION_OPENED)) 
02142:  MOVLB  0
02144:  MOVF   xC4,W
02146:  SUBWF  xC2,W
02148:  BNC   21BA
0214A:  BNZ   2152
0214C:  MOVF   xC3,W
0214E:  SUBWF  xC1,W
02150:  BNC   21BA
02152:  MOVF   xC3,F
02154:  BNZ   215C
02156:  MOVF   xC4,W
02158:  SUBLW  80
0215A:  BZ    21BA
....................          { 
....................             // turn off comparator interrupt so it isn't triggered on stop 
....................             disable_interrupts(INT_COMP); 
0215C:  BCF    FA0.6
....................              
....................             // turn off valve movement 
....................             mV_COASTm; 
0215E:  CLRF   F8D
....................  
....................             if (global_system_state != SYSTEM_CAL_VLV_1) 
02160:  MOVLB  5
02162:  MOVF   x05,W
02164:  SUBLW  10
02166:  BZ    2174
....................             { 
....................             // update user with message to manager 
....................             PUSH_PRIORITY_QUEUE_ISR_MACRO(SEND_UNSOLICITED_FULL_REPORT);    
02168:  MOVLW  A5
0216A:  MOVWF  xB7
0216C:  MOVLB  0
0216E:  CALL   082A
02172:  MOVLB  5
....................             } 
....................              
....................             // Special case: if we are opening during CALIBRATE_VALVE_1 and 
....................             //    have reached our position, start the next calibration  
....................             //    sequence  
....................             if (global_system_state == SYSTEM_CAL_VLV_1) 
02174:  MOVF   x05,W
02176:  SUBLW  10
02178:  BNZ   21BC
....................             { 
....................                push_time_queue_ISR(global_rtc_time + 3, CALIBRATE_VALVE_2); 
0217A:  MOVLW  03
0217C:  MOVLB  0
0217E:  ADDWF  x85,W
02180:  MOVLB  5
02182:  MOVWF  xB7
02184:  MOVLW  00
02186:  MOVLB  0
02188:  ADDWFC x86,W
0218A:  MOVLB  5
0218C:  MOVWF  xB8
0218E:  MOVLW  00
02190:  MOVLB  0
02192:  ADDWFC x87,W
02194:  MOVLB  5
02196:  MOVWF  xB9
02198:  MOVLW  00
0219A:  MOVLB  0
0219C:  ADDWFC x88,W
0219E:  MOVLB  5
021A0:  MOVWF  xBA
021A2:  MOVWF  xBE
021A4:  MOVFF  5B9,5BD
021A8:  MOVFF  5B8,5BC
021AC:  MOVFF  5B7,5BB
021B0:  MOVLW  32
021B2:  MOVWF  xBF
021B4:  MOVLB  0
021B6:  CALL   17D8
021BA:  MOVLB  5
....................             } 
....................          } 
....................       }    
....................       // update the dac setting 
....................       set_comp_dac_level_isr(); 
021BC:  MOVLB  0
021BE:  BRA    1F0C
....................        
....................       // update the fixture setting 
....................        
....................       // if the valve is not moving anymore 
....................       if (IS_VLV_COASTING) 
021C0:  MOVF   F8D,F
021C2:  BNZ   21C6
....................       { 
....................          // switch back to lower clock, turn off CCP3 interrupt 
....................             //fosc_250k_ISR(); 
....................             //#use delay(clock=250KHZ) 
....................          disable_interrupts(INT_CCP3); 
021C4:  BCF    F7A.0
....................                                                                                                         
....................       } 
....................    } 
.................... } 
....................  
....................  
021C6:  BCF    F7B.0
021C8:  GOTO   015E
.................... #INT_CCP4 
.................... void ccp4_isr(void)                     
.................... { 
....................    // real time clock interrupts      
....................    // TMR3 dedicated to CCP4      
....................                                                                                       
....................    // increment global system uptime 
....................    global_rtc_time++; 
*
02E1E:  MOVLW  01
02E20:  ADDWF  x85,F
02E22:  BTFSC  FD8.0
02E24:  INCF   x86,F
02E26:  BTFSC  FD8.2
02E28:  INCF   x87,F
02E2A:  BTFSC  FD8.2
02E2C:  INCF   x88,F
....................    // increment utc time if mote is connected 
....................    if (global_dust_enabled) global_utc_time++; 
02E2E:  BTFSS  xA7.6
02E30:  BRA    2E42
02E32:  MOVLW  01
02E34:  ADDWF  x89,F
02E36:  BTFSC  FD8.0
02E38:  INCF   x8A,F
02E3A:  BTFSC  FD8.2
02E3C:  INCF   x8B,F
02E3E:  BTFSC  FD8.2
02E40:  INCF   x8C,F
....................  
....................    // check if a time queue item needs to be run 
....................    // make sure it isn't polling an empty queue 
....................    while((global_current_time_queue_location != 255) &&                       \ 
....................    (global_current_priority_queue_location != (MAX_PRIORITY_QUEUE_ITEMS - 1)) \ 
....................    && (global_time_queue[global_current_time_queue_location].time_to_execute  \ 
....................    <= global_rtc_time)) 
02E42:  MOVLB  3
02E44:  INCFSZ x9C,W
02E46:  BRA    2E4A
02E48:  BRA    2EC4
02E4A:  MOVF   x82,W
02E4C:  SUBLW  13
02E4E:  BZ    2EC4
02E50:  MOVF   x9C,W
02E52:  MULLW  05
02E54:  MOVF   FF3,W
02E56:  MOVLB  5
02E58:  CLRF   x84
02E5A:  MOVWF  x83
02E5C:  MOVLW  83
02E5E:  ADDWF  x83,W
02E60:  MOVWF  FE9
02E62:  MOVLW  03
02E64:  ADDWFC x84,W
02E66:  MOVWF  FEA
02E68:  MOVFF  FEF,585
02E6C:  MOVFF  FEC,586
02E70:  MOVFF  FEC,587
02E74:  MOVFF  FEC,588
02E78:  MOVF   x88,W
02E7A:  MOVLB  0
02E7C:  SUBWF  x88,W
02E7E:  BTFSC  FD8.0
02E80:  BRA    2E86
02E82:  MOVLB  3
02E84:  BRA    2EC4
02E86:  BNZ   2EBC
02E88:  MOVLB  5
02E8A:  MOVF   x87,W
02E8C:  MOVLB  0
02E8E:  SUBWF  x87,W
02E90:  BTFSC  FD8.0
02E92:  BRA    2E98
02E94:  MOVLB  3
02E96:  BRA    2EC4
02E98:  BNZ   2EBC
02E9A:  MOVLB  5
02E9C:  MOVF   x86,W
02E9E:  MOVLB  0
02EA0:  SUBWF  x86,W
02EA2:  BTFSC  FD8.0
02EA4:  BRA    2EAA
02EA6:  MOVLB  3
02EA8:  BRA    2EC4
02EAA:  BNZ   2EBC
02EAC:  MOVLB  5
02EAE:  MOVF   x85,W
02EB0:  MOVLB  0
02EB2:  SUBWF  x85,W
02EB4:  BTFSC  FD8.0
02EB6:  BRA    2EBC
02EB8:  MOVLB  3
02EBA:  BRA    2EC4
....................    {                               
....................       // pop an item off the time queue and push it into the priority queue 
....................       pop_time_queue_ISR();                      
02EBC:  GOTO   21CC
02EC0:  BRA    2E42
02EC2:  MOVLB  3
....................    }                         
....................     
....................    // check if a message queue item needs to be run 
....................    // make sure it isn't polling an empty queue 
....................    while((global_current_message_queue_location != 255) &&                      \ 
....................       (global_message_queue[global_current_message_queue_location].time_to_send \ 
....................       <= global_rtc_time))    
02EC4:  MOVLB  4
02EC6:  INCFSZ xF7,W
02EC8:  BRA    2ECC
02ECA:  BRA    2F46
02ECC:  MOVF   xF7,W
02ECE:  MULLW  08
02ED0:  MOVF   FF3,W
02ED2:  MOVLB  5
02ED4:  CLRF   x84
02ED6:  MOVWF  x83
02ED8:  MOVLW  A7
02EDA:  ADDWF  x83,W
02EDC:  MOVWF  FE9
02EDE:  MOVLW  04
02EE0:  ADDWFC x84,W
02EE2:  MOVWF  FEA
02EE4:  MOVFF  FEF,585
02EE8:  MOVFF  FEC,586
02EEC:  MOVFF  FEC,587
02EF0:  MOVFF  FEC,588
02EF4:  MOVF   x88,W
02EF6:  MOVLB  0
02EF8:  SUBWF  x88,W
02EFA:  BTFSC  FD8.0
02EFC:  BRA    2F02
02EFE:  MOVLB  4
02F00:  BRA    2F46
02F02:  BNZ   2F38
02F04:  MOVLB  5
02F06:  MOVF   x87,W
02F08:  MOVLB  0
02F0A:  SUBWF  x87,W
02F0C:  BTFSC  FD8.0
02F0E:  BRA    2F14
02F10:  MOVLB  4
02F12:  BRA    2F46
02F14:  BNZ   2F38
02F16:  MOVLB  5
02F18:  MOVF   x86,W
02F1A:  MOVLB  0
02F1C:  SUBWF  x86,W
02F1E:  BTFSC  FD8.0
02F20:  BRA    2F26
02F22:  MOVLB  4
02F24:  BRA    2F46
02F26:  BNZ   2F38
02F28:  MOVLB  5
02F2A:  MOVF   x85,W
02F2C:  MOVLB  0
02F2E:  SUBWF  x85,W
02F30:  BTFSC  FD8.0
02F32:  BRA    2F38
02F34:  MOVLB  4
02F36:  BRA    2F46
....................    {                     
....................       // disable mote interrupt so payload_buf doesn't get overwritten 
....................       disable_interrupts(INT_EXT2_H2L);   
02F38:  BCF    FF0.4
....................       // send message and requeue it at a later date if not ack'd 
....................       pop_message_queue_and_send_ISR(); 
02F3A:  BRA    2866
....................       // re-enable mote interrupt                     
....................       enable_interrupts(INT_EXT2_H2L);     
02F3C:  BSF    FF0.4
02F3E:  BCF    FF1.4
02F40:  MOVLB  3
02F42:  BRA    2EC4
02F44:  MOVLB  4
....................    }                                   
....................     
....................     
....................    // check if a sprinkler queue item needs to be run and make sure it isn't polling an empty queue        
....................    // Note: The queue contains things that are to be run, not the current item running.             
....................    while((global_current_sprinkler_queue_location != 255) &&                      \ 
....................       (global_sprinkler_queue[global_current_sprinkler_queue_location].start_time \ 
....................       <= global_utc_time)) 
02F46:  INCFSZ x29,W
02F48:  BRA    2F4C
02F4A:  BRA    3026
02F4C:  MOVF   x29,W
02F4E:  MULLW  0E
02F50:  MOVF   FF3,W
02F52:  MOVLB  5
02F54:  CLRF   x84
02F56:  MOVWF  x83
02F58:  MOVLW  9D
02F5A:  ADDWF  x83,W
02F5C:  MOVWF  FE9
02F5E:  MOVLW  03
02F60:  ADDWFC x84,W
02F62:  MOVWF  FEA
02F64:  MOVFF  FEF,585
02F68:  MOVFF  FEC,586
02F6C:  MOVFF  FEC,587
02F70:  MOVFF  FEC,588
02F74:  MOVF   x88,W
02F76:  MOVLB  0
02F78:  SUBWF  x8C,W
02F7A:  BTFSC  FD8.0
02F7C:  BRA    2F82
02F7E:  MOVLB  4
02F80:  BRA    3026
02F82:  BNZ   2FB8
02F84:  MOVLB  5
02F86:  MOVF   x87,W
02F88:  MOVLB  0
02F8A:  SUBWF  x8B,W
02F8C:  BTFSC  FD8.0
02F8E:  BRA    2F94
02F90:  MOVLB  4
02F92:  BRA    3026
02F94:  BNZ   2FB8
02F96:  MOVLB  5
02F98:  MOVF   x86,W
02F9A:  MOVLB  0
02F9C:  SUBWF  x8A,W
02F9E:  BTFSC  FD8.0
02FA0:  BRA    2FA6
02FA2:  MOVLB  4
02FA4:  BRA    3026
02FA6:  BNZ   2FB8
02FA8:  MOVLB  5
02FAA:  MOVF   x85,W
02FAC:  MOVLB  0
02FAE:  SUBWF  x89,W
02FB0:  BTFSC  FD8.0
02FB2:  BRA    2FB8
02FB4:  MOVLB  4
02FB6:  BRA    3026
....................    {   
....................       // if the system is in the SYSTEM_IDLE state, bump it into the SYSTEM_RUN state. 
....................       if (global_system_state == SYSTEM_IDLE) global_system_state = SYSTEM_RUN;       
02FB8:  MOVLB  5
02FBA:  MOVF   x05,W
02FBC:  SUBLW  03
02FBE:  BNZ   2FC4
02FC0:  MOVLW  02
02FC2:  MOVWF  x05
....................                                    
....................       // if system is not in run state, do not stop the item.  Send an error  
....................       //    stating that the stop time is delayed 
....................       if (global_system_state != SYSTEM_RUN)                        
02FC4:  MOVF   x05,W
02FC6:  SUBLW  02
02FC8:  BZ    301E
....................       {                       
....................          global_error_message_bitfield |= ERR_MSG_SPINKLER_CMD_DELAYED_INVALID_STATE; 
02FCA:  MOVLB  4
02FCC:  BSF    xF9.6
....................          push_time_queue_ISR(global_rtc_time + 1, MSG_MOTE_ERROR_MSG); 
02FCE:  MOVLW  01
02FD0:  MOVLB  0
02FD2:  ADDWF  x85,W
02FD4:  MOVLB  5
02FD6:  MOVWF  x83
02FD8:  MOVLW  00
02FDA:  MOVLB  0
02FDC:  ADDWFC x86,W
02FDE:  MOVLB  5
02FE0:  MOVWF  x84
02FE2:  MOVLW  00
02FE4:  MOVLB  0
02FE6:  ADDWFC x87,W
02FE8:  MOVLB  5
02FEA:  MOVWF  x85
02FEC:  MOVLW  00
02FEE:  MOVLB  0
02FF0:  ADDWFC x88,W
02FF2:  MOVLB  5
02FF4:  MOVWF  x86
02FF6:  CLRF   19
02FF8:  BTFSC  FF2.7
02FFA:  BSF    19.7
02FFC:  BCF    FF2.7
02FFE:  MOVWF  xBE
03000:  MOVFF  585,5BD
03004:  MOVFF  584,5BC
03008:  MOVFF  583,5BB
0300C:  MOVLW  A0
0300E:  MOVWF  xBF
03010:  MOVLB  0
03012:  CALL   17D8
03016:  BTFSC  19.7
03018:  BSF    FF2.7
....................       } 
0301A:  BRA    3022
0301C:  MOVLB  5
....................       else 
....................       { 
....................          // pop an item off the time queue and push it into the priority queue 
....................          pop_sprinkler_queue_ISR(); 
0301E:  MOVLB  0
03020:  BRA    2BD8
....................       } 
03022:  MOVLB  4
03024:  BRA    2F46
....................    }            
....................                                                                  
....................    // check if a sprinkler queue item needs to be stopped 
....................    if (global_current_sprinkler_settings_end_time <= global_utc_time) 
03026:  MOVF   x2D,W
03028:  MOVLB  0
0302A:  SUBWF  x8C,W
0302C:  BNC   30BC
0302E:  BNZ   3052
03030:  MOVLB  4
03032:  MOVF   x2C,W
03034:  MOVLB  0
03036:  SUBWF  x8B,W
03038:  BNC   30BC
0303A:  BNZ   3052
0303C:  MOVLB  4
0303E:  MOVF   x2B,W
03040:  MOVLB  0
03042:  SUBWF  x8A,W
03044:  BNC   30BC
03046:  BNZ   3052
03048:  MOVLB  4
0304A:  MOVF   x2A,W
0304C:  MOVLB  0
0304E:  SUBWF  x89,W
03050:  BNC   30BC
....................    {                         
....................       // if the system is in the SYSTEM_IDLE state, bump it into the SYSTEM_RUN state. 
....................       if (global_system_state == SYSTEM_IDLE) global_system_state = SYSTEM_RUN;   
03052:  MOVLB  5
03054:  MOVF   x05,W
03056:  SUBLW  03
03058:  BNZ   305E
0305A:  MOVLW  02
0305C:  MOVWF  x05
....................                                                                                            
....................       // if system is not in run state, do not stop the item.  Send an error 
....................       //    stating that the stop time is delayed 
....................       if (global_system_state != SYSTEM_RUN) 
0305E:  MOVF   x05,W
03060:  SUBLW  02
03062:  BZ    30B8
....................       { 
....................          global_error_message_bitfield |= ERR_MSG_SPINKLER_CMD_DELAYED_INVALID_STATE; 
03064:  MOVLB  4
03066:  BSF    xF9.6
....................          push_time_queue_ISR(global_rtc_time + 1, MSG_MOTE_ERROR_MSG); 
03068:  MOVLW  01
0306A:  MOVLB  0
0306C:  ADDWF  x85,W
0306E:  MOVLB  5
03070:  MOVWF  x83
03072:  MOVLW  00
03074:  MOVLB  0
03076:  ADDWFC x86,W
03078:  MOVLB  5
0307A:  MOVWF  x84
0307C:  MOVLW  00
0307E:  MOVLB  0
03080:  ADDWFC x87,W
03082:  MOVLB  5
03084:  MOVWF  x85
03086:  MOVLW  00
03088:  MOVLB  0
0308A:  ADDWFC x88,W
0308C:  MOVLB  5
0308E:  MOVWF  x86
03090:  CLRF   19
03092:  BTFSC  FF2.7
03094:  BSF    19.7
03096:  BCF    FF2.7
03098:  MOVWF  xBE
0309A:  MOVFF  585,5BD
0309E:  MOVFF  584,5BC
030A2:  MOVFF  583,5BB
030A6:  MOVLW  A0
030A8:  MOVWF  xBF
030AA:  MOVLB  0
030AC:  CALL   17D8
030B0:  BTFSC  19.7
030B2:  BSF    FF2.7
....................       }              
030B4:  BRA    30BC
030B6:  MOVLB  5
....................                                                     
....................       /*  
....................       // if you're stopping the current item and there are no more in the queue, turn off the control 
....................       //    loop.                             
....................       else if (global_current_sprinkler_queue_location == 255) 
....................       {   
....................          global_control_loop_mechanism = NO_SPRINKLER_CONTROL; 
....................       }        
....................       */                                          
....................             
....................       else 
....................       {                   
....................          // stop the current sprinkler setting 
....................          stop_current_spinkler_setting_ISR(); 
030B8:  MOVLB  0
030BA:  BRA    2DE2
....................       }              
....................    } 
....................      
....................      
....................      
....................     
....................    // check to see if system should enter SYSTEM_IDLE (low-power) state 
....................    // 
....................    // First condition for SYSTEM_IDLE: 
....................    //    system already in SYSTEM_RUN    
....................    //    Closed valve (or unknown)        
....................    //    no valve movement 
....................    //    rpm = 0 
....................     
....................    // JACK modified E313 
....................    /* 
....................    if (((global_valve_position == VLV_POSITION_CLOSED) ||                                              \      
....................       (global_valve_position == VLV_POSITION_UNKNOWN)) && (IS_VLV_COASTING) &&                         \ 
....................       ((global_rtc_time - global_last_rpm_value_time) > RPM_TIMEOUT)) 
....................    */ 
....................    if (global_valve_position == VLV_POSITION_CLOSED) 
030BC:  MOVF   xC1,F
030BE:  BNZ   30D2
030C0:  MOVF   xC2,F
030C2:  BNZ   30D2
....................    {                                   
....................       // change processor speed?      
....................       // change state to idle        
....................        if (global_system_state == SYSTEM_RUN)  
030C4:  MOVLB  5
030C6:  MOVF   x05,W
030C8:  SUBLW  02
030CA:  BNZ   30D0
....................        { 
....................          global_system_state = SYSTEM_IDLE; 
030CC:  MOVLW  03
030CE:  MOVWF  x05
....................          //fosc_31250_ISR();  
....................        } 
....................    }  
030D0:  BRA    30DE
....................     
....................    // JG thinks that going into SYSTEM_IDLE should also be triggered when 
....................    // water supply is turned off.  THINK ABOUT THIS... must discuss with BL 
....................     
....................    /* 
....................    // Second condition for SYSTEM_IDLE: 
....................    //    system already in SYSTEM_RUN    
....................    //    global_control_loop_mechanism is in either NO_RPM_CONTROL (test command) or NO_SPRINKLER_CONTROL        
....................    //    no valve movement         
....................    //    brake, charge, and mppc values are at their set points 
....................    else if (((global_control_loop_mechanism == NO_RPM_CONTROL)||                                      \ 
....................       (global_control_loop_mechanism == NO_SPRINKLER_CONTROL)) && (IS_VLV_COASTING) &&                \ 
....................       (global_brake_duty == global_brake_duty_set_value) &&                                           \ 
....................       (global_charge_duty == global_charge_duty_set_value) &&                                         \ 
....................       (global_mppc_value == global_mppc_set_value)) 
....................    {                                               
....................       // change processor speed?  
....................       // change state to idle 
....................       if (global_system_state == SYSTEM_RUN)    
....................       { 
....................          global_system_state = SYSTEM_IDLE; 
....................          //fosc_31250_ISR();  
....................       }                
....................    } 
....................    */ 
....................     
....................    // if above conditions are not met and system is in idle mode, put it into run mode 
....................    else if (global_system_state == SYSTEM_IDLE)          
030D2:  MOVLB  5
030D4:  MOVF   x05,W
030D6:  SUBLW  03
030D8:  BNZ   30DE
....................    {                                  
....................       // change processor speed?    
....................       // change state to run state       
....................        global_system_state = SYSTEM_RUN;  
030DA:  MOVLW  02
030DC:  MOVWF  x05
030DE:  CLRF   19
030E0:  BTFSC  FF2.7
030E2:  BSF    19.7
030E4:  BCF    FF2.7
....................        //fosc_250k_ISR();  
....................    }                            
....................                                                           
....................      
....................    // update lcd every second                                 
....................    PUSH_PRIORITY_QUEUE_ISR_MACRO(LCD_UPDATE);    
030E6:  MOVLW  D4
030E8:  MOVWF  xB7
030EA:  MOVLB  0
030EC:  CALL   082A
030F0:  BTFSC  19.7
030F2:  BSF    FF2.7
....................  
....................    // periodic system checkups (all in one to minimize divides) 
....................    // - mote state (reacts as necessary)    
....................    // - battery state (turns off/on charging, sends warnings, etc.) 
....................    // - mote temp (logs data, sends warnings, etc.) 
....................    // - mote utc time (updates utc time if valid) 
....................    if ((global_rtc_time % PERIODIC_CHECKS_TIME) == 0)      
030F4:  MOVF   x85,W
030F6:  ANDLW  1F
030F8:  MOVLB  5
030FA:  MOVWF  x83
030FC:  CLRF   x84
030FE:  CLRF   x85
03100:  CLRF   x86
03102:  MOVF   x83,F
03104:  BNZ   3172
03106:  MOVF   x84,F
03108:  BNZ   3172
0310A:  MOVF   x85,F
0310C:  BNZ   3172
0310E:  MOVF   x86,F
03110:  BNZ   3172
03112:  CLRF   19
03114:  BTFSC  FF2.7
03116:  BSF    19.7
03118:  BCF    FF2.7
....................    {                                                  
....................       PUSH_PRIORITY_QUEUE_ISR_MACRO(CHECK_MOTE_STATE);  
0311A:  MOVLW  B4
0311C:  MOVWF  xB7
0311E:  MOVLB  0
03120:  CALL   082A
03124:  BTFSC  19.7
03126:  BSF    FF2.7
03128:  CLRF   19
0312A:  BTFSC  FF2.7
0312C:  BSF    19.7
0312E:  BCF    FF2.7
....................       PUSH_PRIORITY_QUEUE_ISR_MACRO(CHECK_BATTERY_STATE);    
03130:  MOVLW  A1
03132:  MOVLB  5
03134:  MOVWF  xB7
03136:  MOVLB  0
03138:  CALL   082A
0313C:  BTFSC  19.7
0313E:  BSF    FF2.7
03140:  CLRF   19
03142:  BTFSC  FF2.7
03144:  BSF    19.7
03146:  BCF    FF2.7
....................       PUSH_PRIORITY_QUEUE_ISR_MACRO(CHECK_MOTE_TEMP); 
03148:  MOVLW  A2
0314A:  MOVLB  5
0314C:  MOVWF  xB7
0314E:  MOVLB  0
03150:  CALL   082A
03154:  BTFSC  19.7
03156:  BSF    FF2.7
03158:  CLRF   19
0315A:  BTFSC  FF2.7
0315C:  BSF    19.7
0315E:  BCF    FF2.7
....................       PUSH_PRIORITY_QUEUE_ISR_MACRO(UPDATE_MOTE_TIME); 
03160:  MOVLW  A3
03162:  MOVLB  5
03164:  MOVWF  xB7
03166:  MOVLB  0
03168:  CALL   082A
0316C:  BTFSC  19.7
0316E:  BSF    FF2.7
03170:  MOVLB  5
....................    }                                                                                                                           
.................... } 
....................  
03172:  BCF    F7B.1
03174:  MOVLB  0
03176:  GOTO   00A0
.................... #INT_CCP5 HIGH 
.................... void CCP5_ISR(void) 
.................... { 
.................... // GEN_RPM event capture for determining speed of rotation 
.................... // We need the CCP5 interrupt routine to be very fast because  
.................... //  the sprinkler can be spinning fast enough to generate 500 pulses per sec! 
.................... // With a 250KHz system clock, 2ms may be trouble with the full normal interrupt 
.................... //  overhead.... 
.................... // TMR5 dedicated to CCP5 
....................     
....................    static uint16_t ccp5_value = 0, ccp5_value_prev = 0; 
....................     
....................    // save previous sample  
....................    ccp5_value_prev = ccp5_value; 
0317A:  MOVFF  545,547
0317E:  MOVFF  544,546
....................     
....................    // get current sample      
....................    ccp5_value = CCP_5;          
03182:  MOVFF  F56,545
03186:  MOVFF  F55,544
....................                                    
....................    // disable INT_CCP4 to ensure safe grabbing of global_rtc_time                        
....................    disable_interrupts(INT_CCP4);              
0318A:  BCF    F7A.1
....................    // check if a current period measurement is even valid 
....................    if ((global_rtc_time - global_last_rpm_value_time) > RPM_TIMEOUT)   
0318C:  MOVF   xAE,W
0318E:  SUBWF  x85,W
03190:  MOVLB  5
03192:  MOVWF  xB7
03194:  MOVLB  0
03196:  MOVF   xAF,W
03198:  SUBWFB x86,W
0319A:  MOVLB  5
0319C:  MOVWF  xB8
0319E:  MOVLB  0
031A0:  MOVF   xB0,W
031A2:  SUBWFB x87,W
031A4:  MOVLB  5
031A6:  MOVWF  xB9
031A8:  MOVLB  0
031AA:  MOVF   xB1,W
031AC:  SUBWFB x88,W
031AE:  MOVLB  5
031B0:  MOVWF  xBA
031B2:  MOVF   xBA,F
031B4:  BNZ   31C8
031B6:  MOVF   xB9,F
031B8:  BNZ   31C8
031BA:  MOVF   x22,W
031BC:  SUBWF  xB8,W
031BE:  BNC   31DA
031C0:  BNZ   31C8
031C2:  MOVF   xB7,W
031C4:  SUBWF  x21,W
031C6:  BC    31DA
....................    { 
....................       // save the last time a measurement was take to figure out if system is spinning outside of this routine.     
....................       global_last_rpm_value_time = global_rtc_time;      
031C8:  MOVFF  88,B1
031CC:  MOVFF  87,B0
031D0:  MOVFF  86,AF
031D4:  MOVFF  85,AE
....................       break;                                          
....................    }                              
031D8:  BRA    31EE
....................    else            
....................    {                                                                
....................       // calc current difference/global period     
....................       global_current_period = ccp5_value - ccp5_value_prev;       
031DA:  MOVF   x46,W
031DC:  SUBWF  x44,W
031DE:  MOVLB  0
031E0:  MOVWF  xA8
031E2:  MOVLB  5
031E4:  MOVF   x47,W
031E6:  SUBWFB x45,W
031E8:  MOVLB  0
031EA:  MOVWF  xA9
031EC:  MOVLB  5
....................    }                                           
....................    // save the last time a measurement was take to figure out if system is spinning outside of this routine.     
....................    global_last_rpm_value_time = global_rtc_time;   
031EE:  MOVFF  88,B1
031F2:  MOVFF  87,B0
031F6:  MOVFF  86,AF
031FA:  MOVFF  85,AE
....................    // re-enable INT_CCP4 after grabbing global rtc time        
....................    enable_interrupts(INT_CCP4);  
031FE:  BSF    F7A.1
03200:  BCF    F7B.2
03202:  MOVLB  0
03204:  GOTO   015E
.................... } 
....................                                     

Configuration Fuses:
   Word  1: 8200   HSH NOPLLEN PRIMARY_SW NOFCMEN IESO
   Word  2: 2218   PUT NOBROWNOUT BORV19 WDT_SW WDT256
   Word  3: A800   CCP2B3 NOPBADEN CCP3E0 HFOFST TIMER3B5 CCP2D2 MCLR
   Word  4: 0081   STVREN NOLVP NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
