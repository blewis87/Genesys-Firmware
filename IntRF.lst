CCS PCH C Compiler, Version 5.068, 34367               14-Feb-17 11:44

               Filename:   C:\_PROJ\Jain Irrigation\2017 reset\Firmware\E313\IntRF.lst

               ROM used:   45526 bytes (69%)
                           Largest free fragment is 20006
               RAM used:   1359 (35%) at main() level
                           1600 (41%) worst case
               Stack used: 10 locations (5 in main + 5 for interrupts)
               Stack size: 31

*
00000:  GOTO   A114
*
00008:  GOTO   00EE
0000C:  NOP   
0000E:  NOP   
00010:  NOP   
00012:  NOP   
00014:  NOP   
00016:  NOP   
00018:  MOVWF  04
0001A:  MOVFF  FD8,05
0001E:  MOVFF  FE0,06
00022:  MOVLB  0
00024:  MOVFF  FE9,0C
00028:  MOVFF  FEA,07
0002C:  MOVFF  FE1,08
00030:  MOVFF  FE2,09
00034:  MOVFF  FD9,0A
00038:  MOVFF  FDA,0B
0003C:  MOVFF  FF3,12
00040:  MOVFF  FF4,13
00044:  MOVFF  FFA,14
00048:  MOVFF  FF5,15
0004C:  MOVFF  FF6,16
00050:  MOVFF  FF7,17
00054:  MOVFF  00,0E
00058:  MOVFF  01,0F
0005C:  MOVFF  02,10
00060:  MOVFF  03,11
00064:  BTFSS  FA0.6
00066:  GOTO   0070
0006A:  BTFSC  FA1.6
0006C:  GOTO   1A96
00070:  BTFSS  FF0.4
00072:  GOTO   007C
00076:  BTFSC  FF0.1
00078:  GOTO   17D2
0007C:  BTFSS  F7A.1
0007E:  GOTO   0088
00082:  BTFSC  F7B.1
00084:  GOTO   2E84
00088:  BTFSS  FA0.3
0008A:  GOTO   0094
0008E:  BTFSC  FA1.3
00090:  GOTO   08DC
00094:  BTFSS  FF2.3
00096:  GOTO   00A0
0009A:  BTFSC  FF2.0
0009C:  GOTO   07EC
000A0:  MOVFF  0E,00
000A4:  MOVFF  0F,01
000A8:  MOVFF  10,02
000AC:  MOVFF  11,03
000B0:  MOVFF  0C,FE9
000B4:  MOVFF  07,FEA
000B8:  BSF    07.7
000BA:  MOVFF  08,FE1
000BE:  MOVFF  09,FE2
000C2:  MOVFF  0A,FD9
000C6:  MOVFF  0B,FDA
000CA:  MOVFF  12,FF3
000CE:  MOVFF  13,FF4
000D2:  MOVFF  14,FFA
000D6:  MOVFF  15,FF5
000DA:  MOVFF  16,FF6
000DE:  MOVFF  17,FF7
000E2:  MOVF   04,W
000E4:  MOVFF  06,FE0
000E8:  MOVFF  05,FD8
000EC:  RETFIE 0
000EE:  MOVWF  1A
000F0:  MOVFF  FD8,1B
000F4:  MOVFF  FE0,1C
000F8:  MOVLB  0
000FA:  MOVFF  FE9,22
000FE:  MOVFF  FEA,1D
00102:  MOVFF  FE1,1E
00106:  MOVFF  FE2,1F
0010A:  MOVFF  FD9,20
0010E:  MOVFF  FDA,21
00112:  MOVFF  FF3,28
00116:  MOVFF  FF4,29
0011A:  MOVFF  FFA,2A
0011E:  MOVFF  FF5,2B
00122:  MOVFF  FF6,2C
00126:  MOVFF  FF7,2D
0012A:  MOVFF  00,24
0012E:  MOVFF  01,25
00132:  MOVFF  02,26
00136:  MOVFF  03,27
0013A:  BTFSS  F7A.2
0013C:  GOTO   0146
00140:  BTFSC  F7B.2
00142:  GOTO   31EC
00146:  BTFSS  F7A.0
00148:  GOTO   0152
0014C:  BTFSC  F7B.0
0014E:  GOTO   208E
00152:  BTFSS  FF2.4
00154:  GOTO   015E
00158:  BTFSC  FF2.1
0015A:  GOTO   0822
0015E:  MOVFF  24,00
00162:  MOVFF  25,01
00166:  MOVFF  26,02
0016A:  MOVFF  27,03
0016E:  MOVFF  22,FE9
00172:  MOVFF  1D,FEA
00176:  BSF    1D.7
00178:  MOVFF  1E,FE1
0017C:  MOVFF  1F,FE2
00180:  MOVFF  20,FD9
00184:  MOVFF  21,FDA
00188:  MOVFF  28,FF3
0018C:  MOVFF  29,FF4
00190:  MOVFF  2A,FFA
00194:  MOVFF  2B,FF5
00198:  MOVFF  2C,FF6
0019C:  MOVFF  2D,FF7
001A0:  MOVF   1A,W
001A2:  MOVFF  1C,FE0
001A6:  MOVFF  1B,FD8
001AA:  RETFIE 0
.................... // required device includes/settings 
.................... #include <18F46K22.h> 
.................... //////////// Standard Header file for the PIC18F46K22 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F46K22 
001AC:  ADDLW  BA
001AE:  MOVWF  FF6
001B0:  MOVLW  01
001B2:  ADDWFC FF7,F
001B4:  TBLRD*+
001B6:  MOVF   FF5,W
001B8:  RETURN 0
001BA:  DATA 00,00
001BC:  DATA 89,11
001BE:  DATA 12,23
001C0:  DATA 9B,32
001C2:  DATA 24,46
001C4:  DATA AD,57
001C6:  DATA 36,65
001C8:  DATA BF,74
001CA:  DATA 48,8C
001CC:  DATA C1,9D
001CE:  DATA 5A,AF
001D0:  DATA D3,BE
001D2:  DATA 6C,CA
001D4:  DATA E5,DB
001D6:  DATA 7E,E9
001D8:  DATA F7,F8
001DA:  DATA 81,10
001DC:  DATA 08,01
001DE:  DATA 93,33
001E0:  DATA 1A,22
001E2:  DATA A5,56
001E4:  DATA 2C,47
001E6:  DATA B7,75
001E8:  DATA 3E,64
001EA:  DATA C9,9C
001EC:  DATA 40,8D
001EE:  DATA DB,BF
001F0:  DATA 52,AE
001F2:  DATA ED,DA
001F4:  DATA 64,CB
001F6:  DATA FF,F9
001F8:  DATA 76,E8
001FA:  DATA 02,21
001FC:  DATA 8B,30
001FE:  DATA 10,02
00200:  DATA 99,13
00202:  DATA 26,67
00204:  DATA AF,76
00206:  DATA 34,44
00208:  DATA BD,55
0020A:  DATA 4A,AD
0020C:  DATA C3,BC
0020E:  DATA 58,8E
00210:  DATA D1,9F
00212:  DATA 6E,EB
00214:  DATA E7,FA
00216:  DATA 7C,C8
00218:  DATA F5,D9
0021A:  DATA 83,31
0021C:  DATA 0A,20
0021E:  DATA 91,12
00220:  DATA 18,03
00222:  DATA A7,77
00224:  DATA 2E,66
00226:  DATA B5,54
00228:  DATA 3C,45
0022A:  DATA CB,BD
0022C:  DATA 42,AC
0022E:  DATA D9,9E
00230:  DATA 50,8F
00232:  DATA EF,FB
00234:  DATA 66,EA
00236:  DATA FD,D8
00238:  DATA 74,C9
0023A:  DATA 04,42
0023C:  DATA 8D,53
0023E:  DATA 16,61
00240:  DATA 9F,70
00242:  DATA 20,04
00244:  DATA A9,15
00246:  DATA 32,27
00248:  DATA BB,36
0024A:  DATA 4C,CE
0024C:  DATA C5,DF
0024E:  DATA 5E,ED
00250:  DATA D7,FC
00252:  DATA 68,88
00254:  DATA E1,99
00256:  DATA 7A,AB
00258:  DATA F3,BA
0025A:  DATA 85,52
0025C:  DATA 0C,43
0025E:  DATA 97,71
00260:  DATA 1E,60
00262:  DATA A1,14
00264:  DATA 28,05
00266:  DATA B3,37
00268:  DATA 3A,26
0026A:  DATA CD,DE
0026C:  DATA 44,CF
0026E:  DATA DF,FD
00270:  DATA 56,EC
00272:  DATA E9,98
00274:  DATA 60,89
00276:  DATA FB,BB
00278:  DATA 72,AA
0027A:  DATA 06,63
0027C:  DATA 8F,72
0027E:  DATA 14,40
00280:  DATA 9D,51
00282:  DATA 22,25
00284:  DATA AB,34
00286:  DATA 30,06
00288:  DATA B9,17
0028A:  DATA 4E,EF
0028C:  DATA C7,FE
0028E:  DATA 5C,CC
00290:  DATA D5,DD
00292:  DATA 6A,A9
00294:  DATA E3,B8
00296:  DATA 78,8A
00298:  DATA F1,9B
0029A:  DATA 87,73
0029C:  DATA 0E,62
0029E:  DATA 95,50
002A0:  DATA 1C,41
002A2:  DATA A3,35
002A4:  DATA 2A,24
002A6:  DATA B1,16
002A8:  DATA 38,07
002AA:  DATA CF,FF
002AC:  DATA 46,EE
002AE:  DATA DD,DC
002B0:  DATA 54,CD
002B2:  DATA EB,B9
002B4:  DATA 62,A8
002B6:  DATA F9,9A
002B8:  DATA 70,8B
002BA:  DATA 08,84
002BC:  DATA 81,95
002BE:  DATA 1A,A7
002C0:  DATA 93,B6
002C2:  DATA 2C,C2
002C4:  DATA A5,D3
002C6:  DATA 3E,E1
002C8:  DATA B7,F0
002CA:  DATA 40,08
002CC:  DATA C9,19
002CE:  DATA 52,2B
002D0:  DATA DB,3A
002D2:  DATA 64,4E
002D4:  DATA ED,5F
002D6:  DATA 76,6D
002D8:  DATA FF,7C
002DA:  DATA 89,94
002DC:  DATA 00,85
002DE:  DATA 9B,B7
002E0:  DATA 12,A6
002E2:  DATA AD,D2
002E4:  DATA 24,C3
002E6:  DATA BF,F1
002E8:  DATA 36,E0
002EA:  DATA C1,18
002EC:  DATA 48,09
002EE:  DATA D3,3B
002F0:  DATA 5A,2A
002F2:  DATA E5,5E
002F4:  DATA 6C,4F
002F6:  DATA F7,7D
002F8:  DATA 7E,6C
002FA:  DATA 0A,A5
002FC:  DATA 83,B4
002FE:  DATA 18,86
00300:  DATA 91,97
00302:  DATA 2E,E3
00304:  DATA A7,F2
00306:  DATA 3C,C0
00308:  DATA B5,D1
0030A:  DATA 42,29
0030C:  DATA CB,38
0030E:  DATA 50,0A
00310:  DATA D9,1B
00312:  DATA 66,6F
00314:  DATA EF,7E
00316:  DATA 74,4C
00318:  DATA FD,5D
0031A:  DATA 8B,B5
0031C:  DATA 02,A4
0031E:  DATA 99,96
00320:  DATA 10,87
00322:  DATA AF,F3
00324:  DATA 26,E2
00326:  DATA BD,D0
00328:  DATA 34,C1
0032A:  DATA C3,39
0032C:  DATA 4A,28
0032E:  DATA D1,1A
00330:  DATA 58,0B
00332:  DATA E7,7F
00334:  DATA 6E,6E
00336:  DATA F5,5C
00338:  DATA 7C,4D
0033A:  DATA 0C,C6
0033C:  DATA 85,D7
0033E:  DATA 1E,E5
00340:  DATA 97,F4
00342:  DATA 28,80
00344:  DATA A1,91
00346:  DATA 3A,A3
00348:  DATA B3,B2
0034A:  DATA 44,4A
0034C:  DATA CD,5B
0034E:  DATA 56,69
00350:  DATA DF,78
00352:  DATA 60,0C
00354:  DATA E9,1D
00356:  DATA 72,2F
00358:  DATA FB,3E
0035A:  DATA 8D,D6
0035C:  DATA 04,C7
0035E:  DATA 9F,F5
00360:  DATA 16,E4
00362:  DATA A9,90
00364:  DATA 20,81
00366:  DATA BB,B3
00368:  DATA 32,A2
0036A:  DATA C5,5A
0036C:  DATA 4C,4B
0036E:  DATA D7,79
00370:  DATA 5E,68
00372:  DATA E1,1C
00374:  DATA 68,0D
00376:  DATA F3,3F
00378:  DATA 7A,2E
0037A:  DATA 0E,E7
0037C:  DATA 87,F6
0037E:  DATA 1C,C4
00380:  DATA 95,D5
00382:  DATA 2A,A1
00384:  DATA A3,B0
00386:  DATA 38,82
00388:  DATA B1,93
0038A:  DATA 46,6B
0038C:  DATA CF,7A
0038E:  DATA 54,48
00390:  DATA DD,59
00392:  DATA 62,2D
00394:  DATA EB,3C
00396:  DATA 70,0E
00398:  DATA F9,1F
0039A:  DATA 8F,F7
0039C:  DATA 06,E6
0039E:  DATA 9D,D4
003A0:  DATA 14,C5
003A2:  DATA AB,B1
003A4:  DATA 22,A0
003A6:  DATA B9,92
003A8:  DATA 30,83
003AA:  DATA C7,7B
003AC:  DATA 4E,6A
003AE:  DATA D5,58
003B0:  DATA 5C,49
003B2:  DATA E3,3D
003B4:  DATA 6A,2C
003B6:  DATA F1,1E
003B8:  DATA 78,0F
003BA:  CLRF   FF7
003BC:  ADDLW  CA
003BE:  MOVWF  FF6
003C0:  MOVLW  03
003C2:  ADDWFC FF7,F
003C4:  TBLRD*+
003C6:  MOVF   FF5,W
003C8:  RETURN 0
003CA:  DATA 45,6E
003CC:  DATA 74,65
003CE:  DATA 72,20
003D0:  DATA 44,65
003D2:  DATA 65,70
003D4:  DATA 20,53
003D6:  DATA 6C,65
003D8:  DATA 65,70
003DA:  DATA 00,00
003DC:  CLRF   FF7
003DE:  ADDLW  EC
003E0:  MOVWF  FF6
003E2:  MOVLW  03
003E4:  ADDWFC FF7,F
003E6:  TBLRD*+
003E8:  MOVF   FF5,W
003EA:  RETURN 0
003EC:  DATA 52,65
003EE:  DATA 61,73
003F0:  DATA 6F,6E
003F2:  DATA 3A,20
003F4:  DATA 20,20
003F6:  DATA 20,20
003F8:  DATA 20,20
003FA:  DATA 20,20
003FC:  DATA 00,00
003FE:  CLRF   FF7
00400:  ADDLW  0E
00402:  MOVWF  FF6
00404:  MOVLW  04
00406:  ADDWFC FF7,F
00408:  TBLRD*+
0040A:  MOVF   FF5,W
0040C:  RETURN 0
0040E:  DATA 20,53
00410:  DATA 65,61
00412:  DATA 72,63
00414:  DATA 68,69
00416:  DATA 6E,67
00418:  DATA 20,3F
0041A:  DATA 3F,3F
0041C:  DATA 3F,20
0041E:  DATA 00,00
00420:  CLRF   FF7
00422:  ADDLW  30
00424:  MOVWF  FF6
00426:  MOVLW  04
00428:  ADDWFC FF7,F
0042A:  TBLRD*+
0042C:  MOVF   FF5,W
0042E:  RETURN 0
00430:  DATA 6E,6E
00432:  DATA 6E,6E
00434:  DATA 20,69
00436:  DATA 69,69
00438:  DATA 20,73
0043A:  DATA 73,73
0043C:  DATA 20,64
0043E:  DATA 64,64
00440:  DATA 00,00
00442:  CLRF   FF7
00444:  ADDLW  52
00446:  MOVWF  FF6
00448:  MOVLW  04
0044A:  ADDWFC FF7,F
0044C:  TBLRD*+
0044E:  MOVF   FF5,W
00450:  RETURN 0
00452:  DATA 53,57
00454:  DATA 31,20
00456:  DATA 74,6F
00458:  DATA 20,4A
0045A:  DATA 6F,69
0045C:  DATA 6E,20
0045E:  DATA 20,20
00460:  DATA 20,20
00462:  DATA 00,00
00464:  CLRF   FF7
00466:  ADDLW  74
00468:  MOVWF  FF6
0046A:  MOVLW  04
0046C:  ADDWFC FF7,F
0046E:  TBLRD*+
00470:  MOVF   FF5,W
00472:  RETURN 0
00474:  DATA 53,74
00476:  DATA 72,6F
00478:  DATA 6E,67
0047A:  DATA 65,73
0047C:  DATA 74,3A
0047E:  DATA 20,20
00480:  DATA 20,20
00482:  DATA 20,20
00484:  DATA 00,00
00486:  CLRF   FF7
00488:  ADDLW  96
0048A:  MOVWF  FF6
0048C:  MOVLW  04
0048E:  ADDWFC FF7,F
00490:  TBLRD*+
00492:  MOVF   FF5,W
00494:  RETURN 0
00496:  DATA 20,53
00498:  DATA 65,61
0049A:  DATA 72,63
0049C:  DATA 68,20
0049E:  DATA 53,75
004A0:  DATA 63,63
004A2:  DATA 65,73
004A4:  DATA 73,20
004A6:  DATA 00,00
004A8:  CLRF   FF7
004AA:  ADDLW  B8
004AC:  MOVWF  FF6
004AE:  MOVLW  04
004B0:  ADDWFC FF7,F
004B2:  TBLRD*+
004B4:  MOVF   FF5,W
004B6:  RETURN 0
004B8:  DATA 4E,65
004BA:  DATA 78,74
004BC:  DATA 20,6A
004BE:  DATA 6F,69
004C0:  DATA 6E,3A
004C2:  DATA 20,20
004C4:  DATA 20,20
004C6:  DATA 20,20
004C8:  DATA 00,00
004CA:  CLRF   FF7
004CC:  ADDLW  DA
004CE:  MOVWF  FF6
004D0:  MOVLW  04
004D2:  ADDWFC FF7,F
004D4:  TBLRD*+
004D6:  MOVF   FF5,W
004D8:  RETURN 0
004DA:  DATA 20,20
004DC:  DATA 20,20
004DE:  DATA 20,20
004E0:  DATA 20,20
004E2:  DATA 20,20
004E4:  DATA 20,20
004E6:  DATA 20,20
004E8:  DATA 20,20
004EA:  DATA 00,00
004EC:  CLRF   FF7
004EE:  ADDLW  FC
004F0:  MOVWF  FF6
004F2:  MOVLW  04
004F4:  ADDWFC FF7,F
004F6:  TBLRD*+
004F8:  MOVF   FF5,W
004FA:  RETURN 0
004FC:  DATA 56,62
004FE:  DATA 61,74
00500:  DATA 74,20
00502:  DATA 3D,20
00504:  DATA 20,20
00506:  DATA 20,20
00508:  DATA 20,56
0050A:  DATA 20,20
0050C:  DATA 00,00
0050E:  CLRF   FF7
00510:  ADDLW  1E
00512:  MOVWF  FF6
00514:  MOVLW  05
00516:  ADDWFC FF7,F
00518:  TBLRD*+
0051A:  MOVF   FF5,W
0051C:  RETURN 0
0051E:  DATA 53,68
00520:  DATA 74,64
00522:  DATA 77,6E
00524:  DATA 20,43
00526:  DATA 61,75
00528:  DATA 73,65
0052A:  DATA 3A,20
0052C:  DATA 20,20
0052E:  DATA 00,00
00530:  CLRF   FF7
00532:  ADDLW  40
00534:  MOVWF  FF6
00536:  MOVLW  05
00538:  ADDWFC FF7,F
0053A:  TBLRD*+
0053C:  MOVF   FF5,W
0053E:  RETURN 0
00540:  DATA 76,20
00542:  DATA 20,20
00544:  DATA 20,20
00546:  DATA 20,72
00548:  DATA 20,20
0054A:  DATA 20,20
0054C:  DATA 74,20
0054E:  DATA 20,20
00550:  DATA 00,00
00552:  CLRF   FF7
00554:  ADDLW  62
00556:  MOVWF  FF6
00558:  MOVLW  05
0055A:  ADDWFC FF7,F
0055C:  TBLRD*+
0055E:  MOVF   FF5,W
00560:  RETURN 0
00562:  DATA 63,20
00564:  DATA 20,20
00566:  DATA 20,20
00568:  DATA 20,71
0056A:  DATA 20,20
0056C:  DATA 20,20
0056E:  DATA 61,20
00570:  DATA 20,20
00572:  DATA 00,00
00574:  CLRF   FF7
00576:  ADDLW  84
00578:  MOVWF  FF6
0057A:  MOVLW  05
0057C:  ADDWFC FF7,F
0057E:  TBLRD*+
00580:  MOVF   FF5,W
00582:  RETURN 0
00584:  DATA 6D,20
00586:  DATA 20,20
00588:  DATA 20,20
0058A:  DATA 20,20
0058C:  DATA 6E,20
0058E:  DATA 20,20
00590:  DATA 20,20
00592:  DATA 2A,20
00594:  DATA 00,00
00596:  CLRF   FF7
00598:  ADDLW  A6
0059A:  MOVWF  FF6
0059C:  MOVLW  05
0059E:  ADDWFC FF7,F
005A0:  TBLRD*+
005A2:  MOVF   FF5,W
005A4:  RETURN 0
005A6:  DATA 70,20
005A8:  DATA 20,20
005AA:  DATA 20,20
005AC:  DATA 20,20
005AE:  DATA 2E,20
005B0:  DATA 20,20
005B2:  DATA 20,20
005B4:  DATA 20,20
005B6:  DATA 00,00
005B8:  CLRF   FF7
005BA:  ADDLW  C8
005BC:  MOVWF  FF6
005BE:  MOVLW  05
005C0:  ADDWFC FF7,F
005C2:  TBLRD*+
005C4:  MOVF   FF5,W
005C6:  RETURN 0
005C8:  DATA 2A,2A
005CA:  DATA 2A,00
005CC:  CLRF   FF7
005CE:  ADDLW  DC
005D0:  MOVWF  FF6
005D2:  MOVLW  05
005D4:  ADDWFC FF7,F
005D6:  TBLRD*+
005D8:  MOVF   FF5,W
005DA:  RETURN 0
005DC:  DATA 62,72
005DE:  DATA 20,20
005E0:  DATA 20,20
005E2:  DATA 63,68
005E4:  DATA 20,20
005E6:  DATA 20,20
005E8:  DATA 6D,70
005EA:  DATA 20,20
005EC:  DATA 00,00
005EE:  CLRF   FF7
005F0:  ADDLW  FE
005F2:  MOVWF  FF6
005F4:  MOVLW  05
005F6:  ADDWFC FF7,F
005F8:  TBLRD*+
005FA:  MOVF   FF5,W
005FC:  RETURN 0
005FE:  DATA 72,20
00600:  DATA 20,20
00602:  DATA 2F,20
00604:  DATA 20,20
00606:  DATA 20,76
00608:  DATA 67,20
0060A:  DATA 20,2E
0060C:  DATA 20,20
0060E:  DATA 00,00
00610:  CLRF   FF7
00612:  ADDLW  20
00614:  MOVWF  FF6
00616:  MOVLW  06
00618:  ADDWFC FF7,F
0061A:  TBLRD*+
0061C:  MOVF   FF5,W
0061E:  RETURN 0
00620:  DATA 73,79
00622:  DATA 73,74
00624:  DATA 65,6D
00626:  DATA 20,73
00628:  DATA 74,61
0062A:  DATA 74,65
0062C:  DATA 20,20
0062E:  DATA 20,20
00630:  DATA 00,00
00632:  CLRF   FF7
00634:  ADDLW  42
00636:  MOVWF  FF6
00638:  MOVLW  06
0063A:  ADDWFC FF7,F
0063C:  TBLRD*+
0063E:  MOVF   FF5,W
00640:  RETURN 0
00642:  DATA 53,65
00644:  DATA 74,75
00646:  DATA 70,20
00648:  DATA 4D,61
0064A:  DATA 6E,61
0064C:  DATA 67,65
0064E:  DATA 72,2E
00650:  DATA 2E,2E
00652:  DATA 00,00
00654:  CLRF   FF7
00656:  ADDLW  64
00658:  MOVWF  FF6
0065A:  MOVLW  06
0065C:  ADDWFC FF7,F
0065E:  TBLRD*+
00660:  MOVF   FF5,W
00662:  RETURN 0
00664:  DATA 20,20
00666:  DATA 52,65
00668:  DATA 6C,65
0066A:  DATA 61,73
0066C:  DATA 65,20
0066E:  DATA 53,57
00670:  DATA 31,20
00672:  DATA 20,20
00674:  DATA 00,00
00676:  CLRF   FF7
00678:  ADDLW  86
0067A:  MOVWF  FF6
0067C:  MOVLW  06
0067E:  ADDWFC FF7,F
00680:  TBLRD*+
00682:  MOVF   FF5,W
00684:  RETURN 0
00686:  DATA 44,65
00688:  DATA 61,6C
0068A:  DATA 20,57
0068C:  DATA 69,74
0068E:  DATA 68,20
00690:  DATA 50,61
00692:  DATA 63,6B
00694:  DATA 65,74
00696:  DATA 00,00
00698:  CLRF   FF7
0069A:  ADDLW  A8
0069C:  MOVWF  FF6
0069E:  MOVLW  06
006A0:  ADDWFC FF7,F
006A2:  TBLRD*+
006A4:  MOVF   FF5,W
006A6:  RETURN 0
006A8:  DATA 56,4C
006AA:  DATA 56,20
006AC:  DATA 49,6E
006AE:  DATA 69,74
006B0:  DATA 20,40
006B2:  DATA 20,73
006B4:  DATA 74,61
006B6:  DATA 72,74
006B8:  DATA 00,00
006BA:  CLRF   FF7
006BC:  ADDLW  CA
006BE:  MOVWF  FF6
006C0:  MOVLW  06
006C2:  ADDWFC FF7,F
006C4:  TBLRD*+
006C6:  MOVF   FF5,W
006C8:  RETURN 0
006CA:  DATA 56,4C
006CC:  DATA 56,20
006CE:  DATA 43,61
006D0:  DATA 6C,69
006D2:  DATA 62,72
006D4:  DATA 61,74
006D6:  DATA 69,6F
006D8:  DATA 6E,20
006DA:  DATA 00,00
006DC:  CLRF   FF7
006DE:  ADDLW  EC
006E0:  MOVWF  FF6
006E2:  MOVLW  06
006E4:  ADDWFC FF7,F
006E6:  TBLRD*+
006E8:  MOVF   FF5,W
006EA:  RETURN 0
006EC:  DATA 42,65
006EE:  DATA 67,69
006F0:  DATA 6E,69
006F2:  DATA 6E,67
006F4:  DATA 2E,2E
006F6:  DATA 2E,2E
006F8:  DATA 2E,2E
006FA:  DATA 2E,2E
006FC:  DATA 00,00
006FE:  CLRF   FF7
00700:  ADDLW  0E
00702:  MOVWF  FF6
00704:  MOVLW  07
00706:  ADDWFC FF7,F
00708:  TBLRD*+
0070A:  MOVF   FF5,W
0070C:  RETURN 0
0070E:  DATA 43,6C
00710:  DATA 6F,73
00712:  DATA 65,20
00714:  DATA 43,43
00716:  DATA 50,3D
00718:  DATA 20,20
0071A:  DATA 20,20
0071C:  DATA 20,20
0071E:  DATA 00,00
00720:  CLRF   FF7
00722:  ADDLW  30
00724:  MOVWF  FF6
00726:  MOVLW  07
00728:  ADDWFC FF7,F
0072A:  TBLRD*+
0072C:  MOVF   FF5,W
0072E:  RETURN 0
00730:  DATA 4F,70
00732:  DATA 65,6E
00734:  DATA 20,43
00736:  DATA 43,50
00738:  DATA 20,3D
0073A:  DATA 20,20
0073C:  DATA 20,20
0073E:  DATA 20,20
00740:  DATA 00,00
00742:  CLRF   FF7
00744:  ADDLW  52
00746:  MOVWF  FF6
00748:  MOVLW  07
0074A:  ADDWFC FF7,F
0074C:  TBLRD*+
0074E:  MOVF   FF5,W
00750:  RETURN 0
00752:  DATA 52,65
00754:  DATA 73,65
00756:  DATA 74,74
00758:  DATA 69,6E
0075A:  DATA 67,20
0075C:  DATA 4D,6F
0075E:  DATA 74,65
00760:  DATA 21,21
00762:  DATA 00,00
00764:  CLRF   FF7
00766:  ADDLW  74
00768:  MOVWF  FF6
0076A:  MOVLW  07
0076C:  ADDWFC FF7,F
0076E:  TBLRD*+
00770:  MOVF   FF5,W
00772:  RETURN 0
00774:  DATA 4D,6F
00776:  DATA 74,65
00778:  DATA 20,69
0077A:  DATA 73,20
0077C:  DATA 44,65
0077E:  DATA 61,64
00780:  DATA 20,20
00782:  DATA 20,20
00784:  DATA 00,00
00786:  CLRF   FF7
00788:  ADDLW  96
0078A:  MOVWF  FF6
0078C:  MOVLW  07
0078E:  ADDWFC FF7,F
00790:  TBLRD*+
00792:  MOVF   FF5,W
00794:  RETURN 0
00796:  DATA 53,65
00798:  DATA 61,72
0079A:  DATA 63,68
0079C:  DATA 20,53
0079E:  DATA 74,72
007A0:  DATA 6F,6E
007A2:  DATA 67,20
007A4:  DATA 31,20
007A6:  DATA 00,00
007A8:  CLRF   FF7
007AA:  ADDLW  B8
007AC:  MOVWF  FF6
007AE:  MOVLW  07
007B0:  ADDWFC FF7,F
007B2:  TBLRD*+
007B4:  MOVF   FF5,W
007B6:  RETURN 0
007B8:  DATA 53,65
007BA:  DATA 61,72
007BC:  DATA 63,68
007BE:  DATA 20,53
007C0:  DATA 74,72
007C2:  DATA 6F,6E
007C4:  DATA 67,20
007C6:  DATA 32,20
007C8:  DATA 00,00
007CA:  CLRF   FF7
007CC:  ADDLW  DA
007CE:  MOVWF  FF6
007D0:  MOVLW  07
007D2:  ADDWFC FF7,F
007D4:  TBLRD*+
007D6:  MOVF   FF5,W
007D8:  RETURN 0
007DA:  DATA 20,20
007DC:  DATA 49,6E
007DE:  DATA 69,74
007E0:  DATA 20,4A
007E2:  DATA 6F,69
007E4:  DATA 6E,20
007E6:  DATA 20,20
007E8:  DATA 20,20
007EA:  DATA 00,00
*
01A3C:  MOVLB  6
01A3E:  CLRF   x0A
01A40:  CLRF   x0B
01A42:  MOVLW  01
01A44:  MOVWF  x0C
01A46:  CLRF   FDA
01A48:  CLRF   FD9
01A4A:  MOVLW  06
01A4C:  MOVWF  x0F
01A4E:  MOVLW  02
01A50:  MOVWF  x0E
01A52:  MOVLW  06
01A54:  MOVWF  FEA
01A56:  MOVWF  FE9
01A58:  MOVFF  60F,FE2
01A5C:  MOVFF  60E,FE1
01A60:  MOVFF  60C,60D
01A64:  BCF    FD8.0
01A66:  MOVF   FE5,W
01A68:  MULWF  FEE
01A6A:  MOVF   FF3,W
01A6C:  ADDWFC x0A,F
01A6E:  MOVF   FF4,W
01A70:  ADDWFC x0B,F
01A72:  DECFSZ x0D,F
01A74:  BRA    1A64
01A76:  MOVFF  60A,FDE
01A7A:  MOVFF  60B,60A
01A7E:  CLRF   x0B
01A80:  BTFSC  FD8.0
01A82:  INCF   x0B,F
01A84:  INCF   x0E,F
01A86:  BTFSC  FD8.2
01A88:  INCF   x0F,F
01A8A:  INCF   x0C,F
01A8C:  MOVF   x0C,W
01A8E:  SUBLW  05
01A90:  BNZ   1A52
01A92:  MOVLB  0
01A94:  RETURN 0
*
022BE:  TSTFSZ 01
022C0:  BRA    22C8
022C2:  TSTFSZ 02
022C4:  BRA    22CA
022C6:  BRA    22D6
022C8:  INCF   02,F
022CA:  MOVFF  00,FEE
022CE:  DECFSZ 01,F
022D0:  BRA    22CA
022D2:  DECFSZ 02,F
022D4:  BRA    22CA
022D6:  RETURN 0
*
02570:  BTFSC  FD8.1
02572:  BRA    257C
02574:  MOVLW  06
02576:  MOVWF  FEA
02578:  MOVLW  1E
0257A:  MOVWF  FE9
0257C:  CLRF   00
0257E:  CLRF   01
02580:  CLRF   02
02582:  CLRF   03
02584:  MOVLB  6
02586:  CLRF   x1E
02588:  CLRF   x1F
0258A:  CLRF   x20
0258C:  CLRF   x21
0258E:  MOVF   x1D,W
02590:  IORWF  x1C,W
02592:  IORWF  x1B,W
02594:  IORWF  x1A,W
02596:  BZ    25F0
02598:  MOVLW  20
0259A:  MOVWF  x22
0259C:  BCF    FD8.0
0259E:  RLCF   x16,F
025A0:  RLCF   x17,F
025A2:  RLCF   x18,F
025A4:  RLCF   x19,F
025A6:  RLCF   x1E,F
025A8:  RLCF   x1F,F
025AA:  RLCF   x20,F
025AC:  RLCF   x21,F
025AE:  MOVF   x1D,W
025B0:  SUBWF  x21,W
025B2:  BNZ   25C4
025B4:  MOVF   x1C,W
025B6:  SUBWF  x20,W
025B8:  BNZ   25C4
025BA:  MOVF   x1B,W
025BC:  SUBWF  x1F,W
025BE:  BNZ   25C4
025C0:  MOVF   x1A,W
025C2:  SUBWF  x1E,W
025C4:  BNC   25E4
025C6:  MOVF   x1A,W
025C8:  SUBWF  x1E,F
025CA:  MOVF   x1B,W
025CC:  BTFSS  FD8.0
025CE:  INCFSZ x1B,W
025D0:  SUBWF  x1F,F
025D2:  MOVF   x1C,W
025D4:  BTFSS  FD8.0
025D6:  INCFSZ x1C,W
025D8:  SUBWF  x20,F
025DA:  MOVF   x1D,W
025DC:  BTFSS  FD8.0
025DE:  INCFSZ x1D,W
025E0:  SUBWF  x21,F
025E2:  BSF    FD8.0
025E4:  RLCF   00,F
025E6:  RLCF   01,F
025E8:  RLCF   02,F
025EA:  RLCF   03,F
025EC:  DECFSZ x22,F
025EE:  BRA    259C
025F0:  MOVFF  61E,FEF
025F4:  MOVFF  61F,FEC
025F8:  MOVFF  620,FEC
025FC:  MOVFF  621,FEC
02600:  MOVLB  0
02602:  RETURN 0
*
04384:  CLRF   01
04386:  CLRF   02
04388:  CLRF   00
0438A:  CLRF   03
0438C:  MOVLB  5
0438E:  MOVF   x78,W
04390:  BNZ   4396
04392:  MOVF   x77,W
04394:  BZ    43C6
04396:  MOVLW  10
04398:  MOVWF  x79
0439A:  BCF    FD8.0
0439C:  RLCF   x75,F
0439E:  RLCF   x76,F
043A0:  RLCF   00,F
043A2:  RLCF   03,F
043A4:  MOVF   x78,W
043A6:  SUBWF  03,W
043A8:  BNZ   43AE
043AA:  MOVF   x77,W
043AC:  SUBWF  00,W
043AE:  BNC   43BE
043B0:  MOVF   x77,W
043B2:  SUBWF  00,F
043B4:  BTFSS  FD8.0
043B6:  DECF   03,F
043B8:  MOVF   x78,W
043BA:  SUBWF  03,F
043BC:  BSF    FD8.0
043BE:  RLCF   01,F
043C0:  RLCF   02,F
043C2:  DECFSZ x79,F
043C4:  BRA    439A
043C6:  MOVLB  0
043C8:  RETURN 0
*
04818:  MOVLW  8E
0481A:  MOVWF  00
0481C:  MOVFF  56E,01
04820:  MOVFF  56D,02
04824:  CLRF   03
04826:  MOVF   01,F
04828:  BNZ   483C
0482A:  MOVFF  02,01
0482E:  CLRF   02
04830:  MOVLW  08
04832:  SUBWF  00,F
04834:  MOVF   01,F
04836:  BNZ   483C
04838:  CLRF   00
0483A:  BRA    484C
0483C:  BCF    FD8.0
0483E:  BTFSC  01.7
04840:  BRA    484A
04842:  RLCF   02,F
04844:  RLCF   01,F
04846:  DECF   00,F
04848:  BRA    483C
0484A:  BCF    01.7
0484C:  RETURN 0
0484E:  MOVLB  5
04850:  MOVF   x6D,W
04852:  BTFSC  FD8.2
04854:  BRA    49A0
04856:  MOVWF  x79
04858:  MOVF   x71,W
0485A:  BTFSC  FD8.2
0485C:  BRA    49A0
0485E:  SUBWF  x79,F
04860:  BNC   486C
04862:  MOVLW  7F
04864:  ADDWF  x79,F
04866:  BTFSC  FD8.0
04868:  BRA    49A0
0486A:  BRA    4878
0486C:  MOVLW  81
0486E:  SUBWF  x79,F
04870:  BTFSS  FD8.0
04872:  BRA    49A0
04874:  BTFSC  FD8.2
04876:  BRA    49A0
04878:  MOVFF  579,00
0487C:  CLRF   01
0487E:  CLRF   02
04880:  CLRF   03
04882:  CLRF   x78
04884:  MOVFF  56E,577
04888:  BSF    x77.7
0488A:  MOVFF  56F,576
0488E:  MOVFF  570,575
04892:  MOVLW  19
04894:  MOVWF  x79
04896:  MOVF   x74,W
04898:  SUBWF  x75,F
0489A:  BC    48B6
0489C:  MOVLW  01
0489E:  SUBWF  x76,F
048A0:  BC    48B6
048A2:  SUBWF  x77,F
048A4:  BC    48B6
048A6:  SUBWF  x78,F
048A8:  BC    48B6
048AA:  INCF   x78,F
048AC:  INCF   x77,F
048AE:  INCF   x76,F
048B0:  MOVF   x74,W
048B2:  ADDWF  x75,F
048B4:  BRA    4906
048B6:  MOVF   x73,W
048B8:  SUBWF  x76,F
048BA:  BC    48E0
048BC:  MOVLW  01
048BE:  SUBWF  x77,F
048C0:  BC    48E0
048C2:  SUBWF  x78,F
048C4:  BC    48E0
048C6:  INCF   x78,F
048C8:  INCF   x77,F
048CA:  MOVF   x73,W
048CC:  ADDWF  x76,F
048CE:  MOVF   x74,W
048D0:  ADDWF  x75,F
048D2:  BNC   4906
048D4:  INCF   x76,F
048D6:  BNZ   4906
048D8:  INCF   x77,F
048DA:  BNZ   4906
048DC:  INCF   x78,F
048DE:  BRA    4906
048E0:  MOVF   x72,W
048E2:  IORLW  80
048E4:  SUBWF  x77,F
048E6:  BC    4904
048E8:  MOVLW  01
048EA:  SUBWF  x78,F
048EC:  BC    4904
048EE:  INCF   x78,F
048F0:  MOVF   x72,W
048F2:  IORLW  80
048F4:  ADDWF  x77,F
048F6:  MOVF   x73,W
048F8:  ADDWF  x76,F
048FA:  BNC   48CE
048FC:  INCF   x77,F
048FE:  BNZ   48CE
04900:  INCF   x78,F
04902:  BRA    48CE
04904:  BSF    03.0
04906:  DECFSZ x79,F
04908:  BRA    490C
0490A:  BRA    4922
0490C:  BCF    FD8.0
0490E:  RLCF   x75,F
04910:  RLCF   x76,F
04912:  RLCF   x77,F
04914:  RLCF   x78,F
04916:  BCF    FD8.0
04918:  RLCF   03,F
0491A:  RLCF   02,F
0491C:  RLCF   01,F
0491E:  RLCF   x7A,F
04920:  BRA    4896
04922:  BTFSS  x7A.0
04924:  BRA    4932
04926:  BCF    FD8.0
04928:  RRCF   01,F
0492A:  RRCF   02,F
0492C:  RRCF   03,F
0492E:  RRCF   x7A,F
04930:  BRA    4936
04932:  DECF   00,F
04934:  BZ    49A0
04936:  BTFSC  x7A.7
04938:  BRA    4976
0493A:  BCF    FD8.0
0493C:  RLCF   x75,F
0493E:  RLCF   x76,F
04940:  RLCF   x77,F
04942:  RLCF   x78,F
04944:  MOVF   x74,W
04946:  SUBWF  x75,F
04948:  BC    4958
0494A:  MOVLW  01
0494C:  SUBWF  x76,F
0494E:  BC    4958
04950:  SUBWF  x77,F
04952:  BC    4958
04954:  SUBWF  x78,F
04956:  BNC   498C
04958:  MOVF   x73,W
0495A:  SUBWF  x76,F
0495C:  BC    4968
0495E:  MOVLW  01
04960:  SUBWF  x77,F
04962:  BC    4968
04964:  SUBWF  x78,F
04966:  BNC   498C
04968:  MOVF   x72,W
0496A:  IORLW  80
0496C:  SUBWF  x77,F
0496E:  BC    4976
04970:  MOVLW  01
04972:  SUBWF  x78,F
04974:  BNC   498C
04976:  INCF   03,F
04978:  BNZ   498C
0497A:  INCF   02,F
0497C:  BNZ   498C
0497E:  INCF   01,F
04980:  BNZ   498C
04982:  INCF   00,F
04984:  BZ    49A0
04986:  RRCF   01,F
04988:  RRCF   02,F
0498A:  RRCF   03,F
0498C:  MOVFF  56E,579
04990:  MOVF   x72,W
04992:  XORWF  x79,F
04994:  BTFSS  x79.7
04996:  BRA    499C
04998:  BSF    01.7
0499A:  BRA    49A8
0499C:  BCF    01.7
0499E:  BRA    49A8
049A0:  CLRF   00
049A2:  CLRF   01
049A4:  CLRF   02
049A6:  CLRF   03
049A8:  MOVLB  0
049AA:  RETURN 0
049AC:  MOVLB  5
049AE:  MOVF   x6D,W
049B0:  SUBLW  B6
049B2:  MOVWF  x6D
049B4:  CLRF   03
049B6:  MOVFF  56E,571
049BA:  BSF    x6E.7
049BC:  BCF    FD8.0
049BE:  RRCF   x6E,F
049C0:  RRCF   x6F,F
049C2:  RRCF   x70,F
049C4:  RRCF   03,F
049C6:  RRCF   02,F
049C8:  RRCF   01,F
049CA:  RRCF   00,F
049CC:  DECFSZ x6D,F
049CE:  BRA    49BC
049D0:  BTFSS  x71.7
049D2:  BRA    49EA
049D4:  COMF   00,F
049D6:  COMF   01,F
049D8:  COMF   02,F
049DA:  COMF   03,F
049DC:  INCF   00,F
049DE:  BTFSC  FD8.2
049E0:  INCF   01,F
049E2:  BTFSC  FD8.2
049E4:  INCF   02,F
049E6:  BTFSC  FD8.2
049E8:  INCF   03,F
049EA:  MOVLB  0
049EC:  RETURN 0
*
04B3E:  MOVLB  5
04B40:  MOVF   x6F,W
04B42:  MULWF  x71
04B44:  MOVFF  FF3,01
04B48:  MOVFF  FF4,00
04B4C:  MULWF  x72
04B4E:  MOVF   FF3,W
04B50:  ADDWF  00,F
04B52:  MOVF   x70,W
04B54:  MULWF  x71
04B56:  MOVF   FF3,W
04B58:  ADDWFC 00,W
04B5A:  MOVWF  02
04B5C:  MOVLB  0
04B5E:  RETURN 0
*
05DAE:  ADDWF  FE8,W
05DB0:  CLRF   FF7
05DB2:  RLCF   FF7,F
05DB4:  ADDLW  C9
05DB6:  MOVWF  FF6
05DB8:  MOVLW  5D
05DBA:  ADDWFC FF7,F
05DBC:  TBLRD*-
05DBE:  MOVF   FF5,W
05DC0:  MOVWF  FFA
05DC2:  TBLRD*
05DC4:  MOVF   FF5,W
05DC6:  MOVWF  FF9
05DC8:  DATA 8A,58
05DCA:  DATA 1A,56
05DCC:  DATA 8A,58
05DCE:  DATA A6,5D
05DD0:  DATA A6,5D
05DD2:  DATA CA,5A
05DD4:  DATA CA,5A
05DD6:  DATA A6,5D
05DD8:  DATA 6C,5C
05DDA:  DATA 08,5D
*
06AEA:  MOVLB  5
06AEC:  MOVF   x6C,W
06AEE:  CLRF   01
06AF0:  SUBWF  x6B,W
06AF2:  BC    6AFA
06AF4:  MOVFF  56B,00
06AF8:  BRA    6B12
06AFA:  CLRF   00
06AFC:  MOVLW  08
06AFE:  MOVWF  x6D
06B00:  RLCF   x6B,F
06B02:  RLCF   00,F
06B04:  MOVF   x6C,W
06B06:  SUBWF  00,W
06B08:  BTFSC  FD8.0
06B0A:  MOVWF  00
06B0C:  RLCF   01,F
06B0E:  DECFSZ x6D,F
06B10:  BRA    6B00
06B12:  MOVLB  0
06B14:  RETURN 0
*
081F8:  ADDWF  FE8,W
081FA:  CLRF   FF7
081FC:  RLCF   FF7,F
081FE:  ADDLW  13
08200:  MOVWF  FF6
08202:  MOVLW  82
08204:  ADDWFC FF7,F
08206:  TBLRD*-
08208:  MOVF   FF5,W
0820A:  MOVWF  FFA
0820C:  TBLRD*
0820E:  MOVF   FF5,W
08210:  MOVWF  FF9
08212:  DATA 86,73
08214:  DATA 9C,73
08216:  DATA EE,81
08218:  DATA EE,81
0821A:  DATA EE,81
0821C:  DATA EE,81
0821E:  DATA EE,81
08220:  DATA EE,81
08222:  DATA EE,81
08224:  DATA EE,81
08226:  DATA EE,81
08228:  DATA EE,81
0822A:  DATA EE,81
0822C:  DATA EE,81
0822E:  DATA EE,81
08230:  DATA A2,73
08232:  DATA B8,73
08234:  DATA CE,73
08236:  DATA EE,81
08238:  DATA EE,81
0823A:  DATA EE,81
0823C:  DATA EE,81
0823E:  DATA EE,81
08240:  DATA EE,81
08242:  DATA EE,81
08244:  DATA EE,81
08246:  DATA EE,81
08248:  DATA EE,81
0824A:  DATA EE,81
0824C:  DATA EE,81
0824E:  DATA EE,81
08250:  DATA E4,73
08252:  DATA 52,74
08254:  DATA C0,74
08256:  DATA 18,75
08258:  DATA EE,81
0825A:  DATA EE,81
0825C:  DATA EE,81
0825E:  DATA EE,81
08260:  DATA EE,81
08262:  DATA EE,81
08264:  DATA EE,81
08266:  DATA EE,81
08268:  DATA EE,81
0826A:  DATA EE,81
0826C:  DATA EE,81
0826E:  DATA EE,81
08270:  DATA 08,76
08272:  DATA 3A,76
08274:  DATA 60,76
08276:  DATA FC,76
08278:  DATA 22,77
0827A:  DATA 94,78
0827C:  DATA AC,79
0827E:  DATA EE,81
08280:  DATA EE,81
08282:  DATA EE,81
08284:  DATA EE,81
08286:  DATA EE,81
08288:  DATA EE,81
0828A:  DATA EE,81
0828C:  DATA EE,81
0828E:  DATA EE,81
08290:  DATA FE,79
08292:  DATA 0E,7B
08294:  DATA 38,7B
08296:  DATA 4A,7D
08298:  DATA 1E,7F
0829A:  DATA 26,81
0829C:  DATA 3E,81
....................  
.................... #list 
....................  
.................... #device adc=10  
.................... #device high_ints=TRUE 
....................                   
.................... // standard libraries 
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #include <stdint.h>          
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... ////                           stdint.h                                //// 
.................... ////                                                                   //// 
.................... //// Standard integer definitions.                                     //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDINT 
....................  
.................... #define _STDINT 
....................  
.................... //////////// exact width 
....................  
.................... typedef signed int8 int8_t; 
.................... typedef unsigned int8 uint8_t; 
.................... typedef signed int16 int16_t; 
.................... typedef unsigned int16 uint16_t; 
.................... typedef signed int32 int32_t; 
.................... typedef unsigned int32 uint32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int24_t; 
.................... //typedef unsigned int24 uint24_t; 
.................... typedef signed int64 int64_t; 
.................... typedef unsigned int64 uint64_t; 
.................... #endif 
....................  
.................... #define INT8_MAX  (127) 
.................... #define INT8_MIN  (-128) 
.................... #define UINT8_MAX (255) 
....................  
.................... #define INT16_MAX  (32767) 
.................... #define INT16_MIN  (-32768) 
.................... #define UINT16_MAX (65535) 
....................  
.................... #define INT32_MAX  (2147483647) 
.................... #define INT32_MIN  (-2147483648) 
.................... #define UINT32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT24_MAX  (8388607) 
.................... //#define INT24_MIN  (-8388608) 
.................... //#define UINT24_MAX (16777215) 
....................  
.................... #define INT64_MAX  (9223372036854775807) 
.................... #define INT64_MIN  (-9223372036854775808) 
.................... #define UINT64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// minimum width 
....................  
.................... typedef signed int8 int_least8_t; 
.................... typedef unsigned int8 uint_least8_t; 
.................... typedef signed int16 int_least16_t; 
.................... typedef unsigned int16 uint_least16_t; 
.................... typedef signed int32 int_least32_t; 
.................... typedef unsigned int32 uint_least32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int_least24_t; 
.................... //typedef unsigned int24 uint_least24_t; 
.................... typedef signed int64 int_least64_t; 
.................... typedef unsigned int64 uint_least64_t; 
.................... #endif 
....................  
.................... #define INT_LEAST8_MAX  (127) 
.................... #define INT_LEAST8_MIN  (-128) 
.................... #define UINT_LEAST8_MAX (255) 
....................  
.................... #define INT_LEAST16_MAX  (32767) 
.................... #define INT_LEAST16_MIN  (-32768) 
.................... #define UINT_LEAST16_MAX (65535) 
....................  
.................... #define INT_LEAST32_MAX  (2147483647) 
.................... #define INT_LEAST32_MIN  (-2147483648) 
.................... #define UINT_LEAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_LEAST24_MAX  (8388607) 
.................... //#define INT_LEAST24_MIN  (-8388608) 
.................... //#define UINT_LEAST24_MAX (16777215) 
....................  
.................... #define INT_LEAST64_MAX  (9223372036854775807) 
.................... #define INT_LEAST64_MIN  (-9223372036854775808) 
.................... #define UINT_LEAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// fastest width 
....................  
.................... #if defined(__PCD__) 
.................... typedef signed int16 int_fast8_t; 
.................... typedef unsigned int16 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (32767) 
.................... #define INT_FAST8_MIN  (-32768) 
.................... #define UINT_FAST8_MAX (65535) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... //typedef signed int24 int_fast24_t; 
.................... //typedef unsigned int24 uint_fast24_t; 
.................... typedef signed int64 int_fast64_t; 
.................... typedef unsigned int64 uint_fast64_t; 
.................... #else 
.................... typedef signed int8 int_fast8_t; 
.................... typedef unsigned int8 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (127) 
.................... #define INT_FAST8_MIN  (-128) 
.................... #define UINT_FAST8_MAX (255) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... #endif 
....................  
.................... typedef signed int32 int_fast32_t; 
.................... typedef unsigned int32 uint_fast32_t; 
....................  
.................... #define INT_FAST16_MAX  (32767) 
.................... #define INT_FAST16_MIN  (-32768) 
.................... #define UINT_FAST16_MAX (65535) 
....................  
.................... #define INT_FAST32_MAX  (2147483647) 
.................... #define INT_FAST32_MIN  (-2147483648) 
.................... #define UINT_FAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_FAST24_MAX  (8388607) 
.................... //#define INT_FAST24_MIN  (-8388608) 
.................... //#define UINT_FAST24_MAX (16777215) 
....................  
.................... #define INT_FAST64_MAX  (9223372036854775807) 
.................... #define INT_FAST64_MIN  (-9223372036854775808) 
.................... #define UINT_FAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... //////////// big enough to hold pointers (OPTIONAL) 
....................  
.................... #if defined(__PCD__) 
....................    typedef unsigned int32 uintptr_t; 
....................    typedef signed int32 intptr_t; 
.................... #else 
....................    typedef unsigned int16 uintptr_t; 
....................    typedef signed int16 intptr_t; 
.................... #endif 
....................  
.................... /// TODO: 
.................... /// INTPTRN_MIN INTPTRN_MAX UINTPTRN_MAX 
....................  
....................  
.................... /////////// greatest width (OPTIONAL) 
....................  
.................... /// TODO 
....................  
.................... /// intmax_t uintmax_t 
....................  
.................... /// INTMAXN_MIN INTMAXN_MAX UINTMAXN_MAX 
....................  
.................... /// INTMAX_C(value) UINTMAX_C(value) 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char **endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char **endptr); 
.................... float64 strtod(char *s,char **endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, (char*)0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char **endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char **endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char **endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... size_t mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
*
043CA:  CLRF   19
043CC:  BTFSC  FF2.7
043CE:  BSF    19.7
043D0:  BCF    FF2.7
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
043D2:  MOVFF  34,605
043D6:  MOVFF  33,604
043DA:  MOVFF  32,603
043DE:  MOVFF  31,602
043E2:  MOVLW  41
043E4:  MOVLB  6
043E6:  MOVWF  x09
043E8:  MOVLW  C6
043EA:  MOVWF  x08
043EC:  MOVLW  4E
043EE:  MOVWF  x07
043F0:  MOVLW  6D
043F2:  MOVWF  x06
043F4:  MOVLB  0
043F6:  CALL   1A3C
043FA:  BTFSC  19.7
043FC:  BSF    FF2.7
043FE:  MOVLW  39
04400:  MOVLB  5
04402:  ADDWF  00,W
04404:  MOVWF  31
04406:  MOVLW  30
04408:  ADDWFC 01,W
0440A:  MOVWF  32
0440C:  MOVLW  00
0440E:  ADDWFC 02,W
04410:  MOVWF  33
04412:  MOVLW  00
04414:  ADDWFC 03,W
04416:  MOVWF  34
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
04418:  MOVFF  33,00
0441C:  MOVFF  34,01
04420:  CLRF   02
04422:  CLRF   03
04424:  MOVFF  34,54D
04428:  MOVFF  33,54C
0442C:  MOVFF  34,576
04430:  MOVFF  33,575
04434:  MOVLW  7F
04436:  MOVWF  x78
04438:  SETF   x77
0443A:  MOVLB  0
0443C:  RCALL  4384
0443E:  MOVFF  00,01
04442:  MOVFF  03,02
04446:  GOTO   4488 (RETURN)
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
*
04370:  MOVFF  54F,34
04374:  MOVFF  54E,33
04378:  MOVFF  54D,32
0437C:  MOVFF  54C,31
04380:  GOTO   4486 (RETURN)
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdlibm.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... /*********************************************************************/ 
.................... #ifndef _STDLIBM 
.................... #define _STDLIBM 
....................  
.................... /* Memory Management Functions*/ 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... typedef struct nodet { 
....................    unsigned int8 size; 
....................    unsigned int8 next; }node_t; 
.................... #elif defined(__PCM__) 
.................... typedef struct nodet { 
....................    unsigned int8 size; 
....................    unsigned int16 next; }node_t; 
.................... #elif defined(__PCH__) 
.................... typedef struct nodet { 
....................    unsigned int16 size; 
....................    unsigned int16 next; }node_t; 
.................... #elif defined(__PCD__) 
.................... typedef struct nodet { 
....................    unsigned int16 size; 
....................    unsigned int16 next; }node_t; 
.................... #endif 
....................  
.................... #if !defined(STDLIBM_MANUAL_DYNAMIC_MEMORY) 
....................    #USE DYNAMIC_MEMORY 
.................... #endif 
....................  
.................... #ifndef debug_stdlibm 
....................    #define debug_stdlibm(s) 
.................... #else 
....................    #define __DO_DEBUG_STDLIBM 
....................     
....................    char g_DebugStdlibmStr[50]; 
....................     
....................    #if defined(__PCD__) 
....................       #if (defined(__PIC24E__)||defined(__dsPIC33E__)) 
....................          #define INVALID_MEMORY_LOCATION(x) ((x >= (getenv("RAM")+0x800)) || bit_test(x, 0)) 
....................       #else 
....................          #define INVALID_MEMORY_LOCATION(x) ((x >= (getenv("RAM")+0x1000)) || bit_test(x, 0)) 
....................       #endif 
....................    #else 
....................       #define INVALID_MEMORY_LOCATION(x) (x >= getenv("RAM")) 
....................    #endif 
.................... #endif 
....................  
.................... #if defined(STDLIBM_TRACK_WORST_CASE) 
....................    static size_t _g_StdlibmCurrentBytesUsed = 0; 
....................    static size_t _g_StdlibmWorstCaseBytesUsed = 0; 
....................     
....................    #define _STDLIBM_TRACK_WORST_INC(_x) \ 
....................    do {  \ 
....................       _g_StdlibmCurrentBytesUsed += _x;   \ 
....................       if (_g_StdlibmCurrentBytesUsed > _g_StdlibmWorstCaseBytesUsed) \ 
....................          _g_StdlibmWorstCaseBytesUsed = _g_StdlibmCurrentBytesUsed;  \ 
....................    } while(0) 
....................     
....................    #define _STDLIBM_TRACK_WORST_DEC(_x) _g_StdlibmCurrentBytesUsed-=_x 
.................... #else 
....................    #define _STDLIBM_TRACK_WORST_INC(_x) 
....................    #define _STDLIBM_TRACK_WORST_DEC(_x) 
.................... #endif 
....................  
.................... #include <memmgmt.c> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #if defined(__PCH__) 
....................  #define _MEMMGMT_CSIZE 32768 
....................  #define _MEMMGMT_POS 15 
.................... #elif defined(__PCD__) 
....................    #define _MEMMGMT_CSIZE 32768 
....................    #define _MEMMGMT_POS 15 
.................... #else 
....................    #define _MEMMGMT_CSIZE 127 
....................    #define _MEMMGMT_POS 7 
.................... #endif 
....................  
.................... node_t * create_node(unsigned int16 size, node_t *ptr) // create node at given location 
.................... { 
....................    node_t *result; 
....................    result =ptr; 
....................    result->size=size; 
....................    result->next = NULL; 
....................    return result; 
.................... } 
.................... void update_node(node_t *node, unsigned int16 size) // update the size of given node 
.................... { 
....................    node->size=size; 
.................... } 
....................  
.................... /* Insert node immediately after place */ //old,new 
.................... void insert_node_after(node_t *place, node_t *node)// place the node after another given node 
.................... { 
....................     if (place->next==NULL) 
....................        node->next= NULL; 
....................     else 
....................        node->next=place->next; 
....................     place->next=node; 
.................... } 
....................  
.................... ///////////////////////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... void remove_node(node_t *node) {// remove the given node from the memlist 
....................    node_t *ptr; 
....................    for(ptr=__DYNAMIC_HEAD;ptr->next!=node;ptr=ptr->next); 
....................    ptr->next=node->next; 
....................    node=NULL; 
.................... } 
....................  
.................... ///////////////////////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... #if defined(__DO_DEBUG_STDLIBM) 
.................... void print_list() { // print the current memlist 
....................     node_t *node; 
....................     debug_stdlibm("\r\nThe list is \n\r"); 
....................     for(node = __DYNAMIC_HEAD; node != NULL; node = node->next) 
....................     { 
....................         sprintf(g_DebugStdlibmStr, "H:0x%lx S:0x%lx N:0x%lx\n\r", node, node->size, node->next); 
....................         debug_stdlibm(g_DebugStdlibmStr); 
....................         if (INVALID_MEMORY_LOCATION(node->next)) 
....................         { 
....................            debug_stdlibm("Breaking because of invalid next node\r\n"); 
....................            break; 
....................         }    
....................     } 
....................     sprintf(g_DebugStdlibmStr, "size of node_t %u\r\n",sizeof(node_t)); 
....................     debug_stdlibm(g_DebugStdlibmStr); 
.................... } 
.................... #endif 
....................  
....................  
....................  
....................  
.................... void traverse() 
.................... { 
....................    node_t *node,*temp; 
....................    unsigned int16 nsize,nextsize; 
....................    node=__DYNAMIC_HEAD; 
....................    while(node!=NULL) 
....................    { 
....................      #if defined(__DO_DEBUG_STDLIBM) 
....................       if (INVALID_MEMORY_LOCATION(node)) 
....................       { 
....................          sprintf(g_DebugStdlibmStr, "traverse() invalid node (0x%LX)\r\n", node); 
....................          debug_stdlibm(g_DebugStdlibmStr); 
....................          break; 
....................       }    
....................      #endif 
....................      if(!bit_test(node->size,_MEMMGMT_POS))// node free 
....................       { 
....................          nsize=node->size; 
....................          temp=(unsigned int16)node->next; 
....................         #if defined(__DO_DEBUG_STDLIBM) 
....................          if (INVALID_MEMORY_LOCATION(temp)) 
....................          { 
....................             sprintf(g_DebugStdlibmStr, "traverse() invalid temp (0x%LX)\r\n", node); 
....................             debug_stdlibm(g_DebugStdlibmStr); 
....................             break; 
....................          } 
....................         #endif 
....................          if(!bit_test(temp->size,_MEMMGMT_POS)&& (temp==((unsigned int16)node+nsize+sizeof(node_t))))//next node free and consecutive, so combine 
....................          { 
....................             nextsize=temp->size; 
....................             nsize+=nextsize+sizeof(node_t); 
....................             remove_node(temp); 
....................             update_node(node,nsize); 
....................          } 
....................          else 
....................          node=node->next; 
....................       } 
....................       else 
....................       node=node->next; 
....................    } 
.................... } 
....................  
.................... char *malloc(size_t size) 
.................... { 
....................    node_t *node,*new; 
....................    unsigned int16 nsize; 
....................    #if defined(__PCD__) 
....................    if (size % 2) 
....................       size++; 
....................    #endif 
....................    node=__DYNAMIC_HEAD; 
....................     
....................   #if defined(__DO_DEBUG_STDLIBM) 
....................    sprintf(g_DebugStdlibmStr, "malloc() size=%lu ", size); 
....................    debug_stdlibm(g_DebugStdlibmStr); 
....................   #endif 
....................          
....................    while(node!=NULL) // chk until end of memlist 
....................    { 
....................      #if defined(__DO_DEBUG_STDLIBM) 
....................       if (INVALID_MEMORY_LOCATION(node)) 
....................       { 
....................          sprintf(g_DebugStdlibmStr, " invalid node (0x%LX)\r\n", node); 
....................          debug_stdlibm(g_DebugStdlibmStr); 
....................          print_list(); 
....................          return(0); 
....................       } 
....................      #endif 
....................       if(!bit_test(node->size,_MEMMGMT_POS) && node->size >=size) // node is free and > = req size 
....................       { 
....................          nsize=node->size;    //nsize = size of the node that "node" being pointed at 
....................          if(nsize>size +sizeof(node_t)) //node > req size, so split and add new node to memlist 
....................          { 
....................             new=create_node(nsize-size-sizeof(node_t),(unsigned int16)node+sizeof(node_t)+size); 
....................             insert_node_after(node,new); 
....................             update_node(node,size+_MEMMGMT_CSIZE); 
....................          } 
....................          else//not enough space for new node so use original size 
....................          update_node(node,nsize+_MEMMGMT_CSIZE); 
....................          //end if 
....................          break; 
....................       }//end if 
....................       node=node->next; 
....................    }//end while 
....................    if(node==NULL)// reached end without finding an appropriate node 
....................    { 
....................       debug_stdlibm("Not enough memory for mallocation\r\n"); 
....................       return NULL; 
....................    } 
....................    else 
....................    { 
....................      #if defined(__DO_DEBUG_STDLIBM) 
....................       sprintf(g_DebugStdlibmStr, "%LX\r\n", (char *)node+sizeof(node_t)); 
....................       debug_stdlibm(g_DebugStdlibmStr); 
....................      #endif 
....................       _STDLIBM_TRACK_WORST_INC(size); 
....................       return (char *)node+sizeof(node_t); // return pounsigned int8er to allocated space 
....................    } 
.................... } 
....................  
.................... char *calloc(size_t nmemb,size_t size) 
.................... { 
....................    node_t *node,*new; 
....................    unsigned int16 nsize,resize; 
....................    node=__DYNAMIC_HEAD; 
....................    resize=nmemb*size; 
....................    #if defined(__PCD__) 
....................    if(resize%2) 
....................       resize++; 
....................    #endif 
....................    while(node!=NULL) // chk until end of memlist 
....................    { 
....................      #if defined(__DO_DEBUG_STDLIBM) 
....................       if (INVALID_MEMORY_LOCATION(node)) 
....................       { 
....................          sprintf(g_DebugStdlibmStr, "malloc() invalid node (0x%LX)\r\n", node); 
....................          debug_stdlibm(g_DebugStdlibmStr); 
....................          print_list(); 
....................          return(0); 
....................       } 
....................      #endif 
....................       if(!bit_test(node->size,_MEMMGMT_POS) && node->size >=resize)// node is free and > = req size 
....................       { 
....................          nsize=node->size; 
....................          if(nsize>resize+sizeof(node_t))//node > req size, so split and add new node to memlist 
....................          { 
....................             new=create_node(nsize-resize-sizeof(node_t),(unsigned int16)node+sizeof(node_t)+resize); 
....................             insert_node_after(node,new); 
....................             update_node(node,resize+_MEMMGMT_CSIZE); 
....................          } 
....................          else//not enough space for new node so use original size 
....................          update_node(node,nsize+_MEMMGMT_CSIZE); 
....................          //end if 
....................          break; 
....................       }//end if 
....................       node=node->next; 
....................    }//end while 
....................    if(node==NULL)// reached end without finding an appropriate node 
....................    { 
....................       debug_stdlibm("Not enough memory for callocation\r\n"); 
....................       return NULL; 
....................    } 
....................    else 
....................    { 
....................       memset((unsigned int16)node+sizeof(node_t),0,resize);// initialize to 0 
....................       _STDLIBM_TRACK_WORST_INC(resize); 
....................       return (char *)(unsigned int16)node+sizeof(node_t);// return pounsigned int8er to allocated space 
....................    } 
.................... } 
.................... void free( void * ptr) 
.................... { 
....................    node_t *node; 
....................    unsigned int16 nsize; 
....................  
....................   #if defined(__DO_DEBUG_STDLIBM) 
....................    sprintf(g_DebugStdlibmStr, "free() 0x%LX\r\n", ptr); 
....................    debug_stdlibm(g_DebugStdlibmStr); 
....................   #endif 
....................  
....................    if(ptr==NULL) // not a valid pounsigned int8er 
....................       return; 
....................    else 
....................    { 
....................       node=ptr-sizeof(node_t); 
....................       if(bit_test(node->size,_MEMMGMT_POS))// node occupied 
....................       { 
....................          nsize=node->size-_MEMMGMT_CSIZE; 
....................          update_node(node,nsize); 
....................          ptr=NULL; 
....................          _STDLIBM_TRACK_WORST_DEC(nsize); 
....................       } 
....................       else // wrong input, return 
....................       { 
....................          ptr=NULL; 
....................          return; 
....................       } 
....................    } 
....................    traverse(); 
.................... } 
....................  
.................... char *realloc(void *ptr,size_t size) 
.................... { 
....................    node_t *node,*new,*temp; 
....................    unsigned int16 nsize,nextsize; 
....................    char *newptr; 
....................    #if defined(__PCD__) 
....................    if(size %2) 
....................       size++; 
....................    #endif 
....................    if(ptr==NULL)// null pounsigned int8er, so malloc the req memory 
....................       return(malloc(size)); 
....................    else if(size==0) 
....................    { 
....................       free(ptr); 
....................       return(NULL); 
....................    } 
....................    else 
....................    { 
....................       node=ptr-sizeof(node_t); 
....................       if(bit_test(node->size,_MEMMGMT_POS))// chk if valid pounsigned int8er 
....................       { 
....................          nsize=node->size-_MEMMGMT_CSIZE; 
....................          temp=(unsigned int16)node->next; 
....................          if(nsize>size)// block > req size 
....................          { 
....................         
....................                if(!bit_test(temp->size,_MEMMGMT_POS) && (temp==((unsigned int16)node+nsize+sizeof(node_t))))// next block free and consecutive 
....................                { 
....................                   update_node(node,size+_MEMMGMT_CSIZE); // update block 
....................                   nextsize=temp->size; 
....................                   remove_node(temp); 
....................                   new=create_node(nextsize+(nsize-size),(unsigned int16)node+size+sizeof(node_t)); 
....................                   insert_node_after(node,new); 
....................                   _STDLIBM_TRACK_WORST_DEC(nsize); 
....................                   _STDLIBM_TRACK_WORST_INC(size); 
....................                } 
....................                else if (nsize>size +sizeof(node_t))//node > req size, so split and add new node to memlist 
....................                { 
....................                   update_node(node,size+_MEMMGMT_CSIZE); // update block 
....................                   new=create_node(nsize-size-sizeof(node_t),(unsigned int16)node+sizeof(node_t)+size); 
....................                   insert_node_after(node,new); 
....................                   _STDLIBM_TRACK_WORST_DEC(nsize); 
....................                   _STDLIBM_TRACK_WORST_INC(size); 
....................                } 
....................                else//not enough space for new node so use original size 
....................                update_node(node,nsize+_MEMMGMT_CSIZE); // update block 
....................  
....................          } 
....................          else // block < req size 
....................          { 
....................             if(!bit_test(temp->size,_MEMMGMT_POS) && (temp==((unsigned int16)node+nsize+sizeof(node_t))))// next block free and consecutive 
....................             { 
....................                nextsize=temp->size; 
....................                if(nextsize>=size-nsize) // next block >=difference 
....................                { 
....................                   if(nextsize>size-nsize+sizeof(node_t))//next node > req size, so split and add new node to memlist 
....................                   { 
....................                       update_node(node,size+_MEMMGMT_CSIZE);// update block 
....................                       remove_node(temp); 
....................                       new=create_node(nextsize-(size-nsize),(unsigned int16)node+size+sizeof(node_t)); 
....................                       insert_node_after(node,new); 
....................                      _STDLIBM_TRACK_WORST_DEC(nsize); 
....................                      _STDLIBM_TRACK_WORST_INC(size); 
....................                   } 
....................                   else//not enough space for new node in next node, so use original size 
....................                   { 
....................                       update_node(node,nsize+nextsize+_MEMMGMT_CSIZE);// update block 
....................                       remove_node(temp); 
....................                   } 
....................                } 
....................                else  //next block free but too small for new size 
....................                { 
....................                   newptr = malloc(size);  //use malloc to find new block 
....................                   if(newptr == NULL) 
....................                      return(NULL);        //return NULL if malloc was unable to find new block 
....................                     
....................                   memcpy(newptr, ptr, nsize);   //copy original data to new block 
....................                   free(ptr);                    //free original block 
....................                   return(newptr);               //return new pointer 
....................                } 
....................             } 
....................             else  //next block not free 
....................             { 
....................                newptr = malloc(size);  //use malloc to find new block 
....................                if(newptr == NULL)       
....................                   return(NULL);        //return NULL if malloc was unable to find new block 
....................                 
....................                memcpy(newptr, ptr, nsize);   //copy original data to new block 
....................                free(ptr);                    //free original block 
....................                return(newptr);               //return new pointer 
....................             } 
....................          } 
....................          return (char *)node+sizeof(node_t); // return pounsigned int8er to the reallocated block 
....................       } 
....................       else // not allocated use malloc 
....................       { 
....................          return(malloc(size)); 
....................       } 
....................    } 
....................  } 
....................   
.................... typedef struct 
.................... { 
....................    size_t bytesUsed; 
....................    size_t largestUsedSeg; 
....................    int segmentsUsed; 
....................    size_t bytesFree; 
....................    size_t largestFreeSeg; 
....................    int segmentsFree; 
....................   #if defined(STDLIBM_TRACK_WORST_CASE) 
....................    size_t worstCaseBytesUsed; 
....................   #endif 
.................... } heap_status_t; 
....................  
.................... void GetHeapStatus(heap_status_t *pHeapStatus) 
.................... { 
....................    heap_status_t status; 
....................    node_t *node; 
....................    unsigned int16 nsize; 
....................     
....................    node=__DYNAMIC_HEAD; 
....................     
....................    memset(&status, 0, sizeof(status)); 
....................  
....................    while(node!=NULL) 
....................    { 
....................       nsize = node->size; 
....................       node = node->next; 
....................        
....................       if(!bit_test(nsize, _MEMMGMT_POS)) // node free 
....................       { 
....................          status.bytesFree += nsize; 
....................           
....................          status.segmentsFree++; 
....................           
....................          if (nsize > status.largestFreeSeg) 
....................          { 
....................             status.largestFreeSeg = nsize; 
....................          } 
....................       } 
....................       else 
....................       { 
....................          bit_clear(nsize, _MEMMGMT_POS); 
....................           
....................          status.bytesUsed += nsize; 
....................           
....................          status.segmentsUsed++; 
....................           
....................          if (nsize > status.largestUsedSeg) 
....................          { 
....................             status.largestUsedSeg = nsize; 
....................          } 
....................       } 
....................    } 
....................  
....................   #if defined(STDLIBM_TRACK_WORST_CASE) 
....................    status.worstCaseBytesUsed = _g_StdlibmWorstCaseBytesUsed; 
....................   #endif 
....................  
....................    memcpy(pHeapStatus, &status, sizeof(heap_status_t)); 
.................... } 
.................... #ENDIF 
....................  
....................  
.................... // configuration files   
.................... #include "pic_config.h" 
.................... //IF NO primary oscillator is used, no need for FCMEN or PRIMARY_SW 
.................... // or IESO; also for debug purposes place INTRC at IO pin RA6 
.................... // THINK ABOUT PUT config setting! and transitions out of sleep that require 
.................... // accurate timing for UART 
....................  
.................... /////////////////////Fuses Start/////////////////////////////////////////////// 
.................... #FUSES CCP2B3 //CCP2 input/output multiplexed with RB3 
.................... #FUSES CCP2D2 //CCP2 input/output multiplexed with RD2 
.................... #FUSES CCP3E0 //CCP3 input/output multiplexed with RE0 
.................... #FUSES HFOFST //High Frequency INTRC starts clocking CPU immediately  
.................... #FUSES HSH //High speed Osc, high power 16MHz-25MHz 
.................... #FUSES IESO //Internal External Switch Over mode enabled  
.................... #FUSES MCLR //Master Clear pin enabled  
.................... #FUSES NOBROWNOUT //No brownout reset  
.................... #FUSES NOCPB //No Boot Block code protection  
.................... #FUSES NOCPD //No EE protection  
.................... #FUSES NODEBUG //No Debug mode for ICD 
.................... #FUSES NOEBTR //Memory not protected from table reads  
.................... #FUSES NOEBTRB //Boot block not protected from table reads  
.................... #FUSES NOFCMEN //Fail-safe clock monitor disabled  
.................... #FUSES NOLVP //No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O  
.................... #FUSES NOPBADEN //PORTB pins are configured as digital I/O on RESET 
.................... #FUSES NOPLLEN //4X HW PLL disabled, 4X PLL enabled in software   
.................... #FUSES NOPROTECT //Code not protected from reading  
.................... #FUSES NOWRT //Program memory not write protected  
.................... #FUSES NOWRTB //Boot block not write protected  
.................... #FUSES NOWRTC //configuration not registers write protected  
.................... #FUSES NOWRTD //Data EEPROM not write protected  
.................... #FUSES NOXINST //Extended set extension and Indexed Addressing mode disabled (Legacy mode)  
.................... #FUSES PRIMARY_SW //Primary clock can be disabled in software  
.................... #FUSES PUT //Power Up Timer 
.................... #FUSES STVREN //Stack full/underflow will cause reset 
.................... #FUSES TIMER3B5 //Timer3 Clock In is on pin B5  
.................... #FUSES WDT32768 //Watch Dog Timer uses 1:32768 Postscale  
.................... #FUSES WDT_SW //No Watch Dog Timer, enabled in Software  
.................... //#FUSES WDT //Watch Dog Timer enabled.  
.................... /////////////////////Fuses End///////////////////////////////////////////////// 
....................                                            
.................... /////////////////////Serial and I2C Timing Setup Start///////////////////////// 
.................... #use delay(clock=3,686,400)  
.................... #use RS232 (uart1, baud=115200)        
.................... #use delay(clock=250KHZ) 
.................... // setup i2c for use on 250khz main clock 
.................... #use i2c(master, I2C1, NOINIT, FORCE_HW, SLOW) 
.................... #use  fast_io(all) 
.................... /////////////////////Serial and I2C Timing Setup End/////////////////////////// 
....................  
.................... /////////////////////Special Function Registers Start////////////////////////// 
....................  
.................... #byte    WREG     =  0x0FE8 
.................... #byte    STATUS   =  0x0FD8 
.................... #BIT     CARRY       =  STATUS.0 
....................  
.................... #byte    STKPTR   =  0x0FFC 
.................... #BIT     STKUNF      = STKPTR.6 
.................... #BIT     STKFUL      = STKPTR.7 
....................  
.................... #byte    RCON     =  0x0FD0 
.................... #BIT     IPEN        = RCON.7 
....................  
.................... #byte    INTCON   =  0x0FF2 
.................... #BIT     RBIF        = INTCON.0 
.................... #BIT     INT0IF      = INTCON.1 
.................... #BIT     TMR0IF      = INTCON.2                                                                                                           
.................... #BIT     RBIE        = INTCON.3 
.................... #BIT     INT0IE      = INTCON.4 
.................... #BIT     TMR0IE      = INTCON.5                                                                                                    
.................... #byte    INTCON2  =  0x0FF1 
.................... #BIT     RBPU        = INTCON2.7   
.................... // RBPU lo to allow individual PORTB pullups 
.................... #byte    INTCON3  =  0x0FF0   
.................... #BIT     INT1IF      =  INTCON3.0 
.................... #BIT     INT2IF      =  INTCON3.1 
....................  
.................... #byte    T0CON    =  0x0FD5 
.................... #BIT     TMR0ON      = T0CON.7 
....................  
.................... #byte    OSCCON   =  0x0FD3 
.................... #BIT     SCS0        = OSCCON.0 
.................... #BIT     SCS1        = OSCCON.1 
.................... #BIT     HFIOFS      = OSCCON.2 
.................... #BIT     OSTS        = OSCCON.3 
.................... #BIT     IDLEN       = OSCCON.7 
.................... #byte    OSCCON2  =  0x0FD2 
.................... #BIT     LFIOFS      = OSCCON2.0 
.................... #BIT     MFIOFS      = OSCCON2.1 
.................... #BIT     PRISD       = OSCCON2.2 
.................... #BIT     SOSCGO      = OSCCON2.3 
.................... #BIT     MFIOSEL     = OSCCON2.4 
.................... #BIT     SOSCRUN     = OSCCON2.6 
.................... #BIT     PLLRDY      = OSCCON2.7 
.................... #byte    OSCTUNE  =  0x0F9B 
.................... #BIT     PLLEN       = OSCTUNE.6 
.................... #BIT     INTSRC      = OSCTUNE.7 
....................  
.................... // Timer registers 
.................... #byte    TMR1H    =  0x0FCF 
.................... #byte    TMR1L    =  0x0FCE 
.................... #byte    T1CON    =  0x0FCD 
.................... #BIT     TMR1ON      = T1CON.0 
.................... #byte    T1GCON   =  0x0FCC 
.................... #BIT     T1GGO       = T1GCON.3 
....................  
.................... #byte    T2CON    =  0x0FBA 
.................... #BIT     TMR2ON      = T2CON.2 
.................... #BIT     T2CKPS0     = T2CON.0 
.................... #BIT     T2CKPS1     = T2CON.1 
.................... #byte    PR2      =  0x0FBB 
....................  
.................... #byte    TMR3H    =  0x0FB3 
.................... #byte    TMR3L    =  0x0FB2 
.................... #byte    T3CON    =  0x0FB1 
.................... #BIT     TMR3ON      =  T3CON.0 
.................... #byte    T3GCON   =  0x0FB4 
.................... #BIT     T3GGO       = T3GCON.3 
....................  
.................... #byte    T4CON    =  0x0F51 
.................... #BIT     TMR4ON      = T4CON.2 
.................... #byte    PR4      =  0x0F52 
....................  
....................  
.................... #byte    TMR5H    =  0x0F50 
.................... #byte    TMR5L    =  0x0F4F      
.................... #byte    T5CON    =  0x0F4E 
.................... #BIT     TMR5ON      = T5CON.0 
.................... #byte    T5GCON   =  0x0F4D 
.................... #BIT     T5GGO       = T5GCON.3 
....................  
.................... #byte    T6CON    =  0x0F4A 
.................... #BIT     TMR6ON      = T6CON.2 
.................... #byte    PR6      =  0x0F4B 
....................  
.................... // ADC registers 
.................... #word    ADRES    =  0x0FC3 
.................... #byte    ADCON0   =  0x0FC2 
.................... #BIT     ADON        =  ADCON0.0 
.................... #BIT     ADGO        =  ADCON0.1 
.................... #byte    ADCON2   =  0x0FC0 
.................... #define  ADC_SETUP_DEF  0xFF   // right justified read, 20TAD acquisition time (insurance), FRC 
....................  
.................... // CCP registers       
.................... #byte    CCPR1H   =  0x0FBF 
.................... #byte    CCPR1L   =  0x0FBE 
.................... #byte    CCP1CON  =  0x0FBD 
.................... #byte    CCPR2H   =  0x0F68 
.................... #byte    CCPR2L   =  0x0F67 
.................... #byte    CCP2CON  =  0x0F66 
.................... #byte    CCPR3H   =  0x0F5F 
.................... #byte    CCPR3L   =  0x0F5E 
.................... #byte    CCP3CON  =  0x0F5D 
.................... #byte    CCPR4H   =  0x0F59 
.................... #byte    CCPR4L   =  0x0F58 
.................... #byte    CCP4CON  =  0x0F57 
.................... #byte    CCPR5H   =  0x0F56 
.................... #byte    CCPR5L   =  0x0F55 
.................... #byte    CCP5CON  =  0x0F54 
....................  
.................... #byte    CCPTMRS0 =  0x0F49 
.................... #byte    CCPTMRS1 =  0x0F48 
.................... #byte    PSTR1CON =  0x0FB9 
.................... #byte    BAUDCON1 =  0x0FB8 
....................  
.................... #byte    SPBRGH1  =  0x0FB0 
.................... #byte    SPBRG1   =  0x0FAF 
.................... #byte    RCREG1   =  0x0FAE 
.................... #byte    TXREG1   =  0x0FAD 
.................... #byte    TXSTA1   =  0x0FAC 
.................... #BIT     TRMT1       = TXSTA1.1     // 1: empty xmit reg, 0: xmit in progress 
.................... #byte    RCSTA1   =  0x0FAB 
.................... #BIT     FERR1       = RCSTA1.2 
....................  
.................... #byte    PIR1     =  0x0F9E 
.................... #BIT     TMR1IF      = PIR1.0 
.................... #BIT     TMR2IF      = PIR1.1 
.................... #BIT     SSP1IF      = PIR1.3 
.................... #BIT     ADIF        = PIR1.6 
.................... #byte    PIR2     =  0x0FA1 
.................... #BIT     CCP2IF      = PIR2.0 
.................... #BIT     TMR3IF      = PIR2.1 
.................... #BIT     BCL1IF      = PIR2.3 
.................... #BIT     C1IF        = PIR2.6 
.................... #BIT     OSCFIF      = PIR2.7 
.................... #byte    PIR3     =  0x0FA4 
.................... #BIT     TMR5GIF     = PIR3.2 
.................... #BIT     TMR3GIF     = PIR3.1 
.................... #BIT     TMR1GIF     = PIR3.0 
.................... #byte    PIR4     =  0x0F7B 
.................... #BIT     CCP3IF      = PIR4.0 
.................... #BIT     CCP4IF      = PIR4.1 
.................... #BIT     CCP5IF      = PIR4.2 
.................... #byte    PIR5     =  0x0F7E 
.................... #BIT     TMR4IF      = PIR5.0 
.................... #BIT     TMR5IF      = PIR5.1 
.................... #BIT     TMR6IF      = PIR5.2 
....................  
.................... #byte    PIE1     =  0x0F9D 
.................... #BIT     TMR2IE      =  PIE1.1 
.................... #byte    PIE2     =  0x0FA0 
.................... #BIT     CCP2IE      =  PIE2.0 
.................... #byte    PIE3     =  0x0FA3 
.................... #byte    PIE4     =  0x0F7A 
.................... #byte    PIE5     =  0x0F7D 
....................  
.................... #byte    IPR1     = 0x0F9F 
.................... #byte    IPR2     = 0x0FA2 
.................... #byte    IPR3     = 0x0FA5 
.................... #byte    IPR4     = 0x0F7C 
.................... #byte    IPR5     = 0x0F7F 
....................  
.................... #byte    LATA     =  0x0F89 
.................... #byte    PORTA    =  0x0F80 
.................... #byte    TRISA    =  0x0F92 
.................... #byte    LATB     =  0x0F8A 
.................... #byte    PORTB    =  0x0F81 
.................... #byte    TRISB    =  0x0F93 
.................... #byte    LATC     =  0x0F8B 
.................... #byte    PORTC    =  0x0F82 
.................... #byte    TRISC    =  0x0F94 
.................... #byte    LATD     =  0x0F8C 
.................... #byte    PORTD    =  0x0F83 
.................... #byte    TRISD    =  0x0F95 
.................... #byte    LATE     =  0x0F8D 
.................... #byte    PORTE    =  0x0F84 
.................... #byte    TRISE    =  0x0F96 
....................  
.................... #byte    PSTR2CON =  0x0F63 
.................... #byte    IOCB     =  0x0F62 
.................... #byte    WPUB     =  0x0F61 
.................... #byte    PSTR3CON =  0x0F5A 
....................  
.................... #byte    CM1CON0  =  0x0F79 
.................... #bit     C1ON        = CM1CON0.7 
.................... #bit     C1POL       = CM1CON0.4 
.................... #byte    CM2CON0  =  0x0F78 
.................... #byte    CM2CON1  =  0x0F79 
....................  
.................... #byte    VREFCON0 =  0x0F42 
.................... #bit     FVREN    =  VREFCON0.7     //fixed voltage ref enable 
.................... #bit     FVRST    =  VREFCON0.6     //fixed voltage ref stable 
.................... #bit     FVRS1    =  VREFCON0.5     //fixed voltage select 1 
.................... #bit     FVRS0    =  VREFCON0.4     //fixed voltage select 0 
.................... #byte    VREFCON1 =  0x0F41 
.................... #byte    VREFCON2 =  0x0F40 
....................  
.................... #byte    PMD0     =  0x0F3F 
.................... #byte    PMD1     =  0x0F3E 
.................... #byte    PMD2     =  0x0F3D 
.................... #byte    CTMUICON =  0x0F43 
.................... #byte    CTMUCONL =  0x0F44 
.................... #byte    CTMUCONH =  0x0F45 
.................... #byte    SRCON1   =  0x0F46 
.................... #byte    SRCON0   =  0x0F47 
....................  
.................... #byte    SSP1CON2 =  0x0FC5 
.................... #BIT     SEN         = SSP1CON2.0 
.................... #BIT     PEN         = SSP1CON2.2 
.................... #byte    SSP1CON1 =  0x0FC6 
.................... #BIT     WCOL        = SSP1CON1.7 
.................... #byte    SSP1STAT =  0x0FC7 
.................... #BIT     I2CBUSY     = SSP1STAT.0 
....................  
.................... #define  RCON_INIT    0b00010011 
.................... // OR with RCON to SET BORn, PORn and RIn bits 
....................  
.................... /////////////////////Special Function Registers End//////////////////////////// 
....................  
.................... /////////////////////I/0 Lines and Initialization Start//////////////////////// 
....................   
.................... //  PORTA/B/C _ COLD and TRISA/B/C _ NORM are fine for lowest_pwr() I/O setup 
....................  
.................... ////////////////////ADC channel choices 
.................... #define V_EXT_REF    0        // AN0 = RA0, 1.2V accurate reference 
....................                               // use 1.2V accurate ref for measurements 
.................... #define V_VLVI       1        // AN1 = RA1 
.................... #define V_GEN        12       // AN12 = RB0 (INT0) 
.................... #define V_XDC        13       // Extra IO 1, now used for XDCR measurements 
....................       
.................... #define V_DAC        30       // DAC output may be read by ADC 
.................... #define V_FIXED      31       // 1.024/2.048/4.096V Fixed Reference (internal) 
....................  
....................  
.................... ////////////////////PORT A///////////////////// 
....................  
.................... //    V_EXT_REF    PIN_A0      // external reference, analog AN0 
.................... //    V_VLVI       PIN_A1      // sense line, valve motor current, analog AN1 
.................... #define LED2n        PIN_A2      // RA2 output, active lo 
.................... #define MOTE_RX_CTSn PIN_A3      // RA3 input active lo 
....................                                  //  mote asserts to tell micro it is 
....................                                  //  clear to rcv data from micro; 
....................                                  //  was _DUST_MTCTS 
....................                                  //  set as output, init hi 
.................... #define GPS_PWRn     PIN_A4      // RA4 output, active lo 
.................... #define MOTE_TX_CTSn PIN_A5      // RA5 output, active lo,  
....................                                  //  assert to initiate rcv data from MOTE, 
....................                                  //  byte level handshake; 
....................                                  //  was _DUST_SPCTS                                
.................... //      OSC2         PIN_A6      // xtal osc output connection 
.................... //      OSC1         PIN_A7      // xtal osc input connection 
....................  
.................... #define TRISA_NORM   0b10001011 
....................                                  // A0 analog 
....................                                  // A1 analog 
....................                                  // A2 output 
....................                                  // A3 input 
....................                                  // A4 output 
....................                                  // A5 output 
....................                                  // A6 output 
....................                                  // A7 input 
.................... #define PORTA_INIT   0b01110100 
....................                                  // A0 analog (0) 
....................                                  // A1 analog (0)  
....................                                  // A2 output active lo (1) 
....................                                  // A3 input (0) 
....................                                  // A4 output active lo (1) 
....................                                  // A5 output active lo (1) 
....................                                  // A6 output (1) 
....................                                  // A7 input (0) 
.................... #define PORTA_IDLE   PORTA_INIT 
.................... #define PORTA_DEEP   PORTA_INIT 
....................  
....................  
.................... ////////////////////PORT B//////////////////// 
....................  
.................... #define V_GEN_INT    PIN_B0      // RB0 input, high for significant v_gen; 
....................                                  //  generally analog, but may be input; 
....................                                  //  INT0 
....................                                   
.................... #define GPS_TXRDY    PIN_B1      // RB1 input, high indicates GPS has data 
....................                                  //  ready to transmit to micro 
....................                                   
.................... #define MOTE_TX_RTSn PIN_B2      // RB2 input, active lo 
....................                                  //  mote asserts to tell micro it is 
....................                                  //   ready to send data to micro; 
....................                                  //  was _DUST_MTRTS; INT2    
....................                                   
.................... #define LTC3105_CTRL PIN_B3      // output, active hi, P2A-pwm, 
....................                                  //  shdn/enab input of 3105 
....................                                  //  hi for max chg aggressiveness (lower RPM) 
....................  
.................... #BIT    LTC3105_CTRL_pinstate   = LATB.3 
....................  
....................  
.................... #define SW1n         PIN_B4      // usually an input, active lo 
....................                                  //  note can be IOC 
.................... #define LED1n        PIN_B4      // may become an output, active lo 
....................  
.................... #define ADC_XDCR     PIN_B5      // wired as input (ADC) to analog XDCR signal 
....................                                                                  
.................... #define SPARE2       PIN_B6      // consider as an input (PGC); 
....................                                  //  wired to VLV_XDCR header     
.................... #define SPARE3       PIN_B7      // consider as an input (PGD) 
....................  
.................... #define TRISB_NORM   0b11110111 
....................                                  // B0 input (INT0) 
....................                                  // B1 input (INT1) 
....................                                  // B2 input (INT2) 
....................                                  // B3 output 
....................                                  // B4 input (usually, may become an output) 
....................                                  // B5 input (spare) 
....................                                  // B6 input (PGC) 
....................                                  // B7 input (PGD)                                             
.................... #define TRISB_LED    0b11100111 
....................                                  // same as TRISB_NORM, but PIN_B4 is output 
....................                                                                                 
.................... #define PORTB_INIT   0b00011000 
....................                                  // B0 input (0) 
....................                                  // B1 input (0) 
....................                                  // B2 input (0) 
....................                                  // B3 output (LTC3105_CTRL) hi=fully charge (1) 
....................                                  // B4 usually an input,  
....................                                  //   may be output active lo (1) 
....................                                  // B5 input unused (0) 
....................                                  // B6 may be spare I/O (PGC)  
....................                                  // B7 may be spare I/O (PGD) 
.................... #define PORTB_IDLE   0b00010000  // only difference here is that LTC3105 is 
....................                                  //  shut down              
.................... #define PORTB_DEEP   PORTB_IDLE 
....................  
....................                                    
.................... #define PORTB_PULLUPS            0b00010010 
.................... #define PORTB_PULLUPS_WITH_XDCR  0b00110010             
....................                                  // only MOTE_TX_RTSn (pin B2)  
....................                                  // and SW1/LED1 are pulled up by defualt. 
....................                                  // ADC_XDCR (pin B5) is turned on for a second to detect  
....................                                  //    if the XDCR is plugged in or not during XDCR_init()   
....................                                                                         
....................                                 
....................                                                                                             
.................... ////////////////////PORT C//////////////////// 
....................  
.................... //      SOSCO        PIN_C0      // xtal osc output connection 
.................... //      SOCSI        PIN_C1      // for debug, we can look at frequency here 
.................... #define BRK_CTRLn    PIN_C2      // P1A-pwm, to gates of FETs -- 
....................                                  //  lo for max braking force, hi for no brake 
....................  
.................... #BIT     BRK_pinstate   = LATC.2                               
....................  
.................... //      SCL1         PIN_C3      // I2C clock 
.................... //      SDA1         PIN_C4      // I2C data 
.................... #define XDCR_PWR     PIN_C5      // output, active hi 
.................... //      MOTE_RX      PIN_C6      // UART1 TX output 
.................... //      MOTE_TX      PIN_C7      // UART1 RX input 
....................  
.................... #define TRISC_NORM   0b10011010 
....................                                  // C0 output 
....................                                  // C1 input 
....................                                  // C2 output 
....................                                  // C3/C4 inputs (I2C) 
....................                                  // C5 output 
....................                                  // C6 output (UART TX / MOTE_RX) 
....................                                  // C7 input  (UART RX / MOTE_TX) 
....................  
.................... #define PORTC_INIT   0b01000101 
....................                                  // C0 output (1) 
....................                                  // C1 input (0) 
....................                                  // C2 output (SPD_CTRL hi=no braking) (1) 
....................                                  // C3/4 I2C, init as inputs (0) 
....................                                  // C5 output active hi (0) 
....................                                  // C6 output (1) 
....................                                  // C7 input (0) 
.................... #define PORTC_IDLE   PORTC_INIT 
.................... #define PORTC_DEEP   PORTC_INIT 
....................  
.................... ////////////////////PORT D//////////////////// 
.................... #define GPS_ON       PIN_D0      // output, active hi 
.................... #define MOTE_TIMEn   PIN_D1      // output, active lo, gets time from mote 
.................... #define LCD_RESETn   PIN_D2      // output, active lo 
.................... #define AUX_PWR      PIN_D3      // output, active hi, turns on AUX pwr 
.................... #define MOTE_RESETn  PIN_D4      // output, active lo 
.................... #define MOTE_RX_RTSn PIN_D5      // output, active lo 
....................                                  //  micro asserts to tell mote it is  
....................                                  //   ready to send data to mote 
.................... #define GPS_RX       PIN_D6      // UART2 TX output 
.................... #define GPS_TX       PIN_D7      // UART2 RX input 
....................  
.................... #define TRISD_NORM   0b10000000 
....................                                  // D0 output 
....................                                  // D1 output 
....................                                  // D2 output (spare) 
....................                                  // D3 output 
....................                                  // D4 output 
....................                                  // D5 output 
....................                                  // D6 output 
....................                                  // D7 input 
....................  
.................... #define PORTD_INIT   0b01110110 
....................                                  // D0 output active hi (0) 
....................                                  // D1 output active lo (1) 
....................                                  // D2 output active lo (1) 
....................                                  // D3 output active hi (0) 
....................                                  // D4 output active lo (1) 
....................                                  // D5 output active lo (1) 
....................                                  // D6 output (1) 
....................                                  // D7 input (0) 
.................... #define PORTD_IDLE   PORTD_INIT 
.................... #define PORTD_DEEP   PORTD_INIT 
....................  
.................... ////////////////////PORT E//////////////////// 
.................... #define VLV_CTRL1    PIN_E0      // P3A-pwm, to H-bridge re valve  
.................... #define VLV_CTRL2    PIN_E1      // P3B-pwm, to H-bridge re valve 
.................... #define GEN_RPM      PIN_E2      // CCP5 input 
.................... //       MCLRn       PIN_E3 
....................  
.................... #define TRISE_NORM   0b00001100 
....................                                  // E0 output 
....................                                  // E1 output 
....................                                  // E2 input 
....................                                  // E3 master clear input 
....................  
.................... #define PORTE_INIT   0b00000000 
....................                                  // E0 output (E0,E1 = 00 for coast state) 
....................                                  // E1 output 
....................                                  // E2 input (0) 
....................                                  // E3 input (0) 
.................... #define PORTE_IDLE   PORTE_INIT  // TURNS off the power supply to  
....................                                  //  the valve motor 
.................... #define PORTE_DEEP   PORTE_INIT 
....................  
.................... /////////////////////I/0 Lines and Initialization End////////////////////////// 
....................  
....................  
.................... /////////////////////Timer 0 Start///////////////////////////////////////////// 
....................  
.................... // THESE VALUES ARE DEPENDENT UPON CRYSTAL FREQUENCY 
.................... // Modify with care 
.................... #define  T0_OSC    4340 
.................... // After calibration of 1MHz HFINTOSC timebase to 921.6KHz: 4/Fosc = 4340 nsec 
....................  
.................... // Assume 16 bit timer0 input is FOSC div 128 (timer 0 prescaler) 
.................... // Thus one count every 128*T0_OSC nanoseconds                      
.................... #define T0_SETUP(MS) {  setup_timer_0(T0_DIV_128); \ 
....................                         set_timer0(65536 - (1000000*MS + 64*T0_OSC)/(128*T0_OSC)); } 
.................... // Note roundoff fix                     
.................... // For use with the routine setup_T0_int(*) 
....................  
.................... //Timer 0 options 
.................... #define  T0_500US    65534 
.................... #define  T0_1MS      65536 - 1000/256 
.................... #define  T0_10MS     65536 - 10000/256 
.................... #define  T0_20MS     65536 - 20000/256 
.................... #define  T0_50MS     65536 - 50000/256 
.................... #define  T0_100MS    65536 - 100000/256 
.................... #define  T0_175MS    65536 - 175000/256 
.................... #define  T0_250MS    65536 - 250000/256 
.................... #define  T0_500MS    65536 - 500000/256 
.................... #define  T0_1S       65536 - 1000000/256 
.................... #define  T0_2S       65536 - 2000000/256 
.................... #define  T0_3S       65536 - 3000000/256 
.................... #define  T0_4S       65536 - 4000000/256 
.................... #define  T0_6S       65536 - 6000000/256 
.................... #define  T0_16S      65536 - 16000000/256 
.................... // the max is actually 16.7 seconds 
....................  
.................... /////////////////////Timer 0 End/////////////////////////////////////////////// 
....................  
.................... /////////////////////Timer 2 Start///////////////////////////////////////////// 
....................  
.................... // For use with the routine setup_T2_int(*) 
.................... // The equivalent tick duration for timer2 is 
.................... //  adjusted depending on Fosc to be approx 256usec 
.................... // Timer2 counts up from 0 to match PR2 in order to set int flag 
.................... #define T2_1MS       3 
.................... #define T2_2MS       7 
.................... #define T2_3MS       11 
.................... #define T2_4MS       15 
.................... #define T2_5MS       19 
.................... #define T2_6MS       23 
.................... #define T2_7MS       27 
.................... #define T2_8MS       31 
.................... #define T2_9MS       35 
.................... #define T2_10MS      39 
.................... #define T2_15MS      59 
.................... #define T2_20MS      79 
.................... #define T2_25MS      99 
.................... #define T2_30MS      119 
.................... #define T2_40MS      159 
.................... #define T2_50MS      199 
.................... #define T2_60MS      239 
.................... #define T2_64MS      255 
.................... // cannot set to higher than 64 milliseconds  
....................  
.................... ////////////////////Timer 2 End//////////////////////////////////////////////// 
....................  
.................... /////////////////////Timer 4 Start///////////////////////////////////////////// 
....................  
.................... // For use with the routine setup_T4_int(*) 
.................... // The equivalent tick duration for timer4 is 
.................... //  adjusted depending on Fosc to be approx 256usec 
.................... // Timer4 counts up from 0 to match PR4 in order to set int flag 
.................... #define T4_500US     1 
.................... #define T4_1MS       3 
.................... #define T4_2MS       7 
.................... #define T4_3MS       11 
.................... #define T4_4MS       15 
.................... #define T4_5MS       19 
.................... #define T4_6MS       23 
.................... #define T4_7MS       27 
.................... #define T4_8MS       31 
.................... #define T4_9MS       35 
.................... #define T4_10MS      39 
.................... #define T4_15MS      59 
.................... #define T4_20MS      79 
.................... #define T4_25MS      99 
.................... #define T4_30MS      119 
.................... #define T4_40MS      159 
.................... #define T4_50MS      199 
.................... #define T4_60MS      239 
.................... #define T4_64MS      255 
.................... // cannot set to higher than 64 milliseconds  
....................  
.................... ////////////////////Timer 4 End//////////////////////////////////////////////// 
....................  
....................  
.................... ////////////////////Battery-Voltage Start////////////////////////////////////// 
.................... // magic number based upon 4 samples averages with 1.2V reference! 
.................... // 12.20 format (4.8V) 
.................... #define VAL32_FVR_BAT      4.8 * 1048576 // 5033164.8 = 4CCCCD 
....................  
.................... ////////////////////Battery-Voltage End//////////////////////////////////////// 
....................  
....................  
....................  
.................... ////////////////////Restart Causes Start/////////////////////////////////////// 
.................... /* 
.................... // reset_cause is set to one of these values before any reset_cpu instruction 
....................  
.................... #define WARM_RESTART          0x00  // commanded: joins if needed 
.................... #define SPIN_RESTART          0x10  // generator wakeup from Deep sleep  
....................                                     //  or idle sleep 
....................                                     //  like WARM_RESTART                                         
.................... #define FRC_RJOIN_RESTART     0x20  // commanded to duplicate behavior of 
....................                                     //  unexpected mote state change during 
....................                                     //  RUN; like WARM_RESTART; mote rejoins 
....................                                     //  and informs manager 
.................... #define RJOIN_RESTART         0x30  // unexpected mote state change during 
....................                                     //  RUN; like WARM_RESTART; mote rejoins 
....................                                     //  and informs manager   
.................... #define COLD_RESTART          0x50  // commanded: force join 
.................... */ 
.................... ////////////////////Restart Causes End///////////////////////////////////////// 
....................  
.................... ////////////////////Extra LCD Start//////////////////////////////////////////// 
.................... /* 
.................... // New Haven display part number NHD-C0216CIZ-FSW-FBW-3V3 special characters 
.................... #define  CROSS_CHAR        0xF7 
.................... // small cross 
.................... #define  BOX_CHAR          0xDB 
.................... // rectangle 
.................... #define  TOPLINE_CHAR      0xFF 
.................... // top line designates battery full, no charging needed 
.................... #define  NOTEQU_CHAR       0xFD 
.................... // equ with slash 
.................... #define  NOCHG_CHAR        0xE4 
.................... // c with slash, cent symbol, indicates charger circuit OFF 
.................... #define  MAXCHG_CHAR       'C' 
.................... #define  MINBRAKE_CHAR     'b' 
.................... #define  MAXBRAKE_CHAR     'B' 
.................... // PFHI character, indicates maximum braking force 
.................... #define  NOVLV_CHAR        'v' 
.................... // a PERIOD indicates valve PWM set for NO MOTION 
.................... #define  MAXVLV_CHAR       'V' 
.................... // ! indicates valve PWM set for MAX speed 
....................  
.................... #define  APPOS_CHAR        0x27 
.................... // appostrophe character: ' 
....................  
....................  
.................... //#define  APPROX_CHAR       0x00 
.................... // custom approx equal character loaded at LCD_INIT 
....................  
.................... // custom characters loaded during LCD_INIT 
.................... #define  LEV1_CHAR         0x00 
.................... #define  LEV2_CHAR         0x01 
.................... #define  LEV3_CHAR         '_' 
.................... #define  LEV4_CHAR         0x02 
.................... #define  LEV5_CHAR         0x03 
.................... #define  LEV6_CHAR         '-' 
.................... #define  LEV7_CHAR         0x04 
.................... #define  LEV8_CHAR         0x05 
.................... #define  LEV9_CHAR         0x06 
.................... #define  LEV10_CHAR        0xFF 
....................  
.................... #define  BIGBOX_CHAR       0x07 
.................... #define  WAYLOW_CHAR       0xFB 
.................... // << 
.................... #define  WAYHI_CHAR        0xFC 
.................... // >> 
.................... #define  CIRCLE_CHAR       0xF2 
.................... // small circle 
....................  
.................... */ 
.................... ////////////////////Extra LCD End////////////////////////////////////////////// 
.................... ////////////////////EEPROM Locations Start///////////////////////////////////// 
....................  
.................... // EEPROM LOCATIONS 
.................... #define EE_ADDCHG_DUR      0x0002 
....................    // Configures add-charging time in seconds 
....................    // 2 bytes, low byte at 0x0002 
.................... #define ADDCHG_DUR_DEF     4 
....................    // 4 minutes? 
.................... #define EE_PRECHG_DUR      0x0004 
....................    // Configures precharging time in seconds 
....................    // 2 bytes, low byte at 0x0004 
.................... #define PRECHG_DUR_DEF     10 
....................    // 1.5 minutes?  
.................... #define CHGLOOPS_PER_MIN   110 
....................    // determined experimentally, each loop is about 545 msec 
....................    //  which is a bit longer than I would prefer (!), but oh well. 
....................    //  JG 2015 Jun16 
....................     
.................... // 0x00A thru 0x00F        reserved 
.................... #define EE_NETW_ID         0x0010 
....................    // 2 bytes, low byte at 0x0010; for now, network ID defaults to 0x04CD. 
.................... #define EE_PRENETW_ID      0x0012 
....................    // 2 bytes, low byte at 0x0012; for now, network ID defaults to 0x04CD. 
....................  
....................  
.................... // 0013 reserved 
.................... #define EE_LOCATION     0x0014 
....................    // 2 bytes, low byte at 0x0014; associates sprinkler with particular 
....................    //  physical location on CP 
.................... #define EE_PRELOCATION  0x0016 
....................    // 2 bytes, low byte at 0x0016, previous association of sprinkler with 
....................    //  particular physical location on CP 
....................  
....................    // 0x018 thru 0x01F     reserved 
....................  
.................... // IDLE behavior specified at 0x0020 thru 0x0033 
.................... #define EE_IDLE_OPT        0x0020 
....................    // Configures IDLE behavior.  Applies if battery low during operational 
....................    //  state 
....................    //  0x00  send out Panic Message once when panic level is reached according 
....................    //         to voltage-based algorithm 
....................    //  0x01  send out Panic Message once when panic level is reached according 
....................    //         to charge-based algorithm 
.................... #define MAX_IDLE_OPT       1 
....................    // If manager tries to write any idle_opt value larger than this to EEPROM 
....................    //  a NACK occurs; see above for idle option choices 
.................... #define LEN_IDLE_BLOCK     15 
....................    // There are 15 bytes in the idle block 
....................  
.................... #define EE_IDLE_PROFILE    0x0021 
....................    // Saved only upon entering IDLE state; 
....................    //  profile number which was running or had last been run. 
....................    // 0 for default profile, 1, 2, 3 for controller-specified profile choices 
....................    //  other numbers, use 0 
.................... #define EE_IDLE_STEP       0x0022 
....................    // Saved only upon entering IDLE state; 
....................    //  step number of profile which was running or had last been run. 
....................    //  Step 0xFF indicates that we were not within a profile 
....................    //  Step 0x10 thru 0xFE invalid. 
.................... #define EE_IDLE_STIME      0x0023 
....................    // 2 bytes, low byte at 0x0023, high byte at 0x0024 
....................    // Saved only upon entering IDLE state; 
....................    //  amount of time in seconds that rate was controlled according 
....................    //  to EE_IDLE_STEP at time when IDLE state entered; 
....................    //  set to 0x0000 if EE_IDLE_STEP=0xFF. 
.................... #define EE_IDLE_LOOP       0x0025 
....................    // 2 bytes, low byte at 0x0025, high byte at 0x0026 
....................    // Saved only upon entering IDLE state; 
....................    //  for looping profiles, loop number at time when IDLE state entered; 
....................    //  set to 0x0000 for non-looping profiles, set to 
....................    //  0x0000 if EE_IDLE_STEP=0xFF. (looping beyond 0xFFFF is recorded as 
....................    //  0xFFFF) 
.................... #define EE_IDLE_CHG        0x0027 
....................    // 2 bytes, low byte at 0x0027, high byte at 0x0028 
....................    // Configures used charge in millicoulombs for 
....................    //  charge-based shutdown method (TBD); applies if EE_IDLE.1 is set 
.................... #define EE_IDLE_SHDN_DLY   0x0029 
....................    // 2 bytes, low byte at 0x0029, high byte at 0x002A 
....................    // Configures time in units of 67 secs (TMR0 ints during IDLE) 
....................    //  between sensing of low battery and self-shutdown 
....................  
.................... ////////////////////EEPROM Locations End/////////////////////////////////////// 
.................... //*************************************************************** 
.................... /* 
.................... #define DAY_SECS           24*3600 
....................  
.................... #define VAL32_FVR_BAT      4.8 * 1048576 // 5033164.8 = 4CCCCD 
.................... // magic number based upon 4 samples averages with 1.2V reference! 
.................... // 12.20 format (4.8V) 
....................  
.................... #define NETWORK_ID_DEF  0x04CD 
.................... // 04CD flipped bytes to match received network ID (JG!~?) 
.................... // this is the net_id for BlueBox#0 
.................... #define NETWORK_ID_MAX  NETWORK_ID_DEF + 250 
.................... // We could actually go from 0 (0x04CD) to 254, with 255 being illegal 
.................... //  as what would be read from cleared EEPROM 
....................  
.................... #define MAX_SP_NUM      499 
.................... // based on maximum number of motes that can be supported by Blue Box 
.................... #define MAX_SP_CP       200 
.................... // highest sprinkler number which uses the WARNER VALVE parameters 
.................... //  otherwise uses the BENCH VALVE SIMULATOR parameters 
....................  
.................... // state of charge levels 
....................  
.................... #define R2T             23040 
....................    // 0x00005A00 
....................    // Divide this number by RPM to get the target CCP2 capture value 
....................    //  representative of speed. 
....................    // 23040 RPM/(CCP2-prev_count) = 19200Hz * 6/5, where 19.2KHz is fosc/4, 
....................    //  (1 rising edge occurs per capture event) and 6/5 RPM/Hz is the 
....................    //  generator-dependent relationship between its output frequency and its 
....................    //  RPM. 
....................    // For example, 10RPM results in 2304 counts in the capture register 
.................... #define R2Tx4      R2T*4 
....................  
.................... #define VMOTION_TIMEOUT    60 
.................... // if valve travels longer than this time, a timeout error occurs 
....................  
.................... #define RPM_MIN            4 
.................... #define RPM_MAX            400 
.................... // when target_RPM = 0, we are in a braking mode 
....................  
.................... #define PERIOD_5RPM        4608 
....................  
.................... #define SHUT_DEL_DEF       30 
.................... // default shutdown delay to ensure that all motes get broadcast msg: 30 sec 
.................... // also used to ensure that manager acknowledges errors and first_msg in a  
.................... //  timely manner (else there will be a repeat 
.................... #define REPEAT_LIMIT       4 
.................... // number of times that an unsolicited msg will repeat waiting for an 
.................... //  ACK from the manager. 
....................  
.................... #define STARTUP_DELAY      4 
.................... // delay in units of 1/4 sec at startup before opening valve for 
.................... //  first time 
....................  
.................... #define RSSI_MIN           -64 
.................... // -64 dBm; minimum rssi of an advertising message required 
.................... //   for that network to be a viable net to join 
.................... // BRIAN, this value may be TOO SENSITIVE 
.................... #define LISTEN_TIME        20 
.................... // number of seconds to dwell in promiscuous hi-power listen mode 
.................... //  in search of networks to join when mote has been cold-booted 
.................... // MUST be 1-27 -- 15s is occassionally too short a time 
.................... #define LISTEN_T1          65536 - LISTEN_TIME*2400 
.................... // 76.8KHz clock (19.2KHz counting up at timer1 div8.... 
....................  
....................  
.................... #define TIMER2_SETUP_XTAL        T2_DIV_BY_4, 199, 8 
.................... // for 3.6864MHz xtal, this is the value used in setup_timer_2  
.................... // to achieve 1152Hz PWM frequency (for braking purposes) 
.................... // AND interrupt rate (used for valve algorithms) of 144Hz 
.................... //  (check valve current approx once every 7msec) 
.................... // Increments "RTC" by 7 when keeping track of time (about 0.8% fast!) 
.................... #define FAST_CLK  0 
.................... #define FAST_MS   7 
....................  
.................... #define TIMER2_SETUP_250K        T2_DIV_BY_1, 199, 16 
.................... // for 250KHz internal clock, this is the value used in setup_timer_2  
.................... // to achieve 312.5KHz PWM frequency (for braking purposes) 
.................... // AND interrupt rate of ~104Hz 
.................... // Increments "RTC" by 51 when keeping track of time (about 0.4% slow if  
.................... //    250KHZ internal clock is accurate, which it is not) 
.................... #define MED_CLK   1 
.................... #define MED_MS    51 
....................  
.................... #define TIMER2_SETUP_31K         T1_DIV_BY_1, 199, 4 
.................... // for 31KHz LFINTOSC (inaccurate), this is value used in setup_timner_2 
.................... // to achieve interrupt rate of 9.7Hz (103msec) 
.................... // Not meant to be accurate, no need for variable braking when running at 31KHz 
.................... #define SLOW_CLK  2 
.................... #define SLOW_MS   103 
....................  
.................... //#define TIMER3_CCP2_SETUP       T3_DIV_BY_8 | T3_CCP2 | T3_INTERNAL 
.................... #define TIMER3_CCP2_SETUP       T3_DIV_BY_8 | T3_INTERNAL 
.................... //  This is the value used by setup_timer_3 in order to monitor real time 
.................... //   and to provide a time reference (CCP_2) for measurement of sprinkler RPM. 
.................... // 3.6864MHz div4 div8 = 57.6KHz 
.................... //*****NOTE THIS IS AN ISSUE WITH 3.6864MHz clock 
....................  
.................... #define TIMER3_AD_SETUP           
.................... //  This is the value used by setup_timer_3 in order to automatically 
.................... //   have the ADC monitor the valve current during the initial closure 
.................... //   of the valve. 
.................... //  1.832MHz clock here.  Checks ADC  
....................  
.................... #define CCP1_BRK  CCP_PWM_H_H | CCP_PULSE_STEERING_A | CCP_PULSE_STEERING_SYNC 
.................... //  This is the value used by setup_ccp1 in order to enable PWM-controlled  
.................... //   braking 
.................... #define CCP1_CHG  CCP_PWM_H_H | CCP_PULSE_STEERING_D | CCP_PULSE_STEERING_SYNC 
.................... //  This is value used by setup_cc1 in order to enable PWM-controlled 
.................... //   charging level 
.................... #define CCP1_BOTHn (CCP_PWM_H_H | CCP_PULSE_STEERING_A | CCP_PULSE_STEERING_D | CCP_PULSE_STEERING_SYNC) 
.................... //  This value is sued during transitions to/from full battery situation 
.................... //   CCP_BOTHn provides for charge enable pulse and braking pulsing IN PHASE 
.................... #define CCP1_BOTHi (CCP_PWM_H_L | CCP_PULSE_STEERING_A | CCP_PULSE_STEERING_D | CCP_PULSE_STEERING_SYNC) 
.................... //  CCP_BOTHi provides for charge enable pulse and braking pulsing OUT OF PHASE 
....................  
.................... #define IDLE_LOOP_31       T2_DIV_BY_16,160,1 
.................... // setup for timer2 determines length of lo-power sleeping between 
.................... //  mote message checks -- basically and roughly times the idle loop 
.................... // 31KHz clock, T2 div 16, 160 counts -> 3Hz 
.................... //  thus overflow in about 330 msec 
.................... // For calculating battery check and time check and rejoin timeout, 
.................... //  we assume that each idle loop takes ~400msec.  Longer than 330 because 
.................... //  because of the execution of the steps after timer2 
.................... //  wakes us up and before we go back into idle_sleep.  [150 loops per minute] 
.................... // And note that LFINTOSC is a +/-10% (or so) oscillator, so idle timing 
.................... //  is rough. 
....................  
.................... /* 
.................... #define IDLE_LOOP_76       T2_DIV_BY_16,197,2 
.................... // setup for timer 2 determines length of sleeping between mote 
.................... //  message checks while idling 
.................... // With 76.8KHz clock, timer increments every 833.3usec;  
.................... //  overflows every 198*.833msec = 165msec; interrupts every 330msec 
.................... // (see idle_sleep routine) 
.................... #define IDLE_LOOPS_PERMIN   182 
.................... // This number based on discussion above; change IDLE_LOOP_76 and 
.................... //  IDLE_LOOPS_PERMIN together 
.................... //#define TIMECHK_IDLELOOPS  25 
....................  
.................... #define TIMECHK_IDLEMINS   300 
.................... // DEBUG SETTING FOR TEST: 5 hours.... 
.................... #define TIMECHK_IDLELOOPS  TIMECHK_IDLEMINS*IDLE_LOOPS_PERMIN 
.................... // This amounts to checking network time once every 10 mins. 
....................  
.................... #define TIMCHK_INTERVAL    3600 
.................... // number of seconds between timechecks when knowtime_fl = TRUE 
.................... #define BATCHK_INTERVAL    900 
.................... // number of seconds between battery checks! 
.................... #define BATCHK_MARCH       840 
.................... // what this means is that when there is a marching order change 
.................... //  we preset the batchk_timer to this value... 
.................... // Thus 60 seconds after the valve has been adjusted, we THEN 
.................... //  check battery health (which could lead to a charging on or off  
.................... //  transition..... 
....................  
.................... #define MAX_JOINTIME       1800 
.................... // SHOULD BE ABOUT 1/2 hour or 1800 secs!!!!!! 
.................... // seconds to wait for a join to happen 
.................... ///  even at 1/2 hr, MAY BE TOO SHORT for a full 500 count mesh! 
....................  
.................... #define JOIN_MINSMAX       30 
.................... // Number of minutes that we wait for mote to become operational after  
.................... //  the first join; then we say goodnight 
....................  
.................... #define FIRSTDANCE_INTERVAL   120 
.................... // retry the MSG_IDENTIFIER if no acknowledge within this interval 
....................  
.................... #define REJOIN_INTERVAL       1800 
.................... // number of seconds after which we give up on rejoining! 
.................... */ 
.................... /* 
.................... #define RUN_LOOPS_PERMIN   120 
.................... // assume we are consistently at 500msec per loop 
....................  
.................... #define REJOIN_TIMEOUT     1800 
.................... // number of seconds at which we decide to GIVE up on rejoining! 
.................... #define TIMECHK_RUNSECS    3600 
.................... // check net time every hour 
.................... #define BATCHK_RUNSECS     3600 
.................... // check battery at least every hour 
.................... #define REJOIN_RUNSECS     1800 
.................... // cannot join if have attempted for more than 1/2 hour 
.................... #define REJOIN_DISP_LIM    REJOIN_RUNSECS - 3 
.................... // display REJOIN message during run for 3 seconds after rejoin is 
.................... //  initiated 
....................  
....................  
.................... #define  _ACTIVE_MIN   102 
.................... // if Vdd is 3.3V, this represents .33 volt at the generator 
....................  
.................... #define OPER_BCHK_INTVL    36600 
....................    // check the battery level every OPER_BCHK_INTVL tmr2 interrupts 
....................    //  during operation; 36600 for once every 10 minutes 
....................  
.................... #define FSLEEP_DEL   2 
....................    // wait this number of seconds after receipt of force_warm or force_sleep 
....................    //  manager commands before acting... allows time for ACK 
.................... */ 
....................  
.................... /* 
....................  
.................... #define NO_BRK             0 
.................... #define MAX_BRK            400 
.................... // MAX_BRK for absolute minimum speed 
....................     
.................... // min and max charging aggressiveness values (PWM)    
.................... #define MIN_CHGAGGR        0 
.................... #define MAX_CHGAGGR        400 
....................  
.................... #DEFINE MAX_CHGDUTY        0x320 
....................  
.................... #define MIN_PWM            0 
.................... #define MAX_PWM            400 
....................   
....................  
.................... #define FLAGS1_BNOCH       0x00 
.................... // no charge during BRK control as requested by operator 
....................  
.................... #define FLAGS1_NOFLO       0x01 
....................  
.................... #define FLAGS1_MANRPM      0x02 
.................... // manual set of MPPC (0x0 00-0x1FF), RPM CONTROL 
.................... #define FLAGS1_RPMOLD      0x03 
.................... // old table lookup for RPM control 
....................  
.................... // new adaptive algorith 
.................... #define FLAGS1_DYNLO       0x04 
.................... // most aggressive charging, PWM control of brake 
.................... #define FLAGS1_DYNMID      0x05 
.................... // variable MPPC 0-FF, no brake 
.................... #define FLAGS1_DYNHI       0x06 
.................... // variable PWM control of EN_3105, MPPC = 0xFF, no  brake 
....................  
.................... #define FLAGS1_RNOCH       0x07 
.................... // no charge during RPM control as requested by operator 
....................  
.................... #define FLAGS1_TRANS2F     0x08 
.................... #define FLAGS1_TRANS2N     0x09 
.................... // 08:09 for transitioning states to smooth out battery full situations while 
.................... //  dynamically charging  
....................  
.................... #define FLAGS1_MANBRK      0x0A 
.................... // manual set of MPPC (0x000-0x1FF), NO RPM CONTROL 
.................... #define FLAGS1_BRKOLD      0x0B 
.................... // old formula calc for BRK control 
....................  
.................... #define FLAGS1_MAXCHG      0x0C 
.................... // defined max charging state 
....................  
.................... #define FLAGS1_FREE        0x0D 
.................... // defined state for free spin 
....................  
.................... #define FLAGS1_MANPWM      0x0E 
.................... // manual setting of MPPC and PWM control of 3105 enable 
....................  
.................... #define FLAGS1_DYNFULL     0x0F 
.................... // no charge during BRK control as requested by operator 
....................  
....................    
.................... //#define FLAGS_READY        0x00 
....................  
.................... #define VOPEN_FULL         0x8000 
.................... // Valve to max open 
.................... #define VCLOSE_FULL        0 
.................... #define VUNKNOWN           0xFFFF 
....................  
.................... // RPM increases as cur_MPPC goes from 0 to FF 
.................... #define MPPC_MAX           0x01FF 
.................... #define MPPC_DYNMAX        0xFF 
.................... // value of MPPC during dynamic control mode at which we shift into 
.................... //  hi speed mode wherein we duty cycle modulate the charging circuit! 
.................... #define MPPC_MIN           0x00a 
.................... #define MPPC_ADDCHG        0x0D1 
.................... // This may need to be adjusted if we change the manner in which MPPC is set 
.................... //  during braking. See prep_4_brake reoutine 
....................  
.................... #define MPPC_DUTYLIM       0x320 
....................    // 0x320 = 800 
....................    // maximum duty cycle for charger (special modes) 
....................     
.................... //#define MPPC_CHGOFF        0x1FF 
.................... // What should MPPC be set to when charging is NOT happening?  Does it matter? 
....................  
.................... #define MPPC_DYNCHG    0x0FF 
.................... // This is the default STARTING POINT for the MPPC setpt during dynamic 
.................... //  charging control 
.................... #define MPPC_STEP2F     1 
.................... // This is the MPPC value step change which takes place during transitions 
.................... // from _DYNMID to full battery situation 
.................... #define MPPC_STEP2N     1 
.................... // This is the MPPC value step change which takes place during transitions 
.................... // from full battery situation to Dynamic charging situation 
....................  
.................... #define TRANS_PERSTEP   1 
.................... // This is the target period value step change which takes place during  
.................... // transitions from _DYNMID to full battery situation 
.................... #define TRANS_PWMSTEP   8 
.................... // This is the step change for the PWM when routed to the charger and while 
.................... //  transitioning from _DYNHI to full battery situation 
....................  
.................... #define CHRGING_THRESH     0x0011 
....................    // A/D counts difference between UNLOADED and LOADED Vchg measurement 
....................    // indicates whether or not we are (significantly) charging the battery now. 
....................    // We compare this value to (VchgU-VchgL) where this is in units of ADC 
....................    //  counts -- at 3mV per count, 50mv would be a CHRGING_THRESH of ~17. 
....................  
.................... #define NOSPIN_LIMIT       16 
....................    // Number of ~half-seconds of low or no rotation that must occur in order to 
....................    //  show the nospin display and alert the manager 
....................  
.................... #define NUM_4_STAT         64 
....................    // This is number of rpm measurements to process prior to determination of 
....................    //  AveRPM and Max/Min (~30sec interval) 
....................    // Also signals reporting to the manager 
.................... #define SHIFT_4_STAT       5 
....................    // This is intead of dividing by NUM_4_STAT; change these two values 
....................    //  together 
....................  
.................... #define TEN_MIN            600 
....................    // This is the number of seconds in ten minutes; used to time mandatory 
....................    //  battery checks 
....................  
.................... // defines for prechg_opt 
.................... // TIME or Alternative (voltage-based?) Algorithm utiling regulated RPM 
.................... #define PRECHG_TIME_RPM    0x00 
....................  
....................  
.................... // defines for msg_id (Manager->Mote Payload message ID to Micro) 
.................... #define MSG_FULL              0x01 
.................... #define MSG_WATER_ON          0x02 
.................... #define MSG_WATER_OFF         0x03 
....................    
.................... #define MSG_FORCE_WARM        0x06 
....................  
.................... #define MSG_SHUT_DEL_RD       0x0E 
.................... #define MSG_SHUT_DEL_WR       0x0F 
....................  
.................... #define MSG_FIRMWARE_RD       0x24 
....................  
.................... #define MSG_FORCE_TIME        0x29 
....................  
.................... #define MSG_FORCE_COLD_DEL    0x2B 
.................... #define MSG_FORCE_COLD        0x2C 
....................  
.................... #define MSG_FORCE_REJOIN_DEL  0x2E 
.................... #define MSG_FORCE_REJOIN      0x2F 
....................  
.................... #define MSG_MGR_ACK           0x30 
.................... #define MSG_MGR_NACK          0x31 
....................  
.................... #define MSG_SP_NUM_WR         0x44 
....................  
.................... #define MSG_DEFINE_TEST       0x49 
.................... #define MSG_MARCH1            0x50 
.................... // for IMMEDIATE or future MARCHING ORDER, closed loop RPM, timed valve 
.................... #define MSG_MARCH2            0x51 
.................... // for IMMEDIATE or future MARCHING ORDER, closed RPM and FLOW 
.................... #define MSG_READY             0x52 
.................... #define MSG_TEST              0x53 
.................... #define MSG_DEMO              0x54 
.................... // for immediate open loop setting of valve, brake, charger, etc. 
....................  
.................... #define MSG_REPORT_VALVE      0x59 
....................  
.................... #define MSG_SLEEPNOW          0x5B 
.................... #define MSG_SHUTDOWNC_DEL     0x5C 
.................... #define MSG_SHUTDOWNC         0x5D 
.................... #define MSG_SHUTDOWNO_DEL     0x5E 
.................... #define MSG_SHUTDOWNO         0x5F 
....................  
.................... #define MSG_HEALTH            0x60 
.................... #define MSG_CAL_VALVE         0x61 
.................... // short form of MSG_STD solicited by manager to get LOCATION, STATE, ERRORS 
....................  
.................... // defines for msg_id (Micro to Mote) 
.................... #define MSG_ACK            0x80 
.................... #define MSG_NACK           0x81 
.................... #define MSG_ERROR          0x82 
.................... #define MSG_MICRO_RESPONSE 0x83 
.................... #define MSG_FIRST          0x84 
.................... #define MSG_VCAL           0x85 
....................  
.................... // defines for various unsolicited messages 
.................... #define BATTERRb           7 
.................... //Indicates to LV program that the startup was 
.................... //  rocky due to a DEAD BATTERY! (bit7 set) 
.................... #define LOSPINb            6 
.................... // Indicates to LV program that the freespin speed measured during the  
.................... //  opening dance was less than FREESPIN_MIN (bit6 set) 
.................... #define OCDIFFb            5 
.................... // Indicates to LV program that the 1st open time and the 1st close 
.................... //  time differ by greater than 25% (bit5 set) 
.................... #define REJOINEDb          4 
.................... // Indicates that a rejoin occurred 
....................  
.................... // Note 3:2 carry information about 1st valve open 
.................... // and  1:0 carry information about 1st valve close 
.................... // as follows: 0b00   OK 
.................... //             0b01   timeout 
.................... //             0b10   TOO SHORT of a duration for valve motion 
.................... #define OPENSHORTb         3 
.................... #define OPENLONGb          2 
.................... #define CLOSESHORTb        1 
.................... #define CLOSELONGb         0 
....................  
.................... // defines for error codes as communicated to manager 
.................... #define NO_ERRCODE         0x00 
.................... #define BATOK_ERRCODE      0x03 
....................  
.................... #define FRC_SLEEP_ERRCODE  0x05 
.................... // manager forces system into a sleep state and decommissions the mote 
....................  
.................... #define LOC_ERRCODE        0x21 
.................... #define CPASSOC_ERRCODE    0x22 
.................... #define LOC_CP_ERRCODE     0x23 
....................  
.................... #define ADDCHG_WARNCODE    0x80 
.................... //#define LOWBAT_ERRCODE     0x80 
.................... #define PS_ERRCODE         0x81 
....................          // Vdd too high 
.................... #define WEAKBAT_WARNCODE   0x82 
.................... #define DEADBAT_ERRCODE    0x83 
....................  
.................... // defines for state variable 
.................... #define  DEV_INIT          0x00 
.................... #define  DEV_JOINING       0x01 
.................... #define  DEV_1STEXCH       0x02 
.................... #define  DEV_READY         0x03 
.................... #define  DEV_RUN           0x04 
.................... #define  DEV_PAUSED        0x05 
.................... #define  DEV_IDLE          0x06 
.................... #define  DEV_SLEEP         0x07 
.................... #define  DEV_TEST          0x08 
.................... #define  DEV_DEMO          0x09 
....................  
.................... // defines for vlv_state variable 
.................... #define  VLV_COASTING   0x00 
.................... #define  VLV_CLOSING    0x01 
.................... #define  VLV_OPENING    0x02 
.................... #define  VLV_BRAKING    0x03 
....................  
.................... #define  TYPE_NOXDCR    0x01 
.................... #define  TYPE_XDCR      0x02 
....................  
.................... // defines for sys_state variable 
.................... // F009+ 
.................... // 7:4 - major state indicator 
.................... // 3:0 - minor state indicator 
.................... //       .3 = joining_fl (also set if rejoining fails) 
.................... //       .2 = rejoining_fl 
.................... //       .1 = chgenab_fl 
.................... //       .0 = ctrlRPM_fl 
.................... #define INIT_STATE               0x00 
....................    // OR with joining_fl when established 
....................    // always leads to OPEN1_STATE; 
....................    // NEVER accepts packets (NACK), even if joined 
.................... #define LSTATE_INIT              0x00 
....................  
.................... #define OPEN1_STATE              0x10 
....................    // OR with joining_fl when established 
....................    // always leads to PRECHG_STATE; 
....................    // always from INIT_STATE; 
....................    // May process report commands. 
....................    // [Vmmmm:ss OPENING] countup display 
.................... #define LSTATE_OPEN1   0x01 
....................  
.................... #define PRECHG_STATE             0x22 
....................    // OR with joining_fl when established 
....................    // always leads to CLOSE_STATE; may be in and out quickly if no 
....................    //  precharging is necessary; 
....................    // always from OPEN1_STATE; 
....................    // May process report commands.. 
....................    // [Pmmmm:ss        ] countdown display 
.................... #define LSTATE_PRECHG   0x02 
....................  
.................... #define CLOSE1_STATE             0x32 
....................    // OR with joining_fl when established 
....................    // always leads to JOINING_STATE or READY_STATE; 
....................    // always from PRECHG_STATE; 
....................    // May process report commands. 
....................    // [Vmmmm:ss CLOSING] countup display 
.................... #define LSTATE_CLOSE1   0x03 
....................  
.................... #define JOINING_STATE            0x44 
....................    // always leads to READY_STATE 
....................    // always from CLOSE1_STATE 
....................    // Bypassed if warm start 
....................    // Cannot hear commands. 
....................    // [Jmmmm:ss  moteid] display 
.................... #define LSTATE_JOIN     0x04 
....................  
.................... #define REJOINING_STATE          0x48 
....................    // Leads to READY_ if rejoin is successful 
....................    //  or JFAIL_ if rejoin is unsuccessful 
....................    //  or ADDCHG_ if needed. 
....................    // Drops into this state when we are rejoining 
....................    //  AND there is no pending marching order 
....................    //  Preceeding state READY_ or  
....................    //   short-lived READY_ after completion of marching orders. 
....................    // [Rmmmm:ss  moteid] countup display 
....................    // Cannot hear commands. 
....................    // THINK ABOUT THIS 
....................  
.................... #define DISRUPT1_STATE           0x50 
.................... #define LSTATE_DIS1     0x05 
.................... #define DISRUPT2_STATE           0x60 
.................... #define LSTATE_DIS2     0x06 
.................... #define DISRUPT3_STATE           0x70 
.................... #define LSTATE_DIS3     0x07 
....................  
.................... #define READY_STATE              0x80 
....................    // leads to OPENING_STATE or VADJ_STATE 
....................    //  or to DISRUPT STATE; 
....................    // valve is closed in READY_STATE; 
....................    // from CLOSE1_STATE or or CLOSING_STATE 
....................    // Processes all commands 
....................    // ['yy:ddd:hh:mm:ss] display 
.................... #define LSTATE_READY    0x08 
....................  
.................... #define JFAIL_STATE              0x8C 
....................    // Eventually leads to shutdown of sprinkler 
....................    // Indicates cannot join and we have given up AND all marching orders 
....................    //  have completed 
....................    // Drops into this state from REJOINING_STATE 
....................    // Cannot hear commands. 
....................    // ['yy:ddd:hh:mm:ss] display 
.................... #define LSTATE_JFAIL    0x10 
.................... // band-aid 
....................     
.................... #define OPENING_STATE            0x90 
....................    // OR with rejoining_fl (and joining_fl if failure to join) 
....................    // May be brief if at open-valve end-stop; 
....................    // Leads to either BRK_ or RPM_ or ADDCHG_; 
....................    // From BRK_STATE or RPM_STATE or READY_STATE or PAUSE_STATE or REJOINING_ 
....................    // May process report, param and march commands. 
....................    // [Vmmmm:ss OPENING] countup display 
.................... #define LSTATE_OPENING  0x09 
....................  
.................... #define CLOSING_STATE            0xB2 
....................    // OR with rejoining_fl (and joining_fl if failure to join) 
....................    // May be brief if at close-valve end-stop; 
....................    // Leads to either READY_, PAUSE_. 
....................    // From BRK_STATE or RPM_STATE. 
....................    // May process report, param and march commands. 
....................    // [Vmmmm:ss CLOSING] countup display 
.................... #define LSTATE_CLOSING  0x0B 
....................  
.................... #define VADJ_STATE               0xC0 
....................    // OR with rejoining_fl (and joining_fl if failure to join) 
....................    // May be brief if valve DOES NOT NEED adjustment; 
....................    // Leads to either BRK_STATE or RPM_STATE; 
....................    // From BRK_STATE or RPM_STATE or READY_STATE or PAUSE_STATE 
....................    // May process report, param and march commands. 
....................    // [Vmmmm:ss rrr!RRR] countup display shows current rpm ! desired RPM 
.................... #define LSTATE_VADJ     0x0C 
....................  
.................... #define PAUSE_STATE              0xD0 
....................    // OR with rejoining_fl (and joining_fl if failure to join) 
....................    // Leads to READY_ or OPENING_ or VADJ_ 
....................    // From READY_ or CLOSING_ 
....................    //  (CLOSING_ may have followed BRK_ or RPM_) 
....................    // May process report, param and march commands. 
....................    // either [ mmmm:ss  NOFLOW] countup display  
....................    //     or [Xmmmm:ss  NOFLOW] countdown display if pending order  
.................... #define LSTATE_PAUSE    0x0D 
....................  
.................... #define BRK_STATE                0xE0 
....................    // OR with rejoining_fl (and joining_fl if failure to join) 
....................    //  and OR with chgenab_fl 
....................    // Leads to CLOSING_ or OPENING_ or VADJ_ or READY_; 
....................    // From VADJ_ or OPENING_ 
....................    // May process report, param and march commands. 
....................    // either [ mmmm:ss rrrBbbb] countup display (current RPM B brake force) 
....................    //     or [Xmmmm:ss rrrBbbb] countdown display if pending order   
.................... #define LSTATE_BRK      0x0E 
....................  
.................... #define RPM_STATE       0xF1 
....................    // OR with rejoining_fl (and joining_fl if failure to join) 
....................    //  and OR with chgenab_fl 
....................    // leads to CLOSING_ or OPENING_ or VADJ_ or READY_; 
....................    // from VADJ_STATE or OPENING_STATE 
....................    // May process report, param and march commands. 
....................    // either [ mmmm:ss rrr*RRR] countup display (current RPM / desired RPM) 
....................    //     or [Xmmmm:ss rrr*RRR] countdown display if pending order  
.................... #define LSTATE_RPM      0x0F 
....................  
.................... #define JOIN_MASK       0x0C 
.................... // AND with sys_state to extract both fl_joining and fl_rejoining bits 
.................... #define STATE_MASK      0xF3 
.................... // AND with sys_state to clear both fl_joining and fl_rejoining bits 
.................... #define RPM_CH_MASK     0x03 
.................... // AND with sys_state to extract RPM control bit (0) and charging bit (1) 
....................  
....................  
.................... #define FREESPIN_MIN       60 
.................... // If freespin measured at startup is less than FREESPIN_MIN, then  
.................... //  manager will be informed when UNSOLICITED message is sent 
.................... // See above regarding MSG_UNSOLICITED defines. 
....................  
.................... #define START_BRK          600 
....................    // Some intermediate braking at cold start perior to beginning of precharge 
.................... #define IDLE_BRK           200 
....................    // This is the braking force we apply during idling.... mostly important 
....................    //  for debugging purposes 
....................  
....................  
.................... // IFDEF WARNER we are using Eric's valve 
.................... // otherwise we are using Jake's test fixture 
.................... //#IFDEF   WARNER 
.................... //#define VALVE_STOP         990 
.................... //#ELSE 
.................... //#define VALVE_STOP         960 
.................... //#ENDIF 
....................  
.................... #define VCURLIM            900 
.................... // guess during new board debug Feb 18 2016 
....................  
.................... #define VALVE_STOP_W       990 
.................... #define VALVE_STOP_J       960 
....................    // This is the number of ADC counts below which we assume 
....................    //  the valve motor has hit a stop.  NOTE hardware has a .25 ohm  
....................    //  resistor to Vbat 
....................    // This value will depend on valve drive motor characteristics 
....................    //  *J for test bench; *W for Warner valve 
.................... */ 
.................... //************************************************************************** 
.................... /*    
....................    Experimentation with prototype valves during March/April 2015 brought up 
....................    problems with valve becoming STUCK at an endstop. 
....................    Solutions include:  
....................       1. DO NOT CHECK for excessive current during first few 
....................       nudges when COMING off an endstop 
....................       2. Once valve is moving along (past the initial nudge which overcomes 
....................       inertia) we can check for excessive current sooner in the nudge cycle 
....................    Care must be taken to accomodate various situations which could interfere 
....................       with this approach, such as when nudging is interrupted by the need to 
....................       acknowledge activity at the mote.    
....................   
....................   VALVE_CHKDEL0 is the time in ms to wait after the drive motor is 
....................   turned on before checking if we have excessive current as part of the 
....................   very first nudge which specifically overcomes the startup current 
....................   transient due to inertia 
....................  
....................  VALVE_CHKDEL0 will be dependent upon whether we are using the "WARNER" 
....................   valves or the in-house test fixture   
....................   
....................  VALVE_CHKDEL1 is the normal time in ms to wait after the drive motor is 
....................   turned on before checking if we have excessive current.  The assumption 
....................   for the choice of this value is that we have already overcome the startup 
....................   current transient due to inertia 
....................  
....................  VALVE_CHKNO is the number of nudges during which we DO NOT check for 
....................   excessive current in the case where the valve is specially coming off 
....................   of either the closed or open end stop 
....................  
....................  
....................  Flags specify the situation at hand: 
....................  atstop_fl     TRUE if we are currently at an endstop, this flag 
....................                ensures that the algorithm utilizes VALVE_CHKNO 
....................                 
....................  firstnudge_fl TRUE if we are starting the valve from rest and we are NOT 
....................                at an endstop; ensures that the algorithm utilizes VALVE_CHKDEL1 
....................                 
.................... EXCEPTION and possible issue in the future is the first nudge after  
.................... system startup.  We may or MAY NOT be at an endstop.  So we assume a 
.................... atstop_fl = TRUE.   
....................  
.................... If we are actually FULL OPEN, and get stuck (!) we can 
.................... detect this because the number of steps during initial open will be too few 
.................... (less than 2 or 3) and then we can try again with the atstop_fl set. 
....................  
.................... If we are actually at FULL CLOSED, and get stuck, again the first opening will 
.................... be too few steps and we must then try again with the atstop_fl set..... 
....................  
.................... Thus if after the startup dance, either close_time or open_time are  
.................... "unreasonable", we must simply do it again (although perhaps we could skip 
.................... the precharge if we have a good free-spin value).  This will be optimized 
.................... in a later version of the firmware.  
....................  
.................... condx                      atstop_fl      firstnudge_fl 
.................... ---------------------------------------------------- 
.................... 1st nudge after startup    TRUE           TRUE 
.................... (valve position unknown) 
.................... 1st nudge from endstop     TRUE           FALSE 
.................... 1st nudge norm             FALSE          TRUE 
.................... (or immediately after motion is interrupted by activity from mote) 
.................... subsequence nudges         FALSE          FALSE 
.................... */ 
.................... //*************************************************************************** 
....................  
.................... /* 
....................  
.................... //#define  VALVE_CHKNO       3 
.................... #define VALVE_NOCHK_W     3 
.................... #define VALVE_NOCHK_J     1 
....................  
.................... //#IFDEF   WARNER 
.................... //#define VALVE_ONTIME       150 
.................... //#define VALVE_CHKDEL0      100 
.................... //#ELSE 
.................... //#define VALVE_ONTIME       100 
.................... //#define VALVE_CHKDEL0      50 
.................... //#ENDIF 
....................  
.................... // These values are in milliseconds 
.................... #define VALVE_ONTIME_W     150 
.................... #define VALVE_CHK0_W       100 
.................... #define VALVE_ONTIME_J     100 
.................... #define VALVE_CHK0_J       50 
....................  
.................... // assume 16 bit counter triggered by FOSC div 64 (timer 0 prescaler) 
.................... // Thus one count every 64*T0_OSC nanoseconds 
.................... // Setup timer 0 for div64 and load with the value below for it to time out                         
....................  
.................... #define VALVE_TMR0SET0_W     (65536 - (1000000*(VALVE_ONTIME_W - VALVE_CHK0_W)+32*T0_OSC)/(64*T0_OSC)) 
.................... #define VALVE_TMR0SET0_J     (65536 - (1000000*(VALVE_ONTIME_J - VALVE_CHK0_J)+32*T0_OSC)/(64*T0_OSC)) 
.................... // THUS: if we delay CHK_DEL0 milliseconds, and then set a timer to timeout 
.................... //  according to VALVE_TMR0SET0, we have taken up a full CHUNK's worth of time 
....................  
.................... // once valve is in motion, only wait 20 msec before testing for endstop! 
.................... //  This is arbitrary and conservative. 
.................... #define VALVE_CHKDEL1      20 
.................... #define VALVE_TMR0SET1_W   (65536 - (1000000*(VALVE_ONTIME_W - VALVE_CHKDEL1)+32*T0_OSC)/(64*T0_OSC)) 
.................... #define VALVE_TMR0SET1_J   (65536 - (1000000*(VALVE_ONTIME_J - VALVE_CHKDEL1)+32*T0_OSC)/(64*T0_OSC)) 
.................... // THUS: if we delay CHK_DEL1 milliseconds, and then set a timer to timeout 
.................... //  according to VALVE_TMR0SET1, we have taken up a full CHUNK's worth of time 
....................  
....................    // VALVE_ONTIME is the number of milliseconds that the motor runs between 
....................    //  activity on mote checks 
....................    // VALVE_CHKDEL0 is the number of milliseconds we wait when motor is 
....................    //  first turned on to check for an endstop.  This accounts for the 
....................    //  inertial transient at first turn-on. 
....................     
.................... #define VALVE_ATSTOPDEL    50 
....................  
....................  
.................... #define VALVE_TIM0         (VALVE_ONTIME-VALVE_CHKDEL0) 
.................... // Set TMR0 to overflow after this number of millisecondes 
.................... //  Note that each tick of TMR0 during the move_valve routine is 
.................... //  32/19200 or 1.666 msec or 1667 microseconds 
.................... //  This convenient number is represented by the fraction 3/5 in the  
.................... //   define below 
.................... #define VALVE_TMR0SET0     256 - ((VALVE_TIM0*3)/5)  
.................... // THUS: if we delay CHK_DEL0 milliseconds, and then set a timer to timeout 
.................... //  according to VALVE_TMR0SET0, we have taken up a full CHUNK's worth of time 
....................   
....................  
....................  
....................  
.................... //#IFDEF   WARNER 
.................... //#define VCTR_LIMIT         200 
.................... //#ELSE 
.................... //#define VCTR_LIMIT         175 
.................... //#ENDIF 
....................  
.................... #define VALVE_CTRLIM_W       200 
.................... #define VALVE_CTRLIM_J       175 
.................... // little motions of valve motor should definitely get it to a stop 
.................... //  or to its destination;  if not we time out.  This number is somewhat 
.................... //  arbitrary 
....................  
.................... #define VCLASS2_LIM        38      
.................... // relative to 0 (full close) and 255 (full open) at what limit for  
.................... //  valve desired do we force bouncing off the nearest enstop? 
.................... // 15% would be 38 
.................... #define BOUNCE_OPEN        256-VCLASS2_LIM 
.................... #define BOUNCE_CLOSE       VCLASS2_LIM 
.................... #define V_ENDCTR_LIM       5 
.................... // force an endstop at least every 5 excursions 
....................  
....................  
.................... //#IFDEF   WARNER 
.................... //#define V_SINCEEND_LIM     400  
.................... //#ELSE 
.................... //#define V_SINCEEND_LIM     350 
.................... //#ENDIF 
.................... // force an endstop if cumulative motion has exceeded about 2 full paths 
.................... //  from open to closed 
.................... #define VALVE_SINCELIM_W   400 
.................... #define VALVE_SINCELIM_J   350 
....................  
....................  
.................... #define VFULL_TIM_LIM      7200 
.................... // if this number of seconds has passed since the full open2close or the 
.................... //  full close2open time has been remeasured, then force it. 
....................  
.................... // defines for vset_class variable 
.................... #define BOUNCE0_CL         0x01 
.................... #define BOUNCE0_OP         0x81 
.................... #define BOUNCE1_CL         0x02 
.................... #define BOUNCE1_OP         0x82 
.................... #define BOUNCE2_CL         0x03 
.................... #define BOUNCE2_OP         0x83 
.................... #define BOUNCE3_CL         0x04 
.................... #define BOUNCE3_OP         0x84 
....................  
.................... #define VTOOSHORT          60 
.................... // This is the minimum number of nudges for open to close or close to open 
.................... //  which is acceptable during startup dance.  If not VTOOSHORT, then 
.................... //  no problem is reported during first message after join 
.................... #define FREESPIN_LIM       120 
.................... // This is the minimum RPM which is 'acceptable' for free spin result! 
.................... // If not too slow, then no problem is reported during 
.................... //  first message after join 
....................  
.................... // EEPROM LOCATIONS 
.................... #define EE_ADDCHG_DUR      0x0002 
....................    // Configures add-charging time in seconds 
....................    // 2 bytes, low byte at 0x0002 
.................... #define ADDCHG_DUR_DEF     4 
....................    // 4 minutes? 
.................... #define EE_PRECHG_DUR      0x0004 
....................    // Configures precharging time in seconds 
....................    // 2 bytes, low byte at 0x0004 
.................... #define PRECHG_DUR_DEF     10 
....................    // 1.5 minutes?  
.................... #define CHGLOOPS_PER_MIN   110 
....................    // determined experimentally, each loop is about 545 msec 
....................    //  which is a bit longer than I would prefer (!), but oh well. 
....................    //  JG 2015 Jun16 
....................     
.................... // 0x00A thru 0x00F        reserved 
.................... #define EE_NETW_ID         0x0010 
....................    // 2 bytes, low byte at 0x0010; for now, network ID defaults to 0x04CD. 
.................... #define EE_PRENETW_ID      0x0012 
....................    // 2 bytes, low byte at 0x0012; for now, network ID defaults to 0x04CD. 
....................  
....................  
.................... // 0013 reserved 
.................... #define EE_LOCATION     0x0014 
....................    // 2 bytes, low byte at 0x0014; associates sprinkler with particular 
....................    //  physical location on CP 
.................... #define EE_PRELOCATION  0x0016 
....................    // 2 bytes, low byte at 0x0016, previous association of sprinkler with 
....................    //  particular physical location on CP 
....................  
....................    // 0x018 thru 0x01F     reserved 
....................  
.................... // IDLE behavior specified at 0x0020 thru 0x0033 
.................... #define EE_IDLE_OPT        0x0020 
....................    // Configures IDLE behavior.  Applies if battery low during operational 
....................    //  state 
....................    //  0x00  send out Panic Message once when panic level is reached according 
....................    //         to voltage-based algorithm 
....................    //  0x01  send out Panic Message once when panic level is reached according 
....................    //         to charge-based algorithm 
.................... #define MAX_IDLE_OPT       1 
....................    // If manager tries to write any idle_opt value larger than this to EEPROM 
....................    //  a NACK occurs; see above for idle option choices 
.................... #define LEN_IDLE_BLOCK     15 
....................    // There are 15 bytes in the idle block 
....................  
.................... #define EE_IDLE_PROFILE    0x0021 
....................    // Saved only upon entering IDLE state; 
....................    //  profile number which was running or had last been run. 
....................    // 0 for default profile, 1, 2, 3 for controller-specified profile choices 
....................    //  other numbers, use 0 
.................... #define EE_IDLE_STEP       0x0022 
....................    // Saved only upon entering IDLE state; 
....................    //  step number of profile which was running or had last been run. 
....................    //  Step 0xFF indicates that we were not within a profile 
....................    //  Step 0x10 thru 0xFE invalid. 
.................... #define EE_IDLE_STIME      0x0023 
....................    // 2 bytes, low byte at 0x0023, high byte at 0x0024 
....................    // Saved only upon entering IDLE state; 
....................    //  amount of time in seconds that rate was controlled according 
....................    //  to EE_IDLE_STEP at time when IDLE state entered; 
....................    //  set to 0x0000 if EE_IDLE_STEP=0xFF. 
.................... #define EE_IDLE_LOOP       0x0025 
....................    // 2 bytes, low byte at 0x0025, high byte at 0x0026 
....................    // Saved only upon entering IDLE state; 
....................    //  for looping profiles, loop number at time when IDLE state entered; 
....................    //  set to 0x0000 for non-looping profiles, set to 
....................    //  0x0000 if EE_IDLE_STEP=0xFF. (looping beyond 0xFFFF is recorded as 
....................    //  0xFFFF) 
.................... #define EE_IDLE_CHG        0x0027 
....................    // 2 bytes, low byte at 0x0027, high byte at 0x0028 
....................    // Configures used charge in millicoulombs for 
....................    //  charge-based shutdown method (TBD); applies if EE_IDLE.1 is set 
.................... #define EE_IDLE_SHDN_DLY   0x0029 
....................    // 2 bytes, low byte at 0x0029, high byte at 0x002A 
....................    // Configures time in units of 67 secs (TMR0 ints during IDLE) 
....................    //  between sensing of low battery and self-shutdown 
....................  
....................  
.................... // 0x02F thru 0x033        reserved 
....................  
.................... // PROFILE behavior specified at 0x0034 thru 0x003E 
.................... #define EE_PROFILE_OPT     0x0034 
....................    // Configures PROFILE behavior. 
....................    //  0x00 start profile0 (0x0050-0x007F) from the beginning 
....................    //  0x01 start profile1 (0x0090-0x00BF) from the beginning 
....................    //  0x02 start profile2 (0x00D0-0x00FF) from the beginning 
....................    //  0x03 start profile3 (0x0110-0x013F) from the beginning 
....................    //  0x04 start last used profile (EE_IDLE_PROFILE) from the beginning 
....................    //  0x05 start last used profile (EE_IDLE_PROFILE) from where it stopped 
.................... #define MAX_PROFILE_OPT    0x05 
....................    // profile option value cannot exceed this value 
....................  
....................  
.................... #define EE_SHUT_DEL        0x003E 
....................    // 2 bytes, low byte at 0x003E, high byte at 0x003F 
....................    // number of seconds between MSG_FORCE_COLD_DEL or MSG_SHUTDOWNx_DEL 
....................    //  and actual restart or shutdown 
....................    // For broadcast messages, ensures that all of the motes get the 
....................    //  message before they 'go away' 
....................  
.................... // GENERAL behavior specified at 0x0040 thru 0x004F 
.................... #define EE_GENERAL_OPT     0x0040 
....................    // Configures GENERAL behavior. 
....................    //  0x00 normal operation 
....................    //  0x01 test mode A (debug) 
....................    //  0x02 test mode B (time messages to DUST controller) 
....................    //  0x03 test mode C (debug and time messages) 
.................... #define MAX_GENERAL_OPT    0x03 
....................    // general option value cannot exceed this value 
....................  
.................... // 0x041 thru 0x04F        reserved 
....................  
.................... #define EE_REINFO          0x0050 
....................    // hold last known restart_cause 
....................  
.................... // 0x051 thru 0x05F        reserved 
....................  
.................... #define EE_DEADPROFILE     0x0060 
....................    // If death occurs during profiling, place profile number here (0,1,2,3) 
....................    //  else set to 0xFF 
.................... #define EE_DEADSTEP        0x0061 
....................    // Set to profile step number during which death occurred. 
.................... #define EE_DEADTIME        0x0062 
....................    // 2 bytes indicates how far along we were into the profile step when 
....................    //  dead battery was detected. 
.................... #define EE_DEADSTATE       0x0064 
....................    // system state during which dead battery was detected 
....................  
.................... // 0x065 thru 0x07F        reserved 
....................  
.................... #define EE_ERRORID         0x0080 
....................    // 2 bytes, low byte is the error_id and 
....................    //  high byte is errors1 -- saves last reason for a deep event error 
....................  
.................... #define EE_VSET_CLASS      0x0082 
.................... #define EE_V_ENDCTR        0x0083 
.................... #define EE_V_SINCEEND      0x0084 
.................... #define EE_O_C             0x0086 
.................... #define EE_C_O             0x0088 
....................  
.................... #define EE_RESTART_INFO    0x00A0 
.................... // 0x090 thru 0x0EF        reserved 
....................  
.................... #define EE_PROFILE0        0x00F0 
....................    // This is address of first byte of profile0 (default). 
....................    // May extend to 0x011F. 
....................    // 3 bytes per step, 16 steps.  Each step has 1 byte for RPM and 2 bytes 
....................    //  for duration in seconds.  If duration = 0x0000, then this means 
....................    //  "forever." 
....................    //  If 0x00 <= RPM <= RPM_MIN, then interpret RPM as RPM_MIN. 
....................    //  If RPM_MAX <= RPM <= 0xFF, then interpret RPM as RPM_MAX. 
....................    //  thus RPM = 0x00 and duration = 0xFFFF means single step rpm_min speed forever. 
....................    //  All bytes following duration = 0xFFFF in a profile are ignored. 
....................    //   RPM = 0xFF and duration = 0xFFFF is the end of profile marker for 
....................    //   "repeating" profiles".  0xFF / 0xFFFF cannot be the first step. 
....................    //  for steps preceeding duration = 0xFFFF, duration cannot = 0x0000! 
....................    //  Note that default profile is loaded into EEPROM by firmware 
....................    //   at start if none is present.  Controller can read or write 
....................    //   profiles. 
....................  
.................... // 0x120 thru 0x1EF        reserved 
....................  
.................... #define EE_VDD             0x1F0 
....................    // Two bytes; ADC-based estimate of Vdd (4.12 fixed pt format) 
.................... #define EE_VBATT           0x1F2 
....................    // Two bytes, ADC-based estimate of Vbatt 
.................... #define EE_VGEN            0x1F4 
....................    // Two bytes, ADC-based estimate of Vgen 
.................... #define EE_VSOLAR          0x1F6 
....................    // Two bytes, ADC-based estimate of Vsol 
....................  
....................  
.................... // SCRATCHPAD EEPROM 
....................  
.................... #define EE_DEBUG_1st       0x0200 
.................... #define EE_DEBUG_LAST      0x03F0 
....................  
.................... #define EE_FREE_1st        0x0200 
.................... #define EE_FREE_LAST       0x03BF      // free space never cleared 
.................... #define EE_SCRATCH_1ST     0x03F0 
.................... #define EE_SCRATCH_LAST    0x03F8      // scratch space cleared at start 
....................                                        //  (warm, cold, or xcold) 
....................    // This is the start and end of scrathpad memory in EEPROM.  To be used for 
....................    //  for debug purposes or TBD. 
....................  
.................... #define EE_BOOT_RECORD     0x0200      // new events and time 
.................... #define EE_NETID_TIME      0x0208 
.................... #define EE_MOTEOPER_TIME   0x020C 
.................... #define EE_MOTEIDLE_TIME   0x0210 
.................... #define EE_MSG_RECORD_0    0x0220 
.................... #define EE_MSG_RECORD_END  0x03BF 
....................  
.................... #define EE_SYS_STATE       0x03C0 
....................    // Address of state flags (echoes read only status) 
....................    // Written to EEPROM at significant state transitions 
.................... #define EE_INT_CTR         0x03E8 
....................    // Address of error/alarm flags (as many as 16 bytes) 
....................    // Written to EEPROM at significant state transitions 
.................... #define EE_CUR_PROFILE     0x03F0 
.................... #define EE_MSGBYTES_DBG    0x03F8 
.................... #define EE_PORTB_BIT       0x03F9 
.................... #define EE_PORTB_DIR       0x03FA 
....................  
....................  
....................     
....................  
....................    // for debug only 
....................  
.................... #define DUTYCYCLE_SET      0x40 
.................... // set join duty cycle for mote to this value at startup; approx 15% 
.................... #define SPECIALNV1_00      0x0000 
....................    // for rapid join time during debug, use with pkgen_setnv_special1(**) 
.................... #define SPECIALNV2_00      0x0005 
....................    // for rapid join time during debug, use with pkgen_setnv_special2(**) 
....................    // RAPID: 5 seconds to 0 seconds is a timing range having to do with 
....................    //  looking for advertisements during join 
....................    // NORMAL: 90 to 60 seconds..... 
.................... #define SPECIALNV1_01      0x003C 
....................    // for normal join time during debug, use with pkgen_setnv_special1(**) 
.................... #define SPECIALNV2_01      0x005A 
....................    // for normal join time during debug, use with pkgen_setnv_special2(**) 
....................  
.................... */ 
....................  
....................  
....................       /* signed int properties */ 
.................... #define INT_MAX 32767         /* signed integer minimum*/ 
.................... #define INT_MIN (-32768)      /*signed integer maximum*/ 
....................  
....................       /* signed long properties */ 
.................... #define LONG_MAX 2147483647        /* signed long maximum*/ 
.................... #define LONG_MIN (-2147483648) /* signed long minimum*/ 
....................  
.................... /* 
....................  
.................... // BELOW are constants and defines used in battery check routines 
....................  
.................... #define FVR_NOEE        2455 
.................... // approx 2V, any lower, don't attempt to run the micro or write to EE 
.................... //    fl_bat_NOEE 
.................... //    (BOX_CHAR here and below) 
....................  
.................... #define FVR_NODUST      2332 
.................... // 2.2 V; any lower, don't use the dust module; fl_batNODUST 
.................... //    ('D' here down to FVR_NOEE) 
....................  
.................... #define FVR_TEST        1819        
.................... // 2.7V threshold for testing purposes, display still visible 
....................  
.................... #define FVR_DEAD        1638 
.................... // 3.0V; dead battery, any lower, do not move valve; fl_batDEAD 
.................... //    ('d' here down to FVR_NODUST) 
....................  
.................... #define FVR_WEAK        1534 
.................... // 3.2V; below this point, battery dangerously weak  
.................... //  but can add charge, shout out; fl_batSHOUT, fl_addchg  
.................... //    ('-' here down to FVR_DEAD)) 
....................  
.................... #define FVR_ADDCHG      1511 
.................... // 3.25V; battery weak... below this point add charge, shout out 
.................... //    (! here down to FVR_WEAK); fl_batSHOUT, fl_addchg 
.................... // above this point, battery OK; fl_batOK 
.................... //    ('+' here up to FVR_ADEQUATE) 
....................  
.................... #define FVR_ADEQUATE    1488 
.................... // 3.30V; adequately charged if at or above this point; fl_batOK  
.................... //    ('f' here up to FVR_FULL) 
....................  
.................... #define FVR_FULL        1444 
.................... // 3.40V; battery full at or above this point; fl_batFULL 
.................... //    ('F' here up to FVR_TOOFULL) 
....................  
.................... #define FVR_TOOFULL     1327 
.................... // >=3.7 do not precharge, error condition?; fl_batTOOFULL 
.................... //    (TOPLINE_CHAR here and above) 
....................  
.................... // QCHK_FULL value is compared to 4x 1.2Vref as measured when sprinkler 
.................... //  is running and battery may be charging  (VfvrCAD) 
.................... // If the battery voltage measured during qchk_batt 
.................... //  is such that VfvrCAD < QCHK_FUL [indicates battery fully charged] 
.................... //  then charging will stop, hopefully in a smooth and controlled manner 
.................... //  before the charger hardware cannot charge due to its configuration. 
.................... // After this occurs, charging will not take place until the next marching 
.................... //  order, at which point a chk_batt happens and a different criterion applies. 
.................... // Note that qchk_batt() measures during running and charging! 
.................... // The flag fl_qbatFULL is set and not cleared until the next marching order 
.................... //  is processed. 
.................... #define QCHK_FULL       1391 
.................... // 1023/1391 * 4.8V = 3.53V 
.................... // charging never enabled (fl_qbatFULL set) when VfvrCAD < QCHK_FULL 
.................... //    (chargemark set to TOPLINE_CHAR whenever fl_qbatFULL is set) 
.................... //    (chargemark set to 'c' if !fl_qbatFULL and significant difference 
.................... //     between generator voltage while charging as compared to not charing) 
....................  
.................... #define BATT_HYST       12 
.................... // If the difference between the battery voltage at the start of a new 
.................... //  marching order as compared to the VfvrAD which was measured when 
.................... //  a bat full situation was last determined is greater than this amount, 
.................... //  then we turn charging back on; in other words, if the battery voltage 
.................... //  has dropped during the previous marching order to a great enough extent 
.................... //  AFTER we had already determined that the battery was full, then we turn 
.................... //  charging back on (Rev 030+) 
.................... // Approx a 30mV drop [somewhat arbitrary, but provides a form of hysteresis] 
....................  
.................... #define TM_BATCHK       7200 
....................    // number of seconds maximum between chk_batt() calls; 
....................  
....................  
.................... #define TM_SPINRPT      0xA1 
....................    // arbitrary 8 bit number which, when compared to low byte of seconds ctr 
....................    //  initiates the possible reporting of a spin error (should be greater than 
....................    //  32 seconds because that is the amount of time it takes for the variance 
....................    //  determination to take place (sizeof periods[]) 
....................    // Possible error states include: NOSPIN_ERRCODE, SPEEDLO_ERRCODE, 
....................    //  SPEEDHI_ERRCODE, SPEEDREG_ERRCODE 
....................    // NOSPIN: manager has told us that water is flowing, but 
....................    //  speed is too slow to detect (<~3RPM) 
....................    // SPEEDLO/SPEEDHI: average speed over previous 64 measurements is beyond 
....................    //  limit established (e.g., +/-3%) 
....................    // SPEEDREG: max speed (or min speed) over previous 64 measurements 
....................    //  exceeds limit establihsed (e.g. target+/-6%) 
....................    // In this code, spin checks occur once every 256 seconds, or whenever 
....................    //  requested by the manager (MSG_STATUS_RDONLY). 
....................    // If a problem is detected, an error message immediately goes out one time. 
....................    //  THUS spin errors will be sent at least every 256 seconds 
....................    //  (change later?) 
....................  
.................... #define ONE_WEEK     2235 
....................    // number of 4.51 minute intervals in a week (for DEAD BATT HANDLER) 
....................  
.................... #define DEAD_BATTERY    0xFF 
....................    // indicates that restart event was due to dead battery detection 
....................  
.................... #define GET_A_CHAR(value)   { TMR1L = 0x78;  \ 
....................                               TMR1IF = FALSE;  \ 
....................                               output_low(_DUST_SPCTS);  \ 
....................                               while (!(kbhit() || TMR1IF));  \ 
....................                               errors1 |= RCSTA; \ 
....................                               dust_recive_buffer[value] = RCREG; \ 
....................                               output_high(_DUST_SPCTS); \ 
....................                             } 
.................... #define GET_1_CHAR      { set_timer1(0); \ 
....................                           output_low(_DUST_SPCTS);  \ 
....................                           while (!kbhit() && bit_test(TMR1H,7));  \                          
....................                           *mm = RCREG; \ 
....................                           output_high(_DUST_SPCTS); \  
....................                           mm++; \ 
....................                         } 
....................                          
.................... #define GET_blah_CHAR      { output_low(_DUST_SPCTS);  \ 
....................                           while (!kbhit());  \                          
....................                           *mm = RCREG; \ 
....................                           output_high(_DUST_SPCTS); \  
....................                           mm++; \ 
....................                         } 
....................  
.................... #define GET_32CHARS  {  GET_A_CHAR(0) \ 
....................                         GET_A_CHAR(1) \ 
....................                         GET_A_CHAR(2) \ 
....................                         GET_A_CHAR(3) \ 
....................                         GET_A_CHAR(4) \ 
....................                         GET_A_CHAR(5) \ 
....................                         GET_A_CHAR(6) \ 
....................                         GET_A_CHAR(7) \ 
....................                         GET_A_CHAR(8) \ 
....................                         GET_A_CHAR(9) \ 
....................                         GET_A_CHAR(10) \ 
....................                         GET_A_CHAR(11) \ 
....................                         GET_A_CHAR(12) \ 
....................                         GET_A_CHAR(13) \ 
....................                         GET_A_CHAR(14) \ 
....................                         GET_A_CHAR(15) \ 
....................                         GET_A_CHAR(16) \ 
....................                         GET_A_CHAR(17) \ 
....................                         GET_A_CHAR(18) \ 
....................                         GET_A_CHAR(19) \ 
....................                         GET_A_CHAR(20) \ 
....................                         GET_A_CHAR(21) \ 
....................                         GET_A_CHAR(22) \ 
....................                         GET_A_CHAR(23) \ 
....................                         GET_A_CHAR(24) \ 
....................                         GET_A_CHAR(25) \ 
....................                         GET_A_CHAR(26) \ 
....................                         GET_A_CHAR(27) \ 
....................                         GET_A_CHAR(28) \ 
....................                         GET_A_CHAR(29) \ 
....................                         GET_A_CHAR(30) \ 
....................                         GET_A_CHAR(31) } 
....................                          
.................... #define GET_REST_OF_CHARS  {  GET_1_CHAR \ 
....................                               GET_1_CHAR \ 
....................                               GET_1_CHAR \ 
....................                               GET_1_CHAR \ 
....................                               GET_1_CHAR \ 
....................                               GET_1_CHAR \ 
....................                               GET_1_CHAR \ 
....................                               GET_1_CHAR \ 
....................                               GET_1_CHAR \ 
....................                               GET_1_CHAR \ 
....................                               GET_1_CHAR \ 
....................                               GET_1_CHAR \ 
....................                               GET_1_CHAR \ 
....................                               GET_1_CHAR \ 
....................                               GET_1_CHAR \ 
....................                               GET_1_CHAR \ 
....................                               GET_1_CHAR \ 
....................                               GET_1_CHAR \ 
....................                               GET_1_CHAR \ 
....................                               GET_1_CHAR \ 
....................                               GET_1_CHAR \ 
....................                               GET_1_CHAR \ 
....................                               GET_1_CHAR \ 
....................                               GET_1_CHAR \ 
....................                               GET_1_CHAR \ 
....................                               GET_1_CHAR \ 
....................                               GET_1_CHAR \ 
....................                               GET_1_CHAR \ 
....................                               GET_1_CHAR \ 
....................                               GET_1_CHAR \ 
....................                               GET_1_CHAR \ } 
....................  
....................  
.................... // see MOTETIME.xlsx 
.................... // 1/1/2013 midnight .... 1/1/2062 midnight 
.................... UNSIGNED INT32 CONST YRLUKUP [50] = { 
....................    0x50E22700,0x52C35A80,0x54A48E00,0x5685C180,0x58684680, 
....................    0x5A497A00,0x5C2AAD80,0x5E0BE100,0x5FEE6600,0x61CF9980, 
....................    0x63B0CD00,0x65920080,0x67748580,0x6955B900,0x6B36EC80, 
....................    0x6D182000,0x6EFAA500,0x70DBD880,0x72BD0C00,0x749E3F80, 
....................    0x7680C480,0x7861F800,0x7A432B80,0x7C245F00,0x7E06E400, 
....................    0x7FE81780,0x81C94B00,0x83AA7E80,0x858D0380,0x876E3700, 
....................    0x894F6A80,0x8B309E00,0x8D132300,0x8EF45680,0x90D58A00, 
....................    0x92B6BD80,0x94994280,0x967A7600,0x985BA980,0x9A3CDD00, 
....................    0x9C1F6200,0x9E009580,0x9FE1C900,0xA1C2FC80,0xA3A58180, 
....................    0xA586B500,0xA767E880,0xA9491C00,0xAB2BA100,0xAD0CD480}; 
....................     
....................  
.................... UNSIGNED INT8 CONST BYTE_2_PCT [256] = { 
....................     0, 0, 1, 1, 2, 2, 2, 3, 3, 4, 4, 4, 5, 5, 5, 6,  
....................     6, 7, 7, 7, 8, 8, 9, 9, 9,10,10,11,11,11,12,12, 
....................    13,13,13,14,14,15,15,15,16,16,16,17,17,18,18,18, 
....................    19,19,20,20,20,21,21,22,22,22,23,23,24,24,24,25, 
....................    25,25,26,26,27,27,27,28,28,29,29,29,30,30,31,31, 
....................    31,32,32,33,33,33,34,34,35,35,35,36,36,36,37,37, 
....................    38,38,38,39,39,40,40,40,41,41,42,42,42,43,43,44, 
....................    44,44,45,45,45,46,46,47,47,47,48,48,49,49,49,50, 
....................    50,51,51,51,52,52,53,53,53,54,54,55,55,55,56,56, 
....................    56,57,57,58,58,58,59,59,60,60,60,61,61,62,62,62, 
....................    63,63,64,64,64,65,65,65,66,66,67,67,67,68,68,69, 
....................    69,69,70,70,71,71,71,72,72,73,73,73,74,74,75,75, 
....................    75,76,76,76,77,77,78,78,78,79,79,80,80,80,81,81, 
....................    82,82,82,83,83,84,84,84,85,85,85,86,86,87,87,87, 
....................    88,88,89,89,89,90,90,91,91,91,92,92,93,93,93,94, 
....................    94,95,95,95,96,96,96,97,97,98,98,98,99,99,100,100 }; 
....................     
.................... UNSIGNED INT8 CONST BYTE99_2_10S [100] = { 
....................    '0', '0', '0', '0', '0', '0', '0', '0', '0', '0',  
....................    '1', '1', '1', '1', '1', '1', '1', '1', '1', '1',  
....................    '2', '2', '2', '2', '2', '2', '2', '2', '2', '2',  
....................    '3', '3', '3', '3', '3', '3', '3', '3', '3', '3',  
....................    '4', '4', '4', '4', '4', '4', '4', '4', '4', '4',  
....................    '5', '5', '5', '5', '5', '5', '5', '5', '5', '5',  
....................    '6', '6', '6', '6', '6', '6', '6', '6', '6', '6',  
....................    '7', '7', '7', '7', '7', '7', '7', '7', '7', '7',  
....................    '8', '8', '8', '8', '8', '8', '8', '8', '8', '8',  
....................    '9', '9', '9', '9', '9', '9', '9', '9', '9', '9' }; 
....................  
.................... UNSIGNED INT8 CONST BYTE99_2_1S [100] = { 
....................    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 
....................    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 
....................    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 
....................    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 
....................    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 
....................    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 
....................    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 
....................    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 
....................    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 
....................    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9' }; 
....................     
.................... */ 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... #include "defines.h" 
.................... // defines.h                                                                
.................... // 
.................... // contains all non-pic (and non-dn2500.h) related defines and macros 
....................  
.................... ////////////////////Defines Table of Contents////////////////////////////////// 
.................... //Version 
.................... //Priority Queue 
.................... //Time Queue 
.................... //Command Stack 
.................... //Sprinkler Stack 
.................... //Gen RPM                               
.................... //Control Algorithm 
.................... //Valve                
.................... //XDCR           
.................... //RB ISR         
.................... //I2C Addresses  
.................... //LCD         
.................... //DUST    
.................... //Errors   
....................              
.................... ////////////////////Version//////////////////////////////////////////////////// 
.................... #define FIRMWARE_VERSION 0xE313           
....................  
....................                             
.................... // Defines designed to simplify debugging and program development process         
.................... #DEFINE DISABLE_NO_SPIN_RECOVERY          1 
.................... #DEFINE DISABLE_MAG_DECOUPLING_RECOVERY   1               
.................... #DEFINE DISABLE_RECAL_VLV                 1 
.................... #DEFINE ALLOW_VALVE_SET_WITH_STALE_CAL    1 
.................... #DEFINE OPEN_VALVE_TO_SETPT_AT_BOOT       1 
....................                                     
.................... ////////////////////Priority Queue///////////////////////////////////////////// 
.................... // Maximum number of items in priority queue. Each item is 1 byte and in RAM 
.................... // Actual number of items is max - 1 as item 0 is reserved for sorting use 
.................... #define MAX_PRIORITY_QUEUE_ITEMS   20 
....................  
.................... // Priority Queue items (identified by their priority) (1-255) 
.................... // lower number is higher priority 
.................... #define EMPTY_PRIORITY_QUEUE           0x00 
....................  
.................... #define WAIT_FOR_BOOT_EVENT            0x10 
.................... #define RESET_MOTE                     0x11 
....................  
.................... #define DEAL_WITH_NEW_PACKET           0x20 
....................  
.................... #define VALVE_MOVE_ERROR               0x30 
.................... #define CALIBRATE_VALVE_1              0x31 
.................... #define CALIBRATE_VALVE_2              0x32                   
.................... #define CALIBRATE_VALVE_3              0x33 
.................... #define CALIBRATE_VALVE_4              0x34 
.................... #define CALIBRATE_VALVE_5              0x35 
.................... #define CALIBRATE_VALVE_6              0x36 
.................... #define CALIBRATE_FSR_1                0x37 
.................... #define CALIBRATE_FSR_2                0x38            
.................... #define CALIBRATE_FSR_3                0x39 
.................... #define CALIBRATE_FSR_4                0X3A 
.................... #define MOVE_VALVE_MAG_DECOUPLING_RECOVERY 0x3C              
.................... #define MOVE_VALVE_NO_SPIN_RECOVERY        0x3D  
.................... #define OPEN_VALVE_UNKNOWN_STATE       0x3E 
.................... #define CLOSE_VALVE_UNKNOWN_STATE      0x3F 
.................... #define MOVE_VALVE                     0x40 
.................... #define MOVE_VALVE_AT_BOOT             0x41 
....................  
.................... #define START_GPS_AQUISITION           0x50 
.................... #define CHECK_GPS_FOR_LOCK             0x51  
.................... #define TAKE_XCDR_MESUREMENT_1         0x55 
.................... #define TAKE_XCDR_MESUREMENT_2         0x56   
.................... #define OPTIMIZE_MPPC                  0xA0 
....................  
.................... #define CHECK_BATTERY_STATE            0xA1 
.................... #define CHECK_MOTE_TEMP                0xA2 
.................... #define UPDATE_MOTE_TIME               0xA3 
.................... #define UPDATE_MOTE_NETWORK_INFO       0xA4 
.................... // below added by JG 2017 Feb13 
.................... #define SEND_UNSOLICITED_FULL_REPORT   0xA5 
....................  
.................... #define SEARCH_FOR_STRONGEST_1         0xB1 
.................... #define SEARCH_FOR_STRONGEST_2         0xB2 
.................... #define INIT_JOIN                      0xB3 
.................... #define CHECK_MOTE_STATE               0xB4 
.................... #define CHECK_MOTE_INFO                0xB5 
....................  
.................... #define BUSCOL_RESET                   0xC0 
....................  
.................... #define LCD_DISPLAY_RUN_MODULATION     0xD1 
.................... #define LCD_DISPLAY_RUN_NO_MODULATION  0xD2 
.................... #define LCD_DISPLAY_RBUF               0xD3 
.................... #define LCD_UPDATE                     0xD4 
....................  
.................... #define CPU_RESET                      0xF0 
.................... #define SHUTDOWN_SYSTEM                0xF1 
....................  
.................... // Macros used to push things to priority queue 
.................... #define PUSH_PRIORITY_QUEUE_MACRO(x)   \ 
.................... {disable_interrupts(INT_CCP4);         \ 
.................... push_priority_queue(x);                \ 
.................... enable_interrupts(INT_CCP4);} 
....................                                   
.................... #define PUSH_PRIORITY_QUEUE_ISR_MACRO(x) {push_priority_queue_ISR(x);}  
....................                                   
.................... ////////////////////Time Queue///////////////////////////////////////////////// 
.................... // Maximum number of items in time queue. Each item is 5 bytes and in RAM 
.................... // Actual number of items is max - 1 as item 0 is reserved for sorting use 
.................... #define MAX_TIME_QUEUE_ITEMS   5 
....................  
.................... // empty spot in the time queue, used as return item to signify empty top spot 
.................... #define EMPTY_TIME_QUEUE 0 
....................  
.................... // struct of individual time queue item 
.................... struct TimeQueueItem  
.................... { 
....................    uint32_t time_to_execute; 
....................    uint8_t pq_priority; 
.................... }; 
....................  
.................... // Macro for pushing items onto the time queue 
.................... #define PUSH_TIME_QUEUE_MACRO(x,y)  {disable_interrupts(INT_CCP4);            \ 
....................                                     push_time_queue(x,y);                     \ 
....................                                     enable_interrupts(INT_CCP4);}   
....................                                  
.................... ////////////////////Periodic checks/updates done in the time queue 
.................... // How often "long-term" checks are done within ccp4 (timer interrupt) in seconds 
....................    // - mote state (reacts as necessary) 
....................    // - battery state (turns off/on charging, sends warnings, etc.) 
....................    // - mote temp (logs data, sends warnings, etc.) 
....................    // - mote utc time (updates utc time if valid) 
.................... #define PERIODIC_CHECKS_TIME      32 
....................  
.................... ////////////////////Command Queue////////////////////////////////////////////// 
.................... // depth of command queue 
.................... #define MAX_COMMAND_QUEUE_ITEMS 10 
....................  
.................... // maximum number of sprinkler zones in each command coming from manager 
.................... #define MAX_NUM_SPRINKLER_ZONES 4 
....................  
.................... // struct for individual sprinkler zone settings 
.................... struct SprinklerZoneSettingsItem 
.................... { 
....................    uint16_t vlv_open_amount; 
....................    uint16_t spin_rate; 
....................    uint8_t duty_cycle; 
.................... }; 
....................  
.................... // struct for a single command (coming from manager) and item in the command 
.................... // queue 
.................... struct CommandQueueItem 
.................... { 
....................    uint32_t start_time; 
....................    uint32_t end_time; 
....................    struct SprinklerZoneSettingsItem* sprinkler_settings; 
....................    uint8_t num_of_zones; 
....................    uint8_t control_loop_mechanism; 
.................... }; 
....................  
.................... ////////////////////Sprinkler Queue//////////////////////////////////////////// 
.................... // depth of sprinkler queue (ONLY SETUP FOR 2 AT THE MOMENT) 
.................... //#define MAX_SPRINKLER_QUEUE_ITEMS 2 
.................... #define MAX_SPRINKLER_QUEUE_ITEMS 10 
....................  
.................... // struct for single sprinkler queue item 
.................... struct SprinklerQueueItem 
.................... { 
....................    uint32_t start_time; 
....................    uint32_t end_time; 
....................    uint16_t vlv_open_amount; 
....................    uint16_t spin_rate; 
....................    uint8_t zone_num; 
....................    uint8_t control_loop_mechanism; 
.................... }; 
....................  
.................... #define EMPTY_SPINKLER_QUEUE 0 
.................... /////////////////////Message Queue///////////////////////////////////////////// 
.................... // depth of message queue 
.................... #define MAX_MESSAGE_QUEUE_ITEMS 10  
....................  
.................... // empty spot in the message queue, used as return item to signify empty top spot 
.................... #define EMPTY_MESSAGE_QUEUE 0 
....................  
.................... // how many times will messages be attempted before an error message/bit is sent/set 
.................... #define MAX_UNSOLICITED_MESSAGE_ATTEMPTS 3 
....................                                                                      
.................... // how long to wait between message reattempts in seconds 
.................... #define MESSAGE_RESEND_WAIT_PERIOD 60 
....................  
.................... // how often identical error messages are able to be resent  
.................... // (if there haven't been any other types of error messages) in seconds 
.................... #define ERR_MESSAGE_WAIT_PERIOD 60                                                             
....................                                                                                             
.................... // struct for single message queue item 
.................... struct MessageQueueItem 
.................... {                                            
....................    uint32_t time_to_send; 
....................    uint8_t message_type; 
....................    uint16_t msg_seq; 
....................    uint8_t attempt_num; 
.................... }; 
....................  
.................... // Macro for pushing items onto the message queue 
.................... #define PUSH_MESSAGE_QUEUE_MACRO(x)  {disable_interrupts(INT_CCP4);           \ 
....................                                        push_message_queue(x);                 \ 
....................                                        enable_interrupts(INT_CCP4);}    
....................                                         
.................... #define PUSH_MESSAGE_QUEUE_ISR_MACRO(x)  {disable_interrupts(INT_CCP4);       \ 
....................                                           push_message_queue_isr(x);          \ 
....................                                           enable_interrupts(INT_CCP4);}                                           
....................                                         
.................... // Macro for deleting items off the message queue 
.................... #define REMOVE_MESSAGE_QUEUE_MACRO(x)  {disable_interrupts(INT_CCP4);         \ 
....................                                        remove_message_queue_item(x);          \ 
....................                                        enable_interrupts(INT_CCP4);}                                        
....................  
.................... /////////////////////Gen RPM/////////////////////////////////////////////////// 
.................... #define CCP_PER_RPM     2576980378L                                      
.................... // 39322 shifted 16 places left 
.................... // The timer used for the RPM measurement (CCP5) is 32.768KHz clock 
.................... // Stepper has 50 poles.... 
.................... // stepper output frequency = 50 * revs/sec = 50/60 * RPM                    
.................... // stepper output period = 1.2 / RPM 
.................... // CCP counter period = 1/32768 
.................... // CCP counts = (1.2/RPM) / (1/32768) = 39321.6 / RPM 
.................... // RPM = 39322/(CCP counts)  
....................                                                            
.................... ////////////////////Control Algorithm Defines////////////////////////////////// 
.................... // Min/Max Value of braking 
.................... #define NO_BRK    0 
.................... #define MAX_BRK   400 
....................  
.................... // Min/Max Value of charging 
.................... #define NO_CHARGE    0 
.................... #define MAX_CHARGE   400 
....................  
.................... // Min/Max Value of MPPC 
.................... #define NO_MPPC    0x07 
.................... #define MAX_MPPC   0xFF 
....................  
.................... // Min/Max setting of rpm 
.................... #define MIN_RPM_SETTING    10  
.................... #define MAX_RPM_SETTING    250 
....................  
.................... // Min/Max Value of fixture dac setting 
.................... // Set DAC on lab fixture to 0xC00 to sink ALL the current from the power 
.................... // source...  750mA (Test fixture setup:  full scale (0x1000) draws 1A 
.................... #define NO_FIXTURE    0x000 
.................... #define MAX_FIXTURE   0xC00 
....................  
.................... // Battery Charging cutoffs (in adc counts summed over 4 samples) 
.................... // When to stop charging the battery (3.5V while charging) 
.................... #define BATTERY_STOP_CHARGING    1402 
.................... // Hysteresis to start charging the battery again (3.3V while NOT charging) 
.................... #define BATTERY_START_CHARGING   1490 
.................... // When to warn the manager that the battery is dying (3.1V while NOT charging) 
.................... #define BATTERY_WARN             1584      
.................... // When to put the mote to sleep (3.0V while NOT charging) 
.................... #define BATTERY_DEAD             1637   
....................  
.................... // defines for global_control_loop_mechanism 
.................... // Shows what is being used to control rpm in control loop 
.................... // No rpm control is generally used for test modes                                   
.................... // No rpm control fsr will set braking and charging to 0 for FSR Calibration      
....................                                     
.................... // where to "jump into" the control loop. 
.................... //    basically, regular mode with both engaged, but it will evaluate if it should go into 
.................... //    BRAKE_AND_CHARGE or BRAKE_ONLY         
.................... #define BRAKE_AND_CHARGE_START      0x00 
.................... // regular mode with charging turned on        
.................... #define BRAKE_AND_CHARGE            0x01 
.................... // regular mode with charging turned off (due to full battery most likely) 
.................... #define BRAKE_ONLY                  0x02 
.................... // test mode where charging is force off 
.................... #define FORCE_BRAKE_ONLY            0x03 
.................... // test mode where braking is forced off 
.................... #define FORCE_CHARGE_ONLY           0x04 
.................... // test mode where brake and charge are set 
.................... #define NO_RPM_CONTROL              0x05 
.................... // test mode where brake and charge are set and dynamic mppc is used 
.................... #define NO_RPM_CONTROL_DYN_MPPC     0x06 
.................... // FSR calibration (no brake/charge/rpm control) 
.................... #define NO_RPM_CONTROL_FSR          0x07 
.................... // magnetic decoupling recovery 
.................... #define NO_SPIN_RECOVERY            0x08 
.................... // magnetic decoupling recovery             
.................... #define MAG_DECOUPLING_RECOVERY     0x09   
.................... // idle (nothing in the queue). Disable control loop    
.................... #define NO_SPRINKLER_CONTROL        0xFF                    
....................                                                          
.................... ////////////////////Valve////////////////////////////////////////////////////// 
.................... // Starting position of the DAC (also works as the eeprom stored inital value) 
.................... #define VLV_POSITION_UNKNOWN         0xFFFF 
.................... // Fully closed valve position                                                 
.................... #define VLV_POSITION_CLOSED          0x0000 
.................... // Fully open valve position      
.................... #define VLV_POSITION_OPENED          0x8000 
....................  
.................... // moved to eeprom stuff 
.................... /* 
.................... // Maximum value of "near closed" range 
.................... #define VLV_NEAR_CLOSED_RANGE_MAX    0x1000 
.................... // Maximum value of "near opened" range 
.................... #define VLV_NEAR_OPENED_RANGE_MAX    0x7000 
.................... */ 
.................... // default valve position for pre-calibration                     
.................... #define VLV_PRECALIBRATION_POSITION   0x4000 
.................... // Amount to move open in calibration routine 1 in units of valve position 
.................... #define VLV_CAL_1_MOVEMENT           0x2000     
....................  
.................... // approximate position to move valve at boot time 
.................... // if OPEN_VALVE_TO_SETPT_AT_BOOT is defined.... 
.................... // 0x2000 is 25% 
.................... #define VLV_BOOT_SETPT  0x2000 
....................  
.................... // determines when a VLV_CAL_STALE error message may occur 
.................... // 0x15180 is 24 hours 
.................... #define VLV_SECS_TO_STALE_CAL       0x00015180 
....................  
.................... //moved to eeprom stuff 
.................... /* 
.................... // DAC level while opening near the fully open end 
.................... #define DAC_LVL_OPENING_NEAR_OPENED       22        
.................... // DAC level while opening near the fully closed end 
.................... #define DAC_LVL_OPENING_NEAR_CLOSED       15    
.................... // DAC level while closing near the fully open end 
.................... #define DAC_LVL_CLOSING_NEAR_OPENED       15 
.................... // DAC level while closing near the fully closed end 
.................... #define DAC_LVL_CLOSING_NEAR_CLOSED       21 
.................... // DAC level while moving in the middle of the valve range and it's default 
.................... #define DAC_LVL_IN_MIDDLE                 18 
.................... // DAC level for the inital current boost/lowered current limit   
.................... #define DAC_LVL_INIT_CURRENT_BOOST        15             
.................... */ 
....................  
.................... // Valve timeout in millispans (maximum number of millispans that it can move  
.................... //    without error).  1024 is the full range. 
.................... #define VALVE_TIMEOUT                     1500 
....................  
.................... // Number of movements since an endstop before triggering a re-calibration of 
.................... //    endstop position (done before/triggered by a pending move) 
.................... #define VLV_MOVES_BEFORE_RECAL            25          
....................                                               
.................... // moved to eeprom stuff 
.................... /* 
.................... // Amount of millispans that a current boost/lovered dac level is implemented. 
.................... //    This is done outside of the (NEAR_CLOSED/OPEN_RANGE) 
.................... //    @ 45 seconds to close, 30 = 1.3 seconds 
.................... #define VLV_INIT_CURRENT_BOOST_TIME_1024THS   30      
.................... */                                     
....................  
.................... // default time_to_open/close.  This is the number of 2ndary Osccilator ticks 
.................... //    for 1/1024th of the span if the entire open-close takes 45 seconds. 
.................... #define DEFAULT_VLV_TIME_TO_OPEN          1280   
.................... #define DEFAULT_VLV_TIME_TO_CLOSE         1280        
....................     
.................... // if vlv_time_to_close/open is below this number, errors are thrown and calibration  
.................... //     is thrown away.  750 = 23.4375 seconds 
.................... #define ERROR_VLV_CAL_TIME_LO             750    
.................... // if vlv_time_to_close/open is above this number, errors are thrown and calibration  
.................... //     is thrown away.  750 = 78.125 seconds 
.................... #define ERROR_VLV_CAL_TIME_HI             2500   
....................  
.................... // moved to eeprom stuff 
.................... /* 
.................... // valve not-spinning and magnetic de-coupling defines                                                     
.................... // below this number is the regime where we watch for the vgen not spinning case 
.................... #define VLV_NOT_SPIN_LIMIT                0x6000 
.................... // where we send the valve when we want to fix it.  If it gets fixed before reaching this valve position 
.................... //    it stops. If it does not get fixed by the time it reaches this position, it sends an error and stops. 
.................... #define VLV_NOT_SPIN_FIX                  0x7000 
....................                                             
.................... // above this rpm, consider magnetic coupling or not-spinning fixed 
.................... #define NOT_SPINNING_MAG_DECOUPLING_RPM_FIXED   8        
....................                                                    
.................... // above this number is the regime where we watch for the vgen not spinning case 
.................... #define VLV_MAGNETIC_COUPLING_LIMIT       0x6000        
.................... // where to move the valve at a time when trying to recover  
.................... #define VLV_MAGNETIC_COUPLING_FIX         0x2000          
.................... // amount to move the valve at a time when trying to recover 
....................                                                   
.................... // how many seconds it takes to consider the rpm to be zero (or infinite for higher valve settings)  
.................... // 8 = 7.5 RPM (8 may be max of what ccp5 can handle without overflow)             
.................... #define RPM_TIMEOUT                      8        
.................... */                                                         
....................  
.................... // defines for testing valve state 
.................... #define  IS_VLV_COASTING   (LATE == 0) 
.................... #define  IS_VLV_CLOSING    (LATE == 0x01) 
.................... #define  IS_VLV_OPENING    (LATE == 0x02) 
.................... #define  IS_VLV_BRAKING    (LATE == 0x03) 
....................  
.................... // macros for making the valve move 
.................... #define  mV_COASTm   {LATE=0;} 
.................... #define  mV_CLOSEm   {LATE=0x01;} 
.................... #define  mV_OPENm    {LATE=0x02;} 
.................... #define  mV_BRAKEm   {LATE=0x03;}                                                                                                                      
....................  
.................... ////////////////////XDCR///////////////////////////////////////////////////////  
.................... // limit for detecting if the XDCR is plugged in or not.   
.................... // there is a ~5.6M resistor pulling the line up to vcc. 
.................... // It sums 8 measurements and with the weak pullups is usually around 6200 
.................... // To account for variation, we will set 5000 (around 75 psi on the 100 psi sensor) 
.................... // as the limit to detect it.         
.................... #define XDCR_ADC_OFF_LIMIT 5000      
....................                                                      
.................... ////////////////////RB ISR/////////////////////////////////////////////////////   
.................... // seconds you have to press SW1 until it activate the long press function 
.................... #define SW1_ISR_LONG_PRESS_TIME 5  
....................                                              
.................... ////////////////////I2C Addresses////////////////////////////////////////////// 
.................... #define LCD_ADDRESS 0x7C 
.................... #define XDCR_ADDRESS 0x48         
.................... #define FIXTURE_DAC_ADDRESS 0x40     
....................                                     
.................... ////////////////////LCD Defines////////////////////////////////////////////////     
.................... // total number of lcd pages defined in switch-case in LCD_update_diplay() 
.................... // JG: Actually there are 4 defined in the switch-case, but only 
.................... //  want to see 3 at this time 
.................... #define TOTAL_LCD_PAGES 4                              
....................  
.................... ////////////////////LED Defines Start//////////////////////////////////////////    
.................... // make sure to disable INT_RB4 to not have the led trigger an IOC int 
.................... #define LED1_ON       disable_interrupts(INT_RB4); set_tris_b(TRISB_LED); output_low(LED1n); 
.................... #define LED1_OFF      set_tris_b(TRISB_NORM); enable_interrupts(INT_RB4); 
....................  
.................... #define LED2_ON       output_low(LED2n); 
.................... #define LED2_OFF      output_high(LED2n); 
....................  
.................... ////////////////////LED Defines End//////////////////////////////////////////// 
....................  
.................... ////////////////////DUST Defines/////////////////////////////////////////////// 
.................... // moved to eeprom stuff      
.................... /*                                             
.................... // amount of seconds for mote to stay searching for advertisements                     
.................... #define MOTE_SEARCH_TIME 120        
.................... // amount of time the mote will stay disconnected from the network before shutting down (900 = 15 min)    
.................... #define MOTE_NETWORK_SHUTDOWN_TIMEOUT 900            
.................... */ 
....................  
.................... // Min temperature before sending a warning/shutdown 
.................... #define MOTE_MIN_TEMP_WARNING   -35 
.................... #define MOTE_MAX_TEMP_WARNING    80                                       
.................... #define MOTE_MIN_TEMP_SHUTDOWN   -40 
.................... #define MOTE_MAX_TEMP_SHUTDOWN   85                                                             
....................  
.................... //Crazy macro for finding control escape 
.................... #define STUFF_BYTE(x, y, z)  { \ 
....................     if ((x==CONTROL_ESCAPE)||(x==FLAG_SEQUENCE)) { \ 
....................         y[z++] = CONTROL_ESCAPE; \ 
....................         y[z++] = x ^ XOR_BYTE; \ 
....................     } else { \ 
....................         y[z++] = x;     \ 
....................     } \ 
.................... } 
....................  
.................... #define STUFF_BYTE_ISR(x, y, z)  { \ 
....................     if ((x==CONTROL_ESCAPE)||(x==FLAG_SEQUENCE)) { \ 
....................         y[z++] = CONTROL_ESCAPE; \ 
....................         y[z++] = x ^ XOR_BYTE; \ 
....................     } else { \ 
....................         y[z++] = x;     \ 
....................     } \ 
.................... }       
....................  
.................... // Default newtork ID of bluebox  
.................... // Somewhat arbitrary, but we will refer to 04cd blue box as center pivot number 0 
.................... //    ...which is the default listed below 
.................... #define NETWORK_ID_DEF  0x04cd                                 
....................                                                         
.................... // defines for msg_id (Manager->Mote Payload message ID to Micro) 
.................... #define MSG_MGR_ACK                       0x01 
.................... #define MSG_MGR_NACK                      0x02 
....................                                                           
.................... #define MSG_MGR_FULL_REPORT               0x10 
.................... #define MSG_MGR_HEALTH_REPORT             0x11 
.................... #define MSG_MGR_VALVE_REPORT              0x12 
....................  
.................... #define MSG_MGR_WARM_RESTART              0x20 
.................... #define MSG_MGR_COLD_RESTART              0x21 
.................... #define MSG_MGR_FORCE_REJOIN              0x22 
.................... #define MSG_MGR_SHUTDOWN                  0x23 
....................  
.................... #define MSG_MGR_UPDATE_SP_NUM             0x30 
.................... #define MSG_MGR_CAL_VALVE                 0x31 
.................... #define MSG_MGR_CAL_FSR                   0x32 
.................... #define MSG_MGR_AQUIRE_GPS                0x33 
.................... #define MSG_MGR_UPDATE_EEPROM             0x34  
.................... #define MSG_MGR_READ_EEPROM               0x35  
.................... #define MSG_MGR_READ_XDCR                 0x36 
....................  
.................... #define MSG_MGR_RUN_CMD_NO_MOD            0x40 
.................... #define MSG_MGR_RUN_CMD_MOD               0x41 
.................... #define MSG_MGR_TEST_NO_RPM_CTRL          0x42 
.................... #define MSG_MGR_TEST_RPM_CTRL             0x43 
.................... #define MSG_MGR_DEMO                      0x44 
.................... #define MSG_MGR_CLEAR_SPINKLER_CMD_QUEUE  0x45 
.................... #define MSG_MGR_FORCE_VALVE_MOVEMENT      0x46 
....................  
.................... // defines for msg_id (Micro to Mote) 
.................... #define MSG_MOTE_UNSOLICITED              0x00 
.................... #define MSG_MOTE_ACK                      0x80 
.................... #define MSG_MOTE_NACK                     0x81          
....................  
.................... #define MSG_MOTE_FULL_REPORT              0x90 
.................... #define MSG_MOTE_HEALTH_REPORT            0x91 
.................... #define MSG_MOTE_VALVE_REPORT             0x92                  
.................... #define MSG_MOTE_SPINKLER_CMD_RESPONSE    0x93 
.................... #define MSG_MOTE_JOIN_MSG                 0x94       
.................... #define MSG_MOTE_UPDATE_SP_NUM_RESPONSE   0x95 
.................... #define MSG_MOTE_GPS_POINT_MSG            0x96    
.................... #define MSG_MOTE_EEPROM_READ_RESPONSE     0x97 
.................... #define MSG_MOTE_XDCR_READ_MSG            0x98    
.................... #define MSG_MOTE_ERROR_MSG                0xA0 
....................  
....................  
.................... ////////////////////Status Defines///////////////////////////////////////////// 
.................... ////////////////////Mote Statuses (for global_mote_status) 
.................... /* From jack_dn2500.h 
.................... // Mote Status values 
.................... #define MOTESTATE_INIT           0x00     // Mote is booting. 
.................... #define MOTESTATE_IDLE           0x01     // Mote is accepting config cmds.   
....................                                           //  Upon receiving a join cmd, mote  
....................                                           //  moves into the Searching state. 
....................                                           //  Idle state is low power state. 
.................... #define MOTESTATE_SEARCHING      0x02     // Mote's rcvr is on with a  
....................                                           //  configurable duty cycle while 
....................                                           //  mote is actively searching for net.  
.................... #define MOTESTATE_NEGOTIATING    0x03     // Mote has detected a network  
....................                                           //  and is attempting to connect. 
.................... #define MOTESTATE_CONNECTED      0x04     // Mote has joined the net 
.................... #define MOTESTATE_OPERATIONAL    0x05     // Mote has links to both net mgr and 
....................                                           //  gateway; ready to send data. 
.................... #define MOTESTATE_DISCONNECTED   0x06     // Mote is disconnected. 
.................... #define MOTESTATE_RADIOTEST      0x07 
.................... #define MOTESTATE_PROMISCUOUS    0x08 
.................... #define MOTESTATE_UNKNOWN        0xFF 
.................... */ 
....................  
.................... ////////////////////System States (for global_system_state)       
.................... // system is initalizing, but not ready to run yet      
.................... #define SYSTEM_INIT                       0x00        
.................... // system is paused while sprinkling (for something like going over a waterway, for example) 
.................... //    Not sure if this needs to be used. 
.................... #define SYSTEM_PAUSE                      0x01   
.................... // system is running (sprinkling and control loop running) 
.................... #define SYSTEM_RUN                        0x02  
.................... // system is on and ready for commands, but not in the control loop (lower power)           
.................... #define SYSTEM_IDLE                       0x03        
.................... // system is sleeping (powered down?). Not sure if this needs to be used 
.................... #define SYSTEM_SLEEP                      0x04 
.................... // valve opening a little bit to ensure we dont jam into close endstop 
.................... #define SYSTEM_CAL_VLV_1                  0x10 
.................... // valve closing towards closing endstop pre-calibration 
.................... #define SYSTEM_CAL_VLV_2                  0x11 
.................... // valve opening fully from fully closed for calibration                         
.................... #define SYSTEM_CAL_VLV_3                  0x12 
.................... // doing FSR w/ valve fully open 
.................... #define SYSTEM_CAL_VLV_4                  0x13 
.................... // valve closing fully from fully open for calibration 
.................... #define SYSTEM_CAL_VLV_5                  0x14 
.................... // calibration routine is done, send message to manager and prepare system for 
.................... //    idle/run mode 
.................... #define SYSTEM_CAL_VLV_6                  0x15 
.................... // valve is moving towards one of the endstops trying to recalibrate it's position 
.................... #define SYSTEM_RECAL_VLV_MOVES            0x16 
.................... // valve is moving (outside of calibrate valve routine) 
.................... #define SYSTEM_MOVE_VALVE                 0x17 
.................... // Move valve to desired setting 
.................... #define SYSTEM_CAL_FSR_1                  0x18 
.................... // do fsr calibration 
.................... #define SYSTEM_CAL_FSR_2                  0x19 
.................... // move valve back to original position 
.................... #define SYSTEM_CAL_FSR_3                  0x1A 
.................... // fsr is done, send message to manager and restore previous state/run mode 
.................... #define SYSTEM_CAL_FSR_4 
....................  
.................... // system is searching for a network 
.................... #define SYSTEM_SEARCHING_FOR_NETWORK      0x20 
.................... // system is connecting to a network 
.................... #define SYSTEM_CONNECTING_TO_NETWORK      0x21 
.................... // ????? 
.................... #define SYSTEM_STATE_UNKNOWN              0xFF     
....................  
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////////////////////Error Defines////////////////////////////////////////////// 
.................... /////////////////////////////////////////////////////////////////////////////// 
....................  
.................... ////////////////////Deep sleep/shutdown/restart reasons/errors 
.................... // stored in global_shutdown_errors_bitfield and EEPROM and shown on screen before deep sleep 
.................... // no error 
.................... #define NO_ERR                            0x00 
.................... // mote doesn't respond after a reset 
.................... #define ERR_FAIL_ON_MOTE_RESET            0x01 
.................... // mote receives no advertisement from managers 
.................... #define ERR_NO_ADV_WHILE_SEARCHING        0x02 
.................... // mote has set it's network manager id during search succesfully 
.................... #define NEW_NETWORK_ID_SET                0x03 
.................... // mote does not respond properly to a request 
.................... #define ERR_MOTE_UNRESPONSIVE             0x04 
.................... // mote is outside of operating range (defined under dust) 
.................... #define ERR_MOTE_OUT_OF_TEMP_RANGE        0x05 
.................... // network was unable to join properly 
.................... #define ERR_NETWORK_JOIN_FAIL             0x06 
.................... // unable to set join duty on mote properly 
.................... #define ERR_MTJOINDUTY                    0x07 
.................... // unable to join network with joinkey 
.................... #define ERR_MTJOINKEY                     0x08 
.................... // warm restart requested by manager 
.................... #define WARM_RESTART_REQUEST              0x09 
.................... // cold restart requested by manager 
.................... #define COLD_RESTART_REQUEST              0x0A 
.................... // shutdown requested by manager           
.................... #define MANAGER_SHUTDOWN_REQUEST          0x0B 
.................... // battery is dead 
.................... #define ERR_BATT_DEAD_SLEEP               0x0C 
.................... // network timeout 
.................... #define ERR_NO_NETWORK_TIMEOUT            0x0D 
....................  
.................... // freshly programmed (EEPROM defaults to all F,F,F...F) 
.................... #define NEWLY_PROGRAMMED                  0xFF 
....................  
....................  
.................... ////////////////////global error bitfield errors for sending to manager 
.................... // unsolicited message not ack'd after max attempts 
.................... #define ERR_MSG_UNSOLICITED_MESSAGE_NOT_ACKD       0x00000001 
.................... // state incompatible with requested action 
.................... #define ERR_MSG_INCOMPATIBLE_STATE                 0x00000002 
.................... // valve calibration stale (activity depends on defines) 
.................... #define ERR_MSG_VLV_CAL_STALE                      0x00000004 
.................... //#define ERR_MSG_VLV_NOT_CALIBRATED                 0x00000004 
.................... // mote was unresponsive in system (busy likely) 
.................... #define ERR_MSG_MOTE_UNRESPONSIVE                  0x00000008 
.................... // rpm set point is too high to reach (no charging or braking and still no go) 
.................... #define ERR_MSG_RPM_TOO_HIGH_TO_REACH              0x00000010 
.................... // rpm is too low to reach (full charging, braking and still no go) 
.................... #define ERR_MSG_RPM_TOO_LOW_TO_REACH               0x00000020 
.................... // mote temperature is out of range (sleep) 
.................... #define ERR_MSG_MOTE_TEMP_OUT_OF_RANGE             0x00000040 
.................... // battery is low (warning) 
.................... #define ERR_MSG_BATT_LOW_WARN                      0x00000080 
.................... // battery is dead (going to sleep) 
.................... #define ERR_MSG_BATT_DEAD_SLEEP                    0x00000100 
.................... // valve calibration was invalid (too short) 
.................... #define ERR_MSG_VLV_CAL_FAIL                       0x00000200 
.................... // valve hit an endstop outside of the "closing when opened" etc. areas (close to the endstops) 
.................... #define ERR_MSG_VLV_MOVE_FAIL                      0x00000400 
.................... // not spinning condition detected, recovery attempt proceeding 
.................... #define ERR_MSG_NOT_SPINNING                       0x00000800 
.................... // magnetic decoupling condition detected, recovery attempt proceeding 
.................... #define ERR_MSG_MAG_DECOUPLING                     0x00001000                      
.................... // not spinning condition or magnetic decoupling condition recovery failed (going to sleep (another message afterwards)) 
.................... #define ERR_MSG_MAG_NOT_SPIN_RECOVERY_FAILED       0x00002000 
.................... // signal that system is in invalid state to do run command (e.g. cal vlv, recal vlv, fsr) 
.................... #define ERR_MSG_SPINKLER_CMD_DELAYED_INVALID_STATE 0x00004000    
.................... // signal that the mote is going to shutdown/sleep (or with another reason) 
.................... #define ERR_MSG_MOTE_GOING_TO_DEEP_SLEEP           0x80000000 
....................  
.................... /* 
.................... // message needs to be sent now! Disregard message waiting time. 
.................... #define ERR_MSG_HIGH_PRIORITY                    0x80000000 
.................... */ 
....................  
.................... ////////////////////NACK Bitfield Errors 
....................  
.................... // valve position not calibrated 
.................... #define NACK_BITFIELD_VLV_POSITION_UNKNOWN         0x00000001 
.................... // invalid valve setting requested 
.................... #define NACK_BITFIELD_INVALID_VLV_SETTING          0x00000002 
.................... // invalid rpm setting requested 
.................... #define NACK_BITFIELD_INVALID_RPM_SETTING          0x00000004 
.................... // invalid brake pwm setting requested 
.................... #define NACK_BITFIELD_INVALID_BRAKE_SETTING        0x00000008 
.................... // invalid charge pwm setting requested 
.................... #define NACK_BITFIELD_INVALID_CHARGE_SETTING       0x00000010 
.................... // state incompatible with requested action 
.................... #define NACK_BITFIELD_INCOMPATIBLE_STATE           0x00000020 
.................... // battery is too low for requested action 
.................... #define NACK_BITFIELD_BATT_TOO_LOW                 0x00000040 
.................... // don't have the required hardware for requested operation (e.g. gps, xdcr) 
.................... #define NACK_BITFIELD_INVALID_HARDWARE             0x00000080 
.................... // info recived during eeprom update is invalid (invalid range, number of bytes) 
.................... #define NACK_BITFIELD_INVALID_EEPROM_SETTINGS      0x00000100 
.................... // invalid mppc setting requested 
.................... #define NACK_BITFIELD_INVALID_MPPC_SETTING         0x00000200 
....................  
.................... ////////////////////get and send dustmsg_ISR Errors and pkdecode errors 
.................... // Where the errors start (for checking return values in deal_with_mote) 
.................... #define ERR_BAD_PAYLOAD                   249 
.................... #define ERR_DUSTMSG_START_OF_ERRORS       250 
.................... // CRC errors in pkdecode 
.................... #define ERR_DUSTMSG_CRC                   251 
.................... // Timeout on first byte 
.................... #define ERR_DUSTMSG_TIMEOUT               252 
.................... // RS232 errors from getc() 
.................... #define ERR_DUSTMSG_RS232                 253 
.................... // Framing Error 
.................... #define ERR_DUSTMSG_FRAMING_ERROR         254 
.................... // Message < 6 bytes (too short) 
.................... #define ERR_DUSTMSG_MESSAGE_LENGTH        255 
....................  
....................  
.................... #include "function_headers.h"                   
.................... //pic.h 
.................... void fosc_pri(void); 
.................... void fosc_pri_ISR(void); 
.................... void fosc_4m(void); 
.................... void fosc_1m(void); 
.................... void fosc_250k(void); 
.................... void fosc_250k_ISR(void); 
.................... void fosc_31250(void);  
.................... void fosc_31250_ISR(void);  
.................... void fosc_sec(void); 
.................... void osc_init(void); 
.................... void setup_T0_int(uint16_t value); 
.................... void setup_T2_int(uint8_t value); 
.................... void setup_T4_int(uint8_t value); 
.................... void periph_init(void); 
.................... void vars_init(void);      
.................... void deep_sleep(); 
.................... void start_rtc(void); 
.................... void safeI2C_start(void); 
.................... void safeI2C_write(uint8_t value);  
.................... void setup_rb4_int(void);                                   
.................... void write_system_state(uint8_t system_state_to_change_to);  
.................... uint8_t read_system_state(void);  
....................                                                               
.................... //eeprom.h 
.................... uint8_t read_ee1(uint16_t source); 
.................... uint16_t read_ee2(uint16_t source); 
.................... uint32_t read_ee4(uint16_t source); 
.................... void write_ee1(uint16_t dest, uint8_t dat8); 
.................... void write_ee2(uint16_t dest, uint16_t dat16); 
.................... void write_ee4(uint16_t dest, uint32_t dat32); 
.................... void store_all_eeprom_values(void);   
.................... void read_all_eeprom_values(void);                   
.................... void store_vcal_eeprom_values(void);   
.................... void read_all_eeprom_variables(void);                               
....................  
.................... //periph.h (LCD + XDCR) 
.................... //LCD declerations 
.................... void LCD_init(void); 
.................... void LCD_line1(unsigned char *text); 
.................... void LCD_line2(unsigned char *text); 
.................... void LCD_place_text(unsigned char *text, int1 row, uint8_t col, uint8_t length); 
.................... void LCD_place_char(char ascii, int1 row, uint8_t col); 
.................... void LCD_place_uint8(uint8_t num, int1 row, uint8_t col, uint8_t length); 
.................... void LCD_place_uint16(uint16_t num, int1 row, uint8_t col, uint8_t length); 
.................... void LCD_place_uint32(uint32_t num, int1 row, uint8_t col, uint8_t length); 
.................... void LCD_clear(void); 
.................... void LCD_clear_line1(void); 
.................... void LCD_clear_line2(void); 
.................... void LCD_position(int position); 
.................... void LCD_char(char ascii); 
.................... void LCD_shutdown(void); 
.................... void LCD_startup_splash(void); 
.................... void LCD_display_priority_time_stacks(void); 
.................... void LCD_display_priority_time_stacks_2(void); 
.................... void LCD_display_priority_queue(void);    
.................... void LCD_display_message_queue(void);  
.................... void LCD_display_battery_voltage(int1 lcd_line); 
.................... void LCD_display_batt_voltage(int1 lcd_line, uint8_t col, uint8_t precision); 
.................... void LCD_display_vgen(int1 lcd_line, uint8_t col, uint8_t precision); 
.................... void LCD_update_diplay(void);      
.................... void XDCR_init(void);   
.................... void adc_XDCR_init(void); 
.................... uint16_t XDCR_measure(void);  
.................... uint16_t adc_XDCR_measure(void);     
.................... void fixture_init(void); 
....................  
.................... //dust.h 
.................... void mote_init(void); 
.................... void mote_reset(void); 
.................... uint8_t mote_sleep(void); 
.................... void search_for_strongest(void); 
.................... void process_advert(void); 
.................... uint8_t initiate_join(void); 
.................... void mote_state_check(void); 
.................... void mote_temp_check(void); 
.................... void mote_time_update(void); 
.................... void init_msgSEQ(void); 
.................... void deal_with_mote_ISR(void); 
.................... uint8_t get_dustmsg_ISR(void); 
.................... void  dust_hdlc_pkgen(uint8_t* prefix, uint8_t size, uint8_t* buf, uint8_t size_buf); 
.................... void  dust_hdlc_pkgen_ISR(uint8_t* prefix, uint8_t size, uint8_t* buf, uint8_t size_buf); 
.................... uint8_t dust_hdlc_pksend(); 
.................... uint8_t dust_hdlc_pksend_ISR(); 
.................... uint8_t dust_hdlc_pkdecode_ISR(uint8_t bytes_to_decode); 
.................... uint16_t fcs_fcs16(uint16_t fcs, uint8_t data); 
.................... uint16_t fcs_fcs16_ISR(uint16_t fcs, uint8_t data); 
.................... static uint16_t fcs_calc(uint8_t* p, uint16_t size); 
.................... static uint16_t fcs_calc_ISR(uint8_t* p, uint16_t size); 
.................... uint8_t deal_with_packet(void); 
.................... void prepare_prefix_and_payload(uint8_t payload_buf_length); 
.................... void prepare_prefix_and_payload_ISR(uint8_t payload_buf_length); 
.................... void generate_message_and_send(); 
.................... void generate_message_and_send_ISR(); 
.................... void send_full_report(uint8_t command_id_in_response_to, uint16_t msg_seq); 
.................... void send_health_report(uint8_t command_id_in_response_to, uint16_t msg_seq); 
.................... void send_valve_report(uint8_t command_id_in_response_to, uint16_t msg_seq); 
.................... void send_sprinkler_cmd_response(uint8_t command_id_in_response_to, uint16_t msg_seq); 
.................... void send_update_sp_num_response(uint8_t command_id_in_response_to, uint16_t msg_seq); 
.................... void send_read_eeprom_response(uint8_t command_id_in_response_to, uint16_t msg_seq, uint16_t eeprom_location, uint32_t eeprom_data);  
.................... void send_pressure_xdcr_msg(uint8_t command_id_in_response_to, uint16_t msg_seq);  
.................... void send_pressure_xdcr_msg_ISR(uint8_t command_id_in_response_to, uint16_t msg_seq);  
.................... void send_ack(uint8_t command_id_in_response_to, uint16_t msg_seq); 
.................... void send_nack(uint8_t command_id_in_response_to, uint16_t msg_seq, uint32_t nack_bitfield); 
.................... void send_full_report_ISR(uint8_t command_id_in_response_to, uint16_t msg_seq); 
.................... void send_health_report_ISR(uint8_t command_id_in_response_to, uint16_t msg_seq); 
.................... void send_valve_report_ISR(uint8_t command_id_in_response_to, uint16_t msg_seq); 
.................... void send_join_msg_ISR(uint8_t command_id_in_response_to, uint16_t msg_seq); 
.................... void send_gps_point_msg_ISR(uint8_t command_id_in_response_to, uint16_t msg_seq); 
.................... void send_error_msg_ISR(uint8_t command_id_in_response_to, uint16_t msg_seq); 
....................  
.................... //util.h 
.................... void flash_leds(uint8_t num_of_flashes); 
.................... void flash_leds_ISR(uint8_t num_of_flashes); 
.................... void happy_lites(void); 
.................... char *word_to_4dig_new (uint16_t xword); 
.................... uint16_t convert_rpm_to_period(uint16_t rpm); 
.................... uint16_t convert_period_to_rpm(uint16_t period); 
.................... uint16_t convert_period_to_rpm_ISR(uint16_t period); 
.................... uint8_t  hi2asc(uint8_t xbyte); 
.................... uint8_t  lo2asc(uint8_t xbyte); 
....................  
.................... //stacks_queues.h 
.................... void clear_priority_queue(); 
.................... uint8_t pop_priority_queue(); 
.................... int1 push_priority_queue(uint8_t new_priority_queue_item); 
.................... void push_priority_queue_ISR(uint8_t new_priority_queue_item); 
.................... void push_priority_queue_ISR2(uint8_t new_priority_queue_item); 
.................... void clear_time_queue(); 
.................... int1 pop_time_queue();  
.................... void pop_time_queue_ISR(); 
.................... int1 push_time_queue(uint32_t time_to_execute, uint8_t priority); 
.................... void push_time_queue_ISR(uint32_t time_to_execute, uint8_t priority); 
.................... void allocate_command_queue(void); 
.................... void clear_command_queue(void); 
.................... int1 push_command_queue(struct CommandQueueItem new_command_queue_item); 
.................... void clear_message_queue(void); 
.................... void clear_sprinkler_queue(void); 
.................... void push_sprinkler_queue(uint32_t start_time,uint32_t end_time,uint16_t vlv_open_amount,uint16_t spin_rate,uint8_t zone_num, uint8_t control_loop_mechanism); 
.................... void pop_sprinkler_queue_ISR(void); 
.................... void pop_message_queue_and_send_ISR(void); 
.................... void push_message_queue(uint8_t message_type); 
.................... void push_message_queue_ISR(uint8_t message_type); 
.................... void remove_message_queue_item(uint16_t msg_seq); 
.................... void remove_message_queue_item_ISR(uint16_t msg_seq); 
....................                                              
.................... //control.h 
.................... void setup_gen_rpm(void); 
.................... uint16_t calc_gen_rpm(void);                           
.................... int1  is_brake_duty_valid(uint16_t value); 
.................... int1  is_charge_duty_valid(uint16_t value); 
.................... int1  is_mppc_valid(uint8_t value); 
.................... int1  is_rpm_setting_valid(uint16_t value); 
.................... void set_brake_duty(uint16_t value); 
.................... void set_charge_duty(uint16_t value);                                  
.................... void set_mppc(uint8_t value); 
.................... void set_fixture_dac(uint16_t dac_value); 
.................... void adjust_brake_for_rpm(uint16_t rpm_set_value); 
.................... void adjust_brake_for_vgen(uint16_t vgen_set_value); 
.................... void adjust_fixture_for_rpm(uint16_t fixture_set_value); 
.................... void setup_control_update_speed_vgen(); 
.................... void adjust_mppc(void);        
.................... void update_control_loop(void); 
.................... void stop_current_spinkler_setting(void); 
.................... void stop_current_spinkler_setting_ISR(void); 
....................  
.................... //battery.h 
.................... uint16_t get_vgen(int1 charge_state); 
.................... uint16_t get_vgen_ISR(int1 charge_state); 
.................... uint16_t get_vbatt(int1 charge_state); 
.................... uint16_t get_vbatt_ISR(int1 charge_state); 
.................... uint32_t calc_vbatt(uint16_t vref_count); 
.................... uint16_t calc_vbatt_BCD(uint16_t vref_count); 
.................... uint16_t calc_vgen_BCD(uint16_t vref_count); 
.................... void check_and_deal_with_battery(void); 
....................  
.................... //valve.h 
.................... void  cl_valve(void); 
.................... void  op_valve(void); 
.................... void  cl_valve_timed(uint32_t num_ints); 
.................... void  op_valve_timed(uint32_t num_ints); 
.................... void  comparator_setup(void); 
.................... uint16_t calc_valve_movement_time(uint16_t current_location, uint16_t destination); 
.................... void  set_comp_dac_level(void); 
.................... void  set_comp_dac_level_ISR(void); 
.................... int1  is_valve_position_valid(uint16_t value); 
.................... int1  is_valve_value_full_open_or_close(uint16_t value); 
....................  
.................... #include "jack_dn2500.h" 
.................... /* 
....................  * $HeadURL: https://svn/appeng/trunk/dev/src/api/dust_dn2500.h $ 
....................  * $Id: dust_dn2500.h 261 2010-02-19 23:34:29Z kottaway $ 
....................  * 
....................  * Copyright (c) 2006, Dust Networks, Inc 
....................  * All rights reserved. 
....................  * Redistribution and use in source and binary forms, with or without 
....................  * modification, are permitted provided that the following conditions are met: 
....................  * 
....................  *     * Redistributions of source code must retain the above copyright 
....................  *       notice, this list of conditions and the following disclaimer. 
....................  *     * Redistributions in binary form must reproduce the above copyright 
....................  *       notice, this list of conditions and the following disclaimer in the 
....................  *       documentation and/or other materials provided with the distribution. 
....................  *     * Neither the name of Dust Networks, Inc nor the 
....................  *       names of its contributors may be used to endorse or promote products 
....................  *       derived from this software without specific prior written permission. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED BY DUST NETWORKS, INC AND CONTRIBUTORS "AS IS" AND ANY 
....................  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
....................  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
....................  * DISCLAIMED. IN NO EVENT SHALL DUST NETWORKS, INC AND CONTRIBUTORS BE LIABLE FOR ANY 
....................  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
....................  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
....................  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND 
....................  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
....................  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
....................  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  
....................  * 
....................  * This documentation might include technical inaccuracies or other errors.  
....................  * Corrections and improvements might be incorporated in new versions of the  
....................  * documentation. Dust Networks does not assume any liability arising out of  
....................  * the application or use of any products or services and specifically disclaims  
....................  * any and all liability, including without limitation consequential or incidental damages. 
....................  * 
....................  *  
....................  * 
....................  * Dust Networks reserves the right to make corrections, modifications, enhancements, 
....................  * improvements, and other changes to its products or services at any time and to  
....................  * discontinue any product or service without notice. Customers should obtain the  
....................  * latest relevant information before usage and should verify that such information  
....................  * is current and complete. 
....................  */ 
....................   
....................  // NOTE THAT THIS FILE WAS UPDATED TO INCLUDE THE SEARCH capability 
....................  //  now included in the Eterna parts (JG June 2013) 
....................  
.................... /* Max user data size.  This limit is specific to the  
....................  * amount of data that can be sent via radio to/from the Manager. 
....................  * This is not an HDLC limit which might include byte stuffing. 
....................  */ 
.................... #define MAX_USER_DATA_SIZE       94 
....................  
.................... // prior to encoding for transmission 
.................... // cmd(1), len_pkt(1), flags(1), destaddr(2), svc_index(1), appdomain(1), 
.................... // priority(1), reserved(2), sequence_num(1), len_data(1), MAX_USER_DATA_SIZE 
.................... #define MAX_SEND_REQUEST         MAX_USER_DATA_SIZE + 12 
....................  
.................... // include now the delimiters (2), the FCS (w/ byte stuffing could be 4), 
.................... //  of the 12 bytes added above, there may be an extra 2 due to byte stuffing 
.................... //  and the message can be MAX_USER_DATA_SIZE*2 worst case! 
.................... #define MAX_SEND_BUFFER          MAX_USER_DATA_SIZE*2 + 2 + 4 + 12 + 2 
.................... // This adds up to 208! 
....................  
.................... // after decoding the received message 
.................... // cmd(1), len_pkt(1), flags(1), sourceaddr(2), sequence_num(1), len_data(1),  
.................... // MAX_USER_DATA_SIZE 
.................... #define MAX_DATA_RCVD            MAX_USER_DATA_SIZE + 7 
....................  
.................... // prior to decoding, raw rcv data 
.................... // include delimiters (2), the FCS (4 max), of the 7 bytes above there may be 
.................... //  an extra stuffed byte, and the message can be MAX_USER_DATA_SIZE*2! 
.................... #define MAX_RCV_BUFFER           MAX_USER_DATA_SIZE*2 + 2 + 4 + 7 + 1 
.................... // This adds up to 202 
....................   
.................... #define MAX_JOINKEY_SIZE         16 
....................  
.................... #define MAX_BURST_MESSAGE        3 
....................  
.................... #define DESTADDR_GATEWAY         0xF981 
.................... #define DESTADDR_SWAPPED         0x81F9 
.................... #define DESTADDR_HI              0xF9 
.................... #define DESTADDR_LO              0x81 
....................  
.................... // Microprocessor to Mote Commands 
.................... #define CMD_SET            0x01     // Sets param on the mote. 
.................... #define CMD_GET            0x02     // Gets param from mote 
.................... #define CMD_SETNV          0x03     // Stores param in the motes NV 
.................... #define CMD_GETNV          0x04     // Retrieves param from the motes NV 
.................... #define CMD_SEND           0x05     // Packet destined for the network. 
.................... #define CMD_JOIN           0x06     // Requests that mote attempt to join 
.................... #define CMD_DISCONNECT     0x07     // Requests that mote disconnect 
.................... #define CMD_RESET          0x08     // Resets mote. 
.................... #define CMD_SLEEP          0x09     // Shuts down periphs & puts mote to sleep 
.................... #define CMD_TESTRADIOTX    0x0B     // Initiate a series of packet transmissions. 
.................... #define CMD_TESTRADIORX    0x0C     // Test radio reception for a specified chan. 
.................... #define CMD_CLEARNV        0x10     // Resets the motes NV to factory default.. 
.................... #define CMD_SEARCH         0x11     // new Search for networks capability 
....................                                     // (Eterna parts) 
....................  
.................... // Mote to Microprocessor Commands 
.................... #define CMD_TIME           0x0D     // Time and mote state information. 
.................... #define CMD_SERVICE        0x0E     // Notifies micro of changes in service stat. 
.................... #define CMD_EVENT          0x0F     // Notifies micro of new has occurred. 
.................... #define CMD_ADVERT         0x12     // Notifies micro that an adv has been rcvd. 
.................... #define CMD_DATA           0x81     // Packet from the network to the micro. 
....................  
....................  
.................... // Result Codes 
.................... #define RC_OK              0x00     // Operation was successfully completed. 
.................... #define RC_EXE_ERR         0x01     // Reserved. 
.................... #define RC_PARAM_ERR       0x02     // Reserved. 
.................... #define RC_BUSY            0x03     // Operation on this service is in progress. 
.................... #define RC_INVALID_LEN     0x04     // Invalid packet length. 
.................... #define RC_INV_STATE       0x05     // Invalid mote state for command. 
.................... #define RC_UNSUPPORTED     0x06     // Command not supported for hardware. 
.................... #define RC_UNKNOWN_PARAM   0x07     // Unknown parameter value. 
.................... #define RC_UNKNOWN_CMD     0x08     // Unknown command. 
.................... #define RC_WRITE_FAIL      0x09     // Write failure. 
.................... #define RC_READ_FAIL       0x0A     // Read failure. 
.................... #define RC_LOW_VOLTAGE     0x0B     // Voltage check failed. 
.................... #define RC_NO_RESOURCES    0x0C     // No resources (max # services active) 
.................... #define RC_INCOMPLETE_JOIN 0x0D     // Incomplete join information. 
.................... #define RC_NOT_FOUND       0x0E     // Parameter not found. 
.................... #define RC_INVALID_VALUE   0x0F     // Invalid value. 
....................  
....................  
.................... // Parameter Types 
.................... #define PARAM_MACADDR      0x01     // setNV, getNV 
.................... #define PARAM_JOINKEY      0x02     // setNV 
.................... #define PARAM_NETWORKID    0x03     // setNV, getNV 
.................... #define PARAM_TXPOWER      0x04     // set, setNV, getNV 
.................... #define PARAM_POWERINFO    0x05     // setNV, getNV 
.................... #define PARAM_JOINDUTY     0x06     // set 
....................                                     // Allows micro to control  ratio of listen 
....................                                     //  to sleep time during network search 
.................... #define PARAM_BATTLIFE     0x07     // set 
....................                                     // Allows micro to update the remaining  
....................                                     //  battery life that mote reports to mgr 
.................... #define PARAM_SERVICE      0x08     // set. get  
....................                                     // Allows device to initiate service request 
....................                                     //  or update an existing svc 
.................... #define PARAM_SPECIAL1     0x08     // setnv for special join timing, 1st param 
.................... #define PARAM_SPECIAL2     0x09     // setnv for special join timing, 2nd param 
.................... #define PARAM_EVENTMASK    0x0B     // set 
....................                                     // Allows micro to disable events that may  
....................                                     //  be sent in the mote's event notification 
.................... #define PARAM_MOTEINFO     0x0C     // get 
....................                                     // Gets static info about mote hw and sw 
.................... #define PARAM_NETWORKINFO  0x0D     // get 
....................                                     // Gets mote's current net-related params 
.................... #define PARAM_MOTESTATUS   0x0E     // get 
....................                                     // Gets  mote's state and  
....................                                     //  frequently changing information. 
.................... #define PARAM_TIME         0x0F     // get 
.................... #define PARAM_CHARGE       0x10     // get 
....................                                     // Gets  mote's charge consumption. 
.................... #define PARAM_RADIOSTATSRX 0x11     // get 
....................                                     // Gets results of the mote radio rx test 
.................... #define PARAM_TTL          0x13     // get 
....................                                     // Gets "time to live" 
.................... #define PARAM_OTAPLOCK     0x15     // setNV, getNV 
....................                                     // Over-the-air-programming lockout control 
....................  
....................  
.................... // re get service: Service State - note Bit7=0 for no service pending 
.................... //                                          Bit7=1 for service pending 
.................... #define SVCSTATE_INACTIVE        0x00 
.................... #define SVCSTATE_ACTIVE          0x01 
.................... #define SVCSTATE_REQUESTED       0x02 
....................  
.................... // re get/set service: Service Request Flags Bitmask Values 
.................... #define SVCFLAGS_SOURCE          0x01     // Mote is source of data generated. 
.................... #define SVCFLAGS_SINK            0x02     // Mote is receiver of data. 
.................... #define SVCFLAGS_INTERMITTENT    0x04     // Intermittent traffic  
....................                                           //  (as opposed to regular reporting). 
....................  
.................... // Application domain values 
.................... #define APPDOMAIN_PUBLISH        0x00 
.................... #define APPDOMAIN_EVENT          0x01  
.................... #define APPDOMAIN_MAINTENANCE    0x02  
.................... #define APPDOMAIN_BLOCKXFER      0x03 
....................  
.................... // Mote Status values 
.................... #define MOTESTATE_INIT           0x00     // Mote is  booting. 
.................... #define MOTESTATE_IDLE           0x01     // Mote is accepting config cmds.   
....................                                           //  Upon receiving a join cmd, mote  
....................                                           //  moves into the Searching state. 
....................                                           //  Idle state is low power state. 
.................... #define MOTESTATE_SEARCHING      0x02     // Motes rcvr is on with a  
....................                                           //  configurable duty cycle while 
....................                                           //  mote is actively searching for net.  
.................... #define MOTESTATE_NEGOTIATING    0x03     // Mote has detected a network  
....................                                           //  and is attempting to connect. 
.................... #define MOTESTATE_CONNECTED      0x04     // Mote has joined the net 
.................... #define MOTESTATE_OPERATIONAL    0x05     // Mote has links to both net mgr and 
....................                                           //  gateway; ready to send data. 
.................... #define MOTESTATE_DISCONNECTED   0x06     // Mote is disconnected. 
.................... #define MOTESTATE_RADIOTEST      0x07 
.................... #define MOTESTATE_PROMISCUOUS    0x08 
.................... #define MOTESTATE_UNKNOWN        0xFF 
....................  
.................... // mote alarms bit masks 
.................... #define ALARMS_NVERROR           0x01        // Non-volatile error. 
.................... #define ALARMS_LOW_VOLTAGE       0x02        // Mote voltage too low. 
.................... #define ALARMS_OTP               0x04        // One time programmable error 
....................  
....................  
.................... // re get POWERINFO: power source values 
.................... #define PWRSOURCE_LINE           0x00 
.................... #define PWRSOURCE_BATTERY        0x01 
.................... #define PWRSOURCE_SCAVENGE       0x02 
....................  
.................... // re set/get txpower 
.................... #define TXPOWER_MIN              -2       // minimum power; PA off*/ 
.................... #define TXPOWER_MAX              +8       // maximum power; PA on 
....................  
.................... // serviceIndication event codes 
.................... #define SVC_CREATED_UPDATED      0x00 
.................... #define SVC_DELETED              0x01 
.................... #define SVC_REJECTED             0x02 
.................... #define SVC_DELAYED_RESP         0x03 
....................  
.................... // serviceIndication Network Manager Codes 
.................... #define MGRCODE_SUCCESS             0     // no errors 
.................... #define MGRCODE_PARAM_TOOSMALL      4     // ERR: passed param too small 
.................... #define MGRCODE_BYTES_TOOFEW        5     // ERR: too few data bytes rcvd 
.................... #define MGRCODE_DEVICE_ERR          6     // ERR: device-specific cmd error 
.................... #define MGRCODE_SETNEAREST          8     // WARN: set to nearest possible val 
.................... #define MGRCODE_RESTRICTED          16    // ERR: access restricted 
.................... #define MGRCODE_BUSY                32    // ERR: network manager is busy  
.................... #define MGRCODE_DELAYED_ATTEMPT     33    // ERR: delayed response initiated 
....................                                           //      mgr will attempt to add links 
.................... #define MGRCODE_DENIED              65    // ERR: service request denied 
.................... #define MGRCODE_UNKNOWN_SVC         66    // ERR: unknown service flag 
.................... #define MGRCODE_UNKNOWN_APPDOMAIN   67    // ERR: unknown application domain 
.................... #define MGRCODE_UNKNOWN_NICKNAME    68    // ERR: unknown nickname 
....................  
.................... // re set batteryLife 
.................... #define PWRSTAT_NOMINAL             0x00 
.................... #define PWRSTAT_LOW                 0x01 
.................... #define PWRSTAT_CRIT_LOW            0x02 
.................... #define PWRSTAT_RECHARG_LOW         0x03 
.................... #define PWRSTAT_RECHARG_HIGH        0x04 
....................  
.................... #define BOOT_EVENT               0x01010101  // & with new_events_rcvd to 
....................                                              //  determine if boot event 
....................                                              //  occurred 
.................... #define ALARMS_EVENT             0x02020202 
.................... #define TIME_EVENT               0x04040404  // & with new_events_rcvd to 
....................                                              //  determine if UTC time ref 
....................                                              //  from mote has changed 
.................... #define JOIN_FAIL_EVENT          0x08080808 
.................... #define DISCONNECTED_EVENT       0x10101010 
.................... #define OPERATIONAL_EVENT        0x20202020  // mote has gateway to send data 
.................... #define CONFIG_EVENT             0x40404040 
....................  
....................  
.................... // EVENTMASK bit definitions 
.................... #define EVENTMASK_BOOT           0x01        // Mote booted up. 
.................... #define EVENTMASK_ALARMS         0x02        // Value of alarms field changed. 
.................... #define EVENTMASK_TIMECHANGE     0x04        // UTC time reference changed.     
.................... #define EVENTMASK_JOINFAIL       0x08        // Join operation failed. 
.................... #define EVENTMASK_DISCONNECT     0x10        // Mote has disconnected. 
.................... #define EVENTMASK_OPERATIONAL    0x20        // Mote has gateway to send data. 
.................... #define EVENTMASK_CONFIG         0x40        // Write has changed mote config. 
....................  
.................... //  
.................... // #define WRITEPROTECT_DISABLED    0x0         // bit 0 only 
.................... // #define WRITEPROTECT_ENABLED     0x1         // bit 0 only 
.................... // #define WRITEPROTECT_MASK        0x1 
....................  
.................... // FLAG bit masks & defines 
.................... //#define FLAG_TYPE_MASK          0x01 
.................... #define FLAG_TYPE_REQUEST           0x04     // from micro to mote re get/set 
....................                                              //  and re join, reset, etc 
.................... #define FLAG_TYPE_REQUEST2          0x05 
.................... #define FLAG_SEND_REQUEST           0x04     // from micro to mote with send 
....................                                              //  request only 
.................... #define FLAG_TYPE_TEST              0x00     // from micro to mote re 
....................                                              //  testradiorx and testradiotx 
.................... #define FLAG_MOTE_INDICATION        0x00     // from mote to micro re 
....................                                              //  indications: event, service, 
....................                                              //  time 
.................... #define FLAG_TYPE_RESPONSE          0x01 
.................... #define FLAG_MOTECMD_RESPONSE       0x05     // from mote to micro after 
....................                                              //  micro-initiated command 
....................                                              //  e.g. join, reset, send 
.................... #define FLAG_MICROIND_RESPONSE      0x05     // from micro to mote after 
....................                                              //  mote indication to micro 
....................                                              //  time/service/event/data 
.................... #define FLAG_SET_RESPONSE           0x05     // from mote to micro after set 
.................... #define FLAG_GET_RESPONSE           0x05     // from mote to micro after get 
....................                                              //  TEST THIS 
....................  
.................... #define FLAG_ID                     0x02 
.................... #define FLAG_ID_IGNORE              0x04 
.................... #define FLAG_END2END_RESPONSE       0x80 
.................... #define FLAG_TRANSPORT_TYPE_MASK    0x40 
....................  
....................  
.................... #define FLAG_NV_ONLY                   ~0x80 
.................... #define FLAG_NV_RAM                    0x80 
....................  
....................  
.................... // #define WRITE_PROTECT_MODE_OFF     0x00 // write allowed 
.................... // #define WRITE_PROTECT_MODE_ON      0x01 // write not allowed 
....................  
.................... // packet priorities 
.................... #define PRIORITY_LOW    0x00 
.................... #define PRIORITY_MED    0x01 
.................... #define PRIORITY_HI     0x02 
....................  
.................... // Pack on one byte boundaries because we "type cast" the data structures 
.................... //  to a destination buffer (array of bytes). 
....................  
.................... /*  
.................... //Structure Declarations 
.................... #define DUST_DN2500_HEADER  \ 
....................     uint8_t cmd;     \ 
....................     uint8_t len_pkt; \ 
....................     uint8_t flags; 
....................  
....................  
.................... // A structure defined like this represents the first 4 bytes of  
.................... //  send, join, disconnect, reset, sleep, testradioTX/RX, clearNV  
.................... //  (cmd types 5,6,7,8,9,B,C,10) 
.................... #define DUST_DN2500_HEADER_RESPONSE    \ 
....................     uint8_t cmd;     \ 
....................     uint8_t len_pkt; \ 
....................     uint8_t flags;   \ 
....................     uint8_t result; 
....................      
.................... // A structure defined like this represents the first 4 bytes of all  
.................... //  set, get, setNV, getNV responses (cmd types 1,2,3,4) 
.................... #define DUST_DN2500_PARAM_RESPONSE  \ 
....................     uint8_t cmd;     \ 
....................     uint8_t len_pkt; \ 
....................     uint8_t flags;   \ 
....................     uint8_t result;  \ 
....................     uint8_t parameter_type;        /* DUST_DN2500_CMD_[SET|GET]_PARAM_*  
.................... */ 
....................  
.................... typedef union _mote_to_micro 
.................... // cmd types 1,2,3,4;  5,6,7,8,9,B,C,10;  D,E,F,81 
.................... // get/set; send/join/discon/reset/sleep/testradio/clrNV;  time/svc/event/data  
.................... { 
....................    char      dust_rcvd[MAX_DATA_RCVD];    // THIS is the buffer for unstuffed 
....................                                           //  stripped received data 
....................    struct _set_param_response 
....................    // for set txPower, joinDutyCycle, batteryLife, eventMask 
....................    // for setNV macAddress, networkID, txPower, joinKey, powerInfo, OTAPlockout 
....................    //  and special1 and special2 
....................    // Mote response to micro after most set and setNV commands 
....................    { 
....................       uint8_t     cmd;                 // CMD_SET or CMD_SETNV 
....................       uint8_t     len_pkt;             // always 0x01   
....................       uint8_t     flags;               // expect FLAG_SET_RESPONSE 
....................       uint8_t     result;              // RC_* 
....................       uint8_t     param_type;          // PARAM_TXPOWER, PARAM_JOINTDUY, (set) 
....................                                        // PARAM_BATTLIFE, PARAM_EVENTMASK (set) 
....................                                        // PARAM_MACADDR, PARAM_NETWORKID, (setNV) 
....................                                        // PARAM_TXPOWER, PARAM_JOINKEY, (setNV)  
....................                                        // PARAM_POWERINFO, PARAM_OTAPLOCK (setNV) 
....................                                        // PARAM_SPECIAL1, PARAM_SPECIAL2 
....................    }  set_param_response; 
....................     
....................    struct _set_service_response 
....................    // Mote respnse to micro after set service ONLY 
....................    { 
....................       uint8_t     cmd;                 // CMD_SET 
....................       uint8_t     len_pkt;             // always 0x02 
....................       uint8_t     flags;               // expect FLAG_SET_RESPONSE 
....................       uint8_t     result;              // RC_* 
....................       uint8_t     param_type;          // PARAM_SERVICE 
....................       uint8_t     rem_svc_entries; 
....................    }  set_service_response; 
....................     
....................     struct _get_service_response  
....................    { 
....................       uint8_t     cmd;                 // CMD_GET 
....................       uint8_t     len_pkt;             // always 0x0B 
....................       uint8_t     flags;               // expect FLAG_GET_RESPONSE 
....................       uint8_t     result;              // RC_* 
....................       uint8_t     param_type;          // PARAM_SERVICE 
....................       uint8_t     svc_index; 
....................       uint8_t     svc_state;           // SVCSTATE_* 
....................       uint8_t     svc_flags;           // SVCRQST_* 
....................       uint8_t     app_domain;          // APPDOMAIN_* 
....................       uint16_t    destaddr;            // always 0xF981 
....................       uint32_t    time;                // Period/latency: intermittent flag set 
....................    } get_service_response; 
....................     
....................    struct _get_moteinfo_response  
....................    { 
....................       uint8_t     cmd;                 // CMD_GET 
....................       uint8_t     len_pkt;             // always 0x11 
....................       uint8_t     flags;               // expect FLAG_GET_RESPONSE 
....................       uint8_t     result;              // RC_* 
....................       uint8_t     param_type;          // PARAM_MOTEINFO 
....................       uint8_t     api_version; 
....................       uint8_t     serial_number[8]; 
....................       uint8_t     hw_model; 
....................       uint8_t     hw_version; 
....................       uint8_t     sw_major_ver; 
....................       uint8_t     sw_minor_ver; 
....................       uint8_t     sw_patch; 
....................       uint16_t    sw_build; 
....................    }  get_moteinfo_response; 
....................  
....................    struct _get_networkinfo_response 
....................    { 
....................       uint8_t     cmd;                 // CMD_GET 
....................       uint8_t     len_pkt;             // always 0x0D 
....................       uint8_t     flags;               // expect FLAG_GET_RESPONSE 
....................       uint8_t     result;              // RC_* 
....................       uint8_t     param_type;          // PARAM_NETWORKINFO 
....................       uint8_t     macaddr[8]; 
....................       uint16_t    mote_id; 
....................       uint16_t    network_id; 
....................    }  get_networkinfo_response; 
....................  
....................    struct _get_motestatus_response 
....................    { 
....................       uint8_t     cmd;                 // CMD_GET 
....................       uint8_t     len_pkt;             // always 0x0B 
....................       uint8_t     flags;               // expect FLAG_GET_RESPONSE 
....................       uint8_t     result;              // RC_* 
....................       uint8_t     param_type;          // PARAM_MOTESTATUS 
....................       uint8_t     mote_state;          // MOTESTATE_* 
....................       uint8_t     mote_state_reason;   // Reserved -- ignore 
....................       uint16_t    change_counter; 
....................       uint8_t     number_of_parents; 
....................       uint32_t    mote_alarms;         // ALARMS_* 
....................       uint8_t     reserved; 
....................    }  get_motestatus_response; 
....................  
....................    struct _get_time_response 
....................    { 
....................       uint8_t     cmd;                 // CMD_GET 
....................       uint8_t     len_pkt;             // always 0x10 
....................       uint8_t     flags;               // expect FLAG_GET_RESPONSE 
....................       uint8_t     result;              // RC_* 
....................       uint8_t     param_type;          // PARAM_TIME 
....................       uint32_t    utc_sec; 
....................       uint32_t    utc_usec; 
....................       uint8_t     asn[5];              // Absolute Slot No. (10msec slots since 
....................                                        //  boot). 
....................       uint16_t    asn_offset;          // usec into current slot number  
....................    }  get_time_response; 
....................     
....................    struct _get_charge_response 
....................    { 
....................       uint8_t     cmd;                 // CMD_GET 
....................       uint8_t     len_pkt;             // always 0x0B 
....................       uint8_t     flags;               // expect FLAG_GET_RESPONSE 
....................       uint8_t     result;              // RC_* 
....................       uint8_t     param_type;          // PARAM_CHARGE 
....................       uint32_t    charge_mC;           // charge since last reset 
....................       uint32_t    uptime_sec;          // uptime since last reset 
....................       int8_t      temp_celsius; 
....................       uint8_t     temp_frac_celsius;   // Temperature in 1/255 of Celsius 
....................    }  get_charge_response; 
....................     
....................    struct _get_testrx_response 
....................    { 
....................       uint8_t     cmd;                 // CMD_GET 
....................       uint8_t     len_pkt;             // always 0x05 
....................       uint8_t     flags;               // expect FLAG_GET_RESPONSE 
....................       uint8_t     result;              // RC_* 
....................       uint8_t     param_type;          // PARAM_RADIOSTATSRX 
....................       uint16_t    num_of_received_packets; 
....................       uint16_t    num_of_recep_failures; 
....................    }  get_testrx_response; 
....................   
....................    struct _getNV_macaddr_response 
....................    { 
....................       uint8_t     cmd;                 // CMD_GETNV 
....................       uint8_t     len_pkt;             // always 0x09 
....................       uint8_t     flags;               // expect FLAG_GET_RESPONSE 
....................       uint8_t     result;              // RC_* 
....................       uint8_t     param_type;          // PARAM_MACADDR 
....................       uint8_t     macaddr[8]; 
....................    }  getNV_macaddr_response; 
....................     
....................    struct _getNV_networkid_response 
....................    { 
....................       uint8_t     cmd;                 // CMD_GETNV 
....................       uint8_t     len_pkt;             // always 0x03 
....................       uint8_t     flags;               // expect FLAG_GET_RESPONSE 
....................       uint8_t     result;              // RC_NETWORKID 
....................       uint8_t     param_type;          // PARAM_NETWORKID 
....................       uint16_t    network_id; 
....................    }  getNV_networkid_response; 
....................     
....................    struct _getNV_txpower_response 
....................    { 
....................       uint8_t     cmd;                 // CMD_GETNV 
....................       uint8_t     len_pkt;             // always 0x02 
....................       uint8_t     flags;               // expect FLAG_GET_RESPONSE 
....................       uint8_t     result;              // RC_* 
....................       uint8_t     param_type;          // PARAM_TXPOWER 
....................       uint8_t     txpower; 
....................    }  getNV_txpower_response; 
....................     
....................    struct _getNV_powerinfo_response 
....................    { 
....................       uint8_t     cmd;                 // CMD_GETNV 
....................       uint8_t     len_pkt;             // always 0x0C 
....................       uint8_t     flags;               // expect FLAG_GET_RESPONSE 
....................       uint8_t     result;              // RC_* 
....................       uint8_t     param_type;          // PARAM_POWERINFO 
....................       uint8_t     power_source;        // PWRSOURCE_* 
....................       uint16_t    discharge_current_uA; 
....................       uint32_t    discharge_time_sec; 
....................       uint32_t    recharge_time_sec;     
....................    }  getNV_powerinfo_response; 
....................  
....................    struct _getnv_otaplock_response 
....................    { 
....................       uint8_t     cmd;                 // CMD_GETNV 
....................       uint8_t     len_pkt;             // always 0x02 
....................       uint8_t     flags;               // expect FLAG_GET_RESPONSE 
....................       uint8_t     result;              // RC_* 
....................       uint8_t     param_type;          // PARAM_OTAPLOCK 
....................       uint8_t     otaplock; 
....................    }  getnv_otaplock_response; 
....................     
....................    struct _cmd_response 
....................    { 
....................       uint8_t     cmd;                 // CMD_SEND, CMD_JOIN, 
....................                                        // CMD_DISCONNECT, CMD_RESET 
....................                                        // CMD_SLEEP, CMD_TESTRADIOTX, 
....................                                        // CMD_TESTRADIORX, CMD_CLEARNV 
....................       uint8_t     len_pkt;             // always 0x00 
....................       uint8_t     flags;               // always FLAG_MOTECMD_RESPONSE 
....................       uint8_t     result;              // RC_* 
....................    }  cmd_response; 
....................     
....................    struct _time_indication 
....................    // this is what you get from mote when you toggle _DUST_TIME 
....................    { 
....................       uint8_t     cmd;                 // CMD_TIME 
....................       uint8_t     len_pkt;             // always 0x0F 
....................       uint8_t     flags;               // See tables 98 and 1***************** 
....................       uint32_t    utc_sec; 
....................       uint32_t    utc_usec; 
....................       uint8_t     asn[5];              // Absolute Slot No. (10msec slots since 
....................                                        //  boot. 
....................       uint16_t    asn_offset;          // usec into current slot number 
....................    }  time_indication; 
....................     
....................    struct _service_indication 
....................    { 
....................       uint8_t     cmd;                 // CMD_SERVICE 
....................       uint8_t     len_pkt;             // always 0x0C 
....................       uint8_t     flags;               // See tables 98 and 1***************** 
....................       uint8_t     event_code;          // SVC_* 
....................       uint8_t     mgr_code;            // MGRCODE_* 
....................       uint8_t     svc_index; 
....................       uint8_t     svc_state;           // SVCSTATE_* 
....................       uint8_t     svc_flags;           // SVCRQST_* 
....................       uint8_t     app_domain;          // APPDOMAIN_* 
....................       uint16_t    destaddr;            // always 0xF981 
....................       uint32_t    time;                // Period/latency: intermittent flag set 
....................    }  service_indication; 
....................  
....................    struct _events_indication 
....................    { 
....................       uint8_t     cmd;                 // CMD_EVENT 
....................       uint8_t     len_pkt;             // always 0x09 
....................       uint8_t     flags;               // See tables 98 and 1***************** 
....................       uint32_t    new_events;          // EVENTMASK_* (?) 
....................       uint8_t     mote_state;          // MOTESTATE_* 
....................       uint32_t    mote_alarms;         // ALARMS_* 
....................    }  events_indication; 
....................     
....................    struct _advert_indication 
....................    { 
....................       uint8_t     cmd;                 // CMD_EVENT 
....................       uint8_t     len_pkt;             // always 0x09 
....................       uint8_t     flags; 
....................       uint16_t    network_id; 
....................       uint16_t    mote_id; 
....................       uint8_t     rssi;                // rcvd signal strength 
....................       uint8_t     hop_depth;           // (join priority) 
....................    }  advert_indication; 
....................     
....................    struct _data_from_net 
....................    { 
....................       uint8_t     cmd;                 // CMD_DATA 
....................       uint8_t     len_pkt;             // always len_data + 4 
....................       uint8_t     flags;               // See tables 98 and 1***************** 
....................       uint16_t    sourceaddr;          // always 0xF981 
....................       uint8_t     sequence_num;        // sequence number 
....................       uint8_t     len_data;            // packet data length (<=MAX_USER_DATA_SIZE) 
....................       uint8_t     data[MAX_USER_DATA_SIZE]; 
....................                                        // actual received data 
....................    }  data_from_net; 
.................... }  mote_to_micro;  
....................  
.................... /* 
.................... #define dust_dn2500_response_t                              dust_dn2500_param_response_t 
.................... #define dust_dn2500_set_param_tx_power_response_t           dust_dn2500_param_response_t 
.................... #define dust_dn2500_set_param_join_duty_cycle_response_t    dust_dn2500_param_response_t 
.................... #define dust_dn2500_set_param_battery_life_response_t       dust_dn2500_param_response_t 
.................... #define dust_dn2500_set_param_event_mask_response_t         dust_dn2500_param_response_t 
.................... #define dust_dn2500_set_param_write_protect_response_t      dust_dn2500_param_response_t 
.................... #define dust_dn2500_setnv_mac_address_response_t            dust_dn2500_param_response_t 
.................... #define dust_dn2500_setnv_network_id_response_t             dust_dn2500_param_response_t 
.................... #define dust_dn2500_setnv_tx_power_response_t               dust_dn2500_param_response_t 
.................... #define dust_dn2500_setnv_joinkey_response_t                dust_dn2500_param_response_t 
.................... #define dust_dn2500_setnv_otap_lockout_response_t           dust_dn2500_param_response_t 
.................... #define dust_dn2500_setnv_powerinfo_response_t              dust_dn2500_param_response_t 
.................... #define dust_dn2500_setnv_ttl_response_t                    dust_dn2500_param_response_t 
.................... #define dust_dn2500_send_response_t                         dust_dn2500_cmd_response_t 
.................... #define dust_dn2500_join_response_t                         dust_dn2500_cmd_response_t 
.................... #define dust_dn2500_search_response_t                       dust_dn2500_cmd_response_t 
.................... #define dust_dn2500_disconnect_response_t                   dust_dn2500_cmd_response_t 
.................... #define dust_dn2500_reset_response_t                        dust_dn2500_cmd_response_t 
.................... #define dust_dn2500_lowPowerSleep_response_t                dust_dn2500_cmd_response_t 
.................... #define dust_dn2500_testRadioTx_response_t                  dust_dn2500_cmd_response_t 
.................... #define dust_dn2500_testRadioRx_response_t                  dust_dn2500_cmd_response_t 
.................... #define dust_dn2500_clearnv_response_t                      dust_dn2500_cmd_response_t 
.................... #define dust_dn2500_set_param_hart_device_status_response_t dust_dn2500_param_response_t 
.................... #define dust_dn2500_set_param_hart_device_info_response_t   dust_dn2500_param_response_t 
.................... #define dust_dn2500_setnv_hart_antenna_gain_response_t      dust_dn2500_param_response_t 
....................  
.................... // MICRO TO MOTE RESPONSES AFTER TIME/SERVICE/EVENTS INDICATION OR DATA_FROM_NET 
.................... #define dust_dn2500_time_response_t    dust_dn2500_cmd_response_t 
.................... #define dust_dn2500_service_response_t dust_dn2500_cmd_response_t 
.................... #define dust_dn2500_events_response_t  dust_dn2500_cmd_response_t 
.................... #define dust_dn2500_data_response_t    dust_dn2500_cmd_response_t 
....................  
....................  
.................... struct dust_dn2500_cmd_response_t { 
....................     DUST_DN2500_HEADER_RESPONSE 
.................... }; 
.................... struct dust_dn2500_header_t { 
....................     DUST_DN2500_HEADER 
.................... }; 
....................  
.................... // WHAT UP WITH THIS....  hw/sw incompatibilities insurance?? -- ignore for now 
.................... // points to any extra bytes received that are not identified as a "dust" packet  
.................... struct dust_dn2500_unknown_data_t { 
....................    uint8_t*    data; 
....................    uint8_t     len; 
.................... }; 
.................... */ 
....................  
.................... // uint8_t     macaddr[8]; 
.................... uint8_t     joinkey[MAX_JOINKEY_SIZE]={0x44,0x55,0x53,0x54,0x4E,0x45,0x54,0x57,0x4F,0x52,0x4B,0x53,0x52,0x4F,0x43,0x4B}; 
.................... // need these declaration for pkgen_setnv_macaddr 
....................  
.................... /* 
.................... // The following structures exist in RAM as 'global'.  No need to pass 
.................... //  the structure to the packet generation routines defined below 
.................... struct _set_battlife_struct 
.................... // setup up battlife_days and pwrstat prior to pkgen_set_battlife() call 
.................... { 
....................    uint16_t    battlife_days; 
....................    uint8_t     pwrstat;                // PWRSTAT_* 
.................... }  set_battlife_struct; 
....................  
.................... struct _setnv_powerinfo_struct  
.................... // setup pwrsource, discharge_current_uA, discharge_time_sec, 
.................... //  and recharge_time_sec prior to pkgen_setnv_powerinfo() 
.................... { 
....................    uint8_t     pwrsource;              // PWRSOURCE_* 
....................    uint16_t    discharge_current_uA; 
....................    uint32_t    discharge_time_sec; 
....................    uint32_t    recharge_time_sec;     
.................... }  setnv_powerinfo_struct; 
....................  
.................... struct _set_svc_struct 
.................... // setup  svc_index; request_flags, app_domain and time  
.................... //  pwrstat prior to pkgen_set_battlife() call.  No need to setup dest_address 
.................... { 
....................    uint8_t     svc_index; 
....................    uint8_t     request_flags;          // SVCRQST_* 
....................    uint8_t     app_domain;             // APPDOMAIN_* 
....................    uint16_t    destaddr;               // always 0xF981 
....................                                        //  set properly in pkgen_set_service() 
....................    uint32_t    time;                   // Period/latency: intermittent flag set 
.................... }  set_svc_struct; 
....................  
.................... struct testradiotx_struct 
.................... // setup channel and num_packets prior to pkgen_testradiotx() call 
.................... { 
....................    uint8_t     channel;                // 0-15 
....................    uint16_t    num_packets; 
.................... }  testradiotx_struct; 
....................  
.................... struct testradiorx_struct 
.................... // setup channel and time_sec prior to pkgen_testradiorx() call 
.................... { 
....................    uint8_t     channel;                // 0-15  
....................    uint16_t    time_sec;               // rcv packets for this many secs 
.................... }  testradiorx_struct; 
.................... */ 
....................  
....................  
.................... /* ------------------------------------------------------------------------- */ 
.................... #define __swap32(src) (((uint32_t)src<<24)|(((uint32_t)src&0xff00)<<8)| \ 
....................                            (((uint32_t)src>>8)&0xff00)|((uint32_t)src>>24)) 
.................... #define __swap16(src) (((uint16_t)src<<8)|((uint16_t)src>>8)) 
.................... /* ------------------------------------------------------------------------- */ 
....................  
....................  
.................... /* ----------------------  Packet Generation Macros ------------------------ */ 
....................  
.................... /* setParameter<txPower> Request */ 
.................... #define pkgen_set_txpower(power) { \ 
....................     uint8_t prefix[] = {CMD_SET,0x02/*length*/,FLAG_TYPE_REQUEST,PARAM_TXPOWER}; \ 
....................     uint8_t pw       = power; \ 
....................     dust_hdlc_pkgen(prefix, 4, (uint8_t*)&pw, 1); \ 
.................... } 
....................  
.................... /* setParameter<joinDutyCycle> Request */ 
.................... #define pkgen_set_joinduty(cycle) { \ 
....................     uint8_t prefix[] = {CMD_SET,0x02/*length*/,FLAG_TYPE_REQUEST,PARAM_JOINDUTY}; \ 
....................     uint8_t cy       = cycle; \ 
....................     dust_hdlc_pkgen(prefix, 4, (uint8_t*)&cy, 1); \ 
.................... } 
....................  
.................... /* setParameter<batteryLife> Request */ 
.................... // structure is a declared global 
.................... #define pkgen_set_battlife() { \ 
....................     uint8_t  prefix[] = {CMD_SET,0x04/*length*/,FLAG_TYPE_REQUEST,PARAM_BATTLIFE}; \ 
....................     set_battlife_struct.battlife_days = __swap16(set_battlife_struct.battlife_days); \ 
....................     dust_hdlc_pkgen(prefix, 4, (uint8_t*)&set_battlife_struct, 3); \ 
.................... } 
....................  
.................... /* setParameter<service> Request */ 
.................... // structure is a declared global 
.................... #define pkgen_set_service() { \ 
....................     uint8_t  prefix[] = {CMD_SET,0x0A/*length*/,FLAG_TYPE_REQUEST,PARAM_SERVICE}; \ 
....................     set_svc_struct.destaddr = DESTADDR_SWAPPED; \ 
....................     set_svc_struct.time         = __swap32(set_svc_struct.time); \ 
....................     dust_hdlc_pkgen(prefix, 4, (uint8_t*)&set_svc_struct, 9); \ 
.................... } 
....................  
.................... /* setParameter<eventMask> Request */ 
.................... // eventmask is one of EVENTMASK_* 
.................... #define pkgen_set_eventmask(eventmask) { \ 
....................     uint8_t  prefix[] = {CMD_SET,0x05/*length*/,FLAG_TYPE_REQUEST,PARAM_EVENTMASK}; \ 
....................     uint32_t dstem    = __swap32(eventmask); \ 
....................     dust_hdlc_pkgen(prefix, 4, (uint8_t*)&dstem, 4); \ 
.................... } 
....................  
.................... /* getParameter<moteInfo> Request */ 
.................... #define pkgen_get_moteinfo() { \ 
....................     uint8_t cmd[] = {CMD_GET,0x01/*length*/,FLAG_TYPE_REQUEST,PARAM_MOTEINFO}; \ 
....................     dust_hdlc_pkgen((char*)(NULL), 0, cmd, 4); \ 
.................... } 
....................   
.................... /* getParameter<networkInfo> Request */ 
.................... #define pkgen_get_networkinfo() { \ 
....................     uint8_t cmd[] = {CMD_GET,0x01/*length*/,FLAG_TYPE_REQUEST,PARAM_NETWORKINFO}; \ 
....................     dust_hdlc_pkgen((char*)(NULL), 0, cmd, 4); \ 
.................... } 
....................  
.................... /* getParameter<moteStatus> Request */ 
.................... #define pkgen_get_motestatus() { \ 
....................     uint8_t cmd[] = {CMD_GET,0x01/*length*/,FLAG_TYPE_REQUEST,PARAM_MOTESTATUS}; \ 
....................     dust_hdlc_pkgen((char*)(NULL), 0, cmd, 4); \ 
.................... } 
....................  
.................... /* getParameter<time> Request */ 
.................... #define pkgen_get_time() { \ 
....................     uint8_t cmd[] = {CMD_GET,0x01/*length*/,FLAG_TYPE_REQUEST,PARAM_TIME}; \ 
....................     dust_hdlc_pkgen((char*)(NULL), 0, cmd, 4); \ 
.................... } 
....................  
.................... /* getParameter<charge> Request */ 
.................... #define pkgen_get_charge() { \ 
....................     uint8_t cmd[] = {CMD_GET,0x01/*length*/,FLAG_TYPE_REQUEST,PARAM_CHARGE}; \ 
....................     dust_hdlc_pkgen((char*)(NULL), 0, cmd, 4); \ 
.................... } 
....................  
.................... /* getParameter<testRadioRxStats> Request */ 
.................... #define pkgen_get_radiostatsrx() { \ 
....................     uint8_t cmd[] = {CMD_GET,0x01/*length*/,FLAG_TYPE_REQUEST,PARAM_RADIOSTATSRX}; \ 
....................     dust_hdlc_pkgen((char*)(NULL), 0, cmd, 4); \ 
.................... } 
....................  
.................... /* getParameter<service> Request */ 
.................... #define pkgen_get_service(service_idx) { \ 
....................     uint8_t prefix[] = {CMD_GET,0x02/*length*/,FLAG_TYPE_REQUEST,PARAM_SERVICE}; \ 
....................     uint8_t idx      = svc_index; \ 
....................     dust_hdlc_pkgen(prefix, 4, (uint8_t*)&idx, 1); \ 
.................... } 
....................  
.................... /* setNVParameter<macAddress> Request */ 
.................... // macaddr array is declared 
.................... #define pkgen_setnv_macaddr() { \ 
....................     uint8_t prefix[]   = {CMD_SETNV,0x0D/*length*/,FLAG_TYPE_REQUEST, 0x00, 0x00, 0x00, 0x00, PARAM_MACADDR}; \ 
....................     dust_hdlc_pkgen(prefix, 8, macaddr, 8); \ 
.................... } 
....................  
.................... /* setNVParameter<networkID> Request */ 
.................... #define pkgen_setnv_networkid(networkid) { \ 
....................     uint8_t prefix[] = {CMD_SETNV,0x07/*length*/,FLAG_TYPE_REQUEST, 0x00, 0x00, 0x00, 0x00, PARAM_NETWORKID}; \ 
....................     uint16_t net_id  = networkid; \ 
....................     dust_hdlc_pkgen(prefix, 8, (uint8_t*)&net_id, 2); \ 
.................... } 
....................  
.................... /* setNVParameter<txPower> Request */ 
.................... #define pkgen_setnv_txpower(txpower) { \ 
....................     uint8_t prefix[] = {CMD_SETNV,0x06/*length*/,FLAG_TYPE_REQUEST, 0x00, 0x00, 0x00, 0x00, PARAM_TXPOWER}; \ 
....................     uint8_t dst_power  = txpower; \ 
....................     dust_hdlc_pkgen(prefix, 8, (uint8_t*)&dst_power, 1); \ 
.................... } 
....................  
.................... /* setNVParameter<joinKey> Request */ 
.................... // joinkey array is declared 
....................  
.................... #define pkgen_setnv_joinkey(joinkey) { \ 
....................     uint8_t prefix[]   = {CMD_SETNV,0x15/*length*/,FLAG_TYPE_REQUEST, 0x00, 0x00, 0x00, 0x00, PARAM_JOINKEY}; \ 
....................     dust_hdlc_pkgen(prefix, 8, joinkey, 16); \ 
.................... } 
....................  
.................... //#define pkgen_setnv_joinkey(joinkey) { \ 
.................... //      uint8_t prefix[]   = {CMD_SETNV,0x15/*length*/,FLAG_TYPE_REQUEST, 0x00, 0x00, 0x00, 0x00, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}; \ 
.................... //      dust_hdlc_pkgen(prefix, 8,,16); \ 
.................... //} 
....................  
....................  
.................... /* setNVParameter<powerInfo> Request */ 
.................... // structure is a declared global 
.................... #define pkgen_setnv_powerinfo() { \ 
....................     uint8_t prefix[] = {CMD_SETNV,0x10/*length*/,FLAG_TYPE_REQUEST, 0x00, 0x00, 0x00, 0x00, PARAM_POWERINFO}; \ 
....................     setnv_powerinfo_struct.discharge_current_uA     = __swap16(setnv_powerinfo_struct.discharge_current_uA); \ 
....................     setnv_powerinfo_struct.discharge_time_sec       = __swap32(setnv_powerinfo_struct.discharge_time_sec); \ 
....................     setnv_powerinfo_struct.recharge_time_sec        = __swap32(setnv_powerinfo_struct.recharge_time_sec); \ 
....................     dust_hdlc_pkgen(prefix, 8, (uint8_t*)&setnv_powerinfo_struct, 11); \ 
.................... }  
....................  
.................... /* setNVParameter<OTAPlockout> Request */ 
.................... #define pkgen_setnv_otaplock(lockout) { \ 
....................    uint8_t prefix[] = {CMD_SETNV,0x06/*length*/,FLAG_TYPE_REQUEST, 0x00, 0x00, 0x00, 0x00, PARAM_OTAPLOCK}; \ 
....................    uint8_t otaplock = lockout; \ 
....................    dust_hdlc_pkgen(prefix, 8, (uint8_t*)&otaplock, 1); \ 
.................... } 
....................  
.................... /* setNVParameter<SpecialJoinTimingParams> Request */ 
.................... #define pkgen_setnv_special1(special1) { \ 
....................    uint8_t prefix[] = {CMD_SETNV,0x07/*length*/,0x02, 0x67, 0x12, 0x04, 0x04, PARAM_SPECIAL1}; \ 
....................    uint16_t spec_param1  = special1; \ 
....................    dust_hdlc_pkgen(prefix, 8, (uint8_t*)&spec_param1, 2); \ 
.................... } 
....................  
.................... /* setNVParameter<SpecialJoinTimingParams> Request */ 
.................... #define pkgen_setnv_special2(special2) { \ 
....................    uint8_t prefix[] = {CMD_SETNV,0x07/*length*/,0x00, 0x67, 0x12, 0x04, 0x04, PARAM_SPECIAL2}; \ 
....................    uint16_t spec_param2 = special2; \ 
....................    dust_hdlc_pkgen(prefix, 8, (uint8_t*)&spec_param2, 2); \ 
.................... } 
....................  
.................... /* getNVParameter<macAddress> Request */ 
.................... #define pkgen_getnv_macaddr() { \ 
....................     uint8_t cmd[] = {CMD_GETNV,0x05/*length*/,FLAG_TYPE_REQUEST, 0x00, 0x00, 0x00, 0x00, PARAM_MACADDR}; \ 
....................     dust_hdlc_pkgen((char*)(NULL), 0, cmd, 8); \ 
.................... } 
....................  
.................... /* getNVParameter<networkID> Request */ 
.................... #define pkgen_getnv_networkid() { \ 
....................     uint8_t cmd[] = {CMD_GETNV,0x05/*length*/,FLAG_TYPE_REQUEST, 0x00, 0x00, 0x00, 0x00, PARAM_NETWORKID}; \ 
....................     dust_hdlc_pkgen((char*)(NULL), 0, cmd, 8); \ 
.................... } 
....................  
.................... /* getNVParameter<txPower> Request */ 
.................... #define pkgen_getnv_txpower() { \ 
....................     uint8_t cmd[] = {CMD_GETNV,0x05/*length*/,FLAG_TYPE_REQUEST, 0x00, 0x00, 0x00, 0x00, PARAM_TXPOWER}; \ 
....................     dust_hdlc_pkgen((char*)(NULL), 0, cmd, 8); \ 
.................... } 
....................  
.................... /* getNVParameter<powerInfo> Request */ 
.................... #define pkgen_getnv_powerinfo() { \ 
....................     uint8_t cmd[] = {CMD_GETNV,0x05/*length*/,FLAG_TYPE_REQUEST, 0x00, 0x00, 0x00, 0x00, PARAM_POWERINFO}; \ 
....................     dust_hdlc_pkgen((char*)(NULL), 0, cmd, 8); \ 
.................... } 
....................  
.................... /* getNVParameter<OTAPlockout> Request */ 
.................... #define pkgen_getnv_otaplock() { \ 
....................     uint8_t cmd[]   = {CMD_GETNV,0x05/*length*/,FLAG_TYPE_REQUEST, 0x00, 0x00, 0x00, 0x00, PARAM_OTAPLOCK}; \ 
....................     dust_hdlc_pkgen((char*)(NULL), 0, cmd, 8); \ 
.................... } 
....................  
.................... // command to mote to test the radio transmitter 
.................... // structure is a declared global 
.................... #define pkgen_testradiotx() { \ 
....................     uint8_t  prefix[] = {CMD_TESTRADIOTX, 3 /*payload length*/, FLAG_TYPE_TEST}; \ 
....................     testradiotx_struct.num_packets = __swap16(testradiotx_struct.num_packets); \ 
....................     dust_hdlc_pkgen(prefix, 3, (uint8_t*)&testradiotx_struct, 3); \ 
.................... } 
....................  
.................... #define pkgen_testradiorx() { \ 
....................     uint8_t  prefix[] = {CMD_TESTRADIORX, 3 /*payload length*/, FLAG_TYPE_TEST}; \ 
....................     testradiorx_struct.time_sec = __swap16(testradiorx_struct.time_sec); \ 
....................     dust_hdlc_pkgen(prefix, 3, (uint8_t*)&testradiorx_struct, 3); \ 
.................... } 
....................  
.................... /* Join Request */ 
.................... #define pkgen_join() { \ 
....................     uint8_t cmd[]   = {CMD_JOIN,0x00/*payload length*/,FLAG_TYPE_REQUEST}; \ 
....................     dust_hdlc_pkgen((char*)(NULL), 0, cmd, 3); \ 
.................... } 
....................  
.................... /* Disconnect Request */ 
.................... #define pkgen_disconnect() { \ 
....................     uint8_t cmd[]   = {CMD_DISCONNECT,0x00/*payload length*/,FLAG_TYPE_REQUEST}; \ 
....................     dust_hdlc_pkgen((char*)(NULL), 0, cmd, 3); \ 
.................... } 
....................  
.................... /* Reset Request */ 
.................... #define pkgen_reset() { \ 
....................     uint8_t cmd[]   = {CMD_RESET,0x00/*payload length*/,FLAG_TYPE_REQUEST}; \ 
....................     dust_hdlc_pkgen((char*)(NULL), 0, cmd, 3); \ 
.................... } 
....................  
.................... /* lowPowerSleep Request */ 
.................... #define pkgen_sleep() { \ 
....................     uint8_t cmd[]   = {CMD_SLEEP,0x00/*payload length*/,FLAG_TYPE_REQUEST}; \ 
....................     dust_hdlc_pkgen((char*)(NULL), 0, cmd, 3); \ 
.................... } 
....................  
.................... /* ClearNV Request */ 
.................... #define pkgen_clearnv() { \ 
....................     uint8_t cmd[]   = {CMD_CLEARNV,0x00/*payload length*/,FLAG_TYPE_REQUEST}; \ 
....................     ((char*)(NULL), 0, cmd, 3); \ 
.................... } 
....................  
.................... /* Search Request */ 
.................... #define pkgen_search() { \ 
....................     uint8_t cmd[]   = {CMD_SEARCH,0x00/*payload length*/,FLAG_TYPE_REQUEST}; \ 
....................     dust_hdlc_pkgen((char*)(NULL), 0, cmd, 3); \ 
.................... } 
....................  
.................... // MOTE command responses.  The micro sends a response to mote  
.................... //  after having received an indication or a data packet 
....................  
.................... #define pkgen_time_ind_response(result_fl) { \ 
....................     uint8_t prefix[] = {CMD_TIME,0x00};   \ 
....................     uint16_t r        = result_fl; \ 
....................     dust_hdlc_pkgen(prefix, 2, (uint8_t*)&r, 2); \ 
.................... } 
....................  
.................... #define pkgen_service_ind_response(result_fl) { \ 
....................     uint8_t prefix[] = {CMD_SERVICE,0x00}; \ 
....................     uint16_t r       = result_fl; \ 
....................     dust_hdlc_pkgen(prefix, 2, (uint8_t*)&r, 2);  \ 
.................... } 
....................  
.................... #define pkgen_event_ind_response(result_fl) { \ 
....................     uint8_t prefix[] = {CMD_EVENT,0x00};  \ 
....................     uint16_t r        = result_fl; \ 
....................     dust_hdlc_pkgen(prefix, 2, (uint8_t*)&r, 2); \ 
.................... } 
....................  
.................... #define pkgen_advert_ind_response(result_fl) { \ 
....................     uint8_t prefix[] = {CMD_ADVERT,0x00}; \ 
....................     uint16_t r       = result_fl; \ 
....................     dust_hdlc_pkgen(prefix, 2, (uint8_t*)&r, 2); \ 
.................... } 
....................  
.................... #define pkgen_data_rcvd_response(result_fl) { \ 
....................     uint8_t prefix[] = {CMD_DATA,0x00};  \ 
....................     uint16_t r       = result_fl; \ 
....................     dust_hdlc_pkgen(prefix, 2, (uint8_t*)&r, 2); \ 
.................... } 
....................  
.................... // Added by brian 
.................... #define pkgen_mote_ack() { \ 
....................  uint8_t cmd[]   = {(flags_rcvd+1),response_type}; \ 
....................  dust_hdlc_pkgen((cmd_rcvd << 8), 2, cmd, 2); \ 
.................... } 
....................     
.................... //  
.................... /* 
.................... struct dust_dn2500_t { 
....................  
....................     // SET Parameters Responses 
....................     int8_t (*set_param_tx_power_response)(void* handle, struct dust_dn2500_set_param_tx_power_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................     int8_t (*set_param_join_duty_cycle_response)(void* handle, struct dust_dn2500_set_param_join_duty_cycle_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................     int8_t (*set_param_battery_life_response)(void* handle, struct dust_dn2500_set_param_battery_life_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................     int8_t (*set_param_service_response)(void* handle, struct dust_dn2500_set_param_service_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................     int8_t (*set_param_hart_device_status_response)(void* handle, struct dust_dn2500_set_param_hart_device_status_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................     int8_t (*set_param_hart_device_info_response)(void* handle, struct dust_dn2500_set_param_hart_device_info_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................     int8_t (*set_param_event_mask_response)(void* handle, struct dust_dn2500_set_param_event_mask_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................     int8_t (*set_param_write_protect_response)(void* handle, struct dust_dn2500_set_param_write_protect_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................  
....................     int8_t (*get_param_mote_info_response)(void* handle, struct dust_dn2500_get_param_mote_info_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................     int8_t (*get_param_network_info_response)(void* handle, struct dust_dn2500_get_param_network_info_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................     int8_t (*get_param_mote_status_response)(void* handle, struct dust_dn2500_get_param_mote_status_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................     int8_t (*get_param_time_response)(void* handle, struct dust_dn2500_get_param_time_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................     int8_t (*get_param_charge_response)(void* handle, struct dust_dn2500_get_param_charge_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................     int8_t (*get_param_test_radio_rxstats_response)(void* handle, struct dust_dn2500_get_param_test_radio_rxstats_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................     int8_t (*get_param_service_response)(void* handle, struct dust_dn2500_get_param_service_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................  
....................     // Non-Volatile Parameter Responses 
....................     int8_t (*setnv_mac_address_response)(void* handle, struct dust_dn2500_setnv_mac_address_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................     int8_t (*setnv_network_id_response)(void* handle, struct dust_dn2500_setnv_network_id_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................     int8_t (*setnv_tx_power_response)(void* handle, struct dust_dn2500_setnv_tx_power_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................     int8_t (*setnv_joinkey_response)(void* handle, struct dust_dn2500_setnv_joinkey_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................     int8_t (*setnv_powerinfo_response)(void* handle, struct dust_dn2500_setnv_powerinfo_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................     int8_t (*setnv_ttl_response)(void* handle, struct dust_dn2500_setnv_ttl_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................     int8_t (*setnv_hart_antenna_gain)(void* handle, struct dust_dn2500_setnv_hart_antenna_gain_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................     int8_t (*setnv_otap_lockout)(void* handle, struct dust_dn2500_setnv_otap_lockout_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................  
....................     int8_t (*getnv_mac_address_response)(void* handle, struct dust_dn2500_getnv_mac_address_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................     int8_t (*getnv_network_id_response)(void* handle, struct dust_dn2500_getnv_network_id_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................     int8_t (*getnv_tx_power_response)(void* handle, struct dust_dn2500_getnv_tx_power_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................     int8_t (*getnv_powerinfo_response)(void* handle, struct dust_dn2500_getnv_powerinfo_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................     int8_t (*getnv_ttl_response)(void* handle, struct dust_dn2500_getnv_ttl_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................     int8_t (*getnv_hart_antenna_gain)(void* handle, struct dust_dn2500_getnv_hart_antenna_gain_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................     int8_t (*getnv_otap_lockout)(void* handle, struct dust_dn2500_getnv_otap_lockout_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................  
....................     // Command Responses 
....................     int8_t (*send_response)(void* handle, struct dust_dn2500_send_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................     int8_t (*join_response)(void* handle, struct dust_dn2500_join_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................     int8_t (*disconnect_response)(void* handle, struct dust_dn2500_disconnect_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................     int8_t (*search_response)(void* handle, struct dust_dn2500_search_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................     int8_t (*reset_response)(void* handle, struct dust_dn2500_reset_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................     int8_t (*lowPowerSleep_response)(void* handle, struct dust_dn2500_lowPowerSleep_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................     int8_t (*hartPayload_response)(void* handle, struct dust_dn2500_hartPayload_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................     int8_t (*testRadioTx_response)(void* handle, struct dust_dn2500_testRadioTx_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................     int8_t (*testRadioRx_response)(void* handle, struct dust_dn2500_testRadioRx_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................     int8_t (*clearnv_response)(void* handle, struct dust_dn2500_clearnv_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................  
....................     // MOTE commands sent to sensor processor 
....................     int8_t (*time_request)(void* handle, struct dust_dn2500_time_request_t* p, struct dust_dn2500_unknown_data_t* un); 
....................     int8_t (*service_indication)(void* handle, struct dust_dn2500_service_indication_t* p, struct dust_dn2500_unknown_data_t* un); 
....................     int8_t (*events_request)(void* handle, struct dust_dn2500_events_request_t* p, struct dust_dn2500_unknown_data_t* un); 
....................     int8_t (*data_request)(void* handle, struct dust_dn2500_data_request_t* p, struct dust_dn2500_unknown_data_t* un); 
....................  
....................     // Unknown command 
....................     int8_t (*unknown_command)(void* handle, uint8_t* data, uint8_t len); 
....................  
....................     // source buffer 
....................     uint8_t     bf_src[MAX_ENCODED_PACKET_SIZE]; 
....................     uint8_t     len_src; 
....................  
....................     // destination buffer 
....................     uint8_t     bf_dest[MAX_DEST_BUF_SIZE]; 
....................     uint8_t     len_dest; 
....................  
....................     uint8_t     idx; 
....................      
....................  
....................     // Used in case SW version isn't in sync with HW firmware version 
....................    struct dust_dn2500_unknown_data_t unknown; 
.................... }; 
....................  
.................... // Utility commands to queue and clear packet data 
.................... int8_t dust_dn2500_q_clear(struct dust_dn2500_t* ia); 
.................... int8_t dust_dn2500_q_byte(struct dust_dn2500_t* ia, uint8_t byte); 
....................  
.................... // Routine to dispatch incoming packets to callbacks 
.................... int8_t dust_dn2500_dispatcher(struct pappy_t* md, struct dust_dn2500_t* ia, void* handle); 
.................... //user defined 
....................  
.................... */ 
....................  
.................... // HERE ARE ITEMS FROM DUST_HDLC.H 
.................... #define CONTROL_ESCAPE 0x7d 
.................... #define FLAG_SEQUENCE  0x7e 
.................... #define XOR_BYTE       0x20 
....................  
.................... /* Low level routine return values */ 
.................... #define DUST_HDLC_RTN_SUCCESS                     0 
.................... #define DUST_HDLC_RTN_NOT_ENOUGH_BUFFER_SPACE    -1 
.................... #define DUST_HDLC_RTN_BAD_CRC                    -2 
.................... #define DUST_HDLC_RTN_INVALID_PK_DELIMITERS      -3 
....................  
....................  
.................... // HERE ARE ITEMS FROM DUST_HDLC.C 
.................... #define FCS_INITIAL_FCS16 ((uint16_t) 0xffff) 
.................... #define FCS_GOOD_FCS16    ((uint16_t) 0xf0b8) 
....................  
.................... // We will use the routine that takes LESS PROCESSING TIME at the expense 
.................... //  or greater memory usage. 
....................  
.................... // lookup table for calculation of checksum 
.................... UNSIGNED INT16 CONST fcstab[256] =  { 
....................    0x0000, 0x1189, 0x2312, 0x329b, 0x4624, 0x57ad, 0x6536, 0x74bf, 
....................    0x8c48, 0x9dc1, 0xaf5a, 0xbed3, 0xca6c, 0xdbe5, 0xe97e, 0xf8f7, 
....................    0x1081, 0x0108, 0x3393, 0x221a, 0x56a5, 0x472c, 0x75b7, 0x643e, 
....................    0x9cc9, 0x8d40, 0xbfdb, 0xae52, 0xdaed, 0xcb64, 0xf9ff, 0xe876, 
....................    0x2102, 0x308b, 0x0210, 0x1399, 0x6726, 0x76af, 0x4434, 0x55bd, 
....................    0xad4a, 0xbcc3, 0x8e58, 0x9fd1, 0xeb6e, 0xfae7, 0xc87c, 0xd9f5, 
....................    0x3183, 0x200a, 0x1291, 0x0318, 0x77a7, 0x662e, 0x54b5, 0x453c, 
....................    0xbdcb, 0xac42, 0x9ed9, 0x8f50, 0xfbef, 0xea66, 0xd8fd, 0xc974, 
....................    0x4204, 0x538d, 0x6116, 0x709f, 0x0420, 0x15a9, 0x2732, 0x36bb, 
....................    0xce4c, 0xdfc5, 0xed5e, 0xfcd7, 0x8868, 0x99e1, 0xab7a, 0xbaf3, 
....................    0x5285, 0x430c, 0x7197, 0x601e, 0x14a1, 0x0528, 0x37b3, 0x263a, 
....................    0xdecd, 0xcf44, 0xfddf, 0xec56, 0x98e9, 0x8960, 0xbbfb, 0xaa72, 
....................    0x6306, 0x728f, 0x4014, 0x519d, 0x2522, 0x34ab, 0x0630, 0x17b9, 
....................    0xef4e, 0xfec7, 0xcc5c, 0xddd5, 0xa96a, 0xb8e3, 0x8a78, 0x9bf1, 
....................    0x7387, 0x620e, 0x5095, 0x411c, 0x35a3, 0x242a, 0x16b1, 0x0738, 
....................    0xffcf, 0xee46, 0xdcdd, 0xcd54, 0xb9eb, 0xa862, 0x9af9, 0x8b70, 
....................    0x8408, 0x9581, 0xa71a, 0xb693, 0xc22c, 0xd3a5, 0xe13e, 0xf0b7, 
....................    0x0840, 0x19c9, 0x2b52, 0x3adb, 0x4e64, 0x5fed, 0x6d76, 0x7cff, 
....................    0x9489, 0x8500, 0xb79b, 0xa612, 0xd2ad, 0xc324, 0xf1bf, 0xe036, 
....................    0x18c1, 0x0948, 0x3bd3, 0x2a5a, 0x5ee5, 0x4f6c, 0x7df7, 0x6c7e, 
....................    0xa50a, 0xb483, 0x8618, 0x9791, 0xe32e, 0xf2a7, 0xc03c, 0xd1b5, 
....................    0x2942, 0x38cb, 0x0a50, 0x1bd9, 0x6f66, 0x7eef, 0x4c74, 0x5dfd, 
....................    0xb58b, 0xa402, 0x9699, 0x8710, 0xf3af, 0xe226, 0xd0bd, 0xc134, 
....................    0x39c3, 0x284a, 0x1ad1, 0x0b58, 0x7fe7, 0x6e6e, 0x5cf5, 0x4d7c, 
....................    0xc60c, 0xd785, 0xe51e, 0xf497, 0x8028, 0x91a1, 0xa33a, 0xb2b3, 
....................    0x4a44, 0x5bcd, 0x6956, 0x78df, 0x0c60, 0x1de9, 0x2f72, 0x3efb, 
....................    0xd68d, 0xc704, 0xf59f, 0xe416, 0x90a9, 0x8120, 0xb3bb, 0xa232, 
....................    0x5ac5, 0x4b4c, 0x79d7, 0x685e, 0x1ce1, 0x0d68, 0x3ff3, 0x2e7a, 
....................    0xe70e, 0xf687, 0xc41c, 0xd595, 0xa12a, 0xb0a3, 0x8238, 0x93b1, 
....................    0x6b46, 0x7acf, 0x4854, 0x59dd, 0x2d62, 0x3ceb, 0x0e70, 0x1ff9, 
....................    0xf78f, 0xe606, 0xd49d, 0xc514, 0xb1ab, 0xa022, 0x92b9, 0x8330, 
....................    0x7bc7, 0x6a4e, 0x58d5, 0x495c, 0x3de3, 0x2c6a, 0x1ef1, 0x0f78 
.................... }; 
....................  
.................... /* 
.................... // EVEN MORE STUFF NOT RELEVANT TO JACK IMPLEMENTATION 
.................... // ITEMS FROM DUST_DN2500_HANDLER.H 
.................... // I THINK THESE ARE FUNCTION PROTOTYPES! 
.................... // set_parameter response packets received by sensor processor 
.................... int8_t dust_dn2500_set_param_tx_power_response(void* handle, struct dust_dn2500_set_param_tx_power_response_t* p, struct dust_dn2500_unknown_data_t* un); 
.................... int8_t dust_dn2500_set_param_join_duty_cycle_response(void* handle, struct dust_dn2500_set_param_join_duty_cycle_response_t* p, struct dust_dn2500_unknown_data_t* un); 
.................... int8_t dust_dn2500_set_param_battery_life_response(void* handle, struct dust_dn2500_set_param_battery_life_response_t* p, struct dust_dn2500_unknown_data_t* un); 
.................... int8_t dust_dn2500_set_param_service_response(void* handle, struct dust_dn2500_set_param_service_response_t* p, struct dust_dn2500_unknown_data_t* un); 
.................... int8_t dust_dn2500_set_param_event_mask_response(void* handle, struct dust_dn2500_set_param_event_mask_response_t* p, struct dust_dn2500_unknown_data_t* un); 
.................... int8_t dust_dn2500_set_param_hart_device_status_response(void* handle, struct dust_dn2500_set_param_hart_device_status_response_t* p, struct dust_dn2500_unknown_data_t* un); 
.................... int8_t dust_dn2500_set_param_hart_device_info_response(void* handle, struct dust_dn2500_set_param_hart_device_info_response_t* p, struct dust_dn2500_unknown_data_t* un); 
.................... int8_t dust_dn2500_set_param_write_protect_response(void* handle, struct dust_dn2500_set_param_write_protect_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................  
.................... // get_parameter response packets received by sensor processor 
.................... int8_t dust_dn2500_get_param_mote_info_response(void* handle, struct dust_dn2500_get_param_mote_info_response_t* p, struct dust_dn2500_unknown_data_t* un); 
.................... int8_t dust_dn2500_get_param_network_info_response(void* handle, struct dust_dn2500_get_param_network_info_response_t* p, struct dust_dn2500_unknown_data_t* un); 
.................... int8_t dust_dn2500_get_param_mote_status_response(void* handle, struct dust_dn2500_get_param_mote_status_response_t* p, struct dust_dn2500_unknown_data_t* un); 
.................... int8_t dust_dn2500_get_param_service_response(void* handle, struct dust_dn2500_get_param_service_response_t* p, struct dust_dn2500_unknown_data_t* un); 
.................... int8_t dust_dn2500_get_param_time_response(void* handle, struct dust_dn2500_get_param_time_response_t* p, struct dust_dn2500_unknown_data_t* un); 
.................... int8_t dust_dn2500_get_param_charge_response(void* handle, struct dust_dn2500_get_param_charge_response_t* p, struct dust_dn2500_unknown_data_t* un); 
.................... int8_t dust_dn2500_get_param_test_radio_rxstats_response(void* handle, struct dust_dn2500_get_param_test_radio_rxstats_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................  
.................... // get non-volatile response packets received by sensor processor 
.................... int8_t dust_dn2500_getnv_mac_address_response(void* handle, struct dust_dn2500_getnv_mac_address_response_t* p, struct dust_dn2500_unknown_data_t* un); 
.................... int8_t dust_dn2500_getnv_network_id_response(void* handle, struct dust_dn2500_getnv_network_id_response_t* p, struct dust_dn2500_unknown_data_t* un); 
.................... int8_t dust_dn2500_getnv_tx_power_response(void* handle, struct dust_dn2500_getnv_tx_power_response_t* p, struct dust_dn2500_unknown_data_t* un); 
.................... int8_t dust_dn2500_getnv_powerinfo_response(void* handle, struct dust_dn2500_getnv_powerinfo_response_t* p, struct dust_dn2500_unknown_data_t* un); 
.................... int8_t dust_dn2500_getnv_ttl_response(void* handle, struct dust_dn2500_getnv_ttl_response_t* p, struct dust_dn2500_unknown_data_t* un); 
.................... int8_t dust_dn2500_getnv_hart_antenna_gain(void* handle, struct dust_dn2500_getnv_hart_antenna_gain_response_t* p, struct dust_dn2500_unknown_data_t* un); 
.................... int8_t dust_dn2500_getnv_otap_lockout(void* handle, struct dust_dn2500_getnv_otap_lockout_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................  
.................... // set non-volatile response packets received by sensor processor 
.................... int8_t dust_dn2500_setnv_mac_address_response(void* handle, struct dust_dn2500_setnv_mac_address_response_t* p, struct dust_dn2500_unknown_data_t* un); 
.................... int8_t dust_dn2500_setnv_network_id_response(void* handle, struct dust_dn2500_setnv_network_id_response_t* p, struct dust_dn2500_unknown_data_t* un); 
.................... int8_t dust_dn2500_setnv_tx_power_response(void* handle, struct dust_dn2500_setnv_tx_power_response_t* p, struct dust_dn2500_unknown_data_t* un); 
.................... int8_t dust_dn2500_setnv_joinkey_response(void* handle, struct dust_dn2500_setnv_joinkey_response_t* p, struct dust_dn2500_unknown_data_t* un); 
.................... int8_t dust_dn2500_setnv_powerinfo_response(void* handle, struct dust_dn2500_setnv_powerinfo_response_t* p, struct dust_dn2500_unknown_data_t* un); 
.................... int8_t dust_dn2500_setnv_ttl_response(void* handle, struct dust_dn2500_setnv_ttl_response_t* p, struct dust_dn2500_unknown_data_t* un); 
.................... int8_t dust_dn2500_setnv_hart_antenna_gain(void* handle, struct dust_dn2500_setnv_hart_antenna_gain_response_t* p, struct dust_dn2500_unknown_data_t* un); 
.................... int8_t dust_dn2500_setnv_otap_lockout(void* handle, struct dust_dn2500_setnv_otap_lockout_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................  
.................... // motes response packets received by sensor processor 
.................... int8_t dust_dn2500_send_response(void* handle, struct dust_dn2500_send_response_t* p, struct dust_dn2500_unknown_data_t* un); 
.................... int8_t dust_dn2500_join_response(void* handle, struct dust_dn2500_join_response_t* p, struct dust_dn2500_unknown_data_t* un); 
.................... int8_t dust_dn2500_disconnect_response(void* handle, struct dust_dn2500_disconnect_response_t* p, struct dust_dn2500_unknown_data_t* un); 
.................... int8_t dust_dn2500_search_response(void* handle, struct dust_dn2500_search_response_t* p, struct dust_dn2500_unknown_data_t* un); 
.................... int8_t dust_dn2500_reset_response(void* handle, struct dust_dn2500_reset_response_t* p, struct dust_dn2500_unknown_data_t* un); 
.................... int8_t dust_dn2500_lowPowerSleep_response(void* handle, struct dust_dn2500_lowPowerSleep_response_t* p, struct dust_dn2500_unknown_data_t* un); 
.................... int8_t dust_dn2500_testRadioTx_response(void* handle, struct dust_dn2500_testRadioTx_response_t* p, struct dust_dn2500_unknown_data_t* un); 
.................... int8_t dust_dn2500_testRadioRx_response(void* handle, struct dust_dn2500_testRadioRx_response_t* p, struct dust_dn2500_unknown_data_t* un); 
.................... int8_t dust_dn2500_clearnv_response(void* handle, struct dust_dn2500_clearnv_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................  
.................... // Mote request packets received by sensor processor 
.................... int8_t dust_dn2500_time_request(void* handle, struct dust_dn2500_time_request_t* p, struct dust_dn2500_unknown_data_t* un); 
.................... int8_t dust_dn2500_service_indication(void* handle, struct dust_dn2500_service_indication_t* p, struct dust_dn2500_unknown_data_t* un); 
.................... int8_t dust_dn2500_events_request(void* handle, struct dust_dn2500_events_request_t* p, struct dust_dn2500_unknown_data_t* un); 
.................... int8_t dust_dn2500_data_request(void* handle, struct dust_dn2500_data_request_t* p, struct dust_dn2500_unknown_data_t* un); 
.................... int8_t dust_dn2500_unknown_command(void* handle, uint8_t* data, uint8_t len); 
....................  
.................... */ 
....................  
.................... #include "globals.h"                                
.................... // globals.h 
.................... // 
.................... // This file contains all of the global variables used in the firmware 
.................... //  
.................... // Add to this list carefull and keep it syncronized with vars_init().....                
....................            
.................... ////////////////////Global Variables Table of Contents///////////////////////// 
.................... //Test Globals 
.................... //LCD Globals 
.................... //Time Globals                                                                            
.................... //System Parameter Globals 
.................... //Hardware Enabled Globals                                
.................... //Control Related Globals                  
.................... //Valve Related Globals                                         
.................... //Mote Globals 
.................... //Priority Queue 
.................... //Time Queue                                                               
.................... //Sprinkler Stack                                                                                                 
.................... //Command Stack                     
.................... //System State Globals 
....................  
.................... //Where to put?                                                
.................... uint32_t global_last_connected_time = 0;         
.................... uint16_t global_xdcr_output = 0;                             
....................                                    
.................... // global that keeps track of why the system restarted/shutdown 
.................... uint8_t global_shutdown_cause = 0; 
.................... uint8_t global_previous_shutdown_cause = 0; 
....................  
.................... char global_firmware_version_string[5] = {'A','0','0','0',0};       
....................  
.................... ////////////////////Test Globals/////////////////////////////////////////////// 
.................... uint8_t test_global = 0; 
.................... uint8_t test_global_2 = 0; 
.................... uint32_t test_start_time = 0; 
.................... uint32_t test_end_time = 0; 
.................... uint16_t test_valve_open_1 = 0; 
.................... uint16_t test_rpm_1 = 0; 
.................... uint16_t test_duty_cycle_1 = 0; 
.................... uint16_t test_valve_open_2 = 0; 
.................... uint16_t test_rpm_2 = 0; 
.................... uint16_t test_duty_cycle_2 = 0; 
.................... uint16_t test_valve_open_3 = 0; 
.................... uint16_t test_rpm_3 = 0; 
.................... uint16_t test_duty_cycle_3 = 0; 
....................  
....................   
.................... ////////////////////LCD Globals//////////////////////////////////////////////// 
.................... unsigned char global_temp_line_buff[17]; 
.................... char* global_extra_lcd_ptr; 
....................                      
.................... // LCD skip update flag 
.................... // 0 = don't skip 
.................... // 1 = Last update skipped, clear screen and proceed as normal 
.................... // 2-255 = how many skips (plus 1) to skip.  LCD is updated 1/sec, so 4 =  
.................... //    3 seconds of skipping updates. 
.................... uint8_t     global_skip_lcd_update_count = 0;        
....................  
.................... // Current LCD page number 
.................... // 0 = don't display anything? 
.................... // 1-TOTAL_LCD_PAGES = display that page number     
.................... uint8_t     global_lcd_page_number = 1;       
....................                    
.................... ////////////////////Time Globals/////////////////////////////////////////////// 
.................... // keeps track of time since microprocessor has been awake in seconds 
.................... uint32_t global_rtc_time = 0; 
.................... // keeps track of the time within the mote system (taken from mote) 
.................... uint32_t global_utc_time = 0; 
.................... // keeps track of the time at book (as taken from the mote the first time after 
.................... //  program startup 
.................... uint32_t global_first_utc_time = 0; 
.................... // keeps track of when SW1 was last depressed (for recognition of long press event) 
.................... uint32_t sw1_start_time = 0;   
.................... ////////////////////System Parameter Globals/////////////////////////////////// 
.................... uint16_t global_sprinkler_num = 0; 
....................  
.................... // More globals that we might actually want to keep 
.................... uint8_t     serial_number_rcvd[8] = {0,0,0,0,0,0,0,0}; 
.................... uint8_t     macaddr_rcvd[8] = {0,0,0,0,0,0,0,0}; 
....................  
.................... ////////////////////Hardware Enabled Globals/////////////////////////////////// 
.................... uint8_t  global_hardware_enabled = 0;                                                                
....................    #BIT  global_lcd_enabled         = global_hardware_enabled.0 
....................    #BIT  global_gps_enabled         = global_hardware_enabled.1 
....................    #BIT  global_xcdr_type1_enabled  = global_hardware_enabled.2 
....................    #BIT  global_xcdr_type2_enabled  = global_hardware_enabled.3 
....................    #BIT  global_fixture_enabled     = global_hardware_enabled.4 
....................    #BIT  global_temp1_enabled       = global_hardware_enabled.5 
....................    #BIT  global_dust_enabled        = global_hardware_enabled.6 
....................    #BIT  global_dust_operational    = global_hardware_enabled.7 
....................  
.................... ////////////////////Control Related Globals//////////////////////////////////// 
.................... // keeps track of rpms (updated via interrupt routine) 
.................... uint16_t global_current_period = 0; 
.................... uint16_t global_current_rpm; 
.................... uint16_t global_rpm_set_value = 100; 
.................... uint32_t global_last_rpm_value_time = 0; 
....................  
.................... // keeps track of duty cycles of brake and charge 
.................... uint16_t global_brake_duty = 0; 
.................... uint16_t global_charge_duty = MAX_CHARGE; 
.................... // keeps track of set points for brake and charge duty cycles 
.................... uint16_t global_brake_duty_set_value = 0; 
.................... uint16_t global_charge_duty_set_value = MAX_CHARGE; 
....................  
.................... // keeps track of mppc level 
.................... uint8_t  global_mppc_value = 100; 
.................... uint8_t  global_mppc_set_value = 100; 
.................... // keeps track of vgen 
.................... uint16_t global_vgen = 0; 
.................... // keeps track of fixture dac value 
.................... uint16_t global_fixture_dac_value = NO_FIXTURE; 
....................  
.................... // specifies how the rpm is being controlled (see defines for more info) 
.................... uint8_t global_control_loop_mechanism = BRAKE_AND_CHARGE_START; 
.................... // JG: set to brake and charge for testing purposes Feb 2, 2017 
.................... //uint8_t global_control_loop_mechanism = BRAKE_AND_CHARGE_START; 
....................  
.................... ////////////////////Valve Related Globals////////////////////////////////////// 
.................... // keeps track of current valve position 
.................... uint16_t global_valve_position = VLV_PRECALIBRATION_POSITION;    
.................... // valve position set point 
.................... uint16_t global_valve_position_set_value = VLV_PRECALIBRATION_POSITION;    
....................                                 
.................... // 1/1024th of the time to go from open to close calculated by calibrate valve    
.................... //     routine in units of 2ndary oscillator ticks 
.................... uint16_t global_valve_time_to_close_1024th = DEFAULT_VLV_TIME_TO_CLOSE; 
.................... // 1/1024th of the time to go from close to open calculated by calibrate valve   
.................... //    routine in units of 2ndary oscillator ticks 
.................... uint16_t global_valve_time_to_open_1024th = DEFAULT_VLV_TIME_TO_OPEN; 
.................... // amount of time the valve has been in motion in units of 1/1024ths of a 
.................... //    millispan.  So, not really time, but distance. 
.................... uint16_t global_valve_time_in_motion_1024ths = 0; 
.................... // when the last valve calibration was done, in utc time 
.................... uint32_t global_valve_calibration_utc_time = 0; 
.................... // number of movements since last calibration/endstop  
.................... uint8_t  global_valve_movements_since_endstop = 0; 
....................  
.................... // calibrate FSR valve position (default is 0x2000, but should be set by message) 
.................... uint16_t global_calibrate_fsr_valve_position = 0x2000; 
.................... // calibrate FSR outcome in period (inverse of rpm).  Default/unknown is 0-1 
.................... uint16_t global_calibrate_fsr_period = 0-1; 
.................... // when the last fsr calibration was done, in utc time 
.................... uint32_t global_calibrate_fsr_utc_time = 0; 
....................  
.................... ////////////////////Mote Globals/////////////////////////////////////////////// 
.................... //event flags defined by mote 
.................... uint8_t  event_flags; 
....................    #BIT  fl_boot_event           = event_flags.0 
....................    #BIT  fl_alarm_event          = event_flags.1 
....................    #BIT  fl_time_event           = event_flags.2 
....................    #BIT  fl_joinfail_event       = event_flags.3 
....................    #BIT  fl_disconnected_event   = event_flags.4 
....................    #BIT  fl_operational_event    = event_flags.5 
....................    #BIT  fl_config_event         = event_flags.6 
....................    #BIT  fl_unknown_event        = event_flags.7 
....................  
.................... // Note that bytes_from_mote union contains the stripped unstuffed data 
.................... //  eg, bytes_from_mote.dust_rcvd[128] 
.................... mote_to_micro  bytes_from_mote; 
.................... mote_to_micro* p; 
....................  
.................... // It just can't get bigger than this! 
.................... // pkgen places message to be sent here 
.................... char        dust_send_buffer[MAX_SEND_BUFFER]; 
....................  
.................... // this is only for doing acks and only needs to be  
.................... // MAX_USER_DATA_SIZE*2 + 2 + 4 + 12 + 2 
.................... // MAX_USER_DATA_SIZE is 2 bytes for ack 
.................... char        dust_send_buffer_isr[2*2 + 2 + 4 + 12 + 2]; 
....................  
.................... // THIS is the buffer for RAW rcvd mote 
.................... //  mote packet data 
.................... char        dust_recive_buffer[MAX_RCV_BUFFER + 1]; 
....................  
.................... //  this is place 
.................... //  where the packet to be sent by micro 
.................... //  to NETWORK manager is placed prior 
.................... //  to dust_send_data call 
.................... char        payload_buff[MAX_USER_DATA_SIZE]; 
....................  
.................... // Keeps track of how many bytes to send and passed between pkgen and pksend 
.................... uint8_t num_of_bytes_to_send = 0; 
.................... uint8_t num_of_bytes_to_send_isr = 0; 
....................  
.................... // This is specific to the subroutine 
.................... //  pkgen_send() which creates the message 
.................... //  to be sent from the mote to the net                      
.................... uint8_t     send_prefix[12]; 
....................  
.................... // send_prefix[11] will be set to number of bytes in packet 
.................... // The send_prefix structure is as follows: 
.................... // [0]      CMD_SEND 
.................... // [1]      length of request       - this is payload length + 9 
.................... // [2]      FLAG_SEND_REQUEST 
.................... // [3]/[4]  destination address     - always DESTADDR_HI, DESTADDR_LO 
.................... // [5]      svc_index               - get this from service indication received 
.................... //                                     at join time 
.................... // [6]      APPDOMAIN_MAINTENANCE 
.................... // [7]      PRIORITY_HIGH 
.................... // [8][9]   reserved                - 0x00, 0x00  
.................... // [10]     sequence_num            - always 0xFF for mote-originated packets 
.................... // [11]     payload length          - length of the payload in bytes 
....................  
....................  
.................... // For ensuring a message was recieved properly from mote 
.................... uint8_t result_rcvd = 0; 
....................  
.................... // JG Jan 2017 
.................... int1 fl_alt_LCD; 
....................  
.................... // Flag for going through deal with mote ISR and going to sleep afterwards 
.................... int1 fl_mote_dealt; 
....................  
.................... // Flag for a sucessful get/set response eliminating a few other flags 
.................... int1  global_set_get_response; 
....................  
.................... // FLAGS TO GET RID OF! 
.................... // Flag for receiving an advertisment 
.................... int1  advert_rcvd_fl; 
.................... int1  setnetid_done_fl; 
.................... int1  ack_sent_fl; 
.................... int1  pkt_rcvd_fl; 
.................... int1  joinduty_done_fl; 
.................... int1  gettime_done_fl; 
.................... int1  fl_batNOEE; 
.................... int1  joinkey_done_fl; 
.................... int1  joincmd_done_fl; 
....................  
.................... uint8_t flags_rcvd = 0 ,param_type_rcvd = 0, svc_index_rcvd=0; 
.................... uint16_t mote_msgSEQ = 0; 
....................  
.................... //Globals for when advertisements are received 
.................... uint16_t network_id_rcvd = NETWORK_ID_DEF; 
.................... uint16_t mote_id_rcvd = 0; 
.................... int8_t rssi_rcvd = 0; 
.................... uint8_t hop_depth_rcvd = 0; 
....................  
.................... // global variable that keeps track of the current temperature of the mote.   
.................... //    It is updated every MOTE_CHECKS_TIME seconds 
.................... int8_t global_mote_temperature = 0; 
....................  
.................... ////////////////////Priority Queue///////////////////////////////////////////// 
.................... // Actual priority queue 
.................... volatile uint8_t global_priority_queue[MAX_PRIORITY_QUEUE_ITEMS] = {0}; 
.................... volatile uint8_t global_current_priority_queue_location = (0-1); 
....................  
.................... ////////////////////Time Queue///////////////////////////////////////////////// 
.................... // Actual time queue 
.................... struct TimeQueueItem global_time_queue[MAX_TIME_QUEUE_ITEMS] = {0}; 
.................... uint8_t global_current_time_queue_location = (0-1); 
....................  
.................... ////////////////////Sprinkler Queue//////////////////////////////////////////// 
.................... // Actual sprinkler queue 
.................... struct SprinklerQueueItem global_sprinkler_queue[MAX_SPRINKLER_QUEUE_ITEMS] = {0}; 
.................... uint8_t global_current_sprinkler_queue_location = (0-1); 
.................... // when the current sprinkler command is supposed to end 
.................... uint32_t global_current_sprinkler_settings_end_time = (0-1); 
....................  
.................... ////////////////////Command Queue////////////////////////////////////////////// 
.................... // Actual command queue              
.................... struct CommandQueueItem global_command_queue[MAX_COMMAND_QUEUE_ITEMS] = {0}; 
.................... uint8_t global_current_command_queue_location = (0-1); 
....................  
.................... ////////////////////Message Queue////////////////////////////////////////////// 
.................... // Actual command queue                 
.................... struct MessageQueueItem global_message_queue[MAX_MESSAGE_QUEUE_ITEMS] = {0}; 
.................... uint8_t global_current_message_queue_location = (0-1); 
.................... // global variable that stores the current errors encountered that will be sent 
.................... //    to the manager via an unsolicited error message 
.................... uint32_t global_error_message_bitfield = 0; 
....................  
.................... // the last error message's bitfield and send time for stopping reoccuring error messages 
.................... uint32_t last_error_message_sent_bitfield = 0; 
.................... uint32_t last_error_message_sent_rtc_time = 0; 
....................  
.................... ////////////////////System State Variables///////////////////////////////////// 
.................... uint8_t global_mote_state = MOTESTATE_UNKNOWN; 
.................... uint8_t global_system_state = SYSTEM_STATE_UNKNOWN; 
....................  
.................... ////////////////////Misc/////////////////////////////////////////////////////// 
....................  
....................  
.................... #include "eeprom.h" 
.................... // EEPROM.h 
.................... // This contains all things related to the EEPROM 
.................... // -functions 
.................... // -#defines for memory locations 
.................... // -#defines conveted to eeprom values to load/store out of EEPROM 
....................  
.................... ////////////////////EEPROM Locations Start/////////////////////////////////////////////////////////////  
....................                                                              
.................... // start of EEPROM locations 
.................... #define EE_START_LOCATION     0x0000 
.................... // Location ID                                                                    
.................... #define EE_SPRINKLER_NUM      0x0000 
.................... // Cause for shutdown/restart 
.................... #define EE_RESTART_CAUSE      0x0002                                               
.................... // Last valve calibrations and time            
.................... #define EE_VLV_TIME_TO_OPEN   0x0004                                      
.................... #define EE_VLV_TIME_TO_CLOSE  0x0006                                             
.................... #define EE_VLV_CAL_UTC_TIME   0x0008                                     
.................... // Last valve position 
.................... #define EE_VLV_POSITION       0x000C                                                    
....................                   
.................... // start of eeprom changable variables                                             
.................... #define EE_VLV_NEAR_CLOSED_RANGE_MAX 0x000E 
.................... #define EE_VLV_NEAR_OPENED_RANGE_MAX 0x0010               
.................... #define EE_DAC_LVL_OPENING_NEAR_OPENED 0x0012   
.................... #define EE_DAC_LVL_OPENING_NEAR_CLOSED 0x0014   
.................... #define EE_DAC_LVL_CLOSING_NEAR_OPENED 0x0016   
.................... #define EE_DAC_LVL_CLOSING_NEAR_CLOSED 0x0018   
.................... #define EE_DAC_LVL_IN_MIDDLE 0x001A 
.................... #define EE_DAC_LVL_INIT_CURRENT_BOOST 0x001C 
.................... #define EE_VLV_INIT_CURRENT_BOOST_TIME_1024THS 0x001E  
.................... #define EE_VLV_NOT_SPIN_LIMIT 0x0020   
.................... #define EE_VLV_NOT_SPIN_FIX 0x0022   
.................... #define EE_NOT_SPINNING_MAG_DECOUPLING_RPM_FIXED 0x0024   
.................... #define EE_VLV_MAGNETIC_COUPLING_LIMIT 0x0026   
.................... #define EE_VLV_MAGNETIC_COUPLING_FIX 0x0028   
.................... #define EE_RPM_TIMEOUT 0x002A 
.................... #define EE_MOTE_SEARCH_TIME 0x002C 
.................... #define EE_MOTE_NETWORK_SHUTDOWN_TIMEOUT 0x002E                                         
.................... // end of eeprom changeable variables 
....................  
.................... // last byte of EEPROM used 
.................... #define EE_END_LOCATION       0x002F     
....................                                           
....................  
.................... ////////////////////EEPROM Locations End/////////////////////////////////////////////////////////////// 
....................  
....................  ////////////////////EEPROM defines->globals Start//////////////////////////////////////////////////////   
.................... // Maximum value of "near closed" range 
.................... uint16_t VLV_NEAR_CLOSED_RANGE_MAX = 0x1000; 
.................... // Maximum value of "near opened" range 
.................... uint16_t VLV_NEAR_OPENED_RANGE_MAX =   0x7000;     
....................                                             
.................... // DAC level while opening near the fully open end 
.................... uint16_t DAC_LVL_OPENING_NEAR_OPENED =      24; 
.................... // DAC level while opening near the fully closed end 
.................... uint16_t DAC_LVL_OPENING_NEAR_CLOSED =      20;    
.................... // DAC level while closing near the fully open end 
.................... uint16_t DAC_LVL_CLOSING_NEAR_OPENED =      20; 
.................... // DAC level while closing near the fully closed end                         
.................... uint16_t DAC_LVL_CLOSING_NEAR_CLOSED =      24;  
.................... // DAC level while moving in the middle of the valve range and it's default 
.................... uint16_t DAC_LVL_IN_MIDDLE =                19;  
.................... // DAC level for the inital current boost/lowered current limit   
.................... uint16_t DAC_LVL_INIT_CURRENT_BOOST =       19;      
....................                                                             
.................... // Amount of millispans that a current boost/lovered dac level is implemented. 
.................... //    This is done outside of the (NEAR_CLOSED/OPEN_RANGE)    
.................... //    @ 45 seconds to close, 30 = 1.3 seconds 
.................... uint16_t VLV_INIT_CURRENT_BOOST_TIME_1024THS =  30;   
....................                                                
.................... // valve not-spinning and magnetic de-coupling defines                                                     
.................... // below this number is the regime where we watch for the not spinning case (low torque)  
.................... uint16_t VLV_NOT_SPIN_LIMIT =               0x4000; 
.................... // where we send the valve when we want to fix it.  If it gets fixed before reaching this valve position 
.................... //    it stops. If it does not get fixed by the time it reaches this position, it sends an error and stops. 
.................... uint16_t VLV_NOT_SPIN_FIX =                 0x7000; 
....................                                                
.................... // above this rpm, consider magnetic coupling or not-spinning fixed 
.................... uint8_t NOT_SPINNING_MAG_DECOUPLING_RPM_FIXED =  8;        
....................                                                    
.................... // above this number is the regime where we watch for the magnetic decoupling 
.................... uint16_t VLV_MAGNETIC_COUPLING_LIMIT =      0x5000;        
.................... // where to move the valve at a time when trying to recover  
.................... uint16_t VLV_MAGNETIC_COUPLING_FIX =        0x1000;              
.................... // amount to move the valve at a time when trying to recover    
....................                                                                            
.................... // how many seconds it takes to consider the rpm to be zero (or infinite for higher valve settings) 
.................... // 8 = 7.5 RPM (8 may be max of what ccp5 can handle without overflow)    
.................... // JG SAYS that RPM_TIMEOUT of 2 makes more sense because 
.................... //  any time which exceeds 1 second indicates that the RPM is less than 1.2, 
.................... //  a very low number which we can consider to equal 0. 
.................... uint16_t RPM_TIMEOUT =                     2; 
....................                                         
.................... // amount of seconds for mote to stay searching for advertisements                     
.................... uint16_t MOTE_SEARCH_TIME = 120;        
.................... // amount of time the mote will stay disconnected from the network before shutting down (1200 = 20 min)                                    
.................... uint16_t MOTE_NETWORK_SHUTDOWN_TIMEOUT = 1200;                      
....................  
.................... ////////////////////EEPROM defines->globals End////////////////////////////////////////////////////////  
....................   
.................... ////////////////////EEPROM Functions Start/////////////////////////////////////////////////////////////  
.................... uint8_t read_ee1(uint16_t source) 
.................... {                                                                  
....................    return read_eeprom(source); 
*
03402:  MOVFF  FF2,556
03406:  BCF    FF2.7
03408:  MOVFF  555,FAA
0340C:  MOVFF  554,FA9
03410:  BCF    FA6.6
03412:  BCF    FA6.7
03414:  BSF    FA6.0
03416:  MOVF   FA8,W
03418:  MOVLB  5
0341A:  BTFSC  x56.7
0341C:  BSF    FF2.7
0341E:  MOVWF  01
03420:  MOVLB  0
03422:  RETURN 0
.................... }                 
.................... uint16_t read_ee2(uint16_t source) 
.................... { 
....................    return (make16(read_eeprom(source+1), read_eeprom(source))); 
*
03332:  MOVLW  01
03334:  MOVLB  5
03336:  ADDWF  x54,W
03338:  MOVWF  x56
0333A:  MOVLW  00
0333C:  ADDWFC x55,W
0333E:  MOVWF  x57
03340:  MOVFF  FF2,558
03344:  BCF    FF2.7
03346:  MOVFF  557,FAA
0334A:  MOVFF  556,FA9
0334E:  BCF    FA6.6
03350:  BCF    FA6.7
03352:  BSF    FA6.0
03354:  MOVF   FA8,W
03356:  BTFSC  x58.7
03358:  BSF    FF2.7
0335A:  MOVWF  x56
0335C:  MOVFF  FF2,557
03360:  BCF    FF2.7
03362:  MOVFF  555,FAA
03366:  MOVFF  554,FA9
0336A:  BCF    FA6.6
0336C:  BCF    FA6.7
0336E:  BSF    FA6.0
03370:  MOVF   FA8,W
03372:  BTFSC  x57.7
03374:  BSF    FF2.7
03376:  MOVWF  x59
03378:  MOVFF  556,03
0337C:  MOVF   x59,W
0337E:  MOVWF  01
03380:  MOVF   03,W
03382:  MOVWF  02
03384:  MOVLB  0
03386:  RETURN 0
.................... }  
.................... uint32_t read_ee4(uint16_t source) 
.................... { 
....................    return (make32(read_eeprom(source+3), read_eeprom(source+2), read_eeprom(source+1), read_eeprom(source))); 
*
03456:  MOVLW  03
03458:  MOVLB  5
0345A:  ADDWF  x54,W
0345C:  MOVWF  x56
0345E:  MOVLW  00
03460:  ADDWFC x55,W
03462:  MOVWF  x57
03464:  MOVFF  FF2,558
03468:  BCF    FF2.7
0346A:  MOVFF  557,FAA
0346E:  MOVFF  556,FA9
03472:  BCF    FA6.6
03474:  BCF    FA6.7
03476:  BSF    FA6.0
03478:  MOVF   FA8,W
0347A:  BTFSC  x58.7
0347C:  BSF    FF2.7
0347E:  MOVWF  x56
03480:  MOVLW  02
03482:  ADDWF  x54,W
03484:  MOVWF  x59
03486:  MOVLW  00
03488:  ADDWFC x55,W
0348A:  MOVWF  x5A
0348C:  MOVFF  FF2,557
03490:  BCF    FF2.7
03492:  MOVFF  55A,FAA
03496:  MOVFF  559,FA9
0349A:  BCF    FA6.6
0349C:  BCF    FA6.7
0349E:  BSF    FA6.0
034A0:  MOVF   FA8,W
034A2:  BTFSC  x57.7
034A4:  BSF    FF2.7
034A6:  MOVWF  x59
034A8:  MOVLW  01
034AA:  ADDWF  x54,W
034AC:  MOVWF  x5A
034AE:  MOVLW  00
034B0:  ADDWFC x55,W
034B2:  MOVWF  x5B
034B4:  MOVFF  FF2,55C
034B8:  BCF    FF2.7
034BA:  MOVFF  55B,FAA
034BE:  MOVFF  55A,FA9
034C2:  BCF    FA6.6
034C4:  BCF    FA6.7
034C6:  BSF    FA6.0
034C8:  MOVF   FA8,W
034CA:  BTFSC  x5C.7
034CC:  BSF    FF2.7
034CE:  MOVWF  x5A
034D0:  MOVFF  FF2,55B
034D4:  BCF    FF2.7
034D6:  MOVFF  555,FAA
034DA:  MOVFF  554,FA9
034DE:  BCF    FA6.6
034E0:  BCF    FA6.7
034E2:  BSF    FA6.0
034E4:  MOVF   FA8,W
034E6:  BTFSC  x5B.7
034E8:  BSF    FF2.7
034EA:  MOVWF  x5D
034EC:  MOVFF  556,03
034F0:  MOVFF  559,02
034F4:  MOVFF  55A,01
034F8:  MOVFF  55D,00
034FC:  MOVLB  0
034FE:  RETURN 0
.................... } 
....................  
.................... void write_ee1(uint16_t dest, uint8_t dat8) 
.................... { 
....................    write_eeprom(dest, dat8); 
*
03424:  MOVF   FF2,W
03426:  MOVWF  00
03428:  BCF    FF2.7
0342A:  MOVFF  555,FAA
0342E:  MOVFF  554,FA9
03432:  MOVFF  556,FA8
03436:  BCF    FA6.6
03438:  BCF    FA6.7
0343A:  BSF    FA6.2
0343C:  MOVLB  F
0343E:  MOVLW  55
03440:  MOVWF  FA7
03442:  MOVLW  AA
03444:  MOVWF  FA7
03446:  BSF    FA6.1
03448:  BTFSC  FA6.1
0344A:  BRA    3448
0344C:  BCF    FA6.2
0344E:  MOVF   00,W
03450:  IORWF  FF2,F
03452:  MOVLB  0
03454:  RETURN 0
.................... } 
....................  
.................... void write_ee2(uint16_t dest, uint16_t dat16) 
.................... { 
....................    write_eeprom(dest++, make8(dat16,0)); 
*
03388:  MOVLB  5
0338A:  MOVF   x57,W
0338C:  MOVWF  03
0338E:  MOVF   x56,W
03390:  INCF   x56,F
03392:  BTFSC  FD8.2
03394:  INCF   x57,F
03396:  MOVWF  x5A
03398:  MOVFF  03,55B
0339C:  MOVFF  558,55C
033A0:  MOVF   FF2,W
033A2:  MOVWF  00
033A4:  BCF    FF2.7
033A6:  MOVFF  55B,FAA
033AA:  MOVFF  55A,FA9
033AE:  MOVFF  55C,FA8
033B2:  BCF    FA6.6
033B4:  BCF    FA6.7
033B6:  BSF    FA6.2
033B8:  MOVLB  F
033BA:  MOVLW  55
033BC:  MOVWF  FA7
033BE:  MOVLW  AA
033C0:  MOVWF  FA7
033C2:  BSF    FA6.1
033C4:  BTFSC  FA6.1
033C6:  BRA    33C4
033C8:  BCF    FA6.2
033CA:  MOVF   00,W
033CC:  IORWF  FF2,F
....................    write_eeprom(dest, make8(dat16,1)); 
033CE:  MOVFF  559,55A
033D2:  MOVFF  FF2,00
033D6:  BCF    FF2.7
033D8:  MOVFF  557,FAA
033DC:  MOVFF  556,FA9
033E0:  MOVFF  559,FA8
033E4:  BCF    FA6.6
033E6:  BCF    FA6.7
033E8:  BSF    FA6.2
033EA:  MOVLW  55
033EC:  MOVWF  FA7
033EE:  MOVLW  AA
033F0:  MOVWF  FA7
033F2:  BSF    FA6.1
033F4:  BTFSC  FA6.1
033F6:  BRA    33F4
033F8:  BCF    FA6.2
033FA:  MOVF   00,W
033FC:  IORWF  FF2,F
033FE:  MOVLB  0
03400:  RETURN 0
.................... } 
....................  
.................... void write_ee4(uint16_t dest, uint32_t dat32) 
.................... { 
....................    write_eeprom(dest++, make8(dat32,0)); 
*
06CCC:  MOVLB  5
06CCE:  MOVF   x59,W
06CD0:  MOVWF  03
06CD2:  MOVF   x58,W
06CD4:  INCF   x58,F
06CD6:  BTFSC  FD8.2
06CD8:  INCF   x59,F
06CDA:  MOVWF  x5E
06CDC:  MOVFF  03,55F
06CE0:  MOVFF  55A,560
06CE4:  MOVF   FF2,W
06CE6:  MOVWF  00
06CE8:  BCF    FF2.7
06CEA:  MOVFF  55F,FAA
06CEE:  MOVFF  55E,FA9
06CF2:  MOVFF  560,FA8
06CF6:  BCF    FA6.6
06CF8:  BCF    FA6.7
06CFA:  BSF    FA6.2
06CFC:  MOVLB  F
06CFE:  MOVLW  55
06D00:  MOVWF  FA7
06D02:  MOVLW  AA
06D04:  MOVWF  FA7
06D06:  BSF    FA6.1
06D08:  BTFSC  FA6.1
06D0A:  BRA    6D08
06D0C:  BCF    FA6.2
06D0E:  MOVF   00,W
06D10:  IORWF  FF2,F
....................    write_eeprom(dest++, make8(dat32,1)); 
06D12:  MOVLB  5
06D14:  MOVF   x59,W
06D16:  MOVWF  03
06D18:  MOVF   x58,W
06D1A:  INCF   x58,F
06D1C:  BTFSC  FD8.2
06D1E:  INCF   x59,F
06D20:  MOVWF  x5E
06D22:  MOVFF  03,55F
06D26:  MOVFF  55B,560
06D2A:  MOVF   FF2,W
06D2C:  MOVWF  00
06D2E:  BCF    FF2.7
06D30:  MOVFF  55F,FAA
06D34:  MOVFF  55E,FA9
06D38:  MOVFF  560,FA8
06D3C:  BCF    FA6.6
06D3E:  BCF    FA6.7
06D40:  BSF    FA6.2
06D42:  MOVLB  F
06D44:  MOVLW  55
06D46:  MOVWF  FA7
06D48:  MOVLW  AA
06D4A:  MOVWF  FA7
06D4C:  BSF    FA6.1
06D4E:  BTFSC  FA6.1
06D50:  BRA    6D4E
06D52:  BCF    FA6.2
06D54:  MOVF   00,W
06D56:  IORWF  FF2,F
....................    write_eeprom(dest++, make8(dat32,2)); 
06D58:  MOVLB  5
06D5A:  MOVF   x59,W
06D5C:  MOVWF  03
06D5E:  MOVF   x58,W
06D60:  INCF   x58,F
06D62:  BTFSC  FD8.2
06D64:  INCF   x59,F
06D66:  MOVWF  x5E
06D68:  MOVFF  03,55F
06D6C:  MOVFF  55C,560
06D70:  MOVF   FF2,W
06D72:  MOVWF  00
06D74:  BCF    FF2.7
06D76:  MOVFF  55F,FAA
06D7A:  MOVFF  55E,FA9
06D7E:  MOVFF  560,FA8
06D82:  BCF    FA6.6
06D84:  BCF    FA6.7
06D86:  BSF    FA6.2
06D88:  MOVLB  F
06D8A:  MOVLW  55
06D8C:  MOVWF  FA7
06D8E:  MOVLW  AA
06D90:  MOVWF  FA7
06D92:  BSF    FA6.1
06D94:  BTFSC  FA6.1
06D96:  BRA    6D94
06D98:  BCF    FA6.2
06D9A:  MOVF   00,W
06D9C:  IORWF  FF2,F
....................    write_eeprom(dest, make8(dat32,3)); 
06D9E:  MOVFF  55D,55E
06DA2:  MOVFF  FF2,00
06DA6:  BCF    FF2.7
06DA8:  MOVFF  559,FAA
06DAC:  MOVFF  558,FA9
06DB0:  MOVFF  55D,FA8
06DB4:  BCF    FA6.6
06DB6:  BCF    FA6.7
06DB8:  BSF    FA6.2
06DBA:  MOVLW  55
06DBC:  MOVWF  FA7
06DBE:  MOVLW  AA
06DC0:  MOVWF  FA7
06DC2:  BSF    FA6.1
06DC4:  BTFSC  FA6.1
06DC6:  BRA    6DC4
06DC8:  BCF    FA6.2
06DCA:  MOVF   00,W
06DCC:  IORWF  FF2,F
06DCE:  MOVLB  0
06DD0:  RETURN 0
.................... }                                              
....................  
.................... void store_all_eeprom_values(void) 
.................... {                                                                                                   
....................  
....................    // store valve calibration times in EEPROM 
....................    write_ee2(EE_VLV_TIME_TO_OPEN, global_valve_time_to_open_1024th); 
*
0A02A:  MOVLB  5
0A02C:  CLRF   x57
0A02E:  MOVLW  04
0A030:  MOVWF  x56
0A032:  MOVFF  C8,559
0A036:  MOVFF  C7,558
0A03A:  MOVLB  0
0A03C:  CALL   3388
....................    write_ee2(EE_VLV_TIME_TO_CLOSE, global_valve_time_to_close_1024th); 
0A040:  MOVLB  5
0A042:  CLRF   x57
0A044:  MOVLW  06
0A046:  MOVWF  x56
0A048:  MOVFF  C6,559
0A04C:  MOVFF  C5,558
0A050:  MOVLB  0
0A052:  CALL   3388
....................    write_ee4(EE_VLV_CAL_UTC_TIME, global_valve_calibration_utc_time); 
0A056:  MOVLB  5
0A058:  CLRF   x59
0A05A:  MOVLW  08
0A05C:  MOVWF  x58
0A05E:  MOVFF  CE,55D
0A062:  MOVFF  CD,55C
0A066:  MOVFF  CC,55B
0A06A:  MOVFF  CB,55A
0A06E:  MOVLB  0
0A070:  CALL   6CCC
....................    write_ee2(EE_VLV_POSITION, global_valve_position); 
0A074:  MOVLB  5
0A076:  CLRF   x57
0A078:  MOVLW  0C
0A07A:  MOVWF  x56
0A07C:  MOVFF  C2,559
0A080:  MOVFF  C1,558
0A084:  MOVLB  0
0A086:  CALL   3388
....................    // save the shutdown/restart reason in EEPROM 
....................    write_ee1(EE_RESTART_CAUSE, global_shutdown_cause);                                         
0A08A:  MOVLB  5
0A08C:  CLRF   x55
0A08E:  MOVLW  02
0A090:  MOVWF  x54
0A092:  MOVFF  4D,556
0A096:  MOVLB  0
0A098:  CALL   3424
0A09C:  RETURN 0
....................                                                                          
.................... } 
....................  
....................  
.................... void read_all_eeprom_values(void) 
.................... { 
....................    // if EEPROM is freshly flashed, overwrite sprinkler number with 0 
....................    if (read_ee2(EE_SPRINKLER_NUM) == 0xFFFF) write_ee2(EE_SPRINKLER_NUM,0);      
*
03500:  MOVLB  5
03502:  CLRF   x55
03504:  CLRF   x54
03506:  MOVLB  0
03508:  RCALL  3332
0350A:  MOVFF  02,54C
0350E:  MOVFF  01,54B
03512:  MOVLB  5
03514:  INCFSZ 01,W
03516:  BRA    352A
03518:  INCFSZ x4C,W
0351A:  BRA    352A
0351C:  CLRF   x57
0351E:  CLRF   x56
03520:  CLRF   x59
03522:  CLRF   x58
03524:  MOVLB  0
03526:  RCALL  3388
03528:  MOVLB  5
....................    // pull the sprinkler number from EEPROM  
....................    global_sprinkler_num = read_ee2(EE_SPRINKLER_NUM); 
0352A:  CLRF   x55
0352C:  CLRF   x54
0352E:  MOVLB  0
03530:  RCALL  3332
03532:  MOVFF  02,96
03536:  MOVFF  01,95
....................    // grab the shutdown cause and overwrite it for next time 
....................    global_previous_shutdown_cause = read_ee1(EE_RESTART_CAUSE); 
0353A:  MOVLB  5
0353C:  CLRF   x55
0353E:  MOVLW  02
03540:  MOVWF  x54
03542:  MOVLB  0
03544:  RCALL  3402
03546:  MOVFF  01,4E
....................    write_ee1(EE_RESTART_CAUSE,NO_ERR); 
0354A:  MOVLB  5
0354C:  CLRF   x55
0354E:  MOVLW  02
03550:  MOVWF  x54
03552:  CLRF   x56
03554:  MOVLB  0
03556:  RCALL  3424
....................                                                     
....................    // read valve calibration times and position in EEPROM 
....................    // if freshly flashed, valve position should default to 0xFFFF, which 
....................    // is defined as VLV_POSITION_UNKNOWN 
....................    global_valve_time_to_open_1024th = read_ee2(EE_VLV_TIME_TO_OPEN); 
03558:  MOVLB  5
0355A:  CLRF   x55
0355C:  MOVLW  04
0355E:  MOVWF  x54
03560:  MOVLB  0
03562:  RCALL  3332
03564:  MOVFF  02,C8
03568:  MOVFF  01,C7
....................    global_valve_time_to_close_1024th = read_ee2(EE_VLV_TIME_TO_CLOSE); 
0356C:  MOVLB  5
0356E:  CLRF   x55
03570:  MOVLW  06
03572:  MOVWF  x54
03574:  MOVLB  0
03576:  RCALL  3332
03578:  MOVFF  02,C6
0357C:  MOVFF  01,C5
....................     
....................    if ((global_valve_time_to_open_1024th < ERROR_VLV_CAL_TIME_LO) || \ 
....................        (global_valve_time_to_open_1024th > ERROR_VLV_CAL_TIME_HI)) 
03580:  MOVF   xC8,W
03582:  SUBLW  02
03584:  BNC   358E
03586:  BNZ   359E
03588:  MOVF   xC7,W
0358A:  SUBLW  ED
0358C:  BC    359E
0358E:  MOVF   xC8,W
03590:  SUBLW  08
03592:  BC    35B6
03594:  XORLW  FF
03596:  BNZ   359E
03598:  MOVF   xC7,W
0359A:  SUBLW  C4
0359C:  BC    35B6
....................    { 
....................       global_valve_time_to_open_1024th = DEFAULT_VLV_TIME_TO_OPEN; 
0359E:  MOVLW  05
035A0:  MOVWF  xC8
035A2:  CLRF   xC7
....................       write_ee2 (EE_VLV_TIME_TO_OPEN, DEFAULT_VLV_TIME_TO_OPEN); 
035A4:  MOVLB  5
035A6:  CLRF   x57
035A8:  MOVLW  04
035AA:  MOVWF  x56
035AC:  MOVLW  05
035AE:  MOVWF  x59
035B0:  CLRF   x58
035B2:  MOVLB  0
035B4:  RCALL  3388
....................    } 
....................     
....................    if ((global_valve_time_to_close_1024th < ERROR_VLV_CAL_TIME_LO) || \ 
....................        (global_valve_time_to_close_1024th > ERROR_VLV_CAL_TIME_HI)) 
035B6:  MOVF   xC6,W
035B8:  SUBLW  02
035BA:  BNC   35C4
035BC:  BNZ   35D4
035BE:  MOVF   xC5,W
035C0:  SUBLW  ED
035C2:  BC    35D4
035C4:  MOVF   xC6,W
035C6:  SUBLW  08
035C8:  BC    35EC
035CA:  XORLW  FF
035CC:  BNZ   35D4
035CE:  MOVF   xC5,W
035D0:  SUBLW  C4
035D2:  BC    35EC
....................    { 
....................       global_valve_time_to_close_1024th = DEFAULT_VLV_TIME_TO_CLOSE; 
035D4:  MOVLW  05
035D6:  MOVWF  xC6
035D8:  CLRF   xC5
....................       write_ee2 (EE_VLV_TIME_TO_OPEN, DEFAULT_VLV_TIME_TO_OPEN); 
035DA:  MOVLB  5
035DC:  CLRF   x57
035DE:  MOVLW  04
035E0:  MOVWF  x56
035E2:  MOVLW  05
035E4:  MOVWF  x59
035E6:  CLRF   x58
035E8:  MOVLB  0
035EA:  RCALL  3388
....................    } 
....................  
....................  // for cleared EEPROM, the following read will give us 0xFFFFFFFF, so 
....................  //  add 1 so that it is 0.  This global is compared to current time 
....................  //  to determine if the valve calibration is stale 
....................    global_valve_calibration_utc_time = 1 + read_ee4(EE_VLV_CAL_UTC_TIME); 
035EC:  MOVLB  5
035EE:  CLRF   x55
035F0:  MOVLW  08
035F2:  MOVWF  x54
035F4:  MOVLB  0
035F6:  RCALL  3456
035F8:  MOVLW  01
035FA:  ADDWF  00,W
035FC:  MOVWF  xCB
035FE:  MOVLW  00
03600:  ADDWFC 01,W
03602:  MOVWF  xCC
03604:  MOVLW  00
03606:  ADDWFC 02,W
03608:  MOVWF  xCD
0360A:  MOVLW  00
0360C:  ADDWFC 03,W
0360E:  MOVWF  xCE
....................    global_valve_position = read_ee2(EE_VLV_POSITION); 
03610:  MOVLB  5
03612:  CLRF   x55
03614:  MOVLW  0C
03616:  MOVWF  x54
03618:  MOVLB  0
0361A:  RCALL  3332
0361C:  MOVFF  02,C2
03620:  MOVFF  01,C1
....................    // store unknown valve position incase it doesn't get stored properly on shutdown/restart 
....................    //    so the position isn't used from before 
....................    write_ee2(EE_VLV_POSITION, VLV_POSITION_UNKNOWN); 
03624:  MOVLB  5
03626:  CLRF   x57
03628:  MOVLW  0C
0362A:  MOVWF  x56
0362C:  SETF   x59
0362E:  SETF   x58
03630:  MOVLB  0
03632:  RCALL  3388
03634:  GOTO   A41C (RETURN)
....................  
.................... } 
....................  
.................... void store_vcal_eeprom_values(void) 
.................... {   
....................    // store valve calibration times in EEPROM 
....................    write_ee2(EE_VLV_TIME_TO_OPEN, global_valve_time_to_open_1024th); 
*
0829E:  MOVLB  5
082A0:  CLRF   x57
082A2:  MOVLW  04
082A4:  MOVWF  x56
082A6:  MOVFF  C8,559
082AA:  MOVFF  C7,558
082AE:  MOVLB  0
082B0:  CALL   3388
....................    write_ee2(EE_VLV_TIME_TO_CLOSE, global_valve_time_to_close_1024th); 
082B4:  MOVLB  5
082B6:  CLRF   x57
082B8:  MOVLW  06
082BA:  MOVWF  x56
082BC:  MOVFF  C6,559
082C0:  MOVFF  C5,558
082C4:  MOVLB  0
082C6:  CALL   3388
....................    write_ee4(EE_VLV_CAL_UTC_TIME, global_valve_calibration_utc_time); 
082CA:  MOVLB  5
082CC:  CLRF   x59
082CE:  MOVLW  08
082D0:  MOVWF  x58
082D2:  MOVFF  CE,55D
082D6:  MOVFF  CD,55C
082DA:  MOVFF  CC,55B
082DE:  MOVFF  CB,55A
082E2:  MOVLB  0
082E4:  CALL   6CCC
082E8:  GOTO   A9BC (RETURN)
.................... }                                                               
....................  
.................... void read_all_eeprom_variables(void)     
.................... {                                        
....................    uint16_t temp_u16; 
....................  
....................    temp_u16 = read_ee2(EE_VLV_NEAR_CLOSED_RANGE_MAX);        
*
03638:  MOVLB  5
0363A:  CLRF   x55
0363C:  MOVLW  0E
0363E:  MOVWF  x54
03640:  MOVLB  0
03642:  RCALL  3332
03644:  MOVFF  02,54C
03648:  MOVFF  01,54B
....................    if (temp_u16 != 0xFFFF) VLV_NEAR_CLOSED_RANGE_MAX = temp_u16;  
0364C:  MOVLB  5
0364E:  INCFSZ x4B,W
03650:  BRA    3658
03652:  INCFSZ x4C,W
03654:  BRA    3658
03656:  BRA    3660
03658:  MOVFF  54C,507
0365C:  MOVFF  54B,506
....................     
....................    temp_u16 = read_ee2(EE_VLV_NEAR_OPENED_RANGE_MAX);        
03660:  CLRF   x55
03662:  MOVLW  10
03664:  MOVWF  x54
03666:  MOVLB  0
03668:  RCALL  3332
0366A:  MOVFF  02,54C
0366E:  MOVFF  01,54B
....................    if (temp_u16 != 0xFFFF) VLV_NEAR_OPENED_RANGE_MAX = temp_u16; 
03672:  MOVLB  5
03674:  INCFSZ x4B,W
03676:  BRA    367E
03678:  INCFSZ x4C,W
0367A:  BRA    367E
0367C:  BRA    3686
0367E:  MOVFF  54C,509
03682:  MOVFF  54B,508
....................     
....................    temp_u16 = read_ee2(EE_DAC_LVL_OPENING_NEAR_OPENED);        
03686:  CLRF   x55
03688:  MOVLW  12
0368A:  MOVWF  x54
0368C:  MOVLB  0
0368E:  RCALL  3332
03690:  MOVFF  02,54C
03694:  MOVFF  01,54B
....................    if (temp_u16 != 0xFFFF) DAC_LVL_OPENING_NEAR_OPENED = temp_u16; 
03698:  MOVLB  5
0369A:  INCFSZ x4B,W
0369C:  BRA    36A4
0369E:  INCFSZ x4C,W
036A0:  BRA    36A4
036A2:  BRA    36AC
036A4:  MOVFF  54C,50B
036A8:  MOVFF  54B,50A
....................     
....................    temp_u16 = read_ee2(EE_DAC_LVL_OPENING_NEAR_CLOSED);        
036AC:  CLRF   x55
036AE:  MOVLW  14
036B0:  MOVWF  x54
036B2:  MOVLB  0
036B4:  RCALL  3332
036B6:  MOVFF  02,54C
036BA:  MOVFF  01,54B
....................    if (temp_u16 != 0xFFFF) DAC_LVL_OPENING_NEAR_CLOSED = temp_u16; 
036BE:  MOVLB  5
036C0:  INCFSZ x4B,W
036C2:  BRA    36CA
036C4:  INCFSZ x4C,W
036C6:  BRA    36CA
036C8:  BRA    36D2
036CA:  MOVFF  54C,50D
036CE:  MOVFF  54B,50C
....................     
....................    temp_u16 = read_ee2(EE_DAC_LVL_CLOSING_NEAR_OPENED);        
036D2:  CLRF   x55
036D4:  MOVLW  16
036D6:  MOVWF  x54
036D8:  MOVLB  0
036DA:  RCALL  3332
036DC:  MOVFF  02,54C
036E0:  MOVFF  01,54B
....................    if (temp_u16 != 0xFFFF) DAC_LVL_CLOSING_NEAR_OPENED = temp_u16; 
036E4:  MOVLB  5
036E6:  INCFSZ x4B,W
036E8:  BRA    36F0
036EA:  INCFSZ x4C,W
036EC:  BRA    36F0
036EE:  BRA    36F8
036F0:  MOVFF  54C,50F
036F4:  MOVFF  54B,50E
....................     
....................    temp_u16 = read_ee2(EE_DAC_LVL_CLOSING_NEAR_CLOSED);        
036F8:  CLRF   x55
036FA:  MOVLW  18
036FC:  MOVWF  x54
036FE:  MOVLB  0
03700:  RCALL  3332
03702:  MOVFF  02,54C
03706:  MOVFF  01,54B
....................    if (temp_u16 != 0xFFFF) DAC_LVL_CLOSING_NEAR_CLOSED = temp_u16; 
0370A:  MOVLB  5
0370C:  INCFSZ x4B,W
0370E:  BRA    3716
03710:  INCFSZ x4C,W
03712:  BRA    3716
03714:  BRA    371E
03716:  MOVFF  54C,511
0371A:  MOVFF  54B,510
....................     
....................    temp_u16 = read_ee2(EE_DAC_LVL_IN_MIDDLE);        
0371E:  CLRF   x55
03720:  MOVLW  1A
03722:  MOVWF  x54
03724:  MOVLB  0
03726:  RCALL  3332
03728:  MOVFF  02,54C
0372C:  MOVFF  01,54B
....................    if (temp_u16 != 0xFFFF) DAC_LVL_IN_MIDDLE = temp_u16; 
03730:  MOVLB  5
03732:  INCFSZ x4B,W
03734:  BRA    373C
03736:  INCFSZ x4C,W
03738:  BRA    373C
0373A:  BRA    3744
0373C:  MOVFF  54C,513
03740:  MOVFF  54B,512
....................     
....................    temp_u16 = read_ee2(EE_DAC_LVL_INIT_CURRENT_BOOST);        
03744:  CLRF   x55
03746:  MOVLW  1C
03748:  MOVWF  x54
0374A:  MOVLB  0
0374C:  RCALL  3332
0374E:  MOVFF  02,54C
03752:  MOVFF  01,54B
....................    if (temp_u16 != 0xFFFF) DAC_LVL_INIT_CURRENT_BOOST = temp_u16; 
03756:  MOVLB  5
03758:  INCFSZ x4B,W
0375A:  BRA    3762
0375C:  INCFSZ x4C,W
0375E:  BRA    3762
03760:  BRA    376A
03762:  MOVFF  54C,515
03766:  MOVFF  54B,514
....................     
....................    temp_u16 = read_ee2(EE_VLV_INIT_CURRENT_BOOST_TIME_1024THS);        
0376A:  CLRF   x55
0376C:  MOVLW  1E
0376E:  MOVWF  x54
03770:  MOVLB  0
03772:  RCALL  3332
03774:  MOVFF  02,54C
03778:  MOVFF  01,54B
....................    if (temp_u16 != 0xFFFF) VLV_INIT_CURRENT_BOOST_TIME_1024THS = temp_u16; 
0377C:  MOVLB  5
0377E:  INCFSZ x4B,W
03780:  BRA    3788
03782:  INCFSZ x4C,W
03784:  BRA    3788
03786:  BRA    3790
03788:  MOVFF  54C,517
0378C:  MOVFF  54B,516
....................     
....................    temp_u16 = read_ee2(EE_VLV_NOT_SPIN_LIMIT);        
03790:  CLRF   x55
03792:  MOVLW  20
03794:  MOVWF  x54
03796:  MOVLB  0
03798:  RCALL  3332
0379A:  MOVFF  02,54C
0379E:  MOVFF  01,54B
....................    if (temp_u16 != 0xFFFF) VLV_NOT_SPIN_LIMIT = temp_u16; 
037A2:  MOVLB  5
037A4:  INCFSZ x4B,W
037A6:  BRA    37AE
037A8:  INCFSZ x4C,W
037AA:  BRA    37AE
037AC:  BRA    37B6
037AE:  MOVFF  54C,519
037B2:  MOVFF  54B,518
....................     
....................    temp_u16 = read_ee2(EE_VLV_NOT_SPIN_FIX);        
037B6:  CLRF   x55
037B8:  MOVLW  22
037BA:  MOVWF  x54
037BC:  MOVLB  0
037BE:  RCALL  3332
037C0:  MOVFF  02,54C
037C4:  MOVFF  01,54B
....................    if (temp_u16 != 0xFFFF) VLV_NOT_SPIN_FIX = temp_u16;   
037C8:  MOVLB  5
037CA:  INCFSZ x4B,W
037CC:  BRA    37D4
037CE:  INCFSZ x4C,W
037D0:  BRA    37D4
037D2:  BRA    37DC
037D4:  MOVFF  54C,51B
037D8:  MOVFF  54B,51A
....................     
....................    temp_u16 = read_ee2(EE_NOT_SPINNING_MAG_DECOUPLING_RPM_FIXED);        
037DC:  CLRF   x55
037DE:  MOVLW  24
037E0:  MOVWF  x54
037E2:  MOVLB  0
037E4:  RCALL  3332
037E6:  MOVFF  02,54C
037EA:  MOVFF  01,54B
....................    if (temp_u16 != 0xFFFF) NOT_SPINNING_MAG_DECOUPLING_RPM_FIXED = temp_u16;   
037EE:  MOVLB  5
037F0:  INCFSZ x4B,W
037F2:  BRA    37FA
037F4:  INCFSZ x4C,W
037F6:  BRA    37FA
037F8:  BRA    37FE
037FA:  MOVFF  54B,51C
....................     
....................    temp_u16 = read_ee2(EE_VLV_MAGNETIC_COUPLING_LIMIT);        
037FE:  CLRF   x55
03800:  MOVLW  26
03802:  MOVWF  x54
03804:  MOVLB  0
03806:  RCALL  3332
03808:  MOVFF  02,54C
0380C:  MOVFF  01,54B
....................    if (temp_u16 != 0xFFFF) VLV_MAGNETIC_COUPLING_LIMIT = temp_u16;   
03810:  MOVLB  5
03812:  INCFSZ x4B,W
03814:  BRA    381C
03816:  INCFSZ x4C,W
03818:  BRA    381C
0381A:  BRA    3824
0381C:  MOVFF  54C,51E
03820:  MOVFF  54B,51D
....................     
....................    temp_u16 = read_ee2(EE_VLV_MAGNETIC_COUPLING_FIX);        
03824:  CLRF   x55
03826:  MOVLW  28
03828:  MOVWF  x54
0382A:  MOVLB  0
0382C:  RCALL  3332
0382E:  MOVFF  02,54C
03832:  MOVFF  01,54B
....................    if (temp_u16 != 0xFFFF) VLV_MAGNETIC_COUPLING_FIX = temp_u16; 
03836:  MOVLB  5
03838:  INCFSZ x4B,W
0383A:  BRA    3842
0383C:  INCFSZ x4C,W
0383E:  BRA    3842
03840:  BRA    384A
03842:  MOVFF  54C,520
03846:  MOVFF  54B,51F
....................     
....................    temp_u16 = read_ee2(EE_RPM_TIMEOUT);                       
0384A:  CLRF   x55
0384C:  MOVLW  2A
0384E:  MOVWF  x54
03850:  MOVLB  0
03852:  RCALL  3332
03854:  MOVFF  02,54C
03858:  MOVFF  01,54B
....................    if (temp_u16 != 0xFFFF) RPM_TIMEOUT = temp_u16;   
0385C:  MOVLB  5
0385E:  INCFSZ x4B,W
03860:  BRA    3868
03862:  INCFSZ x4C,W
03864:  BRA    3868
03866:  BRA    3870
03868:  MOVFF  54C,522
0386C:  MOVFF  54B,521
....................     
....................    temp_u16 = read_ee2(EE_MOTE_SEARCH_TIME);        
03870:  CLRF   x55
03872:  MOVLW  2C
03874:  MOVWF  x54
03876:  MOVLB  0
03878:  RCALL  3332
0387A:  MOVFF  02,54C
0387E:  MOVFF  01,54B
....................    if (temp_u16 != 0xFFFF) MOTE_SEARCH_TIME = temp_u16;   
03882:  MOVLB  5
03884:  INCFSZ x4B,W
03886:  BRA    388E
03888:  INCFSZ x4C,W
0388A:  BRA    388E
0388C:  BRA    3896
0388E:  MOVFF  54C,524
03892:  MOVFF  54B,523
....................     
....................    temp_u16 = read_ee2(EE_MOTE_NETWORK_SHUTDOWN_TIMEOUT);        
03896:  CLRF   x55
03898:  MOVLW  2E
0389A:  MOVWF  x54
0389C:  MOVLB  0
0389E:  RCALL  3332
038A0:  MOVFF  02,54C
038A4:  MOVFF  01,54B
....................    if (temp_u16 != 0xFFFF) MOTE_NETWORK_SHUTDOWN_TIMEOUT = temp_u16;    
038A8:  MOVLB  5
038AA:  INCFSZ x4B,W
038AC:  BRA    38B4
038AE:  INCFSZ x4C,W
038B0:  BRA    38B4
038B2:  BRA    38BC
038B4:  MOVFF  54C,526
038B8:  MOVFF  54B,525
038BC:  MOVLB  0
038BE:  GOTO   A420 (RETURN)
.................... } 
....................     
....................  
.................... ////////////////////EEPROM Functions End///////////////////////////////////////////////////////////////  
....................                                                                                                     
....................  
....................   
....................  
....................   
.................... // specific headers                    
.................... #include "pic.h" 
.................... // This file contains all functions related to PIC functions and setup 
....................  
.................... //Function Definitions 
....................  
.................... // These defines are used in the oscillator setup subroutines below. 
.................... // Note the situations of concern: 
.................... //    4MHz osc: TMR2 prescale 16, postscale 6, PR2=99;         DIV16_POST6  
.................... //       [PWM freq 625Hz, PWM resolution 400, TMR2 int rate: 9.6ms] 
.................... //    3.6864MHz osc: TMR2 prescale 16, postscale 6, PR2=99;    DIV16_POST6 
.................... //       [PWM freq 576Hz, PWM resolution 400, TMR2 int rate: 10.4ms] 
.................... //    1MHz osc: TMR2 prescale 4, postscale 6, PR2=99;          DIV4_POST6 
.................... //       [PWM freq 625Hz, PWM resolution 400, TMR2 int rate: 9.6ms] 
.................... //    250KHz osc: TMR2 prescale 16, postscale 6, PR2=99;       DIV1_POST6 
.................... //       [PWM freq 625Hz, PWM resolution 400, TMR2 int rate: 9.6ms] 
.................... //    32768Hz osc: TMR2 prescale 1, postscale 1, PR2=79;       DIV1_POST1 
.................... //       [no PWM, TMR2 int rate: 9.8ms] 
.................... //    31250Hz osc: TMR2 prescale 1, postscale 1, PR2=79;       DIV1_POST1 
.................... //       [no PWM, TMR2 int rate: 10.2ms] 
....................  
.................... // SEE p 177 of DS41412F [PIC18(L)F2X/4XK22 datasheet] 
.................... #define  DIV16_POST6    0b00101110 
.................... #define  DIV4_POST6     0b00101101 
.................... #define  DIV1_POST6     0b00101100 
.................... #define  DIV1_POST1     0b00000100 
....................  
.................... // Each of these subroutines 
.................... //    a. save INTCON (high and low global int enab bits) 
.................... //    b. disable global interrupts 
.................... //    c. select the oscillator 
.................... //    d. set up TMR2, which is used to produce the PWM waveforms 
.................... //       and to cause interrupts to checking, e.g., the valve motor current 
.................... //    e. set up delnum param used by the newdel_10ms routine, 
.................... //       which is oscillator-dependent 
.................... //    f. restore INTCON 
....................  
.................... // These routines simply set up OSCCON, T0CON, T2CON, PR2 and osctype. 
....................  
.................... // PR2 is selected to provide a resolution of 400 in the PWM duty cycle 
.................... //  when clock is 250KHz and above. 
.................... // Below 250KHz the duty cycle resolution is unimportant because we would  
.................... //  be idling... 
.................... // The combination of PR2 and T2CON (T2CON includes prescale (1/4/16)  
.................... //  and postscale (..6..) ensures that the TMR2 ints occur at the proper rate  
.................... //  of approx 10ms regardless of the oscillator choice. 
.................... // Finally T0CON is set such that the timer 0 prescaler is selected to provide 
.................... //  TMR0 functionality and accuracy largely independent of oscillator choice: 
.................... //  e.g., at 31250/250k/1m/4m clock, T0CON is set such that the prescaler is  
.................... //   set to 2/16/64/256 thus providing a consistent counting rate of 3906.25Hz 
.................... //   and a programmable overflow time ranging from 256us up to about 16.8s 
.................... //  Accuracy is a bit compromised when running with the 3.6864MHz primary  
.................... //   crystal, but this error is not significant.... (an 8.5% error...) 
....................  
.................... //  Interrupts disabled to prevent reentrancy 
.................... void     fosc_pri(void) 
.................... { 
....................    uint8_t     tmp_intcon; 
....................    tmp_intcon = INTCON & 0xC0; 
*
01172:  MOVF   FF2,W
01174:  ANDLW  C0
01176:  MOVLB  6
01178:  MOVWF  x19
....................    disable_interrupts(GLOBAL); 
0117A:  BCF    FF2.6
0117C:  BCF    FF2.7
0117E:  BTFSC  FF2.7
01180:  BRA    117C
....................    OSCCON = 0x00;       // select primary xtal oscillator 
01182:  CLRF   FD3
....................    T0CON = T0_DIV_256;  // 278usec per tick 
01184:  MOVLW  07
01186:  MOVWF  FD5
....................    T2CON = 0b01110010;  // T2 scale factor 15*16 (248usec per tick equiv) 
01188:  MOVLW  72
0118A:  MOVWF  FBA
....................    T4CON = 0b01110010;  // T4 scale factor 15*16 (248usec per tick equiv) 
0118C:  MOVLB  F
0118E:  MOVWF  x51
....................    PR2 = 99;            
01190:  MOVLW  63
01192:  MOVWF  FBB
....................    INTCON |= tmp_intcon; 
01194:  MOVLB  6
01196:  MOVF   x19,W
01198:  IORWF  FF2,F
0119A:  MOVLB  0
0119C:  RETURN 0
.................... } 
....................  
.................... void     fosc_pri_ISR(void) 
.................... { 
....................    uint8_t     tmp_intcon; 
....................    tmp_intcon = INTCON & 0xC0; 
*
00916:  MOVF   FF2,W
00918:  ANDLW  C0
0091A:  MOVLB  5
0091C:  MOVWF  xFC
....................    disable_interrupts(GLOBAL); 
0091E:  BCF    FF2.6
00920:  BCF    FF2.7
00922:  BTFSC  FF2.7
00924:  BRA    0920
....................    OSCCON = 0x00;       // select primary xtal oscillator 
00926:  CLRF   FD3
....................    T0CON = T0_DIV_256;  // 278usec per tick 
00928:  MOVLW  07
0092A:  MOVWF  FD5
....................    T2CON = 0b01110010;  // T2 scale factor 15*16 (248usec per tick equiv) 
0092C:  MOVLW  72
0092E:  MOVWF  FBA
....................    T4CON = 0b01110010;  // T4 scale factor 15*16 (248usec per tick equiv) 
00930:  MOVLB  F
00932:  MOVWF  x51
....................    PR2 = 99; 
00934:  MOVLW  63
00936:  MOVWF  FBB
....................    INTCON |= tmp_intcon; 
00938:  MOVLB  5
0093A:  MOVF   xFC,W
0093C:  IORWF  FF2,F
0093E:  MOVLB  0
00940:  GOTO   17E6 (RETURN)
.................... } 
....................  
.................... void     fosc_4m(void) 
.................... { 
....................    uint8_t     tmp_intcon; 
....................    tmp_intcon = INTCON & 0xC0; 
....................    disable_interrupts(GLOBAL); 
....................    OSCCON = 0x52;       // select 4MHz internal oscillator 
....................    T0CON = T0_DIV_256;  // 256usec per tick 
....................    T2CON = 0b01111010;  // T2 scale factor 16x16 (256usec per tick equiv) 
....................    T4CON = 0b01111010;  // T4 scale factor 16x16 (256usec per tick equiv) 
....................    PR2 = 99; 
....................    INTCON |= tmp_intcon; 
.................... } 
....................  
....................  
.................... void     fosc_1m(void) 
.................... { 
....................    uint8_t     tmp_intcon; 
....................    tmp_intcon = INTCON & 0xC0; 
....................    disable_interrupts(GLOBAL); 
....................    OSCCON = 0x32;       // select 1MHz internal oscillator 
....................    T0CON = T0_DIV_64;   // 256usec per tick 
....................    T2CON = 0b00011010;  // T2 scale factor 4*16 (256usec per tick equiv) 
....................    T4CON = 0b00011010;  // T4 scale factor 4*16 (256usec per tick equiv) 
....................    PR2 = 99; 
....................    INTCON |= tmp_intcon; 
.................... } 
....................  
.................... void     fosc_250k(void) 
.................... { 
....................    uint8_t     tmp_intcon; 
....................    tmp_intcon = INTCON & 0xC0; 
*
032B8:  MOVF   FF2,W
032BA:  ANDLW  C0
032BC:  MOVLB  5
032BE:  MOVWF  x4B
....................    disable_interrupts(GLOBAL); 
032C0:  BCF    FF2.6
032C2:  BCF    FF2.7
032C4:  BTFSC  FF2.7
032C6:  BRA    32C2
....................    OSCCON = 0x12;       // select 250KHz internal oscillator 
032C8:  MOVLW  12
032CA:  MOVWF  FD3
....................    T0CON = T0_DIV_16;   // 256usec per tick 
032CC:  MOVLW  03
032CE:  MOVWF  FD5
....................    T2CON = 0b00000010;  // T2 scale factor 1*16 (256usec per tick equiv) 
032D0:  MOVLW  02
032D2:  MOVWF  FBA
....................    T4CON = 0b00000010;  // T4 scale factor 1*16 (256usec per tick equiv) 
032D4:  MOVLB  F
032D6:  MOVWF  x51
....................    PR2 = 99; 
032D8:  MOVLW  63
032DA:  MOVWF  FBB
....................    INTCON |= tmp_intcon; 
032DC:  MOVLB  5
032DE:  MOVF   x4B,W
032E0:  IORWF  FF2,F
032E2:  MOVLB  0
032E4:  GOTO   32F0 (RETURN)
.................... } 
....................  
.................... void     fosc_250k_ISR(void)  
.................... { 
....................    uint8_t     tmp_intcon; 
....................    tmp_intcon = INTCON & 0xC0; 
....................    disable_interrupts(GLOBAL); 
....................    OSCCON = 0x12;       // select 250KHz internal oscillator 
....................    T0CON = T0_DIV_16;   // 256usec per tick 
....................    T2CON = 0b00000010;  // T2 scale factor 1*16 (256usec per tick equiv) 
....................    T4CON = 0b00000010;  // T4 scale factor 1*16 (256usec per tick equiv) 
....................    PR2 = 99; 
....................    INTCON |= tmp_intcon; 
.................... } 
....................  
.................... void     fosc_31250(void) 
.................... { 
....................    uint8_t     tmp_intcon; 
....................    tmp_intcon = INTCON & 0xC0; 
....................    disable_interrupts(GLOBAL); 
....................    OSCCON = 0x02;       // select 31250Hz internal oscillator 
....................    T0CON = T0_DIV_2;    // 256usec per tick 
....................    T2CON = 0b00001000;  // T2 scale factor 2*1 (256usec per tick equiv) 
....................    T4CON = 0b00001000;  // T4 scale factor 2*1 (256usec per tick equiv) 
....................    PR2 = 79; 
....................    INTCON |= tmp_intcon; 
.................... }       
....................  
.................... void     fosc_31250_ISR(void)  
.................... { 
....................    uint8_t     tmp_intcon; 
....................    tmp_intcon = INTCON & 0xC0; 
....................    disable_interrupts(GLOBAL); 
....................    OSCCON = 0x02;       // select 31250Hz internal oscillator 
....................    T0CON = T0_DIV_2;    // 256usec per tick 
....................    T2CON = 0b00001000;  // T2 scale factor 2*1 (256usec per tick equiv) 
....................    T4CON = 0b00001000;  // T4 scale factor 2*1 (256usec per tick equiv) 
....................    PR2 = 79; 
....................    INTCON |= tmp_intcon; 
.................... }       
....................  
.................... void     fosc_sec(void) 
.................... { 
....................    uint8_t     tmp_intcon; 
....................    tmp_intcon = INTCON & 0xC0; 
....................    disable_interrupts(GLOBAL); 
....................    OSCCON = 0x01;       // select secondary xtal oscillator 
....................    T0CON = T0_DIV_2;    // 244usec per tick 
....................    T2CON = 0b00001000;  // T2 scale factor 2*1 (244usec per tick equiv) 
....................    T4CON = 0b00001000;  // T4 scale factor 2*1 (244usec per tick equiv) 
....................    PR2 = 79; 
....................    INTCON |= tmp_intcon; 
.................... } 
....................  
.................... void osc_init(void) 
.................... { 
.................... // initalizes the oscillators/crystals, sets up delays, RS232, and i2c 
....................  
....................     
....................    // set stack pointer to 0 in case things restart 
....................    STKPTR = 0; 
032E8:  CLRF   FFC
....................     
....................    #use delay(clock=3,686,400) 
....................    #use RS232 (uart1, baud=115200, ERRORS) 
*
0119E:  BTFSS  F9E.4
011A0:  BRA    119E
011A2:  MOVWF  FAD
011A4:  RETURN 0
....................    //#use RS232 (uart2, baud=9600) 
....................     
....................    // start up 32.768KHz xtal oscillator 
....................    SOSCGO = TRUE; 
*
032EA:  BSF    FD2.3
....................    // use medium freq internal osc (lower power) for 250KHz and 500KHz choices   
....................    MFIOSEL = TRUE;   
032EC:  BSF    FD2.4
....................     
....................    // switch to main 250k internal osc and setup delay functions                                     
....................    fosc_250k(); 
032EE:  BRA    32B8
....................    #use delay(clock=250KHZ) 
*
03946:  MOVLW  05
03948:  MOVWF  FEA
0394A:  MOVLW  64
0394C:  MOVWF  FE9
0394E:  MOVF   FEF,W
03950:  BZ    3960
03952:  MOVLW  13
03954:  MOVWF  00
03956:  DECFSZ 00,F
03958:  BRA    3956
0395A:  NOP   
0395C:  DECFSZ FEF,F
0395E:  BRA    3952
03960:  RETURN 0
....................     
....................    // setup i2c for use on 250khz main clock 
....................    #use i2c(master, I2C1, FORCE_HW, NO_STRETCH, FAST=10000) 
*
032F0:  GOTO   A3D8 (RETURN)
*
03962:  BCF    FC6.7
03964:  BCF    F9E.3
03966:  MOVFF  57C,FC9
0396A:  MOVLW  02
0396C:  BTFSC  FC6.7
0396E:  BRA    397A
03970:  BTFSS  F9E.3
03972:  BRA    3970
03974:  MOVLW  00
03976:  BTFSC  FC5.6
03978:  MOVLW  01
0397A:  MOVWF  01
0397C:  RETURN 0
.................... } 
....................  
....................     
....................    // during initialization, except for servicing the mote, the fosc is 
....................    //  always at 250KHz 
....................    // The #use delay above ensures that delay_ms instructions are  
....................    //  compiled properly 
....................    // Built-in compiler delay functionality works fine until mote ints 
....................    //  occur because mote service speeds up the clock and screws up the 
....................    //  compiler built-in delay function..... 
....................  
....................    // The assumption is that I2C communications takes place when system  
....................    //  clock is set to 250KHz 
....................     
.................... void     setup_T0_int(uint16_t value) 
.................... { 
.................... // Use this routine to set up TMR0 such that its flag sets after  
.................... //  the designated time. 
.................... // These are not functions that hang up processing.  They merely ensure 
.................... //  that something takes place before a programmable amount of time passes. 
.................... // 
.................... // Add more possibilities as required.... 
.................... // The defines for "value" can be found in the .h file 
....................    disable_interrupts(GLOBAL); 
*
038C2:  BCF    FF2.6
038C4:  BCF    FF2.7
038C6:  BTFSC  FF2.7
038C8:  BRA    38C4
....................    TMR0ON = FALSE; 
038CA:  BCF    FD5.7
....................    set_timer0(value); 
038CC:  MOVFF  569,FD7
038D0:  MOVFF  568,FD6
....................    TMR0IF = FALSE; 
038D4:  BCF    FF2.2
....................    TMR0ON = TRUE; 
038D6:  BSF    FD5.7
....................    enable_interrupts(GLOBAL); 
038D8:  MOVLW  C0
038DA:  IORWF  FF2,F
038DC:  RETURN 0
.................... } 
....................  
.................... void     setup_T2_int(uint8_t value) 
.................... { 
.................... // Use this routine during ISRs to set up TMR4 such that its flag sets 
.................... //  after the designated time. 
....................    TMR2ON = FALSE; 
*
05082:  BCF    FBA.2
....................    set_timer2(0); 
05084:  CLRF   FBC
....................    PR2 = value; 
05086:  MOVFF  54B,FBB
....................    TMR2IF = FALSE; 
0508A:  BCF    F9E.1
....................    TMR2ON = TRUE; 
0508C:  BSF    FBA.2
0508E:  RETURN 0
.................... } 
....................  
.................... void     setup_T4_int(uint8_t value) 
.................... { 
.................... // Use this routine during ISRs to set up TMR4 such that its flag sets 
.................... //  after the designated time. 
....................    TMR4ON = FALSE; 
*
00944:  MOVLB  F
00946:  BCF    x51.2
....................    set_timer4(0); 
00948:  CLRF   x53
....................    PR4 = value; 
0094A:  MOVFF  619,F52
....................    TMR4IF = FALSE; 
0094E:  BCF    F7E.0
....................    TMR4ON = TRUE; 
00950:  BSF    x51.2
00952:  MOVLB  0
00954:  RETURN 0
.................... } 
....................  
....................  
.................... void periph_init(void) 
.................... {  
....................    /* Initalizes and configures all perhips, ports, timers, etc. 
....................     * Items initalized include: 
....................     * Interrupts 
....................     * GPIOs 
....................     * Pullup resistors (Port B) 
....................     * Unused periphs in pic (turned off for lower power usage) 
....................     * Timers 
....................     * CCPs 
....................     *  
....................     */ 
....................  
....................    // extra insurance that we aren't interrupted while setting up periph    
....................    disable_interrupts(GLOBAL); 
*
04094:  BCF    FF2.6
04096:  BCF    FF2.7
04098:  BTFSC  FF2.7
0409A:  BRA    4096
....................     
....................    // get I/O lines and hardware in general into LOWEST POSSIBLE current draw 
....................    setup_vref(VREF_OFF); 
0409C:  MOVLB  F
0409E:  CLRF   x42
....................    setup_dac(DAC_OFF); 
040A0:  CLRF   x41
....................    setup_adc(ADC_OFF); 
040A2:  BCF    FC2.0
....................     
....................    // ensure that the CTMU is off 
....................    CTMUICON = 0; 
040A4:  CLRF   x43
....................    CTMUCONL = 0; 
040A6:  CLRF   x44
....................    CTMUCONH = 0; 
040A8:  CLRF   x45
....................     
....................    // ensure that the SR latch is off 
....................    SRCON0 = 0; 
040AA:  CLRF   x47
....................    SRCON1 = 0; 
040AC:  CLRF   x46
....................  
....................    // turns off comarator. Funny define from PICklkk 
....................    setup_comparator(NC_NC_NC_NC); 
040AE:  CLRF   F77
040B0:  MOVLW  04
040B2:  MOVWF  F78
040B4:  MOVWF  F79
....................     
....................    /* definitively establishes that TMR2 is used to generate PWM frequency 
....................     * for P1x, P2x, P3x 
....................     */ 
....................    CCPTMRS0 = 0; 
040B6:  CLRF   x49
....................    CCPTMRS1 = 0;     
040B8:  CLRF   x48
....................     
....................    /* ADC setup (ports, configuration, reference) 
....................     * to perform an acquisition, select the channel and then turn on the ADC 
....................     * [ADON=TRUE]. Then do a read_adc() 
....................     */ 
....................    setup_adc_ports(sAN0|sAN1|sAN12); 
040BA:  MOVF   FC1,W
040BC:  ANDLW  F0
040BE:  MOVWF  FC1
040C0:  MOVLW  03
040C2:  MOVWF  x38
040C4:  MOVLW  00
040C6:  MOVWF  x3C
040C8:  MOVLW  01
040CA:  MOVWF  x39
040CC:  MOVLW  00
040CE:  MOVWF  x3A
040D0:  MOVWF  x3B
....................    ADCON2 = ADC_SETUP_DEF; 
040D2:  SETF   FC0
....................    setup_adc_reference(VSS_VDD); 
040D4:  BCF    FC1.0
040D6:  BCF    FC1.1
040D8:  BCF    FC1.2
040DA:  BCF    FC1.3
....................     
....................    /* setup pullup resistors on Port B for Mote Uart flow and XDCR detection    
....................     * RB2 (MOTE_TX_RTSn)    
....................     */  
....................     // JG: think about this in light of other port_b_pullups code! 
....................    port_b_pullups(0b00000100); 
040DC:  MOVLW  04
040DE:  MOVWF  F61
040E0:  BCF    FF1.7
....................                                            
....................    // turns uart off 
....................    setup_uart(FALSE); 
040E2:  BCF    FAB.7
040E4:  BCF    FAB.4
040E6:  BCF    FAC.5
....................     
....................    // set the inital state and i/o characteristics for all ports 
....................    output_a(PORTA_INIT);                
040E8:  MOVLW  74
040EA:  MOVWF  F89
....................    output_b(PORTB_INIT); 
040EC:  MOVLW  18
040EE:  MOVWF  F8A
....................    output_c(PORTC_INIT); 
040F0:  MOVLW  45
040F2:  MOVWF  F8B
....................    output_d(PORTD_INIT); 
040F4:  MOVLW  76
040F6:  MOVWF  F8C
....................    output_e(PORTE_INIT); 
040F8:  CLRF   F8D
....................    set_tris_a(TRISA_NORM); 
040FA:  MOVLW  8B
040FC:  MOVWF  F92
....................    set_tris_b(TRISB_NORM); 
040FE:  MOVLW  F7
04100:  MOVWF  F93
....................    set_tris_c(TRISC_NORM); 
04102:  MOVLW  9A
04104:  MOVWF  F94
....................    set_tris_d(TRISD_NORM); 
04106:  MOVLW  80
04108:  MOVWF  F95
....................    set_tris_e(TRISE_NORM); 
0410A:  BCF    F96.0
0410C:  BCF    F96.1
0410E:  BSF    F96.2
04110:  BSF    F96.3
....................   
....................    //********************Timers setup start********************     
....................     
....................    // TMR0 for general timing functions 
....................    setup_timer_0(T0_OFF); 
04112:  CLRF   FD5
....................     
....................    /* TMR1 is used in valve motion algorithm 
....................     * It is timed by the external secondary (32.768kHz) xtal 
....................     * Initalized in off mode 
....................     */ 
....................    setup_timer_1(T1_ENABLE_SOSC | T1_EXTERNAL | T1_DIV_BY_1); 
04114:  MOVLW  8F
04116:  MOVWF  FCD
04118:  CLRF   FCC
....................    TMR1ON = FALSE; 
0411A:  BCF    FCD.0
....................    set_timer1(0); 
0411C:  CLRF   FCF
0411E:  CLRF   FCE
....................     
....................    /* TMR2 is used in all PWM generation and to produce 
....................     * an interrupt event every approx 16msec if desired 
....................     * TMR2 setup handled by oscillator setup macro above 
....................     * Initalized in off mode 
....................     */ 
....................    TMR2ON = FALSE; 
04120:  BCF    FBA.2
....................    set_timer2(0); 
04122:  CLRF   FBC
....................     
....................    /* TMR3 is used to count seconds 
....................     * It is timed by the external secondary (32.768kHz) xtal 
....................     * It is set to 8000 and overflows FFFF in 1 second. 
....................     * It is then reset to 8000 after counting 1 second after overflow 
....................     * Initalized in on mode 125ms before overflow (F000) 
....................     */ 
....................    setup_timer_3(T3_ENABLE_SOSC | T3_EXTERNAL | T3_DIV_BY_1);   
04124:  CLRF   FB4
04126:  MOVWF  FB1
....................    TMR3ON = FALSE; 
04128:  BCF    FB1.0
....................    set_timer3(0); 
0412A:  CLRF   FB3
0412C:  CLRF   FB2
....................       
....................    // TMR4 is not used 
....................    setup_timer_4(T4_DISABLED,0,1); 
0412E:  MOVLW  00
04130:  MOVWF  x51
04132:  MOVLW  00
04134:  MOVWF  x52
....................     
....................    /* TMR5 is dedicated to measurement of RPM 
....................     * It is timed by the external secondary (32.768kHz) xtal 
....................     * Initalized in off mode 
....................     */ 
....................    setup_timer_5(T5_ENABLE_SOSC|T5_EXTERNAL|T5_DIV_BY_1); 
04136:  CLRF   x4D
04138:  MOVLW  8F
0413A:  MOVWF  x4E
....................    TMR5ON = FALSE; 
0413C:  BCF    x4E.0
....................    set_timer5(0); 
0413E:  CLRF   x50
04140:  CLRF   x4F
....................     
....................    // TMR6 is not used 
....................    //setup_timer_6(T6_DISABLED,0,1); 
....................    TMR6ON = FALSE; 
04142:  BCF    x4A.2
....................    set_timer6(0); 
04144:  CLRF   x4C
....................     
....................    // sets up TMR2, TMR0, TMR6 CON   
....................    T0CON = T0_DIV_16;   
04146:  MOVLW  03
04148:  MOVWF  FD5
....................    T2CON = DIV1_POST6; 
0414A:  MOVLW  2C
0414C:  MOVWF  FBA
....................    T6CON = DIV1_POST6;                  
0414E:  MOVWF  x4A
....................    PR2 = 99; 
04150:  MOVLW  63
04152:  MOVWF  FBB
....................    PR6 = 99;   
04154:  MOVWF  x4B
....................     
....................    //********************Timers setup end********************     
....................     
....................    //********************CCP setup start********************     
....................     
....................    //setup_ccp1(CCP_USE_TIMER1_AND_TIMER2 | CCP_PWM_L_L | CCP_PULSE_STEERING_A); 
....................    // CCP1(pwm with TMR2) and P1A are specifically for braking control. 
....................    // Set as above when in use. 
....................    // When off, the BRK_CTRLn line can be set as an I/O for 
....................    //  either max brake (lo) of min (hi) brake. 
....................    // Note that duty cycle 0 for minimum braking,  
....................    //  duty cycle=400 for (almost) maximum braking. 
....................    setup_ccp1(CCP_OFF);          // CCP1 off for now 
04156:  MOVLW  F0
04158:  ANDWF  FBD,F
....................    // P1A (BRAKE_CTRLn) is initialized to brakes off (1) 
....................   
....................    //setup_ccp2(CCP_USE_TIMER1_AND_TIMER2 | CCP_PWM_H_H | CCP_PULSE_STEERING_A); 
....................    // CCP2(pwm with TMR2) and P2A are specifically for control of charging. 
....................    // Set above when in use. 
....................    // When off, the LTC3105_CTRL line can be set as an I/O for  
....................    //  either max charging (hi) or min (lo) charging. 
....................    // Note that duty cycle 0 for no charging, 
....................    //  duty cycle=400 for (almost) max charging. 
....................    setup_ccp2(CCP_OFF);          // CCP2 off for now 
0415A:  ANDWF  F66,F
....................    // P2A (LTC3105_CTRL) is initialized to max charging aggressiveness (1) 
....................     
....................    //setup_ccp3(CCP_USE_TIMER1_AND_TIMER2 | CCP_PWM_L_L | CCP_PULSE_STEERING_A); 
....................    //setup_ccp3(CCP_USE_TIMER1_AND_TIMER2 | CCP_PWM_L_L | CCP_PULSE_STEERING_B); 
....................    //setup_ccp3(CCP_USE_TIMER1_AND_TIMER2 | CCP_COMPARE_RESET_TIMER); 
....................    // CCP3(compare)/TMR1 is for valve timing;  
....................    // CCP3(pwm)/TMR2 if for valve motor speed control 
....................    //Steer output to P3A for closing, steer output to P3B for opening; 
....................    // both VLV_CTRL1 (P3A) and VLV_CTRL2 (P3B) hi for braking; 
....................    // both VLV_CTRL1 (P3A) and VLV_CTRL2 (P3B) lo for coasting; 
....................    // pulse P3A lo while P3B hi for closing, pulse P3B while P3A hi for opening 
....................    //Compare mode used to time valve motion after ramp is finished. 
....................    //  Set CCPf_3 to 0x8000 and start TMR1 for 1sec interrupts; or use other 
....................    //  values for different timings.  General purpose timing when valve not 
....................    //  being timed. 
....................    setup_ccp3(CCP_OFF);          // CCP3 off for now 
0415C:  ANDWF  x5D,F
....................  
....................    //setup_ccp4(CCP_USE_TIMER3_AND_TIMER4 | CCP_COMPARE_RESET_TIMER);  
....................    // CCP4/TMR3 serves only one purpose: the real-time-clock. 
....................    //  Set CCP_4 to 0x8000 and start TMR1 for 1sec interrupts 
....................     
....................    setup_ccp4(CCP_OFF);          // CCP4 off for now 
0415E:  ANDWF  x57,F
....................     
....................    //setup_ccp(CCP_USE_TIMER5_AND_TIMER6 | CCP_CAPTURE_RE); 
....................    // CCP5/TMR5 serves only one purpose: measurement of spin rate.  
....................    setup_ccp5(CCP_OFF); 
04160:  ANDWF  x54,F
....................  
....................    //********************CCP setup end********************    
....................     
....................    //********************INT setup start******************   
....................     
....................    /* Diables: 
....................     * Global int (all ints) 
....................     * All peripheral ints 
....................     * TMR0 overflow int 
....................     * INT0 ext int 
....................     * Port B IOC int 
....................     * Clears: 
....................     * TMROIF, INT0IF, RBIF 
....................     */ 
....................    INTCON = 0; 
04162:  CLRF   FF2
....................     
....................    // PORTB pullups are enabled 
....................    // INTEDG0,1,2 on falling edge 
....................    // TMR0 and RBIP priority  is low 
....................    INTCON2 = 0; 
04164:  CLRF   FF1
....................     
....................    // External INT1, INT2 disabled/cleared and set to low priority                               
....................    INTCON3 = 0; 
04166:  CLRF   FF0
....................     
....................    // Int priority enabled (part of RCON) 
....................    IPEN = TRUE; 
04168:  BSF    FD0.7
....................     
....................    // Clear all peripheral interrupts 
....................    PIR1 = 0;                            
0416A:  CLRF   F9E
....................    PIR2 = 0; 
0416C:  CLRF   FA1
....................    PIR3 = 0; 
0416E:  CLRF   FA4
....................    PIR4 = 0; 
04170:  CLRF   F7B
....................    PIR5 = 0; 
04172:  CLRF   F7E
....................     
....................    // disable all peripheral interrupts 
....................    PIE1 = 0;                           
04174:  CLRF   F9D
....................    PIE2 = 0; 
04176:  CLRF   FA0
....................    PIE3 = 0; 
04178:  CLRF   FA3
....................    PIE4 = 0; 
0417A:  CLRF   F7A
....................    PIE5 = 0; 
0417C:  CLRF   F7D
....................       
....................    //   IPR1 = 0; 
....................    //   IPR2 = 0; 
....................    //   IPR3 = 0; 
....................    //   IPR4 = 0; 
....................    //   IPR5 = 0; 
....................  
....................    // setup IOC to call INT_RB only on RB4 change 
....................    IOCB = 0b00010000;      
0417E:  MOVLW  10
04180:  MOVWF  F62
....................     
....................    //********************INT setup end********************  
....................                                 
....................    // initialize I2C 
....................    i2c_init(TRUE); 
04182:  BCF    FCB.0
04184:  BCF    FCB.1
04186:  BCF    FCB.3
04188:  MOVLW  06
0418A:  MOVWF  FC8
0418C:  MOVLW  28
0418E:  MOVWF  FC6
04190:  BSF    FC7.7
04192:  BCF    FC7.6
....................                           
....................    // initalizes XDCR, sets global xdcr_enabled 
....................    adc_XDCR_init();                                     
04194:  MOVLB  0
04196:  GOTO   38DE
....................          
....................    // initalize LCD, sets global lcd_enabled 
....................    LCD_init(); 
0419A:  RCALL  3A66
....................     
....................    // set mppc value to 0                  
....................    set_mppc(global_mppc_value); 
0419C:  MOVFF  BA,554
041A0:  RCALL  3EEC
....................     
....................    // set battery charge cycle to 100%   
....................    set_charge_duty(global_charge_duty); 
041A2:  MOVFF  B5,557
041A6:  MOVFF  B4,556
041AA:  RCALL  3F78
....................     
....................    // initalize fixture, sets global fixture_enabled 
....................    fixture_init(); 
041AC:  BRA    403A
....................     
....................    // Turn on LTC1541 and MCP4452  
....................    output_high(AUX_PWR); 
041AE:  BSF    F8C.3
....................     
....................    /* This iS for power supply settling etc.. 
....................     * pause for 125ms or longer; should not hang; 
....................     */ 
....................    delay_ms(125); 
041B0:  MOVLW  7D
041B2:  MOVLB  5
041B4:  MOVWF  x64
041B6:  MOVLB  0
041B8:  CALL   3946
041BC:  GOTO   A424 (RETURN)
....................     
....................  
....................      
.................... } 
....................  
.................... void vars_init(void) 
.................... { 
.................... // initalizes all global variables to default values from globals.h 
....................  
.................... ////////////////////Global Variables Table of Contents///////////////////////// 
.................... //Test Globals 
.................... //LCD Globals 
.................... //Time Globals 
.................... //Hardware Enabled Globals 
.................... //Control Related Globals 
.................... //Mote Globals 
.................... //Priority Queue 
.................... //Time Queue 
.................... //Sprinkler Stack 
.................... //Command Stack 
.................... //System State Globals 
....................  
.................... ////////////////////Test Globals/////////////////////////////////////////////// 
....................    test_global = 0; 
....................    test_global_2 = 0; 
....................    test_start_time = 0; 
....................    test_end_time = 0; 
....................    test_valve_open_1 = 0; 
....................    test_rpm_1 = 0; 
....................    test_duty_cycle_1 = 0; 
....................    test_valve_open_2 = 0; 
....................    test_rpm_2 = 0; 
....................    test_duty_cycle_2 = 0; 
....................    test_valve_open_3 = 0; 
....................    test_rpm_3 = 0; 
....................    test_duty_cycle_3 = 0; 
....................   
.................... ////////////////////LCD Globals//////////////////////////////////////////////// 
....................    memset(global_temp_line_buff, 0, sizeof global_temp_line_buff); 
....................    global_extra_lcd_ptr = NULL; 
....................  
.................... ////////////////////Time Globals/////////////////////////////////////////////// 
....................    // keeps track of time since microprocessor has been awake in seconds 
....................    global_rtc_time = 0; 
....................    // keeps track of the time within the mote system (taken from mote) 
....................    global_utc_time = 0; 
....................  
.................... ////////////////////Hardware Enabled Globals/////////////////////////////////// 
....................    global_lcd_enabled = 0; 
....................    global_xcdr_type1_enabled = 0; 
....................    global_xcdr_type2_enabled = 0; 
....................    global_fixture_enabled = 0; 
....................    global_dust_enabled = 0; 
....................  
.................... ////////////////////Control Related Globals//////////////////////////////////// 
....................    // keeps track of rpms (updated via interrupt routine) 
....................    global_current_period = 0; 
....................    global_rpm_set_value = 100; 
....................    // keeps track of duty cycles of brake and charge 
....................    global_brake_duty = 0; 
....................    global_charge_duty = MAX_CHARGE; 
....................    // keeps track of mppc level 
....................    global_mppc_value = 100; 
....................    // keeps track of vgen 
....................    global_vgen = 0; 
....................    // keeps track of fixture dac value 
....................    global_fixture_dac_value = NO_FIXTURE; 
....................  
.................... ////////////////////Valve Related Globals////////////////////////////////////// 
.................... // keeps track of current valve position 
....................    global_valve_position = VLV_POSITION_UNKNOWN; 
....................  
.................... ////////////////////Mote Globals/////////////////////////////////////////////// 
....................    //event flags defined by mote 
....................    event_flags = 0; 
....................  
....................    // Note that bytes_from_mote union contains the stripped unstuffed data 
....................    //  eg, bytes_from_mote.dust_rcvd[128] 
....................     
....................    memset (&bytes_from_mote, 0, sizeof bytes_from_mote); 
....................    p = NULL; 
....................  
....................    // It just can't get bigger than this! 
....................    // pkgen places message to be sent here 
....................    memset(dust_send_buffer, 0, sizeof(dust_send_buffer)); 
....................  
....................    // this is only for doing acks and only needs to be  
....................    // MAX_USER_DATA_SIZE*2 + 2 + 4 + 12 + 2 
....................    // MAX_USER_DATA_SIZE is 2 bytes for ack 
....................    memset(dust_send_buffer_isr, 0, sizeof dust_send_buffer_isr); 
....................  
....................    // THIS is the buffer for RAW rcvd mote 
....................    //  mote packet data 
....................    memset(dust_recive_buffer, 0, sizeof dust_recive_buffer); 
....................  
....................    //  this is place 
....................    //  where the packet to be sent by micro 
....................    //  to NETWORK manager is placed prior 
....................    //  to dust_send_data call 
....................    memset(payload_buff, 0, sizeof payload_buff); 
....................  
....................    // Keeps track of how many bytes to send and passed between pkgen and pksend 
....................    num_of_bytes_to_send = 0; 
....................    num_of_bytes_to_send_isr = 0; 
....................  
....................    // This is specific to the subroutine 
....................    //  pkgen_send() which creates the message 
....................    //  to be sent from the mote to the net                      
....................    send_prefix[0] = CMD_SEND; 
....................    send_prefix[1] = 0; 
....................    send_prefix[2] = FLAG_SEND_REQUEST; 
....................    send_prefix[3] = DESTADDR_HI; 
....................    send_prefix[4] = DESTADDR_LO; 
....................    send_prefix[6] = APPDOMAIN_MAINTENANCE; 
....................    send_prefix[7] = PRIORITY_HI; 
....................    send_prefix[8] = 0; 
....................    send_prefix[9] = 0; 
....................    send_prefix[10] = 0xFF; 
....................    send_prefix[11] = 0; 
....................     
....................    // send_prefix[11] will be set to number of bytes in packet    
....................       // The send_prefix structure is as follows: 
....................       // [0]      CMD_SEND 
....................       // [1]      length of request       - this is payload length + 9 
....................       // [2]      FLAG_SEND_REQUEST 
....................       // [3]/[4]  destination address     - always DESTADDR_HI, DESTADDR_LO 
....................       // [5]      svc_index               - get this from service indication received 
....................       //                                     at join time 
....................       // [6]      APPDOMAIN_MAINTENANCE 
....................       // [7]      PRIORITY_HIGH 
....................       // [8][9]   reserved                - 0x00, 0x00  
....................       // [10]     sequence_num            - always 0xFF for mote-originated packets 
....................       // [11]     payload length          - length of the payload in bytes 
....................  
....................  
....................    // For ensuring a message was recieved properly from mote 
....................    result_rcvd = 0; 
....................  
....................    // Flag for going through deal with mote ISR and going to sleep afterwards 
....................    fl_mote_dealt = 0; 
....................    fl_alt_LCD = 0; 
....................  
....................    // Flag for a sucessful get/set response eliminating a few other flags 
....................    global_set_get_response = 0; 
....................  
....................    // FLAGS TO GET RID OF! 
....................    // Flag for receiving an advertisment 
....................    advert_rcvd_fl = 0; 
....................    setnetid_done_fl = 0; 
....................    ack_sent_fl = 0; 
....................    pkt_rcvd_fl = 0; 
....................    joinduty_done_fl = 0; 
....................    gettime_done_fl = 0; 
....................    fl_batNOEE = 0; 
....................    joinkey_done_fl = 0; 
....................    joincmd_done_fl = 0; 
....................  
....................    flags_rcvd = 0, param_type_rcvd = 0, svc_index_rcvd=0; 
....................    mote_msgSEQ = 0; 
....................  
....................    //Globals for when advertisements are received 
....................    network_id_rcvd = 0; 
....................    mote_id_rcvd = 0; 
....................    rssi_rcvd = 0; 
....................    hop_depth_rcvd = 0; 
....................  
....................    // More globals that we might actually want to keep 
....................    memset(serial_number_rcvd, 0, sizeof serial_number_rcvd); 
....................    memset(macaddr_rcvd, 0, sizeof macaddr_rcvd); 
....................  
.................... ////////////////////Priority Queue///////////////////////////////////////////// 
....................    // Actual priority queue 
....................    memset(global_priority_queue, 0, sizeof global_priority_queue); 
....................    global_current_priority_queue_location = (0-1); 
....................  
.................... ////////////////////Time Queue///////////////////////////////////////////////// 
....................    // Actual time queue 
....................    memset(global_time_queue, 0, sizeof global_time_queue); 
....................    global_current_time_queue_location = (0-1); 
....................  
.................... ////////////////////Sprinkler Queue//////////////////////////////////////////// 
....................    // Actual sprinkler queue 
....................    memset(global_sprinkler_queue, 0, sizeof global_sprinkler_queue); 
....................  
.................... ////////////////////Command Queue////////////////////////////////////////////// 
....................    // Actual command queue 
....................    memset(global_command_queue, 0, sizeof global_command_queue); 
....................  
.................... ////////////////////System State Variables///////////////////////////////////// 
....................    global_mote_state = MOTESTATE_UNKNOWN; 
....................    global_system_state = SYSTEM_INIT; 
.................... } 
....................  
.................... void deep_sleep(void) 
.................... {  // zzzzzzz....... 
....................  
.................... // Ways out of deep sleep: MCLR button, V_GEN_INT (int1) 
.................... // SW1 DOES not wake it up... 
....................  
....................    disable_interrupts(GLOBAL); 
*
09740:  BCF    FF2.6
09742:  BCF    FF2.7
09744:  BTFSC  FF2.7
09746:  BRA    9742
....................    strcpy (global_temp_line_buff, "Enter Deep Sleep"); 
09748:  CLRF   FEA
0974A:  MOVLW  70
0974C:  MOVWF  FE9
0974E:  MOVLW  00
09750:  CALL   03BA
09754:  TBLRD*-
09756:  TBLRD*+
09758:  MOVF   FF5,W
0975A:  MOVWF  FEE
0975C:  IORLW  00
0975E:  BNZ   9756
....................    LCD_line1(global_temp_line_buff); 
09760:  MOVLB  5
09762:  CLRF   x64
09764:  MOVLW  70
09766:  MOVWF  x63
09768:  MOVLB  0
0976A:  CALL   39B0
....................    strcpy (global_temp_line_buff, "Reason:         "); 
0976E:  CLRF   FEA
09770:  MOVLW  70
09772:  MOVWF  FE9
09774:  MOVLW  00
09776:  CALL   03DC
0977A:  TBLRD*-
0977C:  TBLRD*+
0977E:  MOVF   FF5,W
09780:  MOVWF  FEE
09782:  IORLW  00
09784:  BNZ   977C
....................    global_temp_line_buff[8] = hi2asc(global_shutdown_cause); 
09786:  MOVFF  4D,564
0978A:  CALL   32F4
0978E:  MOVFF  01,78
....................    global_temp_line_buff[9] = lo2asc(global_shutdown_cause); 
09792:  MOVFF  4D,564
09796:  CALL   3314
0979A:  MOVFF  01,79
....................    LCD_line2(global_temp_line_buff);      
0979E:  MOVLB  5
097A0:  CLRF   x64
097A2:  MOVLW  70
097A4:  MOVWF  x63
097A6:  MOVLB  0
097A8:  CALL   3A0A
....................     
....................    setup_T0_int(T0_6S); 
097AC:  MOVLW  A4
097AE:  MOVLB  5
097B0:  MOVWF  x69
097B2:  MOVLW  73
097B4:  MOVWF  x68
097B6:  MOVLB  0
097B8:  CALL   38C2
....................    while (!TMR0IF); 
097BC:  BTFSS  FF2.2
097BE:  BRA    97BC
....................     
....................    LCD_shutdown(); 
097C0:  BRA    96C8
....................    output_a(PORTA_DEEP); 
097C2:  MOVLW  74
097C4:  MOVWF  F89
....................    output_b(PORTB_DEEP); 
097C6:  MOVLW  10
097C8:  MOVWF  F8A
....................    output_c(PORTC_DEEP); 
097CA:  MOVLW  45
097CC:  MOVWF  F8B
....................    output_d(PORTD_DEEP); 
097CE:  MOVLW  76
097D0:  MOVWF  F8C
....................    output_e(PORTE_DEEP); 
097D2:  CLRF   F8D
....................    set_tris_a(TRISA_NORM); 
097D4:  MOVLW  8B
097D6:  MOVWF  F92
....................    set_tris_b(TRISB_NORM); 
097D8:  MOVLW  F7
097DA:  MOVWF  F93
....................    set_tris_c(TRISC_NORM); 
097DC:  MOVLW  9A
097DE:  MOVWF  F94
....................    set_tris_d(TRISD_NORM); 
097E0:  MOVLW  80
097E2:  MOVWF  F95
....................    set_tris_e(TRISE_NORM); 
097E4:  BCF    F96.0
097E6:  BCF    F96.1
097E8:  BSF    F96.2
097EA:  BSF    F96.3
....................  
....................    setup_vref(VREF_OFF); 
097EC:  MOVLB  F
097EE:  CLRF   x42
....................    setup_dac(DAC_OFF); 
097F0:  CLRF   x41
....................    setup_adc(ADC_OFF); 
097F2:  BCF    FC2.0
....................    setup_CCP1(CCP_OFF); 
097F4:  MOVLW  F0
097F6:  ANDWF  FBD,F
....................    setup_CCP2(CCP_OFF); 
097F8:  ANDWF  F66,F
....................    setup_CCP3(CCP_OFF);    
097FA:  ANDWF  x5D,F
....................    setup_CCP4(CCP_OFF); 
097FC:  ANDWF  x57,F
....................    setup_CCP5(CCP_OFF); 
097FE:  ANDWF  x54,F
....................    setup_comparator(NC_NC_NC_NC); 
09800:  CLRF   F77
09802:  MOVLW  04
09804:  MOVWF  F78
09806:  MOVWF  F79
....................     
....................    clear_interrupt(INT_TIMER0); 
09808:  BCF    FF2.2
....................    setup_timer_1(T1_DISABLED); 
0980A:  CLRF   FCD
0980C:  CLRF   FCC
....................    setup_timer_2(T2_DISABLED,0,1); 
0980E:  MOVLW  00
09810:  MOVWF  FBA
09812:  MOVLW  00
09814:  MOVWF  FBB
....................    setup_timer_3(T3_DISABLED); 
09816:  CLRF   FB4
09818:  CLRF   FB1
....................    setup_timer_4(T4_DISABLED,0,1); 
0981A:  MOVWF  x51
0981C:  MOVLW  00
0981E:  MOVWF  x52
....................    setup_timer_5(T5_DISABLED); 
09820:  CLRF   x4D
09822:  CLRF   x4E
....................    setup_timer_6(T6_DISABLED,0,1); 
09824:  MOVWF  x4A
09826:  MOVLW  00
09828:  MOVWF  x4B
....................     
....................    setup_wdt(WDT_OFF);    
0982A:  BCF    FD1.0
....................  
....................    setup_uart(FALSE); 
0982C:  BCF    FAB.7
0982E:  BCF    FAB.4
09830:  BCF    FAC.5
....................  
....................    INTCON = 0;                         // TMR0, INT0. IOC ints disabled/cleared 
09832:  CLRF   FF2
....................                                        //  High and Low Priority ints disabled 
....................    INTCON2 = 0;                        // RB port change int is low priority 
09834:  CLRF   FF1
....................                                        //  PORTB pullups are enabled 
....................    INTCON3 = 0;                        // INT1, INT2 ints disabled/cleared 
09836:  CLRF   FF0
....................    IPEN = TRUE;                        // Int priority enabled (part of RCON) 
09838:  BSF    FD0.7
....................     
....................    PIR1 = 0;                           // clear various interrupt flags 
0983A:  CLRF   F9E
....................    PIR2 = 0; 
0983C:  CLRF   FA1
....................    PIR3 = 0; 
0983E:  CLRF   FA4
....................    PIR4 = 0; 
09840:  CLRF   F7B
....................    PIR5 = 0; 
09842:  CLRF   F7E
....................     
....................    PIE1 = 0;                           // disable various interuupts 
09844:  CLRF   F9D
....................    PIE2 = 0; 
09846:  CLRF   FA0
....................    PIE3 = 0; 
09848:  CLRF   FA3
....................    PIE4 = 0; 
0984A:  CLRF   F7A
....................    PIE5 = 0; 
0984C:  CLRF   F7D
....................       
....................    IPR1 = 0; 
0984E:  CLRF   F9F
....................    IPR2 = 0; 
09850:  CLRF   FA2
....................    IPR3 = 0; 
09852:  CLRF   FA5
....................    IPR4 = 0; 
09854:  CLRF   F7C
....................    IPR5 = 0;   
09856:  CLRF   F7F
....................     
....................    IOCB = 0;                     // disable all PORTB interrupt on change 
09858:  CLRF   F62
....................                                  //  functionality 
....................    setup_adc_ports(NO_ANALOGS);                               
0985A:  MOVF   FC1,W
0985C:  ANDLW  F0
0985E:  MOVWF  FC1
09860:  MOVLW  00
09862:  MOVWF  x38
09864:  MOVWF  x3C
09866:  MOVWF  x39
09868:  MOVWF  x3A
0986A:  MOVWF  x3B
....................    clear_interrupt(INT_EXT); 
0986C:  BCF    FF2.1
....................    //clear_interrupt(INT_EXT2); 
....................    enable_interrupts(INT_EXT_L2H);  
0986E:  BSF    FF2.4
09870:  BSF    FF1.6
....................    //enable_interrupts(INT_EXT2_H2L);  
....................    enable_interrupts(GLOBAL); 
09872:  MOVLW  C0
09874:  IORWF  FF2,F
....................    delay_ms(1000);  
09876:  MOVLW  04
09878:  MOVLB  5
0987A:  MOVWF  x63
0987C:  MOVLW  FA
0987E:  MOVWF  x64
09880:  MOVLB  0
09882:  CALL   3946
09886:  MOVLB  5
09888:  DECFSZ x63,F
0988A:  BRA    987C
....................       
....................    sleep(SLEEP_FULL); 
0988C:  MOVFF  FD3,00
09890:  BCF    FD3.7
09892:  SLEEP 
09894:  MOVFF  00,FD3
....................  
....................    //reset_cpu(); 
....................    // wake up because of generator spin or SW1/Hall effect 
....................    if (input(V_GEN_INT)) 
09898:  BTFSS  F81.0
0989A:  BRA    989E
....................    { 
....................    //   reset_cause = SPIN_RESTART; 
....................    // otherwise it was the SW1/Hall effect that woke it up 
....................       reset_cpu(); 
0989C:  RESET
....................    } 
0989E:  MOVLB  0
098A0:  RETURN 0
....................    // deep sleep is exited by a MCLR, or V_GEN_INT (SPIN RESTART) 
....................    // If for some reason it woke up, but not because of a SPIN_RESTART 
....................    //  then simply go back to deep_sleep 
....................     
....................     
.................... }  
....................  
....................  
.................... void start_rtc(void) 
.................... { 
....................    global_rtc_time = 0; 
*
04260:  CLRF   x88
04262:  CLRF   x87
04264:  CLRF   x86
04266:  CLRF   x85
....................    CCP_4 = 0x8000; 
04268:  MOVLW  80
0426A:  MOVLB  F
0426C:  MOVWF  x59
0426E:  CLRF   x58
....................    setup_ccp4(CCP_USE_TIMER3_AND_TIMER4 | CCP_COMPARE_RESET_TIMER); 
04270:  MOVLW  0B
04272:  MOVWF  x57
04274:  MOVLW  FC
04276:  ANDWF  x48,F
04278:  MOVLW  01
0427A:  IORWF  x48,F
....................    CCP4IF = FALSE; 
0427C:  BCF    F7B.1
....................    setup_timer_3(T3_ENABLE_SOSC | T3_EXTERNAL_SYNC | T3_DIV_BY_1); 
0427E:  CLRF   FB4
04280:  MOVLW  8B
04282:  MOVWF  FB1
....................    set_timer3(0);    
04284:  CLRF   FB3
04286:  CLRF   FB2
....................    clear_interrupt(INT_CCP4); 
04288:  BCF    F7B.1
....................    enable_interrupts(INT_CCP4); 
0428A:  BSF    F7A.1
0428C:  MOVLB  0
0428E:  GOTO   A434 (RETURN)
.................... } 
....................  
.................... void safeI2C_start(void) 
.................... { 
....................    setup_T0_int(T0_10MS); 
*
03E9A:  MOVLB  5
03E9C:  SETF   x69
03E9E:  MOVLW  D9
03EA0:  MOVWF  x68
03EA2:  MOVLB  0
03EA4:  RCALL  38C2
....................    while (I2CBUSY && !TMR0IF); 
03EA6:  BTFSS  FC7.0
03EA8:  BRA    3EAE
03EAA:  BTFSS  FF2.2
03EAC:  BRA    3EA6
....................    if (!I2CBUSY) 
03EAE:  BTFSC  FC7.0
03EB0:  BRA    3EBA
....................       i2c_start(); 
03EB2:  BSF    FC5.0
03EB4:  BTFSC  FC5.0
03EB6:  BRA    3EB4
03EB8:  BRA    3ED6
....................    else 
....................    { 
....................       BCL1IF = FALSE; 
03EBA:  BCF    FA1.3
....................       WCOL = FALSE; 
03EBC:  BCF    FC6.7
....................       i2c_init(TRUE); 
03EBE:  BCF    FCB.0
03EC0:  BCF    FCB.1
03EC2:  BCF    FCB.3
03EC4:  MOVLW  06
03EC6:  MOVWF  FC8
03EC8:  MOVLW  28
03ECA:  MOVWF  FC6
03ECC:  BSF    FC7.7
03ECE:  BCF    FC7.6
....................       i2c_start(); 
03ED0:  BSF    FC5.1
03ED2:  BTFSC  FC5.1
03ED4:  BRA    3ED2
....................    } 
03ED6:  RETURN 0
....................        
.................... } 
....................  
.................... void safeI2C_write(uint8_t value) 
.................... { 
....................    // thinking that a spike on the data or clock line is f'ing up 
....................    // i2c transmission, this routine simply looks for the ACK and if 
....................    // it does not see it, tries ONE MORE TIME and one more time only! 
....................    int1  unsuccess_fl; 
....................     
....................    unsuccess_fl = i2c_write(value); 
03ED8:  MOVFF  555,57C
03EDC:  RCALL  3962
03EDE:  MOVF   01,W
03EE0:  MOVLB  5
03EE2:  BCF    x56.0
03EE4:  BTFSC  01.0
03EE6:  BSF    x56.0
03EE8:  MOVLB  0
03EEA:  RETURN 0
.................... //   if (unsuccess_fl) 
.................... //      i2c_write(value); 
.................... }     
....................  
.................... void setup_rb4_int(void) 
.................... { 
....................    // sets up the RB4 interrupt 
....................    RBIF = FALSE; 
*
0480E:  BCF    FF2.0
....................    enable_interrupts(INT_RB4);       
04810:  BSF    FF2.3
04812:  BSF    F62.4
04814:  GOTO   A4C4 (RETURN)
.................... }      
....................       
.................... void write_system_state(uint8_t system_state_to_change_to)  
.................... {                
....................    // Modifies the global_system_state varible outside of the ISRs 
....................    // Also deals with the transition from SYSTEM_IDLE to SYSTEM_RUN and back 
....................                                                                     
....................    // If going from SYSTEM_IDLE to SYSTEM_RUN    
....................    if ((global_system_state == SYSTEM_IDLE) && (system_state_to_change_to == SYSTEM_RUN))  
*
03286:  MOVLB  5
03288:  MOVF   x05,W
0328A:  SUBLW  03
0328C:  BNZ   3296
0328E:  MOVF   x4B,W
03290:  SUBLW  02
03292:  BNZ   3296
....................    {                            
....................       // change processor speed?  
....................       //fosc_250k();  
....................    }  
03294:  BRA    32B0
....................    // If going from SYSTEM_RUN to SYSTEM_IDLE    
....................    else if ((global_system_state == SYSTEM_RUN) && (system_state_to_change_to == SYSTEM_IDLE))                
03296:  MOVF   x05,W
03298:  SUBLW  02
0329A:  BNZ   32A4
0329C:  MOVF   x4B,W
0329E:  SUBLW  03
032A0:  BNZ   32A4
....................    { 
....................       // change processor speed? 
....................       //fosc_31250();             
....................    }  
032A2:  BRA    32B0
....................    // If going from SYSTEM_IDLE to anything else    
....................    else if ((global_system_state == SYSTEM_IDLE) && (system_state_to_change_to != SYSTEM_IDLE)) 
032A4:  MOVF   x05,W
032A6:  SUBLW  03
032A8:  BNZ   32B0
032AA:  MOVF   x4B,W
032AC:  SUBLW  03
032AE:  BZ    32B0
....................    {      
....................       // change processor speed?  
....................       //fosc_250k();      
....................    }                          
....................    // actually change the state 
....................    global_system_state = system_state_to_change_to; 
032B0:  MOVFF  54B,505
032B4:  MOVLB  0
032B6:  RETURN 0
.................... }       
....................  
.................... uint8_t read_system_state(void)        
.................... { 
....................    // safely read the system state outside of ISRs 
....................    return global_system_state; 
*
01F4A:  MOVLB  5
01F4C:  MOVFF  505,01
01F50:  MOVLB  0
01F52:  RETURN 0
.................... } 
....................    
....................  
.................... #include "dust.h"                                        
.................... void mote_init(void) 
.................... { 
....................    // sets the mote message sequence to a random number 
....................    init_msgSEQ(); 
*
04494:  BRA    444A
....................    // enable appropriate interrupts for mote response 
....................    clear_interrupt(INT_EXT2_H2L); 
04496:  BCF    FF0.1
....................    enable_interrupts(INT_EXT2_H2L); 
04498:  BSF    FF0.4
0449A:  BCF    FF1.4
0449C:  GOTO   A43C (RETURN)
.................... }    
....................     
.................... void mote_reset(void) 
.................... { 
....................    // Resets the mote, enables interrupts for the mote to respond, and 
....................    // schedules a WAIT_FOR_BOOT_EVENT to see if the mote responded 
....................   
....................    // Force an reset 
....................    output_low(MOTE_RESETn); 
*
046EE:  BCF    F8C.4
....................    // definitely long enough at any clock speed 
....................    setup_T0_int(T0_250MS); 
046F0:  MOVLW  FC
046F2:  MOVLB  5
046F4:  MOVWF  x69
046F6:  MOVLW  30
046F8:  MOVWF  x68
046FA:  MOVLB  0
046FC:  CALL   38C2
....................    while (!TMR0IF);    
04700:  BTFSS  FF2.2
04702:  BRA    4700
....................    output_high(MOTE_RESETn); 
04704:  BSF    F8C.4
....................       
....................    // add boot event checkup 
....................    PUSH_TIME_QUEUE_MACRO((global_rtc_time + 6), WAIT_FOR_BOOT_EVENT) 
04706:  BCF    F7A.1
04708:  MOVLW  06
0470A:  ADDWF  x85,W
0470C:  MOVLB  5
0470E:  MOVWF  x4B
04710:  MOVLW  00
04712:  MOVLB  0
04714:  ADDWFC x86,W
04716:  MOVLB  5
04718:  MOVWF  x4C
0471A:  MOVLW  00
0471C:  MOVLB  0
0471E:  ADDWFC x87,W
04720:  MOVLB  5
04722:  MOVWF  x4D
04724:  MOVLW  00
04726:  MOVLB  0
04728:  ADDWFC x88,W
0472A:  MOVLB  5
0472C:  MOVWF  x4E
0472E:  MOVWF  x59
04730:  MOVFF  54D,558
04734:  MOVFF  54C,557
04738:  MOVFF  54B,556
0473C:  MOVLW  10
0473E:  MOVWF  x5A
04740:  MOVLB  0
04742:  RCALL  44A0
04744:  BSF    F7A.1
04746:  RETURN 0
.................... } 
....................  
.................... uint8_t mote_sleep(void) 
.................... { 
....................    uint8_t  result_byte; 
....................  
....................    // set the join duty and timeout error handling 
....................    global_set_get_response = FALSE; 
*
0A09E:  MOVLB  3
0A0A0:  BCF    x60.2
....................    pkgen_sleep(); 
0A0A2:  MOVLW  09
0A0A4:  MOVLB  5
0A0A6:  MOVWF  x4C
0A0A8:  CLRF   x4D
0A0AA:  MOVLW  04
0A0AC:  MOVWF  x4E
0A0AE:  CLRF   x66
0A0B0:  CLRF   x65
0A0B2:  CLRF   x67
0A0B4:  MOVLW  05
0A0B6:  MOVWF  x69
0A0B8:  MOVLW  4C
0A0BA:  MOVWF  x68
0A0BC:  MOVLW  03
0A0BE:  MOVWF  x6A
0A0C0:  MOVLB  0
0A0C2:  CALL   606C
....................    result_byte = dust_hdlc_pksend(); 
0A0C6:  CALL   6316
0A0CA:  MOVFF  01,54B
....................    setup_T0_int(T0_250MS); 
0A0CE:  MOVLW  FC
0A0D0:  MOVLB  5
0A0D2:  MOVWF  x69
0A0D4:  MOVLW  30
0A0D6:  MOVWF  x68
0A0D8:  MOVLB  0
0A0DA:  CALL   38C2
....................    while (!TMR0IF && !result_byte); 
0A0DE:  BTFSC  FF2.2
0A0E0:  BRA    A0F0
0A0E2:  MOVLB  5
0A0E4:  MOVF   x4B,F
0A0E6:  BTFSS  FD8.2
0A0E8:  BRA    A0EE
0A0EA:  MOVLB  0
0A0EC:  BRA    A0DE
0A0EE:  MOVLB  0
....................    if (TMR0IF || result_byte) 
0A0F0:  BTFSC  FF2.2
0A0F2:  BRA    A0FC
0A0F4:  MOVLB  5
0A0F6:  MOVF   x4B,F
0A0F8:  BZ    A100
0A0FA:  MOVLB  0
....................    { 
....................       //return ERR_MOTE_UNRESPONSIVE; 
....................    } 
0A0FC:  BRA    A108
0A0FE:  MOVLB  5
....................    else 
....................    { 
....................       return NO_ERR; 
0A100:  MOVLW  00
0A102:  MOVWF  01
0A104:  BRA    A10E
0A106:  MOVLB  0
....................    } 
....................    return NO_ERR; 
0A108:  MOVLW  00
0A10A:  MOVWF  01
0A10C:  MOVLB  5
0A10E:  MOVLB  0
0A110:  GOTO   B13E (RETURN)
.................... } 
.................... void     search_for_strongest(void) 
*
099AE:  MOVLW  80
099B0:  MOVLB  5
099B2:  MOVWF  x4C
099B4:  CLRF   x4E
099B6:  CLRF   x4D
099B8:  CLRF   x50
099BA:  CLRF   x4F
.................... { 
....................    uint8_t     result_byte; 
....................    int8_t      rssi_best = -128; 
....................    int16_t     net_id_best = 0, net_id_current = 0;; 
....................    uint32_t    search_start_time = 0; 
....................    int1        net_id_selected = 0; 
099BC:  CLRF   x54
099BE:  CLRF   x53
099C0:  CLRF   x52
099C2:  CLRF   x51
099C4:  BCF    x55.0
....................     
....................    strcpy (global_temp_line_buff, " Searching ???? "); 
099C6:  CLRF   FEA
099C8:  MOVLW  70
099CA:  MOVWF  FE9
099CC:  MOVLW  00
099CE:  MOVLB  0
099D0:  CALL   03FE
099D4:  TBLRD*-
099D6:  TBLRD*+
099D8:  MOVF   FF5,W
099DA:  MOVWF  FEE
099DC:  IORLW  00
099DE:  BNZ   99D6
....................    LCD_line1(global_temp_line_buff); 
099E0:  MOVLB  5
099E2:  CLRF   x64
099E4:  MOVLW  70
099E6:  MOVWF  x63
099E8:  MOVLB  0
099EA:  CALL   39B0
....................    strcpy (global_temp_line_buff, "nnnn iii sss ddd"); 
099EE:  CLRF   FEA
099F0:  MOVLW  70
099F2:  MOVWF  FE9
099F4:  MOVLW  00
099F6:  CALL   0420
099FA:  TBLRD*-
099FC:  TBLRD*+
099FE:  MOVF   FF5,W
09A00:  MOVWF  FEE
09A02:  IORLW  00
09A04:  BNZ   99FC
....................    LCD_line2(global_temp_line_buff); 
09A06:  MOVLB  5
09A08:  CLRF   x64
09A0A:  MOVLW  70
09A0C:  MOVWF  x63
09A0E:  MOVLB  0
09A10:  CALL   3A0A
....................    
....................    //prepare mote message for searching 
....................    pkgen_search(); 
09A14:  MOVLW  11
09A16:  MOVLB  5
09A18:  MOVWF  x56
09A1A:  CLRF   x57
09A1C:  MOVLW  04
09A1E:  MOVWF  x58
09A20:  CLRF   x66
09A22:  CLRF   x65
09A24:  CLRF   x67
09A26:  MOVLW  05
09A28:  MOVWF  x69
09A2A:  MOVLW  56
09A2C:  MOVWF  x68
09A2E:  MOVLW  03
09A30:  MOVWF  x6A
09A32:  MOVLB  0
09A34:  CALL   606C
....................    result_byte = dust_hdlc_pksend();          
09A38:  CALL   6316
09A3C:  MOVFF  01,54B
....................     
....................    // hangs until search begins or request times out; 
....................    setup_T0_int(T0_250MS); 
09A40:  MOVLW  FC
09A42:  MOVLB  5
09A44:  MOVWF  x69
09A46:  MOVLW  30
09A48:  MOVWF  x68
09A4A:  MOVLB  0
09A4C:  CALL   38C2
....................    while (!TMR0IF && (global_mote_state != MOTESTATE_SEARCHING) && !result_byte); 
09A50:  BTFSC  FF2.2
09A52:  BRA    9A6E
09A54:  MOVLB  5
09A56:  MOVF   x04,W
09A58:  SUBLW  02
09A5A:  BTFSS  FD8.2
09A5C:  BRA    9A62
09A5E:  MOVLB  0
09A60:  BRA    9A6E
09A62:  MOVF   x4B,F
09A64:  BTFSS  FD8.2
09A66:  BRA    9A6C
09A68:  MOVLB  0
09A6A:  BRA    9A50
09A6C:  MOVLB  0
....................     
....................    //  immediately goes to sleep if ERR_MTNOTREADY 
....................    if (TMR0IF || global_mote_state != MOTESTATE_SEARCHING) 
09A6E:  BTFSC  FF2.2
09A70:  BRA    9A7C
09A72:  MOVLB  5
09A74:  MOVF   x04,W
09A76:  SUBLW  02
09A78:  BZ    9A84
09A7A:  MOVLB  0
....................    { 
....................       global_shutdown_cause = ERR_NO_ADV_WHILE_SEARCHING; 
09A7C:  MOVLW  02
09A7E:  MOVWF  4D
....................       deep_sleep();       
09A80:  RCALL  9740
09A82:  MOVLB  5
....................    } 
....................     
....................     
....................    // Search algorithm continues for MOTE_SEARCH_TIME or until net_id is selected 
....................    search_start_time = global_rtc_time; 
09A84:  MOVFF  88,554
09A88:  MOVFF  87,553
09A8C:  MOVFF  86,552
09A90:  MOVFF  85,551
....................    while((global_rtc_time < (search_start_time + MOTE_SEARCH_TIME)) && !net_id_selected) 
09A94:  MOVF   x23,W
09A96:  ADDWF  x51,W
09A98:  MOVWF  00
09A9A:  MOVF   x24,W
09A9C:  ADDWFC x52,W
09A9E:  MOVWF  01
09AA0:  MOVLW  00
09AA2:  ADDWFC x53,W
09AA4:  MOVWF  02
09AA6:  MOVLW  00
09AA8:  ADDWFC x54,W
09AAA:  MOVWF  03
09AAC:  MOVLB  0
09AAE:  MOVF   x88,W
09AB0:  SUBWF  03,W
09AB2:  BTFSS  FD8.0
09AB4:  BRA    9C66
09AB6:  BNZ   9AD4
09AB8:  MOVF   x87,W
09ABA:  SUBWF  02,W
09ABC:  BTFSS  FD8.0
09ABE:  BRA    9C66
09AC0:  BNZ   9AD4
09AC2:  MOVF   x86,W
09AC4:  SUBWF  01,W
09AC6:  BTFSS  FD8.0
09AC8:  BRA    9C66
09ACA:  BNZ   9AD4
09ACC:  MOVF   00,W
09ACE:  SUBWF  x85,W
09AD0:  BTFSC  FD8.0
09AD2:  BRA    9C66
09AD4:  MOVLB  5
09AD6:  BTFSS  x55.0
09AD8:  BRA    9ADE
09ADA:  MOVLB  0
09ADC:  BRA    9C66
....................    { 
....................       // use SW1 to exit early, give user a chance to select strongest netid 
....................       setup_T0_int(T0_2S); 
09ADE:  MOVLW  E1
09AE0:  MOVWF  x69
09AE2:  MOVLW  7C
09AE4:  MOVWF  x68
09AE6:  MOVLB  0
09AE8:  CALL   38C2
....................       while (!TMR0IF) 
09AEC:  BTFSC  FF2.2
09AEE:  BRA    9B16
....................       { 
....................          if (!input(SW1n))                
09AF0:  BTFSC  F81.4
09AF2:  BRA    9B14
....................          { 
....................             //wait for 250MS for debounce                    
....................             setup_T0_int(T0_250MS); 
09AF4:  MOVLW  FC
09AF6:  MOVLB  5
09AF8:  MOVWF  x69
09AFA:  MOVLW  30
09AFC:  MOVWF  x68
09AFE:  MOVLB  0
09B00:  CALL   38C2
....................             while (!TMR0IF);                                                  
09B04:  BTFSS  FF2.2
09B06:  BRA    9B04
....................             //check button after 250ms to see if it's still depressed, if so, exit 
....................             if (!input(SW1n)) 
09B08:  BTFSC  F81.4
09B0A:  BRA    9B14
....................             { 
....................                net_id_selected = TRUE; 
09B0C:  MOVLB  5
09B0E:  BSF    x55.0
....................                break; 
09B10:  MOVLB  0
09B12:  BRA    9B16
....................             }                                                                
....................          } 
09B14:  BRA    9AEC
....................       } 
....................        
....................       // if a new advertisement flag is triggered                      
....................       if (advert_rcvd_fl) 
09B16:  MOVLB  3
09B18:  BTFSS  x60.3
09B1A:  BRA    9C60
....................          { 
....................             //saves current net id 
....................             net_id_current = network_id_rcvd; 
09B1C:  MOVFF  368,550
09B20:  MOVFF  367,54F
....................             //displays information from advertisement 
....................             process_advert(); 
09B24:  MOVLB  0
09B26:  BRA    98A2
....................             //reset advertisement flag 
....................             advert_rcvd_fl = FALSE; 
09B28:  MOVLB  3
09B2A:  BCF    x60.3
....................  
....................             //if the advertisement came from a manager, give user a chance to  
....................             //select it and exit 
....................             if (mote_id_rcvd == 1) 
09B2C:  DECFSZ x69,W
09B2E:  BRA    9C60
09B30:  MOVF   x6A,F
09B32:  BTFSS  FD8.2
09B34:  BRA    9C60
....................             { 
....................                // if lcd is connected, give user a chance to select it 
....................                if (global_lcd_enabled == TRUE) 
09B36:  MOVLB  0
09B38:  BTFSS  xA7.0
09B3A:  BRA    9BCC
....................                { 
....................                   strcpy (global_temp_line_buff, "SW1 to Join     "); 
09B3C:  CLRF   FEA
09B3E:  MOVLW  70
09B40:  MOVWF  FE9
09B42:  MOVLW  00
09B44:  CALL   0442
09B48:  TBLRD*-
09B4A:  TBLRD*+
09B4C:  MOVF   FF5,W
09B4E:  MOVWF  FEE
09B50:  IORLW  00
09B52:  BNZ   9B4A
....................                   global_temp_line_buff[12] = hi2asc(make8(network_id_rcvd,1)); 
09B54:  MOVFF  368,563
09B58:  MOVFF  368,564
09B5C:  CALL   32F4
09B60:  MOVFF  01,7C
....................                   global_temp_line_buff[13] = lo2asc(make8(network_id_rcvd,1)); 
09B64:  MOVFF  368,563
09B68:  MOVFF  368,564
09B6C:  CALL   3314
09B70:  MOVFF  01,7D
....................                   global_temp_line_buff[14] = hi2asc(make8(network_id_rcvd,0)); 
09B74:  MOVFF  367,563
09B78:  MOVFF  367,564
09B7C:  CALL   32F4
09B80:  MOVFF  01,7E
....................                   global_temp_line_buff[15] = lo2asc(make8(network_id_rcvd,0)); 
09B84:  MOVFF  367,563
09B88:  MOVFF  367,564
09B8C:  CALL   3314
09B90:  MOVFF  01,7F
....................                   LCD_line1(global_temp_line_buff); 
09B94:  MOVLB  5
09B96:  CLRF   x64
09B98:  MOVLW  70
09B9A:  MOVWF  x63
09B9C:  MOVLB  0
09B9E:  CALL   39B0
....................                    
....................                   // give the user a chance to select the current NetID for 4sec 
....................                   setup_T0_int(T0_4S); 
09BA2:  MOVLW  C2
09BA4:  MOVLB  5
09BA6:  MOVWF  x69
09BA8:  MOVLW  F7
09BAA:  MOVWF  x68
09BAC:  MOVLB  0
09BAE:  CALL   38C2
....................                   while (!TMR0IF) 
09BB2:  BTFSC  FF2.2
09BB4:  BRA    9BCC
....................                   {                               
....................                      if (!input(SW1n)) 
09BB6:  BTFSC  F81.4
09BB8:  BRA    9BCA
....................                      { 
....................                         net_id_best = net_id_current; 
09BBA:  MOVFF  550,54E
09BBE:  MOVFF  54F,54D
....................                         net_id_selected = 1; 
09BC2:  MOVLB  5
09BC4:  BSF    x55.0
....................                         break; 
09BC6:  MOVLB  0
09BC8:  BRA    9BCC
....................                      } 
09BCA:  BRA    9BB2
....................                   } 
....................                } 
....................                 
....................                // store the strongest signal unless user selected network 
....................                if ((rssi_rcvd > rssi_best) && (net_id_selected == FALSE)) 
09BCC:  MOVLB  5
09BCE:  MOVF   x4C,W
09BD0:  XORLW  80
09BD2:  MOVWF  00
09BD4:  MOVLB  3
09BD6:  MOVF   x6B,W
09BD8:  XORLW  80
09BDA:  SUBWF  00,W
09BDC:  BC    9BF6
09BDE:  MOVLB  5
09BE0:  BTFSS  x55.0
09BE2:  BRA    9BE8
09BE4:  MOVLB  3
09BE6:  BRA    9BF6
....................                { 
....................                   rssi_best = rssi_rcvd; 
09BE8:  MOVFF  36B,54C
....................                   net_id_best = network_id_rcvd; 
09BEC:  MOVFF  368,54E
09BF0:  MOVFF  367,54D
09BF4:  MOVLB  3
....................                } 
....................                strcpy (global_temp_line_buff, "Strongest:      "); 
09BF6:  CLRF   FEA
09BF8:  MOVLW  70
09BFA:  MOVWF  FE9
09BFC:  MOVLW  00
09BFE:  MOVLB  0
09C00:  CALL   0464
09C04:  TBLRD*-
09C06:  TBLRD*+
09C08:  MOVF   FF5,W
09C0A:  MOVWF  FEE
09C0C:  IORLW  00
09C0E:  BNZ   9C06
....................                global_temp_line_buff[12] = hi2asc(make8(net_id_best,1)); 
09C10:  MOVFF  54E,563
09C14:  MOVFF  54E,564
09C18:  CALL   32F4
09C1C:  MOVFF  01,7C
....................                global_temp_line_buff[13] = lo2asc(make8(net_id_best,1)); 
09C20:  MOVFF  54E,563
09C24:  MOVFF  54E,564
09C28:  CALL   3314
09C2C:  MOVFF  01,7D
....................                global_temp_line_buff[14] = hi2asc(make8(net_id_best,0)); 
09C30:  MOVFF  54D,563
09C34:  MOVFF  54D,564
09C38:  CALL   32F4
09C3C:  MOVFF  01,7E
....................                global_temp_line_buff[15] = lo2asc(make8(net_id_best,0)); 
09C40:  MOVFF  54D,563
09C44:  MOVFF  54D,564
09C48:  CALL   3314
09C4C:  MOVFF  01,7F
....................                LCD_line1(global_temp_line_buff); 
09C50:  MOVLB  5
09C52:  CLRF   x64
09C54:  MOVLW  70
09C56:  MOVWF  x63
09C58:  MOVLB  0
09C5A:  CALL   39B0
09C5E:  MOVLB  3
....................             } 
....................          } 
09C60:  MOVLB  5
09C62:  BRA    9A94
09C64:  MOVLB  0
....................       } 
....................                 
....................    disable_interrupts(GLOBAL); 
09C66:  BCF    FF2.6
09C68:  BCF    FF2.7
09C6A:  BTFSC  FF2.7
09C6C:  BRA    9C68
....................     
....................    net_id_best = __swap16(net_id_best);        // swap the bytes [why?] 
09C6E:  MOVFF  54D,564
09C72:  MOVLB  5
09C74:  CLRF   x63
09C76:  MOVF   x4E,W
09C78:  CLRF   03
09C7A:  IORWF  x63,W
09C7C:  MOVWF  00
09C7E:  MOVF   03,W
09C80:  IORWF  x4D,W
09C82:  MOVFF  00,54D
09C86:  MOVWF  x4E
....................    if (!net_id_best) 
09C88:  MOVF   x4D,W
09C8A:  IORWF  x4E,W
09C8C:  BNZ   9C98
....................    { 
....................       // send to deep sleep as no network was found 
....................       global_shutdown_cause = ERR_NO_ADV_WHILE_SEARCHING; 
09C8E:  MOVLW  02
09C90:  MOVWF  4D
....................       deep_sleep(); 
09C92:  MOVLB  0
09C94:  RCALL  9740
09C96:  MOVLB  5
....................    } 
....................    
....................    // now set the best network id into the motes NV memory 
....................    pkgen_setnv_networkid(net_id_best); 
09C98:  MOVLW  03
09C9A:  MOVWF  x59
09C9C:  MOVLW  07
09C9E:  MOVWF  x5A
09CA0:  MOVLW  04
09CA2:  MOVWF  x5B
09CA4:  CLRF   x5C
09CA6:  CLRF   x5D
09CA8:  CLRF   x5E
09CAA:  CLRF   x5F
09CAC:  MOVLW  03
09CAE:  MOVWF  x60
09CB0:  MOVFF  54E,562
09CB4:  MOVFF  54D,561
09CB8:  MOVLW  05
09CBA:  MOVWF  x64
09CBC:  MOVLW  61
09CBE:  MOVWF  x63
09CC0:  MOVLW  05
09CC2:  MOVWF  x66
09CC4:  MOVLW  59
09CC6:  MOVWF  x65
09CC8:  MOVLW  08
09CCA:  MOVWF  x67
09CCC:  MOVFF  564,569
09CD0:  MOVFF  563,568
09CD4:  MOVLW  02
09CD6:  MOVWF  x6A
09CD8:  MOVLB  0
09CDA:  CALL   606C
....................    result_byte = dust_hdlc_pksend(); 
09CDE:  CALL   6316
09CE2:  MOVFF  01,54B
....................    setup_T0_int(T0_250MS); 
09CE6:  MOVLW  FC
09CE8:  MOVLB  5
09CEA:  MOVWF  x69
09CEC:  MOVLW  30
09CEE:  MOVWF  x68
09CF0:  MOVLB  0
09CF2:  CALL   38C2
....................    while (!TMR0IF && !setnetid_done_fl && !result_byte); 
09CF6:  BTFSC  FF2.2
09CF8:  BRA    9D12
09CFA:  MOVLB  3
09CFC:  BTFSS  x60.4
09CFE:  BRA    9D04
09D00:  MOVLB  0
09D02:  BRA    9D12
09D04:  MOVLB  5
09D06:  MOVF   x4B,F
09D08:  BTFSS  FD8.2
09D0A:  BRA    9D10
09D0C:  MOVLB  0
09D0E:  BRA    9CF6
09D10:  MOVLB  0
....................     
....................    if (TMR0IF || result_byte) 
09D12:  BTFSC  FF2.2
09D14:  BRA    9D1E
09D16:  MOVLB  5
09D18:  MOVF   x4B,F
09D1A:  BZ    9D26
09D1C:  MOVLB  0
....................    { 
....................       // send to deep sleep network couldn't be joined 
....................       global_shutdown_cause = ERR_NETWORK_JOIN_FAIL; 
09D1E:  MOVLW  06
09D20:  MOVWF  4D
....................       deep_sleep(); 
09D22:  RCALL  9740
09D24:  MOVLB  5
....................    } 
....................     
....................    strcpy (global_temp_line_buff, " Search Success "); 
09D26:  CLRF   FEA
09D28:  MOVLW  70
09D2A:  MOVWF  FE9
09D2C:  MOVLW  00
09D2E:  MOVLB  0
09D30:  CALL   0486
09D34:  TBLRD*-
09D36:  TBLRD*+
09D38:  MOVF   FF5,W
09D3A:  MOVWF  FEE
09D3C:  IORLW  00
09D3E:  BNZ   9D36
....................    LCD_line1(global_temp_line_buff); 
09D40:  MOVLB  5
09D42:  CLRF   x64
09D44:  MOVLW  70
09D46:  MOVWF  x63
09D48:  MOVLB  0
09D4A:  CALL   39B0
....................    strcpy (global_temp_line_buff, "Next join:      "); 
09D4E:  CLRF   FEA
09D50:  MOVLW  70
09D52:  MOVWF  FE9
09D54:  MOVLW  00
09D56:  CALL   04A8
09D5A:  TBLRD*-
09D5C:  TBLRD*+
09D5E:  MOVF   FF5,W
09D60:  MOVWF  FEE
09D62:  IORLW  00
09D64:  BNZ   9D5C
....................    global_temp_line_buff[12] = hi2asc(make8(net_id_best,0)); 
09D66:  MOVFF  54D,563
09D6A:  MOVFF  54D,564
09D6E:  CALL   32F4
09D72:  MOVFF  01,7C
....................    global_temp_line_buff[13] = lo2asc(make8(net_id_best,0)); 
09D76:  MOVFF  54D,563
09D7A:  MOVFF  54D,564
09D7E:  CALL   3314
09D82:  MOVFF  01,7D
....................    global_temp_line_buff[14] = hi2asc(make8(net_id_best,1)); 
09D86:  MOVFF  54E,563
09D8A:  MOVFF  54E,564
09D8E:  CALL   32F4
09D92:  MOVFF  01,7E
....................    global_temp_line_buff[15] = lo2asc(make8(net_id_best,1)); 
09D96:  MOVFF  54E,563
09D9A:  MOVFF  54E,564
09D9E:  CALL   3314
09DA2:  MOVFF  01,7F
....................    LCD_line2(global_temp_line_buff); 
09DA6:  MOVLB  5
09DA8:  CLRF   x64
09DAA:  MOVLW  70
09DAC:  MOVWF  x63
09DAE:  MOVLB  0
09DB0:  CALL   3A0A
....................  
....................    // Let it sit on the screen for a couple seconds 
....................    setup_T0_int(T0_2S); 
09DB4:  MOVLW  E1
09DB6:  MOVLB  5
09DB8:  MOVWF  x69
09DBA:  MOVLW  7C
09DBC:  MOVWF  x68
09DBE:  MOVLB  0
09DC0:  CALL   38C2
....................    while (!TMR0IF);       
09DC4:  BTFSS  FF2.2
09DC6:  BRA    9DC4
....................     
....................    happy_lites();                                            
09DC8:  CALL   5034
....................                                                  
....................    // send to deep sleep as network id is now set 
....................    global_shutdown_cause |= NEW_NETWORK_ID_SET; 
09DCC:  MOVLW  03
09DCE:  IORWF  4D,F
....................    deep_sleep(); 
09DD0:  RCALL  9740
....................     
....................    return; 
09DD2:  GOTO   B1D4 (RETURN)
.................... } 
....................  
.................... void  process_advert(void) 
.................... { 
....................    strcpy (global_temp_line_buff, "                "); 
*
098A2:  CLRF   FEA
098A4:  MOVLW  70
098A6:  MOVWF  FE9
098A8:  MOVLW  00
098AA:  CALL   04CA
098AE:  TBLRD*-
098B0:  TBLRD*+
098B2:  MOVF   FF5,W
098B4:  MOVWF  FEE
098B6:  IORLW  00
098B8:  BNZ   98B0
....................  
....................    global_temp_line_buff[0] = hi2asc(make8(network_id_rcvd,1)); 
098BA:  MOVFF  368,563
098BE:  MOVFF  368,564
098C2:  CALL   32F4
098C6:  MOVFF  01,70
....................    global_temp_line_buff[1] = lo2asc(make8(network_id_rcvd,1)); 
098CA:  MOVFF  368,563
098CE:  MOVFF  368,564
098D2:  CALL   3314
098D6:  MOVFF  01,71
....................    global_temp_line_buff[2] = hi2asc(make8(network_id_rcvd,0)); 
098DA:  MOVFF  367,563
098DE:  MOVFF  367,564
098E2:  CALL   32F4
098E6:  MOVFF  01,72
....................    global_temp_line_buff[3] = lo2asc(make8(network_id_rcvd,0)); 
098EA:  MOVFF  367,563
098EE:  MOVFF  367,564
098F2:  CALL   3314
098F6:  MOVFF  01,73
....................    // NOTE network_id_rcvd is swapped when rcvd to simplify 
....................    //  the netID comparisons that take place later 
....................     
....................    LCD_line2(global_temp_line_buff);  
098FA:  MOVLB  5
098FC:  CLRF   x64
098FE:  MOVLW  70
09900:  MOVWF  x63
09902:  MOVLB  0
09904:  CALL   3A0A
....................     
....................    mote_id_rcvd = __swap16(mote_id_rcvd);    // swap the bytes [why?] 
09908:  MOVFF  369,564
0990C:  MOVLB  5
0990E:  CLRF   x63
09910:  MOVLB  3
09912:  MOVF   x6A,W
09914:  CLRF   03
09916:  MOVLB  5
09918:  IORWF  x63,W
0991A:  MOVLB  3
0991C:  MOVWF  x69
0991E:  MOVF   03,W
09920:  MOVLB  5
09922:  IORWF  x64,W
09924:  MOVLB  3
09926:  MOVWF  x6A
....................     
....................    LCD_place_uint16(mote_id_rcvd, 1, 5, 3); 
09928:  MOVFF  36A,564
0992C:  MOVFF  369,563
09930:  MOVLW  01
09932:  MOVLB  5
09934:  MOVWF  x65
09936:  MOVLW  05
09938:  MOVWF  x66
0993A:  MOVLW  03
0993C:  MOVWF  x67
0993E:  MOVLB  0
09940:  CALL   6A3C
....................  
....................     
....................       if (rssi_rcvd >= 0) 
09944:  MOVLB  3
09946:  BTFSC  x6B.7
09948:  BRA    996A
....................       { 
....................          LCD_place_uint8(((uint8_t)(rssi_rcvd) + 128), 1, 9, 3); 
0994A:  MOVLW  80
0994C:  ADDWF  x6B,W
0994E:  MOVLB  5
09950:  MOVWF  x63
09952:  MOVWF  x64
09954:  MOVLW  01
09956:  MOVWF  x65
09958:  MOVLW  09
0995A:  MOVWF  x66
0995C:  MOVLW  03
0995E:  MOVWF  x67
09960:  MOVLB  0
09962:  CALL   6B16
....................       } 
09966:  BRA    9992
09968:  MOVLB  3
....................       else 
....................       { 
....................          LCD_place_uint8((128 - abs(rssi_rcvd)), 1, 9, 3); 
0996A:  MOVF   x6B,W
0996C:  BTFSS  x6B.7
0996E:  BRA    9976
09970:  MOVLW  00
09972:  BSF    FD8.0
09974:  SUBFWB x6B,W
09976:  XORLW  FF
09978:  ADDLW  81
0997A:  MOVLB  5
0997C:  MOVWF  x63
0997E:  MOVWF  x64
09980:  MOVLW  01
09982:  MOVWF  x65
09984:  MOVLW  09
09986:  MOVWF  x66
09988:  MOVLW  03
0998A:  MOVWF  x67
0998C:  MOVLB  0
0998E:  CALL   6B16
....................       } 
....................     
....................    LCD_place_uint8(hop_depth_rcvd, 1, 13, 3); 
09992:  MOVFF  36C,564
09996:  MOVLW  01
09998:  MOVLB  5
0999A:  MOVWF  x65
0999C:  MOVLW  0D
0999E:  MOVWF  x66
099A0:  MOVLW  03
099A2:  MOVWF  x67
099A4:  MOVLB  0
099A6:  CALL   6B16
099AA:  GOTO   9B28 (RETURN)
.................... } 
....................  
.................... uint8_t     initiate_join(void) 
.................... { 
.................... // initiates a join by setting the joinduty to the max   
....................    uint8_t  result_byte; 
....................     
....................    // set the join duty and timeout error handling 
....................    global_set_get_response = FALSE; 
*
09DD6:  MOVLB  3
09DD8:  BCF    x60.2
....................    pkgen_set_joinduty(0xFF); 
09DDA:  MOVLW  01
09DDC:  MOVLB  5
09DDE:  MOVWF  x4C
09DE0:  MOVLW  02
09DE2:  MOVWF  x4D
09DE4:  MOVLW  04
09DE6:  MOVWF  x4E
09DE8:  MOVLW  06
09DEA:  MOVWF  x4F
09DEC:  SETF   x50
09DEE:  MOVLW  05
09DF0:  MOVWF  x66
09DF2:  MOVLW  4C
09DF4:  MOVWF  x65
09DF6:  MOVLW  04
09DF8:  MOVWF  x67
09DFA:  MOVLW  05
09DFC:  MOVWF  x69
09DFE:  MOVLW  50
09E00:  MOVWF  x68
09E02:  MOVLW  01
09E04:  MOVWF  x6A
09E06:  MOVLB  0
09E08:  CALL   606C
....................    result_byte = dust_hdlc_pksend(); 
09E0C:  CALL   6316
09E10:  MOVFF  01,54B
....................    setup_T0_int(T0_250MS); 
09E14:  MOVLW  FC
09E16:  MOVLB  5
09E18:  MOVWF  x69
09E1A:  MOVLW  30
09E1C:  MOVWF  x68
09E1E:  MOVLB  0
09E20:  CALL   38C2
....................    while (!TMR0IF && !global_set_get_response && !result_byte); 
09E24:  BTFSC  FF2.2
09E26:  BRA    9E40
09E28:  MOVLB  3
09E2A:  BTFSS  x60.2
09E2C:  BRA    9E32
09E2E:  MOVLB  0
09E30:  BRA    9E40
09E32:  MOVLB  5
09E34:  MOVF   x4B,F
09E36:  BTFSS  FD8.2
09E38:  BRA    9E3E
09E3A:  MOVLB  0
09E3C:  BRA    9E24
09E3E:  MOVLB  0
....................    if (TMR0IF || result_byte) 
09E40:  BTFSC  FF2.2
09E42:  BRA    9E4C
09E44:  MOVLB  5
09E46:  MOVF   x4B,F
09E48:  BZ    9E54
09E4A:  MOVLB  0
....................       return ERR_MTJOINDUTY;  
09E4C:  MOVLW  07
09E4E:  MOVWF  01
09E50:  BRA    9F4A
09E52:  MOVLB  5
....................     
....................    // set the joinkey and timeout error handling   
....................    global_set_get_response = FALSE; 
09E54:  MOVLB  3
09E56:  BCF    x60.2
....................    pkgen_setnv_joinkey(joinkey); 
09E58:  MOVLW  03
09E5A:  MOVLB  5
09E5C:  MOVWF  x51
09E5E:  MOVLW  15
09E60:  MOVWF  x52
09E62:  MOVLW  04
09E64:  MOVWF  x53
09E66:  CLRF   x54
09E68:  CLRF   x55
09E6A:  CLRF   x56
09E6C:  CLRF   x57
09E6E:  MOVLW  02
09E70:  MOVWF  x58
09E72:  MOVLW  05
09E74:  MOVWF  x66
09E76:  MOVLW  51
09E78:  MOVWF  x65
09E7A:  MOVLW  08
09E7C:  MOVWF  x67
09E7E:  CLRF   x69
09E80:  MOVLW  37
09E82:  MOVWF  x68
09E84:  MOVLW  10
09E86:  MOVWF  x6A
09E88:  MOVLB  0
09E8A:  CALL   606C
....................    result_byte = dust_hdlc_pksend(); 
09E8E:  CALL   6316
09E92:  MOVFF  01,54B
....................    setup_T0_int(T0_250MS); 
09E96:  MOVLW  FC
09E98:  MOVLB  5
09E9A:  MOVWF  x69
09E9C:  MOVLW  30
09E9E:  MOVWF  x68
09EA0:  MOVLB  0
09EA2:  CALL   38C2
....................    while (!TMR0IF && !global_set_get_response && !result_byte); 
09EA6:  BTFSC  FF2.2
09EA8:  BRA    9EC2
09EAA:  MOVLB  3
09EAC:  BTFSS  x60.2
09EAE:  BRA    9EB4
09EB0:  MOVLB  0
09EB2:  BRA    9EC2
09EB4:  MOVLB  5
09EB6:  MOVF   x4B,F
09EB8:  BTFSS  FD8.2
09EBA:  BRA    9EC0
09EBC:  MOVLB  0
09EBE:  BRA    9EA6
09EC0:  MOVLB  0
....................    if (TMR0IF || result_byte) 
09EC2:  BTFSC  FF2.2
09EC4:  BRA    9ECE
09EC6:  MOVLB  5
09EC8:  MOVF   x4B,F
09ECA:  BZ    9ED6
09ECC:  MOVLB  0
....................       return ERR_MTJOINKEY;   
09ECE:  MOVLW  08
09ED0:  MOVWF  01
09ED2:  BRA    9F4A
09ED4:  MOVLB  5
....................        
....................    // NOTE that we assume that the non-volatile memory of the mote 
....................    //  contains a valid network ID.... 
....................    // The join could fail if blue box not found or if it is trying to join 
....................    //  to a nonvalid network ID 
....................     
....................    // actually send the join command 
....................    global_set_get_response = FALSE; 
09ED6:  MOVLB  3
09ED8:  BCF    x60.2
....................    pkgen_join(); 
09EDA:  MOVLW  06
09EDC:  MOVLB  5
09EDE:  MOVWF  x59
09EE0:  CLRF   x5A
09EE2:  MOVLW  04
09EE4:  MOVWF  x5B
09EE6:  CLRF   x66
09EE8:  CLRF   x65
09EEA:  CLRF   x67
09EEC:  MOVLW  05
09EEE:  MOVWF  x69
09EF0:  MOVLW  59
09EF2:  MOVWF  x68
09EF4:  MOVLW  03
09EF6:  MOVWF  x6A
09EF8:  MOVLB  0
09EFA:  CALL   606C
....................    result_byte = dust_hdlc_pksend(); 
09EFE:  CALL   6316
09F02:  MOVFF  01,54B
....................    setup_T0_int(T0_250MS); 
09F06:  MOVLW  FC
09F08:  MOVLB  5
09F0A:  MOVWF  x69
09F0C:  MOVLW  30
09F0E:  MOVWF  x68
09F10:  MOVLB  0
09F12:  CALL   38C2
....................    while (!TMR0IF && !global_set_get_response && !result_byte); 
09F16:  BTFSC  FF2.2
09F18:  BRA    9F32
09F1A:  MOVLB  3
09F1C:  BTFSS  x60.2
09F1E:  BRA    9F24
09F20:  MOVLB  0
09F22:  BRA    9F32
09F24:  MOVLB  5
09F26:  MOVF   x4B,F
09F28:  BTFSS  FD8.2
09F2A:  BRA    9F30
09F2C:  MOVLB  0
09F2E:  BRA    9F16
09F30:  MOVLB  0
....................    if (TMR0IF || result_byte) 
09F32:  BTFSC  FF2.2
09F34:  BRA    9F3E
09F36:  MOVLB  5
09F38:  MOVF   x4B,F
09F3A:  BZ    9F46
09F3C:  MOVLB  0
....................       return ERR_NETWORK_JOIN_FAIL; 
09F3E:  MOVLW  06
09F40:  MOVWF  01
09F42:  BRA    9F4A
09F44:  MOVLB  5
....................      
....................    return NO_ERR; 
09F46:  MOVLW  00
09F48:  MOVWF  01
09F4A:  MOVLB  0
09F4C:  GOTO   B1D4 (RETURN)
.................... } 
....................  
.................... void mote_state_check(void) 
.................... { 
.................... // Asks mote what it's status is and responds accordingly (including following 
.................... // up on the mote status later) 
.................... // Restarts mote if needed, triggers join/rejoin if needed, and continues to  
.................... // check status until mote is operational 
....................    uint8_t result_byte; 
....................  
....................    // send the mote status package to the mote 
....................    global_set_get_response = FALSE; 
*
08F64:  MOVLB  3
08F66:  BCF    x60.2
....................    pkgen_get_motestatus(); 
08F68:  MOVLW  02
08F6A:  MOVLB  5
08F6C:  MOVWF  x4C
08F6E:  MOVLW  01
08F70:  MOVWF  x4D
08F72:  MOVLW  04
08F74:  MOVWF  x4E
08F76:  MOVLW  0E
08F78:  MOVWF  x4F
08F7A:  CLRF   x66
08F7C:  CLRF   x65
08F7E:  CLRF   x67
08F80:  MOVLW  05
08F82:  MOVWF  x69
08F84:  MOVLW  4C
08F86:  MOVWF  x68
08F88:  MOVLW  04
08F8A:  MOVWF  x6A
08F8C:  MOVLB  0
08F8E:  CALL   606C
....................    result_byte = dust_hdlc_pksend();                                               
08F92:  CALL   6316
08F96:  MOVFF  01,54B
....................    setup_T0_int(T0_250MS); 
08F9A:  MOVLW  FC
08F9C:  MOVLB  5
08F9E:  MOVWF  x69
08FA0:  MOVLW  30
08FA2:  MOVWF  x68
08FA4:  MOVLB  0
08FA6:  CALL   38C2
....................    while (!TMR0IF && !global_set_get_response && !result_byte); 
08FAA:  BTFSC  FF2.2
08FAC:  BRA    8FC6
08FAE:  MOVLB  3
08FB0:  BTFSS  x60.2
08FB2:  BRA    8FB8
08FB4:  MOVLB  0
08FB6:  BRA    8FC6
08FB8:  MOVLB  5
08FBA:  MOVF   x4B,F
08FBC:  BTFSS  FD8.2
08FBE:  BRA    8FC4
08FC0:  MOVLB  0
08FC2:  BRA    8FAA
08FC4:  MOVLB  0
....................     
....................    // if the mote status request fails, trigger a mote reboot 
....................    if (TMR0IF || result_byte) 
08FC6:  BTFSC  FF2.2
08FC8:  BRA    8FD2
08FCA:  MOVLB  5
08FCC:  MOVF   x4B,F
08FCE:  BZ    9028
08FD0:  MOVLB  0
....................    { 
....................       PUSH_PRIORITY_QUEUE_MACRO(RESET_MOTE); 
08FD2:  BCF    F7A.1
08FD4:  MOVLW  11
08FD6:  MOVLB  5
08FD8:  MOVWF  x52
08FDA:  MOVLB  0
08FDC:  CALL   4748
08FE0:  BSF    F7A.1
....................       PUSH_TIME_QUEUE_MACRO((global_rtc_time + 10), CHECK_MOTE_STATE) 
08FE2:  BCF    F7A.1
08FE4:  MOVLW  0A
08FE6:  ADDWF  x85,W
08FE8:  MOVLB  5
08FEA:  MOVWF  x50
08FEC:  MOVLW  00
08FEE:  MOVLB  0
08FF0:  ADDWFC x86,W
08FF2:  MOVLB  5
08FF4:  MOVWF  x51
08FF6:  MOVLW  00
08FF8:  MOVLB  0
08FFA:  ADDWFC x87,W
08FFC:  MOVLB  5
08FFE:  MOVWF  x52
09000:  MOVLW  00
09002:  MOVLB  0
09004:  ADDWFC x88,W
09006:  MOVLB  5
09008:  MOVWF  x53
0900A:  MOVWF  x59
0900C:  MOVFF  552,558
09010:  MOVFF  551,557
09014:  MOVFF  550,556
09018:  MOVLW  B4
0901A:  MOVWF  x5A
0901C:  MOVLB  0
0901E:  CALL   44A0
09022:  BSF    F7A.1
....................    } 
09024:  BRA    92C6
09026:  MOVLB  5
....................    // if it has been more than MOTE_NETWORK_SHUTDOWN_TIMEOUT seconds since the mote  
....................    //    returned an operational state, and the mote is in the SYSTEM_RUN state or the SYSTEM_IDLE state 
....................    //    (not looking for a network) 
....................    else if (((global_rtc_time - global_last_connected_time) > MOTE_NETWORK_SHUTDOWN_TIMEOUT) && \ 
....................       ((read_system_state() == SYSTEM_RUN) || (read_system_state() == SYSTEM_IDLE)))    
09028:  MOVF   47,W
0902A:  MOVLB  0
0902C:  SUBWF  x85,W
0902E:  MOVLB  5
09030:  MOVWF  x50
09032:  MOVF   48,W
09034:  MOVLB  0
09036:  SUBWFB x86,W
09038:  MOVLB  5
0903A:  MOVWF  x51
0903C:  MOVF   49,W
0903E:  MOVLB  0
09040:  SUBWFB x87,W
09042:  MOVLB  5
09044:  MOVWF  x52
09046:  MOVF   4A,W
09048:  MOVLB  0
0904A:  SUBWFB x88,W
0904C:  MOVLB  5
0904E:  MOVWF  x53
09050:  MOVF   x53,F
09052:  BNZ   9066
09054:  MOVF   x52,F
09056:  BNZ   9066
09058:  MOVF   x26,W
0905A:  SUBWF  x51,W
0905C:  BNC   90D4
0905E:  BNZ   9066
09060:  MOVF   x50,W
09062:  SUBWF  x25,W
09064:  BC    90D4
09066:  MOVLB  0
09068:  CALL   1F4A
0906C:  MOVF   01,W
0906E:  SUBLW  02
09070:  BZ    9082
09072:  CALL   1F4A
09076:  MOVF   01,W
09078:  SUBLW  03
0907A:  BTFSC  FD8.2
0907C:  BRA    9082
0907E:  MOVLB  5
09080:  BRA    90D4
....................    {                                       
....................          // set the shutdown cause and schedule a shutdown 10 seconds later 
....................          global_shutdown_cause = ERR_NO_NETWORK_TIMEOUT; 
09082:  MOVLW  0D
09084:  MOVWF  4D
....................          PUSH_PRIORITY_QUEUE(OPEN_VALVE_UNKNOWN_STATE);   
09086:  MOVLW  3E
09088:  MOVLB  5
0908A:  MOVWF  x52
0908C:  MOVLB  0
0908E:  CALL   4748
....................          PUSH_TIME_QUEUE(global_rtc_time + 10, SHUTDOWN_SYSTEM);    
09092:  MOVLW  0A
09094:  ADDWF  x85,W
09096:  MOVLB  5
09098:  MOVWF  x50
0909A:  MOVLW  00
0909C:  MOVLB  0
0909E:  ADDWFC x86,W
090A0:  MOVLB  5
090A2:  MOVWF  x51
090A4:  MOVLW  00
090A6:  MOVLB  0
090A8:  ADDWFC x87,W
090AA:  MOVLB  5
090AC:  MOVWF  x52
090AE:  MOVLW  00
090B0:  MOVLB  0
090B2:  ADDWFC x88,W
090B4:  MOVLB  5
090B6:  MOVWF  x53
090B8:  MOVWF  x59
090BA:  MOVFF  552,558
090BE:  MOVFF  551,557
090C2:  MOVFF  550,556
090C6:  MOVLW  F1
090C8:  MOVWF  x5A
090CA:  MOVLB  0
090CC:  CALL   44A0
....................    } 
090D0:  BRA    92C6
090D2:  MOVLB  5
....................     
....................    // if mote is idle or disconnected, initiate a join and check on mote later 
....................    else if ((global_mote_state == MOTESTATE_IDLE) ||                          \ 
....................       (global_mote_state == MOTESTATE_DISCONNECTED))   
090D4:  DECFSZ x04,W
090D6:  BRA    90DA
090D8:  BRA    90E0
090DA:  MOVF   x04,W
090DC:  SUBLW  06
090DE:  BNZ   9134
....................    { 
....................       PUSH_PRIORITY_QUEUE_MACRO(INIT_JOIN); 
090E0:  BCF    F7A.1
090E2:  MOVLW  B3
090E4:  MOVWF  x52
090E6:  MOVLB  0
090E8:  CALL   4748
090EC:  BSF    F7A.1
....................       PUSH_TIME_QUEUE_MACRO((global_rtc_time + 10), CHECK_MOTE_STATE) 
090EE:  BCF    F7A.1
090F0:  MOVLW  0A
090F2:  ADDWF  x85,W
090F4:  MOVLB  5
090F6:  MOVWF  x50
090F8:  MOVLW  00
090FA:  MOVLB  0
090FC:  ADDWFC x86,W
090FE:  MOVLB  5
09100:  MOVWF  x51
09102:  MOVLW  00
09104:  MOVLB  0
09106:  ADDWFC x87,W
09108:  MOVLB  5
0910A:  MOVWF  x52
0910C:  MOVLW  00
0910E:  MOVLB  0
09110:  ADDWFC x88,W
09112:  MOVLB  5
09114:  MOVWF  x53
09116:  MOVWF  x59
09118:  MOVFF  552,558
0911C:  MOVFF  551,557
09120:  MOVFF  550,556
09124:  MOVLW  B4
09126:  MOVWF  x5A
09128:  MOVLB  0
0912A:  CALL   44A0
0912E:  BSF    F7A.1
.................... //      LCD_place_char('D',1,15);     
....................    }                                                          
09130:  BRA    92C6
09132:  MOVLB  5
....................     
....................    // if mote is in one of these odd/unwanted modes, trigger reset 
....................    // and a status check (to initiate a join) in the future 
....................    else if ((global_mote_state == MOTESTATE_RADIOTEST) ||                     \ 
....................       (global_mote_state == MOTESTATE_UNKNOWN))                      
09134:  MOVF   x04,W
09136:  SUBLW  07
09138:  BZ    913E
0913A:  INCFSZ x04,W
0913C:  BRA    9192
....................    {    
....................       PUSH_PRIORITY_QUEUE_MACRO(RESET_MOTE); 
0913E:  BCF    F7A.1
09140:  MOVLW  11
09142:  MOVWF  x52
09144:  MOVLB  0
09146:  CALL   4748
0914A:  BSF    F7A.1
....................       PUSH_TIME_QUEUE_MACRO((global_rtc_time + 10), CHECK_MOTE_STATE) 
0914C:  BCF    F7A.1
0914E:  MOVLW  0A
09150:  ADDWF  x85,W
09152:  MOVLB  5
09154:  MOVWF  x50
09156:  MOVLW  00
09158:  MOVLB  0
0915A:  ADDWFC x86,W
0915C:  MOVLB  5
0915E:  MOVWF  x51
09160:  MOVLW  00
09162:  MOVLB  0
09164:  ADDWFC x87,W
09166:  MOVLB  5
09168:  MOVWF  x52
0916A:  MOVLW  00
0916C:  MOVLB  0
0916E:  ADDWFC x88,W
09170:  MOVLB  5
09172:  MOVWF  x53
09174:  MOVWF  x59
09176:  MOVFF  552,558
0917A:  MOVFF  551,557
0917E:  MOVFF  550,556
09182:  MOVLW  B4
09184:  MOVWF  x5A
09186:  MOVLB  0
09188:  CALL   44A0
0918C:  BSF    F7A.1
.................... //      LCD_place_char('U',1,15); 
....................    } 
0918E:  BRA    92C6
09190:  MOVLB  5
....................     
....................    // if mote is in promiscuous listen mode but the system state is not  
....................    //    searching for the network, restart as it's unwanted. 
....................    else if ((global_mote_state == MOTESTATE_PROMISCUOUS) &&                   \ 
....................       (!(read_system_state() == SYSTEM_SEARCHING_FOR_NETWORK))) 
09192:  MOVF   x04,W
09194:  SUBLW  08
09196:  BNZ   9200
09198:  MOVLB  0
0919A:  CALL   1F4A
0919E:  MOVF   01,W
091A0:  SUBLW  20
091A2:  BTFSS  FD8.2
091A4:  BRA    91AA
091A6:  MOVLB  5
091A8:  BRA    9200
....................    {                                                     
....................       PUSH_PRIORITY_QUEUE_MACRO(RESET_MOTE); 
091AA:  BCF    F7A.1
091AC:  MOVLW  11
091AE:  MOVLB  5
091B0:  MOVWF  x52
091B2:  MOVLB  0
091B4:  CALL   4748
091B8:  BSF    F7A.1
....................       PUSH_TIME_QUEUE_MACRO((global_rtc_time + 10), CHECK_MOTE_STATE) 
091BA:  BCF    F7A.1
091BC:  MOVLW  0A
091BE:  ADDWF  x85,W
091C0:  MOVLB  5
091C2:  MOVWF  x50
091C4:  MOVLW  00
091C6:  MOVLB  0
091C8:  ADDWFC x86,W
091CA:  MOVLB  5
091CC:  MOVWF  x51
091CE:  MOVLW  00
091D0:  MOVLB  0
091D2:  ADDWFC x87,W
091D4:  MOVLB  5
091D6:  MOVWF  x52
091D8:  MOVLW  00
091DA:  MOVLB  0
091DC:  ADDWFC x88,W
091DE:  MOVLB  5
091E0:  MOVWF  x53
091E2:  MOVWF  x59
091E4:  MOVFF  552,558
091E8:  MOVFF  551,557
091EC:  MOVFF  550,556
091F0:  MOVLW  B4
091F2:  MOVWF  x5A
091F4:  MOVLB  0
091F6:  CALL   44A0
091FA:  BSF    F7A.1
.................... //      LCD_place_char('N',1,15); 
....................    } 
091FC:  BRA    92C6
091FE:  MOVLB  5
....................     
....................    // if the mote is booting or initiating a join, check up on it later 
....................    else if ((global_mote_state == MOTESTATE_INIT) ||                          \ 
....................       (global_mote_state == MOTESTATE_SEARCHING) ||                           \ 
....................       (global_mote_state == MOTESTATE_NEGOTIATING) ||                         \ 
....................       (global_mote_state == MOTESTATE_CONNECTED)) 
09200:  MOVF   x04,F
09202:  BZ    9216
09204:  MOVF   x04,W
09206:  SUBLW  02
09208:  BZ    9216
0920A:  MOVF   x04,W
0920C:  SUBLW  03
0920E:  BZ    9216
09210:  MOVF   x04,W
09212:  SUBLW  04
09214:  BNZ   925E
....................    {                                                                                
....................       PUSH_TIME_QUEUE_MACRO((global_rtc_time + 10), CHECK_MOTE_STATE)   
09216:  BCF    F7A.1
09218:  MOVLW  0A
0921A:  MOVLB  0
0921C:  ADDWF  x85,W
0921E:  MOVLB  5
09220:  MOVWF  x50
09222:  MOVLW  00
09224:  MOVLB  0
09226:  ADDWFC x86,W
09228:  MOVLB  5
0922A:  MOVWF  x51
0922C:  MOVLW  00
0922E:  MOVLB  0
09230:  ADDWFC x87,W
09232:  MOVLB  5
09234:  MOVWF  x52
09236:  MOVLW  00
09238:  MOVLB  0
0923A:  ADDWFC x88,W
0923C:  MOVLB  5
0923E:  MOVWF  x53
09240:  MOVWF  x59
09242:  MOVFF  552,558
09246:  MOVFF  551,557
0924A:  MOVFF  550,556
0924E:  MOVLW  B4
09250:  MOVWF  x5A
09252:  MOVLB  0
09254:  CALL   44A0
09258:  BSF    F7A.1
.................... //      LCD_place_char('I',1,15);  
....................    } 
0925A:  BRA    92C6
0925C:  MOVLB  5
....................     
....................    // mote is operational, do nothing 
....................    else if (global_mote_state == MOTESTATE_OPERATIONAL) 
0925E:  MOVF   x04,W
09260:  SUBLW  05
09262:  BNZ   9276
....................    {  
....................       global_last_connected_time = global_rtc_time; 
09264:  MOVFF  88,4A
09268:  MOVFF  87,49
0926C:  MOVFF  86,48
09270:  MOVFF  85,47
.................... //      LCD_place_char('O',1,15);      
....................       break; 
....................    } 
09274:  BRA    92C8
....................     
....................    // incase there is some other crazy mote status, restart mote and retry 
....................    else 
....................    { 
....................       PUSH_PRIORITY_QUEUE_MACRO(RESET_MOTE); 
09276:  BCF    F7A.1
09278:  MOVLW  11
0927A:  MOVWF  x52
0927C:  MOVLB  0
0927E:  CALL   4748
09282:  BSF    F7A.1
....................       PUSH_TIME_QUEUE_MACRO((global_rtc_time + 10), CHECK_MOTE_STATE) 
09284:  BCF    F7A.1
09286:  MOVLW  0A
09288:  ADDWF  x85,W
0928A:  MOVLB  5
0928C:  MOVWF  x50
0928E:  MOVLW  00
09290:  MOVLB  0
09292:  ADDWFC x86,W
09294:  MOVLB  5
09296:  MOVWF  x51
09298:  MOVLW  00
0929A:  MOVLB  0
0929C:  ADDWFC x87,W
0929E:  MOVLB  5
092A0:  MOVWF  x52
092A2:  MOVLW  00
092A4:  MOVLB  0
092A6:  ADDWFC x88,W
092A8:  MOVLB  5
092AA:  MOVWF  x53
092AC:  MOVWF  x59
092AE:  MOVFF  552,558
092B2:  MOVFF  551,557
092B6:  MOVFF  550,556
092BA:  MOVLW  B4
092BC:  MOVWF  x5A
092BE:  MOVLB  0
092C0:  CALL   44A0
092C4:  BSF    F7A.1
092C6:  MOVLB  5
....................    } 
....................    break; 
092C8:  MOVLB  0
092CA:  GOTO   B1D4 (RETURN)
.................... } 
....................  
.................... void mote_info_check(void) 
.................... // queries the mote to send back information including mac address (serial no), 
.................... //  hardware model/rev, API version, etc. 
.................... { 
....................    uint8_t result_byte; 
....................     
....................    // if the mote is not enabled/ready exit! 
....................    if (global_dust_enabled == FALSE) return; 
092CE:  BTFSS  xA7.6
092D0:  BRA    9354
....................        
....................    // set the response flag 
....................    global_set_get_response = FALSE; 
092D2:  MOVLB  3
092D4:  BCF    x60.2
....................    // generate the message and send the message 
....................     
....................    pkgen_get_moteinfo(); 
092D6:  MOVLW  02
092D8:  MOVLB  5
092DA:  MOVWF  x4C
092DC:  MOVLW  01
092DE:  MOVWF  x4D
092E0:  MOVLW  04
092E2:  MOVWF  x4E
092E4:  MOVLW  0C
092E6:  MOVWF  x4F
092E8:  CLRF   x66
092EA:  CLRF   x65
092EC:  CLRF   x67
092EE:  MOVLW  05
092F0:  MOVWF  x69
092F2:  MOVLW  4C
092F4:  MOVWF  x68
092F6:  MOVLW  04
092F8:  MOVWF  x6A
092FA:  MOVLB  0
092FC:  CALL   606C
....................    result_byte = dust_hdlc_pksend(); 
09300:  CALL   6316
09304:  MOVFF  01,54B
....................    // set message timeout 
....................    setup_T0_int(T0_250MS); 
09308:  MOVLW  FC
0930A:  MOVLB  5
0930C:  MOVWF  x69
0930E:  MOVLW  30
09310:  MOVWF  x68
09312:  MOVLB  0
09314:  CALL   38C2
....................    while (!TMR0IF && !global_set_get_response && !result_byte); 
09318:  BTFSC  FF2.2
0931A:  BRA    9334
0931C:  MOVLB  3
0931E:  BTFSS  x60.2
09320:  BRA    9326
09322:  MOVLB  0
09324:  BRA    9334
09326:  MOVLB  5
09328:  MOVF   x4B,F
0932A:  BTFSS  FD8.2
0932C:  BRA    9332
0932E:  MOVLB  0
09330:  BRA    9318
09332:  MOVLB  0
....................    // if the message fails, send an error message (kinda pointless though) 
....................    if (TMR0IF || result_byte) 
09334:  BTFSC  FF2.2
09336:  BRA    9340
09338:  MOVLB  5
0933A:  MOVF   x4B,F
0933C:  BZ    9356
0933E:  MOVLB  0
....................    { 
....................       global_error_message_bitfield |= ERR_MOTE_UNRESPONSIVE; 
09340:  MOVLB  4
09342:  BSF    xF8.2
....................       PUSH_MESSAGE_QUEUE_MACRO(MSG_MOTE_ERROR_MSG); 
09344:  BCF    F7A.1
09346:  MOVLW  A0
09348:  MOVLB  5
0934A:  MOVWF  x54
0934C:  MOVLB  0
0934E:  CALL   51F6
09352:  BSF    F7A.1
09354:  MOVLB  5
....................    } 
09356:  MOVLB  0
09358:  GOTO   B1D4 (RETURN)
....................     
.................... } 
....................  
.................... void mote_temp_check(void) 
.................... // queries the mote to send the temperature back and stores it in the global 
.................... //    variable global_mote_temperature  
.................... { 
....................    uint8_t result_byte; 
....................     
....................    // if the mote is not enabled/ready exit! 
....................    if (global_dust_enabled == FALSE) return; 
*
09596:  BTFSS  xA7.6
09598:  BRA    96C0
....................     
....................    // set the response flag 
....................    global_set_get_response = FALSE; 
0959A:  MOVLB  3
0959C:  BCF    x60.2
....................    // generate the message and send the message 
....................    pkgen_get_charge(); 
0959E:  MOVLW  02
095A0:  MOVLB  5
095A2:  MOVWF  x4C
095A4:  MOVLW  01
095A6:  MOVWF  x4D
095A8:  MOVLW  04
095AA:  MOVWF  x4E
095AC:  MOVLW  10
095AE:  MOVWF  x4F
095B0:  CLRF   x66
095B2:  CLRF   x65
095B4:  CLRF   x67
095B6:  MOVLW  05
095B8:  MOVWF  x69
095BA:  MOVLW  4C
095BC:  MOVWF  x68
095BE:  MOVLW  04
095C0:  MOVWF  x6A
095C2:  MOVLB  0
095C4:  CALL   606C
....................    result_byte = dust_hdlc_pksend(); 
095C8:  CALL   6316
095CC:  MOVFF  01,54B
....................    // set message timeout 
....................    setup_T0_int(T0_250MS); 
095D0:  MOVLW  FC
095D2:  MOVLB  5
095D4:  MOVWF  x69
095D6:  MOVLW  30
095D8:  MOVWF  x68
095DA:  MOVLB  0
095DC:  CALL   38C2
....................    while (!TMR0IF && !global_set_get_response && !result_byte); 
095E0:  BTFSC  FF2.2
095E2:  BRA    95FC
095E4:  MOVLB  3
095E6:  BTFSS  x60.2
095E8:  BRA    95EE
095EA:  MOVLB  0
095EC:  BRA    95FC
095EE:  MOVLB  5
095F0:  MOVF   x4B,F
095F2:  BTFSS  FD8.2
095F4:  BRA    95FA
095F6:  MOVLB  0
095F8:  BRA    95E0
095FA:  MOVLB  0
....................    // if the message fails, send an error message (kinda pointless though) 
....................    if (TMR0IF || result_byte) 
095FC:  BTFSC  FF2.2
095FE:  BRA    9608
09600:  MOVLB  5
09602:  MOVF   x4B,F
09604:  BZ    961E
09606:  MOVLB  0
....................    { 
....................       global_error_message_bitfield |= ERR_MOTE_UNRESPONSIVE; 
09608:  MOVLB  4
0960A:  BSF    xF8.2
....................       PUSH_MESSAGE_QUEUE_MACRO(MSG_MOTE_ERROR_MSG); 
0960C:  BCF    F7A.1
0960E:  MOVLW  A0
09610:  MOVLB  5
09612:  MOVWF  x54
09614:  MOVLB  0
09616:  CALL   51F6
0961A:  BSF    F7A.1
0961C:  MOVLB  5
....................    } 
....................     
....................    // if mote temp is outside of operating range, send an error message and queue up a shutdown 
....................    if ((global_mote_temperature < MOTE_MIN_TEMP_SHUTDOWN) || (global_mote_temperature > MOTE_MAX_TEMP_SHUTDOWN)) 
0961E:  MOVLB  3
09620:  MOVF   x6D,W
09622:  XORLW  80
09624:  SUBLW  57
09626:  BC    9632
09628:  BTFSC  x6D.7
0962A:  BRA    969A
0962C:  MOVF   x6D,W
0962E:  SUBLW  55
09630:  BC    969A
....................    { 
....................       // set message error bitfield and queue error message 
....................       global_error_message_bitfield |= (ERR_MSG_MOTE_TEMP_OUT_OF_RANGE | ERR_MSG_MOTE_GOING_TO_DEEP_SLEEP); 
09632:  MOVLB  4
09634:  BSF    xF8.6
09636:  BSF    xFB.7
....................       PUSH_MESSAGE_QUEUE_MACRO(MSG_MOTE_ERROR_MSG); 
09638:  BCF    F7A.1
0963A:  MOVLW  A0
0963C:  MOVLB  5
0963E:  MOVWF  x54
09640:  MOVLB  0
09642:  CALL   51F6
09646:  BSF    F7A.1
....................        
....................       // set the shutdown cause and schedule a shutdown 10 seconds later 
....................       PUSH_PRIORITY_QUEUE(OPEN_VALVE_UNKNOWN_STATE);   
09648:  MOVLW  3E
0964A:  MOVLB  5
0964C:  MOVWF  x52
0964E:  MOVLB  0
09650:  CALL   4748
....................       global_shutdown_cause = ERR_MOTE_OUT_OF_TEMP_RANGE; 
09654:  MOVLW  05
09656:  MOVWF  4D
....................       PUSH_TIME_QUEUE(global_rtc_time + 10, SHUTDOWN_SYSTEM); 
09658:  MOVLW  0A
0965A:  ADDWF  x85,W
0965C:  MOVLB  5
0965E:  MOVWF  x50
09660:  MOVLW  00
09662:  MOVLB  0
09664:  ADDWFC x86,W
09666:  MOVLB  5
09668:  MOVWF  x51
0966A:  MOVLW  00
0966C:  MOVLB  0
0966E:  ADDWFC x87,W
09670:  MOVLB  5
09672:  MOVWF  x52
09674:  MOVLW  00
09676:  MOVLB  0
09678:  ADDWFC x88,W
0967A:  MOVLB  5
0967C:  MOVWF  x53
0967E:  MOVWF  x59
09680:  MOVFF  552,558
09684:  MOVFF  551,557
09688:  MOVFF  550,556
0968C:  MOVLW  F1
0968E:  MOVWF  x5A
09690:  MOVLB  0
09692:  CALL   44A0
....................    } 
09696:  BRA    96C0
09698:  MOVLB  3
....................       // if mote temp is ALMOST outside of operating range, send an error message 
....................    else if ((global_mote_temperature < MOTE_MIN_TEMP_WARNING) || (global_mote_temperature > MOTE_MAX_TEMP_WARNING)) 
0969A:  MOVF   x6D,W
0969C:  XORLW  80
0969E:  SUBLW  5C
096A0:  BC    96AC
096A2:  BTFSC  x6D.7
096A4:  BRA    96C2
096A6:  MOVF   x6D,W
096A8:  SUBLW  50
096AA:  BC    96C2
....................    { 
....................       // set message error bitfield and queue error message 
....................       global_error_message_bitfield |= (ERR_MSG_MOTE_TEMP_OUT_OF_RANGE); 
096AC:  MOVLB  4
096AE:  BSF    xF8.6
....................       PUSH_MESSAGE_QUEUE_MACRO(MSG_MOTE_ERROR_MSG); 
096B0:  BCF    F7A.1
096B2:  MOVLW  A0
096B4:  MOVLB  5
096B6:  MOVWF  x54
096B8:  MOVLB  0
096BA:  CALL   51F6
096BE:  BSF    F7A.1
096C0:  MOVLB  3
....................    } 
096C2:  MOVLB  0
096C4:  GOTO   B1D4 (RETURN)
....................        
.................... } 
....................  
.................... void mote_time_update(void) 
.................... // queries the mote to for the utc time and update the micro's utc time 
.................... { 
....................    uint8_t result_byte; 
....................     
....................    // if the mote is not enabled/ready exit! 
....................    if (global_dust_enabled == FALSE) return; 
*
0935C:  BTFSS  xA7.6
0935E:  BRA    93E2
....................     
....................    // set the response flag 
....................    global_set_get_response = FALSE; 
09360:  MOVLB  3
09362:  BCF    x60.2
....................    // generate the message and send the message 
....................    pkgen_get_time(); 
09364:  MOVLW  02
09366:  MOVLB  5
09368:  MOVWF  x4C
0936A:  MOVLW  01
0936C:  MOVWF  x4D
0936E:  MOVLW  04
09370:  MOVWF  x4E
09372:  MOVLW  0F
09374:  MOVWF  x4F
09376:  CLRF   x66
09378:  CLRF   x65
0937A:  CLRF   x67
0937C:  MOVLW  05
0937E:  MOVWF  x69
09380:  MOVLW  4C
09382:  MOVWF  x68
09384:  MOVLW  04
09386:  MOVWF  x6A
09388:  MOVLB  0
0938A:  CALL   606C
....................    result_byte = dust_hdlc_pksend(); 
0938E:  CALL   6316
09392:  MOVFF  01,54B
....................    // set message timeout 
....................    setup_T0_int(T0_250MS); 
09396:  MOVLW  FC
09398:  MOVLB  5
0939A:  MOVWF  x69
0939C:  MOVLW  30
0939E:  MOVWF  x68
093A0:  MOVLB  0
093A2:  CALL   38C2
....................    while (!TMR0IF && !global_set_get_response && !result_byte); 
093A6:  BTFSC  FF2.2
093A8:  BRA    93C2
093AA:  MOVLB  3
093AC:  BTFSS  x60.2
093AE:  BRA    93B4
093B0:  MOVLB  0
093B2:  BRA    93C2
093B4:  MOVLB  5
093B6:  MOVF   x4B,F
093B8:  BTFSS  FD8.2
093BA:  BRA    93C0
093BC:  MOVLB  0
093BE:  BRA    93A6
093C0:  MOVLB  0
....................    // if the message fails, send an error message (kinda pointless though) 
....................    if (TMR0IF || result_byte) 
093C2:  BTFSC  FF2.2
093C4:  BRA    93CE
093C6:  MOVLB  5
093C8:  MOVF   x4B,F
093CA:  BZ    93E4
093CC:  MOVLB  0
....................    { 
....................       global_error_message_bitfield |= ERR_MOTE_UNRESPONSIVE; 
093CE:  MOVLB  4
093D0:  BSF    xF8.2
....................       PUSH_MESSAGE_QUEUE_MACRO(MSG_MOTE_ERROR_MSG); 
093D2:  BCF    F7A.1
093D4:  MOVLW  A0
093D6:  MOVLB  5
093D8:  MOVWF  x54
093DA:  MOVLB  0
093DC:  CALL   51F6
093E0:  BSF    F7A.1
093E2:  MOVLB  5
....................    }      
093E4:  MOVLB  0
093E6:  GOTO   B1D4 (RETURN)
.................... } 
....................  
.................... void get_mote_net_info(void) 
.................... // queries the mote to get the macaddress 
.................... { 
....................    uint8_t result_byte; 
....................     
....................    // if the mote is not enabled/ready exit! 
....................    if (global_dust_enabled == FALSE) return; 
093EA:  BTFSS  xA7.6
093EC:  BRA    9470
....................     
....................    // set the response flag 
....................    global_set_get_response = FALSE; 
093EE:  MOVLB  3
093F0:  BCF    x60.2
....................    // generate the message and send the message 
....................    pkgen_get_networkinfo(); 
093F2:  MOVLW  02
093F4:  MOVLB  5
093F6:  MOVWF  x4C
093F8:  MOVLW  01
093FA:  MOVWF  x4D
093FC:  MOVLW  04
093FE:  MOVWF  x4E
09400:  MOVLW  0D
09402:  MOVWF  x4F
09404:  CLRF   x66
09406:  CLRF   x65
09408:  CLRF   x67
0940A:  MOVLW  05
0940C:  MOVWF  x69
0940E:  MOVLW  4C
09410:  MOVWF  x68
09412:  MOVLW  04
09414:  MOVWF  x6A
09416:  MOVLB  0
09418:  CALL   606C
....................    result_byte = dust_hdlc_pksend(); 
0941C:  CALL   6316
09420:  MOVFF  01,54B
....................    // set message timeout 
....................    setup_T0_int(T0_250MS); 
09424:  MOVLW  FC
09426:  MOVLB  5
09428:  MOVWF  x69
0942A:  MOVLW  30
0942C:  MOVWF  x68
0942E:  MOVLB  0
09430:  CALL   38C2
....................    while (!TMR0IF && !global_set_get_response && !result_byte); 
09434:  BTFSC  FF2.2
09436:  BRA    9450
09438:  MOVLB  3
0943A:  BTFSS  x60.2
0943C:  BRA    9442
0943E:  MOVLB  0
09440:  BRA    9450
09442:  MOVLB  5
09444:  MOVF   x4B,F
09446:  BTFSS  FD8.2
09448:  BRA    944E
0944A:  MOVLB  0
0944C:  BRA    9434
0944E:  MOVLB  0
....................    // if the message fails, send an error message (kinda pointless though) 
....................    if (TMR0IF || result_byte) 
09450:  BTFSC  FF2.2
09452:  BRA    945C
09454:  MOVLB  5
09456:  MOVF   x4B,F
09458:  BZ    9472
0945A:  MOVLB  0
....................    { 
....................       global_error_message_bitfield |= ERR_MOTE_UNRESPONSIVE; 
0945C:  MOVLB  4
0945E:  BSF    xF8.2
....................       PUSH_MESSAGE_QUEUE_MACRO(MSG_MOTE_ERROR_MSG); 
09460:  BCF    F7A.1
09462:  MOVLW  A0
09464:  MOVLB  5
09466:  MOVWF  x54
09468:  MOVLB  0
0946A:  CALL   51F6
0946E:  BSF    F7A.1
09470:  MOVLB  5
....................    }      
09472:  MOVLB  0
09474:  GOTO   B1D4 (RETURN)
.................... } 
....................  
.................... void init_msgSEQ(void) 
.................... { 
....................    // uses the battery voltage and vgen to seed the random number generator 
....................    srand((get_vbatt(0)<<16) || get_vgen(0)); 
*
0444A:  MOVLB  5
0444C:  CLRF   x6A
0444E:  MOVLB  0
04450:  RCALL  42B4
04452:  MOVFF  02,54C
04456:  MOVFF  01,54B
0445A:  MOVLW  00
0445C:  CLRF   03
0445E:  IORWF  03,W
04460:  BNZ   4474
04462:  MOVLB  5
04464:  CLRF   x57
04466:  MOVLB  0
04468:  RCALL  430E
0446A:  MOVF   01,W
0446C:  IORWF  02,W
0446E:  BNZ   4474
04470:  MOVLW  00
04472:  BRA    4476
04474:  MOVLW  01
04476:  MOVLB  5
04478:  MOVWF  x4B
0447A:  CLRF   x4F
0447C:  CLRF   x4E
0447E:  CLRF   x4D
04480:  MOVWF  x4C
04482:  MOVLB  0
04484:  BRA    4370
....................    mote_msgSEQ = (uint16_t)rand(); 
04486:  BRA    43CA
04488:  MOVFF  02,366
0448C:  MOVFF  01,365
04490:  GOTO   4496 (RETURN)
.................... } 
....................  
.................... void deal_with_mote_ISR(void) 
*
01248:  MOVLB  5
0124A:  CLRF   xFF
0124C:  MOVLB  6
0124E:  BCF    x00.0
01250:  CLRF   x01
01252:  CLRF   x02
01254:  CLRF   x06
01256:  CLRF   x05
01258:  CLRF   x04
0125A:  CLRF   x03
0125C:  CLRF   x0A
0125E:  CLRF   x09
01260:  CLRF   x08
01262:  CLRF   x07
01264:  CLRF   x0E
01266:  CLRF   x0D
01268:  CLRF   x0C
0126A:  CLRF   x0B
0126C:  CLRF   x0F
.................... { 
....................    uint8_t     i; 
....................     
....................    uint16_t    tmp2u16; 
....................     
....................    uint8_t     cmd_rcvd = 0; 
....................    int1        send_ack = FALSE; 
....................     
....................    uint8_t     response_type = 0; 
....................    uint8_t     len_data_rcvd = 0; 
....................    uint32_t    utc_sec_rcvd = 0; 
....................    uint32_t    utc_usec_rcvd = 0; 
....................    uint32_t    new_events_rcvd = 0; 
....................     
....................    // bytes grabbed by get_dustmsg and sent to pkdecode 
....................    uint8_t      num_of_bytes_rcvd_from_mote = 0; 
....................  
....................    // Actually grab the message from the mote 
....................    // gets bytes rcvd(global), dust_recive_buffer, some errors 
....................    num_of_bytes_rcvd_from_mote = get_dustmsg_ISR(); 
0126E:  MOVLB  0
01270:  GOTO   0956
01274:  MOVFF  01,60F
....................     
....................    // Add error handling from get_dustmsg_ISR 
....................    // Send NACK? 
....................    
....................    //decodes the message and returns how many bytes were recived 
....................    dust_hdlc_pkdecode_ISR(num_of_bytes_rcvd_from_mote); 
01278:  MOVFF  60F,614
0127C:  BRA    0AE0
....................     
....................    // Add error handling from pkdecode 
....................    // Send NACK? 
....................     
....................    // get the command type 
....................    cmd_rcvd = bytes_from_mote.dust_rcvd[0];         
0127E:  MOVFF  D9,5FF
....................  
....................    // set these for CMD_TIME, _SERVICE, _EVENT, and _DATA 
....................    //   prefix_x[0] = cmd_rcvd; 
....................    //   prefix_x[1] = 0x00; 
....................    flags_rcvd = bytes_from_mote.dust_rcvd[2]; 
01282:  MOVFF  DB,362
....................  
....................    response_type = RC_OK; 
01286:  MOVLB  6
01288:  CLRF   x01
....................     
....................    //  
....................    if (cmd_rcvd == CMD_SET || cmd_rcvd == CMD_GET || \ 
....................        cmd_rcvd == CMD_SETNV || cmd_rcvd == CMD_GETNV || \ 
....................        cmd_rcvd == CMD_SEND || cmd_rcvd == CMD_JOIN || \ 
....................        cmd_rcvd == CMD_DISCONNECT || cmd_rcvd == CMD_RESET || \ 
....................        cmd_rcvd == CMD_SLEEP || cmd_rcvd == CMD_TESTRADIOTX || \ 
....................        cmd_rcvd == CMD_TESTRADIORX || cmd_rcvd == CMD_CLEARNV || \ 
....................        cmd_rcvd == CMD_SEARCH) 
0128A:  MOVLB  5
0128C:  DECFSZ xFF,W
0128E:  BRA    1292
01290:  BRA    12DA
01292:  MOVF   xFF,W
01294:  SUBLW  02
01296:  BZ    12DA
01298:  MOVF   xFF,W
0129A:  SUBLW  03
0129C:  BZ    12DA
0129E:  MOVF   xFF,W
012A0:  SUBLW  04
012A2:  BZ    12DA
012A4:  MOVF   xFF,W
012A6:  SUBLW  05
012A8:  BZ    12DA
012AA:  MOVF   xFF,W
012AC:  SUBLW  06
012AE:  BZ    12DA
012B0:  MOVF   xFF,W
012B2:  SUBLW  07
012B4:  BZ    12DA
012B6:  MOVF   xFF,W
012B8:  SUBLW  08
012BA:  BZ    12DA
012BC:  MOVF   xFF,W
012BE:  SUBLW  09
012C0:  BZ    12DA
012C2:  MOVF   xFF,W
012C4:  SUBLW  0B
012C6:  BZ    12DA
012C8:  MOVF   xFF,W
012CA:  SUBLW  0C
012CC:  BZ    12DA
012CE:  MOVF   xFF,W
012D0:  SUBLW  10
012D2:  BZ    12DA
012D4:  MOVF   xFF,W
012D6:  SUBLW  11
012D8:  BNZ   12DE
....................    { 
....................        // we are hoping that result_rcvd = RC_OK) 
....................        result_rcvd = bytes_from_mote.dust_rcvd[3]; 
012DA:  MOVFF  DC,35F
....................    }    
....................  
....................    // Determine parameter type and if the response was ok for set and get commands 
....................    if (cmd_rcvd == CMD_SET || cmd_rcvd == CMD_GET || \ 
....................        cmd_rcvd == CMD_SETNV || cmd_rcvd == CMD_GETNV) 
012DE:  DECFSZ xFF,W
012E0:  BRA    12E4
012E2:  BRA    12F6
012E4:  MOVF   xFF,W
012E6:  SUBLW  02
012E8:  BZ    12F6
012EA:  MOVF   xFF,W
012EC:  SUBLW  03
012EE:  BZ    12F6
012F0:  MOVF   xFF,W
012F2:  SUBLW  04
012F4:  BNZ   1304
....................    {      
....................        param_type_rcvd = bytes_from_mote.dust_rcvd[4]; 
012F6:  MOVFF  DD,363
....................        // this eliminates a bunch of flags for one response "ok" flag 
....................        if (result_rcvd == RC_OK) global_set_get_response = TRUE; 
012FA:  MOVLB  3
012FC:  MOVF   x5F,F
012FE:  BNZ   1302
01300:  BSF    x60.2
01302:  MOVLB  5
....................    } 
....................     
....................    // Main switch for all types of mote messages 
....................    switch (cmd_rcvd) 
01304:  MOVF   xFF,W
01306:  XORLW  01
01308:  MOVLB  0
0130A:  BZ    1372
0130C:  XORLW  03
0130E:  BZ    1384
01310:  XORLW  01
01312:  BTFSC  FD8.2
01314:  BRA    1524
01316:  XORLW  07
01318:  BTFSC  FD8.2
0131A:  BRA    1536
0131C:  XORLW  01
0131E:  BTFSC  FD8.2
01320:  BRA    15A2
01322:  XORLW  02
01324:  BTFSC  FD8.2
01326:  BRA    15A2
01328:  XORLW  0F
0132A:  BTFSC  FD8.2
0132C:  BRA    15A2
0132E:  XORLW  01
01330:  BTFSC  FD8.2
01332:  BRA    15A2
01334:  XORLW  02
01336:  BTFSC  FD8.2
01338:  BRA    15A2
0133A:  XORLW  07
0133C:  BTFSC  FD8.2
0133E:  BRA    15A2
01340:  XORLW  1C
01342:  BTFSC  FD8.2
01344:  BRA    15A2
01346:  XORLW  01
01348:  BTFSC  FD8.2
0134A:  BRA    15A4
0134C:  XORLW  17
0134E:  BTFSC  FD8.2
01350:  BRA    15B6
01352:  XORLW  0B
01354:  BTFSC  FD8.2
01356:  BRA    15CA
01358:  XORLW  03
0135A:  BTFSC  FD8.2
0135C:  BRA    1632
0135E:  XORLW  01
01360:  BTFSC  FD8.2
01362:  BRA    163E
01364:  XORLW  1D
01366:  BTFSC  FD8.2
01368:  BRA    16BC
0136A:  XORLW  93
0136C:  BTFSC  FD8.2
0136E:  BRA    16E8
01370:  BRA    1762
....................    {   
....................       // receipt of response after a SET command 
....................       case  CMD_SET: 
....................          // byte4 is the param_type for all SET responses 
....................          switch (param_type_rcvd) 
01372:  MOVLB  3
01374:  MOVF   x63,W
01376:  XORLW  06
01378:  MOVLB  0
0137A:  BZ    1382
0137C:  XORLW  0E
0137E:  BZ    1384
01380:  BRA    1384
....................          {   
....................             case  PARAM_JOINDUTY: 
....................                break; 
01382:  BRA    1384
....................             case  PARAM_SERVICE: 
....................                //    save info, no ack 
....................                //    rem_svc_entries_rcvd = \ 
....................                //    bytes_from_mote.set_service_response.rem_svc_entries; 
....................                break; 
....................             default:           
....................          } 
....................           
....................       // receipt of response after a GET command 
....................       case  CMD_GET: 
....................          // byte4 is the param_type for all GET responses 
....................          switch (param_type_rcvd) 
01384:  MOVLB  3
01386:  MOVF   x63,W
01388:  XORLW  08
0138A:  MOVLB  0
0138C:  BZ    13A8
0138E:  XORLW  04
01390:  BZ    13AE
01392:  XORLW  01
01394:  BZ    13F8
01396:  XORLW  03
01398:  BZ    145A
0139A:  XORLW  01
0139C:  BTFSC  FD8.2
0139E:  BRA    14BA
013A0:  XORLW  1F
013A2:  BTFSC  FD8.2
013A4:  BRA    1520
013A6:  BRA    1524
....................          {   
....................             case  PARAM_SERVICE: 
....................                svc_index_rcvd = bytes_from_mote.get_service_response.svc_index; 
013A8:  MOVFF  DE,364
....................                /* 
....................                svc_state_rcvd = bytes_from_mote.get_service_response.svc_state; 
....................                svc_flags_rcvd = bytes_from_mote.get_service_response.svc_flags; 
....................                app_domain_rcvd = \ 
....................                   bytes_from_mote.get_service_response.app_domain; 
....................                */ 
....................                //destaddr_rcvd = bytes_from_mote.get_service_response.destaddr; 
....................                //time_rcvd = bytes_from_mote.get_service_response.time; 
....................                break; 
013AC:  BRA    1524
....................  
....................             case  PARAM_MOTEINFO: 
....................                for (i=0; i<8; i++) 
013AE:  MOVLB  5
013B0:  CLRF   xFC
013B2:  MOVF   xFC,W
013B4:  SUBLW  07
013B6:  BNC   13F4
....................                   serial_number_rcvd[i] = \ 
....................                      bytes_from_mote.get_moteinfo_response.serial_number[i]; 
013B8:  CLRF   03
013BA:  MOVF   xFC,W
013BC:  ADDLW  97
013BE:  MOVWF  01
013C0:  MOVLW  00
013C2:  ADDWFC 03,F
013C4:  MOVFF  01,614
013C8:  MOVLB  6
013CA:  MOVFF  03,615
013CE:  CLRF   03
013D0:  MOVLB  5
013D2:  MOVF   xFC,W
013D4:  ADDLW  DF
013D6:  MOVWF  FE9
013D8:  MOVLW  00
013DA:  ADDWFC 03,W
013DC:  MOVWF  FEA
013DE:  MOVFF  FEF,616
013E2:  MOVFF  615,FEA
013E6:  MOVFF  01,FE9
013EA:  MOVFF  616,FEF
013EE:  MOVLB  5
013F0:  INCF   xFC,F
013F2:  BRA    13B2
....................                    
....................                /* 
....................                api_version_rcvd = \ 
....................                   bytes_from_mote.get_moteinfo_response.api_version; 
....................                hw_model_rcvd = bytes_from_mote.get_moteinfo_response.hw_model; 
....................                hw_version_rcvd = \ 
....................                   bytes_from_mote.get_moteinfo_response.hw_version; 
....................                sw_major_ver_rcvd = \ 
....................                   bytes_from_mote.get_moteinfo_response.sw_major_ver; 
....................                sw_minor_ver_rcvd = \ 
....................                   bytes_from_mote.get_moteinfo_response.sw_minor_ver; 
....................                sw_patch_rcvd = bytes_from_mote.get_moteinfo_response.sw_patch; 
....................                sw_build_rcvd = bytes_from_mote.get_moteinfo_response.sw_build; 
....................                */ 
....................                break; 
013F4:  MOVLB  0
013F6:  BRA    1524
....................  
....................             case  PARAM_NETWORKINFO: 
....................                for (i=0; i<8; i++) 
013F8:  MOVLB  5
013FA:  CLRF   xFC
013FC:  MOVF   xFC,W
013FE:  SUBLW  07
01400:  BNC   143E
....................                   macaddr_rcvd[i] = \ 
....................                      bytes_from_mote.get_networkinfo_response.macaddr[i]; 
01402:  CLRF   03
01404:  MOVF   xFC,W
01406:  ADDLW  9F
01408:  MOVWF  01
0140A:  MOVLW  00
0140C:  ADDWFC 03,F
0140E:  MOVFF  01,614
01412:  MOVLB  6
01414:  MOVFF  03,615
01418:  CLRF   03
0141A:  MOVLB  5
0141C:  MOVF   xFC,W
0141E:  ADDLW  DE
01420:  MOVWF  FE9
01422:  MOVLW  00
01424:  ADDWFC 03,W
01426:  MOVWF  FEA
01428:  MOVFF  FEF,616
0142C:  MOVFF  615,FEA
01430:  MOVFF  01,FE9
01434:  MOVFF  616,FEF
01438:  MOVLB  5
0143A:  INCF   xFC,F
0143C:  BRA    13FC
....................                mote_id_rcvd = bytes_from_mote.get_networkinfo_response.mote_id; 
0143E:  MOVFF  E7,36A
01442:  MOVFF  E6,369
....................                tmp2u16 = bytes_from_mote.get_networkinfo_response.network_id; 
01446:  MOVFF  E9,5FE
0144A:  MOVFF  E8,5FD
....................                network_id_rcvd = make16(make8(tmp2u16,0),make8(tmp2u16,1)); 
0144E:  MOVFF  5FD,368
01452:  MOVFF  5FE,367
....................  
....................                break; 
01456:  MOVLB  0
01458:  BRA    1524
....................  
....................             case  PARAM_MOTESTATUS: 
....................                global_mote_state = bytes_from_mote.get_motestatus_response.mote_state; 
0145A:  MOVFF  DE,504
....................                 
....................                // this is where I decide if the mote is alive or not 
....................                global_dust_enabled = TRUE; 
0145E:  BSF    xA7.6
....................                 
....................                // If the mote isn't fully connected (operational) set the global 
....................                //    dust operational bit to false 
....................                if (global_mote_state != MOTESTATE_OPERATIONAL) 
01460:  MOVLB  5
01462:  MOVF   x04,W
01464:  SUBLW  05
01466:  BZ    1470
....................                { 
....................                   global_dust_operational = FALSE; 
01468:  MOVLB  0
0146A:  BCF    xA7.7
....................                } 
0146C:  BRA    14B8
0146E:  MOVLB  5
....................                // If the mote is fully connected... 
....................                else  
....................                { 
....................                   // and it wasn't before... 
....................                   if (global_dust_operational == FALSE) 
01470:  MOVLB  0
01472:  BTFSC  xA7.7
01474:  BRA    14B8
....................                   { 
....................   
....................                      // set it to be connected and send a join message! 
....................                      global_dust_operational = TRUE; 
01476:  BSF    xA7.7
....................                      PUSH_MESSAGE_QUEUE_ISR_MACRO(MSG_MOTE_JOIN_MSG); 
01478:  BCF    F7A.1
0147A:  MOVLW  94
0147C:  MOVLB  6
0147E:  MOVWF  x14
01480:  MOVLB  0
01482:  CALL   0C26
01486:  BSF    F7A.1
01488:  CLRF   19
0148A:  BTFSC  FF2.7
0148C:  BSF    19.7
0148E:  BCF    FF2.7
....................                      PUSH_PRIORITY_QUEUE_ISR_MACRO(UPDATE_MOTE_TIME); 
01490:  MOVLW  A3
01492:  MOVLB  6
01494:  MOVWF  x2C
01496:  MOVLB  0
01498:  CALL   082A
0149C:  BTFSC  19.7
0149E:  BSF    FF2.7
014A0:  CLRF   19
014A2:  BTFSC  FF2.7
014A4:  BSF    19.7
014A6:  BCF    FF2.7
....................                      PUSH_PRIORITY_QUEUE_ISR_MACRO(CHECK_MOTE_TEMP); 
014A8:  MOVLW  A2
014AA:  MOVLB  6
014AC:  MOVWF  x2C
014AE:  MOVLB  0
014B0:  CALL   082A
014B4:  BTFSC  19.7
014B6:  BSF    FF2.7
....................                   } 
....................                }    
....................                //mote_alarms_rcvd = \ 
....................                //   bytes_from_mote.get_motestatus_response.mote_alarms; 
.................... /* 
....................                change_counter_rcvd = \ 
....................                   bytes_from_mote.get_motestatus_response.change_counter; 
....................                number_of_parents_rcvd = \ 
....................                   bytes_from_mote.get_motestatus_response.number_of_parents; 
.................... */ 
....................                break; 
014B8:  BRA    1524
....................  
....................             case  PARAM_TIME: 
....................                utc_sec_rcvd = bytes_from_mote.get_time_response.utc_sec; 
014BA:  MOVFF  E1,606
014BE:  MOVFF  E0,605
014C2:  MOVFF  DF,604
014C6:  MOVFF  DE,603
....................                // JG: save first utc time reported from mote since boot 
....................                if (!global_utc_time) 
014CA:  MOVF   x89,F
014CC:  BNZ   14EA
014CE:  MOVF   x8A,F
014D0:  BNZ   14EA
014D2:  MOVF   x8B,F
014D4:  BNZ   14EA
014D6:  MOVF   x8C,F
014D8:  BNZ   14EA
....................                { 
....................                   global_first_utc_time = make32(make8(utc_sec_rcvd,0), \ 
....................                    make8(utc_sec_rcvd,1), make8(utc_sec_rcvd,2), \ 
....................                    make8(utc_sec_rcvd,3));     //  **fix byte order** 
014DA:  MOVFF  603,90
014DE:  MOVFF  604,8F
014E2:  MOVFF  605,8E
014E6:  MOVFF  606,8D
....................                } 
....................                 
....................                global_utc_time = make32(make8(utc_sec_rcvd,0), \ 
....................                 make8(utc_sec_rcvd,1), make8(utc_sec_rcvd,2), \ 
....................                 make8(utc_sec_rcvd,3));     //  **fix byte order** 
014EA:  MOVFF  603,8C
014EE:  MOVFF  604,8B
014F2:  MOVFF  605,8A
014F6:  MOVFF  606,89
....................                               
....................                utc_usec_rcvd = bytes_from_mote.get_time_response.utc_usec; 
014FA:  MOVFF  E5,60A
014FE:  MOVFF  E4,609
01502:  MOVFF  E3,608
01506:  MOVFF  E2,607
....................                if (mote_msgSEQ == 0) 
0150A:  MOVLB  3
0150C:  MOVF   x65,F
0150E:  BNZ   151C
01510:  MOVF   x66,F
01512:  BNZ   151C
....................                { 
....................                   mote_msgSEQ = make16(make8(utc_usec_rcvd,2), \                   
....................                      make8(utc_usec_rcvd,3)); 
01514:  MOVFF  609,366
01518:  MOVFF  60A,365
....................                } 
....................                // This value is used to establish a "random" value for  
....................                //  the mote message Sequence ID 
.................... /*                
....................                for (i=0; i<5; i++) 
....................                   asn_rcvd[i] = bytes_from_mote.get_time_response.asn[i]; 
....................                asn_offset_rcvd = bytes_from_mote.get_time_response.asn_offset; 
.................... */                
....................                break; 
0151C:  MOVLB  0
0151E:  BRA    1524
....................  
....................             case  PARAM_CHARGE: 
....................                //charge_mC_rcvd = bytes_from_mote.get_charge_response.charge_mC; 
....................                //uptime_sec_rcvd = bytes_from_mote.get_charge_response.uptime_sec; 
....................                global_mote_temperature = \ 
....................                   bytes_from_mote.get_charge_response.temp_celsius; 
01520:  MOVFF  E6,36D
....................                //temp_frac_celsius_rcvd = \ 
....................                //   bytes_from_mote.get_charge_response.temp_frac_celsius; 
....................                break; 
.................... /* 
....................             case  PARAM_RADIOSTATSRX: 
....................                num_of_received_packets_rcvd = \ 
....................                   bytes_from_mote.get_testrx_response.num_of_received_packets; 
....................                num_of_recep_failures = \ 
....................                   bytes_from_mote.get_testrx_response.num_of_recep_failures; 
....................                break; 
.................... */ 
....................             default: 
....................          } 
....................  
....................       case  CMD_SETNV: 
....................       // receipt of response after a SETNV command 
....................           switch (param_type_rcvd) 
01524:  MOVLB  3
01526:  MOVF   x63,W
01528:  XORLW  02
0152A:  MOVLB  0
0152C:  BZ    1534
0152E:  XORLW  01
01530:  BZ    1536
01532:  BRA    1536
....................          {  // byte4 is the param_type for all SETNV responses 
....................             /* 
....................             case PARAM_MACADDR: case  PARAM_TXPOWER: \ 
....................             case  PARAM_POWERINFO: case  PARAM_OTAPLOCK: \ 
....................             case PARAM_SPECIAL1: case PARAM_SPECIAL2: 
....................                break; 
....................             */ 
....................             case PARAM_JOINKEY:  
....................                break; 
01534:  BRA    1536
....................             case  PARAM_NETWORKID:  
....................                break; 
....................             default: 
....................          } 
....................  
....................       case  CMD_GETNV: 
....................       // receipt of response after a GETNV command 
....................          switch (param_type_rcvd) 
01536:  MOVLB  3
01538:  MOVF   x63,W
0153A:  XORLW  01
0153C:  MOVLB  0
0153E:  BZ    1546
01540:  XORLW  02
01542:  BZ    158E
01544:  BRA    15A2
....................          {  // byte4 is the param_type for all GETNV responses 
....................             case  PARAM_MACADDR: 
....................                for (i=0; i<8; i++) 
01546:  MOVLB  5
01548:  CLRF   xFC
0154A:  MOVF   xFC,W
0154C:  SUBLW  07
0154E:  BNC   158C
....................                   macaddr_rcvd[i] = \ 
....................                      bytes_from_mote.getNV_macaddr_response.macaddr[i]; 
01550:  CLRF   03
01552:  MOVF   xFC,W
01554:  ADDLW  9F
01556:  MOVWF  01
01558:  MOVLW  00
0155A:  ADDWFC 03,F
0155C:  MOVFF  01,614
01560:  MOVLB  6
01562:  MOVFF  03,615
01566:  CLRF   03
01568:  MOVLB  5
0156A:  MOVF   xFC,W
0156C:  ADDLW  DE
0156E:  MOVWF  FE9
01570:  MOVLW  00
01572:  ADDWFC 03,W
01574:  MOVWF  FEA
01576:  MOVFF  FEF,616
0157A:  MOVFF  615,FEA
0157E:  MOVFF  01,FE9
01582:  MOVFF  616,FEF
01586:  MOVLB  5
01588:  INCF   xFC,F
0158A:  BRA    154A
....................                break; 
0158C:  BRA    15A0
....................  
....................             case  PARAM_NETWORKID: 
....................                tmp2u16 = bytes_from_mote.getNV_networkid_response.network_id; 
0158E:  MOVFF  DF,5FE
01592:  MOVFF  DE,5FD
....................                network_id_rcvd = make16(make8(tmp2u16,0),make8(tmp2u16,1)); 
01596:  MOVFF  5FD,368
0159A:  MOVFF  5FE,367
....................                break; 
0159E:  MOVLB  5
015A0:  MOVLB  0
....................  
....................             default: 
....................           } 
....................  
....................       case  CMD_SEND:         case  CMD_DISCONNECT: \ 
....................       case  CMD_RESET:        case  CMD_SLEEP:     case  CMD_TESTRADIOTX: \ 
....................       case  CMD_TESTRADIORX:  case  CMD_CLEARNV: 
....................          // info saved above; receipt of response after any of the 
....................          // the above; no ack 
....................          break; 
015A2:  BRA    1762
....................       case CMD_SEARCH: 
....................          if (result_rcvd == RC_OK) 
015A4:  MOVLB  3
015A6:  MOVF   x5F,F
015A8:  BNZ   15B2
....................          { 
....................             global_mote_state= MOTESTATE_SEARCHING; 
015AA:  MOVLW  02
015AC:  MOVLB  5
015AE:  MOVWF  x04
015B0:  MOVLB  3
....................          } 
....................          break; 
015B2:  MOVLB  0
015B4:  BRA    1762
....................       case CMD_JOIN: 
....................          if (result_rcvd == RC_OK) 
015B6:  MOVLB  3
015B8:  MOVF   x5F,F
015BA:  BNZ   15C4
....................             global_mote_state = MOTESTATE_NEGOTIATING; 
015BC:  MOVLW  03
015BE:  MOVLB  5
015C0:  MOVWF  x04
015C2:  MOVLB  3
....................             joincmd_done_fl = TRUE; 
015C4:  BSF    x61.3
....................          break; 
015C6:  MOVLB  0
015C8:  BRA    1762
....................  
....................       case  CMD_TIME: 
....................       // receipt of response after a _TIME hardware interrupt 
....................          utc_sec_rcvd = bytes_from_mote.time_indication.utc_sec; 
015CA:  MOVFF  DF,606
015CE:  MOVFF  DE,605
015D2:  MOVFF  DD,604
015D6:  MOVFF  DC,603
....................           
....................          // JG: save first utc time reported from mote since boot 
....................          if (!global_utc_time) 
015DA:  MOVF   x89,F
015DC:  BNZ   15FA
015DE:  MOVF   x8A,F
015E0:  BNZ   15FA
015E2:  MOVF   x8B,F
015E4:  BNZ   15FA
015E6:  MOVF   x8C,F
015E8:  BNZ   15FA
....................          { 
....................             global_first_utc_time = make32(make8(utc_sec_rcvd,0), \ 
....................              make8(utc_sec_rcvd,1), make8(utc_sec_rcvd,2), \ 
....................              make8(utc_sec_rcvd,3));     //  **fix byte order** 
015EA:  MOVFF  603,90
015EE:  MOVFF  604,8F
015F2:  MOVFF  605,8E
015F6:  MOVFF  606,8D
....................          } 
....................  
....................          global_utc_time = make32(make8(utc_sec_rcvd,0), \ 
....................           make8(utc_sec_rcvd,1), make8(utc_sec_rcvd,2), \ 
....................           make8(utc_sec_rcvd,3));     //  **fix byte order** 
015FA:  MOVFF  603,8C
015FE:  MOVFF  604,8B
01602:  MOVFF  605,8A
01606:  MOVFF  606,89
....................          utc_usec_rcvd = bytes_from_mote.time_indication.utc_usec; 
0160A:  MOVFF  E3,60A
0160E:  MOVFF  E2,609
01612:  MOVFF  E1,608
01616:  MOVFF  E0,607
....................          if (!mote_msgSEQ) 
0161A:  MOVLB  3
0161C:  MOVF   x65,W
0161E:  IORWF  x66,W
01620:  BNZ   162A
....................          { 
....................             mote_msgSEQ = make16(make8(utc_usec_rcvd,2), \                   
....................                make8(utc_usec_rcvd,3)); 
01622:  MOVFF  609,366
01626:  MOVFF  60A,365
....................          } 
....................  
....................          /* 
....................          for (i=0; i<5; i++) 
....................             asn_rcvd[i] = bytes_from_mote.time_indication.asn[i]; 
....................          asn_offset_rcvd = bytes_from_mote.time_indication.asn_offset; 
....................          */ 
....................  
.................... //         dust_hdlc_pkgen(prefix_x, 2, (uint8_t*)&r_x, 2);   // type A 
....................          send_ack = TRUE; 
0162A:  MOVLB  6
0162C:  BSF    x00.0
....................          break; 
0162E:  MOVLB  0
01630:  BRA    1762
....................  
....................       case  CMD_SERVICE: 
....................       // receipt of a service indication from from manager 
....................          //event_code_rcvd = bytes_from_mote.service_indication.event_code; 
....................          svc_index_rcvd = bytes_from_mote.service_indication.svc_index; 
01632:  MOVFF  DE,364
....................          /* 
....................          mgr_code_rcvd = bytes_from_mote.service_indication.mgr_code; 
....................          svc_state_rcvd = bytes_from_mote.service_indication.svc_state; 
....................          svc_flags_rcvd = bytes_from_mote.service_indication.svc_flags; 
....................          app_domain_rcvd = bytes_from_mote.service_indication.app_domain; 
....................          */ 
....................          //destaddr_rcvd = bytes_from_mote.service_indication.destaddr; 
....................          //time_rcvd = bytes_from_mote.service_indication.time; 
....................  
....................  //        dust_hdlc_pkgen(prefix_x, 2, (uint8_t*)&r_x, 2);   // type A 
....................  
....................          send_ack = TRUE; 
01636:  MOVLB  6
01638:  BSF    x00.0
....................          break; 
0163A:  MOVLB  0
0163C:  BRA    1762
....................  
....................       case  CMD_EVENT: 
....................       // receipt of an event indication from the mote 
....................          // this is where I decide if the mote is alive or not 
....................          global_dust_enabled = TRUE; 
0163E:  BSF    xA7.6
....................           
....................          new_events_rcvd = bytes_from_mote.events_indication.new_events; 
01640:  MOVFF  DF,60E
01644:  MOVFF  DE,60D
01648:  MOVFF  DD,60C
0164C:  MOVFF  DC,60B
....................          global_mote_state = bytes_from_mote.events_indication.mote_state; 
01650:  MOVFF  E0,504
....................           
....................          // If the mote isn't fully connected (operational) set the global 
....................          //    dust operational bit to false 
....................          if (global_mote_state != MOTESTATE_OPERATIONAL) 
01654:  MOVLB  5
01656:  MOVF   x04,W
01658:  SUBLW  05
0165A:  BZ    1664
....................          { 
....................             global_dust_operational = FALSE; 
0165C:  MOVLB  0
0165E:  BCF    xA7.7
....................          } 
01660:  BRA    16AC
01662:  MOVLB  5
....................          // If the mote is fully connected... 
....................          else  
....................          {                                
....................             // and it wasn't before... 
....................             if (global_dust_operational == FALSE) 
01664:  MOVLB  0
01666:  BTFSC  xA7.7
01668:  BRA    16AC
....................             { 
....................                // set it to be connected and send a join message! 
....................                global_dust_operational = TRUE; 
0166A:  BSF    xA7.7
....................                PUSH_MESSAGE_QUEUE_ISR_MACRO(MSG_MOTE_JOIN_MSG); 
0166C:  BCF    F7A.1
0166E:  MOVLW  94
01670:  MOVLB  6
01672:  MOVWF  x14
01674:  MOVLB  0
01676:  CALL   0C26
0167A:  BSF    F7A.1
0167C:  CLRF   19
0167E:  BTFSC  FF2.7
01680:  BSF    19.7
01682:  BCF    FF2.7
....................                                              
....................                PUSH_PRIORITY_QUEUE_ISR_MACRO(UPDATE_MOTE_TIME); 
01684:  MOVLW  A3
01686:  MOVLB  6
01688:  MOVWF  x2C
0168A:  MOVLB  0
0168C:  CALL   082A
01690:  BTFSC  19.7
01692:  BSF    FF2.7
01694:  CLRF   19
01696:  BTFSC  FF2.7
01698:  BSF    19.7
0169A:  BCF    FF2.7
....................                PUSH_PRIORITY_QUEUE_ISR_MACRO(CHECK_MOTE_TEMP);    
0169C:  MOVLW  A2
0169E:  MOVLB  6
016A0:  MOVWF  x2C
016A2:  MOVLB  0
016A4:  CALL   082A
016A8:  BTFSC  19.7
016AA:  BSF    FF2.7
....................             } 
....................          } 
....................          //mote_alarms_rcvd = bytes_from_mote.events_indication.mote_alarms; 
....................  
....................          event_flags |= make8(new_events_rcvd,3);  // only last byte has 
016AC:  MOVLB  6
016AE:  MOVF   x0E,W
016B0:  MOVLB  0
016B2:  IORWF  xD8,F
....................          // defined events for Eterna 
....................     
....................          send_ack = TRUE;           
016B4:  MOVLB  6
016B6:  BSF    x00.0
....................          break; 
016B8:  MOVLB  0
016BA:  BRA    1762
....................  
....................       case  CMD_ADVERT: 
....................       // receipt of an event indication from the mote 
....................          tmp2u16 = bytes_from_mote.advert_indication.network_id; 
016BC:  MOVFF  DD,5FE
016C0:  MOVFF  DC,5FD
....................          network_id_rcvd = make16(make8(tmp2u16,0),make8(tmp2u16,1)); 
016C4:  MOVFF  5FD,368
016C8:  MOVFF  5FE,367
....................          mote_id_rcvd = bytes_from_mote.advert_indication.mote_id; 
016CC:  MOVFF  DF,36A
016D0:  MOVFF  DE,369
....................           
....................          rssi_rcvd = bytes_from_mote.advert_indication.rssi; 
016D4:  MOVFF  E0,36B
....................          hop_depth_rcvd = bytes_from_mote.advert_indication.hop_depth; 
016D8:  MOVFF  E1,36C
....................           
....................          advert_rcvd_fl = TRUE; 
016DC:  MOVLB  3
016DE:  BSF    x60.3
....................    //      dust_hdlc_pkgen(prefix_x, 2, (uint8_t*)&r_x, 2);   // type A 
....................  
....................          send_ack = TRUE; 
016E0:  MOVLB  6
016E2:  BSF    x00.0
....................          break; 
016E4:  MOVLB  0
016E6:  BRA    1762
....................  
....................       case  CMD_DATA: 
....................       // receipt of a data packet payload from the manager 
....................          //sourceaddr_rcvd = bytes_from_mote.data_from_net.sourceaddr; 
....................          //sequence_num_rcvd = bytes_from_mote.data_from_net.sequence_num; 
....................          len_data_rcvd = bytes_from_mote.data_from_net.len_data; 
016E8:  MOVFF  DF,602
....................  
....................          if (len_data_rcvd <= MAX_USER_DATA_SIZE) 
016EC:  MOVLB  6
016EE:  MOVF   x02,W
016F0:  SUBLW  5E
016F2:  BNC   1742
....................          { 
....................             for (i=0; i<len_data_rcvd; i++) 
016F4:  MOVLB  5
016F6:  CLRF   xFC
016F8:  MOVLB  6
016FA:  MOVF   x02,W
016FC:  MOVLB  5
016FE:  SUBWF  xFC,W
01700:  BC    173E
....................               payload_buff[i] = bytes_from_mote.data_from_net.data[i]; 
01702:  CLRF   03
01704:  MOVF   xFC,W
01706:  ADDLW  F3
01708:  MOVWF  01
0170A:  MOVLW  02
0170C:  ADDWFC 03,F
0170E:  MOVFF  01,614
01712:  MOVLB  6
01714:  MOVFF  03,615
01718:  CLRF   03
0171A:  MOVLB  5
0171C:  MOVF   xFC,W
0171E:  ADDLW  E0
01720:  MOVWF  FE9
01722:  MOVLW  00
01724:  ADDWFC 03,W
01726:  MOVWF  FEA
01728:  MOVFF  FEF,616
0172C:  MOVFF  615,FEA
01730:  MOVFF  01,FE9
01734:  MOVFF  616,FEF
01738:  MOVLB  5
0173A:  INCF   xFC,F
0173C:  BRA    16F8
....................          } 
0173E:  BRA    1748
01740:  MOVLB  6
....................          else 
....................          {     
....................             response_type = RC_INVALID_LEN; 
01742:  MOVLW  04
01744:  MOVWF  x01
01746:  MOVLB  5
....................          } 
....................           
....................          send_ack = TRUE; 
01748:  MOVLB  6
0174A:  BSF    x00.0
0174C:  CLRF   19
0174E:  BTFSC  FF2.7
01750:  BSF    19.7
01752:  BCF    FF2.7
....................  
....................          PUSH_PRIORITY_QUEUE_ISR_MACRO(DEAL_WITH_NEW_PACKET)          
01754:  MOVLW  20
01756:  MOVWF  x2C
01758:  MOVLB  0
0175A:  CALL   082A
0175E:  BTFSC  19.7
01760:  BSF    FF2.7
....................          break; 
....................  
....................       default: 
....................    } 
....................  
....................    // Send acks for appropriate messages 
....................     if (send_ack) 
01762:  MOVLB  6
01764:  BTFSS  x00.0
01766:  BRA    17CC
....................    { 
....................       // generates the dust message 
....................       uint8_t pkgen_buf[2], cmd_rcvd_buf[2]; 
....................       pkgen_buf[0] = (flags_rcvd+1); 
01768:  MOVLW  01
0176A:  MOVLB  3
0176C:  ADDWF  x62,W
0176E:  MOVLB  6
01770:  MOVWF  x10
....................       pkgen_buf[1] = response_type; 
01772:  MOVFF  601,611
....................       cmd_rcvd_buf[0] = cmd_rcvd; 
01776:  MOVFF  5FF,612
....................       cmd_rcvd_buf[1] = 0; 
0177A:  CLRF   x13
....................        
....................       dust_hdlc_pkgen_ISR(cmd_rcvd_buf, 2, pkgen_buf , 2); 
0177C:  MOVLW  06
0177E:  MOVWF  x15
01780:  MOVLW  12
01782:  MOVWF  x14
01784:  MOVLW  02
01786:  MOVWF  x16
01788:  MOVLW  06
0178A:  MOVWF  x18
0178C:  MOVLW  10
0178E:  MOVWF  x17
01790:  MOVLW  02
01792:  MOVWF  x19
01794:  MOVLB  0
01796:  CALL   0EE4
....................        
....................       // try 3 times to send the ack 
....................       for (i = 0; i < 3; i++) 
0179A:  MOVLB  5
0179C:  CLRF   xFC
0179E:  MOVF   xFC,W
017A0:  SUBLW  02
017A2:  BNC   17CA
....................       { 
....................          // successful ack send 
....................          if (dust_hdlc_pksend_ISR() == NO_ERR)  
017A4:  MOVLB  0
017A6:  RCALL  11A6
017A8:  MOVF   01,F
017AA:  BNZ   17B4
....................          { 
....................             break; 
017AC:  MOVLB  5
017AE:  BRA    17CA
....................          } 
017B0:  BRA    17C6
017B2:  MOVLB  0
....................          // wait 50ms and try again 
....................          else 
....................          { 
....................             setup_T4_int(T4_50MS); 
017B4:  MOVLW  C7
017B6:  MOVLB  6
017B8:  MOVWF  x19
017BA:  MOVLB  0
017BC:  CALL   0944
....................             while(!TMR4IF);     
017C0:  BTFSS  F7E.0
017C2:  BRA    17C0
017C4:  MOVLB  5
....................          } 
017C6:  INCF   xFC,F
017C8:  BRA    179E
017CA:  MOVLB  6
....................        
....................       // Add error handling if no ack (not sure how) 
....................       } 
....................    } 
017CC:  MOVLB  0
017CE:  GOTO   17EA (RETURN)
.................... } 
....................  
....................  
.................... uint8_t get_dustmsg_ISR(void) 
*
00956:  MOVLB  6
00958:  CLRF   x14
.................... { 
.................... // After being prompted by a hardware interrupts on the UART lines 
.................... // this routine is called to actually collect the serial data and  
.................... // store it in dust_recive_buffer 
.................... // 
.................... // Returns the number of chars collected (1 char = 1 not 0) or some error code 
.................... // Error Codes: 
.................... // -ERR_GET_DUSTMSG_MESSAGE_LENGTH  
.................... // -ERR_GET_DUSTMSG_FRAMING_ERROR 
....................  
.................... //  When the hardware UART is specified by #use rs232(): 
.................... //  RS232_ERRORS is used only by the getc() function. 
.................... //  RS232_ERRORS is a copy of the RCSTA register except 
.................... //  that Bit 0 is used to indicate a parity error. 
.................... //  RS232 Errors are not yet implemented 
....................  
....................    uint8_t     bytes_rcvd = 0; 
....................     
....................    // Start the UART and pause for initialization 
....................    setup_uart(TRUE);           
0095A:  BSF    FAB.7
0095C:  BSF    FAB.4
0095E:  BSF    FAC.5
....................    setup_T4_int(T4_500US); 
00960:  MOVLW  01
00962:  MOVWF  x19
00964:  MOVLB  0
00966:  RCALL  0944
....................    while(!TMR4IF);        
00968:  BTFSS  F7E.0
0096A:  BRA    0968
....................     
....................    // recieve up to MAX_RCV_BUFFER  
....................    for (bytes_rcvd = 0; bytes_rcvd < MAX_RCV_BUFFER; bytes_rcvd++) 
0096C:  MOVLB  6
0096E:  CLRF   x14
00970:  MOVF   x14,W
00972:  SUBLW  C9
00974:  BNC   09CC
....................    { 
....................       // clear to send a byte 
....................       output_low(MOTE_TX_CTSn);  
00976:  BCF    F89.5
....................        
....................       // setup individual byte timeout and wait for next char 
....................       setup_T4_int(T0_10MS);    
00978:  MOVLW  D9
0097A:  MOVWF  x19
0097C:  MOVLB  0
0097E:  RCALL  0944
....................       while (!kbhit() && !TMR4IF);  
00980:  BTFSC  F9E.5
00982:  BRA    0988
00984:  BTFSS  F7E.0
00986:  BRA    0980
....................        
....................       // not clear to send the next byte until we process this one 
....................       output_high(MOTE_TX_CTSn); 
00988:  BSF    F89.5
....................        
....................       // return error on byte timeout 
....................       if (TMR4IF)  
0098A:  BTFSS  F7E.0
0098C:  BRA    099A
....................       { 
....................          setup_uart(FALSE);  
0098E:  BCF    FAB.7
00990:  BCF    FAB.4
00992:  BCF    FAC.5
....................          return ERR_DUSTMSG_TIMEOUT; 
00994:  MOVLW  FC
00996:  MOVWF  01
00998:  BRA    0A3C
....................       } 
....................        
....................       // grab the byte from the receive register 
....................       dust_recive_buffer[bytes_rcvd] = RCREG1;         
0099A:  CLRF   03
0099C:  MOVLB  6
0099E:  MOVF   x14,W
009A0:  ADDLW  28
009A2:  MOVWF  FE9
009A4:  MOVLW  02
009A6:  ADDWFC 03,W
009A8:  MOVWF  FEA
009AA:  MOVFF  FAE,FEF
....................        
....................       // done with getting message, break out of loop 
....................       if ((dust_recive_buffer[bytes_rcvd] == FLAG_SEQUENCE) && (bytes_rcvd != 0)) 
009AE:  CLRF   03
009B0:  MOVF   x14,W
009B2:  ADDLW  28
009B4:  MOVWF  FE9
009B6:  MOVLW  02
009B8:  ADDWFC 03,W
009BA:  MOVWF  FEA
009BC:  MOVF   FEF,W
009BE:  SUBLW  7E
009C0:  BNZ   09C8
009C2:  MOVF   x14,F
009C4:  BZ    09C8
....................       { 
....................          break;          
009C6:  BRA    09CC
....................       }  
009C8:  INCF   x14,F
009CA:  BRA    0970
....................    } 
....................      
....................    // after the message is done, stop the uart 
....................    setup_uart(FALSE);  
009CC:  BCF    FAB.7
009CE:  BCF    FAB.4
009D0:  BCF    FAC.5
....................     
....................    // Check for errors 
....................    // at this point only possible errors are framing and message length 
....................    // Too long of a message (no ending flag sequence) 
....................    if ((bytes_rcvd == MAX_RCV_BUFFER) && (dust_recive_buffer[bytes_rcvd] != FLAG_SEQUENCE)) 
009D2:  MOVF   x14,W
009D4:  SUBLW  CA
009D6:  BNZ   09F8
009D8:  CLRF   03
009DA:  MOVF   x14,W
009DC:  ADDLW  28
009DE:  MOVWF  FE9
009E0:  MOVLW  02
009E2:  ADDWFC 03,W
009E4:  MOVWF  FEA
009E6:  MOVF   FEF,W
009E8:  SUBLW  7E
009EA:  BZ    09F8
....................    { 
....................       return ERR_DUSTMSG_MESSAGE_LENGTH; 
009EC:  MOVLW  FF
009EE:  MOVWF  01
009F0:  MOVLB  0
009F2:  BRA    0A3C
....................    } 
009F4:  BRA    0A3C
009F6:  MOVLB  6
....................    // Too small of a message, return error code 
....................    else if (bytes_rcvd < 5) 
009F8:  MOVF   x14,W
009FA:  SUBLW  04
009FC:  BNC   0A08
....................    { 
....................       return ERR_DUSTMSG_MESSAGE_LENGTH; 
009FE:  MOVLW  FF
00A00:  MOVWF  01
00A02:  MOVLB  0
00A04:  BRA    0A3C
....................    } 
00A06:  BRA    0A3C
....................    // Framing error, return error code 
....................    else if ((dust_recive_buffer[0] != FLAG_SEQUENCE) || (dust_recive_buffer[bytes_rcvd] != FLAG_SEQUENCE)) 
00A08:  MOVLB  2
00A0A:  MOVF   x28,W
00A0C:  SUBLW  7E
00A0E:  BNZ   0A28
00A10:  CLRF   03
00A12:  MOVLB  6
00A14:  MOVF   x14,W
00A16:  ADDLW  28
00A18:  MOVWF  FE9
00A1A:  MOVLW  02
00A1C:  ADDWFC 03,W
00A1E:  MOVWF  FEA
00A20:  MOVF   FEF,W
00A22:  SUBLW  7E
00A24:  BZ    0A34
00A26:  MOVLB  2
....................    { 
....................       return ERR_DUSTMSG_FRAMING_ERROR; 
00A28:  MOVLW  FE
00A2A:  MOVWF  01
00A2C:  MOVLB  0
00A2E:  BRA    0A3C
....................    } 
00A30:  BRA    0A3C
00A32:  MOVLB  6
....................    // all is well, exit normally 
....................    else 
....................    {           
....................       // return how many bytes recieved in actual (starting at 1) number       
....................       return (bytes_rcvd + 1); 
00A34:  MOVLW  01
00A36:  ADDWF  x14,W
00A38:  MOVWF  01
00A3A:  MOVLB  0
....................    } 
00A3C:  GOTO   1274 (RETURN)
.................... } 
....................  
.................... void dust_hdlc_pkgen(uint8_t* prefix, uint8_t size, \ 
....................                        uint8_t* buf, uint8_t size_buf) 
*
0606C:  MOVLB  5
0606E:  CLRF   x6C
06070:  CLRF   x6B
06072:  CLRF   x6D
06074:  CLRF   x6E
06076:  CLRF   x6F
.................... { 
.................... // dust_hdlc_pkgen() 
.................... // 
.................... // Generate an HDLC packet ready for a mote. 
.................... // 
.................... // 1. Calc CRC-16 
.................... // 2. Add start delimiters (flag sequence) 
.................... // 3. Byte stuff 0x7e & 0x7d 
.................... // 4. Add end delimiters (flag sequence) 
.................... // 
....................      
....................    uint16_t    fcs16       = 0; 
....................    uint8_t     data8       = 0; 
....................    uint8_t     i           = 0; 
....................    uint8_t     j           = 0; 
....................  
.................... // Step 1 
....................    fcs16 = FCS_INITIAL_FCS16; 
06078:  SETF   x6C
0607A:  SETF   x6B
....................     
....................    // FCS the prefix bytes 
....................    for (i = 0; i < size; i++) 
0607C:  CLRF   x6E
0607E:  MOVF   x67,W
06080:  SUBWF  x6E,W
06082:  BC    60BC
....................    { 
....................       fcs16 = fcs_fcs16(fcs16, prefix[i]); 
06084:  MOVF   x6E,W
06086:  ADDWF  x65,W
06088:  MOVWF  FE9
0608A:  MOVLW  00
0608C:  ADDWFC x66,W
0608E:  MOVWF  FEA
06090:  MOVFF  FEF,622
06094:  CLRF   19
06096:  BTFSC  FF2.7
06098:  BSF    19.7
0609A:  BCF    FF2.7
0609C:  MOVFF  56C,621
060A0:  MOVFF  56B,620
060A4:  MOVLB  0
060A6:  CALL   0EA2
060AA:  BTFSC  19.7
060AC:  BSF    FF2.7
060AE:  MOVFF  02,56C
060B2:  MOVFF  01,56B
060B6:  MOVLB  5
060B8:  INCF   x6E,F
060BA:  BRA    607E
....................    } 
....................     
....................    // FCS the data packet bytes 
....................    for (i = 0; i < size_buf; i++) 
060BC:  CLRF   x6E
060BE:  MOVF   x6A,W
060C0:  SUBWF  x6E,W
060C2:  BC    60FC
....................    { 
....................       fcs16 = fcs_fcs16(fcs16, buf[i]); 
060C4:  MOVF   x6E,W
060C6:  ADDWF  x68,W
060C8:  MOVWF  FE9
060CA:  MOVLW  00
060CC:  ADDWFC x69,W
060CE:  MOVWF  FEA
060D0:  MOVFF  FEF,622
060D4:  CLRF   19
060D6:  BTFSC  FF2.7
060D8:  BSF    19.7
060DA:  BCF    FF2.7
060DC:  MOVFF  56C,621
060E0:  MOVFF  56B,620
060E4:  MOVLB  0
060E6:  CALL   0EA2
060EA:  BTFSC  19.7
060EC:  BSF    FF2.7
060EE:  MOVFF  02,56C
060F2:  MOVFF  01,56B
060F6:  MOVLB  5
060F8:  INCF   x6E,F
060FA:  BRA    60BE
....................    } 
....................  
....................    // add 1's complement 
....................    fcs16 = ~(fcs16);  
060FC:  COMF   x6B,F
060FE:  COMF   x6C,F
....................  
.................... // Step 2 
....................    //Set initial delimiter 
....................    j = 0; 
06100:  CLRF   x6F
....................    dust_send_buffer[j++]  = FLAG_SEQUENCE; 
06102:  MOVF   x6F,W
06104:  INCF   x6F,F
06106:  CLRF   03
06108:  ADDLW  40
0610A:  MOVWF  FE9
0610C:  MOVLW  01
0610E:  ADDWFC 03,W
06110:  MOVWF  FEA
06112:  MOVLW  7E
06114:  MOVWF  FEF
....................  
.................... // Step 3 
....................    // Stuff prefix buffer 
....................    for (i = 0; i < size; i++) 
06116:  CLRF   x6E
06118:  MOVF   x67,W
0611A:  SUBWF  x6E,W
0611C:  BC    61B8
....................    { 
....................       STUFF_BYTE(prefix[i], dust_send_buffer, j); 
0611E:  MOVF   x6E,W
06120:  ADDWF  x65,W
06122:  MOVWF  FE9
06124:  MOVLW  00
06126:  ADDWFC x66,W
06128:  MOVWF  FEA
0612A:  MOVF   FEF,W
0612C:  SUBLW  7D
0612E:  BZ    6142
06130:  MOVF   x6E,W
06132:  ADDWF  x65,W
06134:  MOVWF  FE9
06136:  MOVLW  00
06138:  ADDWFC x66,W
0613A:  MOVWF  FEA
0613C:  MOVF   FEF,W
0613E:  SUBLW  7E
06140:  BNZ   618A
06142:  MOVF   x6F,W
06144:  INCF   x6F,F
06146:  CLRF   03
06148:  ADDLW  40
0614A:  MOVWF  FE9
0614C:  MOVLW  01
0614E:  ADDWFC 03,W
06150:  MOVWF  FEA
06152:  MOVLW  7D
06154:  MOVWF  FEF
06156:  MOVF   x6F,W
06158:  INCF   x6F,F
0615A:  CLRF   03
0615C:  ADDLW  40
0615E:  MOVWF  01
06160:  MOVLW  01
06162:  ADDWFC 03,F
06164:  MOVFF  01,570
06168:  MOVFF  03,571
0616C:  MOVF   x6E,W
0616E:  ADDWF  x65,W
06170:  MOVWF  FE9
06172:  MOVLW  00
06174:  ADDWFC x66,W
06176:  MOVWF  FEA
06178:  MOVF   FEF,W
0617A:  XORLW  20
0617C:  MOVWF  x72
0617E:  MOVFF  03,FEA
06182:  MOVFF  01,FE9
06186:  MOVWF  FEF
06188:  BRA    61B4
0618A:  MOVF   x6F,W
0618C:  INCF   x6F,F
0618E:  CLRF   03
06190:  ADDLW  40
06192:  MOVWF  01
06194:  MOVLW  01
06196:  ADDWFC 03,F
06198:  MOVF   x6E,W
0619A:  ADDWF  x65,W
0619C:  MOVWF  FE9
0619E:  MOVLW  00
061A0:  ADDWFC x66,W
061A2:  MOVWF  FEA
061A4:  MOVFF  FEF,572
061A8:  MOVFF  03,FEA
061AC:  MOVFF  01,FE9
061B0:  MOVFF  572,FEF
061B4:  INCF   x6E,F
061B6:  BRA    6118
....................    } 
....................  
....................    // Stuff data buffer 
....................    for (i = 0; i < size_buf; i++) 
061B8:  CLRF   x6E
061BA:  MOVF   x6A,W
061BC:  SUBWF  x6E,W
061BE:  BC    625A
....................    { 
....................       STUFF_BYTE(buf[i], dust_send_buffer, j); 
061C0:  MOVF   x6E,W
061C2:  ADDWF  x68,W
061C4:  MOVWF  FE9
061C6:  MOVLW  00
061C8:  ADDWFC x69,W
061CA:  MOVWF  FEA
061CC:  MOVF   FEF,W
061CE:  SUBLW  7D
061D0:  BZ    61E4
061D2:  MOVF   x6E,W
061D4:  ADDWF  x68,W
061D6:  MOVWF  FE9
061D8:  MOVLW  00
061DA:  ADDWFC x69,W
061DC:  MOVWF  FEA
061DE:  MOVF   FEF,W
061E0:  SUBLW  7E
061E2:  BNZ   622C
061E4:  MOVF   x6F,W
061E6:  INCF   x6F,F
061E8:  CLRF   03
061EA:  ADDLW  40
061EC:  MOVWF  FE9
061EE:  MOVLW  01
061F0:  ADDWFC 03,W
061F2:  MOVWF  FEA
061F4:  MOVLW  7D
061F6:  MOVWF  FEF
061F8:  MOVF   x6F,W
061FA:  INCF   x6F,F
061FC:  CLRF   03
061FE:  ADDLW  40
06200:  MOVWF  01
06202:  MOVLW  01
06204:  ADDWFC 03,F
06206:  MOVFF  01,570
0620A:  MOVFF  03,571
0620E:  MOVF   x6E,W
06210:  ADDWF  x68,W
06212:  MOVWF  FE9
06214:  MOVLW  00
06216:  ADDWFC x69,W
06218:  MOVWF  FEA
0621A:  MOVF   FEF,W
0621C:  XORLW  20
0621E:  MOVWF  x72
06220:  MOVFF  03,FEA
06224:  MOVFF  01,FE9
06228:  MOVWF  FEF
0622A:  BRA    6256
0622C:  MOVF   x6F,W
0622E:  INCF   x6F,F
06230:  CLRF   03
06232:  ADDLW  40
06234:  MOVWF  01
06236:  MOVLW  01
06238:  ADDWFC 03,F
0623A:  MOVF   x6E,W
0623C:  ADDWF  x68,W
0623E:  MOVWF  FE9
06240:  MOVLW  00
06242:  ADDWFC x69,W
06244:  MOVWF  FEA
06246:  MOVFF  FEF,572
0624A:  MOVFF  03,FEA
0624E:  MOVFF  01,FE9
06252:  MOVFF  572,FEF
06256:  INCF   x6E,F
06258:  BRA    61BA
....................    } 
....................  
....................    // Add least significiant byte 1st (RFC 1622). Do byte stuffing. 
....................    data8 = (uint8_t)(fcs16 & 0xff); 
0625A:  MOVFF  56B,56D
....................    STUFF_BYTE(data8, dust_send_buffer, j); 
0625E:  MOVF   x6D,W
06260:  SUBLW  7D
06262:  BZ    626A
06264:  MOVF   x6D,W
06266:  SUBLW  7E
06268:  BNZ   6296
0626A:  MOVF   x6F,W
0626C:  INCF   x6F,F
0626E:  CLRF   03
06270:  ADDLW  40
06272:  MOVWF  FE9
06274:  MOVLW  01
06276:  ADDWFC 03,W
06278:  MOVWF  FEA
0627A:  MOVLW  7D
0627C:  MOVWF  FEF
0627E:  MOVF   x6F,W
06280:  INCF   x6F,F
06282:  CLRF   03
06284:  ADDLW  40
06286:  MOVWF  FE9
06288:  MOVLW  01
0628A:  ADDWFC 03,W
0628C:  MOVWF  FEA
0628E:  MOVF   x6D,W
06290:  XORLW  20
06292:  MOVWF  FEF
06294:  BRA    62AA
06296:  MOVF   x6F,W
06298:  INCF   x6F,F
0629A:  CLRF   03
0629C:  ADDLW  40
0629E:  MOVWF  FE9
062A0:  MOVLW  01
062A2:  ADDWFC 03,W
062A4:  MOVWF  FEA
062A6:  MOVFF  56D,FEF
....................  
....................    // Add most significiant byte 2nd (RFC 1622). Do byte stuffing. 
....................    data8 = (uint8_t)((fcs16>>8) & 0xff); 
062AA:  MOVFF  56C,56D
....................    STUFF_BYTE(data8, dust_send_buffer, j); 
062AE:  MOVF   x6D,W
062B0:  SUBLW  7D
062B2:  BZ    62BA
062B4:  MOVF   x6D,W
062B6:  SUBLW  7E
062B8:  BNZ   62E6
062BA:  MOVF   x6F,W
062BC:  INCF   x6F,F
062BE:  CLRF   03
062C0:  ADDLW  40
062C2:  MOVWF  FE9
062C4:  MOVLW  01
062C6:  ADDWFC 03,W
062C8:  MOVWF  FEA
062CA:  MOVLW  7D
062CC:  MOVWF  FEF
062CE:  MOVF   x6F,W
062D0:  INCF   x6F,F
062D2:  CLRF   03
062D4:  ADDLW  40
062D6:  MOVWF  FE9
062D8:  MOVLW  01
062DA:  ADDWFC 03,W
062DC:  MOVWF  FEA
062DE:  MOVF   x6D,W
062E0:  XORLW  20
062E2:  MOVWF  FEF
062E4:  BRA    62FA
062E6:  MOVF   x6F,W
062E8:  INCF   x6F,F
062EA:  CLRF   03
062EC:  ADDLW  40
062EE:  MOVWF  FE9
062F0:  MOVLW  01
062F2:  ADDWFC 03,W
062F4:  MOVWF  FEA
062F6:  MOVFF  56D,FEF
....................  
.................... // Step 4 
....................    // CHECK_BUF_SIZE(j+1); 
....................    dust_send_buffer[j++]  = FLAG_SEQUENCE; 
062FA:  MOVF   x6F,W
062FC:  INCF   x6F,F
062FE:  CLRF   03
06300:  ADDLW  40
06302:  MOVWF  FE9
06304:  MOVLW  01
06306:  ADDWFC 03,W
06308:  MOVWF  FEA
0630A:  MOVLW  7E
0630C:  MOVWF  FEF
....................  
....................    // Set the number of bytes actually written 
....................    num_of_bytes_to_send = j; 
0630E:  MOVFF  56F,351
....................     
....................    return; 
06312:  MOVLB  0
06314:  RETURN 0
.................... } 
....................  
.................... void dust_hdlc_pkgen_ISR(uint8_t* prefix, uint8_t size, \ 
....................                        uint8_t* buf, uint8_t size_buf) 
*
00EE4:  MOVLB  6
00EE6:  CLRF   x1B
00EE8:  CLRF   x1A
00EEA:  CLRF   x1C
00EEC:  CLRF   x1D
00EEE:  CLRF   x1E
.................... { 
.................... // Generate an HDLC packet ready for a mote. 
.................... // 
.................... // 1. Calc CRC-16 
.................... // 2. Add start delimiters (flag sequence) 
.................... // 3. Byte stuff 0x7e & 0x7d 
.................... // 4. Add end delimiters (flag sequence) 
.................... // 
....................      
....................    uint16_t    fcs16       = 0; 
....................    uint8_t     data8       = 0; 
....................    uint8_t     i           = 0; 
....................    uint8_t     j           = 0; 
....................  
.................... // Step 1 
....................    fcs16 = FCS_INITIAL_FCS16; 
00EF0:  SETF   x1B
00EF2:  SETF   x1A
....................     
....................    // FCS the prefix bytes 
....................    for (i = 0; i < size; i++) 
00EF4:  CLRF   x1D
00EF6:  MOVF   x16,W
00EF8:  SUBWF  x1D,W
00EFA:  BC    0F26
....................    { 
....................       fcs16 = fcs_fcs16(fcs16, prefix[i]); 
00EFC:  MOVF   x1D,W
00EFE:  ADDWF  x14,W
00F00:  MOVWF  FE9
00F02:  MOVLW  00
00F04:  ADDWFC x15,W
00F06:  MOVWF  FEA
00F08:  MOVFF  FEF,622
00F0C:  MOVFF  61B,621
00F10:  MOVFF  61A,620
00F14:  MOVLB  0
00F16:  RCALL  0EA2
00F18:  MOVFF  02,61B
00F1C:  MOVFF  01,61A
00F20:  MOVLB  6
00F22:  INCF   x1D,F
00F24:  BRA    0EF6
....................    } 
....................     
....................    // FCS the data packet bytes 
....................    for (i = 0; i < size_buf; i++) 
00F26:  CLRF   x1D
00F28:  MOVF   x19,W
00F2A:  SUBWF  x1D,W
00F2C:  BC    0F58
....................    { 
....................       fcs16 = fcs_fcs16(fcs16, buf[i]); 
00F2E:  MOVF   x1D,W
00F30:  ADDWF  x17,W
00F32:  MOVWF  FE9
00F34:  MOVLW  00
00F36:  ADDWFC x18,W
00F38:  MOVWF  FEA
00F3A:  MOVFF  FEF,622
00F3E:  MOVFF  61B,621
00F42:  MOVFF  61A,620
00F46:  MOVLB  0
00F48:  RCALL  0EA2
00F4A:  MOVFF  02,61B
00F4E:  MOVFF  01,61A
00F52:  MOVLB  6
00F54:  INCF   x1D,F
00F56:  BRA    0F28
....................    } 
....................  
....................    // add 1's complement 
....................    fcs16 = ~(fcs16);  
00F58:  COMF   x1A,F
00F5A:  COMF   x1B,F
....................  
.................... // Step 2 
....................    //Set initial delimiter 
....................    j = 0; 
00F5C:  CLRF   x1E
....................    dust_send_buffer_isr[j++]  = FLAG_SEQUENCE; 
00F5E:  MOVF   x1E,W
00F60:  INCF   x1E,F
00F62:  CLRF   03
00F64:  ADDLW  10
00F66:  MOVWF  FE9
00F68:  MOVLW  02
00F6A:  ADDWFC 03,W
00F6C:  MOVWF  FEA
00F6E:  MOVLW  7E
00F70:  MOVWF  FEF
....................  
.................... // Step 3 
....................    // Stuff prefix buffer 
....................    for (i = 0; i < size; i++) 
00F72:  CLRF   x1D
00F74:  MOVF   x16,W
00F76:  SUBWF  x1D,W
00F78:  BC    1014
....................    { 
....................       STUFF_BYTE(prefix[i], dust_send_buffer_isr, j); 
00F7A:  MOVF   x1D,W
00F7C:  ADDWF  x14,W
00F7E:  MOVWF  FE9
00F80:  MOVLW  00
00F82:  ADDWFC x15,W
00F84:  MOVWF  FEA
00F86:  MOVF   FEF,W
00F88:  SUBLW  7D
00F8A:  BZ    0F9E
00F8C:  MOVF   x1D,W
00F8E:  ADDWF  x14,W
00F90:  MOVWF  FE9
00F92:  MOVLW  00
00F94:  ADDWFC x15,W
00F96:  MOVWF  FEA
00F98:  MOVF   FEF,W
00F9A:  SUBLW  7E
00F9C:  BNZ   0FE6
00F9E:  MOVF   x1E,W
00FA0:  INCF   x1E,F
00FA2:  CLRF   03
00FA4:  ADDLW  10
00FA6:  MOVWF  FE9
00FA8:  MOVLW  02
00FAA:  ADDWFC 03,W
00FAC:  MOVWF  FEA
00FAE:  MOVLW  7D
00FB0:  MOVWF  FEF
00FB2:  MOVF   x1E,W
00FB4:  INCF   x1E,F
00FB6:  CLRF   03
00FB8:  ADDLW  10
00FBA:  MOVWF  01
00FBC:  MOVLW  02
00FBE:  ADDWFC 03,F
00FC0:  MOVFF  01,61F
00FC4:  MOVFF  03,620
00FC8:  MOVF   x1D,W
00FCA:  ADDWF  x14,W
00FCC:  MOVWF  FE9
00FCE:  MOVLW  00
00FD0:  ADDWFC x15,W
00FD2:  MOVWF  FEA
00FD4:  MOVF   FEF,W
00FD6:  XORLW  20
00FD8:  MOVWF  x21
00FDA:  MOVFF  03,FEA
00FDE:  MOVFF  01,FE9
00FE2:  MOVWF  FEF
00FE4:  BRA    1010
00FE6:  MOVF   x1E,W
00FE8:  INCF   x1E,F
00FEA:  CLRF   03
00FEC:  ADDLW  10
00FEE:  MOVWF  01
00FF0:  MOVLW  02
00FF2:  ADDWFC 03,F
00FF4:  MOVF   x1D,W
00FF6:  ADDWF  x14,W
00FF8:  MOVWF  FE9
00FFA:  MOVLW  00
00FFC:  ADDWFC x15,W
00FFE:  MOVWF  FEA
01000:  MOVFF  FEF,621
01004:  MOVFF  03,FEA
01008:  MOVFF  01,FE9
0100C:  MOVFF  621,FEF
01010:  INCF   x1D,F
01012:  BRA    0F74
....................    } 
....................  
....................    // Stuff data buffer 
....................    for (i = 0; i < size_buf; i++) 
01014:  CLRF   x1D
01016:  MOVF   x19,W
01018:  SUBWF  x1D,W
0101A:  BC    10B6
....................    { 
....................       STUFF_BYTE(buf[i], dust_send_buffer_isr, j); 
0101C:  MOVF   x1D,W
0101E:  ADDWF  x17,W
01020:  MOVWF  FE9
01022:  MOVLW  00
01024:  ADDWFC x18,W
01026:  MOVWF  FEA
01028:  MOVF   FEF,W
0102A:  SUBLW  7D
0102C:  BZ    1040
0102E:  MOVF   x1D,W
01030:  ADDWF  x17,W
01032:  MOVWF  FE9
01034:  MOVLW  00
01036:  ADDWFC x18,W
01038:  MOVWF  FEA
0103A:  MOVF   FEF,W
0103C:  SUBLW  7E
0103E:  BNZ   1088
01040:  MOVF   x1E,W
01042:  INCF   x1E,F
01044:  CLRF   03
01046:  ADDLW  10
01048:  MOVWF  FE9
0104A:  MOVLW  02
0104C:  ADDWFC 03,W
0104E:  MOVWF  FEA
01050:  MOVLW  7D
01052:  MOVWF  FEF
01054:  MOVF   x1E,W
01056:  INCF   x1E,F
01058:  CLRF   03
0105A:  ADDLW  10
0105C:  MOVWF  01
0105E:  MOVLW  02
01060:  ADDWFC 03,F
01062:  MOVFF  01,61F
01066:  MOVFF  03,620
0106A:  MOVF   x1D,W
0106C:  ADDWF  x17,W
0106E:  MOVWF  FE9
01070:  MOVLW  00
01072:  ADDWFC x18,W
01074:  MOVWF  FEA
01076:  MOVF   FEF,W
01078:  XORLW  20
0107A:  MOVWF  x21
0107C:  MOVFF  03,FEA
01080:  MOVFF  01,FE9
01084:  MOVWF  FEF
01086:  BRA    10B2
01088:  MOVF   x1E,W
0108A:  INCF   x1E,F
0108C:  CLRF   03
0108E:  ADDLW  10
01090:  MOVWF  01
01092:  MOVLW  02
01094:  ADDWFC 03,F
01096:  MOVF   x1D,W
01098:  ADDWF  x17,W
0109A:  MOVWF  FE9
0109C:  MOVLW  00
0109E:  ADDWFC x18,W
010A0:  MOVWF  FEA
010A2:  MOVFF  FEF,621
010A6:  MOVFF  03,FEA
010AA:  MOVFF  01,FE9
010AE:  MOVFF  621,FEF
010B2:  INCF   x1D,F
010B4:  BRA    1016
....................    } 
....................  
....................    // Add least significiant byte 1st (RFC 1622). Do byte stuffing. 
....................    data8 = (uint8_t)(fcs16 & 0xff); 
010B6:  MOVFF  61A,61C
....................    STUFF_BYTE(data8, dust_send_buffer_isr, j); 
010BA:  MOVF   x1C,W
010BC:  SUBLW  7D
010BE:  BZ    10C6
010C0:  MOVF   x1C,W
010C2:  SUBLW  7E
010C4:  BNZ   10F2
010C6:  MOVF   x1E,W
010C8:  INCF   x1E,F
010CA:  CLRF   03
010CC:  ADDLW  10
010CE:  MOVWF  FE9
010D0:  MOVLW  02
010D2:  ADDWFC 03,W
010D4:  MOVWF  FEA
010D6:  MOVLW  7D
010D8:  MOVWF  FEF
010DA:  MOVF   x1E,W
010DC:  INCF   x1E,F
010DE:  CLRF   03
010E0:  ADDLW  10
010E2:  MOVWF  FE9
010E4:  MOVLW  02
010E6:  ADDWFC 03,W
010E8:  MOVWF  FEA
010EA:  MOVF   x1C,W
010EC:  XORLW  20
010EE:  MOVWF  FEF
010F0:  BRA    1106
010F2:  MOVF   x1E,W
010F4:  INCF   x1E,F
010F6:  CLRF   03
010F8:  ADDLW  10
010FA:  MOVWF  FE9
010FC:  MOVLW  02
010FE:  ADDWFC 03,W
01100:  MOVWF  FEA
01102:  MOVFF  61C,FEF
....................  
....................    // Add most significiant byte 2nd (RFC 1622). Do byte stuffing. 
....................    data8 = (uint8_t)((fcs16>>8) & 0xff); 
01106:  MOVFF  61B,61C
....................    STUFF_BYTE(data8, dust_send_buffer_isr, j); 
0110A:  MOVF   x1C,W
0110C:  SUBLW  7D
0110E:  BZ    1116
01110:  MOVF   x1C,W
01112:  SUBLW  7E
01114:  BNZ   1142
01116:  MOVF   x1E,W
01118:  INCF   x1E,F
0111A:  CLRF   03
0111C:  ADDLW  10
0111E:  MOVWF  FE9
01120:  MOVLW  02
01122:  ADDWFC 03,W
01124:  MOVWF  FEA
01126:  MOVLW  7D
01128:  MOVWF  FEF
0112A:  MOVF   x1E,W
0112C:  INCF   x1E,F
0112E:  CLRF   03
01130:  ADDLW  10
01132:  MOVWF  FE9
01134:  MOVLW  02
01136:  ADDWFC 03,W
01138:  MOVWF  FEA
0113A:  MOVF   x1C,W
0113C:  XORLW  20
0113E:  MOVWF  FEF
01140:  BRA    1156
01142:  MOVF   x1E,W
01144:  INCF   x1E,F
01146:  CLRF   03
01148:  ADDLW  10
0114A:  MOVWF  FE9
0114C:  MOVLW  02
0114E:  ADDWFC 03,W
01150:  MOVWF  FEA
01152:  MOVFF  61C,FEF
....................  
.................... // Step 4 
....................    // CHECK_BUF_SIZE(j+1); 
....................    dust_send_buffer_isr[j++]  = FLAG_SEQUENCE; 
01156:  MOVF   x1E,W
01158:  INCF   x1E,F
0115A:  CLRF   03
0115C:  ADDLW  10
0115E:  MOVWF  FE9
01160:  MOVLW  02
01162:  ADDWFC 03,W
01164:  MOVWF  FEA
01166:  MOVLW  7E
01168:  MOVWF  FEF
....................  
....................    // Set the number of bytes actually written 
....................    num_of_bytes_to_send_isr = j; 
0116A:  MOVFF  61E,352
....................     
....................    return; 
0116E:  MOVLB  0
01170:  RETURN 0
.................... } 
....................  
.................... uint8_t dust_hdlc_pksend() 
.................... { 
.................... // This routine actually sends out the packet from the micro to the mote 
....................  
....................    uint8_t     n; 
....................    uint8_t     tmp_oscccon, tmp_t2con, tmp_pr2, tmp_t0con; 
....................     
....................    // save the crystal status for later restore 
....................    tmp_oscccon = OSCCON; 
*
06316:  MOVFF  FD3,564
....................    tmp_t2con = T2CON; 
0631A:  MOVFF  FBA,565
....................    tmp_pr2 = PR2; 
0631E:  MOVFF  FBB,566
....................    tmp_t0con = T0CON; 
06322:  MOVFF  FD5,567
06326:  CLRF   19
06328:  BTFSC  FF2.7
0632A:  BSF    19.7
0632C:  BCF    FF2.7
....................     
....................    // turn on high-speed crystal for UART communication 
....................    fosc_pri(); 
0632E:  CALL   1172
06332:  BTFSC  19.7
06334:  BSF    FF2.7
....................  
....................    // prepare mote to recieve data 
....................    output_low(MOTE_RX_RTSn); 
06336:  BCF    F8C.5
....................    
....................    // turn on uart and wait for it to initalize 
....................    setup_uart(TRUE);                      
06338:  BSF    FAB.7
0633A:  BSF    FAB.4
0633C:  BSF    FAC.5
....................    setup_T0_int(T0_500US); 
0633E:  MOVLB  5
06340:  SETF   x69
06342:  MOVLW  FE
06344:  MOVWF  x68
06346:  MOVLB  0
06348:  CALL   38C2
....................    while(!TMR0IF);    
0634C:  BTFSS  FF2.2
0634E:  BRA    634C
....................  
....................    // loop for sending out bytes 
....................    for (n = 0; n < num_of_bytes_to_send; n++) 
06350:  MOVLB  5
06352:  CLRF   x63
06354:  MOVLB  3
06356:  MOVF   x51,W
06358:  MOVLB  5
0635A:  SUBWF  x63,W
0635C:  BC    63A8
....................    { 
....................       // setup send timeout for error handling 
....................       setup_T0_int(T0_10MS); 
0635E:  SETF   x69
06360:  MOVLW  D9
06362:  MOVWF  x68
06364:  MOVLB  0
06366:  CALL   38C2
....................  
....................       // wait until a transmit is done or timeout error 
....................       while (!TRMT1 && !TMR0IF); 
0636A:  BTFSC  FAC.1
0636C:  BRA    6372
0636E:  BTFSS  FF2.2
06370:  BRA    636A
....................        
....................       // if the timeout occured before the tranmit finished 
....................       if (TMR0IF) 
06372:  BTFSS  FF2.2
06374:  BRA    6386
....................       { 
....................          // tell mote that it is no longer going to recieve data 
....................          output_high(MOTE_RX_RTSn); 
06376:  BSF    F8C.5
....................          // turn off uart 
....................          setup_uart(FALSE); 
06378:  BCF    FAB.7
0637A:  BCF    FAB.4
0637C:  BCF    FAC.5
....................          // return error code 
....................          return ERR_DUSTMSG_TIMEOUT; 
0637E:  MOVLW  FC
06380:  MOVWF  01
06382:  BRA    63CA
....................       } 
06384:  BRA    63A2
....................       // if transmit buffer is open 
....................       else 
....................       { 
....................          // send byte to mote 
....................          putc(dust_send_buffer[n]); 
06386:  CLRF   03
06388:  MOVLB  5
0638A:  MOVF   x63,W
0638C:  ADDLW  40
0638E:  MOVWF  FE9
06390:  MOVLW  01
06392:  ADDWFC 03,W
06394:  MOVWF  FEA
06396:  MOVFF  FEF,568
0639A:  MOVF   x68,W
0639C:  MOVLB  0
0639E:  CALL   119E
....................       } 
063A2:  MOVLB  5
063A4:  INCF   x63,F
063A6:  BRA    6354
....................    } 
....................     
....................    // wait until the last transmit is done 
....................    while (!TRMT1); 
063A8:  BTFSS  FAC.1
063AA:  BRA    63A8
....................  
....................    // tell mote that it no longer is going to recieve data 
....................    output_high(MOTE_RX_RTSn); 
063AC:  BSF    F8C.5
....................     
....................    // turn off the uart 
....................    setup_uart(FALSE); 
063AE:  BCF    FAB.7
063B0:  BCF    FAB.4
063B2:  BCF    FAC.5
....................     
....................    //fosc_250k(); 
....................    
....................    // restore the crystal status 
....................    OSCCON = tmp_oscccon; 
063B4:  MOVFF  564,FD3
....................    T2CON = tmp_t2con; 
063B8:  MOVFF  565,FBA
....................    T0CON = tmp_t0con; 
063BC:  MOVFF  567,FD5
....................    PR2 = tmp_PR2; 
063C0:  MOVFF  566,FBB
....................     
....................    // return no error 
....................    return NO_ERR; 
063C4:  MOVLW  00
063C6:  MOVWF  01
063C8:  MOVLB  0
063CA:  RETURN 0
.................... } 
....................  
.................... uint8_t dust_hdlc_pksend_ISR() 
.................... { 
.................... // We're now running at 3.6864MHz at 115.2K baud 
.................... // This routine actually sends out the packet from the micro to the mote 
....................     
....................    uint8_t     n; 
....................    uint8_t     tmp_oscccon, tmp_t2con, tmp_pr2, tmp_t0con; 
....................     
....................    // save the crystal status for later restore 
....................    tmp_oscccon = OSCCON; 
*
011A6:  MOVFF  FD3,615
....................    tmp_t2con = T2CON; 
011AA:  MOVFF  FBA,616
....................    tmp_pr2 = PR2; 
011AE:  MOVFF  FBB,617
....................    tmp_t0con = T0CON; 
011B2:  MOVFF  FD5,618
....................     
....................    // turn on high-speed crystal for UART communication 
....................    fosc_pri(); 
011B6:  RCALL  1172
....................  
....................    // prepare mote to recieve data 
....................    output_low(MOTE_RX_RTSn); 
011B8:  BCF    F8C.5
....................    
....................    // turn on uart and wait for it to initalize 
....................    setup_uart(TRUE);                      
011BA:  BSF    FAB.7
011BC:  BSF    FAB.4
011BE:  BSF    FAC.5
....................    setup_T4_int(T4_500US); 
011C0:  MOVLW  01
011C2:  MOVLB  6
011C4:  MOVWF  x19
011C6:  MOVLB  0
011C8:  CALL   0944
....................    while(!TMR4IF);    
011CC:  BTFSS  F7E.0
011CE:  BRA    11CC
....................  
....................    for (n = 0; n < num_of_bytes_to_send_isr; n++) 
011D0:  MOVLB  6
011D2:  CLRF   x14
011D4:  MOVLB  3
011D6:  MOVF   x52,W
011D8:  MOVLB  6
011DA:  SUBWF  x14,W
011DC:  BC    1224
....................    { 
....................       // setup send timeout for error handling 
....................       setup_T4_int(T4_10MS); 
011DE:  MOVLW  27
011E0:  MOVWF  x19
011E2:  MOVLB  0
011E4:  CALL   0944
....................  
....................       // wait until a transmit is done or timeout error 
....................       while (!TRMT1 && !TMR4IF); 
011E8:  BTFSC  FAC.1
011EA:  BRA    11F0
011EC:  BTFSS  F7E.0
011EE:  BRA    11E8
....................        
....................       // if the timeout occured before the tranmit finished 
....................       if (TMR4IF) 
011F0:  BTFSS  F7E.0
011F2:  BRA    1204
....................       { 
....................          // tell mote that it is no longer going to recieve data 
....................          output_high(MOTE_RX_RTSn); 
011F4:  BSF    F8C.5
....................          // turn off uart 
....................          setup_uart(FALSE); 
011F6:  BCF    FAB.7
011F8:  BCF    FAB.4
011FA:  BCF    FAC.5
....................          // return error code 
....................          return ERR_DUSTMSG_TIMEOUT; 
011FC:  MOVLW  FC
011FE:  MOVWF  01
01200:  BRA    1246
....................       } 
01202:  BRA    121E
....................       // if transmit buffer is open 
....................       else 
....................       { 
....................          // send byte to mote 
....................          putc(dust_send_buffer_isr[n]); 
01204:  CLRF   03
01206:  MOVLB  6
01208:  MOVF   x14,W
0120A:  ADDLW  10
0120C:  MOVWF  FE9
0120E:  MOVLW  02
01210:  ADDWFC 03,W
01212:  MOVWF  FEA
01214:  MOVFF  FEF,619
01218:  MOVF   x19,W
0121A:  MOVLB  0
0121C:  RCALL  119E
....................       } 
0121E:  MOVLB  6
01220:  INCF   x14,F
01222:  BRA    11D4
....................    } 
....................     
....................    // wait until the last transmit is done 
....................    while (!TRMT1); 
01224:  BTFSS  FAC.1
01226:  BRA    1224
....................  
....................    // tell mote that it no longer is going to recieve data 
....................    output_high(MOTE_RX_RTSn); 
01228:  BSF    F8C.5
....................     
....................    // turn off the uart 
....................    setup_uart(FALSE); 
0122A:  BCF    FAB.7
0122C:  BCF    FAB.4
0122E:  BCF    FAC.5
....................     
....................    // restore the crystal status 
....................    OSCCON = tmp_oscccon; 
01230:  MOVFF  615,FD3
....................    T2CON = tmp_t2con; 
01234:  MOVFF  616,FBA
....................    T0CON = tmp_t0con; 
01238:  MOVFF  618,FD5
....................    PR2 = tmp_PR2; 
0123C:  MOVFF  617,FBB
....................     
....................    // return no error 
....................    return NO_ERR; 
01240:  MOVLW  00
01242:  MOVWF  01
01244:  MOVLB  0
01246:  RETURN 0
.................... } 
....................  
.................... uint8_t dust_hdlc_pkdecode_ISR(uint8_t bytes_to_decode) 
*
00AE0:  MOVLB  6
00AE2:  CLRF   x16
00AE4:  CLRF   x15
00AE6:  CLRF   x1D
.................... { 
.................... /* 
....................  * Decode an HDLC packet from Mote. 
....................  * 
....................  * NOTE: The destination buffer must contain an extra 
....................  *       2 bytes to hold CRC data.  This requirement 
....................  *       simplifies the code and improves performance. 
....................  * 
....................  * 1. Remove delimiters 
....................  * 2. Unstuff *payload* and CRC bytes 
....................  * 3. Assemble CRC bytes 
....................  * 4. Check CRC 
....................  *  
....................  * Returns error messages or the number of byte decoded 
.................... */ 
....................  
.................... //  Note changes to routine as supplied by Dust: 
.................... //  The buffer and buffer size for the storage of received packet 
.................... //   are hardwired to be dust_recive_buffer[128] for the raw data 
.................... //   and bytes_from_mote.dust_rcvd for the unstuffed and stripped data 
....................  
....................    uint16_t    crc16       = 0; 
....................    uint8_t*    src_ptr; 
....................    uint8_t*    src_ptr_end; 
....................    uint8_t*    dest_ptr; 
....................  
....................    uint8_t      dust_bytes_rcvd = 0; 
....................  
.................... // 1 Check for start/end delimiters 
....................     if ((FLAG_SEQUENCE != dust_recive_buffer[0]) || 
....................         (FLAG_SEQUENCE != dust_recive_buffer[bytes_to_decode-1]))  
00AE8:  MOVLB  2
00AEA:  MOVF   x28,W
00AEC:  SUBLW  7E
00AEE:  BNZ   0B0A
00AF0:  MOVLW  01
00AF2:  MOVLB  6
00AF4:  SUBWF  x14,W
00AF6:  CLRF   03
00AF8:  ADDLW  28
00AFA:  MOVWF  FE9
00AFC:  MOVLW  02
00AFE:  ADDWFC 03,W
00B00:  MOVWF  FEA
00B02:  MOVF   FEF,W
00B04:  SUBLW  7E
00B06:  BZ    0B12
00B08:  MOVLB  2
....................     { 
....................         // return framing error 
....................         return ERR_DUSTMSG_FRAMING_ERROR; 
00B0A:  MOVLW  FE
00B0C:  MOVWF  01
00B0E:  BRA    0C20
00B10:  MOVLB  6
....................     } 
....................  
.................... // 2 Unstuff *payload* and CRC data into destination buffer 
....................     dest_ptr    = bytes_from_mote.dust_rcvd; 
00B12:  CLRF   x1C
00B14:  MOVLW  D9
00B16:  MOVWF  x1B
....................     src_ptr_end = &dust_recive_buffer[bytes_to_decode-1]; 
00B18:  MOVLW  01
00B1A:  SUBWF  x14,W
00B1C:  CLRF   03
00B1E:  ADDLW  28
00B20:  MOVWF  01
00B22:  MOVLW  02
00B24:  ADDWFC 03,F
00B26:  MOVFF  01,619
00B2A:  MOVFF  03,61A
....................     for (src_ptr = &dust_recive_buffer[1]; src_ptr < src_ptr_end; src_ptr++) 
00B2E:  MOVLW  02
00B30:  MOVWF  x18
00B32:  MOVLW  29
00B34:  MOVWF  x17
00B36:  MOVF   x18,W
00B38:  SUBWF  x1A,W
00B3A:  BNC   0BAC
00B3C:  BNZ   0B44
00B3E:  MOVF   x19,W
00B40:  SUBWF  x17,W
00B42:  BC    0BAC
....................     { 
....................         if (*src_ptr == CONTROL_ESCAPE) { 
00B44:  MOVFF  618,03
00B48:  MOVFF  617,FE9
00B4C:  MOVFF  618,FEA
00B50:  MOVF   FEF,W
00B52:  SUBLW  7D
00B54:  BNZ   0B82
....................            src_ptr++; /* skip to next byte, which contains the actual data */ 
00B56:  INCF   x17,F
00B58:  BTFSC  FD8.2
00B5A:  INCF   x18,F
....................             *dest_ptr++ = *src_ptr ^ XOR_BYTE; 
00B5C:  MOVFF  61C,61F
00B60:  MOVF   x1B,W
00B62:  INCF   x1B,F
00B64:  BTFSC  FD8.2
00B66:  INCF   x1C,F
00B68:  MOVWF  x1E
00B6A:  MOVFF  617,FE9
00B6E:  MOVFF  618,FEA
00B72:  MOVF   FEF,W
00B74:  XORLW  20
00B76:  MOVFF  61F,FEA
00B7A:  MOVFF  61E,FE9
00B7E:  MOVWF  FEF
....................         } 
00B80:  BRA    0BA4
....................         else 
....................         { 
....................             *dest_ptr++ = *src_ptr; 
00B82:  MOVFF  61C,61F
00B86:  MOVF   x1B,W
00B88:  INCF   x1B,F
00B8A:  BTFSC  FD8.2
00B8C:  INCF   x1C,F
00B8E:  MOVFF  617,FE9
00B92:  MOVFF  618,FEA
00B96:  MOVFF  FEF,620
00B9A:  MOVFF  61F,FEA
00B9E:  MOVWF  FE9
00BA0:  MOVFF  620,FEF
....................         } 
00BA4:  INCF   x17,F
00BA6:  BTFSC  FD8.2
00BA8:  INCF   x18,F
00BAA:  BRA    0B36
....................     } 
....................  
.................... // 3 Assemble CRC 
....................     dest_ptr--;                 /* now points to MSBs */ 
00BAC:  MOVF   x1B,W
00BAE:  BTFSC  FD8.2
00BB0:  DECF   x1C,F
00BB2:  DECF   x1B,F
....................     crc16 = *dest_ptr-- << 8; 
00BB4:  MOVFF  61C,03
00BB8:  MOVF   x1B,W
00BBA:  BTFSC  FD8.2
00BBC:  DECF   x1C,F
00BBE:  DECF   x1B,F
00BC0:  MOVWF  FE9
00BC2:  MOVFF  03,FEA
00BC6:  MOVFF  FEF,616
00BCA:  CLRF   x15
....................     crc16 += *dest_ptr;         /* add LSBs */ 
00BCC:  MOVFF  61B,FE9
00BD0:  MOVFF  61C,FEA
00BD4:  MOVF   FEF,W
00BD6:  ADDWF  x15,F
00BD8:  MOVLW  00
00BDA:  ADDWFC x16,F
....................  
....................     /* Fill in the number of bytes actually written */ 
....................    dust_bytes_rcvd = (uint8_t)(dest_ptr - bytes_from_mote.dust_rcvd); 
00BDC:  MOVLW  D9
00BDE:  SUBWF  x1B,W
00BE0:  MOVWF  00
00BE2:  MOVLW  00
00BE4:  SUBWFB x1C,W
00BE6:  MOVFF  00,61D
....................  
.................... // 4 Return error if CRCs don't match       
....................     if (fcs_calc_ISR(bytes_from_mote.dust_rcvd, dust_bytes_rcvd) != crc16 )  
00BEA:  CLRF   x1F
00BEC:  MOVLW  D9
00BEE:  MOVWF  x1E
00BF0:  CLRF   x21
00BF2:  MOVFF  61D,620
00BF6:  MOVLB  0
00BF8:  BRA    0A84
00BFA:  MOVFF  02,61F
00BFE:  MOVFF  01,61E
00C02:  MOVLB  6
00C04:  MOVF   x15,W
00C06:  SUBWF  01,W
00C08:  BNZ   0C10
00C0A:  MOVF   x16,W
00C0C:  SUBWF  x1F,W
00C0E:  BZ    0C1A
....................     { 
....................        // indicate bad CRC 
....................        return ERR_DUSTMSG_CRC;       
00C10:  MOVLW  FB
00C12:  MOVWF  01
00C14:  MOVLB  2
00C16:  BRA    0C20
00C18:  MOVLB  6
....................     } 
....................    return dust_bytes_rcvd; 
00C1A:  MOVFF  61D,01
00C1E:  MOVLB  2
00C20:  MOVLB  0
00C22:  GOTO   127E (RETURN)
.................... } 
....................  
.................... uint16_t fcs_fcs16(uint16_t fcs, uint8_t data) 
.................... { 
....................    return (fcs >> 8) ^ fcstab[(fcs ^ data) & 0xff]; 
*
00EA2:  MOVFF  621,623
00EA6:  MOVLB  6
00EA8:  CLRF   x24
00EAA:  MOVF   x20,W
00EAC:  XORWF  x22,W
00EAE:  MOVWF  x25
00EB0:  CLRF   x26
00EB2:  BCF    FD8.0
00EB4:  RLCF   x25,W
00EB6:  MOVWF  02
00EB8:  RLCF   x26,W
00EBA:  MOVWF  03
00EBC:  MOVF   02,W
00EBE:  MOVFF  03,FF7
00EC2:  MOVLB  0
00EC4:  CALL   01AC
00EC8:  TBLRD*+
00ECA:  MOVFF  FF5,03
00ECE:  MOVLB  6
00ED0:  XORWF  x23,W
00ED2:  MOVWF  00
00ED4:  MOVF   03,W
00ED6:  XORWF  x24,W
00ED8:  MOVWF  03
00EDA:  MOVFF  00,01
00EDE:  MOVWF  02
00EE0:  MOVLB  0
00EE2:  RETURN 0
.................... } 
....................  
.................... uint16_t fcs_fcs16_ISR(uint16_t fcs, uint8_t data) 
.................... { 
....................    return (fcs >> 8) ^ fcstab[(fcs ^ data) & 0xff]; 
*
00A40:  MOVFF  626,628
00A44:  MOVLB  6
00A46:  CLRF   x29
00A48:  MOVF   x25,W
00A4A:  XORWF  x27,W
00A4C:  MOVWF  x2A
00A4E:  CLRF   x2B
00A50:  BCF    FD8.0
00A52:  RLCF   x2A,W
00A54:  MOVWF  02
00A56:  RLCF   x2B,W
00A58:  MOVWF  03
00A5A:  MOVF   02,W
00A5C:  MOVFF  03,FF7
00A60:  MOVLB  0
00A62:  CALL   01AC
00A66:  TBLRD*+
00A68:  MOVFF  FF5,03
00A6C:  MOVLB  6
00A6E:  XORWF  x28,W
00A70:  MOVWF  00
00A72:  MOVF   03,W
00A74:  XORWF  x29,W
00A76:  MOVWF  03
00A78:  MOVFF  00,01
00A7C:  MOVWF  02
00A7E:  MOVLB  0
00A80:  GOTO   0AB6 (RETURN)
.................... } 
....................  
.................... static uint16_t fcs_calc(uint8_t* p, uint16_t size) 
.................... { 
.................... /* fcs_calc() 
....................  * 
....................  * Calculate the 2 byte CRC-16 value given a buffer. 
....................  * 
....................  * Returns: 
....................  *      2 byte CRC-16 value 
....................  */ 
....................     uint16_t    fcs = 0; 
....................     fcs = FCS_INITIAL_FCS16; 
....................     while (size) { 
....................         fcs = fcs_fcs16(fcs, *p++); 
....................         size--; 
....................     } 
....................     return ~fcs; /* add 1's complement */ 
.................... } 
....................  
.................... static uint16_t fcs_calc_ISR(uint8_t* p, uint16_t size) 
00A84:  MOVLB  6
00A86:  CLRF   x23
00A88:  CLRF   x22
.................... { 
....................     uint16_t    fcs = 0; 
....................     fcs = FCS_INITIAL_FCS16; 
00A8A:  SETF   x23
00A8C:  SETF   x22
....................     while (size) { 
00A8E:  MOVF   x20,W
00A90:  IORWF  x21,W
00A92:  BZ    0ACA
....................         fcs = fcs_fcs16_ISR(fcs, *p++); 
00A94:  MOVFF  61F,03
00A98:  MOVF   x1E,W
00A9A:  INCF   x1E,F
00A9C:  BTFSC  FD8.2
00A9E:  INCF   x1F,F
00AA0:  MOVWF  FE9
00AA2:  MOVFF  03,FEA
00AA6:  MOVFF  FEF,627
00AAA:  MOVFF  623,626
00AAE:  MOVFF  622,625
00AB2:  MOVLB  0
00AB4:  BRA    0A40
00AB6:  MOVFF  02,623
00ABA:  MOVFF  01,622
....................         size--; 
00ABE:  MOVLB  6
00AC0:  MOVF   x20,W
00AC2:  BTFSC  FD8.2
00AC4:  DECF   x21,F
00AC6:  DECF   x20,F
00AC8:  BRA    0A8E
....................     } 
....................     return ~fcs; /* add 1's complement */ 
00ACA:  MOVFF  623,03
00ACE:  COMF   03,F
00AD0:  MOVF   x22,W
00AD2:  XORLW  FF
00AD4:  MOVWF  01
00AD6:  MOVFF  03,02
00ADA:  MOVLB  0
00ADC:  GOTO   0BFA (RETURN)
.................... } 
....................  
.................... uint8_t deal_with_packet(void) 
.................... { 
....................    uint8_t  command_id_received; 
....................    uint16_t mgr_msgSEQ; 
....................    uint32_t temp_uint32; 
....................    // clear out for use as NACK bitfield each time 
....................    temp_uint32 = 0; 
*
07334:  MOVLB  5
07336:  CLRF   x51
07338:  CLRF   x50
0733A:  CLRF   x4F
0733C:  CLRF   x4E
....................    static struct CommandQueueItem command_queue_item; 
....................    static struct SprinklerZoneSettingsItem sprinkler_zone_settings_item; 
....................    &command_queue_item.sprinkler_settings = &sprinkler_zone_settings_item; 
0733E:  MOVLW  05
07340:  MOVWF  x31
07342:  MOVLW  34
07344:  MOVWF  x30
....................     
....................    // This Dust-recommended prepend for messages (both from manager to mote and 
....................    //    from mote to manager) ensures that we do not conflict with any future 
....................    //    Hart-related aspects.  
....................     
....................    // This prepend is in the same spot for messages going either direction 
....................    // Return with an error if any char is incorrect 
....................    if ((payload_buff[0] != 0x00) || (payload_buff[1] != 0x00) ||              \ 
....................       (payload_buff[2] != 0xFC) || (payload_buff[3] != 0x12)) 
07346:  MOVLB  2
07348:  MOVF   xF3,F
0734A:  BNZ   735C
0734C:  MOVF   xF4,F
0734E:  BNZ   735C
07350:  MOVF   xF5,W
07352:  SUBLW  FC
07354:  BNZ   735C
07356:  MOVF   xF6,W
07358:  SUBLW  12
0735A:  BZ    7364
....................    {    
....................       return ERR_BAD_PAYLOAD; 
0735C:  MOVLW  F9
0735E:  MOVWF  01
07360:  GOTO   81F2
....................    } 
....................     
....................    // The mgr_msgSEQ, a sequence number used by the manager software to identify 
....................    //    messages which are ACK'd or NACK'd always follows the prepend. 
....................    mgr_msgSEQ = make16(payload_buff[5],payload_buff[4]); 
07364:  MOVFF  2F8,54D
07368:  MOVFF  2F7,54C
....................     
....................    // Then comes the msg_rcvd identifier which is the packet's intent, 
....................    //    such as 'give me a full report,' or 'do a warm start.' 
....................    // We leave payload_buff[6] alone so the command ID is identical for the  
....................    //    response message 
....................    command_id_received = payload_buff[6]; 
0736C:  MOVFF  2F9,54B
....................   
....................    // Switch for sorting through different messages recieved 
....................    switch (command_id_received) 
07370:  MOVLW  01
07372:  MOVLB  5
07374:  SUBWF  x4B,W
07376:  ADDLW  BA
07378:  BTFSC  FD8.0
0737A:  GOTO   81F0
0737E:  ADDLW  46
07380:  MOVLB  0
07382:  GOTO   81F8
....................    { 
....................    // Manager ACKs or NACKs unsolicited messages from micro to manager such as: 
....................    //    a. Message at startup 
....................    //    b. ERROR messages 
....................    //    c. Valve calibrate response 
....................    //    d. Bulk data dump 
....................     
.................... //////// Manager ACKs/NACKs//////// 
....................       // Manager ACKs 
....................       case MSG_MGR_ACK: 
....................          // clear off unsolicited message of proper msgSEQ 
....................          REMOVE_MESSAGE_QUEUE_MACRO(mgr_msgSEQ); 
07386:  BCF    F7A.1
07388:  MOVFF  54D,553
0738C:  MOVFF  54C,552
07390:  GOTO   5E54
07394:  BSF    F7A.1
....................          break; 
07396:  MOVLB  5
07398:  GOTO   81F0
....................                                                         
....................       // Manager NACKs    
....................       case MSG_MGR_NACK: 
....................          // Do nothing. Messages will get resent as if it never got acked by 
....................          //    manager 
....................          break;    
0739C:  MOVLB  5
0739E:  GOTO   81F0
....................        
.................... //////// Report Requests//////// 
....................       // Manager requests a full report 
....................       case MSG_MGR_FULL_REPORT: 
....................          send_full_report(command_id_received, mgr_msgSEQ);   
073A2:  MOVFF  54B,552
073A6:  MOVFF  54D,554
073AA:  MOVFF  54C,553
073AE:  CALL   6426
....................          break; 
073B2:  MOVLB  5
073B4:  GOTO   81F0
....................       // Manager requests a health report 
....................       case MSG_MGR_HEALTH_REPORT: 
....................          send_health_report(command_id_received, mgr_msgSEQ); 
073B8:  MOVFF  54B,552
073BC:  MOVFF  54D,554
073C0:  MOVFF  54C,553
073C4:  GOTO   6740
....................          break; 
073C8:  MOVLB  5
073CA:  GOTO   81F0
....................       // Manager requests a valve report 
....................       case MSG_MGR_VALVE_REPORT: 
....................          send_valve_report(command_id_received, mgr_msgSEQ); 
073CE:  MOVFF  54B,552
073D2:  MOVFF  54D,554
073D6:  MOVFF  54C,553
073DA:  CALL   67C6
....................          break; 
073DE:  MOVLB  5
073E0:  GOTO   81F0
....................        
.................... //////// Restart/Shutdown Commands////////                                            
....................       // Manager requests a warm restart (micro reboots) 
....................       case MSG_MGR_WARM_RESTART: 
....................          send_ack(command_id_received, mgr_msgSEQ); 
073E4:  MOVFF  54B,552
073E8:  MOVFF  54D,554
073EC:  MOVFF  54C,553
073F0:  CALL   68FA
....................          // set the shutdown cause 
....................          global_shutdown_cause = WARM_RESTART_REQUEST; 
073F4:  MOVLW  09
073F6:  MOVWF  4D
....................          // save the shutdown/restart reason in EEPROM 
....................          write_ee1(EE_RESTART_CAUSE, global_shutdown_cause); 
073F8:  MOVLB  5
073FA:  CLRF   x55
073FC:  MOVLW  02
073FE:  MOVWF  x54
07400:  MOVFF  4D,556
07404:  MOVLB  0
07406:  CALL   3424
....................          // restart micro                                                         
....................          PUSH_TIME_QUEUE_MACRO(global_rtc_time + 5, CPU_RESET);  
0740A:  BCF    F7A.1
0740C:  MOVLW  05
0740E:  ADDWF  x85,W
07410:  MOVLB  5
07412:  MOVWF  x52
07414:  MOVLW  00
07416:  MOVLB  0
07418:  ADDWFC x86,W
0741A:  MOVLB  5
0741C:  MOVWF  x53
0741E:  MOVLW  00
07420:  MOVLB  0
07422:  ADDWFC x87,W
07424:  MOVLB  5
07426:  MOVWF  x54
07428:  MOVLW  00
0742A:  MOVLB  0
0742C:  ADDWFC x88,W
0742E:  MOVLB  5
07430:  MOVWF  x55
07432:  MOVWF  x59
07434:  MOVFF  554,558
07438:  MOVFF  553,557
0743C:  MOVFF  552,556
07440:  MOVLW  F0
07442:  MOVWF  x5A
07444:  MOVLB  0
07446:  CALL   44A0
0744A:  BSF    F7A.1
....................          break;  
0744C:  MOVLB  5
0744E:  GOTO   81F0
....................       // Manager requests a cold restart (mote and micro reboot)   
....................       case MSG_MGR_COLD_RESTART: 
....................          send_ack(command_id_received, mgr_msgSEQ); 
07452:  MOVFF  54B,552
07456:  MOVFF  54D,554
0745A:  MOVFF  54C,553
0745E:  CALL   68FA
....................          // set the shutdown cause 
....................          global_shutdown_cause = COLD_RESTART_REQUEST; 
07462:  MOVLW  0A
07464:  MOVWF  4D
....................          // save the shutdown/restart reason in EEPROM 
....................          write_ee1(EE_RESTART_CAUSE, global_shutdown_cause); 
07466:  MOVLB  5
07468:  CLRF   x55
0746A:  MOVLW  02
0746C:  MOVWF  x54
0746E:  MOVFF  4D,556
07472:  MOVLB  0
07474:  CALL   3424
....................          // restart micro 
....................          PUSH_TIME_QUEUE_MACRO(global_rtc_time + 5, CPU_RESET); 
07478:  BCF    F7A.1
0747A:  MOVLW  05
0747C:  ADDWF  x85,W
0747E:  MOVLB  5
07480:  MOVWF  x52
07482:  MOVLW  00
07484:  MOVLB  0
07486:  ADDWFC x86,W
07488:  MOVLB  5
0748A:  MOVWF  x53
0748C:  MOVLW  00
0748E:  MOVLB  0
07490:  ADDWFC x87,W
07492:  MOVLB  5
07494:  MOVWF  x54
07496:  MOVLW  00
07498:  MOVLB  0
0749A:  ADDWFC x88,W
0749C:  MOVLB  5
0749E:  MOVWF  x55
074A0:  MOVWF  x59
074A2:  MOVFF  554,558
074A6:  MOVFF  553,557
074AA:  MOVFF  552,556
074AE:  MOVLW  F0
074B0:  MOVWF  x5A
074B2:  MOVLB  0
074B4:  CALL   44A0
074B8:  BSF    F7A.1
....................          break; 
074BA:  MOVLB  5
074BC:  GOTO   81F0
....................       // Manager requests a rejoin (restart mote and rejoin)  
....................       case MSG_MGR_FORCE_REJOIN: 
....................          send_ack(command_id_received, mgr_msgSEQ); 
074C0:  MOVFF  54B,552
074C4:  MOVFF  54D,554
074C8:  MOVFF  54C,553
074CC:  CALL   68FA
....................          // schedule rejoin/restart mote 
....................          PUSH_TIME_QUEUE_MACRO(global_rtc_time + 5, RESET_MOTE); 
074D0:  BCF    F7A.1
074D2:  MOVLW  05
074D4:  ADDWF  x85,W
074D6:  MOVLB  5
074D8:  MOVWF  x52
074DA:  MOVLW  00
074DC:  MOVLB  0
074DE:  ADDWFC x86,W
074E0:  MOVLB  5
074E2:  MOVWF  x53
074E4:  MOVLW  00
074E6:  MOVLB  0
074E8:  ADDWFC x87,W
074EA:  MOVLB  5
074EC:  MOVWF  x54
074EE:  MOVLW  00
074F0:  MOVLB  0
074F2:  ADDWFC x88,W
074F4:  MOVLB  5
074F6:  MOVWF  x55
074F8:  MOVWF  x59
074FA:  MOVFF  554,558
074FE:  MOVFF  553,557
07502:  MOVFF  552,556
07506:  MOVLW  11
07508:  MOVWF  x5A
0750A:  MOVLB  0
0750C:  CALL   44A0
07510:  BSF    F7A.1
....................          break; 
07512:  MOVLB  5
07514:  GOTO   81F0
....................       // Manager requests a shutdown (deep sleep, move valve to specified position 
....................       //    and at a certain time) 
....................       case MSG_MGR_SHUTDOWN: 
....................          send_ack(command_id_received, mgr_msgSEQ); 
07518:  MOVFF  54B,552
0751C:  MOVFF  54D,554
07520:  MOVFF  54C,553
07524:  CALL   68FA
....................          // set valve posisition and move valve 
....................          global_valve_position_set_value = make16(payload_buff[12], payload_buff[11]); 
07528:  MOVFF  2FF,C4
0752C:  MOVFF  2FE,C3
....................          PUSH_PRIORITY_QUEUE_MACRO(MOVE_VALVE); 
07530:  BCF    F7A.1
07532:  MOVLW  40
07534:  MOVLB  5
07536:  MOVWF  x52
07538:  MOVLB  0
0753A:  CALL   4748
0753E:  BSF    F7A.1
....................          // set the shutdown cause 
....................          global_shutdown_cause = MANAGER_SHUTDOWN_REQUEST; 
07540:  MOVLW  0B
07542:  MOVWF  4D
....................          // figure out the shutdown time in rtc time (given in utc time or 0 for NOW) 
....................          // temp_uint32 is now the utc shutdown time 
....................          temp_uint32 = make32(payload_buff[10], payload_buff[9],payload_buff[8], payload_buff[7]); 
07544:  MOVFF  2FD,551
07548:  MOVFF  2FC,550
0754C:  MOVFF  2FB,54F
07550:  MOVFF  2FA,54E
....................           
....................          // if shutdown isn't now (time = 0), utc_shutdown_time + rtc_time - utc_time = rtc_shutdown_time 
....................          if (temp_uint32 != 0) 
07554:  MOVLB  5
07556:  MOVF   x4E,F
07558:  BNZ   7566
0755A:  MOVF   x4F,F
0755C:  BNZ   7566
0755E:  MOVF   x50,F
07560:  BNZ   7566
07562:  MOVF   x51,F
07564:  BZ    75D4
....................          { 
....................             temp_uint32 += global_rtc_time - global_utc_time; 
07566:  MOVLB  0
07568:  MOVF   x89,W
0756A:  SUBWF  x85,W
0756C:  MOVWF  00
0756E:  MOVF   x8A,W
07570:  SUBWFB x86,W
07572:  MOVWF  01
07574:  MOVF   x8B,W
07576:  SUBWFB x87,W
07578:  MOVWF  02
0757A:  MOVF   x8C,W
0757C:  SUBWFB x88,W
0757E:  MOVWF  03
07580:  MOVF   00,W
07582:  MOVLB  5
07584:  ADDWF  x4E,F
07586:  MOVF   01,W
07588:  ADDWFC x4F,F
0758A:  MOVF   02,W
0758C:  ADDWFC x50,F
0758E:  MOVF   03,W
07590:  ADDWFC x51,F
....................             // in some rare cases, this simple math might give a huge number (more than an hour past current rtc 
....................             //    time.) In that case, time should be now. 
....................             // The rare case would be when there is latency in the network more than the  
....................             //    elapsed rtc time. 
....................             if (temp_uint32 > (global_rtc_time + 3600)) 
07592:  MOVLW  10
07594:  MOVLB  0
07596:  ADDWF  x85,W
07598:  MOVWF  00
0759A:  MOVLW  0E
0759C:  ADDWFC x86,W
0759E:  MOVWF  01
075A0:  MOVLW  00
075A2:  ADDWFC x87,W
075A4:  MOVWF  02
075A6:  MOVLW  00
075A8:  ADDWFC x88,W
075AA:  MOVWF  03
075AC:  MOVLB  5
075AE:  SUBWF  x51,W
075B0:  BNC   75D2
075B2:  BNZ   75CA
075B4:  MOVF   02,W
075B6:  SUBWF  x50,W
075B8:  BNC   75D2
075BA:  BNZ   75CA
075BC:  MOVF   01,W
075BE:  SUBWF  x4F,W
075C0:  BNC   75D2
075C2:  BNZ   75CA
075C4:  MOVF   x4E,W
075C6:  SUBWF  00,W
075C8:  BC    75D2
....................             {  
....................                temp_uint32 = 0; 
075CA:  CLRF   x51
075CC:  CLRF   x50
075CE:  CLRF   x4F
075D0:  CLRF   x4E
....................             } 
....................          } 
075D2:  BRA    75E4
....................          // shutdown time is now (sent time is 0) 
....................          else 
....................          { 
....................             temp_uint32 = global_rtc_time; 
075D4:  MOVFF  88,551
075D8:  MOVFF  87,550
075DC:  MOVFF  86,54F
075E0:  MOVFF  85,54E
....................          }                                   
....................          // schedule the shutdown 
....................          PUSH_TIME_QUEUE_MACRO(temp_uint32, SHUTDOWN_SYSTEM); 
075E4:  BCF    F7A.1
075E6:  MOVFF  551,559
075EA:  MOVFF  550,558
075EE:  MOVFF  54F,557
075F2:  MOVFF  54E,556
075F6:  MOVLW  F1
075F8:  MOVWF  x5A
075FA:  MOVLB  0
075FC:  CALL   44A0
07600:  BSF    F7A.1
....................          break; 
07602:  MOVLB  5
07604:  GOTO   81F0
....................  
.................... //////// Erraneous Commands//////// 
....................       case MSG_MGR_UPDATE_SP_NUM: 
....................          // update sprinkler number 
....................          // check if number is in a valid range, NACK if no good. 
....................          global_sprinkler_num = make16(payload_buff[8], payload_buff[7]); 
07608:  MOVFF  2FB,96
0760C:  MOVFF  2FA,95
....................          // write sprinkler number 
....................          write_ee2(EE_SPRINKLER_NUM, global_sprinkler_num); 
07610:  MOVLB  5
07612:  CLRF   x57
07614:  CLRF   x56
07616:  MOVFF  96,559
0761A:  MOVFF  95,558
0761E:  MOVLB  0
07620:  CALL   3388
....................          send_update_sp_num_response(command_id_received, mgr_msgSEQ); 
07624:  MOVFF  54B,552
07628:  MOVFF  54D,554
0762C:  MOVFF  54C,553
07630:  GOTO   6920
....................          break; 
07634:  MOVLB  5
07636:  GOTO   81F0
....................       case MSG_MGR_CAL_VALVE: 
....................          send_ack(command_id_received, mgr_msgSEQ);             
0763A:  MOVFF  54B,552
0763E:  MOVFF  54D,554
07642:  MOVFF  54C,553
07646:  CALL   68FA
....................          // schedule calibrate valve 
....................          PUSH_PRIORITY_QUEUE_MACRO(CALIBRATE_VALVE_1);    
0764A:  BCF    F7A.1
0764C:  MOVLW  31
0764E:  MOVLB  5
07650:  MOVWF  x52
07652:  MOVLB  0
07654:  CALL   4748
07658:  BSF    F7A.1
....................          break; 
0765A:  MOVLB  5
0765C:  GOTO   81F0
....................       case MSG_MGR_CAL_FSR:          
....................          if (read_system_state() != SYSTEM_RUN)    
07660:  CALL   1F4A
07664:  MOVF   01,W
07666:  SUBLW  02
07668:  BZ    7670
....................          {        
....................             temp_uint32 |= NACK_BITFIELD_INCOMPATIBLE_STATE; 
0766A:  MOVLB  5
0766C:  BSF    x4E.5
0766E:  MOVLB  0
....................          }                                                     
....................          if (global_valve_position == VLV_POSITION_UNKNOWN) 
07670:  INCFSZ xC1,W
07672:  BRA    767E
07674:  INCFSZ xC2,W
07676:  BRA    767E
....................          { 
....................             temp_uint32 |= NACK_BITFIELD_VLV_POSITION_UNKNOWN;     
07678:  MOVLB  5
0767A:  BSF    x4E.0
0767C:  MOVLB  0
....................          } 
....................          if (!is_valve_position_valid(make16(payload_buff[8], payload_buff[7])))    
0767E:  MOVFF  2FB,553
07682:  MOVFF  2FA,552
07686:  MOVFF  2FB,555
0768A:  MOVFF  2FA,554
0768E:  CALL   6954
07692:  MOVF   01,F
07694:  BNZ   769C
....................          {                                                                       
....................             temp_uint32 |= NACK_BITFIELD_INVALID_VLV_SETTING;                     
07696:  MOVLB  5
07698:  BSF    x4E.1
0769A:  MOVLB  0
....................          } 
....................          // if the NACK bitfield contains anything, send the nack instead of proceeding 
....................          if (temp_uint32 != 0)          
0769C:  MOVLB  5
0769E:  MOVF   x4E,F
076A0:  BNZ   76AE
076A2:  MOVF   x4F,F
076A4:  BNZ   76AE
076A6:  MOVF   x50,F
076A8:  BNZ   76AE
076AA:  MOVF   x51,F
076AC:  BZ    76D4
....................          { 
....................             send_nack(command_id_received, mgr_msgSEQ, temp_uint32); 
076AE:  MOVFF  54B,552
076B2:  MOVFF  54D,554
076B6:  MOVFF  54C,553
076BA:  MOVFF  551,558
076BE:  MOVFF  550,557
076C2:  MOVFF  54F,556
076C6:  MOVFF  54E,555
076CA:  MOVLB  0
076CC:  CALL   6976
....................          }                                             
076D0:  BRA    76F6
076D2:  MOVLB  5
....................          else                                              
....................          {                  
....................             send_ack(command_id_received, mgr_msgSEQ); 
076D4:  MOVFF  54B,552
076D8:  MOVFF  54D,554
076DC:  MOVFF  54C,553
076E0:  MOVLB  0
076E2:  CALL   68FA
....................             // schedule calibrate valve                    
....................             PUSH_PRIORITY_QUEUE_MACRO(CALIBRATE_FSR_1);   
076E6:  BCF    F7A.1
076E8:  MOVLW  37
076EA:  MOVLB  5
076EC:  MOVWF  x52
076EE:  MOVLB  0
076F0:  CALL   4748
076F4:  BSF    F7A.1
....................          } 
....................          break; 
076F6:  MOVLB  5
076F8:  GOTO   81F0
....................           
....................       case MSG_MGR_AQUIRE_GPS:  
....................          send_ack(command_id_received, mgr_msgSEQ); 
076FC:  MOVFF  54B,552
07700:  MOVFF  54D,554
07704:  MOVFF  54C,553
07708:  CALL   68FA
....................          // start gps point aquisition                         
....................          PUSH_PRIORITY_QUEUE_MACRO(START_GPS_AQUISITION);               
0770C:  BCF    F7A.1
0770E:  MOVLW  50
07710:  MOVLB  5
07712:  MOVWF  x52
07714:  MOVLB  0
07716:  CALL   4748
0771A:  BSF    F7A.1
....................          break; 
0771C:  MOVLB  5
0771E:  GOTO   81F0
....................                                                                           
....................       case MSG_MGR_UPDATE_EEPROM:                                
....................          LCD_clear();                                                 
07722:  CALL   5E1A
....................          LCD_place_uint16(make16(payload_buff[8], payload_buff[7]),0,0,5);   
07726:  MOVFF  2FB,553
0772A:  MOVFF  2FA,552
0772E:  MOVFF  2FB,564
07732:  MOVFF  2FA,563
07736:  MOVLB  5
07738:  CLRF   x65
0773A:  CLRF   x66
0773C:  MOVLW  05
0773E:  MOVWF  x67
07740:  MOVLB  0
07742:  CALL   6A3C
....................          LCD_place_uint8(payload_buff[9],0,7,3);          
07746:  MOVFF  2FC,564
0774A:  MOVLB  5
0774C:  CLRF   x65
0774E:  MOVLW  07
07750:  MOVWF  x66
07752:  MOVLW  03
07754:  MOVWF  x67
07756:  MOVLB  0
07758:  CALL   6B16
....................          LCD_place_uint32(make32(payload_buff[13],payload_buff[12],payload_buff[11],payload_buff[10]),1,0,8); 
0775C:  MOVFF  300,555
07760:  MOVFF  2FF,554
07764:  MOVFF  2FE,553
07768:  MOVFF  2FD,552
0776C:  MOVFF  300,559
07770:  MOVFF  2FF,558
07774:  MOVFF  2FE,557
07778:  MOVFF  2FD,556
0777C:  MOVLW  01
0777E:  MOVLB  5
07780:  MOVWF  x5A
07782:  CLRF   x5B
07784:  MOVLW  08
07786:  MOVWF  x5C
07788:  MOVLB  0
0778A:  CALL   6BAA
....................          global_skip_lcd_update_count = 3;         
0778E:  MOVLW  03
07790:  MOVWF  x83
....................                                                                                                  
....................          // if eeprom location is outside of the valid range                                      
....................          //    (not in between start and end location (taking into account the number of bytes))    
....................          if ((make16(payload_buff[8], payload_buff[7]) < EE_START_LOCATION) ||                        \                      
....................             ((make16(payload_buff[8], payload_buff[7]) + payload_buff[9] - 1) > EE_END_LOCATION) ||   \                                                
....................             // also check if number of bytes != 1, 2, or 4 
....................             (!((payload_buff[9] == 1) || (payload_buff[9] == 2) || (payload_buff[9] == 4))))        
07792:  MOVFF  2FB,553
07796:  MOVFF  2FA,552
0779A:  MOVLB  2
0779C:  MOVF   xFC,W
0779E:  MOVLB  5
077A0:  ADDWF  x52,F
077A2:  MOVLW  00
077A4:  ADDWFC x53,F
077A6:  MOVLW  01
077A8:  SUBWF  x52,F
077AA:  MOVLW  00
077AC:  SUBWFB x53,F
077AE:  BNZ   77CC
077B0:  MOVF   x52,W
077B2:  SUBLW  2F
077B4:  BNC   77CC
077B6:  MOVLB  2
077B8:  DECFSZ xFC,W
077BA:  BRA    77BE
077BC:  BRA    77EC
077BE:  MOVF   xFC,W
077C0:  SUBLW  02
077C2:  BZ    77EC
077C4:  MOVF   xFC,W
077C6:  SUBLW  04
077C8:  BZ    77EC
077CA:  MOVLB  5
....................          {                                                                                         
....................             send_nack(command_id_received, mgr_msgSEQ, NACK_BITFIELD_INVALID_EEPROM_SETTINGS);     
077CC:  MOVFF  54B,552
077D0:  MOVFF  54D,554
077D4:  MOVFF  54C,553
077D8:  CLRF   x58
077DA:  CLRF   x57
077DC:  MOVLW  01
077DE:  MOVWF  x56
077E0:  CLRF   x55
077E2:  MOVLB  0
077E4:  CALL   6976
....................          }                                                                                            
077E8:  BRA    788E
077EA:  MOVLB  2
....................          // valid location and number of bytes                      
....................          else                                    
....................          {                                                                                                 
....................             if (payload_buff[9] == 1) 
077EC:  DECFSZ xFC,W
077EE:  BRA    780E
....................             { 
....................                write_ee1(make16(payload_buff[8], payload_buff[7]),payload_buff[10]); 
077F0:  MOVFF  2FB,553
077F4:  MOVFF  2FA,552
077F8:  MOVFF  2FB,555
077FC:  MOVFF  2FA,554
07800:  MOVFF  2FD,556
07804:  MOVLB  0
07806:  CALL   3424
....................             } 
0780A:  BRA    787A
0780C:  MOVLB  2
....................             else if (payload_buff[9] == 2)                
0780E:  MOVF   xFC,W
07810:  SUBLW  02
07812:  BNZ   783E
....................             {                                           
....................                write_ee2(make16(payload_buff[8], payload_buff[7]),make16(payload_buff[11],payload_buff[10])); 
07814:  MOVFF  2FB,553
07818:  MOVFF  2FA,552
0781C:  MOVFF  2FE,555
07820:  MOVFF  2FD,554
07824:  MOVFF  2FB,557
07828:  MOVFF  2FA,556
0782C:  MOVFF  2FE,559
07830:  MOVFF  2FD,558
07834:  MOVLB  0
07836:  CALL   3388
....................             } 
0783A:  BRA    787A
0783C:  MOVLB  2
....................             else if (payload_buff[9] == 4)                                            
0783E:  MOVF   xFC,W
07840:  SUBLW  04
07842:  BNZ   787C
....................             { 
....................                write_ee4(make16(payload_buff[8], payload_buff[7]),make32(payload_buff[13],payload_buff[12],payload_buff[11],payload_buff[10])); 
07844:  MOVFF  2FB,553
07848:  MOVFF  2FA,552
0784C:  MOVFF  300,557
07850:  MOVFF  2FF,556
07854:  MOVFF  2FE,555
07858:  MOVFF  2FD,554
0785C:  MOVFF  2FB,559
07860:  MOVFF  2FA,558
07864:  MOVFF  300,55D
07868:  MOVFF  2FF,55C
0786C:  MOVFF  2FE,55B
07870:  MOVFF  2FD,55A
07874:  MOVLB  0
07876:  CALL   6CCC
0787A:  MOVLB  2
....................             } 
....................             send_ack(command_id_received, mgr_msgSEQ); 
0787C:  MOVFF  54B,552
07880:  MOVFF  54D,554
07884:  MOVFF  54C,553
07888:  MOVLB  0
0788A:  CALL   68FA
....................          } 
....................          break;  
0788E:  MOVLB  5
07890:  GOTO   81F0
....................        
....................       case MSG_MGR_READ_EEPROM:                                                                              
....................          // if eeprom location is outside of the valid range                                      
....................          //    (not in between start and end location (taking into account the number of bytes))    
....................          if ((make16(payload_buff[8], payload_buff[7]) < EE_START_LOCATION) ||                        \                      
....................             ((make16(payload_buff[8], payload_buff[7]) + payload_buff[9] - 1) > EE_END_LOCATION) ||   \                                                
....................             // also check if number of bytes != 1, 2, or 4 
....................             (!((payload_buff[9] == 1) || (payload_buff[9] == 2) || (payload_buff[9] == 4))))        
07894:  MOVFF  2FB,553
07898:  MOVFF  2FA,552
0789C:  MOVLB  2
0789E:  MOVF   xFC,W
078A0:  MOVLB  5
078A2:  ADDWF  x52,F
078A4:  MOVLW  00
078A6:  ADDWFC x53,F
078A8:  MOVLW  01
078AA:  SUBWF  x52,F
078AC:  MOVLW  00
078AE:  SUBWFB x53,F
078B0:  BNZ   78CE
078B2:  MOVF   x52,W
078B4:  SUBLW  2F
078B6:  BNC   78CE
078B8:  MOVLB  2
078BA:  DECFSZ xFC,W
078BC:  BRA    78C0
078BE:  BRA    78EE
078C0:  MOVF   xFC,W
078C2:  SUBLW  02
078C4:  BZ    78EE
078C6:  MOVF   xFC,W
078C8:  SUBLW  04
078CA:  BZ    78EE
078CC:  MOVLB  5
....................          {                                                                                         
....................             send_nack(command_id_received, mgr_msgSEQ, NACK_BITFIELD_INVALID_EEPROM_SETTINGS);     
078CE:  MOVFF  54B,552
078D2:  MOVFF  54D,554
078D6:  MOVFF  54C,553
078DA:  CLRF   x58
078DC:  CLRF   x57
078DE:  MOVLW  01
078E0:  MOVWF  x56
078E2:  CLRF   x55
078E4:  MOVLB  0
078E6:  CALL   6976
....................          }                                                                                            
078EA:  BRA    79A6
078EC:  MOVLB  2
....................          // valid location and number of bytes                      
....................          else                                    
....................          {                                                                                                 
....................             if (payload_buff[9] == 1) 
078EE:  DECFSZ xFC,W
078F0:  BRA    7918
....................             {                                 
....................                temp_uint32 = read_ee1(make16(payload_buff[8], payload_buff[7])); 
078F2:  MOVFF  2FB,553
078F6:  MOVFF  2FA,552
078FA:  MOVFF  2FB,555
078FE:  MOVFF  2FA,554
07902:  MOVLB  0
07904:  CALL   3402
07908:  MOVLB  5
0790A:  CLRF   x51
0790C:  CLRF   x50
0790E:  CLRF   x4F
07910:  MOVFF  01,54E
....................             } 
07914:  BRA    7974
07916:  MOVLB  2
....................             else if (payload_buff[9] == 2)                
07918:  MOVF   xFC,W
0791A:  SUBLW  02
0791C:  BNZ   7946
....................             {                                           
....................                temp_uint32 = read_ee2(make16(payload_buff[8], payload_buff[7]));        
0791E:  MOVFF  2FB,553
07922:  MOVFF  2FA,552
07926:  MOVFF  2FB,555
0792A:  MOVFF  2FA,554
0792E:  MOVLB  0
07930:  CALL   3332
07934:  MOVLB  5
07936:  CLRF   x51
07938:  CLRF   x50
0793A:  MOVFF  02,54F
0793E:  MOVFF  01,54E
....................             } 
07942:  BRA    7974
07944:  MOVLB  2
....................             else if (payload_buff[9] == 4)                                            
07946:  MOVF   xFC,W
07948:  SUBLW  04
0794A:  BNZ   7972
....................             { 
....................                temp_uint32 = read_ee4(make16(payload_buff[8], payload_buff[7])); 
0794C:  MOVFF  2FB,553
07950:  MOVFF  2FA,552
07954:  MOVFF  2FB,555
07958:  MOVFF  2FA,554
0795C:  MOVLB  0
0795E:  CALL   3456
07962:  MOVFF  03,551
07966:  MOVFF  02,550
0796A:  MOVFF  01,54F
0796E:  MOVFF  00,54E
07972:  MOVLB  5
....................             } 
....................             send_read_eeprom_response(command_id_received, mgr_msgSEQ, make16(payload_buff[8], payload_buff[7]), temp_uint32);   
07974:  MOVFF  2FB,553
07978:  MOVFF  2FA,552
0797C:  MOVFF  54B,554
07980:  MOVFF  54D,556
07984:  MOVFF  54C,555
07988:  MOVFF  2FB,558
0798C:  MOVFF  2FA,557
07990:  MOVFF  551,55C
07994:  MOVFF  550,55B
07998:  MOVFF  54F,55A
0799C:  MOVFF  54E,559
079A0:  MOVLB  0
079A2:  GOTO   6DD2
....................          } 
....................          break; 
079A6:  MOVLB  5
079A8:  GOTO   81F0
....................        
....................       case MSG_MGR_READ_XDCR:                                                     
....................          // if the type1 (fancy expensive all-sensors xdcrs) are connected    
....................          if (global_xcdr_type1_enabled)                                      
079AC:  BTFSS  xA7.2
079AE:  BRA    79D2
....................          {                              
....................             // ack it (yes, because it takes ~50ms for the xdcr to settle, it must be an 
....................             //    unsolicited response that happens later) 
....................             send_ack(command_id_received, mgr_msgSEQ);       
079B0:  MOVFF  54B,552
079B4:  MOVFF  54D,554
079B8:  MOVFF  54C,553
079BC:  CALL   68FA
....................             // schedule calibrate valve                               
....................             PUSH_PRIORITY_QUEUE_MACRO(TAKE_XCDR_MESUREMENT_1);   
079C0:  BCF    F7A.1
079C2:  MOVLW  55
079C4:  MOVLB  5
079C6:  MOVWF  x52
079C8:  MOVLB  0
079CA:  CALL   4748
079CE:  BSF    F7A.1
....................          }                                       
079D0:  BRA    79F8
....................          // if a xdcr isn't connected, then nack it! 
....................          else                                
....................          {   
....................             temp_uint32 |= NACK_BITFIELD_INVALID_HARDWARE; 
079D2:  MOVLB  5
079D4:  BSF    x4E.7
....................             send_nack(command_id_received, mgr_msgSEQ, temp_uint32);   
079D6:  MOVFF  54B,552
079DA:  MOVFF  54D,554
079DE:  MOVFF  54C,553
079E2:  MOVFF  551,558
079E6:  MOVFF  550,557
079EA:  MOVFF  54F,556
079EE:  MOVFF  54E,555
079F2:  MOVLB  0
079F4:  CALL   6976
....................          }        
....................          break;                                          
079F8:  MOVLB  5
079FA:  GOTO   81F0
....................                                                                      
....................           
.................... //////// Run/Test/Demo Commands////////         
....................       case MSG_MGR_RUN_CMD_NO_MOD: 
....................              
....................          if (global_valve_position == VLV_POSITION_UNKNOWN) 
079FE:  INCFSZ xC1,W
07A00:  BRA    7A0C
07A02:  INCFSZ xC2,W
07A04:  BRA    7A0C
....................          { 
....................             temp_uint32 |= NACK_BITFIELD_VLV_POSITION_UNKNOWN; 
07A06:  MOVLB  5
07A08:  BSF    x4E.0
07A0A:  MOVLB  0
....................          } 
....................          if (!is_valve_position_valid(make16(payload_buff[16], payload_buff[15]))) 
07A0C:  MOVFF  303,553
07A10:  MOVFF  302,552
07A14:  MOVFF  303,555
07A18:  MOVFF  302,554
07A1C:  CALL   6954
07A20:  MOVF   01,F
07A22:  BNZ   7A2A
....................          { 
....................             temp_uint32 |= NACK_BITFIELD_INVALID_VLV_SETTING; 
07A24:  MOVLB  5
07A26:  BSF    x4E.1
07A28:  MOVLB  0
....................          } 
....................          if (!is_rpm_setting_valid(make16(payload_buff[18], payload_buff[17]))) 
07A2A:  MOVFF  305,553
07A2E:  MOVFF  304,552
07A32:  MOVFF  305,555
07A36:  MOVFF  304,554
07A3A:  CALL   6E2C
07A3E:  MOVF   01,F
07A40:  BNZ   7A48
....................          { 
....................             temp_uint32 |= NACK_BITFIELD_INVALID_RPM_SETTING; 
07A42:  MOVLB  5
07A44:  BSF    x4E.2
07A46:  MOVLB  0
....................          } 
....................   
....................          // if the NACK bitfield contains anything, send the nack instead of proceeding 
....................          if (temp_uint32 != 0) 
07A48:  MOVLB  5
07A4A:  MOVF   x4E,F
07A4C:  BNZ   7A5A
07A4E:  MOVF   x4F,F
07A50:  BNZ   7A5A
07A52:  MOVF   x50,F
07A54:  BNZ   7A5A
07A56:  MOVF   x51,F
07A58:  BZ    7A80
....................          { 
....................             send_nack(command_id_received, mgr_msgSEQ, temp_uint32);  
07A5A:  MOVFF  54B,552
07A5E:  MOVFF  54D,554
07A62:  MOVFF  54C,553
07A66:  MOVFF  551,558
07A6A:  MOVFF  550,557
07A6E:  MOVFF  54F,556
07A72:  MOVFF  54E,555
07A76:  MOVLB  0
07A78:  CALL   6976
....................          }      
07A7C:  BRA    7B0A
07A7E:  MOVLB  5
....................          // add non-modulated run command to command queue  
....................          else 
....................          { 
....................             push_sprinkler_queue(make32(payload_buff[10],payload_buff[9],payload_buff[8],payload_buff[7]), \ 
....................                make32(payload_buff[14],payload_buff[13],payload_buff[12],payload_buff[11]), \ 
....................                make16(payload_buff[16], payload_buff[15]), make16(payload_buff[18], payload_buff[17]), \ 
....................                0, BRAKE_AND_CHARGE_START); 
07A80:  MOVFF  2FD,555
07A84:  MOVFF  2FC,554
07A88:  MOVFF  2FB,553
07A8C:  MOVFF  2FA,552
07A90:  MOVFF  301,559
07A94:  MOVFF  300,558
07A98:  MOVFF  2FF,557
07A9C:  MOVFF  2FE,556
07AA0:  MOVFF  303,55B
07AA4:  MOVFF  302,55A
07AA8:  MOVFF  305,55D
07AAC:  MOVFF  304,55C
07AB0:  MOVFF  2FD,561
07AB4:  MOVFF  2FC,560
07AB8:  MOVFF  2FB,55F
07ABC:  MOVFF  2FA,55E
07AC0:  MOVFF  301,565
07AC4:  MOVFF  300,564
07AC8:  MOVFF  2FF,563
07ACC:  MOVFF  2FE,562
07AD0:  MOVFF  303,567
07AD4:  MOVFF  302,566
07AD8:  MOVFF  305,569
07ADC:  MOVFF  304,568
07AE0:  CLRF   x6A
07AE2:  CLRF   x6B
07AE4:  MOVLB  0
07AE6:  CALL   6E5A
....................              
....................             // have the micro check the battery to determine the proper charging 
....................             PUSH_PRIORITY_QUEUE_MACRO(CHECK_BATTERY_STATE);  
07AEA:  BCF    F7A.1
07AEC:  MOVLW  A1
07AEE:  MOVLB  5
07AF0:  MOVWF  x52
07AF2:  MOVLB  0
07AF4:  CALL   4748
07AF8:  BSF    F7A.1
....................             send_sprinkler_cmd_response(command_id_received, mgr_msgSEQ); 
07AFA:  MOVFF  54B,552
07AFE:  MOVFF  54D,554
07B02:  MOVFF  54C,553
07B06:  GOTO   7098
....................          } 
....................          break; 
07B0A:  MOVLB  5
07B0C:  BRA    81F0
....................           
....................       case MSG_MGR_RUN_CMD_MOD: 
....................          // since this isn't implemented, nack it 
....................          temp_uint32 |= NACK_BITFIELD_INCOMPATIBLE_STATE;   
07B0E:  MOVLB  5
07B10:  BSF    x4E.5
....................          send_nack(command_id_received, mgr_msgSEQ, temp_uint32); 
07B12:  MOVFF  54B,552
07B16:  MOVFF  54D,554
07B1A:  MOVFF  54C,553
07B1E:  MOVFF  551,558
07B22:  MOVFF  550,557
07B26:  MOVFF  54F,556
07B2A:  MOVFF  54E,555
07B2E:  MOVLB  0
07B30:  CALL   6976
....................                               
....................          // add modulated run command to command queue 
....................          // send_sprinkler_cmd_response(command_id_received, mgr_msgSEQ); 
....................          break; 
07B34:  MOVLB  5
07B36:  BRA    81F0
....................                                                    
....................       case MSG_MGR_TEST_NO_RPM_CTRL:    
....................              
....................          // this test added by JG 
....................          if (!is_valve_value_full_open_or_close(make16(payload_buff[8], payload_buff[7]))) 
07B38:  MOVFF  2FB,553
07B3C:  MOVFF  2FA,552
07B40:  MOVFF  2FB,555
07B44:  MOVFF  2FA,554
07B48:  CALL   72AE
07B4C:  MOVF   01,F
07B4E:  BNZ   7B5E
....................          { 
....................             if (global_valve_position == VLV_POSITION_UNKNOWN)   
07B50:  INCFSZ xC1,W
07B52:  BRA    7B5E
07B54:  INCFSZ xC2,W
07B56:  BRA    7B5E
....................             {                                                     
....................                temp_uint32 |= NACK_BITFIELD_VLV_POSITION_UNKNOWN;  
07B58:  MOVLB  5
07B5A:  BSF    x4E.0
07B5C:  MOVLB  0
....................             }                             
....................          }              
....................          if (!is_valve_position_valid(make16(payload_buff[8], payload_buff[7]))) 
07B5E:  MOVFF  2FB,553
07B62:  MOVFF  2FA,552
07B66:  MOVFF  2FB,555
07B6A:  MOVFF  2FA,554
07B6E:  CALL   6954
07B72:  MOVF   01,F
07B74:  BNZ   7B7C
....................          { 
....................             temp_uint32 |= NACK_BITFIELD_INVALID_VLV_SETTING; 
07B76:  MOVLB  5
07B78:  BSF    x4E.1
07B7A:  MOVLB  0
....................          }  
....................          if (!is_brake_duty_valid(make16(payload_buff[10], payload_buff[9]))) 
07B7C:  MOVFF  2FD,553
07B80:  MOVFF  2FC,552
07B84:  MOVFF  2FD,555
07B88:  MOVFF  2FC,554
07B8C:  GOTO   72D2
07B90:  MOVF   01,F
07B92:  BNZ   7B9A
....................          { 
....................             temp_uint32 |= NACK_BITFIELD_INVALID_BRAKE_SETTING; 
07B94:  MOVLB  5
07B96:  BSF    x4E.3
07B98:  MOVLB  0
....................          } 
....................          if (!is_charge_duty_valid(make16(payload_buff[12], payload_buff[11]))) 
07B9A:  MOVFF  2FF,553
07B9E:  MOVFF  2FE,552
07BA2:  MOVFF  2FF,555
07BA6:  MOVFF  2FE,554
07BAA:  GOTO   72F6
07BAE:  MOVF   01,F
07BB0:  BNZ   7BB8
....................          { 
....................             temp_uint32 |= NACK_BITFIELD_INVALID_CHARGE_SETTING; 
07BB2:  MOVLB  5
07BB4:  BSF    x4E.4
07BB6:  MOVLB  0
....................          } 
....................          // if in mppc non-dynamic mode, check mppc 
....................          if ((payload_buff[14] == FALSE) && (!is_mppc_valid(payload_buff[13]))) 
07BB8:  MOVLB  3
07BBA:  MOVF   x01,F
07BBC:  BNZ   7BD8
07BBE:  MOVFF  300,552
07BC2:  MOVLB  0
07BC4:  GOTO   731A
07BC8:  MOVF   01,F
07BCA:  BTFSC  FD8.2
07BCC:  BRA    7BD2
07BCE:  MOVLB  3
07BD0:  BRA    7BD8
....................          { 
....................             temp_uint32 |= NACK_BITFIELD_INVALID_MPPC_SETTING; 
07BD2:  MOVLB  5
07BD4:  BSF    x4F.1
07BD6:  MOVLB  3
....................          } 
....................           
....................          // if the NACK bitfield contains anything, send the nack instead of proceeding 
....................          if (temp_uint32 != 0) 
07BD8:  MOVLB  5
07BDA:  MOVF   x4E,F
07BDC:  BNZ   7BEA
07BDE:  MOVF   x4F,F
07BE0:  BNZ   7BEA
07BE2:  MOVF   x50,F
07BE4:  BNZ   7BEA
07BE6:  MOVF   x51,F
07BE8:  BZ    7C10
....................          { 
....................             send_nack(command_id_received, mgr_msgSEQ, temp_uint32); 
07BEA:  MOVFF  54B,552
07BEE:  MOVFF  54D,554
07BF2:  MOVFF  54C,553
07BF6:  MOVFF  551,558
07BFA:  MOVFF  550,557
07BFE:  MOVFF  54F,556
07C02:  MOVFF  54E,555
07C06:  MOVLB  0
07C08:  CALL   6976
....................          } 
07C0C:  BRA    7D46
07C0E:  MOVLB  5
....................          // add non-modulated run command to command queue  
....................          else 
....................          { 
....................                                                  
....................             // deal with JG-added special cases of commands to fully open or 
....................             //  or fully close the valve in cases whete the valve has not 
....................             //  yet been calibrated 
....................             if ((make16(payload_buff[8], payload_buff[7]) == VLV_POSITION_OPENED) \ 
....................                && (global_valve_position == VLV_POSITION_UNKNOWN)) 
07C10:  MOVFF  2FB,553
07C14:  MOVFF  2FA,552
07C18:  MOVF   x52,F
07C1A:  BNZ   7C4C
07C1C:  MOVF   x53,W
07C1E:  SUBLW  80
07C20:  BNZ   7C4C
07C22:  MOVLB  0
07C24:  INCFSZ xC1,W
07C26:  BRA    7C2A
07C28:  BRA    7C2E
07C2A:  MOVLB  5
07C2C:  BRA    7C4C
07C2E:  INCFSZ xC2,W
07C30:  BRA    7C34
07C32:  BRA    7C38
07C34:  MOVLB  5
07C36:  BRA    7C4C
....................             { 
....................                PUSH_PRIORITY_QUEUE_MACRO(OPEN_VALVE_UNKNOWN_STATE); 
07C38:  BCF    F7A.1
07C3A:  MOVLW  3E
07C3C:  MOVLB  5
07C3E:  MOVWF  x52
07C40:  MOVLB  0
07C42:  CALL   4748
07C46:  BSF    F7A.1
....................             } 
07C48:  BRA    7C94
07C4A:  MOVLB  5
....................              
....................             else if ((make16(payload_buff[8], payload_buff[7]) == VLV_POSITION_CLOSED) \ 
....................                && (global_valve_position == VLV_POSITION_UNKNOWN)) 
07C4C:  MOVFF  2FB,553
07C50:  MOVFF  2FA,552
07C54:  MOVF   x52,F
07C56:  BNZ   7C86
07C58:  MOVF   x53,F
07C5A:  BNZ   7C86
07C5C:  MOVLB  0
07C5E:  INCFSZ xC1,W
07C60:  BRA    7C64
07C62:  BRA    7C68
07C64:  MOVLB  5
07C66:  BRA    7C86
07C68:  INCFSZ xC2,W
07C6A:  BRA    7C6E
07C6C:  BRA    7C72
07C6E:  MOVLB  5
07C70:  BRA    7C86
....................             { 
....................                PUSH_PRIORITY_QUEUE_MACRO(CLOSE_VALVE_UNKNOWN_STATE); 
07C72:  BCF    F7A.1
07C74:  MOVLW  3F
07C76:  MOVLB  5
07C78:  MOVWF  x52
07C7A:  MOVLB  0
07C7C:  CALL   4748
07C80:  BSF    F7A.1
....................             } 
07C82:  BRA    7C94
07C84:  MOVLB  5
....................               
....................             else 
....................             { 
....................                PUSH_PRIORITY_QUEUE_MACRO(MOVE_VALVE); 
07C86:  BCF    F7A.1
07C88:  MOVLW  40
07C8A:  MOVWF  x52
07C8C:  MOVLB  0
07C8E:  CALL   4748
07C92:  BSF    F7A.1
....................             }                                        
....................                         
....................             global_brake_duty_set_value = (make16(payload_buff[10], payload_buff[9])); 
07C94:  MOVFF  2FD,B7
07C98:  MOVFF  2FC,B6
....................             global_charge_duty_set_value = (make16(payload_buff[12], payload_buff[11])); 
07C9C:  MOVFF  2FF,B9
07CA0:  MOVFF  2FE,B8
....................                                 
....................             // clear queue 
....................             clear_sprinkler_queue();  
07CA4:  CALL   55B2
....................              
....................             if (payload_buff[14] == FALSE)                                               
07CA8:  MOVLB  3
07CAA:  MOVF   x01,F
07CAC:  BNZ   7CEC
....................             { 
....................                // set test parameters with no rpm control and preset mppc value    
....................                push_sprinkler_queue(0, 0-1,make16(payload_buff[8], payload_buff[7]), 0, \ 
....................                0, NO_RPM_CONTROL);      
07CAE:  MOVFF  2FB,553
07CB2:  MOVFF  2FA,552
07CB6:  MOVLB  5
07CB8:  CLRF   x61
07CBA:  CLRF   x60
07CBC:  CLRF   x5F
07CBE:  CLRF   x5E
07CC0:  SETF   x65
07CC2:  SETF   x64
07CC4:  SETF   x63
07CC6:  SETF   x62
07CC8:  MOVFF  2FB,567
07CCC:  MOVFF  2FA,566
07CD0:  CLRF   x69
07CD2:  CLRF   x68
07CD4:  CLRF   x6A
07CD6:  MOVLW  05
07CD8:  MOVWF  x6B
07CDA:  MOVLB  0
07CDC:  CALL   6E5A
....................                global_mppc_set_value = payload_buff[13]; 
07CE0:  MOVFF  300,BB
....................                global_control_loop_mechanism = NO_RPM_CONTROL; 
07CE4:  MOVLW  05
07CE6:  MOVWF  xC0
....................             } 
07CE8:  BRA    7D26
07CEA:  MOVLB  3
....................             else if (payload_buff[14] == TRUE)         
07CEC:  DECFSZ x01,W
07CEE:  BRA    7D28
....................             { 
....................                // set test parameters with no rpm control and dynamic mppc 
....................                push_sprinkler_queue(0, 0-1,make16(payload_buff[8], payload_buff[7]), 0, \ 
....................                0, NO_RPM_CONTROL_DYN_MPPC); 
07CF0:  MOVFF  2FB,553
07CF4:  MOVFF  2FA,552
07CF8:  MOVLB  5
07CFA:  CLRF   x61
07CFC:  CLRF   x60
07CFE:  CLRF   x5F
07D00:  CLRF   x5E
07D02:  SETF   x65
07D04:  SETF   x64
07D06:  SETF   x63
07D08:  SETF   x62
07D0A:  MOVFF  2FB,567
07D0E:  MOVFF  2FA,566
07D12:  CLRF   x69
07D14:  CLRF   x68
07D16:  CLRF   x6A
07D18:  MOVLW  06
07D1A:  MOVWF  x6B
07D1C:  MOVLB  0
07D1E:  CALL   6E5A
....................                global_control_loop_mechanism = NO_RPM_CONTROL_DYN_MPPC; 
07D22:  MOVLW  06
07D24:  MOVWF  xC0
07D26:  MOVLB  3
....................             } 
....................              
....................             global_valve_position_set_value = make16(payload_buff[8], payload_buff[7]); 
07D28:  MOVFF  2FB,C4
07D2C:  MOVFF  2FA,C3
....................             global_rpm_set_value = 0; 
07D30:  MOVLB  0
07D32:  CLRF   xAD
07D34:  CLRF   xAC
....................  
....................             send_full_report(command_id_received, mgr_msgSEQ); 
07D36:  MOVFF  54B,552
07D3A:  MOVFF  54D,554
07D3E:  MOVFF  54C,553
07D42:  CALL   6426
....................          } 
....................          break; 
07D46:  MOVLB  5
07D48:  BRA    81F0
....................           
....................       case MSG_MGR_TEST_RPM_CTRL: 
....................        
....................          // this test added by JG 
....................          if (!is_valve_value_full_open_or_close(make16(payload_buff[8], payload_buff[7]))) 
07D4A:  MOVFF  2FB,553
07D4E:  MOVFF  2FA,552
07D52:  MOVFF  2FB,555
07D56:  MOVFF  2FA,554
07D5A:  CALL   72AE
07D5E:  MOVF   01,F
07D60:  BNZ   7D70
....................          { 
....................             if (global_valve_position == VLV_POSITION_UNKNOWN) 
07D62:  INCFSZ xC1,W
07D64:  BRA    7D70
07D66:  INCFSZ xC2,W
07D68:  BRA    7D70
....................             { 
....................                temp_uint32 |= NACK_BITFIELD_VLV_POSITION_UNKNOWN; 
07D6A:  MOVLB  5
07D6C:  BSF    x4E.0
07D6E:  MOVLB  0
....................             } 
....................          } 
....................          if (!is_valve_position_valid(make16(payload_buff[8], payload_buff[7]))) 
07D70:  MOVFF  2FB,553
07D74:  MOVFF  2FA,552
07D78:  MOVFF  2FB,555
07D7C:  MOVFF  2FA,554
07D80:  CALL   6954
07D84:  MOVF   01,F
07D86:  BNZ   7D8E
....................          { 
....................             temp_uint32 |= NACK_BITFIELD_INVALID_VLV_SETTING; 
07D88:  MOVLB  5
07D8A:  BSF    x4E.1
07D8C:  MOVLB  0
....................          } 
....................          if (!is_rpm_setting_valid(make16(payload_buff[10], payload_buff[9]))) 
07D8E:  MOVFF  2FD,553
07D92:  MOVFF  2FC,552
07D96:  MOVFF  2FD,555
07D9A:  MOVFF  2FC,554
07D9E:  CALL   6E2C
07DA2:  MOVF   01,F
07DA4:  BNZ   7DAC
....................          {                                
....................             temp_uint32 |= NACK_BITFIELD_INVALID_RPM_SETTING; 
07DA6:  MOVLB  5
07DA8:  BSF    x4E.2
07DAA:  MOVLB  0
....................          } 
....................           
....................          // if the NACK bitfield contains anything, send the nack instead of proceeding 
....................          if (temp_uint32 != 0) 
07DAC:  MOVLB  5
07DAE:  MOVF   x4E,F
07DB0:  BNZ   7DBE
07DB2:  MOVF   x4F,F
07DB4:  BNZ   7DBE
07DB6:  MOVF   x50,F
07DB8:  BNZ   7DBE
07DBA:  MOVF   x51,F
07DBC:  BZ    7DE4
....................          { 
....................             send_nack(command_id_received, mgr_msgSEQ, temp_uint32); 
07DBE:  MOVFF  54B,552
07DC2:  MOVFF  54D,554
07DC6:  MOVFF  54C,553
07DCA:  MOVFF  551,558
07DCE:  MOVFF  550,557
07DD2:  MOVFF  54F,556
07DD6:  MOVFF  54E,555
07DDA:  MOVLB  0
07DDC:  CALL   6976
....................          } 
07DE0:  BRA    7F1A
07DE2:  MOVLB  5
....................          // add non-modulated run command to command queue  
....................          else 
....................          {  
....................             // clear queue  
....................             clear_sprinkler_queue(); 
07DE4:  MOVLB  0
07DE6:  CALL   55B2
....................              
....................             // set test parameters with rpm control 
....................             // JG: Add test of extra byte to address whether or not to 
....................             //  be have charging as part of the control loop 
....................             if (payload_buff[11] == 0xFF) 
07DEA:  MOVLB  2
07DEC:  INCFSZ xFE,W
07DEE:  BRA    7E32
....................             { 
....................                push_sprinkler_queue(0, 0-1,make16(payload_buff[8], payload_buff[7]), \ 
....................                   make16(payload_buff[10], payload_buff[9]), 0, BRAKE_AND_CHARGE_START); 
07DF0:  MOVFF  2FB,553
07DF4:  MOVFF  2FA,552
07DF8:  MOVFF  2FD,555
07DFC:  MOVFF  2FC,554
07E00:  MOVLB  5
07E02:  CLRF   x61
07E04:  CLRF   x60
07E06:  CLRF   x5F
07E08:  CLRF   x5E
07E0A:  SETF   x65
07E0C:  SETF   x64
07E0E:  SETF   x63
07E10:  SETF   x62
07E12:  MOVFF  2FB,567
07E16:  MOVFF  2FA,566
07E1A:  MOVFF  2FD,569
07E1E:  MOVFF  2FC,568
07E22:  CLRF   x6A
07E24:  CLRF   x6B
07E26:  MOVLB  0
07E28:  CALL   6E5A
....................                    
....................                global_control_loop_mechanism = BRAKE_AND_CHARGE_START; 
07E2C:  CLRF   xC0
....................             } 
07E2E:  BRA    7E74
07E30:  MOVLB  2
....................             else 
....................             { 
....................                push_sprinkler_queue(0, 0-1,make16(payload_buff[8], payload_buff[7]), \ 
....................                   make16(payload_buff[10], payload_buff[9]), 0, BRAKE_ONLY); 
07E32:  MOVFF  2FB,553
07E36:  MOVFF  2FA,552
07E3A:  MOVFF  2FD,555
07E3E:  MOVFF  2FC,554
07E42:  MOVLB  5
07E44:  CLRF   x61
07E46:  CLRF   x60
07E48:  CLRF   x5F
07E4A:  CLRF   x5E
07E4C:  SETF   x65
07E4E:  SETF   x64
07E50:  SETF   x63
07E52:  SETF   x62
07E54:  MOVFF  2FB,567
07E58:  MOVFF  2FA,566
07E5C:  MOVFF  2FD,569
07E60:  MOVFF  2FC,568
07E64:  CLRF   x6A
07E66:  MOVLW  02
07E68:  MOVWF  x6B
07E6A:  MOVLB  0
07E6C:  CALL   6E5A
....................                 
....................                global_control_loop_mechanism = BRAKE_ONLY; 
07E70:  MOVLW  02
07E72:  MOVWF  xC0
....................             } 
....................                 
....................             // deal with JG-added special cases of commands to fully open or 
....................             //  or fully close the valve in cases where the valve has not 
....................             //  yet been calibrated 
....................             if ((make16(payload_buff[8], payload_buff[7]) == VLV_POSITION_OPENED) \ 
....................                && (global_valve_position == VLV_POSITION_UNKNOWN)) 
07E74:  MOVFF  2FB,553
07E78:  MOVFF  2FA,552
07E7C:  MOVLB  5
07E7E:  MOVF   x52,F
07E80:  BNZ   7EB2
07E82:  MOVF   x53,W
07E84:  SUBLW  80
07E86:  BNZ   7EB2
07E88:  MOVLB  0
07E8A:  INCFSZ xC1,W
07E8C:  BRA    7E90
07E8E:  BRA    7E94
07E90:  MOVLB  5
07E92:  BRA    7EB2
07E94:  INCFSZ xC2,W
07E96:  BRA    7E9A
07E98:  BRA    7E9E
07E9A:  MOVLB  5
07E9C:  BRA    7EB2
....................             { 
....................                PUSH_PRIORITY_QUEUE_MACRO(OPEN_VALVE_UNKNOWN_STATE); 
07E9E:  BCF    F7A.1
07EA0:  MOVLW  3E
07EA2:  MOVLB  5
07EA4:  MOVWF  x52
07EA6:  MOVLB  0
07EA8:  CALL   4748
07EAC:  BSF    F7A.1
....................             } 
07EAE:  BRA    7EFA
07EB0:  MOVLB  5
....................              
....................             else if ((make16(payload_buff[8], payload_buff[7]) == VLV_POSITION_CLOSED) \ 
....................                && (global_valve_position == VLV_POSITION_UNKNOWN)) 
07EB2:  MOVFF  2FB,553
07EB6:  MOVFF  2FA,552
07EBA:  MOVF   x52,F
07EBC:  BNZ   7EEC
07EBE:  MOVF   x53,F
07EC0:  BNZ   7EEC
07EC2:  MOVLB  0
07EC4:  INCFSZ xC1,W
07EC6:  BRA    7ECA
07EC8:  BRA    7ECE
07ECA:  MOVLB  5
07ECC:  BRA    7EEC
07ECE:  INCFSZ xC2,W
07ED0:  BRA    7ED4
07ED2:  BRA    7ED8
07ED4:  MOVLB  5
07ED6:  BRA    7EEC
....................             { 
....................                PUSH_PRIORITY_QUEUE_MACRO(CLOSE_VALVE_UNKNOWN_STATE); 
07ED8:  BCF    F7A.1
07EDA:  MOVLW  3F
07EDC:  MOVLB  5
07EDE:  MOVWF  x52
07EE0:  MOVLB  0
07EE2:  CALL   4748
07EE6:  BSF    F7A.1
....................             }                                      
07EE8:  BRA    7EFA
07EEA:  MOVLB  5
....................              
....................             else 
....................             { 
....................                PUSH_PRIORITY_QUEUE_MACRO(MOVE_VALVE);   
07EEC:  BCF    F7A.1
07EEE:  MOVLW  40
07EF0:  MOVWF  x52
07EF2:  MOVLB  0
07EF4:  CALL   4748
07EF8:  BSF    F7A.1
....................             } 
....................              
....................             global_valve_position_set_value = make16(payload_buff[8], payload_buff[7]); 
07EFA:  MOVFF  2FB,C4
07EFE:  MOVFF  2FA,C3
....................             global_rpm_set_value = make16(payload_buff[10], payload_buff[9]); 
07F02:  MOVFF  2FD,AD
07F06:  MOVFF  2FC,AC
....................             send_full_report(command_id_received, mgr_msgSEQ);    
07F0A:  MOVFF  54B,552
07F0E:  MOVFF  54D,554
07F12:  MOVFF  54C,553
07F16:  CALL   6426
....................          } 
....................          break;  
07F1A:  MOVLB  5
07F1C:  BRA    81F0
....................           
....................       case MSG_MGR_DEMO: 
....................          if (global_valve_position == VLV_POSITION_UNKNOWN) 
07F1E:  INCFSZ xC1,W
07F20:  BRA    7F2C
07F22:  INCFSZ xC2,W
07F24:  BRA    7F2C
....................          { 
....................             temp_uint32 |= NACK_BITFIELD_VLV_POSITION_UNKNOWN; 
07F26:  MOVLB  5
07F28:  BSF    x4E.0
07F2A:  MOVLB  0
....................          }      
....................          // if the NACK bitfield contains anything, send the nack instead of proceeding 
....................          if (temp_uint32 != 0) 
07F2C:  MOVLB  5
07F2E:  MOVF   x4E,F
07F30:  BNZ   7F3E
07F32:  MOVF   x4F,F
07F34:  BNZ   7F3E
07F36:  MOVF   x50,F
07F38:  BNZ   7F3E
07F3A:  MOVF   x51,F
07F3C:  BZ    7F64
....................          { 
....................             send_nack(command_id_received, mgr_msgSEQ, temp_uint32); 
07F3E:  MOVFF  54B,552
07F42:  MOVFF  54D,554
07F46:  MOVFF  54C,553
07F4A:  MOVFF  551,558
07F4E:  MOVFF  550,557
07F52:  MOVFF  54F,556
07F56:  MOVFF  54E,555
07F5A:  MOVLB  0
07F5C:  CALL   6976
....................          }         
07F60:  BRA    8126
07F62:  MOVLB  5
....................          else 
....................          { 
....................             clear_sprinkler_queue(); 
07F64:  MOVLB  0
07F66:  CALL   55B2
....................             push_sprinkler_queue(global_utc_time, global_utc_time + 30, 0x4000, 100, 0, BRAKE_AND_CHARGE_START); 
07F6A:  MOVLW  1E
07F6C:  ADDWF  x89,W
07F6E:  MOVLB  5
07F70:  MOVWF  x52
07F72:  MOVLW  00
07F74:  MOVLB  0
07F76:  ADDWFC x8A,W
07F78:  MOVLB  5
07F7A:  MOVWF  x53
07F7C:  MOVLW  00
07F7E:  MOVLB  0
07F80:  ADDWFC x8B,W
07F82:  MOVLB  5
07F84:  MOVWF  x54
07F86:  MOVLW  00
07F88:  MOVLB  0
07F8A:  ADDWFC x8C,W
07F8C:  MOVLB  5
07F8E:  MOVWF  x55
07F90:  MOVFF  8C,561
07F94:  MOVFF  8B,560
07F98:  MOVFF  8A,55F
07F9C:  MOVFF  89,55E
07FA0:  MOVWF  x65
07FA2:  MOVFF  554,564
07FA6:  MOVFF  553,563
07FAA:  MOVFF  552,562
07FAE:  MOVLW  40
07FB0:  MOVWF  x67
07FB2:  CLRF   x66
07FB4:  CLRF   x69
07FB6:  MOVLW  64
07FB8:  MOVWF  x68
07FBA:  CLRF   x6A
07FBC:  CLRF   x6B
07FBE:  MOVLB  0
07FC0:  CALL   6E5A
....................             push_sprinkler_queue(global_utc_time + 30, global_utc_time + 60, 0x4000, 50, 0, BRAKE_AND_CHARGE_START); 
07FC4:  MOVLW  1E
07FC6:  ADDWF  x89,W
07FC8:  MOVLB  5
07FCA:  MOVWF  x52
07FCC:  MOVLW  00
07FCE:  MOVLB  0
07FD0:  ADDWFC x8A,W
07FD2:  MOVLB  5
07FD4:  MOVWF  x53
07FD6:  MOVLW  00
07FD8:  MOVLB  0
07FDA:  ADDWFC x8B,W
07FDC:  MOVLB  5
07FDE:  MOVWF  x54
07FE0:  MOVLW  00
07FE2:  MOVLB  0
07FE4:  ADDWFC x8C,W
07FE6:  MOVLB  5
07FE8:  MOVWF  x55
07FEA:  MOVLW  3C
07FEC:  MOVLB  0
07FEE:  ADDWF  x89,W
07FF0:  MOVLB  5
07FF2:  MOVWF  x56
07FF4:  MOVLW  00
07FF6:  MOVLB  0
07FF8:  ADDWFC x8A,W
07FFA:  MOVLB  5
07FFC:  MOVWF  x57
07FFE:  MOVLW  00
08000:  MOVLB  0
08002:  ADDWFC x8B,W
08004:  MOVLB  5
08006:  MOVWF  x58
08008:  MOVLW  00
0800A:  MOVLB  0
0800C:  ADDWFC x8C,W
0800E:  MOVLB  5
08010:  MOVWF  x59
08012:  MOVFF  555,561
08016:  MOVFF  554,560
0801A:  MOVFF  553,55F
0801E:  MOVFF  552,55E
08022:  MOVWF  x65
08024:  MOVFF  558,564
08028:  MOVFF  557,563
0802C:  MOVFF  556,562
08030:  MOVLW  40
08032:  MOVWF  x67
08034:  CLRF   x66
08036:  CLRF   x69
08038:  MOVLW  32
0803A:  MOVWF  x68
0803C:  CLRF   x6A
0803E:  CLRF   x6B
08040:  MOVLB  0
08042:  CALL   6E5A
....................             push_sprinkler_queue(global_utc_time + 60, global_utc_time + 90, 0x4000, 10, 0, BRAKE_AND_CHARGE_START); 
08046:  MOVLW  3C
08048:  ADDWF  x89,W
0804A:  MOVLB  5
0804C:  MOVWF  x52
0804E:  MOVLW  00
08050:  MOVLB  0
08052:  ADDWFC x8A,W
08054:  MOVLB  5
08056:  MOVWF  x53
08058:  MOVLW  00
0805A:  MOVLB  0
0805C:  ADDWFC x8B,W
0805E:  MOVLB  5
08060:  MOVWF  x54
08062:  MOVLW  00
08064:  MOVLB  0
08066:  ADDWFC x8C,W
08068:  MOVLB  5
0806A:  MOVWF  x55
0806C:  MOVLW  5A
0806E:  MOVLB  0
08070:  ADDWF  x89,W
08072:  MOVLB  5
08074:  MOVWF  x56
08076:  MOVLW  00
08078:  MOVLB  0
0807A:  ADDWFC x8A,W
0807C:  MOVLB  5
0807E:  MOVWF  x57
08080:  MOVLW  00
08082:  MOVLB  0
08084:  ADDWFC x8B,W
08086:  MOVLB  5
08088:  MOVWF  x58
0808A:  MOVLW  00
0808C:  MOVLB  0
0808E:  ADDWFC x8C,W
08090:  MOVLB  5
08092:  MOVWF  x59
08094:  MOVFF  555,561
08098:  MOVFF  554,560
0809C:  MOVFF  553,55F
080A0:  MOVFF  552,55E
080A4:  MOVWF  x65
080A6:  MOVFF  558,564
080AA:  MOVFF  557,563
080AE:  MOVFF  556,562
080B2:  MOVLW  40
080B4:  MOVWF  x67
080B6:  CLRF   x66
080B8:  CLRF   x69
080BA:  MOVLW  0A
080BC:  MOVWF  x68
080BE:  CLRF   x6A
080C0:  CLRF   x6B
080C2:  MOVLB  0
080C4:  CALL   6E5A
....................             push_sprinkler_queue(global_utc_time + 90, 0-1, VLV_POSITION_CLOSED, 0, 0, BRAKE_AND_CHARGE_START); 
080C8:  MOVLW  5A
080CA:  ADDWF  x89,W
080CC:  MOVLB  5
080CE:  MOVWF  x52
080D0:  MOVLW  00
080D2:  MOVLB  0
080D4:  ADDWFC x8A,W
080D6:  MOVLB  5
080D8:  MOVWF  x53
080DA:  MOVLW  00
080DC:  MOVLB  0
080DE:  ADDWFC x8B,W
080E0:  MOVLB  5
080E2:  MOVWF  x54
080E4:  MOVLW  00
080E6:  MOVLB  0
080E8:  ADDWFC x8C,W
080EA:  MOVLB  5
080EC:  MOVWF  x55
080EE:  MOVWF  x61
080F0:  MOVFF  554,560
080F4:  MOVFF  553,55F
080F8:  MOVFF  552,55E
080FC:  SETF   x65
080FE:  SETF   x64
08100:  SETF   x63
08102:  SETF   x62
08104:  CLRF   x67
08106:  CLRF   x66
08108:  CLRF   x69
0810A:  CLRF   x68
0810C:  CLRF   x6A
0810E:  CLRF   x6B
08110:  MOVLB  0
08112:  CALL   6E5A
....................             send_ack(command_id_received, mgr_msgSEQ); 
08116:  MOVFF  54B,552
0811A:  MOVFF  54D,554
0811E:  MOVFF  54C,553
08122:  CALL   68FA
....................             // add demo mode stuff to commmand queue 
....................          }                                 
....................       case MSG_MGR_CLEAR_SPINKLER_CMD_QUEUE: 
....................          clear_sprinkler_queue(); 
08126:  CALL   55B2
....................          send_full_report(command_id_received, mgr_msgSEQ); 
0812A:  MOVFF  54B,552
0812E:  MOVFF  54D,554
08132:  MOVFF  54C,553
08136:  CALL   6426
....................          break;  
0813A:  MOVLB  5
0813C:  BRA    81F0
....................        
....................       // To force the valve to move and change nothing else  
....................       //    (retrieve current settings for brake, charge, etc. 
....................       //    Will force the valve to go fully open/closed if uncalibrated (position unknown)    
....................       case MSG_MGR_FORCE_VALVE_MOVEMENT:               
....................          // if the valve position is unknown and we're trying to send it full open or full closed,  
....................          //    set the valve position to the precalibration (the middle) and proceed as the valve 
....................          //    will recalibrate its position 
....................          if ((global_valve_position == VLV_POSITION_UNKNOWN) &&                                       \ 
....................             (is_valve_value_full_open_or_close(make16(payload_buff[8], payload_buff[7]))))   
0813E:  INCFSZ xC1,W
08140:  BRA    8166
08142:  INCFSZ xC2,W
08144:  BRA    8166
08146:  MOVFF  2FB,553
0814A:  MOVFF  2FA,552
0814E:  MOVFF  2FB,555
08152:  MOVFF  2FA,554
08156:  CALL   72AE
0815A:  MOVF   01,F
0815C:  BZ    8166
....................          {                            
....................             global_valve_position = VLV_PRECALIBRATION_POSITION;  
0815E:  MOVLW  40
08160:  MOVWF  xC2
08162:  CLRF   xC1
....................          }       
08164:  BRA    818C
....................           
....................          // if the valve position is unknown and we're trying to send it to a specific position, NACK it    
....................          else if ((global_valve_position == VLV_POSITION_UNKNOWN) &&                                  \ 
....................             (!is_valve_value_full_open_or_close(make16(payload_buff[8], payload_buff[7]))))  
08166:  INCFSZ xC1,W
08168:  BRA    818C
0816A:  INCFSZ xC2,W
0816C:  BRA    818C
0816E:  MOVFF  2FB,553
08172:  MOVFF  2FA,552
08176:  MOVFF  2FB,555
0817A:  MOVFF  2FA,554
0817E:  CALL   72AE
08182:  MOVF   01,F
08184:  BNZ   818C
....................          { 
....................             temp_uint32 |= NACK_BITFIELD_VLV_POSITION_UNKNOWN; 
08186:  MOVLB  5
08188:  BSF    x4E.0
0818A:  MOVLB  0
....................          }           
....................           
....................          // if the NACK bitfield contains anything, send the nack instead of proceeding 
....................          if (temp_uint32 != 0)                                      
0818C:  MOVLB  5
0818E:  MOVF   x4E,F
08190:  BNZ   819E
08192:  MOVF   x4F,F
08194:  BNZ   819E
08196:  MOVF   x50,F
08198:  BNZ   819E
0819A:  MOVF   x51,F
0819C:  BZ    81C4
....................          { 
....................             send_nack(command_id_received, mgr_msgSEQ, temp_uint32); 
0819E:  MOVFF  54B,552
081A2:  MOVFF  54D,554
081A6:  MOVFF  54C,553
081AA:  MOVFF  551,558
081AE:  MOVFF  550,557
081B2:  MOVFF  54F,556
081B6:  MOVFF  54E,555
081BA:  MOVLB  0
081BC:  CALL   6976
....................          }    
081C0:  BRA    81EA
081C2:  MOVLB  5
....................          // otherwise, set the valve position, send a move valve command to the queue, and send a report 
....................          else  
....................          {     
....................             global_valve_position_set_value = make16(payload_buff[8], payload_buff[7]); 
081C4:  MOVFF  2FB,C4
081C8:  MOVFF  2FA,C3
....................             PUSH_PRIORITY_QUEUE_MACRO(MOVE_VALVE);   
081CC:  BCF    F7A.1
081CE:  MOVLW  40
081D0:  MOVWF  x52
081D2:  MOVLB  0
081D4:  CALL   4748
081D8:  BSF    F7A.1
....................             send_valve_report(command_id_received, mgr_msgSEQ); 
081DA:  MOVFF  54B,552
081DE:  MOVFF  54D,554
081E2:  MOVFF  54C,553
081E6:  CALL   67C6
....................          } 
....................          break;     
081EA:  MOVLB  5
081EC:  BRA    81F0
081EE:  MOVLB  5
081F0:  MOVLB  2
....................    }        
081F2:  MOVLB  0
081F4:  GOTO   A734 (RETURN)
.................... }  // deal_with_packet 
....................  
....................  
.................... void prepare_prefix_and_payload(uint8_t payload_buf_length) 
.................... { 
....................       // Setup send_prefix 
....................       send_prefix[0] = CMD_SEND; 
*
05FB2:  MOVLW  05
05FB4:  MOVLB  3
05FB6:  MOVWF  x53
....................       // set the size part of the prefix to payload length + 9 other bytes 
....................       send_prefix[1] = payload_buf_length + 9; 
05FB8:  MOVLW  09
05FBA:  MOVLB  5
05FBC:  ADDWF  x5D,W
05FBE:  MOVLB  3
05FC0:  MOVWF  x54
....................       send_prefix[2] = FLAG_SEND_REQUEST; 
05FC2:  MOVLW  04
05FC4:  MOVWF  x55
....................       send_prefix[3] = DESTADDR_HI; 
05FC6:  MOVLW  F9
05FC8:  MOVWF  x56
....................       send_prefix[4] = DESTADDR_LO; 
05FCA:  MOVLW  81
05FCC:  MOVWF  x57
....................       // setup the ???? 
....................       send_prefix[5] = svc_index_rcvd; 
05FCE:  MOVFF  364,358
....................       send_prefix[6] = APPDOMAIN_MAINTENANCE; 
05FD2:  MOVLW  02
05FD4:  MOVWF  x59
....................       send_prefix[7] = PRIORITY_HI; 
05FD6:  MOVWF  x5A
....................       send_prefix[8] = 0; 
05FD8:  CLRF   x5B
....................       send_prefix[9] = 0; 
05FDA:  CLRF   x5C
....................       send_prefix[10] = 0xFF; 
05FDC:  SETF   x5D
....................       send_prefix[11] = payload_buf_length; 
05FDE:  MOVFF  55D,35E
....................       payload_buff[0] = 0x00; 
05FE2:  MOVLB  2
05FE4:  CLRF   xF3
....................       payload_buff[1] = 0x00; 
05FE6:  CLRF   xF4
....................       payload_buff[2] = 0xFC; 
05FE8:  MOVLW  FC
05FEA:  MOVWF  xF5
....................       payload_buff[3] = 0x12;  
05FEC:  MOVLW  12
05FEE:  MOVWF  xF6
05FF0:  MOVLB  0
05FF2:  RETURN 0
.................... } 
.................... void prepare_prefix_and_payload_ISR(uint8_t payload_buf_length) 
.................... { 
....................       // Setup send_prefix 
....................       send_prefix[0] = CMD_SEND; 
*
023FC:  MOVLW  05
023FE:  MOVLB  3
02400:  MOVWF  x53
....................       // set the size part of the prefix to payload length + 9 other bytes 
....................       send_prefix[1] = payload_buf_length + 9; 
02402:  MOVLW  09
02404:  MOVLB  6
02406:  ADDWF  x08,W
02408:  MOVLB  3
0240A:  MOVWF  x54
....................       send_prefix[2] = FLAG_SEND_REQUEST; 
0240C:  MOVLW  04
0240E:  MOVWF  x55
....................       send_prefix[3] = DESTADDR_HI; 
02410:  MOVLW  F9
02412:  MOVWF  x56
....................       send_prefix[4] = DESTADDR_LO; 
02414:  MOVLW  81
02416:  MOVWF  x57
....................       // setup the ???? 
....................       send_prefix[5] = svc_index_rcvd; 
02418:  MOVFF  364,358
....................       send_prefix[6] = APPDOMAIN_MAINTENANCE; 
0241C:  MOVLW  02
0241E:  MOVWF  x59
....................       send_prefix[7] = PRIORITY_HI;                                                                       
02420:  MOVWF  x5A
....................       send_prefix[8] = 0; 
02422:  CLRF   x5B
....................       send_prefix[9] = 0; 
02424:  CLRF   x5C
....................       send_prefix[10] = 0xFF; 
02426:  SETF   x5D
....................       send_prefix[11] = payload_buf_length; 
02428:  MOVFF  608,35E
....................       payload_buff[0] = 0x00; 
0242C:  MOVLB  2
0242E:  CLRF   xF3
....................       payload_buff[1] = 0x00; 
02430:  CLRF   xF4
....................       payload_buff[2] = 0xFC;                           
02432:  MOVLW  FC
02434:  MOVWF  xF5
....................       payload_buff[3] = 0x12;  
02436:  MOVLW  12
02438:  MOVWF  xF6
0243A:  MOVLB  0
0243C:  RETURN 0
.................... } 
.................... void generate_message_and_send() 
.................... { 
....................    uint8_t n, res_byte; 
....................    // generate the message 
....................    dust_hdlc_pkgen(send_prefix, 12, payload_buff, send_prefix[11]); 
*
063CC:  MOVLW  03
063CE:  MOVLB  5
063D0:  MOVWF  x66
063D2:  MOVLW  53
063D4:  MOVWF  x65
063D6:  MOVLW  0C
063D8:  MOVWF  x67
063DA:  MOVLW  02
063DC:  MOVWF  x69
063DE:  MOVLW  F3
063E0:  MOVWF  x68
063E2:  MOVFF  35E,56A
063E6:  MOVLB  0
063E8:  RCALL  606C
....................     
....................    // try to send the message a 3 times 
....................    for (n = 0; n < 3; n++) 
063EA:  MOVLB  5
063EC:  CLRF   x5D
063EE:  MOVF   x5D,W
063F0:  SUBLW  02
063F2:  BNC   6422
....................    { 
....................       // try to send the message 
....................       res_byte = dust_hdlc_pksend();    
063F4:  MOVLB  0
063F6:  RCALL  6316
063F8:  MOVFF  01,55E
....................       // timeout of 50ms if pksend returns an error 
....................       setup_T0_int(T0_50MS); 
063FC:  MOVLB  5
063FE:  SETF   x69
06400:  MOVLW  3D
06402:  MOVWF  x68
06404:  MOVLB  0
06406:  CALL   38C2
....................       // if the message doesn't return no error, try sending again 
....................       while ((res_byte != NO_ERR) && !TMR0IF);        
0640A:  MOVLB  5
0640C:  MOVF   x5E,F
0640E:  BZ    6414
06410:  BTFSS  FF2.2
06412:  BRA    640C
....................       if (TMR0IF) 
06414:  BTFSS  FF2.2
06416:  BRA    641C
....................          continue; 
06418:  BRA    641E
0641A:  BRA    641E
....................       else 
....................          break; 
0641C:  BRA    6422
0641E:  INCF   x5D,F
06420:  BRA    63EE
....................    } 
06422:  MOVLB  0
06424:  RETURN 0
.................... } 
.................... void generate_message_and_send_ISR() 
.................... { 
....................    uint8_t n, res_byte; 
....................    // generate the message 
....................    dust_hdlc_pkgen_ISR(send_prefix, 12, payload_buff, send_prefix[11]); 
*
02498:  MOVLW  03
0249A:  MOVLB  6
0249C:  MOVWF  x15
0249E:  MOVLW  53
024A0:  MOVWF  x14
024A2:  MOVLW  0C
024A4:  MOVWF  x16
024A6:  MOVLW  02
024A8:  MOVWF  x18
024AA:  MOVLW  F3
024AC:  MOVWF  x17
024AE:  MOVFF  35E,619
024B2:  MOVLB  0
024B4:  CALL   0EE4
....................                                     
....................    // try to send the message a 3 times 
....................    for (n = 0; n < 3; n++) 
024B8:  MOVLB  6
024BA:  CLRF   x08
024BC:  MOVF   x08,W
024BE:  SUBLW  02
024C0:  BNC   24F0
....................    { 
....................       // try to send the message 
....................       res_byte = dust_hdlc_pksend_ISR();    
024C2:  MOVLB  0
024C4:  CALL   11A6
024C8:  MOVFF  01,609
....................       // timeout of 50ms if pksend returns an error 
....................       setup_T4_int(T4_50MS);  
024CC:  MOVLW  C7
024CE:  MOVLB  6
024D0:  MOVWF  x19
024D2:  MOVLB  0
024D4:  CALL   0944
....................       // if the message doesn't return no error, try sending again 
....................       while ((res_byte != NO_ERR) && !TMR0IF);        
024D8:  MOVLB  6
024DA:  MOVF   x09,F
024DC:  BZ    24E2
024DE:  BTFSS  FF2.2
024E0:  BRA    24DA
....................       if (TMR4IF) 
024E2:  BTFSS  F7E.0
024E4:  BRA    24EA
....................          continue; 
024E6:  BRA    24EC
024E8:  BRA    24EC
....................       else 
....................          break; 
024EA:  BRA    24F0
024EC:  INCF   x08,F
024EE:  BRA    24BC
....................    } 
024F0:  MOVLB  0
024F2:  RETURN 0
.................... } 
....................  
.................... void send_full_report_ISR(uint8_t command_id_in_response_to, uint16_t msg_seq) 
.................... { 
....................    uint16_t temp_u16; 
....................    //flash led to help identifying motes 
....................    LED2_ON; 
....................    prepare_prefix_and_payload(58); 
....................    payload_buff[4] = make8(msg_seq,0); 
....................    payload_buff[5] = make8(msg_seq,1); 
....................    payload_buff[6] = command_id_in_response_to; 
....................    payload_buff[7] = MSG_MOTE_FULL_REPORT; 
....................    payload_buff[8] = make8(global_sprinkler_num, 0); 
....................    payload_buff[9] = make8(global_sprinkler_num, 1); 
....................    payload_buff[10] = global_hardware_enabled; 
....................    payload_buff[11] = read_system_state(); 
....................    // vbatt(unchanged charge state) 
.................... //   temp_u16 = get_vbatt_ISR(0); 
....................    temp_u16 = 0; 
....................    payload_buff[12] = make8(temp_u16, 0); 
....................    payload_buff[13] = make8(temp_u16, 1); 
....................    // vbatt(no charging)        
.................... //   temp_u16 = get_vbatt_ISR(1); 
....................    temp_u16 = 0; 
....................    payload_buff[14] = make8(temp_u16, 0); 
....................    payload_buff[15] = make8(temp_u16, 1); 
....................    // vgen(unchanged charge state) 
.................... //   temp_u16 = get_vgen_ISR(0); 
....................    temp_u16 = 0; 
....................    payload_buff[16] = make8(temp_u16, 0); 
....................    payload_buff[17] = make8(temp_u16, 1);       
....................    /* 
....................    disable_interrupts(INT_CCP5);              
....................    temp_u16 = convert_period_to_rpm(global_current_period); 
....................    enable_interrupts(INT_CCP5); 
....................    */ 
....................    temp_u16 = 0; 
....................    payload_buff[18] = make8(temp_u16, 0); 
....................    payload_buff[19] = make8(temp_u16, 1);                
....................    payload_buff[20] = make8(global_rpm_set_value,0); 
....................    payload_buff[21] = make8(global_rpm_set_value,1); 
....................    disable_interrupts(INT_CCP4); 
....................    if (global_current_sprinkler_queue_location != 255) 
....................    { 
....................       payload_buff[22] = make8(global_sprinkler_queue[global_current_sprinkler_queue_location].spin_rate,0); 
....................       payload_buff[23] = make8(global_sprinkler_queue[global_current_sprinkler_queue_location].spin_rate,1); 
....................    } 
....................    else 
....................    { 
....................       payload_buff[22] = 0; 
....................       payload_buff[23] = 0; 
....................    } 
....................    payload_buff[24] = make8(global_brake_duty,0); 
....................    payload_buff[25] = make8(global_brake_duty,1); 
....................    payload_buff[26] = make8(global_brake_duty_set_value,0); 
....................    payload_buff[27] = make8(global_brake_duty_set_value,1); 
....................    payload_buff[28] = make8(global_charge_duty,0); 
....................    payload_buff[29] = make8(global_charge_duty,1); 
....................    payload_buff[30] = make8(global_charge_duty_set_value,0); 
....................    payload_buff[31] = make8(global_charge_duty_set_value,1); 
....................    payload_buff[32] = global_mppc_value; 
....................    payload_buff[33] = global_control_loop_mechanism; 
....................    payload_buff[34] = make8(global_calibrate_fsr_valve_position, 0); 
....................    payload_buff[35] = make8(global_calibrate_fsr_valve_position, 1); 
....................    temp_u16 = convert_period_to_rpm(global_calibrate_fsr_period); 
....................    payload_buff[36] = make8(temp_u16, 0); 
....................    payload_buff[37] = make8(temp_u16, 1); 
....................    payload_buff[38] = LATE; 
....................    payload_buff[39] = make8(global_valve_position,0); 
....................    payload_buff[40] = make8(global_valve_position,1); 
....................    payload_buff[41] = make8(global_valve_position_set_value,0); 
....................    payload_buff[42] = make8(global_valve_position_set_value,1); 
....................    if (global_current_sprinkler_queue_location != 255) 
....................    { 
....................       payload_buff[43] = make8(global_sprinkler_queue[global_current_sprinkler_queue_location].vlv_open_amount,0); 
....................       payload_buff[44] = make8(global_sprinkler_queue[global_current_sprinkler_queue_location].vlv_open_amount,1); 
....................       payload_buff[45] = make8(global_sprinkler_queue[global_current_sprinkler_queue_location].start_time,0); 
....................       payload_buff[46] = make8(global_sprinkler_queue[global_current_sprinkler_queue_location].start_time,1); 
....................       payload_buff[47] = make8(global_sprinkler_queue[global_current_sprinkler_queue_location].start_time,2); 
....................       payload_buff[48] = make8(global_sprinkler_queue[global_current_sprinkler_queue_location].start_time,3); 
....................    } 
....................    else 
....................    { 
....................       payload_buff[43] = 0; 
....................       payload_buff[44] = 0; 
....................       payload_buff[45] = 0; 
....................       payload_buff[46] = 0; 
....................       payload_buff[47] = 0; 
....................       payload_buff[48] = 0; 
....................    } 
....................    enable_interrupts(INT_CCP4); 
....................    payload_buff[49] = make8(global_xdcr_output, 0); 
....................    payload_buff[50] = make8(global_xdcr_output, 1); 
....................       //  JG: changed from mote uptime to boot time 
....................    payload_buff[51] = make8(global_first_utc_time,0); 
....................    payload_buff[52] = make8(global_first_utc_time,1); 
....................    payload_buff[53] = make8(global_first_utc_time,2); 
....................    payload_buff[54] = make8(global_first_utc_time,3); 
....................    /* 
....................    payload_buff[51] = make8(global_rtc_time,0); 
....................    payload_buff[52] = make8(global_rtc_time,1); 
....................    payload_buff[53] = make8(global_rtc_time,2); 
....................    payload_buff[54] = make8(global_rtc_time,3); 
....................    */ 
....................    payload_buff[55] = global_previous_shutdown_cause; 
....................    payload_buff[56] = make8(FIRMWARE_VERSION,0); 
....................    payload_buff[57] = make8(FIRMWARE_VERSION,1); 
....................  
....................    generate_message_and_send(); 
....................    LED2_OFF; 
.................... } 
....................  
.................... void send_full_report(uint8_t command_id_in_response_to, uint16_t msg_seq) 
.................... { 
....................    uint16_t temp_u16; 
....................    //flash led to help identifying motes  
....................    prepare_prefix_and_payload(58); 
*
06426:  MOVLW  3A
06428:  MOVLB  5
0642A:  MOVWF  x5D
0642C:  MOVLB  0
0642E:  RCALL  5FB2
....................    payload_buff[4] = make8(msg_seq,0); 
06430:  MOVFF  553,2F7
06434:  MOVLB  2
....................    payload_buff[5] = make8(msg_seq,1); 
06436:  MOVFF  554,2F8
0643A:  MOVLB  2
....................    payload_buff[6] = command_id_in_response_to; 
0643C:  MOVFF  552,2F9
....................    payload_buff[7] = MSG_MOTE_FULL_REPORT; 
06440:  MOVLW  90
06442:  MOVWF  xFA
....................    payload_buff[8] = make8(global_sprinkler_num, 0); 
06444:  MOVFF  95,2FB
06448:  MOVLB  2
....................    payload_buff[9] = make8(global_sprinkler_num, 1); 
0644A:  MOVFF  96,2FC
0644E:  MOVLB  2
....................    payload_buff[10] = global_hardware_enabled; 
06450:  MOVFF  A7,2FD
....................    payload_buff[11] = read_system_state(); 
06454:  MOVLB  0
06456:  CALL   1F4A
0645A:  MOVFF  01,2FE
....................    // vbatt(unchanged charge state) 
....................    temp_u16 = get_vbatt(0); 
0645E:  MOVLB  5
06460:  CLRF   x6A
06462:  MOVLB  0
06464:  CALL   42B4
06468:  MOVFF  02,556
0646C:  MOVFF  01,555
....................    payload_buff[12] = make8(temp_u16, 0); 
06470:  MOVFF  555,2FF
06474:  MOVLB  2
....................    payload_buff[13] = make8(temp_u16, 1); 
06476:  MOVFF  556,300
0647A:  MOVLB  3
....................    // vbatt(no charging)        
....................    temp_u16 = get_vbatt(1); 
0647C:  MOVLW  01
0647E:  MOVLB  5
06480:  MOVWF  x6A
06482:  MOVLB  0
06484:  CALL   42B4
06488:  MOVFF  02,556
0648C:  MOVFF  01,555
....................    payload_buff[14] = make8(temp_u16, 0); 
06490:  MOVFF  555,301
06494:  MOVLB  3
....................    payload_buff[15] = make8(temp_u16, 1); 
06496:  MOVFF  556,302
0649A:  MOVLB  3
....................    // vgen(unchanged charge state) 
....................    temp_u16 = get_vgen(0); 
0649C:  MOVLB  5
0649E:  CLRF   x57
064A0:  MOVLB  0
064A2:  CALL   430E
064A6:  MOVFF  02,556
064AA:  MOVFF  01,555
....................    payload_buff[16] = make8(temp_u16, 0); 
064AE:  MOVFF  555,303
064B2:  MOVLB  3
....................    payload_buff[17] = make8(temp_u16, 1);       
064B4:  MOVFF  556,304
064B8:  MOVLB  3
....................    disable_interrupts(INT_CCP5);              
064BA:  BCF    F7A.2
....................    temp_u16 = convert_period_to_rpm(global_current_period); 
064BC:  MOVFF  A9,558
064C0:  MOVFF  A8,557
064C4:  MOVLB  0
064C6:  RCALL  5FF4
064C8:  MOVFF  02,556
064CC:  MOVFF  01,555
....................    enable_interrupts(INT_CCP5); 
064D0:  BSF    F7A.2
....................    payload_buff[18] = make8(temp_u16, 0); 
064D2:  MOVFF  555,305
064D6:  MOVLB  3
....................    payload_buff[19] = make8(temp_u16, 1);                
064D8:  MOVFF  556,306
064DC:  MOVLB  3
....................    payload_buff[20] = make8(global_rpm_set_value,0); 
064DE:  MOVFF  AC,307
064E2:  MOVLB  3
....................    payload_buff[21] = make8(global_rpm_set_value,1); 
064E4:  MOVFF  AD,308
064E8:  MOVLB  3
....................    disable_interrupts(INT_CCP4); 
064EA:  BCF    F7A.1
....................    if (global_current_sprinkler_queue_location != 255) 
064EC:  MOVLB  4
064EE:  INCFSZ x29,W
064F0:  BRA    64F4
064F2:  BRA    655A
....................    { 
....................       payload_buff[22] = make8(global_sprinkler_queue[global_current_sprinkler_queue_location].spin_rate,0); 
064F4:  MOVF   x29,W
064F6:  MULLW  0E
064F8:  MOVF   FF3,W
064FA:  MOVLB  5
064FC:  CLRF   x58
064FE:  MOVWF  x57
06500:  MOVLW  0A
06502:  ADDWF  x57,W
06504:  MOVWF  01
06506:  MOVLW  00
06508:  ADDWFC x58,W
0650A:  MOVWF  03
0650C:  MOVF   01,W
0650E:  ADDLW  9D
06510:  MOVWF  FE9
06512:  MOVLW  03
06514:  ADDWFC 03,W
06516:  MOVWF  FEA
06518:  MOVFF  FEC,558
0651C:  MOVF   FED,F
0651E:  MOVFF  FEF,309
06522:  MOVLB  3
....................       payload_buff[23] = make8(global_sprinkler_queue[global_current_sprinkler_queue_location].spin_rate,1); 
06524:  MOVLB  4
06526:  MOVF   x29,W
06528:  MULLW  0E
0652A:  MOVF   FF3,W
0652C:  MOVLB  5
0652E:  CLRF   x58
06530:  MOVWF  x57
06532:  MOVLW  0A
06534:  ADDWF  x57,W
06536:  MOVWF  01
06538:  MOVLW  00
0653A:  ADDWFC x58,W
0653C:  MOVWF  03
0653E:  MOVF   01,W
06540:  ADDLW  9D
06542:  MOVWF  FE9
06544:  MOVLW  03
06546:  ADDWFC 03,W
06548:  MOVWF  FEA
0654A:  MOVFF  FEC,30A
0654E:  MOVF   FED,F
06550:  MOVFF  FEF,557
06554:  MOVLB  3
....................    } 
06556:  BRA    6560
06558:  MOVLB  4
....................    else 
....................    { 
....................       payload_buff[22] = 0; 
0655A:  MOVLB  3
0655C:  CLRF   x09
....................       payload_buff[23] = 0; 
0655E:  CLRF   x0A
....................    } 
....................    payload_buff[24] = make8(global_brake_duty,0); 
06560:  MOVFF  B2,30B
06564:  MOVLB  3
....................    payload_buff[25] = make8(global_brake_duty,1); 
06566:  MOVFF  B3,30C
0656A:  MOVLB  3
....................    payload_buff[26] = make8(global_brake_duty_set_value,0); 
0656C:  MOVFF  B6,30D
06570:  MOVLB  3
....................    payload_buff[27] = make8(global_brake_duty_set_value,1); 
06572:  MOVFF  B7,30E
06576:  MOVLB  3
....................    payload_buff[28] = make8(global_charge_duty,0); 
06578:  MOVFF  B4,30F
0657C:  MOVLB  3
....................    payload_buff[29] = make8(global_charge_duty,1); 
0657E:  MOVFF  B5,310
06582:  MOVLB  3
....................    payload_buff[30] = make8(global_charge_duty_set_value,0); 
06584:  MOVFF  B8,311
06588:  MOVLB  3
....................    payload_buff[31] = make8(global_charge_duty_set_value,1); 
0658A:  MOVFF  B9,312
0658E:  MOVLB  3
....................    payload_buff[32] = global_mppc_value; 
06590:  MOVFF  BA,313
....................    payload_buff[33] = global_control_loop_mechanism; 
06594:  MOVFF  C0,314
....................    payload_buff[34] = make8(global_calibrate_fsr_valve_position, 0); 
06598:  MOVFF  D0,315
0659C:  MOVLB  3
....................    payload_buff[35] = make8(global_calibrate_fsr_valve_position, 1); 
0659E:  MOVFF  D1,316
065A2:  MOVLB  3
....................    temp_u16 = convert_period_to_rpm(global_calibrate_fsr_period); 
065A4:  MOVFF  D3,558
065A8:  MOVFF  D2,557
065AC:  MOVLB  0
065AE:  RCALL  5FF4
065B0:  MOVFF  02,556
065B4:  MOVFF  01,555
....................    payload_buff[36] = make8(temp_u16, 0); 
065B8:  MOVFF  555,317
065BC:  MOVLB  3
....................    payload_buff[37] = make8(temp_u16, 1); 
065BE:  MOVFF  556,318
065C2:  MOVLB  3
....................    payload_buff[38] = LATE; 
065C4:  MOVFF  F8D,319
....................    payload_buff[39] = make8(global_valve_position,0); 
065C8:  MOVFF  C1,31A
065CC:  MOVLB  3
....................    payload_buff[40] = make8(global_valve_position,1); 
065CE:  MOVFF  C2,31B
065D2:  MOVLB  3
....................    payload_buff[41] = make8(global_valve_position_set_value,0); 
065D4:  MOVFF  C3,31C
065D8:  MOVLB  3
....................    payload_buff[42] = make8(global_valve_position_set_value,1); 
065DA:  MOVFF  C4,31D
065DE:  MOVLB  3
....................    if (global_current_sprinkler_queue_location != 255) 
065E0:  MOVLB  4
065E2:  INCFSZ x29,W
065E4:  BRA    65E8
065E6:  BRA    66FE
....................    { 
....................       payload_buff[43] = make8(global_sprinkler_queue[global_current_sprinkler_queue_location].vlv_open_amount,0); 
065E8:  MOVF   x29,W
065EA:  MULLW  0E
065EC:  MOVF   FF3,W
065EE:  MOVLB  5
065F0:  CLRF   x58
065F2:  MOVWF  x57
065F4:  MOVLW  08
065F6:  ADDWF  x57,W
065F8:  MOVWF  01
065FA:  MOVLW  00
065FC:  ADDWFC x58,W
065FE:  MOVWF  03
06600:  MOVF   01,W
06602:  ADDLW  9D
06604:  MOVWF  FE9
06606:  MOVLW  03
06608:  ADDWFC 03,W
0660A:  MOVWF  FEA
0660C:  MOVFF  FEC,558
06610:  MOVF   FED,F
06612:  MOVFF  FEF,31E
06616:  MOVLB  3
....................       payload_buff[44] = make8(global_sprinkler_queue[global_current_sprinkler_queue_location].vlv_open_amount,1); 
06618:  MOVLB  4
0661A:  MOVF   x29,W
0661C:  MULLW  0E
0661E:  MOVF   FF3,W
06620:  MOVLB  5
06622:  CLRF   x58
06624:  MOVWF  x57
06626:  MOVLW  08
06628:  ADDWF  x57,W
0662A:  MOVWF  01
0662C:  MOVLW  00
0662E:  ADDWFC x58,W
06630:  MOVWF  03
06632:  MOVF   01,W
06634:  ADDLW  9D
06636:  MOVWF  FE9
06638:  MOVLW  03
0663A:  ADDWFC 03,W
0663C:  MOVWF  FEA
0663E:  MOVFF  FEC,31F
06642:  MOVF   FED,F
06644:  MOVFF  FEF,557
06648:  MOVLB  3
....................       payload_buff[45] = make8(global_sprinkler_queue[global_current_sprinkler_queue_location].start_time,0); 
0664A:  MOVLB  4
0664C:  MOVF   x29,W
0664E:  MULLW  0E
06650:  MOVF   FF3,W
06652:  MOVLB  5
06654:  CLRF   x58
06656:  MOVWF  x57
06658:  MOVLW  9D
0665A:  ADDWF  x57,W
0665C:  MOVWF  FE9
0665E:  MOVLW  03
06660:  ADDWFC x58,W
06662:  MOVWF  FEA
06664:  MOVFF  FEF,320
06668:  MOVFF  FEC,55A
0666C:  MOVFF  FEC,55B
06670:  MOVFF  FEC,55C
06674:  MOVLB  3
....................       payload_buff[46] = make8(global_sprinkler_queue[global_current_sprinkler_queue_location].start_time,1); 
06676:  MOVLB  4
06678:  MOVF   x29,W
0667A:  MULLW  0E
0667C:  MOVF   FF3,W
0667E:  MOVLB  5
06680:  CLRF   x58
06682:  MOVWF  x57
06684:  MOVLW  9D
06686:  ADDWF  x57,W
06688:  MOVWF  FE9
0668A:  MOVLW  03
0668C:  ADDWFC x58,W
0668E:  MOVWF  FEA
06690:  MOVFF  FEF,559
06694:  MOVFF  FEC,321
06698:  MOVFF  FEC,55B
0669C:  MOVFF  FEC,55C
066A0:  MOVLB  3
....................       payload_buff[47] = make8(global_sprinkler_queue[global_current_sprinkler_queue_location].start_time,2); 
066A2:  MOVLB  4
066A4:  MOVF   x29,W
066A6:  MULLW  0E
066A8:  MOVF   FF3,W
066AA:  MOVLB  5
066AC:  CLRF   x58
066AE:  MOVWF  x57
066B0:  MOVLW  9D
066B2:  ADDWF  x57,W
066B4:  MOVWF  FE9
066B6:  MOVLW  03
066B8:  ADDWFC x58,W
066BA:  MOVWF  FEA
066BC:  MOVFF  FEF,559
066C0:  MOVFF  FEC,55A
066C4:  MOVFF  FEC,322
066C8:  MOVFF  FEC,55C
066CC:  MOVLB  3
....................       payload_buff[48] = make8(global_sprinkler_queue[global_current_sprinkler_queue_location].start_time,3); 
066CE:  MOVLB  4
066D0:  MOVF   x29,W
066D2:  MULLW  0E
066D4:  MOVF   FF3,W
066D6:  MOVLB  5
066D8:  CLRF   x58
066DA:  MOVWF  x57
066DC:  MOVLW  9D
066DE:  ADDWF  x57,W
066E0:  MOVWF  FE9
066E2:  MOVLW  03
066E4:  ADDWFC x58,W
066E6:  MOVWF  FEA
066E8:  MOVFF  FEF,559
066EC:  MOVFF  FEC,55A
066F0:  MOVFF  FEC,55B
066F4:  MOVFF  FEC,323
066F8:  MOVLB  3
....................    } 
066FA:  BRA    670C
066FC:  MOVLB  4
....................    else 
....................    { 
....................       payload_buff[43] = 0; 
066FE:  MOVLB  3
06700:  CLRF   x1E
....................       payload_buff[44] = 0; 
06702:  CLRF   x1F
....................       payload_buff[45] = 0; 
06704:  CLRF   x20
....................       payload_buff[46] = 0; 
06706:  CLRF   x21
....................       payload_buff[47] = 0; 
06708:  CLRF   x22
....................       payload_buff[48] = 0; 
0670A:  CLRF   x23
....................    } 
....................    enable_interrupts(INT_CCP4); 
0670C:  BSF    F7A.1
....................    payload_buff[49] = make8(global_xdcr_output, 0); 
0670E:  MOVFF  4B,324
....................    payload_buff[50] = make8(global_xdcr_output, 1); 
06712:  MOVFF  4C,325
....................       //  JG: changed from mote uptime to boot time 
....................    payload_buff[51] = make8(global_first_utc_time,0); 
06716:  MOVFF  8D,326
0671A:  MOVLB  3
....................    payload_buff[52] = make8(global_first_utc_time,1); 
0671C:  MOVFF  8E,327
06720:  MOVLB  3
....................    payload_buff[53] = make8(global_first_utc_time,2); 
06722:  MOVFF  8F,328
06726:  MOVLB  3
....................    payload_buff[54] = make8(global_first_utc_time,3); 
06728:  MOVFF  90,329
0672C:  MOVLB  3
....................    /* 
....................    payload_buff[51] = make8(global_rtc_time,0); 
....................    payload_buff[52] = make8(global_rtc_time,1); 
....................    payload_buff[53] = make8(global_rtc_time,2); 
....................    payload_buff[54] = make8(global_rtc_time,3); 
....................    */ 
....................    payload_buff[55] = global_previous_shutdown_cause; 
0672E:  MOVFF  4E,32A
....................    payload_buff[56] = make8(FIRMWARE_VERSION,0); 
06732:  MOVLW  13
06734:  MOVWF  x2B
....................    payload_buff[57] = make8(FIRMWARE_VERSION,1); 
06736:  MOVLW  E3
06738:  MOVWF  x2C
....................  
....................    generate_message_and_send(); 
0673A:  MOVLB  0
0673C:  RCALL  63CC
0673E:  RETURN 0
.................... } 
.................... void send_health_report(uint8_t command_id_in_response_to, uint16_t msg_seq) 
.................... {   
....................    uint16_t temp_u16; 
....................     
....................    prepare_prefix_and_payload(18); 
06740:  MOVLW  12
06742:  MOVLB  5
06744:  MOVWF  x5D
06746:  MOVLB  0
06748:  RCALL  5FB2
....................    payload_buff[4] = make8(msg_seq,0); 
0674A:  MOVFF  553,2F7
0674E:  MOVLB  2
....................    payload_buff[5] = make8(msg_seq,1); 
06750:  MOVFF  554,2F8
06754:  MOVLB  2
....................    payload_buff[6] = command_id_in_response_to; 
06756:  MOVFF  552,2F9
....................    payload_buff[7] = MSG_MOTE_HEALTH_REPORT; 
0675A:  MOVLW  91
0675C:  MOVWF  xFA
....................    payload_buff[8] = make8(global_sprinkler_num, 0); 
0675E:  MOVFF  95,2FB
06762:  MOVLB  2
....................    payload_buff[9] = make8(global_sprinkler_num, 1); 
06764:  MOVFF  96,2FC
06768:  MOVLB  2
....................    payload_buff[10] = global_hardware_enabled; 
0676A:  MOVFF  A7,2FD
....................    payload_buff[11] = read_system_state(); 
0676E:  MOVLB  0
06770:  CALL   1F4A
06774:  MOVFF  01,2FE
....................    // vbatt(unchanged charge state) 
....................    temp_u16 = get_vbatt(0); 
06778:  MOVLB  5
0677A:  CLRF   x6A
0677C:  MOVLB  0
0677E:  CALL   42B4
06782:  MOVFF  02,556
06786:  MOVFF  01,555
....................    payload_buff[12] = make8(temp_u16, 0); 
0678A:  MOVFF  555,2FF
0678E:  MOVLB  2
....................    payload_buff[13] = make8(temp_u16, 1); 
06790:  MOVFF  556,300
06794:  MOVLB  3
....................    // vbatt(no charging) 
....................    temp_u16 = get_vbatt(1); 
06796:  MOVLW  01
06798:  MOVLB  5
0679A:  MOVWF  x6A
0679C:  MOVLB  0
0679E:  CALL   42B4
067A2:  MOVFF  02,556
067A6:  MOVFF  01,555
....................    payload_buff[14] = make8(temp_u16, 0); 
067AA:  MOVFF  555,301
067AE:  MOVLB  3
....................    payload_buff[15] = make8(temp_u16, 1); 
067B0:  MOVFF  556,302
067B4:  MOVLB  3
....................    payload_buff[16] = global_valve_movements_since_endstop; 
067B6:  MOVFF  CF,303
....................    // grab the most recent temperature 
....................    payload_buff[17] = global_mote_temperature; 
067BA:  MOVFF  36D,304
....................    generate_message_and_send(); 
067BE:  MOVLB  0
067C0:  RCALL  63CC
067C2:  GOTO   73C8 (RETURN)
.................... } 
.................... void send_valve_report(uint8_t command_id_in_response_to, uint16_t msg_seq) 
.................... { 
....................    uint16_t temp_u16; 
....................     
....................    prepare_prefix_and_payload(28); 
067C6:  MOVLW  1C
067C8:  MOVLB  5
067CA:  MOVWF  x5D
067CC:  MOVLB  0
067CE:  CALL   5FB2
....................    payload_buff[4] = make8(msg_seq,0); 
067D2:  MOVFF  553,2F7
067D6:  MOVLB  2
....................    payload_buff[5] = make8(msg_seq,1); 
067D8:  MOVFF  554,2F8
067DC:  MOVLB  2
....................    payload_buff[6] = command_id_in_response_to;                                                         
067DE:  MOVFF  552,2F9
....................    payload_buff[7] = MSG_MOTE_VALVE_REPORT;  
067E2:  MOVLW  92
067E4:  MOVWF  xFA
....................    payload_buff[8] = make8(global_sprinkler_num, 0); 
067E6:  MOVFF  95,2FB
067EA:  MOVLB  2
....................    payload_buff[9] = make8(global_sprinkler_num, 1); 
067EC:  MOVFF  96,2FC
067F0:  MOVLB  2
....................    payload_buff[10] = make8(global_valve_position, 0); 
067F2:  MOVFF  C1,2FD
067F6:  MOVLB  2
....................    payload_buff[11] = make8(global_valve_position, 1); 
067F8:  MOVFF  C2,2FE
067FC:  MOVLB  2
....................    payload_buff[12] = make8((global_valve_time_to_open_1024th << 4), 0); 
067FE:  MOVLB  0
06800:  RLCF   xC7,W
06802:  MOVLB  5
06804:  MOVWF  x57
06806:  MOVLB  0
06808:  RLCF   xC8,W
0680A:  MOVLB  5
0680C:  MOVWF  x58
0680E:  RLCF   x57,F
06810:  RLCF   x58,F
06812:  RLCF   x57,F
06814:  RLCF   x58,F
06816:  RLCF   x57,F
06818:  RLCF   x58,F
0681A:  MOVLW  F0
0681C:  ANDWF  x57,F
0681E:  MOVFF  557,2FF
06822:  MOVLB  2
....................    payload_buff[13] = make8((global_valve_time_to_open_1024th << 4), 1); 
06824:  MOVLB  0
06826:  RLCF   xC7,W
06828:  MOVLB  5
0682A:  MOVWF  x57
0682C:  MOVLB  0
0682E:  RLCF   xC8,W
06830:  MOVLB  5
06832:  MOVWF  x58
06834:  RLCF   x57,F
06836:  RLCF   x58,F
06838:  RLCF   x57,F
0683A:  RLCF   x58,F
0683C:  RLCF   x57,F
0683E:  RLCF   x58,F
06840:  MOVLW  F0
06842:  ANDWF  x57,F
06844:  MOVFF  558,300
06848:  MOVLB  3
....................    payload_buff[14] = make8((global_valve_time_to_close_1024th << 4), 0); 
0684A:  MOVLB  0
0684C:  RLCF   xC5,W
0684E:  MOVLB  5
06850:  MOVWF  x57
06852:  MOVLB  0
06854:  RLCF   xC6,W
06856:  MOVLB  5
06858:  MOVWF  x58
0685A:  RLCF   x57,F
0685C:  RLCF   x58,F
0685E:  RLCF   x57,F
06860:  RLCF   x58,F
06862:  RLCF   x57,F
06864:  RLCF   x58,F
06866:  MOVLW  F0
06868:  ANDWF  x57,F
0686A:  MOVFF  557,301
0686E:  MOVLB  3
....................    payload_buff[15] = make8((global_valve_time_to_close_1024th << 4), 1); 
06870:  MOVLB  0
06872:  RLCF   xC5,W
06874:  MOVLB  5
06876:  MOVWF  x57
06878:  MOVLB  0
0687A:  RLCF   xC6,W
0687C:  MOVLB  5
0687E:  MOVWF  x58
06880:  RLCF   x57,F
06882:  RLCF   x58,F
06884:  RLCF   x57,F
06886:  RLCF   x58,F
06888:  RLCF   x57,F
0688A:  RLCF   x58,F
0688C:  MOVLW  F0
0688E:  ANDWF  x57,F
06890:  MOVFF  558,302
06894:  MOVLB  3
....................    payload_buff[16] = make8(global_valve_calibration_utc_time, 0); 
06896:  MOVFF  CB,303
0689A:  MOVLB  3
....................    payload_buff[17] = make8(global_valve_calibration_utc_time, 1); 
0689C:  MOVFF  CC,304
068A0:  MOVLB  3
....................    payload_buff[18] = make8(global_valve_calibration_utc_time, 2); 
068A2:  MOVFF  CD,305
068A6:  MOVLB  3
....................    payload_buff[19] = make8(global_valve_calibration_utc_time, 3); 
068A8:  MOVFF  CE,306
068AC:  MOVLB  3
....................    payload_buff[20] = make8(global_calibrate_fsr_valve_position, 0); 
068AE:  MOVFF  D0,307
068B2:  MOVLB  3
....................    payload_buff[21] = make8(global_calibrate_fsr_valve_position, 1); 
068B4:  MOVFF  D1,308
068B8:  MOVLB  3
....................    temp_u16 = convert_period_to_rpm(global_calibrate_fsr_period); 
068BA:  MOVFF  D3,558
068BE:  MOVFF  D2,557
068C2:  MOVLB  0
068C4:  CALL   5FF4
068C8:  MOVFF  02,556
068CC:  MOVFF  01,555
....................    payload_buff[22] = make8(temp_u16, 0); 
068D0:  MOVFF  555,309
068D4:  MOVLB  3
....................    payload_buff[23] = make8(temp_u16, 1); 
068D6:  MOVFF  556,30A
068DA:  MOVLB  3
....................    payload_buff[24] = make8(global_calibrate_fsr_utc_time, 0); 
068DC:  MOVFF  D4,30B
068E0:  MOVLB  3
....................    payload_buff[25] = make8(global_calibrate_fsr_utc_time, 1); 
068E2:  MOVFF  D5,30C
068E6:  MOVLB  3
....................    payload_buff[26] = make8(global_calibrate_fsr_utc_time, 2); 
068E8:  MOVFF  D6,30D
068EC:  MOVLB  3
....................    payload_buff[27] = make8(global_calibrate_fsr_utc_time, 3); 
068EE:  MOVFF  D7,30E
068F2:  MOVLB  3
....................    generate_message_and_send(); 
068F4:  MOVLB  0
068F6:  RCALL  63CC
068F8:  RETURN 0
.................... } 
.................... void send_sprinkler_cmd_response(uint8_t command_id_in_response_to, uint16_t msg_seq) 
.................... { 
....................    uint16_t temp_u16; 
....................     
....................    prepare_prefix_and_payload(25); 
*
07098:  MOVLW  19
0709A:  MOVLB  5
0709C:  MOVWF  x5D
0709E:  MOVLB  0
070A0:  CALL   5FB2
....................    payload_buff[4] = make8(msg_seq,0); 
070A4:  MOVFF  553,2F7
070A8:  MOVLB  2
....................    payload_buff[5] = make8(msg_seq,1); 
070AA:  MOVFF  554,2F8
070AE:  MOVLB  2
....................    payload_buff[6] = command_id_in_response_to; 
070B0:  MOVFF  552,2F9
....................    payload_buff[7] = MSG_MOTE_SPINKLER_CMD_RESPONSE; 
070B4:  MOVLW  93
070B6:  MOVWF  xFA
....................    payload_buff[8] = make8(global_sprinkler_num, 0); 
070B8:  MOVFF  95,2FB
070BC:  MOVLB  2
....................    payload_buff[9] = make8(global_sprinkler_num, 1); 
070BE:  MOVFF  96,2FC
070C2:  MOVLB  2
....................    payload_buff[10] = global_hardware_enabled; 
070C4:  MOVFF  A7,2FD
....................    payload_buff[11] = make8(global_rpm_set_value, 0); 
070C8:  MOVFF  AC,2FE
070CC:  MOVLB  2
....................    payload_buff[12] = make8(global_rpm_set_value, 1); 
070CE:  MOVFF  AD,2FF
070D2:  MOVLB  2
....................    disable_interrupts(INT_CCP4); 
070D4:  BCF    F7A.1
....................    if (global_current_sprinkler_queue_location != 255) 
070D6:  MOVLB  4
070D8:  INCFSZ x29,W
070DA:  BRA    70DE
070DC:  BRA    7144
....................    { 
....................       payload_buff[13] = make8(global_sprinkler_queue[global_current_sprinkler_queue_location].spin_rate,0); 
070DE:  MOVF   x29,W
070E0:  MULLW  0E
070E2:  MOVF   FF3,W
070E4:  MOVLB  5
070E6:  CLRF   x58
070E8:  MOVWF  x57
070EA:  MOVLW  0A
070EC:  ADDWF  x57,W
070EE:  MOVWF  01
070F0:  MOVLW  00
070F2:  ADDWFC x58,W
070F4:  MOVWF  03
070F6:  MOVF   01,W
070F8:  ADDLW  9D
070FA:  MOVWF  FE9
070FC:  MOVLW  03
070FE:  ADDWFC 03,W
07100:  MOVWF  FEA
07102:  MOVFF  FEC,558
07106:  MOVF   FED,F
07108:  MOVFF  FEF,300
0710C:  MOVLB  3
....................       payload_buff[14] = make8(global_sprinkler_queue[global_current_sprinkler_queue_location].spin_rate,1); 
0710E:  MOVLB  4
07110:  MOVF   x29,W
07112:  MULLW  0E
07114:  MOVF   FF3,W
07116:  MOVLB  5
07118:  CLRF   x58
0711A:  MOVWF  x57
0711C:  MOVLW  0A
0711E:  ADDWF  x57,W
07120:  MOVWF  01
07122:  MOVLW  00
07124:  ADDWFC x58,W
07126:  MOVWF  03
07128:  MOVF   01,W
0712A:  ADDLW  9D
0712C:  MOVWF  FE9
0712E:  MOVLW  03
07130:  ADDWFC 03,W
07132:  MOVWF  FEA
07134:  MOVFF  FEC,301
07138:  MOVF   FED,F
0713A:  MOVFF  FEF,557
0713E:  MOVLB  3
....................    } 
07140:  BRA    714A
07142:  MOVLB  4
....................    else 
....................    { 
....................       payload_buff[13] = 0; 
07144:  MOVLB  3
07146:  CLRF   x00
....................       payload_buff[14] = 0; 
07148:  CLRF   x01
....................    } 
....................    payload_buff[15] = make8(global_valve_position_set_value,0); 
0714A:  MOVFF  C3,302
0714E:  MOVLB  3
....................    payload_buff[16] = make8(global_valve_position_set_value,1); 
07150:  MOVFF  C4,303
07154:  MOVLB  3
....................    if (global_current_sprinkler_queue_location != 255) 
07156:  MOVLB  4
07158:  INCFSZ x29,W
0715A:  BRA    715E
0715C:  BRA    7274
....................    { 
....................       payload_buff[17] = make8(global_sprinkler_queue[global_current_sprinkler_queue_location].vlv_open_amount,0); 
0715E:  MOVF   x29,W
07160:  MULLW  0E
07162:  MOVF   FF3,W
07164:  MOVLB  5
07166:  CLRF   x58
07168:  MOVWF  x57
0716A:  MOVLW  08
0716C:  ADDWF  x57,W
0716E:  MOVWF  01
07170:  MOVLW  00
07172:  ADDWFC x58,W
07174:  MOVWF  03
07176:  MOVF   01,W
07178:  ADDLW  9D
0717A:  MOVWF  FE9
0717C:  MOVLW  03
0717E:  ADDWFC 03,W
07180:  MOVWF  FEA
07182:  MOVFF  FEC,558
07186:  MOVF   FED,F
07188:  MOVFF  FEF,304
0718C:  MOVLB  3
....................       payload_buff[18] = make8(global_sprinkler_queue[global_current_sprinkler_queue_location].vlv_open_amount,1); 
0718E:  MOVLB  4
07190:  MOVF   x29,W
07192:  MULLW  0E
07194:  MOVF   FF3,W
07196:  MOVLB  5
07198:  CLRF   x58
0719A:  MOVWF  x57
0719C:  MOVLW  08
0719E:  ADDWF  x57,W
071A0:  MOVWF  01
071A2:  MOVLW  00
071A4:  ADDWFC x58,W
071A6:  MOVWF  03
071A8:  MOVF   01,W
071AA:  ADDLW  9D
071AC:  MOVWF  FE9
071AE:  MOVLW  03
071B0:  ADDWFC 03,W
071B2:  MOVWF  FEA
071B4:  MOVFF  FEC,305
071B8:  MOVF   FED,F
071BA:  MOVFF  FEF,557
071BE:  MOVLB  3
....................       payload_buff[19] = make8(global_sprinkler_queue[global_current_sprinkler_queue_location].start_time,0); 
071C0:  MOVLB  4
071C2:  MOVF   x29,W
071C4:  MULLW  0E
071C6:  MOVF   FF3,W
071C8:  MOVLB  5
071CA:  CLRF   x58
071CC:  MOVWF  x57
071CE:  MOVLW  9D
071D0:  ADDWF  x57,W
071D2:  MOVWF  FE9
071D4:  MOVLW  03
071D6:  ADDWFC x58,W
071D8:  MOVWF  FEA
071DA:  MOVFF  FEF,306
071DE:  MOVFF  FEC,55A
071E2:  MOVFF  FEC,55B
071E6:  MOVFF  FEC,55C
071EA:  MOVLB  3
....................       payload_buff[20] = make8(global_sprinkler_queue[global_current_sprinkler_queue_location].start_time,1); 
071EC:  MOVLB  4
071EE:  MOVF   x29,W
071F0:  MULLW  0E
071F2:  MOVF   FF3,W
071F4:  MOVLB  5
071F6:  CLRF   x58
071F8:  MOVWF  x57
071FA:  MOVLW  9D
071FC:  ADDWF  x57,W
071FE:  MOVWF  FE9
07200:  MOVLW  03
07202:  ADDWFC x58,W
07204:  MOVWF  FEA
07206:  MOVFF  FEF,559
0720A:  MOVFF  FEC,307
0720E:  MOVFF  FEC,55B
07212:  MOVFF  FEC,55C
07216:  MOVLB  3
....................       payload_buff[21] = make8(global_sprinkler_queue[global_current_sprinkler_queue_location].start_time,2); 
07218:  MOVLB  4
0721A:  MOVF   x29,W
0721C:  MULLW  0E
0721E:  MOVF   FF3,W
07220:  MOVLB  5
07222:  CLRF   x58
07224:  MOVWF  x57
07226:  MOVLW  9D
07228:  ADDWF  x57,W
0722A:  MOVWF  FE9
0722C:  MOVLW  03
0722E:  ADDWFC x58,W
07230:  MOVWF  FEA
07232:  MOVFF  FEF,559
07236:  MOVFF  FEC,55A
0723A:  MOVFF  FEC,308
0723E:  MOVFF  FEC,55C
07242:  MOVLB  3
....................       payload_buff[22] = make8(global_sprinkler_queue[global_current_sprinkler_queue_location].start_time,3); 
07244:  MOVLB  4
07246:  MOVF   x29,W
07248:  MULLW  0E
0724A:  MOVF   FF3,W
0724C:  MOVLB  5
0724E:  CLRF   x58
07250:  MOVWF  x57
07252:  MOVLW  9D
07254:  ADDWF  x57,W
07256:  MOVWF  FE9
07258:  MOVLW  03
0725A:  ADDWFC x58,W
0725C:  MOVWF  FEA
0725E:  MOVFF  FEF,559
07262:  MOVFF  FEC,55A
07266:  MOVFF  FEC,55B
0726A:  MOVFF  FEC,309
0726E:  MOVLB  3
....................    } 
07270:  BRA    7282
07272:  MOVLB  4
....................    else 
....................    { 
....................       payload_buff[17] = 0; 
07274:  MOVLB  3
07276:  CLRF   x04
....................       payload_buff[18] = 0; 
07278:  CLRF   x05
....................       payload_buff[19] = 0; 
0727A:  CLRF   x06
....................       payload_buff[20] = 0; 
0727C:  CLRF   x07
....................       payload_buff[21] = 0; 
0727E:  CLRF   x08
....................       payload_buff[22] = 0; 
07280:  CLRF   x09
....................    } 
....................    enable_interrupts(INT_CCP4); 
07282:  BSF    F7A.1
....................    // vbatt(no charging) 
....................    temp_u16 = get_vbatt(1); 
07284:  MOVLW  01
07286:  MOVLB  5
07288:  MOVWF  x6A
0728A:  MOVLB  0
0728C:  CALL   42B4
07290:  MOVFF  02,556
07294:  MOVFF  01,555
....................    payload_buff[23] = make8(temp_u16, 0); 
07298:  MOVFF  555,30A
0729C:  MOVLB  3
....................    payload_buff[24] = make8(temp_u16, 1); 
0729E:  MOVFF  556,30B
072A2:  MOVLB  3
....................    generate_message_and_send(); 
072A4:  MOVLB  0
072A6:  CALL   63CC
072AA:  GOTO   7B0A (RETURN)
.................... } 
.................... void send_update_sp_num_response(uint8_t command_id_in_response_to, uint16_t msg_seq) 
.................... { 
....................    prepare_prefix_and_payload(10); 
*
06920:  MOVLW  0A
06922:  MOVLB  5
06924:  MOVWF  x5D
06926:  MOVLB  0
06928:  CALL   5FB2
....................    payload_buff[4] = make8(msg_seq,0); 
0692C:  MOVFF  553,2F7
06930:  MOVLB  2
....................    payload_buff[5] = make8(msg_seq,1); 
06932:  MOVFF  554,2F8
06936:  MOVLB  2
....................    payload_buff[6] = command_id_in_response_to; 
06938:  MOVFF  552,2F9
....................    payload_buff[7] = MSG_MOTE_UPDATE_SP_NUM_RESPONSE; 
0693C:  MOVLW  95
0693E:  MOVWF  xFA
....................    payload_buff[8] = make8(global_sprinkler_num, 0); 
06940:  MOVFF  95,2FB
06944:  MOVLB  2
....................    payload_buff[9] = make8(global_sprinkler_num, 1); 
06946:  MOVFF  96,2FC
0694A:  MOVLB  2
....................    generate_message_and_send(); 
0694C:  MOVLB  0
0694E:  RCALL  63CC
06950:  GOTO   7634 (RETURN)
.................... }        
.................... void send_read_eeprom_response(uint8_t command_id_in_response_to, uint16_t msg_seq, uint16_t eeprom_location, uint32_t eeprom_data)  
.................... { 
....................    prepare_prefix_and_payload(16); 
*
06DD2:  MOVLW  10
06DD4:  MOVLB  5
06DD6:  MOVWF  x5D
06DD8:  MOVLB  0
06DDA:  CALL   5FB2
....................    payload_buff[4] = make8(msg_seq,0);                                                    
06DDE:  MOVFF  555,2F7
06DE2:  MOVLB  2
....................    payload_buff[5] = make8(msg_seq,1); 
06DE4:  MOVFF  556,2F8
06DE8:  MOVLB  2
....................    payload_buff[6] = command_id_in_response_to; 
06DEA:  MOVFF  554,2F9
....................    payload_buff[7] = MSG_MOTE_EEPROM_READ_RESPONSE;  
06DEE:  MOVLW  97
06DF0:  MOVWF  xFA
....................    payload_buff[8] = make8(global_sprinkler_num, 0); 
06DF2:  MOVFF  95,2FB
06DF6:  MOVLB  2
....................    payload_buff[9] = make8(global_sprinkler_num, 1); 
06DF8:  MOVFF  96,2FC
06DFC:  MOVLB  2
....................    payload_buff[10] = make8(eeprom_location, 0); 
06DFE:  MOVFF  557,2FD
06E02:  MOVLB  2
....................    payload_buff[11] = make8(eeprom_location, 1);   
06E04:  MOVFF  558,2FE
06E08:  MOVLB  2
....................    payload_buff[12] = make8(eeprom_data, 0);                          
06E0A:  MOVFF  559,2FF
06E0E:  MOVLB  2
....................    payload_buff[13] = make8(eeprom_data, 1);   
06E10:  MOVFF  55A,300
06E14:  MOVLB  3
....................    payload_buff[14] = make8(eeprom_data, 2);     
06E16:  MOVFF  55B,301
06E1A:  MOVLB  3
....................    payload_buff[15] = make8(eeprom_data, 3);   
06E1C:  MOVFF  55C,302
06E20:  MOVLB  3
....................    generate_message_and_send();    
06E22:  MOVLB  0
06E24:  CALL   63CC
06E28:  GOTO   79A6 (RETURN)
.................... }                
.................... void send_pressure_xdcr_msg(uint8_t command_id_in_response_to, uint16_t msg_seq)    
.................... {                    
....................    prepare_prefix_and_payload(12); 
....................    payload_buff[4] = make8(msg_seq,0);                                                    
....................    payload_buff[5] = make8(msg_seq,1);       
....................    payload_buff[6] = command_id_in_response_to;                    
....................    payload_buff[7] = MSG_MOTE_XDCR_READ_MSG;           
....................    payload_buff[8] = make8(global_sprinkler_num, 0);    
....................    payload_buff[9] = make8(global_sprinkler_num, 1); 
....................    payload_buff[10] = make8(global_xdcr_output, 0);                  
....................    payload_buff[11] = make8(global_xdcr_output, 1);    
....................    generate_message_and_send();                               
.................... }        
.................... void send_ack(uint8_t command_id_in_response_to, uint16_t msg_seq) 
.................... { 
....................    prepare_prefix_and_payload(8); 
*
068FA:  MOVLW  08
068FC:  MOVLB  5
068FE:  MOVWF  x5D
06900:  MOVLB  0
06902:  CALL   5FB2
....................    payload_buff[4] = make8(msg_seq,0); 
06906:  MOVFF  553,2F7
0690A:  MOVLB  2
....................    payload_buff[5] = make8(msg_seq,1); 
0690C:  MOVFF  554,2F8
06910:  MOVLB  2
....................    payload_buff[6] = command_id_in_response_to; 
06912:  MOVFF  552,2F9
....................    payload_buff[7] = MSG_MOTE_ACK; 
06916:  MOVLW  80
06918:  MOVWF  xFA
....................    generate_message_and_send(); 
0691A:  MOVLB  0
0691C:  RCALL  63CC
0691E:  RETURN 0
.................... } 
.................... void send_nack(uint8_t command_id_in_response_to, uint16_t msg_seq, uint32_t nack_bitfield) 
.................... { 
....................    prepare_prefix_and_payload(12); 
*
06976:  MOVLW  0C
06978:  MOVLB  5
0697A:  MOVWF  x5D
0697C:  MOVLB  0
0697E:  CALL   5FB2
....................    payload_buff[4] = make8(msg_seq,0); 
06982:  MOVFF  553,2F7
06986:  MOVLB  2
....................    payload_buff[5] = make8(msg_seq,1); 
06988:  MOVFF  554,2F8
0698C:  MOVLB  2
....................    payload_buff[6] = command_id_in_response_to; 
0698E:  MOVFF  552,2F9
....................    payload_buff[7] = MSG_MOTE_NACK; 
06992:  MOVLW  81
06994:  MOVWF  xFA
....................    payload_buff[8] = make8(nack_bitfield, 0); 
06996:  MOVFF  555,2FB
0699A:  MOVLB  2
....................    payload_buff[9] = make8(nack_bitfield, 1); 
0699C:  MOVFF  556,2FC
069A0:  MOVLB  2
....................    payload_buff[10] = make8(nack_bitfield, 2); 
069A2:  MOVFF  557,2FD
069A6:  MOVLB  2
....................    payload_buff[11] = make8(nack_bitfield, 3); 
069A8:  MOVFF  558,2FE
069AC:  MOVLB  2
....................    generate_message_and_send(); 
069AE:  MOVLB  0
069B0:  RCALL  63CC
069B2:  RETURN 0
.................... }                                        
....................  
.................... // unsolicted responses (only sent within CCP4 ISR) 
.................... void send_health_report_ISR(uint8_t command_id_in_response_to, uint16_t msg_seq) 
.................... { 
....................    uint16_t temp_u16; 
....................     
....................    prepare_prefix_and_payload_ISR(18); 
*
024F4:  MOVLW  12
024F6:  MOVLB  6
024F8:  MOVWF  x08
024FA:  MOVLB  0
024FC:  RCALL  23FC
....................    payload_buff[4] = make8(msg_seq,0); 
024FE:  MOVFF  604,2F7
02502:  MOVLB  2
....................    payload_buff[5] = make8(msg_seq,1); 
02504:  MOVFF  605,2F8
02508:  MOVLB  2
....................    payload_buff[6] = command_id_in_response_to; 
0250A:  MOVFF  603,2F9
....................    payload_buff[7] = MSG_MOTE_HEALTH_REPORT; 
0250E:  MOVLW  91
02510:  MOVWF  xFA
....................    payload_buff[8] = make8(global_sprinkler_num, 0); 
02512:  MOVFF  95,2FB
02516:  MOVLB  2
....................    payload_buff[9] = make8(global_sprinkler_num, 1); 
02518:  MOVFF  96,2FC
0251C:  MOVLB  2
....................    payload_buff[10] = global_hardware_enabled; 
0251E:  MOVFF  A7,2FD
....................    payload_buff[11] = global_system_state; 
02522:  MOVFF  505,2FE
....................  // vbatt(unchanged charge state) 
....................    temp_u16 = get_vbatt_ISR(0); 
02526:  MOVLB  6
02528:  CLRF   x08
0252A:  MOVLB  0
0252C:  RCALL  243E
0252E:  MOVFF  02,607
02532:  MOVFF  01,606
....................    payload_buff[12] = make8(temp_u16, 0); 
02536:  MOVFF  606,2FF
0253A:  MOVLB  2
....................    payload_buff[13] = make8(temp_u16, 1); 
0253C:  MOVFF  607,300
02540:  MOVLB  3
....................    // vbatt(no charging) 
....................    temp_u16 = get_vbatt_ISR(1); 
02542:  MOVLW  01
02544:  MOVLB  6
02546:  MOVWF  x08
02548:  MOVLB  0
0254A:  RCALL  243E
0254C:  MOVFF  02,607
02550:  MOVFF  01,606
....................    payload_buff[14] = make8(temp_u16, 0); 
02554:  MOVFF  606,301
02558:  MOVLB  3
....................    payload_buff[15] = make8(temp_u16, 1); 
0255A:  MOVFF  607,302
0255E:  MOVLB  3
....................    payload_buff[16] = global_valve_movements_since_endstop; 
02560:  MOVFF  CF,303
....................    payload_buff[17] = global_mote_temperature; 
02564:  MOVFF  36D,304
....................    generate_message_and_send_ISR(); 
02568:  MOVLB  0
0256A:  RCALL  2498
0256C:  GOTO   2A9A (RETURN)
.................... } 
.................... void send_valve_report_ISR(uint8_t command_id_in_response_to, uint16_t msg_seq) 
.................... { 
....................    uint16_t temp_u16; 
....................    prepare_prefix_and_payload_ISR(28); 
*
0266E:  MOVLW  1C
02670:  MOVLB  6
02672:  MOVWF  x08
02674:  MOVLB  0
02676:  RCALL  23FC
....................    payload_buff[4] = make8(msg_seq,0); 
02678:  MOVFF  604,2F7
0267C:  MOVLB  2
....................    payload_buff[5] = make8(msg_seq,1); 
0267E:  MOVFF  605,2F8
02682:  MOVLB  2
....................    payload_buff[6] = command_id_in_response_to; 
02684:  MOVFF  603,2F9
....................    payload_buff[7] = MSG_MOTE_VALVE_REPORT; 
02688:  MOVLW  92
0268A:  MOVWF  xFA
....................    payload_buff[8] = make8(global_sprinkler_num, 0); 
0268C:  MOVFF  95,2FB
02690:  MOVLB  2
....................    payload_buff[9] = make8(global_sprinkler_num, 1); 
02692:  MOVFF  96,2FC
02696:  MOVLB  2
....................    payload_buff[10] = make8(global_valve_position, 0); 
02698:  MOVFF  C1,2FD
0269C:  MOVLB  2
....................    payload_buff[11] = make8(global_valve_position, 1); 
0269E:  MOVFF  C2,2FE
026A2:  MOVLB  2
....................    payload_buff[12] = make8((global_valve_time_to_open_1024th << 4), 0); 
026A4:  MOVLB  0
026A6:  RLCF   xC7,W
026A8:  MOVLB  6
026AA:  MOVWF  x08
026AC:  MOVLB  0
026AE:  RLCF   xC8,W
026B0:  MOVLB  6
026B2:  MOVWF  x09
026B4:  RLCF   x08,F
026B6:  RLCF   x09,F
026B8:  RLCF   x08,F
026BA:  RLCF   x09,F
026BC:  RLCF   x08,F
026BE:  RLCF   x09,F
026C0:  MOVLW  F0
026C2:  ANDWF  x08,F
026C4:  MOVFF  608,2FF
026C8:  MOVLB  2
....................    payload_buff[13] = make8((global_valve_time_to_open_1024th << 4), 1); 
026CA:  MOVLB  0
026CC:  RLCF   xC7,W
026CE:  MOVLB  6
026D0:  MOVWF  x08
026D2:  MOVLB  0
026D4:  RLCF   xC8,W
026D6:  MOVLB  6
026D8:  MOVWF  x09
026DA:  RLCF   x08,F
026DC:  RLCF   x09,F
026DE:  RLCF   x08,F
026E0:  RLCF   x09,F
026E2:  RLCF   x08,F
026E4:  RLCF   x09,F
026E6:  MOVLW  F0
026E8:  ANDWF  x08,F
026EA:  MOVFF  609,300
026EE:  MOVLB  3
....................    payload_buff[14] = make8((global_valve_time_to_close_1024th << 4), 0); 
026F0:  MOVLB  0
026F2:  RLCF   xC5,W
026F4:  MOVLB  6
026F6:  MOVWF  x08
026F8:  MOVLB  0
026FA:  RLCF   xC6,W
026FC:  MOVLB  6
026FE:  MOVWF  x09
02700:  RLCF   x08,F
02702:  RLCF   x09,F
02704:  RLCF   x08,F
02706:  RLCF   x09,F
02708:  RLCF   x08,F
0270A:  RLCF   x09,F
0270C:  MOVLW  F0
0270E:  ANDWF  x08,F
02710:  MOVFF  608,301
02714:  MOVLB  3
....................    payload_buff[15] = make8((global_valve_time_to_close_1024th << 4), 1); 
02716:  MOVLB  0
02718:  RLCF   xC5,W
0271A:  MOVLB  6
0271C:  MOVWF  x08
0271E:  MOVLB  0
02720:  RLCF   xC6,W
02722:  MOVLB  6
02724:  MOVWF  x09
02726:  RLCF   x08,F
02728:  RLCF   x09,F
0272A:  RLCF   x08,F
0272C:  RLCF   x09,F
0272E:  RLCF   x08,F
02730:  RLCF   x09,F
02732:  MOVLW  F0
02734:  ANDWF  x08,F
02736:  MOVFF  609,302
0273A:  MOVLB  3
....................    payload_buff[16] = make8(global_valve_calibration_utc_time, 0); 
0273C:  MOVFF  CB,303
02740:  MOVLB  3
....................    payload_buff[17] = make8(global_valve_calibration_utc_time, 1); 
02742:  MOVFF  CC,304
02746:  MOVLB  3
....................    payload_buff[18] = make8(global_valve_calibration_utc_time, 2); 
02748:  MOVFF  CD,305
0274C:  MOVLB  3
....................    payload_buff[19] = make8(global_valve_calibration_utc_time, 3); 
0274E:  MOVFF  CE,306
02752:  MOVLB  3
....................    payload_buff[20] = make8(global_calibrate_fsr_valve_position, 0); 
02754:  MOVFF  D0,307
02758:  MOVLB  3
....................    payload_buff[21] = make8(global_calibrate_fsr_valve_position, 1); 
0275A:  MOVFF  D1,308
0275E:  MOVLB  3
....................    temp_u16 = convert_period_to_rpm_ISR(global_calibrate_fsr_period); 
02760:  MOVFF  D3,609
02764:  MOVFF  D2,608
02768:  MOVLB  0
0276A:  BRA    2604
0276C:  MOVFF  02,607
02770:  MOVFF  01,606
....................    payload_buff[22] = make8(temp_u16, 0); 
02774:  MOVFF  606,309
02778:  MOVLB  3
....................    payload_buff[23] = make8(temp_u16, 1); 
0277A:  MOVFF  607,30A
0277E:  MOVLB  3
....................    payload_buff[24] = make8(global_calibrate_fsr_utc_time, 0); 
02780:  MOVFF  D4,30B
02784:  MOVLB  3
....................    payload_buff[25] = make8(global_calibrate_fsr_utc_time, 1); 
02786:  MOVFF  D5,30C
0278A:  MOVLB  3
....................    payload_buff[26] = make8(global_calibrate_fsr_utc_time, 2); 
0278C:  MOVFF  D6,30D
02790:  MOVLB  3
....................    payload_buff[27] = make8(global_calibrate_fsr_utc_time, 3); 
02792:  MOVFF  D7,30E
02796:  MOVLB  3
....................    generate_message_and_send_ISR(); 
02798:  MOVLB  0
0279A:  RCALL  2498
0279C:  GOTO   2A9A (RETURN)
.................... } 
.................... void send_join_msg_ISR(uint8_t command_id_in_response_to, uint16_t msg_seq) 
.................... { 
....................    prepare_prefix_and_payload_ISR(18); 
027A0:  MOVLW  12
027A2:  MOVLB  6
027A4:  MOVWF  x08
027A6:  MOVLB  0
027A8:  RCALL  23FC
....................    payload_buff[4] = make8(msg_seq,0); 
027AA:  MOVFF  604,2F7
027AE:  MOVLB  2
....................    payload_buff[5] = make8(msg_seq,1); 
027B0:  MOVFF  605,2F8
027B4:  MOVLB  2
....................    payload_buff[6] = command_id_in_response_to; 
027B6:  MOVFF  603,2F9
....................    payload_buff[7] = MSG_MOTE_JOIN_MSG; 
027BA:  MOVLW  94
027BC:  MOVWF  xFA
....................    payload_buff[8] = make8(global_sprinkler_num, 0); 
027BE:  MOVFF  95,2FB
027C2:  MOVLB  2
....................    payload_buff[9] = make8(global_sprinkler_num, 1); 
027C4:  MOVFF  96,2FC
027C8:  MOVLB  2
....................    payload_buff[10] = global_hardware_enabled; 
027CA:  MOVFF  A7,2FD
....................    payload_buff[11] = make8(global_rtc_time,0); 
027CE:  MOVFF  85,2FE
027D2:  MOVLB  2
....................    payload_buff[12] = make8(global_rtc_time,1); 
027D4:  MOVFF  86,2FF
027D8:  MOVLB  2
....................    payload_buff[13] = make8(global_rtc_time,2); 
027DA:  MOVFF  87,300
027DE:  MOVLB  3
....................    payload_buff[14] = make8(global_rtc_time,3);    
027E0:  MOVFF  88,301
027E4:  MOVLB  3
....................    payload_buff[15] = global_previous_shutdown_cause; 
027E6:  MOVFF  4E,302
....................    payload_buff[16] = make8(FIRMWARE_VERSION,0); 
027EA:  MOVLW  13
027EC:  MOVWF  x03
....................    payload_buff[17] = make8(FIRMWARE_VERSION,1);   
027EE:  MOVLW  E3
027F0:  MOVWF  x04
....................    generate_message_and_send_ISR(); 
027F2:  MOVLB  0
027F4:  RCALL  2498
027F6:  GOTO   2A9A (RETURN)
.................... } 
.................... void send_gps_point_msg_ISR(uint8_t command_id_in_response_to, uint16_t msg_seq) 
.................... { 
....................    prepare_prefix_and_payload_ISR(23); 
027FA:  MOVLW  17
027FC:  MOVLB  6
027FE:  MOVWF  x08
02800:  MOVLB  0
02802:  RCALL  23FC
....................    payload_buff[4] = make8(msg_seq,0); 
02804:  MOVFF  604,2F7
02808:  MOVLB  2
....................    payload_buff[5] = make8(msg_seq,1); 
0280A:  MOVFF  605,2F8
0280E:  MOVLB  2
....................    payload_buff[6] = command_id_in_response_to; 
02810:  MOVFF  603,2F9
....................    payload_buff[7] = MSG_MOTE_GPS_POINT_MSG; 
02814:  MOVLW  96
02816:  MOVWF  xFA
....................    payload_buff[8] = make8(global_sprinkler_num, 0); 
02818:  MOVFF  95,2FB
0281C:  MOVLB  2
....................    payload_buff[9] = make8(global_sprinkler_num, 1); 
0281E:  MOVFF  96,2FC
02822:  MOVLB  2
....................    generate_message_and_send_ISR(); 
02824:  MOVLB  0
02826:  RCALL  2498
02828:  GOTO   2A9A (RETURN)
.................... }                  
.................... void send_pressure_xdcr_msg_ISR(uint8_t command_id_in_response_to, uint16_t msg_seq)    
.................... {                          
....................    prepare_prefix_and_payload_ISR(12);  
0282C:  MOVLW  0C
0282E:  MOVLB  6
02830:  MOVWF  x08
02832:  MOVLB  0
02834:  RCALL  23FC
....................    payload_buff[4] = make8(msg_seq,0);                                                    
02836:  MOVFF  604,2F7
0283A:  MOVLB  2
....................    payload_buff[5] = make8(msg_seq,1);       
0283C:  MOVFF  605,2F8
02840:  MOVLB  2
....................    payload_buff[6] = command_id_in_response_to;                    
02842:  MOVFF  603,2F9
....................    payload_buff[7] = MSG_MOTE_XDCR_READ_MSG;     
02846:  MOVLW  98
02848:  MOVWF  xFA
....................    payload_buff[8] = make8(global_sprinkler_num, 0);    
0284A:  MOVFF  95,2FB
0284E:  MOVLB  2
....................    payload_buff[9] = make8(global_sprinkler_num, 1);                        
02850:  MOVFF  96,2FC
02854:  MOVLB  2
....................    payload_buff[10] = make8(global_xdcr_output, 0);                  
02856:  MOVFF  4B,2FD
....................    payload_buff[11] = make8(global_xdcr_output, 1);       
0285A:  MOVFF  4C,2FE
....................    generate_message_and_send_ISR();                               
0285E:  MOVLB  0
02860:  RCALL  2498
02862:  GOTO   2A9A (RETURN)
.................... }  
.................... void send_error_msg_ISR(uint8_t command_id_in_response_to, uint16_t msg_seq) 
.................... { 
....................    prepare_prefix_and_payload_ISR(14); 
02866:  MOVLW  0E
02868:  MOVLB  6
0286A:  MOVWF  x08
0286C:  MOVLB  0
0286E:  RCALL  23FC
....................    payload_buff[4] = make8(msg_seq,0); 
02870:  MOVFF  604,2F7
02874:  MOVLB  2
....................    payload_buff[5] = make8(msg_seq,1); 
02876:  MOVFF  605,2F8
0287A:  MOVLB  2
....................    payload_buff[6] = command_id_in_response_to; 
0287C:  MOVFF  603,2F9
....................    payload_buff[7] = MSG_MOTE_ERROR_MSG; 
02880:  MOVLW  A0
02882:  MOVWF  xFA
....................    payload_buff[8] = make8(global_sprinkler_num, 0); 
02884:  MOVFF  95,2FB
02888:  MOVLB  2
....................    payload_buff[9] = make8(global_sprinkler_num, 1); 
0288A:  MOVFF  96,2FC
0288E:  MOVLB  2
....................    payload_buff[10] = make8(global_error_message_bitfield,0); 
02890:  MOVFF  4F8,2FD
02894:  MOVLB  2
....................    payload_buff[11] = make8(global_error_message_bitfield,1); 
02896:  MOVFF  4F9,2FE
0289A:  MOVLB  2
....................    payload_buff[12] = make8(global_error_message_bitfield,2); 
0289C:  MOVFF  4FA,2FF
028A0:  MOVLB  2
....................    payload_buff[13] = make8(global_error_message_bitfield,3); 
028A2:  MOVFF  4FB,300
028A6:  MOVLB  3
....................    generate_message_and_send_ISR(); 
028A8:  MOVLB  0
028AA:  RCALL  2498
028AC:  GOTO   2A9A (RETURN)
.................... } 
....................  
.................... #include "periph.h"                                                       
.................... // This file contains all functions definitions for the LCD and XDCR 
.................... // The globals.h file is needed 
....................  
.................... ////////////////////LCD Functions Start///////////////////////////////////////// 
....................  
.................... //************************************************************** 
.................... // These routines communicate to the 16x2 LCD display via I2C. * 
.................... // Here are the HEX codes for the 32 display positions:        * 
.................... // Line 1   00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F    * 
.................... // Line 2   40 41 42 43 44 45 46 47 48 49 4A 4B 4C 4D 4E 4F    * 
.................... //************************************************************** 
....................  
.................... void LCD_init(void)    
.................... { 
....................    output_low(LCD_RESETn);                                
*
03A66:  BCF    F8C.2
....................    
....................    delay_ms(1); 
03A68:  MOVLW  14
03A6A:  MOVWF  00
03A6C:  DECFSZ 00,F
03A6E:  BRA    3A6C
03A70:  NOP   
....................     
....................    //setup_T0_int(T0_1MS); 
....................    //while (!TMR0IF); 
....................  
....................    output_high(LCD_RESETn); 
03A72:  BSF    F8C.2
....................    //setup_T0_int(T0_100MS); 
....................    //while (!TMR0IF); 
....................     
....................    delay_ms(100); 
03A74:  MOVLW  64
03A76:  MOVLB  5
03A78:  MOVWF  x64
03A7A:  MOVLB  0
03A7C:  RCALL  3946
....................    i2c_start(); 
03A7E:  BSF    FC5.1
03A80:  BTFSC  FC5.1
03A82:  BRA    3A80
....................     
....................    global_lcd_enabled = !i2c_write(LCD_ADDRESS);    // (0x7C)WRITE LCD address 
03A84:  BCF    xA7.0
03A86:  MOVLW  7C
03A88:  MOVLB  5
03A8A:  MOVWF  x7C
03A8C:  MOVLB  0
03A8E:  RCALL  3962
03A90:  MOVF   01,W
03A92:  BNZ   3A96
03A94:  BSF    xA7.0
....................    if (!global_lcd_enabled) 
03A96:  BTFSC  xA7.0
03A98:  BRA    3AA2
....................    { 
....................       i2c_stop(); 
03A9A:  BSF    FC5.2
03A9C:  BTFSC  FC5.2
03A9E:  BRA    3A9C
....................       return; 
03AA0:  BRA    3E98
....................    } 
....................  
....................    i2c_write(0x00);              // (0x00)Control byte 
03AA2:  MOVLB  5
03AA4:  CLRF   x7C
03AA6:  MOVLB  0
03AA8:  RCALL  3962
....................    i2c_write(0x38);              // (0x38)Function Set: 8 bits, 
03AAA:  MOVLW  38
03AAC:  MOVLB  5
03AAE:  MOVWF  x7C
03AB0:  MOVLB  0
03AB2:  RCALL  3962
....................    i2c_stop();                   //  use Instruction Table 0 
03AB4:  BSF    FC5.2
03AB6:  BTFSC  FC5.2
03AB8:  BRA    3AB6
....................    delay_cycles(255); 
03ABA:  MOVLW  54
03ABC:  MOVWF  00
03ABE:  DECFSZ 00,F
03AC0:  BRA    3ABE
03AC2:  BRA    3AC4
....................     
....................    i2c_start(); 
03AC4:  BSF    FC5.0
03AC6:  BTFSC  FC5.0
03AC8:  BRA    3AC6
....................    i2c_write(LCD_ADDRESS);     // (0x7C)WRITE LCD address 
03ACA:  MOVLW  7C
03ACC:  MOVLB  5
03ACE:  MOVWF  x7C
03AD0:  MOVLB  0
03AD2:  RCALL  3962
....................    i2c_write(0x00);     // (0x00)Control byte 
03AD4:  MOVLB  5
03AD6:  CLRF   x7C
03AD8:  MOVLB  0
03ADA:  RCALL  3962
....................    i2c_write(0x40);     // set CG address 0 
03ADC:  MOVLW  40
03ADE:  MOVLB  5
03AE0:  MOVWF  x7C
03AE2:  MOVLB  0
03AE4:  RCALL  3962
....................    i2c_stop(); 
03AE6:  BSF    FC5.2
03AE8:  BTFSC  FC5.2
03AEA:  BRA    3AE8
....................    delay_cycles(255); 
03AEC:  MOVLW  54
03AEE:  MOVWF  00
03AF0:  DECFSZ 00,F
03AF2:  BRA    3AF0
03AF4:  BRA    3AF6
....................    
....................    i2c_start();         // define special character  
03AF6:  BSF    FC5.0
03AF8:  BTFSC  FC5.0
03AFA:  BRA    3AF8
....................    i2c_write(LCD_ADDRESS);     // WRITE LCD address 
03AFC:  MOVLW  7C
03AFE:  MOVLB  5
03B00:  MOVWF  x7C
03B02:  MOVLB  0
03B04:  RCALL  3962
....................    i2c_write(0x40);     // Datasend 
03B06:  MOVLW  40
03B08:  MOVLB  5
03B0A:  MOVWF  x7C
03B0C:  MOVLB  0
03B0E:  RCALL  3962
....................     
.................... // special char 0 (LEV1) 
....................    i2c_write(0b00000); 
03B10:  MOVLB  5
03B12:  CLRF   x7C
03B14:  MOVLB  0
03B16:  RCALL  3962
....................    i2c_write(0b00000); 
03B18:  MOVLB  5
03B1A:  CLRF   x7C
03B1C:  MOVLB  0
03B1E:  RCALL  3962
....................    i2c_write(0b00000); 
03B20:  MOVLB  5
03B22:  CLRF   x7C
03B24:  MOVLB  0
03B26:  RCALL  3962
....................    i2c_write(0b00000); 
03B28:  MOVLB  5
03B2A:  CLRF   x7C
03B2C:  MOVLB  0
03B2E:  RCALL  3962
....................    i2c_write(0b00000); 
03B30:  MOVLB  5
03B32:  CLRF   x7C
03B34:  MOVLB  0
03B36:  RCALL  3962
....................    i2c_write(0b00000); 
03B38:  MOVLB  5
03B3A:  CLRF   x7C
03B3C:  MOVLB  0
03B3E:  RCALL  3962
....................    i2c_write(0b00000); 
03B40:  MOVLB  5
03B42:  CLRF   x7C
03B44:  MOVLB  0
03B46:  RCALL  3962
....................    i2c_write(0b11111); 
03B48:  MOVLW  1F
03B4A:  MOVLB  5
03B4C:  MOVWF  x7C
03B4E:  MOVLB  0
03B50:  RCALL  3962
.................... // special char 1 (LEV2) 
....................    i2c_write(0b00000); 
03B52:  MOVLB  5
03B54:  CLRF   x7C
03B56:  MOVLB  0
03B58:  RCALL  3962
....................    i2c_write(0b00000); 
03B5A:  MOVLB  5
03B5C:  CLRF   x7C
03B5E:  MOVLB  0
03B60:  RCALL  3962
....................    i2c_write(0b00000); 
03B62:  MOVLB  5
03B64:  CLRF   x7C
03B66:  MOVLB  0
03B68:  RCALL  3962
....................    i2c_write(0b00000); 
03B6A:  MOVLB  5
03B6C:  CLRF   x7C
03B6E:  MOVLB  0
03B70:  RCALL  3962
....................    i2c_write(0b00000); 
03B72:  MOVLB  5
03B74:  CLRF   x7C
03B76:  MOVLB  0
03B78:  RCALL  3962
....................    i2c_write(0b00000); 
03B7A:  MOVLB  5
03B7C:  CLRF   x7C
03B7E:  MOVLB  0
03B80:  RCALL  3962
....................    i2c_write(0b11111); 
03B82:  MOVLW  1F
03B84:  MOVLB  5
03B86:  MOVWF  x7C
03B88:  MOVLB  0
03B8A:  RCALL  3962
....................    i2c_write(0b11111); 
03B8C:  MOVLW  1F
03B8E:  MOVLB  5
03B90:  MOVWF  x7C
03B92:  MOVLB  0
03B94:  RCALL  3962
.................... // special char 2 (LEV4) 
....................    i2c_write(0b00000); 
03B96:  MOVLB  5
03B98:  CLRF   x7C
03B9A:  MOVLB  0
03B9C:  RCALL  3962
....................    i2c_write(0b00000); 
03B9E:  MOVLB  5
03BA0:  CLRF   x7C
03BA2:  MOVLB  0
03BA4:  RCALL  3962
....................    i2c_write(0b00000); 
03BA6:  MOVLB  5
03BA8:  CLRF   x7C
03BAA:  MOVLB  0
03BAC:  RCALL  3962
....................    i2c_write(0b00000); 
03BAE:  MOVLB  5
03BB0:  CLRF   x7C
03BB2:  MOVLB  0
03BB4:  RCALL  3962
....................    i2c_write(0b00000); 
03BB6:  MOVLB  5
03BB8:  CLRF   x7C
03BBA:  MOVLB  0
03BBC:  RCALL  3962
....................    i2c_write(0b11111); 
03BBE:  MOVLW  1F
03BC0:  MOVLB  5
03BC2:  MOVWF  x7C
03BC4:  MOVLB  0
03BC6:  RCALL  3962
....................    i2c_write(0b00000); 
03BC8:  MOVLB  5
03BCA:  CLRF   x7C
03BCC:  MOVLB  0
03BCE:  RCALL  3962
....................    i2c_write(0b00000); 
03BD0:  MOVLB  5
03BD2:  CLRF   x7C
03BD4:  MOVLB  0
03BD6:  RCALL  3962
.................... // special char 3 (LEV5) 
....................    i2c_write(0b00000); 
03BD8:  MOVLB  5
03BDA:  CLRF   x7C
03BDC:  MOVLB  0
03BDE:  RCALL  3962
....................    i2c_write(0b00000); 
03BE0:  MOVLB  5
03BE2:  CLRF   x7C
03BE4:  MOVLB  0
03BE6:  RCALL  3962
....................    i2c_write(0b00000); 
03BE8:  MOVLB  5
03BEA:  CLRF   x7C
03BEC:  MOVLB  0
03BEE:  RCALL  3962
....................    i2c_write(0b00000); 
03BF0:  MOVLB  5
03BF2:  CLRF   x7C
03BF4:  MOVLB  0
03BF6:  RCALL  3962
....................    i2c_write(0b11111); 
03BF8:  MOVLW  1F
03BFA:  MOVLB  5
03BFC:  MOVWF  x7C
03BFE:  MOVLB  0
03C00:  RCALL  3962
....................    i2c_write(0b00000); 
03C02:  MOVLB  5
03C04:  CLRF   x7C
03C06:  MOVLB  0
03C08:  RCALL  3962
....................    i2c_write(0b00000); 
03C0A:  MOVLB  5
03C0C:  CLRF   x7C
03C0E:  MOVLB  0
03C10:  RCALL  3962
....................    i2c_write(0b00000); 
03C12:  MOVLB  5
03C14:  CLRF   x7C
03C16:  MOVLB  0
03C18:  RCALL  3962
.................... // special char 4 (LEV7) 
....................    i2c_write(0b00000); 
03C1A:  MOVLB  5
03C1C:  CLRF   x7C
03C1E:  MOVLB  0
03C20:  RCALL  3962
....................    i2c_write(0b00000); 
03C22:  MOVLB  5
03C24:  CLRF   x7C
03C26:  MOVLB  0
03C28:  RCALL  3962
....................    i2c_write(0b11111); 
03C2A:  MOVLW  1F
03C2C:  MOVLB  5
03C2E:  MOVWF  x7C
03C30:  MOVLB  0
03C32:  RCALL  3962
....................    i2c_write(0b00000); 
03C34:  MOVLB  5
03C36:  CLRF   x7C
03C38:  MOVLB  0
03C3A:  RCALL  3962
....................    i2c_write(0b00000); 
03C3C:  MOVLB  5
03C3E:  CLRF   x7C
03C40:  MOVLB  0
03C42:  RCALL  3962
....................    i2c_write(0b00000); 
03C44:  MOVLB  5
03C46:  CLRF   x7C
03C48:  MOVLB  0
03C4A:  RCALL  3962
....................    i2c_write(0b00000); 
03C4C:  MOVLB  5
03C4E:  CLRF   x7C
03C50:  MOVLB  0
03C52:  RCALL  3962
....................    i2c_write(0b00000); 
03C54:  MOVLB  5
03C56:  CLRF   x7C
03C58:  MOVLB  0
03C5A:  RCALL  3962
.................... // special char 5 (LEV8) 
....................    i2c_write(0b00000); 
03C5C:  MOVLB  5
03C5E:  CLRF   x7C
03C60:  MOVLB  0
03C62:  RCALL  3962
....................    i2c_write(0b11111); 
03C64:  MOVLW  1F
03C66:  MOVLB  5
03C68:  MOVWF  x7C
03C6A:  MOVLB  0
03C6C:  RCALL  3962
....................    i2c_write(0b00000); 
03C6E:  MOVLB  5
03C70:  CLRF   x7C
03C72:  MOVLB  0
03C74:  RCALL  3962
....................    i2c_write(0b00000); 
03C76:  MOVLB  5
03C78:  CLRF   x7C
03C7A:  MOVLB  0
03C7C:  RCALL  3962
....................    i2c_write(0b00000); 
03C7E:  MOVLB  5
03C80:  CLRF   x7C
03C82:  MOVLB  0
03C84:  RCALL  3962
....................    i2c_write(0b00000); 
03C86:  MOVLB  5
03C88:  CLRF   x7C
03C8A:  MOVLB  0
03C8C:  RCALL  3962
....................    i2c_write(0b00000); 
03C8E:  MOVLB  5
03C90:  CLRF   x7C
03C92:  MOVLB  0
03C94:  RCALL  3962
....................    i2c_write(0b00000); 
03C96:  MOVLB  5
03C98:  CLRF   x7C
03C9A:  MOVLB  0
03C9C:  RCALL  3962
.................... // special char 6 (LEV9) 
....................    i2c_write(0b11111); 
03C9E:  MOVLW  1F
03CA0:  MOVLB  5
03CA2:  MOVWF  x7C
03CA4:  MOVLB  0
03CA6:  RCALL  3962
....................    i2c_write(0b11111); 
03CA8:  MOVLW  1F
03CAA:  MOVLB  5
03CAC:  MOVWF  x7C
03CAE:  MOVLB  0
03CB0:  RCALL  3962
....................    i2c_write(0b00000); 
03CB2:  MOVLB  5
03CB4:  CLRF   x7C
03CB6:  MOVLB  0
03CB8:  RCALL  3962
....................    i2c_write(0b00000); 
03CBA:  MOVLB  5
03CBC:  CLRF   x7C
03CBE:  MOVLB  0
03CC0:  RCALL  3962
....................    i2c_write(0b00000); 
03CC2:  MOVLB  5
03CC4:  CLRF   x7C
03CC6:  MOVLB  0
03CC8:  RCALL  3962
....................    i2c_write(0b00000); 
03CCA:  MOVLB  5
03CCC:  CLRF   x7C
03CCE:  MOVLB  0
03CD0:  RCALL  3962
....................    i2c_write(0b00000); 
03CD2:  MOVLB  5
03CD4:  CLRF   x7C
03CD6:  MOVLB  0
03CD8:  RCALL  3962
....................    i2c_write(0b00000); 
03CDA:  MOVLB  5
03CDC:  CLRF   x7C
03CDE:  MOVLB  0
03CE0:  RCALL  3962
....................    // special char 7 (BIGBOX) 
....................    i2c_write(0b11111); 
03CE2:  MOVLW  1F
03CE4:  MOVLB  5
03CE6:  MOVWF  x7C
03CE8:  MOVLB  0
03CEA:  RCALL  3962
....................    i2c_write(0b11111); 
03CEC:  MOVLW  1F
03CEE:  MOVLB  5
03CF0:  MOVWF  x7C
03CF2:  MOVLB  0
03CF4:  RCALL  3962
....................    i2c_write(0b11111); 
03CF6:  MOVLW  1F
03CF8:  MOVLB  5
03CFA:  MOVWF  x7C
03CFC:  MOVLB  0
03CFE:  RCALL  3962
....................    i2c_write(0b11111); 
03D00:  MOVLW  1F
03D02:  MOVLB  5
03D04:  MOVWF  x7C
03D06:  MOVLB  0
03D08:  RCALL  3962
....................    i2c_write(0b11111); 
03D0A:  MOVLW  1F
03D0C:  MOVLB  5
03D0E:  MOVWF  x7C
03D10:  MOVLB  0
03D12:  RCALL  3962
....................    i2c_write(0b11111); 
03D14:  MOVLW  1F
03D16:  MOVLB  5
03D18:  MOVWF  x7C
03D1A:  MOVLB  0
03D1C:  RCALL  3962
....................    i2c_write(0b11111); 
03D1E:  MOVLW  1F
03D20:  MOVLB  5
03D22:  MOVWF  x7C
03D24:  MOVLB  0
03D26:  RCALL  3962
....................    i2c_write(0b00000);  
03D28:  MOVLB  5
03D2A:  CLRF   x7C
03D2C:  MOVLB  0
03D2E:  RCALL  3962
....................   
....................    i2c_stop();  
03D30:  BSF    FC5.2
03D32:  BTFSC  FC5.2
03D34:  BRA    3D32
....................  
....................    i2c_start(); 
03D36:  BSF    FC5.0
03D38:  BTFSC  FC5.0
03D3A:  BRA    3D38
....................    i2c_write(0x00);              // (0x00)Control byte 
03D3C:  MOVLB  5
03D3E:  CLRF   x7C
03D40:  MOVLB  0
03D42:  RCALL  3962
....................    i2c_write(0x38);              // (0x38)Function Set: 8 bits, 
03D44:  MOVLW  38
03D46:  MOVLB  5
03D48:  MOVWF  x7C
03D4A:  MOVLB  0
03D4C:  RCALL  3962
....................    i2c_stop();                   //  use Instruction Table 0 
03D4E:  BSF    FC5.2
03D50:  BTFSC  FC5.2
03D52:  BRA    3D50
....................     
....................    i2c_stop();  
03D54:  BSF    FC5.2
03D56:  BTFSC  FC5.2
03D58:  BRA    3D56
....................    delay_cycles(255); 
03D5A:  MOVLW  54
03D5C:  MOVWF  00
03D5E:  DECFSZ 00,F
03D60:  BRA    3D5E
03D62:  BRA    3D64
....................     
....................    i2c_start();                             
03D64:  BSF    FC5.0
03D66:  BTFSC  FC5.0
03D68:  BRA    3D66
....................    i2c_write(LCD_ADDRESS);     // (0x7C)WRITE LCD address 
03D6A:  MOVLW  7C
03D6C:  MOVLB  5
03D6E:  MOVWF  x7C
03D70:  MOVLB  0
03D72:  RCALL  3962
....................    i2c_write(0x00);     // (0x00)Control byte 
03D74:  MOVLB  5
03D76:  CLRF   x7C
03D78:  MOVLB  0
03D7A:  RCALL  3962
....................    i2c_write(0x38);     // (0x38)Function Set: 8 bits, use Instruction Table 0 
03D7C:  MOVLW  38
03D7E:  MOVLB  5
03D80:  MOVWF  x7C
03D82:  MOVLB  0
03D84:  RCALL  3962
.................... //   delay_ms(40); 
....................    delay_cycles(255); 
03D86:  MOVLW  54
03D88:  MOVWF  00
03D8A:  DECFSZ 00,F
03D8C:  BRA    3D8A
03D8E:  BRA    3D90
....................    i2c_write(0x39);     // (0x39)Function Set: 8 bits, use Instruction Table 1 
03D90:  MOVLW  39
03D92:  MOVLB  5
03D94:  MOVWF  x7C
03D96:  MOVLB  0
03D98:  RCALL  3962
.................... //   delay_ms(40); 
....................    delay_cycles(255); 
03D9A:  MOVLW  54
03D9C:  MOVWF  00
03D9E:  DECFSZ 00,F
03DA0:  BRA    3D9E
03DA2:  BRA    3DA4
....................    i2c_write(0x14);     // (0x14)Internal OSC frequency 
03DA4:  MOVLW  14
03DA6:  MOVLB  5
03DA8:  MOVWF  x7C
03DAA:  MOVLB  0
03DAC:  RCALL  3962
....................    i2c_write(0x74);     // (0x78 recommended, JG prefers 0x74)Contrast set 
03DAE:  MOVLW  74
03DB0:  MOVLB  5
03DB2:  MOVWF  x7C
03DB4:  MOVLB  0
03DB6:  RCALL  3962
....................    i2c_write(0x5E);     // (0x5E)ICON display ON, booster ON 
03DB8:  MOVLW  5E
03DBA:  MOVLB  5
03DBC:  MOVWF  x7C
03DBE:  MOVLB  0
03DC0:  RCALL  3962
....................    i2c_write(0x6D);     // (0x6D)Follower circuit ON 
03DC2:  MOVLW  6D
03DC4:  MOVLB  5
03DC6:  MOVWF  x7C
03DC8:  MOVLB  0
03DCA:  RCALL  3962
.................... //   delay_ms(200); 
....................    delay_cycles(255); 
03DCC:  MOVLW  54
03DCE:  MOVWF  00
03DD0:  DECFSZ 00,F
03DD2:  BRA    3DD0
03DD4:  BRA    3DD6
....................    i2c_write(0x0C);     // (0x0C)Entire display ON;  
03DD6:  MOVLW  0C
03DD8:  MOVLB  5
03DDA:  MOVWF  x7C
03DDC:  MOVLB  0
03DDE:  RCALL  3962
....................                         // (0x0F)Entire display ON/blink at cursor 
....................    i2c_write(0x01);     // (0x01)Clear display 
03DE0:  MOVLW  01
03DE2:  MOVLB  5
03DE4:  MOVWF  x7C
03DE6:  MOVLB  0
03DE8:  RCALL  3962
....................    delay_ms(40); 
03DEA:  MOVLW  28
03DEC:  MOVLB  5
03DEE:  MOVWF  x64
03DF0:  MOVLB  0
03DF2:  RCALL  3946
....................    i2c_write(0x06);     // (0x06)Entry Mode Set 
03DF4:  MOVLW  06
03DF6:  MOVLB  5
03DF8:  MOVWF  x7C
03DFA:  MOVLB  0
03DFC:  RCALL  3962
.................... //   delay_ms(40); 
....................    delay_cycles(255); 
03DFE:  MOVLW  54
03E00:  MOVWF  00
03E02:  DECFSZ 00,F
03E04:  BRA    3E02
03E06:  BRA    3E08
....................    i2c_write(0x38); 
03E08:  MOVLW  38
03E0A:  MOVLB  5
03E0C:  MOVWF  x7C
03E0E:  MOVLB  0
03E10:  RCALL  3962
.................... //   delay_ms(40); 
....................    delay_cycles(255); 
03E12:  MOVLW  54
03E14:  MOVWF  00
03E16:  DECFSZ 00,F
03E18:  BRA    3E16
03E1A:  BRA    3E1C
....................    i2c_stop(); 
03E1C:  BSF    FC5.2
03E1E:  BTFSC  FC5.2
03E20:  BRA    3E1E
....................     
....................  
....................    i2c_start(); 
03E22:  BSF    FC5.0
03E24:  BTFSC  FC5.0
03E26:  BRA    3E24
....................    i2c_write(LCD_ADDRESS);     // (0x7C)WRITE LCD address 
03E28:  MOVLW  7C
03E2A:  MOVLB  5
03E2C:  MOVWF  x7C
03E2E:  MOVLB  0
03E30:  RCALL  3962
....................    i2c_write(0x00);     // (0x00)Control byte 
03E32:  MOVLB  5
03E34:  CLRF   x7C
03E36:  MOVLB  0
03E38:  RCALL  3962
....................    i2c_write(0x38);     // (0x38)Function Set: 8 bits, 
03E3A:  MOVLW  38
03E3C:  MOVLB  5
03E3E:  MOVWF  x7C
03E40:  MOVLB  0
03E42:  RCALL  3962
....................                         //  use Instruction Table 0 
....................    i2c_write(0x18);     // Clear any shift 
03E44:  MOVLW  18
03E46:  MOVLB  5
03E48:  MOVWF  x7C
03E4A:  MOVLB  0
03E4C:  RCALL  3962
....................    i2c_write(0x20);     // CGRAM = 0 
03E4E:  MOVLW  20
03E50:  MOVLB  5
03E52:  MOVWF  x7C
03E54:  MOVLB  0
03E56:  RCALL  3962
....................    // JG Jan 30 2015 
....................    i2c_write(0x38); 
03E58:  MOVLW  38
03E5A:  MOVLB  5
03E5C:  MOVWF  x7C
03E5E:  MOVLB  0
03E60:  RCALL  3962
....................     
....................    i2c_stop(); 
03E62:  BSF    FC5.2
03E64:  BTFSC  FC5.2
03E66:  BRA    3E64
....................     
....................    strcpy (global_temp_line_buff, "                "); 
03E68:  CLRF   FEA
03E6A:  MOVLW  70
03E6C:  MOVWF  FE9
03E6E:  MOVLW  00
03E70:  CALL   04CA
03E74:  TBLRD*-
03E76:  TBLRD*+
03E78:  MOVF   FF5,W
03E7A:  MOVWF  FEE
03E7C:  IORLW  00
03E7E:  BNZ   3E76
....................    LCD_line1(global_temp_line_buff); 
03E80:  MOVLB  5
03E82:  CLRF   x64
03E84:  MOVLW  70
03E86:  MOVWF  x63
03E88:  MOVLB  0
03E8A:  RCALL  39B0
....................    LCD_line2(global_temp_line_buff); 
03E8C:  MOVLB  5
03E8E:  CLRF   x64
03E90:  MOVLW  70
03E92:  MOVWF  x63
03E94:  MOVLB  0
03E96:  RCALL  3A0A
....................  
....................    return; 
03E98:  RETURN 0
.................... } 
....................  
.................... void LCD_line1(unsigned char *text) 
.................... { 
....................    uint8_t  n; 
....................  
....................    if (!global_lcd_enabled) return;   
*
039B0:  BTFSS  xA7.0
039B2:  BRA    3A08
....................    LCD_position(0x00);   // Move to start of first line 
039B4:  MOVLB  5
039B6:  CLRF   x7A
039B8:  MOVLB  0
039BA:  RCALL  397E
....................    i2c_start(); 
039BC:  BSF    FC5.0
039BE:  BTFSC  FC5.0
039C0:  BRA    39BE
....................    i2c_write(LCD_ADDRESS);   // WRITE LCD address 
039C2:  MOVLW  7C
039C4:  MOVLB  5
039C6:  MOVWF  x7C
039C8:  MOVLB  0
039CA:  RCALL  3962
....................    i2c_write(0x40);    // Datasend 
039CC:  MOVLW  40
039CE:  MOVLB  5
039D0:  MOVWF  x7C
039D2:  MOVLB  0
039D4:  RCALL  3962
....................    for(n=0;n<16;n++) 
039D6:  MOVLB  5
039D8:  CLRF   x65
039DA:  MOVF   x65,W
039DC:  SUBLW  0F
039DE:  BNC   3A00
....................    { 
....................       i2c_write(*text); 
039E0:  MOVFF  564,03
039E4:  MOVFF  563,FE9
039E8:  MOVFF  564,FEA
039EC:  MOVFF  FEF,57C
039F0:  MOVLB  0
039F2:  RCALL  3962
....................       ++text; 
039F4:  MOVLB  5
039F6:  INCF   x63,F
039F8:  BTFSC  FD8.2
039FA:  INCF   x64,F
039FC:  INCF   x65,F
039FE:  BRA    39DA
....................    } 
....................    i2c_stop(); 
03A00:  BSF    FC5.2
03A02:  BTFSC  FC5.2
03A04:  BRA    3A02
03A06:  MOVLB  0
03A08:  RETURN 0
.................... } 
....................  
.................... void LCD_line2(unsigned char *text) 
.................... { 
....................    uint8_t  n; 
....................     
....................    if (!global_lcd_enabled) return; 
03A0A:  BTFSS  xA7.0
03A0C:  BRA    3A64
....................    LCD_position(0x40);   // Move to start of second line 
03A0E:  MOVLW  40
03A10:  MOVLB  5
03A12:  MOVWF  x7A
03A14:  MOVLB  0
03A16:  RCALL  397E
....................    i2c_start(); 
03A18:  BSF    FC5.0
03A1A:  BTFSC  FC5.0
03A1C:  BRA    3A1A
....................    i2c_write(LCD_ADDRESS);   // WRITE LCD address 
03A1E:  MOVLW  7C
03A20:  MOVLB  5
03A22:  MOVWF  x7C
03A24:  MOVLB  0
03A26:  RCALL  3962
....................    i2c_write(0x40);    // Datasend 
03A28:  MOVLW  40
03A2A:  MOVLB  5
03A2C:  MOVWF  x7C
03A2E:  MOVLB  0
03A30:  RCALL  3962
....................    for(n=0;n<16;n++) 
03A32:  MOVLB  5
03A34:  CLRF   x65
03A36:  MOVF   x65,W
03A38:  SUBLW  0F
03A3A:  BNC   3A5C
....................    { 
....................       i2c_write(*text); 
03A3C:  MOVFF  564,03
03A40:  MOVFF  563,FE9
03A44:  MOVFF  564,FEA
03A48:  MOVFF  FEF,57C
03A4C:  MOVLB  0
03A4E:  RCALL  3962
....................       ++text; 
03A50:  MOVLB  5
03A52:  INCF   x63,F
03A54:  BTFSC  FD8.2
03A56:  INCF   x64,F
03A58:  INCF   x65,F
03A5A:  BRA    3A36
....................    } 
....................    i2c_stop(); 
03A5C:  BSF    FC5.2
03A5E:  BTFSC  FC5.2
03A60:  BRA    3A5E
03A62:  MOVLB  0
03A64:  RETURN 0
.................... } 
....................  
.................... void LCD_place_text(unsigned char *text, int1 row, uint8_t col, uint8_t length) 
.................... { 
....................    //places text at a particular position (row (0 or 1), col (0-15)). 
....................    //not much error checking (for speed) on row/col or length (don't cause seg fault) 
....................     
....................    uint8_t n; 
....................     
....................    if (!global_lcd_enabled) return; 
*
069B4:  BTFSS  xA7.0
069B6:  BRA    6A3A
....................    if (col < 16) 
069B8:  MOVLB  5
069BA:  MOVF   x76,W
069BC:  SUBLW  0F
069BE:  BNC   6A38
....................    { 
....................       if (row == 0) LCD_position(col);   //set LCD position (row,col) 
069C0:  MOVF   x75,F
069C2:  BNZ   69D2
069C4:  MOVFF  576,57A
069C8:  MOVLB  0
069CA:  CALL   397E
069CE:  BRA    69E0
069D0:  MOVLB  5
....................       else LCD_position(0x40 + col); 
069D2:  MOVLW  40
069D4:  ADDWF  x76,W
069D6:  MOVWF  x79
069D8:  MOVWF  x7A
069DA:  MOVLB  0
069DC:  CALL   397E
....................        
....................       i2c_start(); 
069E0:  BSF    FC5.0
069E2:  BTFSC  FC5.0
069E4:  BRA    69E2
....................       i2c_write(LCD_ADDRESS);   // WRITE LCD address 
069E6:  MOVLW  7C
069E8:  MOVLB  5
069EA:  MOVWF  x7C
069EC:  MOVLB  0
069EE:  CALL   3962
....................       i2c_write(0x40);    // Datasend 
069F2:  MOVLW  40
069F4:  MOVLB  5
069F6:  MOVWF  x7C
069F8:  MOVLB  0
069FA:  CALL   3962
....................       for(n = 0; ((n < length) && ((n + col) < 16)); n++) 
069FE:  MOVLB  5
06A00:  CLRF   x78
06A02:  MOVF   x77,W
06A04:  SUBWF  x78,W
06A06:  BC    6A32
06A08:  MOVF   x76,W
06A0A:  ADDWF  x78,W
06A0C:  SUBLW  0F
06A0E:  BNC   6A32
....................       { 
....................         i2c_write(*text); 
06A10:  MOVFF  574,03
06A14:  MOVFF  573,FE9
06A18:  MOVFF  574,FEA
06A1C:  MOVFF  FEF,57C
06A20:  MOVLB  0
06A22:  CALL   3962
....................         ++text; 
06A26:  MOVLB  5
06A28:  INCF   x73,F
06A2A:  BTFSC  FD8.2
06A2C:  INCF   x74,F
06A2E:  INCF   x78,F
06A30:  BRA    6A02
....................       } 
....................       i2c_stop(); 
06A32:  BSF    FC5.2
06A34:  BTFSC  FC5.2
06A36:  BRA    6A34
06A38:  MOVLB  0
....................    } 
06A3A:  RETURN 0
.................... } 
....................  
.................... void LCD_place_char(char ascii, int1 row, uint8_t col) 
.................... { 
....................    //places a char at a particular position (row (0 or 1), col (0-15)). 
....................    //no error checking (for speed) on row/col (don't cause seg fault) 
....................     
....................    if (!global_lcd_enabled) return; 
*
04D86:  BTFSS  xA7.0
04D88:  BRA    4DB8
....................    if (col < 16) 
04D8A:  MOVLB  5
04D8C:  MOVF   x5C,W
04D8E:  SUBLW  0F
04D90:  BNC   4DBA
....................    { 
....................       if (row == 0) LCD_position(col);   //set LCD position (row,col) 
04D92:  MOVF   x5B,F
04D94:  BNZ   4DA4
04D96:  MOVFF  55C,57A
04D9A:  MOVLB  0
04D9C:  CALL   397E
04DA0:  BRA    4DB2
04DA2:  MOVLB  5
....................       else LCD_position(0x40 + col); 
04DA4:  MOVLW  40
04DA6:  ADDWF  x5C,W
04DA8:  MOVWF  x5D
04DAA:  MOVWF  x7A
04DAC:  MOVLB  0
04DAE:  CALL   397E
....................        
....................       LCD_char(ascii); 
04DB2:  MOVFF  55A,55D
04DB6:  BRA    4D52
04DB8:  MOVLB  5
....................    } 
04DBA:  MOVLB  0
04DBC:  RETURN 0
.................... } 
....................  
.................... void LCD_place_uint8(uint8_t num, int1 row, uint8_t col, uint8_t length) 
.................... { 
....................    uint8_t n;  
....................     
....................    if (!global_lcd_enabled) return;   
*
06B16:  BTFSS  xA7.0
06B18:  BRA    6BA4
....................     
....................    if (length <= 3) 
06B1A:  MOVLB  5
06B1C:  MOVF   x67,W
06B1E:  SUBLW  03
06B20:  BNC   6BA6
....................    { 
....................       for (n = 0; n < 3; n++) 
06B22:  CLRF   x68
06B24:  MOVF   x68,W
06B26:  SUBLW  02
06B28:  BNC   6B6A
....................       { 
....................          *(global_temp_line_buff + (2 - n)) = ('0' + (num%10)); 
06B2A:  MOVLW  02
06B2C:  BSF    FD8.0
06B2E:  SUBFWB x68,W
06B30:  ADDLW  70
06B32:  MOVWF  01
06B34:  CLRF   03
06B36:  BTFSC  FD8.0
06B38:  INCF   03,F
06B3A:  MOVWF  FE9
06B3C:  MOVFF  03,FEA
06B40:  MOVFF  564,56B
06B44:  MOVLW  0A
06B46:  MOVWF  x6C
06B48:  MOVLB  0
06B4A:  RCALL  6AEA
06B4C:  MOVF   00,W
06B4E:  ADDLW  30
06B50:  MOVWF  FEF
....................          num/=10; 
06B52:  MOVFF  564,56B
06B56:  MOVLW  0A
06B58:  MOVLB  5
06B5A:  MOVWF  x6C
06B5C:  MOVLB  0
06B5E:  RCALL  6AEA
06B60:  MOVFF  01,564
06B64:  MOVLB  5
06B66:  INCF   x68,F
06B68:  BRA    6B24
....................       } 
....................       global_extra_lcd_ptr = global_temp_line_buff; 
06B6A:  MOVLB  0
06B6C:  CLRF   x82
06B6E:  MOVLW  70
06B70:  MOVWF  x81
....................       for (n = length; n < 3; n++) 
06B72:  MOVFF  567,568
06B76:  MOVLB  5
06B78:  MOVF   x68,W
06B7A:  SUBLW  02
06B7C:  BNC   6B8C
....................       { 
....................          ++global_extra_lcd_ptr; 
06B7E:  MOVLB  0
06B80:  INCF   x81,F
06B82:  BTFSC  FD8.2
06B84:  INCF   x82,F
06B86:  MOVLB  5
06B88:  INCF   x68,F
06B8A:  BRA    6B78
....................       } 
....................        
....................       LCD_place_text(global_extra_lcd_ptr,row, col, length); 
06B8C:  MOVFF  82,574
06B90:  MOVFF  81,573
06B94:  MOVFF  565,575
06B98:  MOVFF  566,576
06B9C:  MOVFF  567,577
06BA0:  MOVLB  0
06BA2:  RCALL  69B4
06BA4:  MOVLB  5
....................    }    
06BA6:  MOVLB  0
06BA8:  RETURN 0
.................... } 
....................  
.................... void LCD_place_uint16(uint16_t num, int1 row, uint8_t col, uint8_t length) 
.................... { 
....................    uint8_t n;   
....................    char *global_temp_line_buff[5]; 
....................     
....................    if (!global_lcd_enabled) return;   
*
06A3C:  BTFSS  xA7.0
06A3E:  BRA    6AE4
....................     
....................    if (length <= 5) 
06A40:  MOVLB  5
06A42:  MOVF   x67,W
06A44:  SUBLW  05
06A46:  BNC   6AE6
....................    { 
....................       for (n = 0; n < 5; n++) 
06A48:  CLRF   x68
06A4A:  MOVF   x68,W
06A4C:  SUBLW  04
06A4E:  BNC   6AA8
....................       { 
....................          *(global_temp_line_buff + (4 - n)) = ('0' + (num%10)); 
06A50:  MOVLW  04
06A52:  BSF    FD8.0
06A54:  SUBFWB x68,W
06A56:  ADDLW  69
06A58:  MOVWF  01
06A5A:  MOVLW  05
06A5C:  MOVWF  03
06A5E:  BTFSC  FD8.0
06A60:  INCF   03,F
06A62:  MOVFF  01,FE9
06A66:  MOVFF  03,FEA
06A6A:  MOVFF  564,576
06A6E:  MOVFF  563,575
06A72:  CLRF   x78
06A74:  MOVLW  0A
06A76:  MOVWF  x77
06A78:  MOVLB  0
06A7A:  CALL   4384
06A7E:  MOVF   00,W
06A80:  ADDLW  30
06A82:  MOVWF  FEF
....................          num/=10; 
06A84:  MOVFF  564,576
06A88:  MOVFF  563,575
06A8C:  MOVLB  5
06A8E:  CLRF   x78
06A90:  MOVLW  0A
06A92:  MOVWF  x77
06A94:  MOVLB  0
06A96:  CALL   4384
06A9A:  MOVFF  02,564
06A9E:  MOVFF  01,563
06AA2:  MOVLB  5
06AA4:  INCF   x68,F
06AA6:  BRA    6A4A
....................       } 
....................       global_extra_lcd_ptr = global_temp_line_buff; 
06AA8:  MOVLW  05
06AAA:  MOVLB  0
06AAC:  MOVWF  x82
06AAE:  MOVLW  69
06AB0:  MOVWF  x81
....................       for (n = length; n < 5; n++) 
06AB2:  MOVFF  567,568
06AB6:  MOVLB  5
06AB8:  MOVF   x68,W
06ABA:  SUBLW  04
06ABC:  BNC   6ACC
....................       { 
....................          ++global_extra_lcd_ptr; 
06ABE:  MOVLB  0
06AC0:  INCF   x81,F
06AC2:  BTFSC  FD8.2
06AC4:  INCF   x82,F
06AC6:  MOVLB  5
06AC8:  INCF   x68,F
06ACA:  BRA    6AB8
....................       } 
....................        
....................       LCD_place_text(global_extra_lcd_ptr,row, col, length); 
06ACC:  MOVFF  82,574
06AD0:  MOVFF  81,573
06AD4:  MOVFF  565,575
06AD8:  MOVFF  566,576
06ADC:  MOVFF  567,577
06AE0:  MOVLB  0
06AE2:  RCALL  69B4
06AE4:  MOVLB  5
....................    }    
06AE6:  MOVLB  0
06AE8:  RETURN 0
.................... } 
....................  
.................... void LCD_place_uint32(uint32_t num, int1 row, uint8_t col, uint8_t length) 
.................... { 
....................    uint8_t n;   
....................     
....................    if (!global_lcd_enabled) return;   
*
06BAA:  BTFSS  xA7.0
06BAC:  BRA    6CC6
....................     
....................    if (length <= 10) 
06BAE:  MOVLB  5
06BB0:  MOVF   x5C,W
06BB2:  SUBLW  0A
06BB4:  BTFSS  FD8.0
06BB6:  BRA    6CC8
....................    { 
....................       for (n = 0; n < 10; n++) 
06BB8:  CLRF   x5D
06BBA:  MOVF   x5D,W
06BBC:  SUBLW  09
06BBE:  BNC   6C8C
....................       { 
....................          *(global_temp_line_buff + (9 - n)) = ('0' + (num%10)); 
06BC0:  MOVLW  09
06BC2:  BSF    FD8.0
06BC4:  SUBFWB x5D,W
06BC6:  ADDLW  70
06BC8:  MOVWF  01
06BCA:  CLRF   03
06BCC:  BTFSC  FD8.0
06BCE:  INCF   03,F
06BD0:  MOVWF  x5E
06BD2:  MOVFF  03,55F
06BD6:  MOVFF  FEA,561
06BDA:  MOVFF  FE9,560
06BDE:  BSF    FD8.1
06BE0:  MOVLW  05
06BE2:  MOVWF  FEA
06BE4:  MOVLW  62
06BE6:  MOVWF  FE9
06BE8:  CLRF   19
06BEA:  BTFSC  FF2.7
06BEC:  BSF    19.7
06BEE:  BCF    FF2.7
06BF0:  MOVFF  559,619
06BF4:  MOVFF  558,618
06BF8:  MOVFF  557,617
06BFC:  MOVFF  556,616
06C00:  MOVLB  6
06C02:  CLRF   x1D
06C04:  CLRF   x1C
06C06:  CLRF   x1B
06C08:  MOVLW  0A
06C0A:  MOVWF  x1A
06C0C:  MOVLB  0
06C0E:  CALL   2570
06C12:  BTFSC  19.7
06C14:  BSF    FF2.7
06C16:  MOVFF  562,00
06C1A:  MOVFF  563,01
06C1E:  MOVFF  564,02
06C22:  MOVFF  565,03
06C26:  MOVFF  561,FEA
06C2A:  MOVFF  560,FE9
06C2E:  MOVLW  30
06C30:  ADDWF  00,F
06C32:  MOVLW  00
06C34:  ADDWFC 01,F
06C36:  ADDWFC 02,F
06C38:  ADDWFC 03,F
06C3A:  MOVFF  55F,FEA
06C3E:  MOVFF  55E,FE9
06C42:  MOVFF  00,FEF
....................          num/=10; 
06C46:  BCF    FD8.1
06C48:  CLRF   19
06C4A:  BTFSC  FF2.7
06C4C:  BSF    19.7
06C4E:  BCF    FF2.7
06C50:  MOVFF  559,619
06C54:  MOVFF  558,618
06C58:  MOVFF  557,617
06C5C:  MOVFF  556,616
06C60:  MOVLB  6
06C62:  CLRF   x1D
06C64:  CLRF   x1C
06C66:  CLRF   x1B
06C68:  MOVLW  0A
06C6A:  MOVWF  x1A
06C6C:  MOVLB  0
06C6E:  CALL   2570
06C72:  BTFSC  19.7
06C74:  BSF    FF2.7
06C76:  MOVFF  03,559
06C7A:  MOVFF  02,558
06C7E:  MOVFF  01,557
06C82:  MOVFF  00,556
06C86:  MOVLB  5
06C88:  INCF   x5D,F
06C8A:  BRA    6BBA
....................       } 
....................       global_extra_lcd_ptr = global_temp_line_buff; 
06C8C:  MOVLB  0
06C8E:  CLRF   x82
06C90:  MOVLW  70
06C92:  MOVWF  x81
....................       for (n = length; n < 10; n++) 
06C94:  MOVFF  55C,55D
06C98:  MOVLB  5
06C9A:  MOVF   x5D,W
06C9C:  SUBLW  09
06C9E:  BNC   6CAE
....................       { 
....................          ++global_extra_lcd_ptr; 
06CA0:  MOVLB  0
06CA2:  INCF   x81,F
06CA4:  BTFSC  FD8.2
06CA6:  INCF   x82,F
06CA8:  MOVLB  5
06CAA:  INCF   x5D,F
06CAC:  BRA    6C9A
....................       } 
....................        
....................       LCD_place_text(global_extra_lcd_ptr,row, col, length); 
06CAE:  MOVFF  82,574
06CB2:  MOVFF  81,573
06CB6:  MOVFF  55A,575
06CBA:  MOVFF  55B,576
06CBE:  MOVFF  55C,577
06CC2:  MOVLB  0
06CC4:  RCALL  69B4
06CC6:  MOVLB  5
....................    }    
06CC8:  MOVLB  0
06CCA:  RETURN 0
.................... } 
....................  
.................... void LCD_clear(void) 
.................... { 
....................    if (!global_lcd_enabled) return; 
*
05E1A:  BTFSS  xA7.0
05E1C:  BRA    5E52
....................     
....................    strcpy (global_temp_line_buff, "                "); 
05E1E:  CLRF   FEA
05E20:  MOVLW  70
05E22:  MOVWF  FE9
05E24:  MOVLW  00
05E26:  CALL   04CA
05E2A:  TBLRD*-
05E2C:  TBLRD*+
05E2E:  MOVF   FF5,W
05E30:  MOVWF  FEE
05E32:  IORLW  00
05E34:  BNZ   5E2C
....................    LCD_line1(global_temp_line_buff); 
05E36:  MOVLB  5
05E38:  CLRF   x64
05E3A:  MOVLW  70
05E3C:  MOVWF  x63
05E3E:  MOVLB  0
05E40:  CALL   39B0
....................    LCD_line2(global_temp_line_buff); 
05E44:  MOVLB  5
05E46:  CLRF   x64
05E48:  MOVLW  70
05E4A:  MOVWF  x63
05E4C:  MOVLB  0
05E4E:  CALL   3A0A
05E52:  RETURN 0
.................... } 
....................  
.................... void LCD_clear_line1(void) 
.................... { 
....................    if (!global_lcd_enabled) return; 
....................     
....................    strcpy (global_temp_line_buff, "                "); 
....................    LCD_line1(global_temp_line_buff); 
.................... } 
....................  
.................... void LCD_clear_line2(void) 
.................... { 
....................    if (!global_lcd_enabled) return; 
....................     
....................    strcpy (global_temp_line_buff, "                "); 
....................    LCD_line2(global_temp_line_buff); 
.................... } 
....................  
.................... void LCD_position(int position) 
.................... { 
....................    if (!global_lcd_enabled) return; 
*
0397E:  BTFSS  xA7.0
03980:  BRA    39AE
....................    i2c_start();                             
03982:  BSF    FC5.0
03984:  BTFSC  FC5.0
03986:  BRA    3984
....................    i2c_write(LCD_ADDRESS);     // (0x7C)WRITE LCD address 
03988:  MOVLW  7C
0398A:  MOVLB  5
0398C:  MOVWF  x7C
0398E:  MOVLB  0
03990:  RCALL  3962
....................    i2c_write(0x00);     // (0x00)Control byte 
03992:  MOVLB  5
03994:  CLRF   x7C
03996:  MOVLB  0
03998:  RCALL  3962
....................    i2c_write(0x80+position); //  
0399A:  MOVLW  80
0399C:  MOVLB  5
0399E:  ADDWF  x7A,W
039A0:  MOVWF  x7B
039A2:  MOVWF  x7C
039A4:  MOVLB  0
039A6:  RCALL  3962
....................    i2c_stop(); 
039A8:  BSF    FC5.2
039AA:  BTFSC  FC5.2
039AC:  BRA    39AA
039AE:  RETURN 0
.................... } 
....................  
.................... void LCD_char(char ascii)    
.................... { 
....................    if (!global_lcd_enabled) return; 
*
04D52:  BTFSS  xA7.0
04D54:  BRA    4D82
....................    i2c_start();                             
04D56:  BSF    FC5.0
04D58:  BTFSC  FC5.0
04D5A:  BRA    4D58
....................    i2c_write(LCD_ADDRESS);   // WRITE LCD address 
04D5C:  MOVLW  7C
04D5E:  MOVLB  5
04D60:  MOVWF  x7C
04D62:  MOVLB  0
04D64:  CALL   3962
....................    i2c_write(0x40);    // Datasend 
04D68:  MOVLW  40
04D6A:  MOVLB  5
04D6C:  MOVWF  x7C
04D6E:  MOVLB  0
04D70:  CALL   3962
....................    i2c_write(ascii);    //  
04D74:  MOVFF  55D,57C
04D78:  CALL   3962
....................    i2c_stop(); 
04D7C:  BSF    FC5.2
04D7E:  BTFSC  FC5.2
04D80:  BRA    4D7E
04D82:  GOTO   4DB8 (RETURN)
.................... } 
....................  
.................... void LCD_shutdown(void)    
.................... {        
....................  
....................    if (!global_lcd_enabled) return;   
*
096C8:  BTFSS  xA7.0
096CA:  BRA    973C
....................        
....................    output_low(LCD_RESETn); 
096CC:  BCF    F8C.2
....................    delay_ms(5); 
096CE:  MOVLW  67
096D0:  MOVWF  00
096D2:  DECFSZ 00,F
096D4:  BRA    96D2
096D6:  BRA    96D8
....................    output_high(LCD_RESETn); 
096D8:  BSF    F8C.2
....................     
....................    i2c_start();                             
096DA:  BSF    FC5.0
096DC:  BTFSC  FC5.0
096DE:  BRA    96DC
....................    i2c_write(LCD_ADDRESS);     // WRITE LCD address 
096E0:  MOVLW  7C
096E2:  MOVLB  5
096E4:  MOVWF  x7C
096E6:  MOVLB  0
096E8:  CALL   3962
....................    i2c_write(0x00);     // Control byte 
096EC:  MOVLB  5
096EE:  CLRF   x7C
096F0:  MOVLB  0
096F2:  CALL   3962
....................    i2c_write(0x39);     // Function Set: 8 bits, use Instruction Table 1 
096F6:  MOVLW  39
096F8:  MOVLB  5
096FA:  MOVWF  x7C
096FC:  MOVLB  0
096FE:  CALL   3962
....................    i2c_write(0x52);     // ICON display OFF, booster OFF 
09702:  MOVLW  52
09704:  MOVLB  5
09706:  MOVWF  x7C
09708:  MOVLB  0
0970A:  CALL   3962
....................    i2c_write(0x60);     // Follower circuit OFF 
0970E:  MOVLW  60
09710:  MOVLB  5
09712:  MOVWF  x7C
09714:  MOVLB  0
09716:  CALL   3962
....................    i2c_write(0x08);     // Entire display OFF 
0971A:  MOVLW  08
0971C:  MOVLB  5
0971E:  MOVWF  x7C
09720:  MOVLB  0
09722:  CALL   3962
....................    i2c_stop(); 
09726:  BSF    FC5.2
09728:  BTFSC  FC5.2
0972A:  BRA    9728
....................     
....................    output_low(LCD_RESETn); 
0972C:  BCF    F8C.2
....................    delay_ms(5); 
0972E:  MOVLW  67
09730:  MOVWF  00
09732:  DECFSZ 00,F
09734:  BRA    9732
09736:  BRA    9738
....................    output_high(LCD_RESETn); 
09738:  BSF    F8C.2
....................    global_lcd_enabled = 0; 
0973A:  BCF    xA7.0
0973C:  GOTO   97C2 (RETURN)
.................... } 
....................  
.................... void LCD_startup_splash(void) 
.................... {                               
....................    uint8_t n; 
....................     
....................    if (!global_lcd_enabled) return; 
....................     
....................    strcpy(global_temp_line_buff, "Jain Genesys    "); 
....................    for (n = 0; n < 16; n++) 
....................       { 
....................       LCD_place_text(global_temp_line_buff,0,(15-n),16); 
....................       setup_T0_int(T0_100MS); 
....................       while (!TMR0IF); 
....................       } 
....................    strcpy(global_temp_line_buff, "Version         ");    
....................    for (n = 0; n < 16; n++) 
....................    { 
....................       LCD_place_text(global_temp_line_buff,1,(15-n),16); 
....................       setup_T0_int(T0_100MS); 
....................       while (!TMR0IF); 
....................    }    
....................    strcpy(global_temp_line_buff, global_firmware_version_string); 
....................    LCD_place_text(global_temp_line_buff,1,8,4); 
....................    setup_T0_int(T0_2S); 
....................    while (!TMR0IF); 
....................    for (n = 0; n < 16; n++) 
....................    { 
....................       LCD_place_char(' ',0,(15-n)); 
....................       LCD_place_char(' ',1,(15-n)); 
....................       setup_T0_int(T0_100MS); 
....................       while (!TMR0IF);  
....................    }    
.................... } 
.................... /* 
.................... void LCD_display_battery_voltage(int1 lcd_line) 
.................... { 
....................    //Grabs and displays battery voltage on LCD 
....................    //Takes the LCD line that it should be displayed 
....................    //on as input. 
....................  
....................     
....................    uint8_t temp_bat_int_part = 0; 
....................    uint16_t temp_bat_fract_part = 0; 
....................    uint32_t temp_bat_both_part = 0; 
....................    char * digit_result; 
....................     
....................    if (!global_lcd_enabled) return; 
....................    //set line buffer to all spaces 
....................    char lcd_line_buff[17] = {' '}; 
....................     
....................    strcpy (lcd_line_buff, "Battery = ?.???V"); 
....................  
....................    // get the battery count (not charging) 
....................    // and convert it to a voltage 
....................    temp_bat_both_part = calc_vbatt(get_vbatt(1)); 
....................    temp_bat_fract_part = (uint16_t) (temp_bat_both_part); 
....................    temp_bat_int_part = (uint8_t) (temp_bat_both_part >> 16); 
....................    digit_result = word_to_4dig_new(temp_bat_fract_part); 
....................     
....................     
....................    if (digit_result != 0) 
....................    { 
....................       lcd_line_buff[10] = '0' + temp_bat_int_part; 
....................       lcd_line_buff[12] = digit_result[3]; 
....................       lcd_line_buff[13] = digit_result[2]; 
....................       lcd_line_buff[14] = digit_result[1]; 
....................    } 
....................    else 
....................    { 
....................       strcpy (lcd_line_buff, "Battery ERROR!  "); 
....................    } 
....................     
....................    if (lcd_line == 0) 
....................    { 
....................       LCD_line1(lcd_line_buff); 
....................    } 
....................    else if (lcd_line == 1) 
....................    { 
....................       LCD_line2(lcd_line_buff); 
....................    } 
.................... } 
....................  
.................... uint32_t LCD_battery_screen(uint16_t vRef) 
.................... { 
.................... //Puts the battery voltage on the LCD across both screens 
.................... // 
.................... } 
....................  
....................  
.................... void LCD_display_revision(int1 lcd_line) 
.................... { 
....................    if (!global_lcd_enabled) return; 
....................    strcpy (line2_buff, "Rev.            "); 
....................    tempo_u8 = make8(FIRMWARE_REV,1); 
....................    line2_buff[4] = hi2asc(tempo_u8); 
....................     
.................... #ifdef  WIP 
....................    line2_buff[4] += 0x20;     // lowercase if work in progress 
.................... #endif 
....................    line2_buff[5] = lo2asc(tempo_u8); 
....................    tempo_u8 = make8(FIRMWARE_REV,0); 
....................    line2_buff[6] = hi2asc(tempo_u8); 
....................    line2_buff[7] = lo2asc(tempo_u8); 
....................   
.................... } 
.................... */ 
....................  
.................... void LCD_display_priority_time_stacks(void) 
.................... {                                            
....................       if (!global_lcd_enabled) return;     
....................        
....................    disable_interrupts(GLOBAL); 
....................    LCD_place_uint8(global_current_priority_queue_location, 0, 0, 3);      
....................        
....................       if (global_current_priority_queue_location != 255) 
....................       {      
....................          LCD_place_uint8(global_priority_queue[global_current_priority_queue_location], 0, 4, 3); 
....................       } 
....................       else 
....................       {       
....................          strcpy (global_temp_line_buff, "   "); 
....................          LCD_place_text(global_temp_line_buff, 0, 4, 3); 
....................       } 
....................        
....................       LCD_place_uint8(global_current_time_queue_location, 0, 8, 3); 
....................        
....................       if (global_current_time_queue_location != 255) 
....................       { 
....................          LCD_place_uint8(global_priority_queue[global_current_time_queue_location], 0, 12, 3); 
....................       } 
....................       else 
....................       {       
....................          strcpy (global_temp_line_buff, "   "); 
....................          LCD_place_text(global_temp_line_buff, 0, 12, 3); 
....................       } 
....................       enable_interrupts(GLOBAL); 
.................... }  
....................  
.................... void LCD_display_priority_time_stacks_2(void) 
.................... { 
....................    uint8_t n; 
....................     
....................    disable_interrupts(INT_CCP4); 
....................    LCD_clear(); 
....................    for (n = 0; n < MAX_TIME_QUEUE_ITEMS; n++) 
....................    { 
....................       LCD_place_uint8(n,0,0,1); 
....................       LCD_place_uint8(global_time_queue[n].pq_priority,0,2,3);                       
....................       LCD_place_uint32(global_time_queue[n].time_to_execute,0,6,5); 
....................       LCD_place_uint8(global_current_time_queue_location, 0, 12, 3);        
....................       setup_T0_int(T0_250MS);                                                       
....................       while (!TMR0IF);     
....................    }                               
....................    enable_interrupts(INT_CCP4);                                  
.................... } 
....................  
.................... void LCD_display_priority_queue(void) 
.................... { 
....................    uint8_t n; 
....................     
....................    disable_interrupts(GLOBAL); 
....................    LCD_clear(); 
....................    for (n = 0; n < MAX_PRIORITY_QUEUE_ITEMS; n++) 
....................    { 
....................       LCD_place_uint8(n,0,0,2); 
....................       LCD_place_uint8(global_priority_queue[n],0,3,3); 
....................       LCD_place_uint8(global_current_priority_queue_location, 0, 7, 3); 
....................       if (global_priority_queue[n] != EMPTY_PRIORITY_QUEUE) 
....................          setup_T0_int(T0_1S); 
....................       while (!TMR0IF); 
....................    } 
....................    enable_interrupts(GLOBAL); 
.................... } 
....................                  
.................... void LCD_display_message_queue(void)  
.................... { 
....................    uint8_t n; 
....................    disable_interrupts(INT_CCP4); 
....................     
....................    for (n = global_current_message_queue_location; n != 255; n--) 
....................    {                                                                                                                          
....................       LCD_clear(); 
....................       LCD_place_uint8(n, 0, 0, 3);                                 
....................       LCD_place_uint32(global_message_queue[n].time_to_send, 0, 4, 10); 
....................       LCD_place_uint8(global_message_queue[n].message_type, 1, 0, 3); 
....................       LCD_place_uint16(global_message_queue[n].msg_seq, 1, 4, 5);  
....................       LCD_place_uint8(global_message_queue[n].attempt_num, 1, 10, 3);  
....................       while(input(SW1n)); 
....................    }                          
....................    LCD_clear(); 
....................    enable_interrupts(INT_CCP4);   
.................... }                                                                        
.................... void LCD_display_battery_voltage(int1 lcd_line) 
.................... {                                            
....................    if (!global_lcd_enabled) return;     
*
04F58:  BTFSS  xA7.0
04F5A:  BRA    4FD6
....................        
....................    uint32_t battery_voltage = calc_vbatt(get_vbatt(1)); 
04F5C:  MOVLW  01
04F5E:  MOVLB  5
04F60:  MOVWF  x6A
04F62:  MOVLB  0
04F64:  CALL   42B4
04F68:  MOVFF  02,551
04F6C:  MOVFF  01,550
04F70:  MOVFF  02,553
04F74:  MOVFF  01,552
04F78:  BRA    49EE
04F7A:  MOVFF  03,54F
04F7E:  MOVFF  02,54E
04F82:  MOVFF  01,54D
04F86:  MOVFF  00,54C
....................    strcpy (global_temp_line_buff, "Vbatt =      V  "); 
04F8A:  CLRF   FEA
04F8C:  MOVLW  70
04F8E:  MOVWF  FE9
04F90:  MOVLW  00
04F92:  CALL   04EC
04F96:  TBLRD*-
04F98:  TBLRD*+
04F9A:  MOVF   FF5,W
04F9C:  MOVWF  FEE
04F9E:  IORLW  00
04FA0:  BNZ   4F98
....................    if (lcd_line == 0) LCD_line1(global_temp_line_buff); 
04FA2:  MOVLB  5
04FA4:  MOVF   x4B,F
04FA6:  BNZ   4FB8
04FA8:  CLRF   x64
04FAA:  MOVLW  70
04FAC:  MOVWF  x63
04FAE:  MOVLB  0
04FB0:  CALL   39B0
04FB4:  BRA    4FC4
04FB6:  MOVLB  5
....................    else LCD_line2(global_temp_line_buff); 
04FB8:  CLRF   x64
04FBA:  MOVLW  70
04FBC:  MOVWF  x63
04FBE:  MOVLB  0
04FC0:  CALL   3A0A
....................    LCD_display_batt_voltage(lcd_line, 8, 2); 
04FC4:  MOVFF  54B,550
04FC8:  MOVLW  08
04FCA:  MOVLB  5
04FCC:  MOVWF  x51
04FCE:  MOVLW  02
04FD0:  MOVWF  x52
04FD2:  MOVLB  0
04FD4:  RCALL  4DBE
04FD6:  GOTO   A4CE (RETURN)
.................... //   LCD_place_uint8((uint8_t)(battery_voltage>>16),lcd_line,8,1); 
.................... //   LCD_place_uint16((uint16_t)battery_voltage,lcd_line,10,4); 
.................... } 
....................  
.................... void LCD_display_batt_voltage(int1 lcd_line, uint8_t col, uint8_t precision) 
.................... { 
....................    // precision is the number of digits to the right of the decimal pt 
....................    // Valid values are 1, 2, 3 
....................    // The assumption is that there is a SINGLE digit preceeding the dp 
....................     
....................    if (!global_lcd_enabled) return; 
*
04DBE:  BTFSS  xA7.0
04DC0:  BRA    4F52
....................  
....................    if (col>15) 
04DC2:  MOVLB  5
04DC4:  MOVF   x51,W
04DC6:  SUBLW  0F
04DC8:  BC    4DD0
....................       return; 
04DCA:  MOVLB  0
04DCC:  BRA    4F52
04DCE:  MOVLB  5
....................    if (precision > 3) 
04DD0:  MOVF   x52,W
04DD2:  SUBLW  03
04DD4:  BC    4DDA
....................       precision = 3;   
04DD6:  MOVLW  03
04DD8:  MOVWF  x52
....................     
....................    if ((precision == 3) && (col > 11)) 
04DDA:  MOVF   x52,W
04DDC:  SUBLW  03
04DDE:  BNZ   4DE8
04DE0:  MOVF   x51,W
04DE2:  SUBLW  0B
04DE4:  BC    4DE8
....................       precision--; 
04DE6:  DECF   x52,F
....................    if ((precision == 2) && (col > 12)) 
04DE8:  MOVF   x52,W
04DEA:  SUBLW  02
04DEC:  BNZ   4DF6
04DEE:  MOVF   x51,W
04DF0:  SUBLW  0C
04DF2:  BC    4DF6
....................       precision--; 
04DF4:  DECF   x52,F
....................    if ((precision == 1) && (col > 13)) 
04DF6:  DECFSZ x52,W
04DF8:  BRA    4E02
04DFA:  MOVF   x51,W
04DFC:  SUBLW  0D
04DFE:  BC    4E02
....................       precision--; 
04E00:  DECF   x52,F
....................        
....................    uint16_t battery_voltage_BCD = calc_vbatt_BCD(get_vbatt(1)); 
....................  
....................    uint8_t volts = '0' + (uint8_t)(battery_voltage_BCD >> 12); 
....................    uint8_t tenths = '0' + (uint8_t)((battery_voltage_BCD & 0x0F00) >> 8); 
....................    uint8_t hundredths = '0' + (uint8_t)((battery_voltage_BCD & 0x00F0) >> 4); 
....................    uint8_t thousandths = '0' + (uint8_t)(battery_voltage_BCD & 0x000F); 
04E02:  MOVLW  01
04E04:  MOVWF  x6A
04E06:  MOVLB  0
04E08:  CALL   42B4
04E0C:  MOVFF  02,55A
04E10:  MOVFF  01,559
04E14:  MOVFF  02,55C
04E18:  MOVFF  01,55B
04E1C:  BRA    4B60
04E1E:  MOVFF  02,554
04E22:  MOVFF  01,553
04E26:  MOVLB  5
04E28:  SWAPF  x54,W
04E2A:  MOVWF  02
04E2C:  CLRF   03
04E2E:  MOVLW  0F
04E30:  ANDWF  02,F
04E32:  MOVF   02,W
04E34:  ADDLW  30
04E36:  MOVWF  x55
04E38:  CLRF   x59
04E3A:  MOVF   x54,W
04E3C:  ANDLW  0F
04E3E:  MOVWF  x5A
04E40:  CLRF   03
04E42:  ADDLW  30
04E44:  MOVWF  x56
04E46:  MOVF   x53,W
04E48:  ANDLW  F0
04E4A:  MOVWF  x59
04E4C:  CLRF   x5A
04E4E:  RRCF   x5A,W
04E50:  MOVWF  03
04E52:  RRCF   x59,W
04E54:  MOVWF  02
04E56:  RRCF   03,F
04E58:  RRCF   02,F
04E5A:  RRCF   03,F
04E5C:  RRCF   02,F
04E5E:  RRCF   03,F
04E60:  RRCF   02,F
04E62:  MOVLW  0F
04E64:  ANDWF  03,F
04E66:  MOVF   02,W
04E68:  ADDLW  30
04E6A:  MOVWF  x57
04E6C:  MOVF   x53,W
04E6E:  ANDLW  0F
04E70:  MOVWF  00
04E72:  MOVF   00,W
04E74:  ADDLW  30
04E76:  MOVWF  x58
....................    
....................    switch (precision) 
04E78:  MOVF   x52,W
04E7A:  XORLW  00
04E7C:  MOVLB  0
04E7E:  BZ    4E8A
04E80:  XORLW  01
04E82:  BZ    4E98
04E84:  XORLW  03
04E86:  BZ    4EB2
04E88:  BRA    4ED6
....................    { 
....................       case 0: 
....................          if (tenths > '5') 
04E8A:  MOVLB  5
04E8C:  MOVF   x56,W
04E8E:  SUBLW  35
04E90:  BC    4E94
....................             volts++; 
04E92:  INCF   x55,F
....................          break; 
04E94:  MOVLB  0
04E96:  BRA    4ED6
....................        
....................       case 1: 
....................          if (hundredths > '5') 
04E98:  MOVLB  5
04E9A:  MOVF   x57,W
04E9C:  SUBLW  35
04E9E:  BC    4EA2
....................             tenths++; 
04EA0:  INCF   x56,F
....................          if (tenths > '9' ) 
04EA2:  MOVF   x56,W
04EA4:  SUBLW  39
04EA6:  BC    4EAE
....................          { 
....................             volts++; 
04EA8:  INCF   x55,F
....................             tenths = '0'; 
04EAA:  MOVLW  30
04EAC:  MOVWF  x56
....................          } 
....................          break; 
04EAE:  MOVLB  0
04EB0:  BRA    4ED6
....................  
....................       case 2: 
....................          if (thousandths > '5') 
04EB2:  MOVLB  5
04EB4:  MOVF   x58,W
04EB6:  SUBLW  35
04EB8:  BC    4EBC
....................             hundredths++; 
04EBA:  INCF   x57,F
....................          if (hundredths > '9') 
04EBC:  MOVF   x57,W
04EBE:  SUBLW  39
04EC0:  BC    4EC8
....................          { 
....................             tenths++; 
04EC2:  INCF   x56,F
....................             hundredths = '0'; 
04EC4:  MOVLW  30
04EC6:  MOVWF  x57
....................          } 
....................          if (tenths > '9') 
04EC8:  MOVF   x56,W
04ECA:  SUBLW  39
04ECC:  BC    4ED4
....................          { 
....................             volts++; 
04ECE:  INCF   x55,F
....................             tenths = '0'; 
04ED0:  MOVLW  30
04ED2:  MOVWF  x56
....................          }          
....................          break; 
04ED4:  MOVLB  0
....................    } 
....................    
....................    LCD_place_char (volts, lcd_line, col++); 
04ED6:  MOVLB  5
04ED8:  MOVF   x51,W
04EDA:  INCF   x51,F
04EDC:  MOVWF  x59
04EDE:  MOVFF  555,55A
04EE2:  MOVFF  550,55B
04EE6:  MOVWF  x5C
04EE8:  MOVLB  0
04EEA:  RCALL  4D86
....................     
....................    if (precision) 
04EEC:  MOVLB  5
04EEE:  MOVF   x52,F
04EF0:  BZ    4F54
....................    { 
....................       LCD_place_char ('.', lcd_line, col++); 
04EF2:  MOVF   x51,W
04EF4:  INCF   x51,F
04EF6:  MOVWF  x59
04EF8:  MOVLW  2E
04EFA:  MOVWF  x5A
04EFC:  MOVFF  550,55B
04F00:  MOVFF  559,55C
04F04:  MOVLB  0
04F06:  RCALL  4D86
....................       LCD_place_char (tenths, lcd_line, col++); 
04F08:  MOVLB  5
04F0A:  MOVF   x51,W
04F0C:  INCF   x51,F
04F0E:  MOVWF  x59
04F10:  MOVFF  556,55A
04F14:  MOVFF  550,55B
04F18:  MOVWF  x5C
04F1A:  MOVLB  0
04F1C:  RCALL  4D86
....................         
....................       if (precision > 1) 
04F1E:  MOVLB  5
04F20:  MOVF   x52,W
04F22:  SUBLW  01
04F24:  BC    4F3C
....................          LCD_place_char (hundredths, lcd_line, col++); 
04F26:  MOVF   x51,W
04F28:  INCF   x51,F
04F2A:  MOVWF  x59
04F2C:  MOVFF  557,55A
04F30:  MOVFF  550,55B
04F34:  MOVWF  x5C
04F36:  MOVLB  0
04F38:  RCALL  4D86
04F3A:  MOVLB  5
....................       if (precision > 2) 
04F3C:  MOVF   x52,W
04F3E:  SUBLW  02
04F40:  BC    4F54
....................          LCD_place_char (thousandths, lcd_line, col); 
04F42:  MOVFF  558,55A
04F46:  MOVFF  550,55B
04F4A:  MOVFF  551,55C
04F4E:  MOVLB  0
04F50:  RCALL  4D86
04F52:  MOVLB  5
....................    } 
04F54:  MOVLB  0
04F56:  RETURN 0
.................... }     
....................   
.................... void LCD_display_vgen(int1 lcd_line, uint8_t col, uint8_t precision) 
.................... { 
....................    // precision is the number of digits to the right of the decimal pt 
....................    // Valid values are 1, 2, 3 
....................    // The assumption is that there are 2 digits preceding the decimpal point 
....................     
....................    if (!global_lcd_enabled) return; 
*
086F8:  BTFSS  xA7.0
086FA:  BRA    88E4
....................  
....................    if (col>15) 
086FC:  MOVLB  5
086FE:  MOVF   x4D,W
08700:  SUBLW  0F
08702:  BC    870A
....................       return; 
08704:  MOVLB  0
08706:  BRA    88E4
08708:  MOVLB  5
....................    if (precision > 3) 
0870A:  MOVF   x4E,W
0870C:  SUBLW  03
0870E:  BC    8714
....................       precision = 3;   
08710:  MOVLW  03
08712:  MOVWF  x4E
....................     
....................    if ((precision == 3) && (col > 10)) 
08714:  MOVF   x4E,W
08716:  SUBLW  03
08718:  BNZ   8722
0871A:  MOVF   x4D,W
0871C:  SUBLW  0A
0871E:  BC    8722
....................       precision--; 
08720:  DECF   x4E,F
....................    if ((precision == 2) && (col > 11)) 
08722:  MOVF   x4E,W
08724:  SUBLW  02
08726:  BNZ   8730
08728:  MOVF   x4D,W
0872A:  SUBLW  0B
0872C:  BC    8730
....................       precision--; 
0872E:  DECF   x4E,F
....................    if ((precision == 1) && (col > 12)) 
08730:  DECFSZ x4E,W
08732:  BRA    873C
08734:  MOVF   x4D,W
08736:  SUBLW  0C
08738:  BC    873C
....................       precision--; 
0873A:  DECF   x4E,F
....................        
....................    uint16_t vgen_BCD = calc_vgen_BCD(get_vgen(0)); 
....................  
....................    uint8_t tens = '0' + (uint8_t)(vgen_BCD >> 12)/10; 
....................    uint8_t volts = '0' + (uint8_t)(vgen_BCD >> 12)%10; 
....................    uint8_t tenths = '0' + (uint8_t)((vgen_BCD & 0x0F00) >> 8); 
....................    uint8_t hundredths = '0' + (uint8_t)((vgen_BCD & 0x00F0) >> 4); 
....................    uint8_t thousandths = '0' + (uint8_t)(vgen_BCD & 0x000F); 
0873C:  CLRF   x57
0873E:  MOVLB  0
08740:  CALL   430E
08744:  MOVFF  02,557
08748:  MOVFF  01,556
0874C:  MOVFF  02,559
08750:  MOVFF  01,558
08754:  BRA    84F0
08756:  MOVFF  02,550
0875A:  MOVFF  01,54F
0875E:  MOVLB  5
08760:  SWAPF  x50,W
08762:  MOVWF  02
08764:  CLRF   03
08766:  MOVLW  0F
08768:  ANDWF  02,F
0876A:  MOVFF  02,557
0876E:  MOVFF  02,56B
08772:  MOVLW  0A
08774:  MOVWF  x6C
08776:  MOVLB  0
08778:  CALL   6AEA
0877C:  MOVF   01,W
0877E:  ADDLW  30
08780:  MOVLB  5
08782:  MOVWF  x51
08784:  SWAPF  x50,W
08786:  MOVWF  02
08788:  CLRF   03
0878A:  MOVLW  0F
0878C:  ANDWF  02,F
0878E:  MOVFF  02,557
08792:  MOVFF  02,56B
08796:  MOVLW  0A
08798:  MOVWF  x6C
0879A:  MOVLB  0
0879C:  CALL   6AEA
087A0:  MOVF   00,W
087A2:  ADDLW  30
087A4:  MOVLB  5
087A6:  MOVWF  x52
087A8:  CLRF   x56
087AA:  MOVF   x50,W
087AC:  ANDLW  0F
087AE:  MOVWF  x57
087B0:  CLRF   03
087B2:  ADDLW  30
087B4:  MOVWF  x53
087B6:  MOVF   x4F,W
087B8:  ANDLW  F0
087BA:  MOVWF  x56
087BC:  CLRF   x57
087BE:  RRCF   x57,W
087C0:  MOVWF  03
087C2:  RRCF   x56,W
087C4:  MOVWF  02
087C6:  RRCF   03,F
087C8:  RRCF   02,F
087CA:  RRCF   03,F
087CC:  RRCF   02,F
087CE:  RRCF   03,F
087D0:  RRCF   02,F
087D2:  MOVLW  0F
087D4:  ANDWF  03,F
087D6:  MOVF   02,W
087D8:  ADDLW  30
087DA:  MOVWF  x54
087DC:  MOVF   x4F,W
087DE:  ANDLW  0F
087E0:  MOVWF  00
087E2:  MOVF   00,W
087E4:  ADDLW  30
087E6:  MOVWF  x55
....................    
....................    switch (precision) 
087E8:  MOVF   x4E,W
087EA:  XORLW  00
087EC:  MOVLB  0
087EE:  BZ    87FA
087F0:  XORLW  01
087F2:  BZ    8808
087F4:  XORLW  03
087F6:  BZ    8822
087F8:  BRA    8846
....................    { 
....................       case 0: 
....................          if (tenths > '5') 
087FA:  MOVLB  5
087FC:  MOVF   x53,W
087FE:  SUBLW  35
08800:  BC    8804
....................             volts++; 
08802:  INCF   x52,F
....................          break; 
08804:  MOVLB  0
08806:  BRA    8846
....................        
....................       case 1: 
....................          if (hundredths > '5') 
08808:  MOVLB  5
0880A:  MOVF   x54,W
0880C:  SUBLW  35
0880E:  BC    8812
....................             tenths++; 
08810:  INCF   x53,F
....................          if (tenths > '9' ) 
08812:  MOVF   x53,W
08814:  SUBLW  39
08816:  BC    881E
....................          { 
....................             volts++; 
08818:  INCF   x52,F
....................             tenths = '0'; 
0881A:  MOVLW  30
0881C:  MOVWF  x53
....................          } 
....................          break; 
0881E:  MOVLB  0
08820:  BRA    8846
....................  
....................       case 2: 
....................          if (thousandths > '5') 
08822:  MOVLB  5
08824:  MOVF   x55,W
08826:  SUBLW  35
08828:  BC    882C
....................             hundredths++; 
0882A:  INCF   x54,F
....................          if (hundredths > '9') 
0882C:  MOVF   x54,W
0882E:  SUBLW  39
08830:  BC    8838
....................          { 
....................             tenths++; 
08832:  INCF   x53,F
....................             hundredths = '0'; 
08834:  MOVLW  30
08836:  MOVWF  x54
....................          } 
....................          if (tenths > '9') 
08838:  MOVF   x53,W
0883A:  SUBLW  39
0883C:  BC    8844
....................          { 
....................             volts++; 
0883E:  INCF   x52,F
....................             tenths = '0'; 
08840:  MOVLW  30
08842:  MOVWF  x53
....................          }          
....................          break; 
08844:  MOVLB  0
....................    } 
....................    
....................    LCD_place_char (tens, lcd_line, col++); 
08846:  MOVLB  5
08848:  MOVF   x4D,W
0884A:  INCF   x4D,F
0884C:  MOVWF  x56
0884E:  MOVFF  551,55A
08852:  MOVFF  54C,55B
08856:  MOVWF  x5C
08858:  MOVLB  0
0885A:  CALL   4D86
....................    LCD_place_char (volts, lcd_line, col++); 
0885E:  MOVLB  5
08860:  MOVF   x4D,W
08862:  INCF   x4D,F
08864:  MOVWF  x56
08866:  MOVFF  552,55A
0886A:  MOVFF  54C,55B
0886E:  MOVWF  x5C
08870:  MOVLB  0
08872:  CALL   4D86
....................     
....................    if (precision) 
08876:  MOVLB  5
08878:  MOVF   x4E,F
0887A:  BZ    88E6
....................    { 
....................       LCD_place_char ('.', lcd_line, col++); 
0887C:  MOVF   x4D,W
0887E:  INCF   x4D,F
08880:  MOVWF  x56
08882:  MOVLW  2E
08884:  MOVWF  x5A
08886:  MOVFF  54C,55B
0888A:  MOVFF  556,55C
0888E:  MOVLB  0
08890:  CALL   4D86
....................       LCD_place_char (tenths, lcd_line, col++); 
08894:  MOVLB  5
08896:  MOVF   x4D,W
08898:  INCF   x4D,F
0889A:  MOVWF  x56
0889C:  MOVFF  553,55A
088A0:  MOVFF  54C,55B
088A4:  MOVWF  x5C
088A6:  MOVLB  0
088A8:  CALL   4D86
....................         
....................       if (precision > 1) 
088AC:  MOVLB  5
088AE:  MOVF   x4E,W
088B0:  SUBLW  01
088B2:  BC    88CC
....................          LCD_place_char (hundredths, lcd_line, col++); 
088B4:  MOVF   x4D,W
088B6:  INCF   x4D,F
088B8:  MOVWF  x56
088BA:  MOVFF  554,55A
088BE:  MOVFF  54C,55B
088C2:  MOVWF  x5C
088C4:  MOVLB  0
088C6:  CALL   4D86
088CA:  MOVLB  5
....................       if (precision > 2) 
088CC:  MOVF   x4E,W
088CE:  SUBLW  02
088D0:  BC    88E6
....................          LCD_place_char (thousandths, lcd_line, col); 
088D2:  MOVFF  555,55A
088D6:  MOVFF  54C,55B
088DA:  MOVFF  54D,55C
088DE:  MOVLB  0
088E0:  CALL   4D86
088E4:  MOVLB  5
....................    } 
088E6:  MOVLB  0
088E8:  GOTO   8EB8 (RETURN)
.................... }     
....................  
.................... void LCD_display_shutdown_cause(int1 lcd_line)            
.................... {                    
....................    if (!global_lcd_enabled) return;     
*
04FDA:  BTFSS  xA7.0
04FDC:  BRA    5030
....................     
....................    strcpy (global_temp_line_buff, "Shtdwn Cause:   "); 
04FDE:  CLRF   FEA
04FE0:  MOVLW  70
04FE2:  MOVWF  FE9
04FE4:  MOVLW  00
04FE6:  CALL   050E
04FEA:  TBLRD*-
04FEC:  TBLRD*+
04FEE:  MOVF   FF5,W
04FF0:  MOVWF  FEE
04FF2:  IORLW  00
04FF4:  BNZ   4FEC
....................    global_temp_line_buff[14] = hi2asc(global_previous_shutdown_cause); 
04FF6:  MOVFF  4E,564
04FFA:  CALL   32F4
04FFE:  MOVFF  01,7E
....................    global_temp_line_buff[15] = lo2asc(global_previous_shutdown_cause); 
05002:  MOVFF  4E,564
05006:  CALL   3314
0500A:  MOVFF  01,7F
....................    if (lcd_line == 0) LCD_line1(global_temp_line_buff); 
0500E:  MOVLB  5
05010:  MOVF   x4B,F
05012:  BNZ   5024
05014:  CLRF   x64
05016:  MOVLW  70
05018:  MOVWF  x63
0501A:  MOVLB  0
0501C:  CALL   39B0
05020:  BRA    5030
05022:  MOVLB  5
....................    else LCD_line2(global_temp_line_buff); 
05024:  CLRF   x64
05026:  MOVLW  70
05028:  MOVWF  x63
0502A:  MOVLB  0
0502C:  CALL   3A0A
05030:  GOTO   A4DA (RETURN)
.................... } 
....................                                      
.................... void LCD_update_diplay(void)            
*
088EC:  MOVLW  20
088EE:  MOVLB  5
088F0:  MOVWF  x4B
.................... {                                       
....................    // char for displaying mote state    
....................    char state_char = ' ';                 
....................        
....................    switch(global_lcd_page_number)       
088F2:  MOVLB  0
088F4:  MOVF   x84,W
088F6:  XORLW  01
088F8:  BZ    890E
088FA:  XORLW  03
088FC:  BTFSC  FD8.2
088FE:  BRA    8A94
08900:  XORLW  01
08902:  BTFSC  FD8.2
08904:  BRA    8D1A
08906:  XORLW  07
08908:  BTFSC  FD8.2
0890A:  BRA    8EBC
0890C:  BRA    8F58
....................    {     
....................       // display screen 1     
....................       case 1:                                    
....................          // This is where you should put the stuff that doesn't need to be updated all the time 
....................          // last update was skipped, clear screen and fill screen         
....................          if (global_skip_lcd_update_count == 1) 
0890E:  DECFSZ x83,W
08910:  BRA    8964
....................          { 
....................             LCD_clear();                                         
08912:  CALL   5E1A
....................             global_skip_lcd_update_count = 0;   
08916:  CLRF   x83
....................             strcpy (global_temp_line_buff, "v      r    t   "); 
08918:  CLRF   FEA
0891A:  MOVLW  70
0891C:  MOVWF  FE9
0891E:  MOVLW  00
08920:  CALL   0530
08924:  TBLRD*-
08926:  TBLRD*+
08928:  MOVF   FF5,W
0892A:  MOVWF  FEE
0892C:  IORLW  00
0892E:  BNZ   8926
....................             LCD_line1(global_temp_line_buff);            
08930:  MOVLB  5
08932:  CLRF   x64
08934:  MOVLW  70
08936:  MOVWF  x63
08938:  MOVLB  0
0893A:  CALL   39B0
....................             strcpy (global_temp_line_buff, "c      q    a   "); 
0893E:  CLRF   FEA
08940:  MOVLW  70
08942:  MOVWF  FE9
08944:  MOVLW  00
08946:  CALL   0552
0894A:  TBLRD*-
0894C:  TBLRD*+
0894E:  MOVF   FF5,W
08950:  MOVWF  FEE
08952:  IORLW  00
08954:  BNZ   894C
....................             LCD_line2(global_temp_line_buff);    
08956:  MOVLB  5
08958:  CLRF   x64
0895A:  MOVLW  70
0895C:  MOVWF  x63
0895E:  MOVLB  0
08960:  CALL   3A0A
....................          }                                                  
....................                                 
....................          // This is where you put what you want on the screen                                        
....................          // v indicates Valve position 
....................          // r indicates speed of rotation Rpm 
....................          // t indicates message Type 
....................          // c indicates real-time Clock in seconds 
....................          // q indicates message Queue location 
....................          // a indicates Attempt_num 
....................          LCD_place_uint16(global_valve_position, 0, 1, 5); 
08964:  MOVFF  C2,564
08968:  MOVFF  C1,563
0896C:  MOVLB  5
0896E:  CLRF   x65
08970:  MOVLW  01
08972:  MOVWF  x66
08974:  MOVLW  05
08976:  MOVWF  x67
08978:  MOVLB  0
0897A:  CALL   6A3C
....................          if (read_system_state() != SYSTEM_IDLE) 
0897E:  CALL   1F4A
08982:  MOVF   01,W
08984:  SUBLW  03
08986:  BZ    89A4
....................          { 
....................             LCD_place_uint16(global_current_rpm,0,8,3); 
08988:  MOVFF  AB,564
0898C:  MOVFF  AA,563
08990:  MOVLB  5
08992:  CLRF   x65
08994:  MOVLW  08
08996:  MOVWF  x66
08998:  MOVLW  03
0899A:  MOVWF  x67
0899C:  MOVLB  0
0899E:  CALL   6A3C
....................          } 
089A2:  BRA    89DA
....................          else 
....................          { 
....................             LCD_place_char('*',0,8); 
089A4:  MOVLW  2A
089A6:  MOVLB  5
089A8:  MOVWF  x5A
089AA:  CLRF   x5B
089AC:  MOVLW  08
089AE:  MOVWF  x5C
089B0:  MOVLB  0
089B2:  CALL   4D86
....................             LCD_place_char('*',0,9); 
089B6:  MOVLW  2A
089B8:  MOVLB  5
089BA:  MOVWF  x5A
089BC:  CLRF   x5B
089BE:  MOVLW  09
089C0:  MOVWF  x5C
089C2:  MOVLB  0
089C4:  CALL   4D86
....................             LCD_place_char('*',0,10); 
089C8:  MOVLW  2A
089CA:  MOVLB  5
089CC:  MOVWF  x5A
089CE:  CLRF   x5B
089D0:  MOVLW  0A
089D2:  MOVWF  x5C
089D4:  MOVLB  0
089D6:  CALL   4D86
....................          }  
....................            
....................          LCD_place_uint32(global_rtc_time, 1,1,5);                      
089DA:  MOVFF  88,559
089DE:  MOVFF  87,558
089E2:  MOVFF  86,557
089E6:  MOVFF  85,556
089EA:  MOVLW  01
089EC:  MOVLB  5
089EE:  MOVWF  x5A
089F0:  MOVWF  x5B
089F2:  MOVLW  05
089F4:  MOVWF  x5C
089F6:  MOVLB  0
089F8:  CALL   6BAA
....................          //LCD_place_uint16(global_xdcr_output, 1, 8, 5);                 
....................          //LCD_place_uint32(global_utc_time, 1,1,10);           
....................                                                                                       
....................          LCD_place_uint8(global_current_message_queue_location, 1, 8, 3); 
089FC:  MOVFF  4F7,564
08A00:  MOVLW  01
08A02:  MOVLB  5
08A04:  MOVWF  x65
08A06:  MOVLW  08
08A08:  MOVWF  x66
08A0A:  MOVLW  03
08A0C:  MOVWF  x67
08A0E:  MOVLB  0
08A10:  CALL   6B16
....................          if (global_current_message_queue_location != 255) 
08A14:  MOVLB  4
08A16:  INCFSZ xF7,W
08A18:  BRA    8A1C
08A1A:  BRA    8A92
....................          {                              
....................             LCD_place_uint8(global_message_queue[global_current_message_queue_location].message_type,0,13,3); 
08A1C:  MOVF   xF7,W
08A1E:  MULLW  08
08A20:  MOVF   FF3,W
08A22:  MOVLB  5
08A24:  CLRF   x4D
08A26:  MOVWF  x4C
08A28:  MOVLW  04
08A2A:  ADDWF  x4C,W
08A2C:  MOVWF  01
08A2E:  MOVLW  00
08A30:  ADDWFC x4D,W
08A32:  MOVWF  03
08A34:  MOVF   01,W
08A36:  ADDLW  A7
08A38:  MOVWF  FE9
08A3A:  MOVLW  04
08A3C:  ADDWFC 03,W
08A3E:  MOVWF  FEA
08A40:  MOVFF  FEF,564
08A44:  CLRF   x65
08A46:  MOVLW  0D
08A48:  MOVWF  x66
08A4A:  MOVLW  03
08A4C:  MOVWF  x67
08A4E:  MOVLB  0
08A50:  CALL   6B16
....................             LCD_place_uint8(global_message_queue[global_current_message_queue_location].attempt_num,1,13,3); 
08A54:  MOVLB  4
08A56:  MOVF   xF7,W
08A58:  MULLW  08
08A5A:  MOVF   FF3,W
08A5C:  MOVLB  5
08A5E:  CLRF   x4D
08A60:  MOVWF  x4C
08A62:  MOVLW  07
08A64:  ADDWF  x4C,W
08A66:  MOVWF  01
08A68:  MOVLW  00
08A6A:  ADDWFC x4D,W
08A6C:  MOVWF  03
08A6E:  MOVF   01,W
08A70:  ADDLW  A7
08A72:  MOVWF  FE9
08A74:  MOVLW  04
08A76:  ADDWFC 03,W
08A78:  MOVWF  FEA
08A7A:  MOVFF  FEF,564
08A7E:  MOVLW  01
08A80:  MOVWF  x65
08A82:  MOVLW  0D
08A84:  MOVWF  x66
08A86:  MOVLW  03
08A88:  MOVWF  x67
08A8A:  MOVLB  0
08A8C:  CALL   6B16
08A90:  MOVLB  4
....................          }    
....................                 
....................       break;  
08A92:  BRA    8F5E
....................       // display screen 2  
....................       case 2:               
....................          // This is where you should put the stuff that doesn't need to be updated all the time 
....................          // last update was skipped, clear screen and fill screen         
....................          if (global_skip_lcd_update_count == 1)   
08A94:  DECFSZ x83,W
08A96:  BRA    8AEA
....................          {                                         
....................             LCD_clear();                                         
08A98:  CALL   5E1A
....................             global_skip_lcd_update_count = 0; 
08A9C:  CLRF   x83
....................             strcpy (global_temp_line_buff, "m       n     * "); 
08A9E:  CLRF   FEA
08AA0:  MOVLW  70
08AA2:  MOVWF  FE9
08AA4:  MOVLW  00
08AA6:  CALL   0574
08AAA:  TBLRD*-
08AAC:  TBLRD*+
08AAE:  MOVF   FF5,W
08AB0:  MOVWF  FEE
08AB2:  IORLW  00
08AB4:  BNZ   8AAC
....................             LCD_line1(global_temp_line_buff);            
08AB6:  MOVLB  5
08AB8:  CLRF   x64
08ABA:  MOVLW  70
08ABC:  MOVWF  x63
08ABE:  MOVLB  0
08AC0:  CALL   39B0
....................             strcpy (global_temp_line_buff, "p       .       "); 
08AC4:  CLRF   FEA
08AC6:  MOVLW  70
08AC8:  MOVWF  FE9
08ACA:  MOVLW  00
08ACC:  CALL   0596
08AD0:  TBLRD*-
08AD2:  TBLRD*+
08AD4:  MOVF   FF5,W
08AD6:  MOVWF  FEE
08AD8:  IORLW  00
08ADA:  BNZ   8AD2
....................             LCD_line2(global_temp_line_buff);    
08ADC:  MOVLB  5
08ADE:  CLRF   x64
08AE0:  MOVLW  70
08AE2:  MOVWF  x63
08AE4:  MOVLB  0
08AE6:  CALL   3A0A
....................          }                                                       
....................                     
....................          // This is the place where you put what you want onto the screen 
....................          // m indicates Mote ID (hex) 
....................          // n indicates Net ID (hex) 
....................          // * indicates mote state (Booting, Idle, Searching, 
....................          //                         Negotiating, Connected, 
....................          //                         Operational, Disconnected, 
....................          //                         Radio test, Promiscuous Listen) 
....................          // p indicates sprinkler Position (2 digit pivot#, 3 digit location) 
....................          // . is the decimal pt in the battery voltage (2 decimal precision) 
....................          // final 4 places are for Firmware Rev 1st char A-F (e.g. A123) 
....................          // last four characters of line 2 is the hex firmware 
....................          //  revision, e.g. D308    
....................           
....................          // place the mac address on the LCD 
....................          global_temp_line_buff[0] = hi2asc(macaddr_rcvd[5]); 
08AEA:  MOVFF  A4,564
08AEE:  CALL   32F4
08AF2:  MOVFF  01,70
....................          global_temp_line_buff[1] = lo2asc(macaddr_rcvd[5]); 
08AF6:  MOVFF  A4,564
08AFA:  CALL   3314
08AFE:  MOVFF  01,71
....................          global_temp_line_buff[2] = hi2asc(macaddr_rcvd[6]); 
08B02:  MOVFF  A5,564
08B06:  CALL   32F4
08B0A:  MOVFF  01,72
....................          global_temp_line_buff[3] = lo2asc(macaddr_rcvd[6]); 
08B0E:  MOVFF  A5,564
08B12:  CALL   3314
08B16:  MOVFF  01,73
....................          global_temp_line_buff[4] = hi2asc(macaddr_rcvd[7]); 
08B1A:  MOVFF  A6,564
08B1E:  CALL   32F4
08B22:  MOVFF  01,74
....................          global_temp_line_buff[5] = lo2asc(macaddr_rcvd[7]); 
08B26:  MOVFF  A6,564
08B2A:  CALL   3314
08B2E:  MOVFF  01,75
....................          LCD_place_text(global_temp_line_buff,0,1,6);  
08B32:  MOVLB  5
08B34:  CLRF   x74
08B36:  MOVLW  70
08B38:  MOVWF  x73
08B3A:  CLRF   x75
08B3C:  MOVLW  01
08B3E:  MOVWF  x76
08B40:  MOVLW  06
08B42:  MOVWF  x77
08B44:  MOVLB  0
08B46:  CALL   69B4
....................                                 
....................          // place the network id on the LCD                        
....................          global_temp_line_buff[0] = hi2asc(make8(network_id_rcvd,1)); 
08B4A:  MOVFF  368,54C
08B4E:  MOVFF  368,564
08B52:  CALL   32F4
08B56:  MOVFF  01,70
....................          global_temp_line_buff[1] = lo2asc(make8(network_id_rcvd,1)); 
08B5A:  MOVFF  368,54C
08B5E:  MOVFF  368,564
08B62:  CALL   3314
08B66:  MOVFF  01,71
....................          global_temp_line_buff[2] = hi2asc(make8(network_id_rcvd,0)); 
08B6A:  MOVFF  367,54C
08B6E:  MOVFF  367,564
08B72:  CALL   32F4
08B76:  MOVFF  01,72
....................          global_temp_line_buff[3] = lo2asc(make8(network_id_rcvd,0)); 
08B7A:  MOVFF  367,54C
08B7E:  MOVFF  367,564
08B82:  CALL   3314
08B86:  MOVFF  01,73
....................          LCD_place_text(global_temp_line_buff,0,9,4);        
08B8A:  MOVLB  5
08B8C:  CLRF   x74
08B8E:  MOVLW  70
08B90:  MOVWF  x73
08B92:  CLRF   x75
08B94:  MOVLW  09
08B96:  MOVWF  x76
08B98:  MOVLW  04
08B9A:  MOVWF  x77
08B9C:  MOVLB  0
08B9E:  CALL   69B4
....................           
....................          // put the mote state on the LCD       
....................          switch (global_mote_state) 
08BA2:  MOVLB  5
08BA4:  MOVF   x04,W
08BA6:  XORLW  00
08BA8:  MOVLB  0
08BAA:  BZ    8BCE
08BAC:  XORLW  01
08BAE:  BZ    8BD6
08BB0:  XORLW  03
08BB2:  BZ    8BDE
08BB4:  XORLW  01
08BB6:  BZ    8BE6
08BB8:  XORLW  07
08BBA:  BZ    8BEE
08BBC:  XORLW  01
08BBE:  BZ    8BF6
08BC0:  XORLW  03
08BC2:  BZ    8BFE
08BC4:  XORLW  01
08BC6:  BZ    8C06
08BC8:  XORLW  0F
08BCA:  BZ    8C0E
08BCC:  BRA    8C18
....................          {               
....................             case MOTESTATE_INIT: 
....................                // booting 
....................                state_char = 'B'; 
08BCE:  MOVLW  42
08BD0:  MOVLB  5
08BD2:  MOVWF  x4B
....................                break;   
08BD4:  BRA    8C1E
....................             case MOTESTATE_IDLE: 
....................                state_char = 'I'; 
08BD6:  MOVLW  49
08BD8:  MOVLB  5
08BDA:  MOVWF  x4B
....................                break;  
08BDC:  BRA    8C1E
....................             case MOTESTATE_SEARCHING: 
....................                state_char = 'S'; 
08BDE:  MOVLW  53
08BE0:  MOVLB  5
08BE2:  MOVWF  x4B
....................                break;      
08BE4:  BRA    8C1E
....................             case MOTESTATE_NEGOTIATING: 
....................                state_char = 'N'; 
08BE6:  MOVLW  4E
08BE8:  MOVLB  5
08BEA:  MOVWF  x4B
....................                break; 
08BEC:  BRA    8C1E
....................             case MOTESTATE_CONNECTED: 
....................                state_char = 'C'; 
08BEE:  MOVLW  43
08BF0:  MOVLB  5
08BF2:  MOVWF  x4B
....................                break;  
08BF4:  BRA    8C1E
....................             case MOTESTATE_OPERATIONAL: 
....................                state_char = 'O'; 
08BF6:  MOVLW  4F
08BF8:  MOVLB  5
08BFA:  MOVWF  x4B
....................                break;  
08BFC:  BRA    8C1E
....................             case MOTESTATE_DISCONNECTED: 
....................                state_char = 'D'; 
08BFE:  MOVLW  44
08C00:  MOVLB  5
08C02:  MOVWF  x4B
....................                break;   
08C04:  BRA    8C1E
....................             case MOTESTATE_RADIOTEST: 
....................                state_char = 'R'; 
08C06:  MOVLW  52
08C08:  MOVLB  5
08C0A:  MOVWF  x4B
....................                break;   
08C0C:  BRA    8C1E
....................             case MOTESTATE_PROMISCUOUS: 
....................                state_char = 'P'; 
08C0E:  MOVLW  50
08C10:  MOVLB  5
08C12:  MOVWF  x4B
....................                break;  
08C14:  BRA    8C1E
08C16:  MOVLB  0
....................             default: 
....................                state_char = '*'; 
08C18:  MOVLW  2A
08C1A:  MOVLB  5
08C1C:  MOVWF  x4B
....................                break;    
....................          }                      
....................          LCD_place_char(state_char, 0, 15);           
08C1E:  MOVFF  54B,55A
08C22:  CLRF   x5B
08C24:  MOVLW  0F
08C26:  MOVWF  x5C
08C28:  MOVLB  0
08C2A:  CALL   4D86
....................                   
....................          // put the sprinkler position??? on the LCD                              
....................          strcpy(global_temp_line_buff, "***"); 
08C2E:  CLRF   FEA
08C30:  MOVLW  70
08C32:  MOVWF  FE9
08C34:  MOVLW  00
08C36:  CALL   05B8
08C3A:  TBLRD*-
08C3C:  TBLRD*+
08C3E:  MOVF   FF5,W
08C40:  MOVWF  FEE
08C42:  IORLW  00
08C44:  BNZ   8C3C
....................          if (state_char == 'O') 
08C46:  MOVLB  5
08C48:  MOVF   x4B,W
08C4A:  SUBLW  4F
08C4C:  BNZ   8C7A
....................             LCD_place_uint8((uint8_t)(network_id_rcvd - NETWORK_ID_DEF), 1, 1, 2); 
08C4E:  MOVLW  CD
08C50:  MOVLB  3
08C52:  SUBWF  x67,W
08C54:  MOVWF  00
08C56:  MOVLW  04
08C58:  SUBWFB x68,W
08C5A:  MOVWF  03
08C5C:  MOVFF  00,54C
08C60:  MOVLB  5
08C62:  MOVFF  00,564
08C66:  MOVLW  01
08C68:  MOVWF  x65
08C6A:  MOVWF  x66
08C6C:  MOVLW  02
08C6E:  MOVWF  x67
08C70:  MOVLB  0
08C72:  CALL   6B16
08C76:  BRA    8C90
08C78:  MOVLB  5
....................          else 
....................             LCD_place_text(global_temp_line_buff,1,1,2); 
08C7A:  CLRF   x74
08C7C:  MOVLW  70
08C7E:  MOVWF  x73
08C80:  MOVLW  01
08C82:  MOVWF  x75
08C84:  MOVWF  x76
08C86:  MOVLW  02
08C88:  MOVWF  x77
08C8A:  MOVLB  0
08C8C:  CALL   69B4
....................                                        
....................          // put the sprinkler number on the LCD 
....................          if (global_sprinkler_num > 999) 
08C90:  MOVF   x96,W
08C92:  SUBLW  02
08C94:  BC    8CBA
08C96:  XORLW  FF
08C98:  BNZ   8CA0
08C9A:  MOVF   x95,W
08C9C:  SUBLW  E7
08C9E:  BC    8CBA
....................             LCD_place_text(global_temp_line_buff,1,3,3); 
08CA0:  MOVLB  5
08CA2:  CLRF   x74
08CA4:  MOVLW  70
08CA6:  MOVWF  x73
08CA8:  MOVLW  01
08CAA:  MOVWF  x75
08CAC:  MOVLW  03
08CAE:  MOVWF  x76
08CB0:  MOVWF  x77
08CB2:  MOVLB  0
08CB4:  CALL   69B4
08CB8:  BRA    8CD4
....................          else 
....................             LCD_place_uint16(global_sprinkler_num, 1, 3, 3); 
08CBA:  MOVFF  96,564
08CBE:  MOVFF  95,563
08CC2:  MOVLW  01
08CC4:  MOVLB  5
08CC6:  MOVWF  x65
08CC8:  MOVLW  03
08CCA:  MOVWF  x66
08CCC:  MOVWF  x67
08CCE:  MOVLB  0
08CD0:  CALL   6A3C
....................           
....................          // put the battery voltage on the LCD 
....................          LCD_display_batt_voltage(1, 7, 2);                 
08CD4:  MOVLW  01
08CD6:  MOVLB  5
08CD8:  MOVWF  x50
08CDA:  MOVLW  07
08CDC:  MOVWF  x51
08CDE:  MOVLW  02
08CE0:  MOVWF  x52
08CE2:  MOVLB  0
08CE4:  CALL   4DBE
....................           
....................          // put the firmware version on the LCD 
....................          strcpy(global_temp_line_buff, global_firmware_version_string);       
08CE8:  CLRF   FEA
08CEA:  MOVLW  70
08CEC:  MOVWF  FE9
08CEE:  CLRF   FE2
08CF0:  MOVLW  4F
08CF2:  MOVWF  FE1
08CF4:  MOVF   FE7,F
08CF6:  MOVFF  FE6,FEE
08CFA:  BNZ   8CF4
....................          LCD_place_text(global_temp_line_buff,1,12,4);   
08CFC:  MOVLB  5
08CFE:  CLRF   x74
08D00:  MOVLW  70
08D02:  MOVWF  x73
08D04:  MOVLW  01
08D06:  MOVWF  x75
08D08:  MOVLW  0C
08D0A:  MOVWF  x76
08D0C:  MOVLW  04
08D0E:  MOVWF  x77
08D10:  MOVLB  0
08D12:  CALL   69B4
....................                                                              
....................          break;         
08D16:  MOVLB  4
08D18:  BRA    8F5E
....................        
....................       // another screen 
....................       case 3: 
....................         
....................          if (global_skip_lcd_update_count == 1)   
08D1A:  DECFSZ x83,W
08D1C:  BRA    8D70
....................          {                                         
....................             LCD_clear();                                         
08D1E:  CALL   5E1A
....................             global_skip_lcd_update_count = 0; 
08D22:  CLRF   x83
....................             strcpy (global_temp_line_buff, "br    ch    mp  "); 
08D24:  CLRF   FEA
08D26:  MOVLW  70
08D28:  MOVWF  FE9
08D2A:  MOVLW  00
08D2C:  CALL   05CC
08D30:  TBLRD*-
08D32:  TBLRD*+
08D34:  MOVF   FF5,W
08D36:  MOVWF  FEE
08D38:  IORLW  00
08D3A:  BNZ   8D32
....................             LCD_line1(global_temp_line_buff);            
08D3C:  MOVLB  5
08D3E:  CLRF   x64
08D40:  MOVLW  70
08D42:  MOVWF  x63
08D44:  MOVLB  0
08D46:  CALL   39B0
....................             strcpy (global_temp_line_buff, "r   /    vg  .  "); 
08D4A:  CLRF   FEA
08D4C:  MOVLW  70
08D4E:  MOVWF  FE9
08D50:  MOVLW  00
08D52:  CALL   05EE
08D56:  TBLRD*-
08D58:  TBLRD*+
08D5A:  MOVF   FF5,W
08D5C:  MOVWF  FEE
08D5E:  IORLW  00
08D60:  BNZ   8D58
....................             LCD_line2(global_temp_line_buff);    
08D62:  MOVLB  5
08D64:  CLRF   x64
08D66:  MOVLW  70
08D68:  MOVWF  x63
08D6A:  MOVLB  0
08D6C:  CALL   3A0A
....................          }                                                       
....................                     
....................          // This is the place where you put what you want onto the screen 
....................          // br indicates BRaking duty cycle (0-400) 
....................          // ch indicates CHarging duty cycle (0-400) 
....................          // mp indicates MPpc setting (2-digit HEX) 
....................          // r.../... indicates measured RPM / target RMP 
....................          // vg indicates detected voltage from generator 00.00 
....................           
....................          LCD_place_uint16(global_brake_duty,0,2,3);  
08D70:  MOVFF  B3,564
08D74:  MOVFF  B2,563
08D78:  MOVLB  5
08D7A:  CLRF   x65
08D7C:  MOVLW  02
08D7E:  MOVWF  x66
08D80:  MOVLW  03
08D82:  MOVWF  x67
08D84:  MOVLB  0
08D86:  CALL   6A3C
....................          LCD_place_uint16(global_charge_duty,0,8,3); 
08D8A:  MOVFF  B5,564
08D8E:  MOVFF  B4,563
08D92:  MOVLB  5
08D94:  CLRF   x65
08D96:  MOVLW  08
08D98:  MOVWF  x66
08D9A:  MOVLW  03
08D9C:  MOVWF  x67
08D9E:  MOVLB  0
08DA0:  CALL   6A3C
....................          LCD_place_char(hi2asc(global_mppc_value),0,14); 
08DA4:  MOVFF  BA,564
08DA8:  CALL   32F4
08DAC:  MOVFF  01,54C
08DB0:  MOVFF  01,55A
08DB4:  MOVLB  5
08DB6:  CLRF   x5B
08DB8:  MOVLW  0E
08DBA:  MOVWF  x5C
08DBC:  MOVLB  0
08DBE:  CALL   4D86
....................          LCD_place_char(lo2asc(global_mppc_value),0,15); 
08DC2:  MOVFF  BA,564
08DC6:  CALL   3314
08DCA:  MOVFF  01,54C
08DCE:  MOVFF  01,55A
08DD2:  MOVLB  5
08DD4:  CLRF   x5B
08DD6:  MOVLW  0F
08DD8:  MOVWF  x5C
08DDA:  MOVLB  0
08DDC:  CALL   4D86
....................           
....................          // do not report measured RPM if it is not being measured 
....................          if (read_system_state() != SYSTEM_IDLE) 
08DE0:  CALL   1F4A
08DE4:  MOVF   01,W
08DE6:  SUBLW  03
08DE8:  BZ    8E06
....................          { 
....................             LCD_place_uint16(global_current_rpm,1,1,3); 
08DEA:  MOVFF  AB,564
08DEE:  MOVFF  AA,563
08DF2:  MOVLW  01
08DF4:  MOVLB  5
08DF6:  MOVWF  x65
08DF8:  MOVWF  x66
08DFA:  MOVLW  03
08DFC:  MOVWF  x67
08DFE:  MOVLB  0
08E00:  CALL   6A3C
....................          } 
08E04:  BRA    8E40
....................          else 
....................          { 
....................             LCD_place_char('*',1,1); 
08E06:  MOVLW  2A
08E08:  MOVLB  5
08E0A:  MOVWF  x5A
08E0C:  MOVLW  01
08E0E:  MOVWF  x5B
08E10:  MOVWF  x5C
08E12:  MOVLB  0
08E14:  CALL   4D86
....................             LCD_place_char('*',1,2); 
08E18:  MOVLW  2A
08E1A:  MOVLB  5
08E1C:  MOVWF  x5A
08E1E:  MOVLW  01
08E20:  MOVWF  x5B
08E22:  MOVLW  02
08E24:  MOVWF  x5C
08E26:  MOVLB  0
08E28:  CALL   4D86
....................             LCD_place_char('*',1,3); 
08E2C:  MOVLW  2A
08E2E:  MOVLB  5
08E30:  MOVWF  x5A
08E32:  MOVLW  01
08E34:  MOVWF  x5B
08E36:  MOVLW  03
08E38:  MOVWF  x5C
08E3A:  MOVLB  0
08E3C:  CALL   4D86
....................          } 
....................           
....................          // do not report target RPM if there is no target 
....................          if ((global_control_loop_mechanism == NO_RPM_CONTROL) || \ 
....................              (global_control_loop_mechanism == NO_RPM_CONTROL_DYN_MPPC)) 
08E40:  MOVF   xC0,W
08E42:  SUBLW  05
08E44:  BZ    8E4C
08E46:  MOVF   xC0,W
08E48:  SUBLW  06
08E4A:  BNZ   8E8A
....................          { 
....................             LCD_place_char('*',1,5); 
08E4C:  MOVLW  2A
08E4E:  MOVLB  5
08E50:  MOVWF  x5A
08E52:  MOVLW  01
08E54:  MOVWF  x5B
08E56:  MOVLW  05
08E58:  MOVWF  x5C
08E5A:  MOVLB  0
08E5C:  CALL   4D86
....................             LCD_place_char('*',1,6); 
08E60:  MOVLW  2A
08E62:  MOVLB  5
08E64:  MOVWF  x5A
08E66:  MOVLW  01
08E68:  MOVWF  x5B
08E6A:  MOVLW  06
08E6C:  MOVWF  x5C
08E6E:  MOVLB  0
08E70:  CALL   4D86
....................             LCD_place_char('*',1,7); 
08E74:  MOVLW  2A
08E76:  MOVLB  5
08E78:  MOVWF  x5A
08E7A:  MOVLW  01
08E7C:  MOVWF  x5B
08E7E:  MOVLW  07
08E80:  MOVWF  x5C
08E82:  MOVLB  0
08E84:  CALL   4D86
....................          } 
08E88:  BRA    8EA6
....................          else 
....................          { 
....................             LCD_place_uint16(global_rpm_set_value,1,5,3); 
08E8A:  MOVFF  AD,564
08E8E:  MOVFF  AC,563
08E92:  MOVLW  01
08E94:  MOVLB  5
08E96:  MOVWF  x65
08E98:  MOVLW  05
08E9A:  MOVWF  x66
08E9C:  MOVLW  03
08E9E:  MOVWF  x67
08EA0:  MOVLB  0
08EA2:  CALL   6A3C
....................          } 
....................           
....................          // put the vgen voltage on the LCD 
....................  
....................          LCD_display_vgen(1, 11, 2); 
08EA6:  MOVLW  01
08EA8:  MOVLB  5
08EAA:  MOVWF  x4C
08EAC:  MOVLW  0B
08EAE:  MOVWF  x4D
08EB0:  MOVLW  02
08EB2:  MOVWF  x4E
08EB4:  MOVLB  0
08EB6:  BRA    86F8
....................  
....................       break; 
08EB8:  MOVLB  4
08EBA:  BRA    8F5E
....................        
....................       // extra screen 
....................       case 4: 
....................          if (global_skip_lcd_update_count == 1) 
08EBC:  DECFSZ x83,W
08EBE:  BRA    8F12
....................          {                                         
....................             LCD_clear();                                         
08EC0:  CALL   5E1A
....................             global_skip_lcd_update_count = 0; 
08EC4:  CLRF   x83
....................             strcpy (global_temp_line_buff, "system state    "); 
08EC6:  CLRF   FEA
08EC8:  MOVLW  70
08ECA:  MOVWF  FE9
08ECC:  MOVLW  00
08ECE:  CALL   0610
08ED2:  TBLRD*-
08ED4:  TBLRD*+
08ED6:  MOVF   FF5,W
08ED8:  MOVWF  FEE
08EDA:  IORLW  00
08EDC:  BNZ   8ED4
....................             LCD_line1(global_temp_line_buff);            
08EDE:  MOVLB  5
08EE0:  CLRF   x64
08EE2:  MOVLW  70
08EE4:  MOVWF  x63
08EE6:  MOVLB  0
08EE8:  CALL   39B0
....................             strcpy (global_temp_line_buff, "                "); 
08EEC:  CLRF   FEA
08EEE:  MOVLW  70
08EF0:  MOVWF  FE9
08EF2:  MOVLW  00
08EF4:  CALL   04CA
08EF8:  TBLRD*-
08EFA:  TBLRD*+
08EFC:  MOVF   FF5,W
08EFE:  MOVWF  FEE
08F00:  IORLW  00
08F02:  BNZ   8EFA
....................             LCD_line2(global_temp_line_buff);    
08F04:  MOVLB  5
08F06:  CLRF   x64
08F08:  MOVLW  70
08F0A:  MOVWF  x63
08F0C:  MOVLB  0
08F0E:  CALL   3A0A
....................          }     
....................             LCD_place_uint8(read_system_state(),0,13,3);  
08F12:  CALL   1F4A
08F16:  MOVFF  01,54C
08F1A:  MOVFF  01,564
08F1E:  MOVLB  5
08F20:  CLRF   x65
08F22:  MOVLW  0D
08F24:  MOVWF  x66
08F26:  MOVLW  03
08F28:  MOVWF  x67
08F2A:  MOVLB  0
08F2C:  CALL   6B16
....................             LCD_place_uint32(global_last_rpm_value_time,1,0,10);  
08F30:  MOVFF  B1,559
08F34:  MOVFF  B0,558
08F38:  MOVFF  AF,557
08F3C:  MOVFF  AE,556
08F40:  MOVLW  01
08F42:  MOVLB  5
08F44:  MOVWF  x5A
08F46:  CLRF   x5B
08F48:  MOVLW  0A
08F4A:  MOVWF  x5C
08F4C:  MOVLB  0
08F4E:  CALL   6BAA
....................          break;    
08F52:  MOVLB  4
08F54:  BRA    8F5E
08F56:  MOVLB  0
....................                                                                        
....................       // if somehow global_lcd_page_number get incremented above the last page, clear the LCD    
....................       default: 
....................          LCD_clear();                
08F58:  CALL   5E1A
....................       break;     
08F5C:  MOVLB  4
....................    }                                              
08F5E:  MOVLB  0
08F60:  GOTO   ADC6 (RETURN)
.................... }       
....................  
....................                                                                                                    
.................... void XDCR_init(void) 
.................... { 
....................    i2c_start(); 
....................  
....................    global_xcdr_type1_enabled = !i2c_write(XDCR_ADDRESS);    // (0x48) WRITE LCD address? 
....................    if (!global_xcdr_type1_enabled) 
....................    { 
....................       i2c_stop();                                     
....................       delay_cycles(255); 
....................       output_low(XDCR_PWR);   
....................       return;                             
....................    }                              
....................    //i2c_write(0b00000000);                                    
....................    i2c_write(0x00);  
....................    i2c_stop();            
....................    // set up the ADC here 
.................... }     
....................                
.................... void adc_XDCR_init(void) 
*
038DE:  MOVLB  5
038E0:  CLRF   x4D
038E2:  CLRF   x4C
.................... {    
....................    uint8_t n; 
....................    uint16_t xdcr_output_sum = 0; 
....................     
....................    // turn on pullup resisitor on xdcr line (so you can check if it's connected)                     
....................    port_b_pullups(PORTB_PULLUPS_WITH_XDCR);   
038E4:  MOVLW  32
038E6:  MOVWF  F61
....................     
....................    // turn on XDCR and wait 100ms for the adc to settle (really only 25ms or so is needed) 
....................    output_high(XDCR_PWR);       
038E8:  BSF    F8B.5
....................    setup_T0_int(T0_100MS);                                     
038EA:  MOVLW  FE
038EC:  MOVWF  x69
038EE:  MOVLW  7A
038F0:  MOVWF  x68
038F2:  MOVLB  0
038F4:  RCALL  38C2
....................    while(!TMR0IF);           
038F6:  BTFSS  FF2.2
038F8:  BRA    38F6
....................               
....................    // turn on ADC                   
....................    ADON = TRUE;                
038FA:  BSF    FC2.0
....................                                    
....................    // set adc to V_EXTRA_IO_1 (pin 7 on header going "across river") 
....................    set_adc_channel(ADC_XDCR);       
038FC:  MOVLW  34
038FE:  MOVWF  01
03900:  MOVF   FC2,W
03902:  ANDLW  83
03904:  IORWF  01,W
03906:  MOVWF  FC2
....................  
....................    // sum up 8 samples from the adc (.3 ms/sample @ 250Khz clock)                                                                                                                                                                            
....................    for (n = 0; n < 8; n++) 
03908:  MOVLB  5
0390A:  CLRF   x4B
0390C:  MOVF   x4B,W
0390E:  SUBLW  07
03910:  BNC   3924
....................    {                                                                                                                                                                                                         
....................       xdcr_output_sum += read_adc(); 
03912:  BSF    FC2.1
03914:  BTFSC  FC2.1
03916:  BRA    3914
03918:  MOVF   FC3,W
0391A:  ADDWF  x4C,F
0391C:  MOVF   FC4,W
0391E:  ADDWFC x4D,F
03920:  INCF   x4B,F
03922:  BRA    390C
....................    }                     
....................         
....................    // turn off XDCR power 
....................    output_low(XDCR_PWR);  
03924:  BCF    F8B.5
....................                                                     
....................    // turn off adc                                                                                          
....................    ADON = FALSE;             
03926:  BCF    FC2.0
....................                                    
....................    if (xdcr_output_sum < XDCR_ADC_OFF_LIMIT) 
03928:  MOVF   x4D,W
0392A:  SUBLW  13
0392C:  BNC   393C
0392E:  BNZ   3936
03930:  MOVF   x4C,W
03932:  SUBLW  87
03934:  BNC   393C
....................    { 
....................       global_xcdr_type1_enabled = TRUE;    
03936:  MOVLB  0
03938:  BSF    xA7.2
0393A:  MOVLB  5
....................    }                                             
....................                          
....................    // return pullups to normal state (without testing if XDCR is there)                            
....................    port_b_pullups(PORTB_PULLUPS);         
0393C:  MOVLW  12
0393E:  MOVWF  F61
03940:  MOVLB  0
03942:  GOTO   419A (RETURN)
.................... }                                     
....................  
.................... uint16_t XDCR_measure(void)                                          
.................... {                                          
....................    uint32_t temp_u32;                                           
....................      
....................    i2c_start(); 
....................                                                      
....................    // (0x49) READ ADC address?                 
....................    i2c_write(XDCR_ADDRESS + 1);    
....................                                      
....................    temp_u32 = make32(i2c_read(TRUE), i2c_read(TRUE), i2c_read(FALSE), 0); 
.................... //   LCD_clear();                     
.................... //   LCD_place_uint32(temp_u32,0,0,10);   
.................... //   global_skip_lcd_update_count = 5;               
....................                                       
....................    i2c_stop();                                                          
....................                                             
....................    if ((make8(temp_u32,3) & 0xC0) == 0xC0)  
....................    {                                 
....................       return 0xFFFF;        // saturated top of scale 
....................    }                                                                                     
....................    else if (!(make8(temp_u32,3) & 0xC0))                          
....................    {                                                                           
....................       return 0;             // saturated bottom of scale 
....................    }             
....................    else                                     
....................    {                                                                                                                                                                          
....................       temp_u32 = temp_u32<<2;           // ignore "Bit23 Sig" and "Bit22 MSB" 
.................... //      LCD_clear();                                     
.................... //      LCD_place_uint8(make8(temp_u32,1),1,0,3); 
.................... //     global_skip_lcd_update_count = 5;                                                                                   
....................       return make16(make8(temp_u32,3), make8(temp_u32,2));               
....................    }                                                               
.................... } 
....................  
.................... uint16_t adc_XDCR_measure()     
*
08458:  MOVLB  5
0845A:  CLRF   x4D
0845C:  CLRF   x4C
.................... {                           
....................    uint8_t n; 
....................    uint16_t adc_value = 0;                   
....................     
....................    // if the XDCR isn't connected, return 0 (really, you should never see 0 with adc noise)                      
....................    if (!global_xcdr_type1_enabled) return 0;        
0845E:  MOVLB  0
08460:  BTFSC  xA7.2
08462:  BRA    846C
08464:  MOVLW  00
08466:  MOVWF  01
08468:  MOVWF  02
0846A:  BRA    84AA
....................     
....................    // turn on ADC         
....................    ADON = TRUE;                
0846C:  BSF    FC2.0
....................                                    
....................    // set adc to V_EXTRA_IO_1 (pin 7 on header going "across river" 
....................    set_adc_channel(ADC_XDCR);       
0846E:  MOVLW  34
08470:  MOVWF  01
08472:  MOVF   FC2,W
08474:  ANDLW  83
08476:  IORWF  01,W
08478:  MOVWF  FC2
....................                                      
....................    // sum up 8 samples from the adc (.3 ms/sample @ 250Khz clock)                                                                                                                                                                              
....................    for (n=0; n<8; n++) 
0847A:  MOVLB  5
0847C:  CLRF   x4B
0847E:  MOVF   x4B,W
08480:  SUBLW  07
08482:  BNC   8496
....................    {                                                                                                                                                                                                         
....................       adc_value += read_adc(); 
08484:  BSF    FC2.1
08486:  BTFSC  FC2.1
08488:  BRA    8486
0848A:  MOVF   FC3,W
0848C:  ADDWF  x4C,F
0848E:  MOVF   FC4,W
08490:  ADDWFC x4D,F
08492:  INCF   x4B,F
08494:  BRA    847E
....................    }                     
....................                       
....................    // turn off XDCR power 
....................    output_low(XDCR_PWR);  
08496:  BCF    F8B.5
....................                 
....................    // turn off adc                                                                                          
....................    ADON = FALSE;             
08498:  BCF    FC2.0
....................                                                   
....................    // store XDCR output globally (not shifted)                                               
....................    global_xdcr_output = adc_value;         
0849A:  MOVFF  54D,4C
0849E:  MOVFF  54C,4B
....................                     
....................    // return the voltage shifted by 3 bits to scale from (0-1023) * 8 to 0-65535 or close enough     
....................    return global_xdcr_output;                     
084A2:  MOVFF  4B,01
084A6:  MOVFF  4C,02
084AA:  MOVLB  0
084AC:  GOTO   AD44 (RETURN)
.................... } 
....................  
....................  
.................... void  fixture_init()          
.................... { 
....................    uint8_t  resbyte;               
....................    resbyte = 0;                                                                                              
*
0403A:  MOVLB  5
0403C:  CLRF   x4B
....................     
....................    safeI2C_start();         
0403E:  MOVLB  0
04040:  RCALL  3E9A
....................     
....................    resbyte += i2c_write(FIXTURE_DAC_ADDRESS);                 // FIXTURE DAC ADDRESS 
04042:  MOVLW  40
04044:  MOVLB  5
04046:  MOVWF  x7C
04048:  MOVLB  0
0404A:  RCALL  3962
0404C:  MOVF   01,W
0404E:  MOVLB  5
04050:  ADDWF  x4B,F
....................  
....................    resbyte += i2c_write (0x60);                // use internal reference 
04052:  MOVLW  60
04054:  MOVWF  x7C
04056:  MOVLB  0
04058:  RCALL  3962
0405A:  MOVF   01,W
0405C:  MOVLB  5
0405E:  ADDWF  x4B,F
....................    resbyte += i2c_write (0x00);                // set DAC to 0 
04060:  CLRF   x7C
04062:  MOVLB  0
04064:  RCALL  3962
04066:  MOVF   01,W
04068:  MOVLB  5
0406A:  ADDWF  x4B,F
....................    resbyte += i2c_write (0x00);                // low nibble not used (12 bit DAC) 
0406C:  CLRF   x7C
0406E:  MOVLB  0
04070:  RCALL  3962
04072:  MOVF   01,W
04074:  MOVLB  5
04076:  ADDWF  x4B,F
....................     
....................    if (resbyte != 0) global_fixture_enabled = TRUE; 
04078:  MOVF   x4B,F
0407A:  BZ    4082
0407C:  MOVLB  0
0407E:  BSF    xA7.4
04080:  MOVLB  5
....................    i2c_stop(); 
04082:  BSF    FC5.2
04084:  BTFSC  FC5.2
04086:  BRA    4084
....................     
....................    set_fixture_dac(NO_FIXTURE); 
04088:  CLRF   x4D
0408A:  CLRF   x4C
0408C:  MOVLB  0
0408E:  BRA    3FE6
04090:  GOTO   41AE (RETURN)
.................... }                              
....................  
.................... #include "control.h"                      
.................... void setup_gen_rpm(void) 
.................... { 
....................    setup_timer_5(T5_ENABLE_SOSC | T5_EXTERNAL_SYNC | T5_DIV_BY_1); 
*
04292:  MOVLB  F
04294:  CLRF   x4D
04296:  MOVLW  8B
04298:  MOVWF  x4E
....................    setup_ccp5(CCP_USE_TIMER5_AND_TIMER6 | CCP_CAPTURE_RE);  
0429A:  CLRF   x54
0429C:  MOVLW  05
0429E:  MOVWF  x54
042A0:  MOVLW  F3
042A2:  ANDWF  x48,F
042A4:  MOVLW  08
042A6:  IORWF  x48,F
....................    clear_interrupt(INT_CCP5);     // insurance 
042A8:  BCF    F7B.2
....................  
....................    disable_interrupts(INT_TIMER5); 
042AA:  BCF    F7D.1
....................    enable_interrupts(INT_CCP5); 
042AC:  BSF    F7A.2
042AE:  MOVLB  0
042B0:  GOTO   A438 (RETURN)
.................... } 
....................  
.................... uint16_t calc_gen_rpm(void) 
.................... {   
....................    uint16_t current_rpm16; 
....................    uint32_t current_rpm32; 
....................     
....................       
....................    disable_interrupts(INT_CCP5);                 
*
05114:  BCF    F7A.2
....................    current_rpm32 = global_last_rpm_value_time; 
05116:  MOVFF  B1,559
0511A:  MOVFF  B0,558
0511E:  MOVFF  AF,557
05122:  MOVFF  AE,556
....................    enable_interrupts(INT_CCP5);        
05126:  BSF    F7A.2
....................                                             
....................    // if the last measurement of rpm was more than RPM_TIMEOUT seconds ago 
....................    if ((global_rtc_time - current_rpm32) > RPM_TIMEOUT)            
05128:  MOVLB  5
0512A:  MOVF   x56,W
0512C:  MOVLB  0
0512E:  SUBWF  x85,W
05130:  MOVLB  5
05132:  MOVWF  x5A
05134:  MOVF   x57,W
05136:  MOVLB  0
05138:  SUBWFB x86,W
0513A:  MOVLB  5
0513C:  MOVWF  x5B
0513E:  MOVF   x58,W
05140:  MOVLB  0
05142:  SUBWFB x87,W
05144:  MOVLB  5
05146:  MOVWF  x5C
05148:  MOVF   x59,W
0514A:  MOVLB  0
0514C:  SUBWFB x88,W
0514E:  MOVLB  5
05150:  MOVWF  x5D
05152:  MOVF   x5D,F
05154:  BNZ   5168
05156:  MOVF   x5C,F
05158:  BNZ   5168
0515A:  MOVF   x22,W
0515C:  SUBWF  x5B,W
0515E:  BNC   5172
05160:  BNZ   5168
05162:  MOVF   x5A,W
05164:  SUBWF  x21,W
05166:  BC    5172
....................    {  
.................... #IFNDEF DISABLE_NO_SPIN_RECOVERY    
....................       if (global_valve_position <= VLV_NOT_SPIN_LIMIT) 
.................... #ENDIF 
....................       { 
....................          return 0;                                
05168:  MOVLW  00
0516A:  MOVWF  01
0516C:  MOVWF  02
0516E:  BRA    51F0
....................       } 
....................  
.................... #IFNDEF DISABLE_MAG_DECOUPLING_RECOVERY 
....................       else if(global_valve_position >= VLV_MAGNETIC_COUPLING_LIMIT) 
....................       { 
....................          return 0-1; 
....................       } 
.................... #ENDIF 
....................    }  
05170:  BRA    51EA
....................     
....................    // otherwise, calculate rpms as usual 
....................    else 
....................    {  
....................       disable_interrupts(INT_CCP5); 
05172:  BCF    F7A.2
....................       current_rpm32 = CCP_PER_RPM/(make32(0,0,make8(global_current_period,1), make8(global_current_period,0)));    
05174:  MOVFF  A9,55A
05178:  MOVFF  A8,55B
0517C:  CLRF   x5F
0517E:  CLRF   x5E
05180:  MOVFF  A9,55D
05184:  MOVFF  A8,55C
05188:  BCF    FD8.1
0518A:  CLRF   19
0518C:  BTFSC  FF2.7
0518E:  BSF    19.7
05190:  BCF    FF2.7
05192:  MOVLW  99
05194:  MOVLB  6
05196:  MOVWF  x19
05198:  MOVWF  x18
0519A:  MOVWF  x17
0519C:  MOVLW  9A
0519E:  MOVWF  x16
051A0:  MOVFF  55F,61D
051A4:  MOVFF  55E,61C
051A8:  MOVFF  A9,61B
051AC:  MOVFF  A8,61A
051B0:  MOVLB  0
051B2:  CALL   2570
051B6:  BTFSC  19.7
051B8:  BSF    FF2.7
051BA:  MOVFF  03,559
051BE:  MOVFF  02,558
051C2:  MOVFF  01,557
051C6:  MOVFF  00,556
....................       enable_interrupts(INT_CCP5); 
051CA:  BSF    F7A.2
....................       current_rpm16 = make16(make8(current_rpm32,3), make8(current_rpm32,2)); 
051CC:  MOVFF  559,555
051D0:  MOVFF  558,554
....................       if (bit_test(current_rpm32, 15)) 
051D4:  MOVLB  5
051D6:  BTFSS  x57.7
051D8:  BRA    51E0
....................       { 
....................          current_rpm16++; 
051DA:  INCF   x54,F
051DC:  BTFSC  FD8.2
051DE:  INCF   x55,F
....................       } 
....................       return current_rpm16; 
051E0:  MOVFF  554,01
051E4:  MOVFF  555,02
051E8:  BRA    51F0
....................    } 
....................    return 0; 
051EA:  MOVLW  00
051EC:  MOVWF  01
051EE:  MOVWF  02
051F0:  MOVLB  0
051F2:  GOTO   5602 (RETURN)
.................... } 
....................  
.................... int1  is_brake_duty_valid(uint16_t value) 
.................... // returns true if valid range for brake duty cycle 
.................... { 
....................    if (value > MAX_BRK) return FALSE; 
*
072D2:  MOVLB  5
072D4:  MOVF   x55,W
072D6:  SUBLW  00
072D8:  BC    72EC
072DA:  XORLW  FF
072DC:  BNZ   72E4
072DE:  MOVF   x54,W
072E0:  SUBLW  90
072E2:  BC    72EC
072E4:  MOVLW  00
072E6:  MOVWF  01
072E8:  BRA    72F0
072EA:  BRA    72F0
....................    else if ((value < NO_BRK) && (NO_BRK != 0)) return FALSE; 
....................    else return TRUE; 
072EC:  MOVLW  01
072EE:  MOVWF  01
072F0:  MOVLB  0
072F2:  GOTO   7B90 (RETURN)
.................... } 
.................... int1  is_charge_duty_valid(uint16_t value) 
.................... // returns true if valid range for charge duty cycle 
.................... { 
....................    if (value > MAX_CHARGE) return FALSE; 
072F6:  MOVLB  5
072F8:  MOVF   x55,W
072FA:  SUBLW  00
072FC:  BC    7310
072FE:  XORLW  FF
07300:  BNZ   7308
07302:  MOVF   x54,W
07304:  SUBLW  90
07306:  BC    7310
07308:  MOVLW  00
0730A:  MOVWF  01
0730C:  BRA    7314
0730E:  BRA    7314
....................    else if ((value < NO_CHARGE) && (NO_CHARGE != 0)) return FALSE; 
....................    else return TRUE; 
07310:  MOVLW  01
07312:  MOVWF  01
07314:  MOVLB  0
07316:  GOTO   7BAE (RETURN)
.................... } 
.................... int1  is_mppc_valid(uint8_t value) 
.................... // returns true if valid range for mppc 
.................... { 
....................    if (value > MAX_MPPC) return FALSE; 
....................    else if ((value < NO_MPPC) && (NO_MPPC != 0)) return FALSE; 
0731A:  MOVLB  5
0731C:  MOVF   x52,W
0731E:  SUBLW  06
07320:  BNC   732A
07322:  MOVLW  00
07324:  MOVWF  01
07326:  BRA    732E
07328:  BRA    732E
....................    else return TRUE; 
0732A:  MOVLW  01
0732C:  MOVWF  01
0732E:  MOVLB  0
07330:  GOTO   7BC8 (RETURN)
.................... } 
.................... int1  is_rpm_setting_valid(uint16_t value) 
.................... // returns true if valid range for rpm 
.................... { 
....................    if (value > MAX_RPM_SETTING) return FALSE; 
*
06E2C:  MOVLB  5
06E2E:  MOVF   x55,F
06E30:  BNZ   6E38
06E32:  MOVF   x54,W
06E34:  SUBLW  FA
06E36:  BC    6E40
06E38:  MOVLW  00
06E3A:  MOVWF  01
06E3C:  BRA    6E56
06E3E:  BRA    6E56
....................    else if ((value < MIN_RPM_SETTING) && (MIN_RPM_SETTING != 0)) return FALSE; 
06E40:  MOVF   x55,F
06E42:  BNZ   6E52
06E44:  MOVF   x54,W
06E46:  SUBLW  09
06E48:  BNC   6E52
06E4A:  MOVLW  00
06E4C:  MOVWF  01
06E4E:  BRA    6E56
06E50:  BRA    6E56
....................    else return TRUE; 
06E52:  MOVLW  01
06E54:  MOVWF  01
06E56:  MOVLB  0
06E58:  RETURN 0
.................... } 
.................... void  set_brake_duty(uint16_t value) 
.................... { 
....................    if (value == NO_BRK) 
*
0550A:  MOVLB  5
0550C:  MOVF   x56,F
0550E:  BNZ   551C
05510:  MOVF   x57,F
05512:  BNZ   551C
....................    { 
....................       setup_ccp1(CCP_OFF); 
05514:  MOVLW  F0
05516:  ANDWF  FBD,F
....................       output_high(BRK_CTRLn);    // no braking 
05518:  BSF    F8B.2
....................    } 
0551A:  BRA    556C
....................    else if (value == MAX_BRK) 
0551C:  MOVF   x56,W
0551E:  SUBLW  90
05520:  BNZ   552E
05522:  DECFSZ x57,W
05524:  BRA    552E
....................    { 
....................       setup_ccp1(CCP_OFF); 
05526:  MOVLW  F0
05528:  ANDWF  FBD,F
....................       output_low(BRK_CTRLn);     // maximum braking 
0552A:  BCF    F8B.2
....................    } 
0552C:  BRA    556C
....................     
....................    else 
....................    {       
....................       setup_ccp1(CCP_USE_TIMER5_AND_TIMER6 | CCP_PWM_L_L | CCP_PULSE_STEERING_A); 
0552E:  BCF    F8B.2
05530:  MOVLW  0F
05532:  MOVWF  FBD
05534:  CLRF   FB7
05536:  CLRF   FB6
05538:  MOVLW  01
0553A:  MOVWF  FB9
0553C:  MOVLW  FC
0553E:  MOVLB  F
05540:  ANDWF  x49,F
05542:  MOVLW  02
05544:  IORWF  x49,F
....................       // increase pwm duty1 for slower speed 
....................       CCP1CON |= (make8(value,0) & 0x03) << 4; 
05546:  MOVLB  5
05548:  MOVF   x56,W
0554A:  ANDLW  03
0554C:  MOVWF  00
0554E:  SWAPF  00,F
05550:  MOVLW  F0
05552:  ANDWF  00,F
05554:  MOVF   00,W
05556:  IORWF  FBD,F
....................       CCPR1L = make8((value>>2),0); 
05558:  RRCF   x57,W
0555A:  MOVWF  x59
0555C:  RRCF   x56,W
0555E:  MOVWF  x58
05560:  RRCF   x59,F
05562:  RRCF   x58,F
05564:  MOVLW  3F
05566:  ANDWF  x59,F
05568:  MOVFF  558,FBE
....................    } 
....................     
....................    global_brake_duty = value; 
0556C:  MOVFF  557,B3
05570:  MOVFF  556,B2
05574:  MOVLB  0
05576:  RETURN 0
.................... } 
....................  
.................... void     set_charge_duty(uint16_t value) 
.................... { 
....................    if (value == NO_CHARGE) 
*
03F78:  MOVLB  5
03F7A:  MOVF   x56,F
03F7C:  BNZ   3F8A
03F7E:  MOVF   x57,F
03F80:  BNZ   3F8A
....................    { 
....................       setup_ccp2(CCP_OFF); 
03F82:  MOVLW  F0
03F84:  ANDWF  F66,F
....................       output_low(LTC3105_CTRL);     // lo for NO CHARGING 
03F86:  BCF    F8A.3
....................    } 
03F88:  BRA    3FDA
....................    else if (value == MAX_CHARGE) 
03F8A:  MOVF   x56,W
03F8C:  SUBLW  90
03F8E:  BNZ   3F9C
03F90:  DECFSZ x57,W
03F92:  BRA    3F9C
....................    { 
....................       setup_ccp2(CCP_OFF); 
03F94:  MOVLW  F0
03F96:  ANDWF  F66,F
....................       output_high(LTC3105_CTRL);    // maximum charging aggressiveness 
03F98:  BSF    F8A.3
....................    } 
03F9A:  BRA    3FDA
....................     
....................    else 
....................    {    
....................       //setup_ccp2(CCP_USE_TIMER1_AND_TIMER2 | CCP_PWM_H_H | CCP_PULSE_STEERING_A); 
....................       setup_ccp2(CCP_USE_TIMER5_AND_TIMER6 | CCP_PWM_H_H | CCP_PULSE_STEERING_A); 
03F9C:  BCF    F8A.3
03F9E:  MOVLW  0C
03FA0:  MOVWF  F66
03FA2:  CLRF   F65
03FA4:  CLRF   F64
03FA6:  MOVLW  01
03FA8:  MOVWF  F63
03FAA:  MOVLW  E7
03FAC:  MOVLB  F
03FAE:  ANDWF  x49,F
03FB0:  MOVLW  10
03FB2:  IORWF  x49,F
....................       // increase pwm duty2 for slower speed 
....................       CCP2CON |= (make8(value,0) & 0x03) << 4; 
03FB4:  MOVLB  5
03FB6:  MOVF   x56,W
03FB8:  ANDLW  03
03FBA:  MOVWF  00
03FBC:  SWAPF  00,F
03FBE:  MOVLW  F0
03FC0:  ANDWF  00,F
03FC2:  MOVF   00,W
03FC4:  IORWF  F66,F
....................       CCPR2L = make8((value>>2),0); 
03FC6:  RRCF   x57,W
03FC8:  MOVWF  x59
03FCA:  RRCF   x56,W
03FCC:  MOVWF  x58
03FCE:  RRCF   x59,F
03FD0:  RRCF   x58,F
03FD2:  MOVLW  3F
03FD4:  ANDWF  x59,F
03FD6:  MOVFF  558,F67
....................    } 
....................    global_charge_duty = value; 
03FDA:  MOVFF  557,B5
03FDE:  MOVFF  556,B4
03FE2:  MOVLB  0
03FE4:  RETURN 0
.................... }                   
....................  
.................... void set_mppc(uint8_t value) 
.................... { 
....................    // for large scale PCBs 
....................     
....................    safeI2C_start(); 
*
03EEC:  RCALL  3E9A
....................  
....................    safei2c_write(0x58);   // address 
03EEE:  MOVLW  58
03EF0:  MOVLB  5
03EF2:  MOVWF  x55
03EF4:  MOVLB  0
03EF6:  RCALL  3ED8
....................    safei2c_write(0x00);   // Pot 0 command 
03EF8:  MOVLB  5
03EFA:  CLRF   x55
03EFC:  MOVLB  0
03EFE:  RCALL  3ED8
....................    safei2c_write(value);  
03F00:  MOVFF  554,555
03F04:  RCALL  3ED8
....................    safei2c_write(0x10);   // Pot 1 command 
03F06:  MOVLW  10
03F08:  MOVLB  5
03F0A:  MOVWF  x55
03F0C:  MOVLB  0
03F0E:  RCALL  3ED8
....................    safei2c_write(value);  
03F10:  MOVFF  554,555
03F14:  RCALL  3ED8
....................    safei2c_write(0x60);   // Pot 2 command 
03F16:  MOVLW  60
03F18:  MOVLB  5
03F1A:  MOVWF  x55
03F1C:  MOVLB  0
03F1E:  RCALL  3ED8
....................    safei2c_write(value);  
03F20:  MOVFF  554,555
03F24:  RCALL  3ED8
....................    safei2c_write(0x70);   // Pot 3 command 
03F26:  MOVLW  70
03F28:  MOVLB  5
03F2A:  MOVWF  x55
03F2C:  MOVLB  0
03F2E:  RCALL  3ED8
....................    safei2c_write(value);     
03F30:  MOVFF  554,555
03F34:  RCALL  3ED8
....................    i2c_stop(); 
03F36:  BSF    FC5.2
03F38:  BTFSC  FC5.2
03F3A:  BRA    3F38
....................  
....................    // and connect all four pots 
....................    safeI2C_start(); 
03F3C:  RCALL  3E9A
....................     
....................    safei2c_write(0x58);  
03F3E:  MOVLW  58
03F40:  MOVLB  5
03F42:  MOVWF  x55
03F44:  MOVLB  0
03F46:  RCALL  3ED8
....................    safei2c_write(0x40);   // TCON0 
03F48:  MOVLW  40
03F4A:  MOVLB  5
03F4C:  MOVWF  x55
03F4E:  MOVLB  0
03F50:  RCALL  3ED8
....................    safei2c_write(0xff);   // Connect 0 and 1 
03F52:  MOVLB  5
03F54:  SETF   x55
03F56:  MOVLB  0
03F58:  RCALL  3ED8
....................    safei2c_write(0xa0);   // TCON1 
03F5A:  MOVLW  A0
03F5C:  MOVLB  5
03F5E:  MOVWF  x55
03F60:  MOVLB  0
03F62:  RCALL  3ED8
....................    safei2c_write(0xff);   // Connect 2 and 3 
03F64:  MOVLB  5
03F66:  SETF   x55
03F68:  MOVLB  0
03F6A:  RCALL  3ED8
....................    i2c_stop(); 
03F6C:  BSF    FC5.2
03F6E:  BTFSC  FC5.2
03F70:  BRA    3F6E
....................     
....................    global_mppc_value = value; 
03F72:  MOVFF  554,BA
03F76:  RETURN 0
.................... } 
....................  
.................... void  set_fixture_dac(uint16_t dac_value) 
.................... { 
....................    safeI2C_start(); 
*
03FE6:  RCALL  3E9A
....................  
.................... //   fl_FIXTURE = !i2c_write(0x40);   // (0x40) Write FIXTURE DAC address 
.................... //   if (!fl_FIXTURE); 
.................... //   { 
.................... //      i2c_stop(); 
.................... //      return; 
.................... //   } 
....................     
....................    safei2c_write(0x40); 
03FE8:  MOVLW  40
03FEA:  MOVLB  5
03FEC:  MOVWF  x55
03FEE:  MOVLB  0
03FF0:  RCALL  3ED8
....................    safei2c_write(0x30); 
03FF2:  MOVLW  30
03FF4:  MOVLB  5
03FF6:  MOVWF  x55
03FF8:  MOVLB  0
03FFA:  RCALL  3ED8
....................  
....................    dac_value <<= 4;        // shift 12 bit value so that MS bit is at bit15  
03FFC:  MOVLB  5
03FFE:  RLCF   x4C,F
04000:  RLCF   x4D,F
04002:  RLCF   x4C,F
04004:  RLCF   x4D,F
04006:  RLCF   x4C,F
04008:  RLCF   x4D,F
0400A:  RLCF   x4C,F
0400C:  RLCF   x4D,F
0400E:  MOVLW  F0
04010:  ANDWF  x4C,F
....................    safei2c_write (make8(dac_value,1));  
04012:  MOVFF  54D,54E
04016:  MOVFF  54D,555
0401A:  MOVLB  0
0401C:  RCALL  3ED8
....................    safei2c_write (make8(dac_value,0)); 
0401E:  MOVFF  54C,54E
04022:  MOVFF  54C,555
04026:  RCALL  3ED8
....................    i2c_stop(); 
04028:  BSF    FC5.2
0402A:  BTFSC  FC5.2
0402C:  BRA    402A
....................     
....................    global_fixture_dac_value = dac_value; 
0402E:  MOVFF  54D,BF
04032:  MOVFF  54C,BE
04036:  GOTO   4090 (RETURN)
.................... } 
....................  
.................... void adjust_brake_for_rpm(uint16_t rpm_set_value) 
.................... { 
....................    if (calc_gen_rpm() < rpm_set_value) 
....................    { 
....................       if (global_brake_duty != NO_BRK) 
....................       { 
....................          global_brake_duty--; 
....................       } 
....................       set_brake_duty(global_brake_duty); 
....................    } 
....................    else if (calc_gen_rpm() > rpm_set_value) 
....................    { 
....................       if (global_brake_duty != MAX_BRK) 
....................       { 
....................          global_brake_duty++; 
....................       } 
....................       set_brake_duty(global_brake_duty); 
....................    } 
.................... } 
....................  
.................... void adjust_brake_for_vgen(uint16_t vgen_set_value) 
.................... { 
....................    if (get_vgen(0) < vgen_set_value) 
....................    { 
....................       if (global_brake_duty != NO_BRK) 
....................       { 
....................          global_brake_duty--; 
....................       } 
....................       set_brake_duty(global_brake_duty); 
....................    } 
....................    else if (get_vgen(0) > vgen_set_value) 
....................    { 
....................       if (global_brake_duty != MAX_BRK) 
....................       { 
....................          global_brake_duty++; 
....................       } 
....................       set_brake_duty(global_brake_duty); 
....................    } 
.................... } 
....................  
....................     
.................... void adjust_fixture_for_rpm(uint16_t fixture_set_value) 
.................... { 
....................    if (calc_gen_rpm() < fixture_set_value) 
....................    { 
....................       if (global_fixture_dac_value != NO_FIXTURE) 
....................       { 
....................          global_fixture_dac_value--; 
....................       } 
....................       set_fixture_dac(global_fixture_dac_value); 
....................    } 
....................    else if (calc_gen_rpm() > fixture_set_value) 
....................    { 
....................       if (global_fixture_dac_value != MAX_FIXTURE) 
....................       { 
....................          global_fixture_dac_value++; 
....................       } 
....................       set_fixture_dac(global_fixture_dac_value); 
....................    } 
.................... }       
....................        
.................... void adjust_mppc(void) 
.................... { 
....................    static uint16_t last_vbatt_measurement = 0; 
....................    static uint16_t current_vbatt_measurement = 0; 
....................    static uint8_t last_mppc_value = 0; 
....................    static uint8_t last_last_mppc_value = 0; 
....................     
....................    // if the battery is full, exit 
....................     
....................     current_vbatt_measurement = get_vbatt(0); 
*
09F50:  MOVLB  5
09F52:  CLRF   x6A
09F54:  MOVLB  0
09F56:  CALL   42B4
09F5A:  MOVFF  02,53C
09F5E:  MOVFF  01,53B
....................      
....................    // first time to initalize values 
....................    if ((last_vbatt_measurement == 0) || (last_mppc_value == 0)) 
09F62:  MOVLB  5
09F64:  MOVF   x39,F
09F66:  BNZ   9F6C
09F68:  MOVF   x3A,F
09F6A:  BZ    9F70
09F6C:  MOVF   x3D,F
09F6E:  BNZ   9F7C
....................    { 
....................       last_vbatt_measurement = current_vbatt_measurement; 
09F70:  MOVFF  53C,53A
09F74:  MOVFF  53B,539
....................       last_mppc_value = global_mppc_value; 
09F78:  MOVFF  BA,53D
....................    } 
....................    last_last_mppc_value = last_mppc_value; 
09F7C:  MOVFF  53D,53E
....................    last_mppc_value = global_mppc_value; 
09F80:  MOVFF  BA,53D
....................        
....................    if (last_vbatt_measurement < current_vbatt_measurement) 
09F84:  MOVF   x3A,W
09F86:  SUBWF  x3C,W
09F88:  BNC   9FD8
09F8A:  BNZ   9F92
09F8C:  MOVF   x3B,W
09F8E:  SUBWF  x39,W
09F90:  BC    9FD8
....................    { 
....................       if (last_last_mppc_value < global_mppc_value) 
09F92:  MOVLB  0
09F94:  MOVF   xBA,W
09F96:  MOVLB  5
09F98:  SUBWF  x3E,W
09F9A:  BC    9FAC
....................       { 
....................          if (global_mppc_value != MAX_MPPC) global_mppc_value+=5; 
09F9C:  MOVLB  0
09F9E:  INCFSZ xBA,W
09FA0:  BRA    9FA4
09FA2:  BRA    9FA8
09FA4:  MOVLW  05
09FA6:  ADDWF  xBA,F
....................       } 
09FA8:  BRA    9FD4
09FAA:  MOVLB  5
....................       else if (last_last_mppc_value > global_mppc_value) 
09FAC:  MOVF   x3E,W
09FAE:  MOVLB  0
09FB0:  SUBWF  xBA,W
09FB2:  BC    9FC0
....................       { 
....................          if (global_mppc_value != NO_MPPC) global_mppc_value-=5; 
09FB4:  MOVF   xBA,W
09FB6:  SUBLW  07
09FB8:  BZ    9FBE
09FBA:  MOVLW  05
09FBC:  SUBWF  xBA,F
....................       } 
09FBE:  BRA    9FD4
....................       else 
....................       { 
....................          if (global_mppc_value == NO_MPPC) global_mppc_value++; 
09FC0:  MOVF   xBA,W
09FC2:  SUBLW  07
09FC4:  BNZ   9FCA
09FC6:  INCF   xBA,F
09FC8:  BRA    9FD4
....................          else if (global_mppc_value == MAX_MPPC) global_mppc_value--; 
09FCA:  INCFSZ xBA,W
09FCC:  BRA    9FD2
09FCE:  DECF   xBA,F
09FD0:  BRA    9FD4
....................          else global_mppc_value++; 
09FD2:  INCF   xBA,F
....................       } 
....................    } 
09FD4:  BRA    A016
09FD6:  MOVLB  5
....................    else 
....................    { 
....................       if (last_last_mppc_value > global_mppc_value) 
09FD8:  MOVF   x3E,W
09FDA:  MOVLB  0
09FDC:  SUBWF  xBA,W
09FDE:  BC    9FEA
....................       { 
....................          if (global_mppc_value != MAX_MPPC) global_mppc_value++; 
09FE0:  INCFSZ xBA,W
09FE2:  BRA    9FE6
09FE4:  BRA    9FE8
09FE6:  INCF   xBA,F
....................       } 
09FE8:  BRA    A016
....................       else if (last_last_mppc_value < global_mppc_value) 
09FEA:  MOVF   xBA,W
09FEC:  MOVLB  5
09FEE:  SUBWF  x3E,W
09FF0:  BC    A000
....................       { 
....................          if (global_mppc_value != NO_MPPC) global_mppc_value--; 
09FF2:  MOVLB  0
09FF4:  MOVF   xBA,W
09FF6:  SUBLW  07
09FF8:  BZ    9FFC
09FFA:  DECF   xBA,F
....................       } 
09FFC:  BRA    A016
09FFE:  MOVLB  5
....................       else 
....................       { 
....................          if (global_mppc_value == NO_MPPC) global_mppc_value++; 
0A000:  MOVLB  0
0A002:  MOVF   xBA,W
0A004:  SUBLW  07
0A006:  BNZ   A00C
0A008:  INCF   xBA,F
0A00A:  BRA    A016
....................          else if (global_mppc_value == MAX_MPPC) global_mppc_value--; 
0A00C:  INCFSZ xBA,W
0A00E:  BRA    A014
0A010:  DECF   xBA,F
0A012:  BRA    A016
....................          else global_mppc_value++; 
0A014:  INCF   xBA,F
....................       } 
....................    } 
....................     
....................    last_vbatt_measurement = current_vbatt_measurement; 
0A016:  MOVFF  53C,53A
0A01A:  MOVFF  53B,539
....................    set_mppc(global_mppc_value); 
0A01E:  MOVFF  BA,554
0A022:  CALL   3EEC
....................    return; 
0A026:  GOTO   B1D4 (RETURN)
.................... } 
....................  
.................... uint8_t calc_mppc_by_vgen(void) 
.................... { 
....................    int16_t mppc; 
....................    mppc = (((get_vgen(0) - 100) * 20)/100); 
*
05090:  MOVLB  5
05092:  CLRF   x57
05094:  MOVLB  0
05096:  CALL   430E
0509A:  MOVFF  02,557
0509E:  MOVFF  01,556
050A2:  MOVLW  64
050A4:  MOVLB  5
050A6:  SUBWF  x56,F
050A8:  MOVLW  00
050AA:  SUBWFB x57,F
050AC:  MOVFF  557,570
050B0:  MOVFF  556,56F
050B4:  CLRF   x72
050B6:  MOVLW  14
050B8:  MOVWF  x71
050BA:  MOVLB  0
050BC:  RCALL  4B3E
050BE:  MOVFF  02,557
050C2:  MOVFF  01,556
050C6:  MOVFF  02,576
050CA:  MOVFF  01,575
050CE:  MOVLB  5
050D0:  CLRF   x78
050D2:  MOVLW  64
050D4:  MOVWF  x77
050D6:  MOVLB  0
050D8:  CALL   4384
050DC:  MOVFF  02,555
050E0:  MOVLB  5
050E2:  MOVFF  01,554
....................    if (mppc < NO_MPPC) 
050E6:  BTFSC  x55.7
050E8:  BRA    50F4
050EA:  MOVF   x55,F
050EC:  BNZ   50FC
050EE:  MOVF   x54,W
050F0:  SUBLW  06
050F2:  BNC   50FC
....................    { 
....................       mppc = NO_MPPC; 
050F4:  CLRF   x55
050F6:  MOVLW  07
050F8:  MOVWF  x54
....................    } 
050FA:  BRA    510A
....................    else if (mppc > MAX_MPPC) 
050FC:  BTFSC  x55.7
050FE:  BRA    510A
05100:  MOVF   x55,W
05102:  SUBLW  00
05104:  BC    510A
....................    { 
....................       mppc = MAX_MPPC; 
05106:  CLRF   x55
05108:  SETF   x54
....................    } 
....................    return mppc; 
0510A:  MOVFF  554,01
0510E:  MOVLB  0
05110:  GOTO   55E2 (RETURN)
.................... } 
....................  
.................... void update_control_loop(void) 
.................... { 
.................... // Moves the brake duty and charge duty closer to their respective set points 
.................... // How quickly they move towards their set points depends on how far away they 
.................... //    are from the set points. 
....................  
....................    uint16_t rpm_difference, brake_duty_difference, charge_duty_difference; 
....................    uint8_t  duty_change, brake_duty_change, charge_duty_change; 
....................    static uint8_t  control_loop_cycles_to_next_update = 1; 
....................     
....................    /* 
....................    // if the sprinkler has no current commands, exit the control loop                   
....................    if (global_control_loop_mechanism == NO_SPRINKLER_CONTROL)  
....................    { 
....................       return; 
....................    } 
....................    */ 
....................     
....................    // set mppc to dynamic if in any other mode except test mode no rpm (with mppc hard set) 
....................    if (global_control_loop_mechanism != NO_RPM_CONTROL) 
*
055DA:  MOVF   xC0,W
055DC:  SUBLW  05
055DE:  BZ    55E6
....................    { 
....................       global_mppc_set_value = calc_mppc_by_vgen(); 
055E0:  BRA    5090
055E2:  MOVFF  01,BB
....................    } 
....................    // set the mppc value              
....................    set_mppc(global_mppc_set_value);   
055E6:  MOVFF  BB,554
055EA:  CALL   3EEC
....................     
....................    // if it hasn't been enough cycles to update the control loop, exit 
....................    if (--control_loop_cycles_to_next_update > 0) 
055EE:  MOVLB  5
055F0:  DECF   x3F,F
055F2:  BZ    55FA
....................    { 
....................       return; 
055F4:  GOTO   5DA8
....................    } 
055F8:  BRA    55FE
....................    // otherwise, set it to the default of 1 
....................    else  
....................    { 
....................       control_loop_cycles_to_next_update = 1; 
055FA:  MOVLW  01
055FC:  MOVWF  x3F
....................    } 
....................     
....................    // grab the current rpm 
....................    global_current_rpm = calc_gen_rpm(); 
055FE:  MOVLB  0
05600:  BRA    5114
05602:  MOVFF  02,AB
05606:  MOVFF  01,AA
....................     
....................    // decide which regime we are in 
....................    switch (global_control_loop_mechanism) 
0560A:  MOVF   xC0,W
0560C:  ADDLW  F6
0560E:  BTFSC  FD8.0
05610:  GOTO   5DA6
05614:  ADDLW  0A
05616:  GOTO   5DAE
....................    { 
....................    // regular brake + charge rpm control 
....................    case BRAKE_AND_CHARGE: 
....................       // calculate the difference in rpm from set point 
....................       rpm_difference = abs((int16_t)global_current_rpm - (int16_t)global_rpm_set_value); 
0561A:  MOVF   xAC,W
0561C:  SUBWF  xAA,W
0561E:  MOVLB  5
05620:  MOVWF  x54
05622:  MOVLB  0
05624:  MOVF   xAD,W
05626:  SUBWFB xAB,W
05628:  MOVLB  5
0562A:  MOVWF  x55
0562C:  MOVWF  03
0562E:  MOVF   x54,W
05630:  BTFSS  x55.7
05632:  BRA    5644
05634:  MOVLW  00
05636:  BSF    FD8.0
05638:  SUBFWB x54,W
0563A:  MOVWF  00
0563C:  MOVLW  00
0563E:  SUBFWB x55,W
05640:  MOVWF  03
05642:  MOVF   00,W
05644:  MOVWF  x4B
05646:  MOVFF  03,54C
....................        
....................       // calulate how much to change the parameter (either brake or charge, just 
....................       //    reusing brake duty cycle for both) and how often to update based on  
....................       //    rpm difference from setpoint 
....................       if (rpm_difference >= 50)  
0564A:  MOVF   x4C,F
0564C:  BNZ   5654
0564E:  MOVF   x4B,W
05650:  SUBLW  31
05652:  BC    565E
....................       { 
....................          duty_change = 10; 
05654:  MOVLW  0A
05656:  MOVWF  x51
....................          control_loop_cycles_to_next_update = 5;               
05658:  MOVLW  05
0565A:  MOVWF  x3F
....................       } 
0565C:  BRA    56A2
....................       else if (rpm_difference >= 25)  
0565E:  MOVF   x4C,F
05660:  BNZ   5668
05662:  MOVF   x4B,W
05664:  SUBLW  18
05666:  BC    5672
....................       { 
....................          duty_change = 5; 
05668:  MOVLW  05
0566A:  MOVWF  x51
....................          control_loop_cycles_to_next_update = 6; 
0566C:  MOVLW  06
0566E:  MOVWF  x3F
....................       } 
05670:  BRA    56A2
....................       else if (rpm_difference >= 10) 
05672:  MOVF   x4C,F
05674:  BNZ   567C
05676:  MOVF   x4B,W
05678:  SUBLW  09
0567A:  BC    5686
....................       { 
....................          duty_change = 4; 
0567C:  MOVLW  04
0567E:  MOVWF  x51
....................          control_loop_cycles_to_next_update = 7; 
05680:  MOVLW  07
05682:  MOVWF  x3F
....................       } 
05684:  BRA    56A2
....................       else if (rpm_difference >= 5)  
05686:  MOVF   x4C,F
05688:  BNZ   5690
0568A:  MOVF   x4B,W
0568C:  SUBLW  04
0568E:  BC    569A
....................       { 
....................          duty_change = 2; 
05690:  MOVLW  02
05692:  MOVWF  x51
....................          control_loop_cycles_to_next_update = 8; 
05694:  MOVLW  08
05696:  MOVWF  x3F
....................       } 
05698:  BRA    56A2
.................... //      else if (rpm_difference >= 0)  
....................       else 
....................       {   
....................          duty_change = 1; 
0569A:  MOVLW  01
0569C:  MOVWF  x51
....................          control_loop_cycles_to_next_update = 10; 
0569E:  MOVLW  0A
056A0:  MOVWF  x3F
....................       } 
....................        
....................       // Set point is lower than current value (increase braking force) 
....................       if (global_current_rpm > global_rpm_set_value)  
056A2:  MOVLB  0
056A4:  MOVF   xAD,W
056A6:  SUBWF  xAB,W
056A8:  BTFSS  FD8.0
056AA:  BRA    579E
056AC:  BNZ   56B6
056AE:  MOVF   xAA,W
056B0:  SUBWF  xAC,W
056B2:  BTFSC  FD8.0
056B4:  BRA    579E
....................       { 
....................          // if we are at max charge already, move to the braking 
....................          if (global_charge_duty == MAX_CHARGE) 
056B6:  MOVF   xB4,W
056B8:  SUBLW  90
056BA:  BNZ   5746
056BC:  DECFSZ xB5,W
056BE:  BRA    5746
....................          { 
....................             // if we are at max brake (and charge) and detecting a magnetic decoupling condition 
....................             if ((global_brake_duty == MAX_BRK) && (global_current_rpm == 0-1)) 
056C0:  MOVF   xB2,W
056C2:  SUBLW  90
056C4:  BNZ   56D4
056C6:  DECFSZ xB3,W
056C8:  BRA    56D4
056CA:  INCFSZ xAA,W
056CC:  BRA    56D4
056CE:  INCFSZ xAB,W
056D0:  BRA    56D4
....................             { 
.................... #IFNDEF DISABLE_MAG_DECOUPLING_RECOVERY 
....................              
....................                // start magnetic de-coupling fix 
....................                // set an error bit saying magnetic decoupling is detected 
....................                global_error_message_bitfield |= ERR_MSG_MAG_DECOUPLING; 
....................                // send error message 
....................                PUSH_MESSAGE_QUEUE_MACRO(MSG_MOTE_ERROR_MSG); 
....................                // push a MOVE_VALVE_MAG_DECOUPLING_RECOVERY event 
....................                PUSH_PRIORITY_QUEUE_MACRO(MOVE_VALVE_MAG_DECOUPLING_RECOVERY); 
.................... #ENDIF 
....................             } 
056D2:  BRA    5744
....................  
....................             // if we are at max brake (and charge) (no decoupling) send an error message 
....................             else if (global_brake_duty == MAX_BRK) 
056D4:  MOVF   xB2,W
056D6:  SUBLW  90
056D8:  BNZ   56F2
056DA:  DECFSZ xB3,W
056DC:  BRA    56F2
....................             { 
....................                // set an error bit saying rpm was too low to reach 
....................                global_error_message_bitfield |= ERR_MSG_RPM_TOO_LOW_TO_REACH; 
056DE:  MOVLB  4
056E0:  BSF    xF8.5
....................                // send error message 
....................                PUSH_MESSAGE_QUEUE_MACRO(MSG_MOTE_ERROR_MSG); 
056E2:  BCF    F7A.1
056E4:  MOVLW  A0
056E6:  MOVLB  5
056E8:  MOVWF  x54
056EA:  MOVLB  0
056EC:  RCALL  51F6
056EE:  BSF    F7A.1
....................             } 
056F0:  BRA    5744
....................             // if we can't increase charge anymore, set it to max 
....................             else if ((global_brake_duty + duty_change) > MAX_CHARGE) 
056F2:  MOVLB  5
056F4:  MOVF   x51,W
056F6:  MOVLB  0
056F8:  ADDWF  xB2,W
056FA:  MOVLB  5
056FC:  MOVWF  x54
056FE:  MOVLW  00
05700:  MOVLB  0
05702:  ADDWFC xB3,W
05704:  MOVLB  5
05706:  MOVWF  x55
05708:  SUBLW  00
0570A:  BC    5726
0570C:  XORLW  FF
0570E:  BNZ   5716
05710:  MOVF   x54,W
05712:  SUBLW  90
05714:  BC    5726
....................             { 
....................                set_brake_duty(MAX_BRK); 
05716:  MOVLW  01
05718:  MOVWF  x57
0571A:  MOVLW  90
0571C:  MOVWF  x56
0571E:  MOVLB  0
05720:  RCALL  550A
....................             } 
05722:  BRA    5744
05724:  MOVLB  5
....................             // increase braking as per normal 
....................             else 
....................             { 
....................                set_brake_duty(global_brake_duty + duty_change); 
05726:  MOVF   x51,W
05728:  MOVLB  0
0572A:  ADDWF  xB2,W
0572C:  MOVLB  5
0572E:  MOVWF  x54
05730:  MOVLW  00
05732:  MOVLB  0
05734:  ADDWFC xB3,W
05736:  MOVLB  5
05738:  MOVWF  x55
0573A:  MOVWF  x57
0573C:  MOVFF  554,556
05740:  MOVLB  0
05742:  RCALL  550A
....................             } 
....................          }   
05744:  BRA    579C
....................          // if we can't increase charge anymore, set it to max 
....................          else if ((global_charge_duty + duty_change) > MAX_CHARGE) 
05746:  MOVLB  5
05748:  MOVF   x51,W
0574A:  MOVLB  0
0574C:  ADDWF  xB4,W
0574E:  MOVLB  5
05750:  MOVWF  x54
05752:  MOVLW  00
05754:  MOVLB  0
05756:  ADDWFC xB5,W
05758:  MOVLB  5
0575A:  MOVWF  x55
0575C:  SUBLW  00
0575E:  BC    577C
05760:  XORLW  FF
05762:  BNZ   576A
05764:  MOVF   x54,W
05766:  SUBLW  90
05768:  BC    577C
....................          { 
....................             set_charge_duty(MAX_CHARGE); 
0576A:  MOVLW  01
0576C:  MOVWF  x57
0576E:  MOVLW  90
05770:  MOVWF  x56
05772:  MOVLB  0
05774:  CALL   3F78
....................          } 
05778:  BRA    579C
0577A:  MOVLB  5
....................         // increase charging as per normal 
....................         else 
....................         { 
....................             set_charge_duty(global_charge_duty + duty_change); 
0577C:  MOVF   x51,W
0577E:  MOVLB  0
05780:  ADDWF  xB4,W
05782:  MOVLB  5
05784:  MOVWF  x54
05786:  MOVLW  00
05788:  MOVLB  0
0578A:  ADDWFC xB5,W
0578C:  MOVLB  5
0578E:  MOVWF  x55
05790:  MOVWF  x57
05792:  MOVFF  554,556
05796:  MOVLB  0
05798:  CALL   3F78
....................         } 
....................       } 
0579C:  BRA    5888
....................       // Set point is higher than current value (increase braking force) 
....................       else if (global_current_rpm < global_rpm_set_value)  
0579E:  MOVF   xAB,W
057A0:  SUBWF  xAD,W
057A2:  BTFSS  FD8.0
057A4:  BRA    5888
057A6:  BNZ   57B0
057A8:  MOVF   xAC,W
057AA:  SUBWF  xAA,W
057AC:  BTFSC  FD8.0
057AE:  BRA    5888
....................       { 
....................          // if we are at min braking already, move to the charging 
....................          if (global_brake_duty == NO_BRK) 
057B0:  MOVF   xB2,F
057B2:  BNZ   583A
057B4:  MOVF   xB3,F
057B6:  BNZ   583A
....................          { 
....................             // if we are at min charge (and brake) and the rpms are 0  
....................             // (a not spinning condition) 
....................             if ((global_charge_duty == NO_CHARGE) && (global_current_rpm == 0)) 
057B8:  MOVF   xB4,F
057BA:  BNZ   57CA
057BC:  MOVF   xB5,F
057BE:  BNZ   57CA
057C0:  MOVF   xAA,F
057C2:  BNZ   57CA
057C4:  MOVF   xAB,F
057C6:  BNZ   57CA
....................             { 
.................... #IFNDEF DISABLE_NO_SPIN_RECOVERY             
....................                // start not spinning recovery 
....................                // set an error bit saying there isn't any spinning 
....................                global_error_message_bitfield |= ERR_MSG_NOT_SPINNING; 
....................                // send error message to manager 
....................                PUSH_MESSAGE_QUEUE_MACRO(MSG_MOTE_ERROR_MSG); 
....................                // push a MOVE_VALVE_NO_SPIN_RECOVERY event                
....................                PUSH_PRIORITY_QUEUE_MACRO(MOVE_VALVE_NO_SPIN_RECOVERY); 
.................... #ENDIF 
....................             } 
057C8:  BRA    5838
....................             // if we are at min charge (and brake) send an error message if 
....................             //    the bitfield bit isn't already sent (to avoid sending messages 
....................             //    all the time 
....................             else if (global_charge_duty == NO_CHARGE)  
057CA:  MOVF   xB4,F
057CC:  BNZ   57E6
057CE:  MOVF   xB5,F
057D0:  BNZ   57E6
....................             { 
....................                // set an error bit saying rpm was too high to reach 
....................                global_error_message_bitfield |= ERR_MSG_RPM_TOO_HIGH_TO_REACH; 
057D2:  MOVLB  4
057D4:  BSF    xF8.4
....................                // send error message to manager 
....................                PUSH_MESSAGE_QUEUE_MACRO(MSG_MOTE_ERROR_MSG); 
057D6:  BCF    F7A.1
057D8:  MOVLW  A0
057DA:  MOVLB  5
057DC:  MOVWF  x54
057DE:  MOVLB  0
057E0:  RCALL  51F6
057E2:  BSF    F7A.1
....................             } 
057E4:  BRA    5838
....................             // if we can't decrease charge anymore, set it to min 
....................             // notice use of unsigned math here  
....................             else if ((global_charge_duty - duty_change) > MAX_CHARGE) 
057E6:  MOVLB  5
057E8:  MOVF   x51,W
057EA:  MOVLB  0
057EC:  SUBWF  xB4,W
057EE:  MOVLB  5
057F0:  MOVWF  x54
057F2:  MOVLW  00
057F4:  MOVLB  0
057F6:  SUBWFB xB5,W
057F8:  MOVLB  5
057FA:  MOVWF  x55
057FC:  SUBLW  00
057FE:  BC    5818
05800:  XORLW  FF
05802:  BNZ   580A
05804:  MOVF   x54,W
05806:  SUBLW  90
05808:  BC    5818
....................             { 
....................                set_charge_duty(NO_CHARGE); 
0580A:  CLRF   x57
0580C:  CLRF   x56
0580E:  MOVLB  0
05810:  CALL   3F78
....................             } 
05814:  BRA    5838
05816:  MOVLB  5
....................             // decrease charging as per normal 
....................             else 
....................             { 
....................                set_charge_duty(global_charge_duty - duty_change); 
05818:  MOVF   x51,W
0581A:  MOVLB  0
0581C:  SUBWF  xB4,W
0581E:  MOVLB  5
05820:  MOVWF  x54
05822:  MOVLW  00
05824:  MOVLB  0
05826:  SUBWFB xB5,W
05828:  MOVLB  5
0582A:  MOVWF  x55
0582C:  MOVWF  x57
0582E:  MOVFF  554,556
05832:  MOVLB  0
05834:  CALL   3F78
....................             } 
....................          }   
05838:  BRA    5888
....................          // if we can't decrease brake anymore, set it to min 
....................          // notice use of unsigned math here  
....................          else if ((global_brake_duty - duty_change) > MAX_BRK) 
0583A:  MOVLB  5
0583C:  MOVF   x51,W
0583E:  MOVLB  0
05840:  SUBWF  xB2,W
05842:  MOVLB  5
05844:  MOVWF  x54
05846:  MOVLW  00
05848:  MOVLB  0
0584A:  SUBWFB xB3,W
0584C:  MOVLB  5
0584E:  MOVWF  x55
05850:  SUBLW  00
05852:  BC    586A
05854:  XORLW  FF
05856:  BNZ   585E
05858:  MOVF   x54,W
0585A:  SUBLW  90
0585C:  BC    586A
....................          { 
....................             set_brake_duty(NO_BRK); 
0585E:  CLRF   x57
05860:  CLRF   x56
05862:  MOVLB  0
05864:  RCALL  550A
....................          } 
05866:  BRA    5888
05868:  MOVLB  5
....................         // decrease braking as per normal 
....................         else 
....................         { 
....................             set_brake_duty(global_brake_duty - duty_change); 
0586A:  MOVF   x51,W
0586C:  MOVLB  0
0586E:  SUBWF  xB2,W
05870:  MOVLB  5
05872:  MOVWF  x54
05874:  MOVLW  00
05876:  MOVLB  0
05878:  SUBWFB xB3,W
0587A:  MOVLB  5
0587C:  MOVWF  x55
0587E:  MOVWF  x57
05880:  MOVFF  554,556
05884:  MOVLB  0
05886:  RCALL  550A
....................         } 
....................       } 
....................       break; 
05888:  BRA    5DA6
....................        
....................    // RPM is only controlled by brake (when charger is turned off 
....................    case BRAKE_ONLY: 
....................    case BRAKE_AND_CHARGE_START: 
....................       // calculate the difference in rpm from set point 
....................       rpm_difference = abs((int16_t)global_current_rpm - (int16_t)global_rpm_set_value); 
0588A:  MOVF   xAC,W
0588C:  SUBWF  xAA,W
0588E:  MOVLB  5
05890:  MOVWF  x54
05892:  MOVLB  0
05894:  MOVF   xAD,W
05896:  SUBWFB xAB,W
05898:  MOVLB  5
0589A:  MOVWF  x55
0589C:  MOVWF  03
0589E:  MOVF   x54,W
058A0:  BTFSS  x55.7
058A2:  BRA    58B4
058A4:  MOVLW  00
058A6:  BSF    FD8.0
058A8:  SUBFWB x54,W
058AA:  MOVWF  00
058AC:  MOVLW  00
058AE:  SUBFWB x55,W
058B0:  MOVWF  03
058B2:  MOVF   00,W
058B4:  MOVWF  x4B
058B6:  MOVFF  03,54C
....................        
....................       // calulate how much to change the parameter (either brake or charge, just 
....................       //    reusing brake duty cycle for both) and how often to update based on  
....................       //    rpm difference from setpoint 
....................       if (rpm_difference >= 50)  
058BA:  MOVF   x4C,F
058BC:  BNZ   58C4
058BE:  MOVF   x4B,W
058C0:  SUBLW  31
058C2:  BC    58CE
....................       { 
....................          duty_change = 15; 
058C4:  MOVLW  0F
058C6:  MOVWF  x51
....................          control_loop_cycles_to_next_update = 5; 
058C8:  MOVLW  05
058CA:  MOVWF  x3F
....................       } 
058CC:  BRA    5912
....................       else if (rpm_difference >= 25)  
058CE:  MOVF   x4C,F
058D0:  BNZ   58D8
058D2:  MOVF   x4B,W
058D4:  SUBLW  18
058D6:  BC    58E2
....................       { 
....................          duty_change = 10; 
058D8:  MOVLW  0A
058DA:  MOVWF  x51
....................          control_loop_cycles_to_next_update = 5; 
058DC:  MOVLW  05
058DE:  MOVWF  x3F
....................       } 
058E0:  BRA    5912
....................       else if (rpm_difference >= 10) 
058E2:  MOVF   x4C,F
058E4:  BNZ   58EC
058E6:  MOVF   x4B,W
058E8:  SUBLW  09
058EA:  BC    58F6
....................       { 
....................          duty_change = 5; 
058EC:  MOVLW  05
058EE:  MOVWF  x51
....................          control_loop_cycles_to_next_update = 7; 
058F0:  MOVLW  07
058F2:  MOVWF  x3F
....................       } 
058F4:  BRA    5912
....................       else if (rpm_difference >= 5)  
058F6:  MOVF   x4C,F
058F8:  BNZ   5900
058FA:  MOVF   x4B,W
058FC:  SUBLW  04
058FE:  BC    590A
....................       { 
....................          duty_change = 2; 
05900:  MOVLW  02
05902:  MOVWF  x51
....................          control_loop_cycles_to_next_update = 8; 
05904:  MOVLW  08
05906:  MOVWF  x3F
....................       } 
05908:  BRA    5912
.................... //      else if (rpm_difference >= 0)  
....................       else 
....................       {   
....................          duty_change = 1; 
0590A:  MOVLW  01
0590C:  MOVWF  x51
....................          control_loop_cycles_to_next_update = 8; 
0590E:  MOVLW  08
05910:  MOVWF  x3F
....................       } 
....................        
....................       // Set point is lower than current value (increase braking force) 
....................       if (global_current_rpm > global_rpm_set_value)  
05912:  MOVLB  0
05914:  MOVF   xAD,W
05916:  SUBWF  xAB,W
05918:  BNC   5996
0591A:  BNZ   5922
0591C:  MOVF   xAA,W
0591E:  SUBWF  xAC,W
05920:  BC    5996
....................       { 
....................       // if we are at max brake (and charge) and detecting a magnetic decoupling condition 
....................          if ((global_brake_duty == MAX_BRK) && (global_current_rpm == 0-1)) 
05922:  MOVF   xB2,W
05924:  SUBLW  90
05926:  BNZ   5936
05928:  DECFSZ xB3,W
0592A:  BRA    5936
0592C:  INCFSZ xAA,W
0592E:  BRA    5936
05930:  INCFSZ xAB,W
05932:  BRA    5936
....................          { 
.................... #IFNDEF DISABLE_MAG_DECOUPLING_RECOVERY          
....................             // start magnetic de-coupling fix 
....................             // set an error bit saying magnetic decoupling is detected 
....................             global_error_message_bitfield |= ERR_MSG_MAG_DECOUPLING; 
....................             // send error message 
....................             PUSH_MESSAGE_QUEUE_MACRO(MSG_MOTE_ERROR_MSG); 
....................             // push a MOVE_VALVE_MAG_DECOUPLING_RECOVERY event 
....................             PUSH_PRIORITY_QUEUE_MACRO(MOVE_VALVE_MAG_DECOUPLING_RECOVERY); 
.................... #ENDIF             
....................          } 
05934:  BRA    5994
....................          // if we are at max brake (and charge) send an error message 
....................          else if (global_brake_duty == MAX_BRK) 
05936:  MOVF   xB2,W
05938:  SUBLW  90
0593A:  BNZ   5942
0593C:  DECFSZ xB3,W
0593E:  BRA    5942
....................          { 
.................... #IFNDEF DISABLE_MAG_DECOUPLING_RECOVERY          
....................             // set an error bit saying rpm was too low to reach 
....................             global_error_message_bitfield |= ERR_MSG_MAG_DECOUPLING; 
....................             // send error message 
....................             PUSH_MESSAGE_QUEUE_MACRO(MSG_MOTE_ERROR_MSG); 
.................... #ENDIF 
....................          } 
05940:  BRA    5994
....................          // if we can't increase charge anymore, set it to max 
....................          else if ((global_brake_duty + duty_change) > MAX_CHARGE) 
05942:  MOVLB  5
05944:  MOVF   x51,W
05946:  MOVLB  0
05948:  ADDWF  xB2,W
0594A:  MOVLB  5
0594C:  MOVWF  x54
0594E:  MOVLW  00
05950:  MOVLB  0
05952:  ADDWFC xB3,W
05954:  MOVLB  5
05956:  MOVWF  x55
05958:  SUBLW  00
0595A:  BC    5976
0595C:  XORLW  FF
0595E:  BNZ   5966
05960:  MOVF   x54,W
05962:  SUBLW  90
05964:  BC    5976
....................          { 
....................             set_brake_duty(MAX_BRK); 
05966:  MOVLW  01
05968:  MOVWF  x57
0596A:  MOVLW  90
0596C:  MOVWF  x56
0596E:  MOVLB  0
05970:  RCALL  550A
....................          } 
05972:  BRA    5994
05974:  MOVLB  5
....................          // increase braking as per normal 
....................          else 
....................          { 
....................             set_brake_duty(global_brake_duty + duty_change); 
05976:  MOVF   x51,W
05978:  MOVLB  0
0597A:  ADDWF  xB2,W
0597C:  MOVLB  5
0597E:  MOVWF  x54
05980:  MOVLW  00
05982:  MOVLB  0
05984:  ADDWFC xB3,W
05986:  MOVLB  5
05988:  MOVWF  x55
0598A:  MOVWF  x57
0598C:  MOVFF  554,556
05990:  MOVLB  0
05992:  RCALL  550A
....................          } 
....................         
....................       } 
05994:  BRA    5A20
....................       // Set point is higher than current value (increase braking force) 
....................       else if (global_current_rpm < global_rpm_set_value)  
05996:  MOVF   xAB,W
05998:  SUBWF  xAD,W
0599A:  BNC   5A20
0599C:  BNZ   59A4
0599E:  MOVF   xAC,W
059A0:  SUBWF  xAA,W
059A2:  BC    5A20
....................       { 
....................           
....................          // if we are at min charge (and brake) and the rpms are 0  
....................          // (a not spinning condition) 
....................          if (global_brake_duty == NO_BRK && (global_current_rpm == 0)) 
059A4:  MOVF   xB2,F
059A6:  BNZ   59B6
059A8:  MOVF   xB3,F
059AA:  BNZ   59B6
059AC:  MOVF   xAA,F
059AE:  BNZ   59B6
059B0:  MOVF   xAB,F
059B2:  BNZ   59B6
....................          { 
.................... #IFNDEF DISABLE_NO_SPIN_RECOVERY        
....................             // start not spinning recovery 
....................             // set an error bit saying there isn't any spinning 
....................             global_error_message_bitfield |= ERR_MSG_NOT_SPINNING; 
....................             // send error message to manager 
....................             PUSH_MESSAGE_QUEUE_MACRO(MSG_MOTE_ERROR_MSG); 
....................             // push a MOVE_VALVE_NO_SPIN_RECOVERY event                
....................             PUSH_PRIORITY_QUEUE_MACRO(MOVE_VALVE_NO_SPIN_RECOVERY); 
.................... #ENDIF 
....................          } 
059B4:  BRA    5A20
....................          // if we are at min braking already, move to the charging 
....................          else if (global_brake_duty == NO_BRK) 
059B6:  MOVF   xB2,F
059B8:  BNZ   59D2
059BA:  MOVF   xB3,F
059BC:  BNZ   59D2
....................          { 
....................             // if we are at min charge (and brake) send an error message if 
....................             //    the bitfield bit isn't already sent (to avoid sending messages 
....................             //    all the time 
....................     
....................             // set an error bit saying rpm was too high to reach 
....................             global_error_message_bitfield |= ERR_MSG_RPM_TOO_HIGH_TO_REACH; 
059BE:  MOVLB  4
059C0:  BSF    xF8.4
....................             // send error message to manager 
....................             PUSH_MESSAGE_QUEUE_MACRO(MSG_MOTE_ERROR_MSG);   
059C2:  BCF    F7A.1
059C4:  MOVLW  A0
059C6:  MOVLB  5
059C8:  MOVWF  x54
059CA:  MOVLB  0
059CC:  RCALL  51F6
059CE:  BSF    F7A.1
....................          }   
059D0:  BRA    5A20
....................          // if we can't decrease brake anymore, set it to min 
....................          // notice use of unsigned math here  
....................          else if ((global_brake_duty - duty_change) > MAX_BRK) 
059D2:  MOVLB  5
059D4:  MOVF   x51,W
059D6:  MOVLB  0
059D8:  SUBWF  xB2,W
059DA:  MOVLB  5
059DC:  MOVWF  x54
059DE:  MOVLW  00
059E0:  MOVLB  0
059E2:  SUBWFB xB3,W
059E4:  MOVLB  5
059E6:  MOVWF  x55
059E8:  SUBLW  00
059EA:  BC    5A02
059EC:  XORLW  FF
059EE:  BNZ   59F6
059F0:  MOVF   x54,W
059F2:  SUBLW  90
059F4:  BC    5A02
....................          { 
....................             set_brake_duty(NO_BRK); 
059F6:  CLRF   x57
059F8:  CLRF   x56
059FA:  MOVLB  0
059FC:  RCALL  550A
....................          } 
059FE:  BRA    5A20
05A00:  MOVLB  5
....................         // decrease braking as per normal 
....................         else 
....................         { 
....................             set_brake_duty(global_brake_duty - duty_change); 
05A02:  MOVF   x51,W
05A04:  MOVLB  0
05A06:  SUBWF  xB2,W
05A08:  MOVLB  5
05A0A:  MOVWF  x54
05A0C:  MOVLW  00
05A0E:  MOVLB  0
05A10:  SUBWFB xB3,W
05A12:  MOVLB  5
05A14:  MOVWF  x55
05A16:  MOVWF  x57
05A18:  MOVFF  554,556
05A1C:  MOVLB  0
05A1E:  RCALL  550A
....................         } 
....................       } 
....................        
....................       // if we are in the brake only loop and want to turn off charger 
....................       if (global_control_loop_mechanism == BRAKE_ONLY) 
05A20:  MOVF   xC0,W
05A22:  SUBLW  02
05A24:  BNZ   5A70
....................       { 
....................          // turn down charging until it is off (slowly) 
....................          if (global_charge_duty != NO_CHARGE) 
05A26:  MOVF   xB4,F
05A28:  BNZ   5A2E
05A2A:  MOVF   xB5,F
05A2C:  BZ    5A6E
....................          { 
....................             // if gobal_charge_duty is 0-3 (note unsigned int math) 
....................             if ((global_charge_duty - 4) > MAX_CHARGE) 
05A2E:  MOVLW  04
05A30:  SUBWF  xB4,W
05A32:  MOVLB  5
05A34:  MOVWF  x54
05A36:  MOVLW  00
05A38:  MOVLB  0
05A3A:  SUBWFB xB5,W
05A3C:  MOVLB  5
05A3E:  MOVWF  x55
05A40:  SUBLW  00
05A42:  BC    5A58
05A44:  XORLW  FF
05A46:  BNZ   5A4E
05A48:  MOVF   x54,W
05A4A:  SUBLW  90
05A4C:  BC    5A58
....................             { 
....................                // set it to no charge 
....................                global_charge_duty = NO_CHARGE; 
05A4E:  MOVLB  0
05A50:  CLRF   xB5
05A52:  CLRF   xB4
....................             } 
05A54:  BRA    5A62
05A56:  MOVLB  5
....................             else 
....................             { 
....................                // otherwise, decrement it by 4 
....................                global_charge_duty -= 4; 
05A58:  MOVLW  04
05A5A:  MOVLB  0
05A5C:  SUBWF  xB4,F
05A5E:  MOVLW  00
05A60:  SUBWFB xB5,F
....................             } 
....................             // set lower charge amount. 
....................             set_charge_duty(global_charge_duty);  
05A62:  MOVFF  B5,557
05A66:  MOVFF  B4,556
05A6A:  CALL   3F78
....................          } 
....................       } 
05A6E:  BRA    5AC8
....................       // if we are trying to turn the charger back on    
....................       else if (global_control_loop_mechanism == BRAKE_AND_CHARGE_START) 
05A70:  MOVF   xC0,F
05A72:  BNZ   5AC8
....................       {    
....................          // if gobal_charge_duty is almost completely on 
....................          if ((global_charge_duty + 4) >= MAX_CHARGE) 
05A74:  MOVLW  04
05A76:  ADDWF  xB4,W
05A78:  MOVLB  5
05A7A:  MOVWF  x54
05A7C:  MOVLW  00
05A7E:  MOVLB  0
05A80:  ADDWFC xB5,W
05A82:  MOVLB  5
05A84:  MOVWF  x55
05A86:  SUBLW  00
05A88:  BC    5AA4
05A8A:  XORLW  FF
05A8C:  BNZ   5A94
05A8E:  MOVF   x54,W
05A90:  SUBLW  8F
05A92:  BC    5AA4
....................          { 
....................             // set it to max charge 
....................             global_charge_duty = MAX_CHARGE; 
05A94:  MOVLW  01
05A96:  MOVLB  0
05A98:  MOVWF  xB5
05A9A:  MOVLW  90
05A9C:  MOVWF  xB4
....................             // change control loop mechanism so it changes on next loop 
....................             global_control_loop_mechanism = BRAKE_AND_CHARGE; 
05A9E:  MOVLW  01
05AA0:  MOVWF  xC0
....................          } 
05AA2:  BRA    5ABC
....................          // if the braking has turned itself all the way off trying to compensate for 
....................          //    the charging turning on, switch over to the main control loop 
....................          else if(global_brake_duty == NO_BRK) 
05AA4:  MOVLB  0
05AA6:  MOVF   xB2,F
05AA8:  BNZ   5AB4
05AAA:  MOVF   xB3,F
05AAC:  BNZ   5AB4
....................          { 
....................             // change control loop mechanism 
....................             global_control_loop_mechanism = BRAKE_AND_CHARGE; 
05AAE:  MOVLW  01
05AB0:  MOVWF  xC0
....................          } 
05AB2:  BRA    5ABC
....................          // otherwise, keep increasing the charge duty cycle. 
....................          else 
....................          { 
....................             // otherwise, decrement it by 4 
....................             global_charge_duty += 4; 
05AB4:  MOVLW  04
05AB6:  ADDWF  xB4,F
05AB8:  MOVLW  00
05ABA:  ADDWFC xB5,F
....................          } 
....................          // set higher charge amount. 
....................          set_charge_duty(global_charge_duty); 
05ABC:  MOVFF  B5,557
05AC0:  MOVFF  B4,556
05AC4:  CALL   3F78
....................       } 
....................       break; 
05AC8:  BRA    5DA6
....................        
....................        
....................    // If in no rpm test mode 
....................    case NO_RPM_CONTROL_DYN_MPPC: 
....................    case NO_RPM_CONTROL: 
....................  
....................       // move things closer to the set values 
....................       // worst case senario 2.3 seconds to move 400 counts 
....................        
....................       // if difference is >= 200, move by 20  
....................       // if difference is >= 100, move by 10 
....................       // if difference is >= 50, move by 5 
....................       // if difference is >= 10, move by 2 
....................       // if difference is < 10, move by 1 
....................        
....................       brake_duty_difference = abs((int16_t)global_brake_duty - (int16_t)global_brake_duty_set_value); 
05ACA:  MOVF   xB6,W
05ACC:  SUBWF  xB2,W
05ACE:  MOVLB  5
05AD0:  MOVWF  x54
05AD2:  MOVLB  0
05AD4:  MOVF   xB7,W
05AD6:  SUBWFB xB3,W
05AD8:  MOVLB  5
05ADA:  MOVWF  x55
05ADC:  MOVWF  03
05ADE:  MOVF   x54,W
05AE0:  BTFSS  x55.7
05AE2:  BRA    5AF4
05AE4:  MOVLW  00
05AE6:  BSF    FD8.0
05AE8:  SUBFWB x54,W
05AEA:  MOVWF  00
05AEC:  MOVLW  00
05AEE:  SUBFWB x55,W
05AF0:  MOVWF  03
05AF2:  MOVF   00,W
05AF4:  MOVWF  x4D
05AF6:  MOVFF  03,54E
....................       charge_duty_difference = abs((int16_t)global_charge_duty - (int16_t)global_charge_duty_set_value); 
05AFA:  MOVLB  0
05AFC:  MOVF   xB8,W
05AFE:  SUBWF  xB4,W
05B00:  MOVLB  5
05B02:  MOVWF  x54
05B04:  MOVLB  0
05B06:  MOVF   xB9,W
05B08:  SUBWFB xB5,W
05B0A:  MOVLB  5
05B0C:  MOVWF  x55
05B0E:  MOVWF  03
05B10:  MOVF   x54,W
05B12:  BTFSS  x55.7
05B14:  BRA    5B26
05B16:  MOVLW  00
05B18:  BSF    FD8.0
05B1A:  SUBFWB x54,W
05B1C:  MOVWF  00
05B1E:  MOVLW  00
05B20:  SUBFWB x55,W
05B22:  MOVWF  03
05B24:  MOVF   00,W
05B26:  MOVWF  x4F
05B28:  MOVFF  03,550
....................        
....................       if (brake_duty_difference >= 200) brake_duty_change = 20; 
05B2C:  MOVF   x4E,F
05B2E:  BNZ   5B36
05B30:  MOVF   x4D,W
05B32:  SUBLW  C7
05B34:  BC    5B3C
05B36:  MOVLW  14
05B38:  MOVWF  x52
05B3A:  BRA    5B78
....................       else if (brake_duty_difference >= 100) brake_duty_change = 10; 
05B3C:  MOVF   x4E,F
05B3E:  BNZ   5B46
05B40:  MOVF   x4D,W
05B42:  SUBLW  63
05B44:  BC    5B4C
05B46:  MOVLW  0A
05B48:  MOVWF  x52
05B4A:  BRA    5B78
....................       else if (brake_duty_difference >= 50) brake_duty_change = 5; 
05B4C:  MOVF   x4E,F
05B4E:  BNZ   5B56
05B50:  MOVF   x4D,W
05B52:  SUBLW  31
05B54:  BC    5B5C
05B56:  MOVLW  05
05B58:  MOVWF  x52
05B5A:  BRA    5B78
....................       else if (brake_duty_difference >= 10) brake_duty_change = 2; 
05B5C:  MOVF   x4E,F
05B5E:  BNZ   5B66
05B60:  MOVF   x4D,W
05B62:  SUBLW  09
05B64:  BC    5B6C
05B66:  MOVLW  02
05B68:  MOVWF  x52
05B6A:  BRA    5B78
....................       else if (brake_duty_difference > 0) brake_duty_change = 1; 
05B6C:  MOVF   x4D,F
05B6E:  BNZ   5B74
05B70:  MOVF   x4E,F
05B72:  BZ    5B78
05B74:  MOVLW  01
05B76:  MOVWF  x52
....................        
....................       if (global_brake_duty > global_brake_duty_set_value)  
05B78:  MOVLB  0
05B7A:  MOVF   xB7,W
05B7C:  SUBWF  xB3,W
05B7E:  BNC   5BA0
05B80:  BNZ   5B88
05B82:  MOVF   xB2,W
05B84:  SUBWF  xB6,W
05B86:  BC    5BA0
....................       { 
....................          global_brake_duty-=brake_duty_change; 
05B88:  MOVLB  5
05B8A:  MOVF   x52,W
05B8C:  MOVLB  0
05B8E:  SUBWF  xB2,F
05B90:  MOVLW  00
05B92:  SUBWFB xB3,F
....................          set_brake_duty(global_brake_duty); 
05B94:  MOVFF  B3,557
05B98:  MOVFF  B2,556
05B9C:  RCALL  550A
....................       } 
05B9E:  BRA    5BC4
....................       else if (global_brake_duty < global_brake_duty_set_value) 
05BA0:  MOVF   xB3,W
05BA2:  SUBWF  xB7,W
05BA4:  BNC   5BC4
05BA6:  BNZ   5BAE
05BA8:  MOVF   xB6,W
05BAA:  SUBWF  xB2,W
05BAC:  BC    5BC4
....................       { 
....................          global_brake_duty+=brake_duty_change; 
05BAE:  MOVLB  5
05BB0:  MOVF   x52,W
05BB2:  MOVLB  0
05BB4:  ADDWF  xB2,F
05BB6:  MOVLW  00
05BB8:  ADDWFC xB3,F
....................          set_brake_duty(global_brake_duty); 
05BBA:  MOVFF  B3,557
05BBE:  MOVFF  B2,556
05BC2:  RCALL  550A
....................       } 
....................        
....................       if (charge_duty_difference >= 200) charge_duty_change = 20; 
05BC4:  MOVLB  5
05BC6:  MOVF   x50,F
05BC8:  BNZ   5BD0
05BCA:  MOVF   x4F,W
05BCC:  SUBLW  C7
05BCE:  BC    5BD6
05BD0:  MOVLW  14
05BD2:  MOVWF  x53
05BD4:  BRA    5C12
....................       else if (charge_duty_difference >= 100) charge_duty_change = 10; 
05BD6:  MOVF   x50,F
05BD8:  BNZ   5BE0
05BDA:  MOVF   x4F,W
05BDC:  SUBLW  63
05BDE:  BC    5BE6
05BE0:  MOVLW  0A
05BE2:  MOVWF  x53
05BE4:  BRA    5C12
....................       else if (charge_duty_difference >= 50) charge_duty_change = 5; 
05BE6:  MOVF   x50,F
05BE8:  BNZ   5BF0
05BEA:  MOVF   x4F,W
05BEC:  SUBLW  31
05BEE:  BC    5BF6
05BF0:  MOVLW  05
05BF2:  MOVWF  x53
05BF4:  BRA    5C12
....................       else if (charge_duty_difference >= 10) charge_duty_change = 2; 
05BF6:  MOVF   x50,F
05BF8:  BNZ   5C00
05BFA:  MOVF   x4F,W
05BFC:  SUBLW  09
05BFE:  BC    5C06
05C00:  MOVLW  02
05C02:  MOVWF  x53
05C04:  BRA    5C12
....................       else if (charge_duty_difference > 0) charge_duty_change = 1; 
05C06:  MOVF   x4F,F
05C08:  BNZ   5C0E
05C0A:  MOVF   x50,F
05C0C:  BZ    5C12
05C0E:  MOVLW  01
05C10:  MOVWF  x53
....................        
....................       if (global_charge_duty > global_charge_duty_set_value)  
05C12:  MOVLB  0
05C14:  MOVF   xB9,W
05C16:  SUBWF  xB5,W
05C18:  BNC   5C3C
05C1A:  BNZ   5C22
05C1C:  MOVF   xB4,W
05C1E:  SUBWF  xB8,W
05C20:  BC    5C3C
....................       { 
....................          global_charge_duty-=charge_duty_change; 
05C22:  MOVLB  5
05C24:  MOVF   x53,W
05C26:  MOVLB  0
05C28:  SUBWF  xB4,F
05C2A:  MOVLW  00
05C2C:  SUBWFB xB5,F
....................          set_charge_duty(global_charge_duty); 
05C2E:  MOVFF  B5,557
05C32:  MOVFF  B4,556
05C36:  CALL   3F78
....................       } 
05C3A:  BRA    5C62
....................       else if (global_charge_duty < global_charge_duty_set_value) 
05C3C:  MOVF   xB5,W
05C3E:  SUBWF  xB9,W
05C40:  BNC   5C62
05C42:  BNZ   5C4A
05C44:  MOVF   xB8,W
05C46:  SUBWF  xB4,W
05C48:  BC    5C62
....................       { 
....................          global_charge_duty+=charge_duty_change; 
05C4A:  MOVLB  5
05C4C:  MOVF   x53,W
05C4E:  MOVLB  0
05C50:  ADDWF  xB4,F
05C52:  MOVLW  00
05C54:  ADDWFC xB5,F
....................          set_charge_duty(global_charge_duty); 
05C56:  MOVFF  B5,557
05C5A:  MOVFF  B4,556
05C5E:  CALL   3F78
....................       } 
....................       control_loop_cycles_to_next_update = 1; 
05C62:  MOVLW  01
05C64:  MOVLB  5
05C66:  MOVWF  x3F
....................       break; 
05C68:  MOVLB  0
05C6A:  BRA    5DA6
....................    case NO_SPIN_RECOVERY: 
....................       // it's fixed! 
....................       // RPM is above the limit (10), RPM is not MAX (for decoupled condition) and valve is moving. 
....................       if ((global_current_rpm > NOT_SPINNING_MAG_DECOUPLING_RPM_FIXED) && (global_current_rpm !=(0-1)) && (!IS_VLV_COASTING)) 
05C6C:  MOVF   xAB,F
05C6E:  BNZ   5C7A
05C70:  MOVF   xAA,W
05C72:  MOVLB  5
05C74:  SUBWF  x1C,W
05C76:  BC    5CB4
05C78:  MOVLB  0
05C7A:  INCFSZ xAA,W
05C7C:  BRA    5C88
05C7E:  INCFSZ xAB,W
05C80:  BRA    5C88
05C82:  MOVLB  5
05C84:  BRA    5CB4
05C86:  MOVLB  0
05C88:  MOVF   F8D,F
05C8A:  BTFSS  FD8.2
05C8C:  BRA    5C92
05C8E:  MOVLB  5
05C90:  BRA    5CB4
....................       { 
....................          //stop the valve movement 
....................          disable_interrupts(INT_CCP3); 
05C92:  BCF    F7A.0
....................          global_valve_position_set_value = global_valve_position; 
05C94:  MOVFF  C2,C4
05C98:  MOVFF  C1,C3
....................          enable_interrupts(INT_CCP3); 
05C9C:  BSF    F7A.0
....................          // change control loop back to a normal mode 
....................          global_control_loop_mechanism = BRAKE_AND_CHARGE_START; 
05C9E:  CLRF   xC0
....................          // send a valve report to let people know of the new position 
....................          PUSH_MESSAGE_QUEUE_MACRO(MSG_MOTE_VALVE_REPORT); 
05CA0:  BCF    F7A.1
05CA2:  MOVLW  92
05CA4:  MOVLB  5
05CA6:  MOVWF  x54
05CA8:  MOVLB  0
05CAA:  CALL   51F6
05CAE:  BSF    F7A.1
....................       } 
05CB0:  BRA    5D02
05CB2:  MOVLB  5
....................       // KINDA MESSY, FIX THIS LATER 
....................       // if the valve is within 5% of valve range (~2 seconds) of the position it's going, 
....................       //    control loop update position is slowed to 100x64ms or 6.4 seconds to give it time to react  
....................       else if ((!IS_VLV_COASTING) && ((global_valve_position_set_value - global_valve_position) < 0x0400)) 
05CB4:  MOVF   F8D,F
05CB6:  BZ    5CD6
05CB8:  MOVLB  0
05CBA:  MOVF   xC1,W
05CBC:  SUBWF  xC3,W
05CBE:  MOVLB  5
05CC0:  MOVWF  x54
05CC2:  MOVLB  0
05CC4:  MOVF   xC2,W
05CC6:  SUBWFB xC4,W
05CC8:  MOVLB  5
05CCA:  MOVWF  x55
05CCC:  SUBLW  03
05CCE:  BNC   5CD6
....................       { 
....................          control_loop_cycles_to_next_update = 100; 
05CD0:  MOVLW  64
05CD2:  MOVWF  x3F
....................       } 
05CD4:  BRA    5D04
....................       // it tried to move the valve a bunch and it didn't fix it :-/ 
....................       else if (IS_VLV_COASTING) 
05CD6:  MOVF   F8D,F
05CD8:  BNZ   5D04
....................       { 
....................          // set an error bit saying there isn't any spinning 
....................          global_error_message_bitfield |= ERR_MSG_MAG_NOT_SPIN_RECOVERY_FAILED; 
05CDA:  MOVLB  4
05CDC:  BSF    xF9.5
....................          // send error message to manager 
....................          PUSH_MESSAGE_QUEUE_MACRO(MSG_MOTE_ERROR_MSG); 
05CDE:  BCF    F7A.1
05CE0:  MOVLW  A0
05CE2:  MOVLB  5
05CE4:  MOVWF  x54
05CE6:  MOVLB  0
05CE8:  CALL   51F6
05CEC:  BSF    F7A.1
....................          // stop the current sprinkler setting (also closes valve) and clear the queue 
....................          stop_current_spinkler_setting(); 
05CEE:  RCALL  5578
....................          clear_sprinkler_queue(); 
05CF0:  RCALL  55B2
....................          // send a valve report to let people know of the new position 
....................          PUSH_MESSAGE_QUEUE_MACRO(MSG_MOTE_VALVE_REPORT); 
05CF2:  BCF    F7A.1
05CF4:  MOVLW  92
05CF6:  MOVLB  5
05CF8:  MOVWF  x54
05CFA:  MOVLB  0
05CFC:  CALL   51F6
05D00:  BSF    F7A.1
05D02:  MOVLB  5
....................       } 
....................       break; 
05D04:  MOVLB  0
05D06:  BRA    5DA6
....................    case MAG_DECOUPLING_RECOVERY: 
....................       // it's fixed! 
....................       // RPM is above the limit (10), RPM is not MAX (for decoupled condition) and valve is moving. 
....................       if ((global_current_rpm > NOT_SPINNING_MAG_DECOUPLING_RPM_FIXED) && (global_current_rpm !=(0-1)) && (!IS_VLV_COASTING)) 
05D08:  MOVF   xAB,F
05D0A:  BNZ   5D16
05D0C:  MOVF   xAA,W
05D0E:  MOVLB  5
05D10:  SUBWF  x1C,W
05D12:  BC    5D52
05D14:  MOVLB  0
05D16:  INCFSZ xAA,W
05D18:  BRA    5D24
05D1A:  INCFSZ xAB,W
05D1C:  BRA    5D24
05D1E:  MOVLB  5
05D20:  BRA    5D52
05D22:  MOVLB  0
05D24:  MOVF   F8D,F
05D26:  BTFSS  FD8.2
05D28:  BRA    5D2E
05D2A:  MOVLB  5
05D2C:  BRA    5D52
....................       { 
....................          //stop the valve movement 
....................          disable_interrupts(INT_CCP3); 
05D2E:  BCF    F7A.0
....................          global_valve_position_set_value = global_valve_position; 
05D30:  MOVFF  C2,C4
05D34:  MOVFF  C1,C3
....................          enable_interrupts(INT_CCP3); 
05D38:  BSF    F7A.0
....................          // change control loop back to a normal mode 
....................          global_control_loop_mechanism = BRAKE_AND_CHARGE_START; 
05D3A:  CLRF   xC0
....................          // send a valve report to let people know of the new position 
....................          PUSH_MESSAGE_QUEUE_MACRO(MSG_MOTE_VALVE_REPORT); 
05D3C:  BCF    F7A.1
05D3E:  MOVLW  92
05D40:  MOVLB  5
05D42:  MOVWF  x54
05D44:  MOVLB  0
05D46:  CALL   51F6
05D4A:  BSF    F7A.1
....................          // put the control algorithm into a non-rpm controlled state (sort of an idle state) 
....................          global_control_loop_mechanism = BRAKE_AND_CHARGE_START; 
05D4C:  CLRF   xC0
....................       } 
05D4E:  BRA    5DA2
05D50:  MOVLB  5
....................       // KINDA MESSY, FIX THIS LATER 
....................       // if the valve is within 5% of valve range (~2 seconds) of the position it's going, 
....................       //    control loop update position is slowed to 100x64ms or 6.4 seconds to give it time to react  
....................       else if ((!IS_VLV_COASTING) && ((global_valve_position - global_valve_position_set_value) < 0x0400)) 
05D52:  MOVF   F8D,F
05D54:  BZ    5D74
05D56:  MOVLB  0
05D58:  MOVF   xC3,W
05D5A:  SUBWF  xC1,W
05D5C:  MOVLB  5
05D5E:  MOVWF  x54
05D60:  MOVLB  0
05D62:  MOVF   xC4,W
05D64:  SUBWFB xC2,W
05D66:  MOVLB  5
05D68:  MOVWF  x55
05D6A:  SUBLW  03
05D6C:  BNC   5D74
....................       { 
....................          control_loop_cycles_to_next_update = 100; 
05D6E:  MOVLW  64
05D70:  MOVWF  x3F
....................       } 
05D72:  BRA    5DA4
....................       // it tried to move the valve a bunch and it didn't fix it :-/ 
....................       else if (IS_VLV_COASTING) 
05D74:  MOVF   F8D,F
05D76:  BNZ   5DA4
....................       { 
....................          // set an error bit saying there isn't any spinning 
....................          global_error_message_bitfield |= ERR_MSG_MAG_NOT_SPIN_RECOVERY_FAILED; 
05D78:  MOVLB  4
05D7A:  BSF    xF9.5
....................          // send error message to manager 
....................          PUSH_MESSAGE_QUEUE_MACRO(MSG_MOTE_ERROR_MSG); 
05D7C:  BCF    F7A.1
05D7E:  MOVLW  A0
05D80:  MOVLB  5
05D82:  MOVWF  x54
05D84:  MOVLB  0
05D86:  CALL   51F6
05D8A:  BSF    F7A.1
....................          // stop the current sprinkler setting (also closes valve) and clear the queue 
....................          stop_current_spinkler_setting(); 
05D8C:  CALL   5578
....................          clear_sprinkler_queue(); 
05D90:  RCALL  55B2
....................          // send a valve report to let people know of the new position 
....................          PUSH_MESSAGE_QUEUE_MACRO(MSG_MOTE_VALVE_REPORT); 
05D92:  BCF    F7A.1
05D94:  MOVLW  92
05D96:  MOVLB  5
05D98:  MOVWF  x54
05D9A:  MOVLB  0
05D9C:  CALL   51F6
05DA0:  BSF    F7A.1
05DA2:  MOVLB  5
....................       } 
....................       break; 
05DA4:  MOVLB  0
05DA6:  MOVLB  5
....................    }      
....................    return; 
05DA8:  MOVLB  0
05DAA:  GOTO   A5DE (RETURN)
.................... } 
....................  
.................... void stop_current_spinkler_setting(void) 
.................... { 
....................    global_current_sprinkler_settings_end_time = 0-1; 
*
05578:  SETF   00
0557A:  SETF   01
0557C:  SETF   02
0557E:  SETF   03
05580:  MOVFF  03,42D
05584:  MOVFF  02,42C
05588:  MOVFF  01,42B
0558C:  MOVFF  00,42A
05590:  CLRF   19
05592:  BTFSC  FF2.7
05594:  BSF    19.7
05596:  BCF    FF2.7
....................    PUSH_PRIORITY_QUEUE_ISR(OPEN_VALVE_UNKNOWN_STATE); 
05598:  MOVLW  3E
0559A:  MOVLB  6
0559C:  MOVWF  x2C
0559E:  MOVLB  0
055A0:  CALL   082A
055A4:  BTFSC  19.7
055A6:  BSF    FF2.7
....................    global_rpm_set_value = 0; 
055A8:  CLRF   xAD
055AA:  CLRF   xAC
....................    //global_sprinkler_queue[global_current_sprinkler_queue_location].zone_num; 
....................    global_control_loop_mechanism = NO_RPM_CONTROL; 
055AC:  MOVLW  05
055AE:  MOVWF  xC0
055B0:  RETURN 0
.................... } 
.................... void stop_current_spinkler_setting_ISR(void) 
.................... { 
....................    global_current_sprinkler_settings_end_time = 0-1; 
*
02E48:  SETF   00
02E4A:  SETF   01
02E4C:  SETF   02
02E4E:  SETF   03
02E50:  MOVFF  03,42D
02E54:  MOVFF  02,42C
02E58:  MOVFF  01,42B
02E5C:  MOVFF  00,42A
02E60:  CLRF   19
02E62:  BTFSC  FF2.7
02E64:  BSF    19.7
02E66:  BCF    FF2.7
....................    PUSH_PRIORITY_QUEUE_ISR_MACRO(OPEN_VALVE_UNKNOWN_STATE);           
02E68:  MOVLW  3E
02E6A:  MOVLB  6
02E6C:  MOVWF  x2C
02E6E:  MOVLB  0
02E70:  CALL   082A
02E74:  BTFSC  19.7
02E76:  BSF    FF2.7
....................    global_rpm_set_value = 0; 
02E78:  CLRF   xAD
02E7A:  CLRF   xAC
....................    //global_sprinkler_queue[global_current_sprinkler_queue_location].zone_num; 
....................    global_control_loop_mechanism = NO_RPM_CONTROL; 
02E7C:  MOVLW  05
02E7E:  MOVWF  xC0
02E80:  GOTO   312A (RETURN)
.................... }                                                         
....................  
.................... #include "valve.h"        
.................... void  comparator_setup(void) 
.................... { 
.................... // Sets up and enables the comparator for current limit detection when moving 
.................... //    valve 
....................     
....................    // turns off comparator 
....................    setup_comparator(NC_NC_NC_NC); 
*
0842A:  CLRF   F77
0842C:  MOVLW  04
0842E:  MOVWF  F78
08430:  MOVWF  F79
....................     
....................    // Sets up the DAC for a range of VDD-VSS 
....................    setup_DAC(DAC_VSS_VDD); 
08432:  MOVLW  80
08434:  MOVLB  F
08436:  MOVWF  x41
....................     
....................    // sets up an appropriate dac level depending on movement direction and  
....................    //    valve position 
....................    set_comp_dac_level(); 
08438:  MOVLB  0
0843A:  BRA    82EC
....................     
....................    // delay for comparator to setup? 
....................    delay_cycles(5); 
0843C:  BRA    843E
0843E:  BRA    8440
08440:  NOP   
....................     
....................    // CP1 compares VLV_I at its neg input to the DAC output 
....................    // CP2 off at power up and stays off 
....................    setup_comparator(CP1_A1_DAC); 
08442:  CLRF   F77
08444:  CLRF   F78
08446:  MOVLW  85
08448:  MOVWF  F79
0844A:  MOVF   F92,W
0844C:  IORLW  02
0844E:  MOVWF  F92
08450:  MOVF   F93,W
....................                                      
....................    // clear the comparator interrupt and enable it 
....................    clear_interrupt(INT_COMP); 
08452:  BCF    FA1.6
....................    enable_interrupts(INT_COMP); 
08454:  BSF    FA0.6
08456:  RETURN 0
.................... } 
....................  
....................  
.................... uint16_t calc_valve_movement_time(uint16_t current_location, uint16_t destination) 
.................... { 
.................... // calculates the amount of time it takes to make the move from  
.................... //    current location to destination and returns it in seconds (7.9 format) 
....................  
....................    uint32_t temp_u32; 
....................     
....................    // if valve is going to open 
....................    if (current_location < destination) 
....................    { 
....................       temp_u32 = ((uint32_t)(destination - current_location) * (uint32_t)(global_valve_time_to_open_1024th));  
....................    }   
....................    // if valve is going to close or not move at all 
....................    else if (current_location >= destination) 
....................    { 
....................       temp_u32 = ((uint32_t)(current_location - destination) * (uint32_t)(global_valve_time_to_close_1024th));  
....................    }   
....................     
....................    // now 8.24 format; convert to 16 bit 7.9 format (seconds) 
....................    if (bit_test(temp_u32,14)) 
....................    { 
....................       temp_u32 += 0x8000; 
....................    } 
....................    // return the time in 7.9 format (seconds) 
....................    return(uint16_t)(temp_u32 >> 15); 
.................... } 
....................  
.................... void set_comp_dac_level(void) 
.................... { 
.................... // sets the dac level for the comparator for different situations/vlv positions 
....................  
....................    // if valve is just begining to move and outside of the "almost close/opened" 
....................    //    regime.  DAC level is lowered to allow for more current draw. 
....................    if ((global_valve_time_in_motion_1024ths <= VLV_INIT_CURRENT_BOOST_TIME_1024THS)    \ 
....................       && (!(global_valve_position < VLV_NEAR_CLOSED_RANGE_MAX)) &&                     \ 
....................       (!(global_valve_position > VLV_NEAR_OPENED_RANGE_MAX))) 
*
082EC:  MOVF   xCA,W
082EE:  MOVLB  5
082F0:  SUBWF  x17,W
082F2:  BNC   833C
082F4:  BNZ   8300
082F6:  MOVLB  0
082F8:  MOVF   xC9,W
082FA:  MOVLB  5
082FC:  SUBWF  x16,W
082FE:  BNC   833C
08300:  MOVLB  0
08302:  MOVF   xC2,W
08304:  MOVLB  5
08306:  SUBWF  x07,W
08308:  BNC   831C
0830A:  BNZ   833C
0830C:  MOVF   x06,W
0830E:  MOVLB  0
08310:  SUBWF  xC1,W
08312:  BTFSC  FD8.0
08314:  BRA    831A
08316:  MOVLB  5
08318:  BRA    833C
0831A:  MOVLB  5
0831C:  MOVF   x09,W
0831E:  MOVLB  0
08320:  SUBWF  xC2,W
08322:  BNC   8336
08324:  BTFSC  FD8.2
08326:  BRA    832C
08328:  MOVLB  5
0832A:  BRA    833C
0832C:  MOVF   xC1,W
0832E:  MOVLB  5
08330:  SUBWF  x08,W
08332:  BNC   833C
08334:  MOVLB  0
....................    { 
....................       dac_write(DAC_LVL_INIT_CURRENT_BOOST); 
08336:  MOVFF  514,F40
....................    } 
0833A:  BRA    8422
....................     
....................    // initial valve open (for a few seconds) 
....................    else if (read_system_state() == SYSTEM_CAL_VLV_1) 
0833C:  MOVLB  0
0833E:  CALL   1F4A
08342:  MOVF   01,W
08344:  SUBLW  10
08346:  BNZ   834E
....................    { 
....................       dac_write(DAC_LVL_IN_MIDDLE); 
08348:  MOVFF  512,F40
....................    } 
0834C:  BRA    8422
....................     
....................    // inital valve close (don't know where we are exactly) 
....................    else if (read_system_state() == SYSTEM_CAL_VLV_2) 
0834E:  CALL   1F4A
08352:  MOVF   01,W
08354:  SUBLW  11
08356:  BNZ   8380
....................    { 
....................       // normally, during this state, the valve position should be unknown 
....................  
....................       // if the valve is almost (or fully) open after the inital open push aka 
....................       //    it hit the open endstop 
....................       if (global_valve_position > VLV_NEAR_OPENED_RANGE_MAX) 
08358:  MOVLB  5
0835A:  MOVF   x09,W
0835C:  MOVLB  0
0835E:  SUBWF  xC2,W
08360:  BNC   837A
08362:  BNZ   8374
08364:  MOVF   xC1,W
08366:  MOVLB  5
08368:  SUBWF  x08,W
0836A:  BTFSS  FD8.0
0836C:  BRA    8372
0836E:  MOVLB  0
08370:  BRA    837A
08372:  MOVLB  0
....................       { 
....................          dac_write(DAC_LVL_CLOSING_NEAR_OPENED); 
08374:  MOVFF  50E,F40
....................       } 
08378:  BRA    837E
....................       // otherwise, position is unknown and will be assumed to be closing near 
....................       //    the closed endstop.  DAC level will be set as such to get a  
....................       //    consistent calibration 
....................       else 
....................       { 
....................          dac_write(DAC_LVL_CLOSING_NEAR_CLOSED); 
0837A:  MOVFF  510,F40
....................       } 
....................    } 
0837E:  BRA    8422
....................     
....................    // valve closing 
....................    else if (IS_VLV_CLOSING) 
08380:  DECFSZ F8D,W
08382:  BRA    83CE
....................    { 
....................       // valve is almost closed (or closed) and closing 
....................       if (global_valve_position < VLV_NEAR_CLOSED_RANGE_MAX) 
08384:  MOVF   xC2,W
08386:  MOVLB  5
08388:  SUBWF  x07,W
0838A:  BNC   83A4
0838C:  BNZ   839E
0838E:  MOVF   x06,W
08390:  MOVLB  0
08392:  SUBWF  xC1,W
08394:  BTFSS  FD8.0
08396:  BRA    839C
08398:  MOVLB  5
0839A:  BRA    83A4
0839C:  MOVLB  5
....................       { 
....................          dac_write(DAC_LVL_CLOSING_NEAR_CLOSED); 
0839E:  MOVFF  510,F40
....................       } 
083A2:  BRA    83CA
....................       // valve is almost open (or open) and closing 
....................       else if (global_valve_position > VLV_NEAR_OPENED_RANGE_MAX) 
083A4:  MOVF   x09,W
083A6:  MOVLB  0
083A8:  SUBWF  xC2,W
083AA:  BNC   83C4
083AC:  BNZ   83BE
083AE:  MOVF   xC1,W
083B0:  MOVLB  5
083B2:  SUBWF  x08,W
083B4:  BTFSS  FD8.0
083B6:  BRA    83BC
083B8:  MOVLB  0
083BA:  BRA    83C4
083BC:  MOVLB  0
....................       { 
....................          dac_write(DAC_LVL_CLOSING_NEAR_OPENED); 
083BE:  MOVFF  50E,F40
....................       } 
083C2:  BRA    83C8
....................       // valve is in the middle somewhere 
....................       else 
....................       { 
....................          dac_write(DAC_LVL_IN_MIDDLE); 
083C4:  MOVFF  512,F40
083C8:  MOVLB  5
....................       } 
....................    } 
083CA:  BRA    8424
083CC:  MOVLB  0
....................     
....................    // valve opening 
....................    else if (IS_VLV_OPENING) 
083CE:  MOVF   F8D,W
083D0:  SUBLW  02
083D2:  BNZ   841E
....................    { 
....................       // valve is almost closed (or closed) and opening 
....................       if (global_valve_position < VLV_NEAR_CLOSED_RANGE_MAX) 
083D4:  MOVF   xC2,W
083D6:  MOVLB  5
083D8:  SUBWF  x07,W
083DA:  BNC   83F4
083DC:  BNZ   83EE
083DE:  MOVF   x06,W
083E0:  MOVLB  0
083E2:  SUBWF  xC1,W
083E4:  BTFSS  FD8.0
083E6:  BRA    83EC
083E8:  MOVLB  5
083EA:  BRA    83F4
083EC:  MOVLB  5
....................       { 
....................          dac_write(DAC_LVL_OPENING_NEAR_CLOSED); 
083EE:  MOVFF  50C,F40
....................       } 
083F2:  BRA    841A
....................       // valve is almost open (or open) and opening 
....................       else if (global_valve_position > VLV_NEAR_OPENED_RANGE_MAX) 
083F4:  MOVF   x09,W
083F6:  MOVLB  0
083F8:  SUBWF  xC2,W
083FA:  BNC   8414
083FC:  BNZ   840E
083FE:  MOVF   xC1,W
08400:  MOVLB  5
08402:  SUBWF  x08,W
08404:  BTFSS  FD8.0
08406:  BRA    840C
08408:  MOVLB  0
0840A:  BRA    8414
0840C:  MOVLB  0
....................       { 
....................          dac_write(DAC_LVL_OPENING_NEAR_OPENED); 
0840E:  MOVFF  50A,F40
....................       } 
08412:  BRA    8418
....................       // valve is in the middle somewhere 
....................       else 
....................       { 
....................          dac_write(DAC_LVL_IN_MIDDLE); 
08414:  MOVFF  512,F40
08418:  MOVLB  5
....................       } 
....................    } 
0841A:  BRA    8424
0841C:  MOVLB  0
....................     
....................    // other cases (like if this accidentally gets called before valve is 
....................    //    actually moving, although it should get picked up by the initial  
....................    //    boost case 
....................    else 
....................    { 
....................       dac_write(DAC_LVL_IN_MIDDLE); 
0841E:  MOVFF  512,F40
08422:  MOVLB  5
....................    } 
08424:  MOVLB  0
08426:  GOTO   843C (RETURN)
.................... } 
....................  
....................  
.................... void set_comp_dac_level_ISR(void) 
.................... { 
.................... // sets the dac level for the comparator for different situations/vlv positions 
....................  
....................    // if valve is just begining to move and outside of the "almost close/opened" 
....................    //    regime.  DAC level is lowered to allow for more current draw. 
....................    if ((global_valve_time_in_motion_1024ths <= VLV_INIT_CURRENT_BOOST_TIME_1024THS) \ 
....................       && (!(global_valve_position < VLV_NEAR_CLOSED_RANGE_MAX)) &&            \ 
....................       (!(global_valve_position > VLV_NEAR_OPENED_RANGE_MAX))) 
*
01F54:  MOVF   xCA,W
01F56:  MOVLB  5
01F58:  SUBWF  x17,W
01F5A:  BNC   1FA4
01F5C:  BNZ   1F68
01F5E:  MOVLB  0
01F60:  MOVF   xC9,W
01F62:  MOVLB  5
01F64:  SUBWF  x16,W
01F66:  BNC   1FA4
01F68:  MOVLB  0
01F6A:  MOVF   xC2,W
01F6C:  MOVLB  5
01F6E:  SUBWF  x07,W
01F70:  BNC   1F84
01F72:  BNZ   1FA4
01F74:  MOVF   x06,W
01F76:  MOVLB  0
01F78:  SUBWF  xC1,W
01F7A:  BTFSC  FD8.0
01F7C:  BRA    1F82
01F7E:  MOVLB  5
01F80:  BRA    1FA4
01F82:  MOVLB  5
01F84:  MOVF   x09,W
01F86:  MOVLB  0
01F88:  SUBWF  xC2,W
01F8A:  BNC   1F9E
01F8C:  BTFSC  FD8.2
01F8E:  BRA    1F94
01F90:  MOVLB  5
01F92:  BRA    1FA4
01F94:  MOVF   xC1,W
01F96:  MOVLB  5
01F98:  SUBWF  x08,W
01F9A:  BNC   1FA4
01F9C:  MOVLB  0
....................    { 
....................       dac_write(DAC_LVL_INIT_CURRENT_BOOST); 
01F9E:  MOVFF  514,F40
....................    } 
01FA2:  BRA    2086
....................     
....................    // initial valve open (for a few seconds) 
....................    else if (read_system_state() == SYSTEM_CAL_VLV_1) 
01FA4:  MOVLB  0
01FA6:  RCALL  1F4A
01FA8:  MOVF   01,W
01FAA:  SUBLW  10
01FAC:  BNZ   1FB4
....................    { 
....................       dac_write(DAC_LVL_IN_MIDDLE); 
01FAE:  MOVFF  512,F40
....................    } 
01FB2:  BRA    2086
....................     
....................    // inital valve close (don't know where we are exactly) 
....................    else if (read_system_state() == SYSTEM_CAL_VLV_2) 
01FB4:  RCALL  1F4A
01FB6:  MOVF   01,W
01FB8:  SUBLW  11
01FBA:  BNZ   1FE4
....................    { 
....................       // normally, during this state, the valve position should be unknown 
....................  
....................       // if the valve is almost (or fully) open after the inital open push aka 
....................       //    it hit the open endstop 
....................       if (global_valve_position > VLV_NEAR_OPENED_RANGE_MAX) 
01FBC:  MOVLB  5
01FBE:  MOVF   x09,W
01FC0:  MOVLB  0
01FC2:  SUBWF  xC2,W
01FC4:  BNC   1FDE
01FC6:  BNZ   1FD8
01FC8:  MOVF   xC1,W
01FCA:  MOVLB  5
01FCC:  SUBWF  x08,W
01FCE:  BTFSS  FD8.0
01FD0:  BRA    1FD6
01FD2:  MOVLB  0
01FD4:  BRA    1FDE
01FD6:  MOVLB  0
....................       { 
....................          dac_write(DAC_LVL_CLOSING_NEAR_OPENED); 
01FD8:  MOVFF  50E,F40
....................       } 
01FDC:  BRA    1FE2
....................       // otherwise, position is unknown and will be assumed to be closing near 
....................       //    the closed endstop.  DAC level will be set as such to get a  
....................       //    consistent calibration 
....................       else 
....................       { 
....................          dac_write(DAC_LVL_CLOSING_NEAR_CLOSED); 
01FDE:  MOVFF  510,F40
....................       } 
....................    } 
01FE2:  BRA    2086
....................     
....................    // valve closing 
....................    else if (IS_VLV_CLOSING) 
01FE4:  DECFSZ F8D,W
01FE6:  BRA    2032
....................    { 
....................       // valve is almost closed (or closed) and closing 
....................       if (global_valve_position < VLV_NEAR_CLOSED_RANGE_MAX) 
01FE8:  MOVF   xC2,W
01FEA:  MOVLB  5
01FEC:  SUBWF  x07,W
01FEE:  BNC   2008
01FF0:  BNZ   2002
01FF2:  MOVF   x06,W
01FF4:  MOVLB  0
01FF6:  SUBWF  xC1,W
01FF8:  BTFSS  FD8.0
01FFA:  BRA    2000
01FFC:  MOVLB  5
01FFE:  BRA    2008
02000:  MOVLB  5
....................       { 
....................          dac_write(DAC_LVL_CLOSING_NEAR_CLOSED); 
02002:  MOVFF  510,F40
....................       } 
02006:  BRA    202E
....................       // valve is almost open (or open) and closing 
....................       else if (global_valve_position > VLV_NEAR_OPENED_RANGE_MAX) 
02008:  MOVF   x09,W
0200A:  MOVLB  0
0200C:  SUBWF  xC2,W
0200E:  BNC   2028
02010:  BNZ   2022
02012:  MOVF   xC1,W
02014:  MOVLB  5
02016:  SUBWF  x08,W
02018:  BTFSS  FD8.0
0201A:  BRA    2020
0201C:  MOVLB  0
0201E:  BRA    2028
02020:  MOVLB  0
....................       { 
....................          dac_write(DAC_LVL_CLOSING_NEAR_OPENED); 
02022:  MOVFF  50E,F40
....................       } 
02026:  BRA    202C
....................       // valve is in the middle somewhere 
....................       else 
....................       { 
....................          dac_write(DAC_LVL_IN_MIDDLE); 
02028:  MOVFF  512,F40
0202C:  MOVLB  5
....................       } 
....................    } 
0202E:  BRA    2088
02030:  MOVLB  0
....................     
....................    // valve opening 
....................    else if (IS_VLV_OPENING) 
02032:  MOVF   F8D,W
02034:  SUBLW  02
02036:  BNZ   2082
....................    { 
....................       // valve is almost closed (or closed) and opening 
....................       if (global_valve_position < VLV_NEAR_CLOSED_RANGE_MAX) 
02038:  MOVF   xC2,W
0203A:  MOVLB  5
0203C:  SUBWF  x07,W
0203E:  BNC   2058
02040:  BNZ   2052
02042:  MOVF   x06,W
02044:  MOVLB  0
02046:  SUBWF  xC1,W
02048:  BTFSS  FD8.0
0204A:  BRA    2050
0204C:  MOVLB  5
0204E:  BRA    2058
02050:  MOVLB  5
....................       { 
....................          dac_write(DAC_LVL_OPENING_NEAR_CLOSED); 
02052:  MOVFF  50C,F40
....................       } 
02056:  BRA    207E
....................       // valve is almost open (or open) and opening 
....................       else if (global_valve_position > VLV_NEAR_OPENED_RANGE_MAX) 
02058:  MOVF   x09,W
0205A:  MOVLB  0
0205C:  SUBWF  xC2,W
0205E:  BNC   2078
02060:  BNZ   2072
02062:  MOVF   xC1,W
02064:  MOVLB  5
02066:  SUBWF  x08,W
02068:  BTFSS  FD8.0
0206A:  BRA    2070
0206C:  MOVLB  0
0206E:  BRA    2078
02070:  MOVLB  0
....................       { 
....................          dac_write(DAC_LVL_OPENING_NEAR_OPENED); 
02072:  MOVFF  50A,F40
....................       } 
02076:  BRA    207C
....................       // valve is in the middle somewhere 
....................       else 
....................       { 
....................          dac_write(DAC_LVL_IN_MIDDLE); 
02078:  MOVFF  512,F40
0207C:  MOVLB  5
....................       } 
....................    } 
0207E:  BRA    2088
02080:  MOVLB  0
....................     
....................    // other cases (like if this accidentally gets called before valve is 
....................    //    actually moving, although it should get picked up by the initial  
....................    //    boost case 
....................    else 
....................    { 
....................       dac_write(DAC_LVL_IN_MIDDLE); 
02082:  MOVFF  512,F40
02086:  MOVLB  5
....................    } 
02088:  MOVLB  0
0208A:  GOTO   220A (RETURN)
.................... } 
....................  
.................... int1 is_valve_position_valid(uint16_t value) 
.................... // returns true if valid range for valve 
.................... { 
....................    if (value > VLV_POSITION_OPENED) return FALSE; 
*
06954:  MOVLB  5
06956:  MOVF   x55,W
06958:  SUBLW  7F
0695A:  BC    696E
0695C:  XORLW  FF
0695E:  BNZ   6966
06960:  MOVF   x54,W
06962:  SUBLW  00
06964:  BC    696E
06966:  MOVLW  00
06968:  MOVWF  01
0696A:  BRA    6972
0696C:  BRA    6972
....................    else if ((value < VLV_POSITION_CLOSED) && (VLV_POSITION_CLOSED != 0)) return FALSE; 
....................    else return TRUE; 
0696E:  MOVLW  01
06970:  MOVWF  01
06972:  MOVLB  0
06974:  RETURN 0
.................... } 
....................  
.................... int1 is_valve_value_full_open_or_close(uint16_t value) 
.................... // return true if valve is either full open or vull close 
.................... { 
....................    if ((value == VLV_POSITION_OPENED) || (value == VLV_POSITION_CLOSED))  
*
072AE:  MOVLB  5
072B0:  MOVF   x54,F
072B2:  BNZ   72BA
072B4:  MOVF   x55,W
072B6:  SUBLW  80
072B8:  BZ    72C2
072BA:  MOVF   x54,F
072BC:  BNZ   72CA
072BE:  MOVF   x55,F
072C0:  BNZ   72CA
....................       return TRUE; 
072C2:  MOVLW  01
072C4:  MOVWF  01
072C6:  BRA    72CE
072C8:  BRA    72CE
....................    else return FALSE; 
072CA:  MOVLW  00
072CC:  MOVWF  01
072CE:  MOVLB  0
072D0:  RETURN 0
.................... } 
....................  
.................... #include "battery.h"                                                           
.................... // JG 
.................... uint16_t get_vbatt(int1 charge_state) 
*
042B4:  MOVLB  5
042B6:  CLRF   x6D
042B8:  CLRF   x6C
.................... { 
....................    /* Samples the V_EXT_REF to get the battery voltage 
....................     * and returns a uint16_t of the sum of 4 samples 
....................     * charge_state defines if you want the LTC3105 to be: 
....................     * 0 - original state 
....................     * 1 - not charging 
....................     */ 
....................                                                           
....................    uint8_t nn; 
....................    uint16_t v_batt_value = 0; 
....................    int1     tmp_RB3; 
....................    uint8_t  tmp_ccp2con; 
....................     
....................    // save state of RB3, which includes the LTC3105_CTRL line 
....................    tmp_ccp2con = CCP2CON;        
042BA:  MOVFF  F66,56F
....................     
....................    // save state of CCP2, which controls charging aggressiveness 
....................    // note that CCP2 will have control of the pin unless it is OFF 
....................    tmp_RB3 = LTC3105_CTRL_pinstate;  
042BE:  BCF    x6E.0
042C0:  BTFSC  F8A.3
042C2:  BSF    x6E.0
....................     
....................    // turn on ADC 
....................    ADON = TRUE;          
042C4:  BSF    FC2.0
....................     
....................    // set adc to VREF 
....................    set_adc_channel(V_EXT_REF); 
042C6:  MOVLW  00
042C8:  MOVWF  01
042CA:  MOVF   FC2,W
042CC:  ANDLW  83
042CE:  IORWF  01,W
042D0:  MOVWF  FC2
....................     
....................    // alter the charge state if necessary 
....................    // charge state off 
....................    if (charge_state == 1) 
042D2:  DECFSZ x6A,W
042D4:  BRA    42DC
....................    { 
....................       setup_ccp2(CCP_OFF);    
042D6:  MOVLW  F0
042D8:  ANDWF  F66,F
....................       output_low(LTC3105_CTRL); 
042DA:  BCF    F8A.3
....................    } 
....................     
....................    // sum up 4 samples from the adc 
....................    for (nn=0; nn<4; nn++) 
042DC:  CLRF   x6B
042DE:  MOVF   x6B,W
042E0:  SUBLW  03
042E2:  BNC   42F6
....................    { 
....................       v_batt_value += read_adc(); 
042E4:  BSF    FC2.1
042E6:  BTFSC  FC2.1
042E8:  BRA    42E6
042EA:  MOVF   FC3,W
042EC:  ADDWF  x6C,F
042EE:  MOVF   FC4,W
042F0:  ADDWFC x6D,F
042F2:  INCF   x6B,F
042F4:  BRA    42DE
....................    } 
....................     
....................    // Now return charger to its previous state 
....................    LTC3105_CTRL_pinstate = tmp_RB3; 
042F6:  BCF    F8A.3
042F8:  BTFSC  x6E.0
042FA:  BSF    F8A.3
....................    CCP2CON = tmp_ccp2con; 
042FC:  MOVFF  56F,F66
....................     
....................    // turn off adc 
....................    ADON = FALSE; 
04300:  BCF    FC2.0
....................     
....................    // return the voltage 
....................    return v_batt_value; 
04302:  MOVFF  56C,01
04306:  MOVFF  56D,02
0430A:  MOVLB  0
0430C:  RETURN 0
.................... } 
....................  
.................... uint16_t get_vbatt_ISR(int1 charge_state) 
*
0243E:  MOVLB  6
02440:  CLRF   x0B
02442:  CLRF   x0A
.................... { 
....................    /* Samples the V_EXT_REF to get the battery voltage 
....................     * and returns a uint16_t of the sum of 4 samples 
....................     * charge_state defines if you want the LTC3105 to be: 
....................     * 0 - original state 
....................     * 1 - not charging 
....................     */ 
....................      
....................    uint8_t nn; 
....................    uint16_t v_batt_value = 0; 
....................    int1     tmp_RB3; 
....................    uint8_t  tmp_ccp2con; 
....................     
....................    // save state of RB3, which includes the LTC3105_CTRL line 
....................    tmp_ccp2con = CCP2CON; 
02444:  MOVFF  F66,60D
....................     
....................    // save state of CCP2, which controls charging aggressiveness 
....................    // note that CCP2 will have control of the pin unless it is OFF 
....................    tmp_RB3 = LTC3105_CTRL_pinstate;  
02448:  BCF    x0C.0
0244A:  BTFSC  F8A.3
0244C:  BSF    x0C.0
....................     
....................    // turn on ADC 
....................    ADON = TRUE;          
0244E:  BSF    FC2.0
....................     
....................    // set adc to VREF 
....................    set_adc_channel(V_EXT_REF); 
02450:  MOVLW  00
02452:  MOVWF  01
02454:  MOVF   FC2,W
02456:  ANDLW  83
02458:  IORWF  01,W
0245A:  MOVWF  FC2
....................     
....................    // alter the charge state if necessary 
....................    // charge state off 
....................    if (charge_state == 1) 
0245C:  DECFSZ x08,W
0245E:  BRA    2466
....................    { 
....................       setup_ccp2(CCP_OFF);    
02460:  MOVLW  F0
02462:  ANDWF  F66,F
....................       output_low(LTC3105_CTRL); 
02464:  BCF    F8A.3
....................    } 
....................     
....................    // sum up 4 samples from the adc 
....................    for (nn=0; nn<4; nn++) 
02466:  CLRF   x09
02468:  MOVF   x09,W
0246A:  SUBLW  03
0246C:  BNC   2480
....................    { 
....................       v_batt_value += read_adc(); 
0246E:  BSF    FC2.1
02470:  BTFSC  FC2.1
02472:  BRA    2470
02474:  MOVF   FC3,W
02476:  ADDWF  x0A,F
02478:  MOVF   FC4,W
0247A:  ADDWFC x0B,F
0247C:  INCF   x09,F
0247E:  BRA    2468
....................    } 
....................     
....................    // Now return charger to its previous state 
....................    LTC3105_CTRL_pinstate = tmp_RB3; 
02480:  BCF    F8A.3
02482:  BTFSC  x0C.0
02484:  BSF    F8A.3
....................    CCP2CON = tmp_ccp2con; 
02486:  MOVFF  60D,F66
....................     
....................    // turn off adc 
....................    ADON = FALSE; 
0248A:  BCF    FC2.0
....................     
....................    // return the voltage 
....................    return v_batt_value; 
0248C:  MOVFF  60A,01
02490:  MOVFF  60B,02
02494:  MOVLB  0
02496:  RETURN 0
.................... } 
....................  
.................... uint16_t get_vgen(int1 charge_state) 
*
0430E:  MOVLB  5
04310:  CLRF   x5A
04312:  CLRF   x59
.................... { 
....................    /* Samples the V_GEN to get the battery voltage 
....................     * and returns a uint16_t of the sum of 4 samples 
....................     * charge_state defines if you want the LTC3105 to be: 
....................     * 0 - original state 
....................     * 1 - not charging 
....................     */ 
....................      
....................    uint8_t nn; 
....................    uint16_t vgen_value = 0; 
....................    int1     tmp_RB3; 
....................    uint8_t  tmp_ccp2con; 
....................     
....................    // save state of RB3, which includes the LTC3105_CTRL line 
....................    tmp_ccp2con = CCP2CON; 
04314:  MOVFF  F66,55C
....................     
....................    // save state of CCP2, which controls charging aggressiveness 
....................    // note that CCP2 will have control of the pin unless it is OFF 
....................    tmp_RB3 = LTC3105_CTRL_pinstate;  
04318:  BCF    x5B.0
0431A:  BTFSC  F8A.3
0431C:  BSF    x5B.0
....................     
....................    // turn on ADC 
....................    ADON = TRUE;          
0431E:  BSF    FC2.0
....................     
....................    // set adc to VREF 
....................    set_adc_channel(V_GEN); 
04320:  MOVLW  30
04322:  MOVWF  01
04324:  MOVF   FC2,W
04326:  ANDLW  83
04328:  IORWF  01,W
0432A:  MOVWF  FC2
....................     
....................    // alter the charge state if necessary 
....................    // charge state off 
....................    if (charge_state == 1) 
0432C:  DECFSZ x57,W
0432E:  BRA    4336
....................    { 
....................       setup_ccp2(CCP_OFF);    
04330:  MOVLW  F0
04332:  ANDWF  F66,F
....................       output_low(LTC3105_CTRL); 
04334:  BCF    F8A.3
....................    } 
....................     
....................    // sum up 3 samples from the adc 
....................    for (nn=0; nn<3; nn++) 
04336:  CLRF   x58
04338:  MOVF   x58,W
0433A:  SUBLW  02
0433C:  BNC   4350
....................    { 
....................       vgen_value += read_adc(); 
0433E:  BSF    FC2.1
04340:  BTFSC  FC2.1
04342:  BRA    4340
04344:  MOVF   FC3,W
04346:  ADDWF  x59,F
04348:  MOVF   FC4,W
0434A:  ADDWFC x5A,F
0434C:  INCF   x58,F
0434E:  BRA    4338
....................    } 
....................     
....................    // Now return charger to its previous state 
....................    LTC3105_CTRL_pinstate = tmp_RB3; 
04350:  BCF    F8A.3
04352:  BTFSC  x5B.0
04354:  BSF    F8A.3
....................    CCP2CON = tmp_ccp2con; 
04356:  MOVFF  55C,F66
....................     
....................    // turn off adc 
....................    ADON = FALSE; 
0435A:  BCF    FC2.0
....................     
....................    // save vgen to global value 
....................    global_vgen = vgen_value; 
0435C:  MOVFF  55A,BD
04360:  MOVFF  559,BC
....................     
....................    // return the voltage 
....................    return vgen_value; 
04364:  MOVFF  559,01
04368:  MOVFF  55A,02
0436C:  MOVLB  0
0436E:  RETURN 0
.................... } 
....................  
.................... uint16_t get_vgen_ISR(int1 charge_state) 
.................... { 
....................    /* Samples the V_GEN to get the battery voltage 
....................     * and returns a uint16_t of the sum of 4 samples 
....................     * charge_state defines if you want the LTC3105 to be: 
....................     * 0 - original state 
....................     * 1 - not charging 
....................     */ 
....................      
....................    uint8_t nn; 
....................    uint16_t vgen_value = 0; 
....................    int1     tmp_RB3; 
....................    uint8_t  tmp_ccp2con; 
....................     
....................    // save state of RB3, which includes the LTC3105_CTRL line 
....................    tmp_ccp2con = CCP2CON; 
....................     
....................    // save state of CCP2, which controls charging aggressiveness 
....................    // note that CCP2 will have control of the pin unless it is OFF 
....................    tmp_RB3 = LTC3105_CTRL_pinstate;  
....................     
....................    // turn on ADC 
....................    ADON = TRUE;          
....................     
....................    // set adc to VREF 
....................    set_adc_channel(V_GEN); 
....................     
....................    // alter the charge state if necessary 
....................    // charge state off 
....................    if (charge_state == 1) 
....................    { 
....................       setup_ccp2(CCP_OFF);    
....................       output_low(LTC3105_CTRL); 
....................    } 
....................     
....................    // sum up 3 samples from the adc 
....................    for (nn=0; nn<3; nn++) 
....................    { 
....................       vgen_value += read_adc(); 
....................    } 
....................     
....................    // Now return charger to its previous state 
....................    LTC3105_CTRL_pinstate = tmp_RB3; 
....................    CCP2CON = tmp_ccp2con; 
....................     
....................    // turn off adc 
....................    ADON = FALSE; 
....................     
....................    // save vgen to global value 
....................    global_vgen = vgen_value; 
....................     
....................    // return the voltage 
....................    return vgen_value; 
.................... } 
....................  
.................... uint16_t calc_vbatt_BCD(uint16_t vref_count) 
.................... { 
....................    /* Takes the voltage count as an input (summed from ADC) 
....................     * and outputs the battery integer and fractional as a single uint32_t 
....................     * It's output is BCD as follows: 
....................     * volts (.) tenths hundredths thousandths 
....................    */ 
....................    uint8_t volts, tenths, hundredths, thousandths; 
....................  
....................    uint32_t tempo_u32, frac_part; 
....................    uint16_t tempo_u16;   
....................     
....................    uint16_t    bat_frac_part;    // in units of mV 
....................     
....................    tempo_u32 = VAL32_FVR_BAT/vref_count;   // = 1 count in volts in 12.20 format 
*
04B60:  MOVFF  55C,56E
04B64:  MOVFF  55B,56D
04B68:  RCALL  4818
04B6A:  MOVLW  9A
04B6C:  MOVLB  5
04B6E:  MOVWF  x70
04B70:  MOVLW  99
04B72:  MOVWF  x6F
04B74:  MOVLW  19
04B76:  MOVWF  x6E
04B78:  MOVLW  95
04B7A:  MOVWF  x6D
04B7C:  MOVFF  03,574
04B80:  MOVFF  02,573
04B84:  MOVFF  01,572
04B88:  MOVFF  00,571
04B8C:  MOVLB  0
04B8E:  RCALL  484E
04B90:  MOVFF  03,570
04B94:  MOVFF  02,56F
04B98:  MOVFF  01,56E
04B9C:  MOVFF  00,56D
04BA0:  RCALL  49AC
04BA2:  MOVFF  03,564
04BA6:  MOVFF  02,563
04BAA:  MOVFF  01,562
04BAE:  MOVFF  00,561
04BB2:  CLRF   19
04BB4:  BTFSC  FF2.7
04BB6:  BSF    19.7
04BB8:  BCF    FF2.7
....................    tempo_u32 *= 1023;                        // bat voltage in 12.20 format 
04BBA:  MOVFF  564,605
04BBE:  MOVFF  563,604
04BC2:  MOVFF  562,603
04BC6:  MOVFF  561,602
04BCA:  MOVLB  6
04BCC:  CLRF   x09
04BCE:  CLRF   x08
04BD0:  MOVLW  03
04BD2:  MOVWF  x07
04BD4:  SETF   x06
04BD6:  MOVLB  0
04BD8:  CALL   1A3C
04BDC:  BTFSC  19.7
04BDE:  BSF    FF2.7
04BE0:  MOVFF  03,564
04BE4:  MOVFF  02,563
04BE8:  MOVFF  01,562
04BEC:  MOVFF  00,561
....................    tempo_u16 = (uint16_t)(tempo_u32 >> 8); 
04BF0:  MOVFF  563,56A
04BF4:  MOVFF  562,569
....................                                              // bat voltage in 4.12 format 
....................    volts = (uint8_t)(tempo_u16 >> 12);       // 2 or 3.....    
04BF8:  MOVLB  5
04BFA:  SWAPF  x6A,W
04BFC:  MOVWF  02
04BFE:  MOVLW  0F
04C00:  ANDWF  02,F
04C02:  MOVFF  02,55D
....................     
....................    frac_part = (uint32_t)(tempo_u16 & 0x0fff); 
04C06:  MOVF   x6A,W
04C08:  ANDLW  0F
04C0A:  MOVFF  569,565
04C0E:  MOVWF  x66
04C10:  CLRF   x67
04C12:  CLRF   x68
04C14:  CLRF   19
04C16:  BTFSC  FF2.7
04C18:  BSF    19.7
04C1A:  BCF    FF2.7
....................                                        // one count of frac_part is 1/4096 volt 
....................                                        // no rounding, full resolution 
....................    tempo_u32 = (frac_part * 1000);     // We ignore the mV rounding issue 
04C1C:  MOVFF  568,605
04C20:  MOVFF  567,604
04C24:  MOVFF  566,603
04C28:  MOVFF  565,602
04C2C:  MOVLB  6
04C2E:  CLRF   x09
04C30:  CLRF   x08
04C32:  MOVLW  03
04C34:  MOVWF  x07
04C36:  MOVLW  E8
04C38:  MOVWF  x06
04C3A:  MOVLB  0
04C3C:  CALL   1A3C
04C40:  BTFSC  19.7
04C42:  BSF    FF2.7
04C44:  MOVFF  03,564
04C48:  MOVFF  02,563
04C4C:  MOVFF  01,562
04C50:  MOVFF  00,561
....................                                        //  cuz battery measurement doesn't 
....................                                        //  support even mV resolution 
....................    tempo_u32 >>= 12; 
04C54:  MOVLB  5
04C56:  MOVFF  562,561
04C5A:  MOVFF  563,562
04C5E:  MOVFF  564,563
04C62:  CLRF   x64
04C64:  RRCF   x64,F
04C66:  RRCF   x63,F
04C68:  RRCF   x62,F
04C6A:  RRCF   x61,F
04C6C:  RRCF   x64,F
04C6E:  RRCF   x63,F
04C70:  RRCF   x62,F
04C72:  RRCF   x61,F
04C74:  RRCF   x64,F
04C76:  RRCF   x63,F
04C78:  RRCF   x62,F
04C7A:  RRCF   x61,F
04C7C:  RRCF   x64,F
04C7E:  RRCF   x63,F
04C80:  RRCF   x62,F
04C82:  RRCF   x61,F
04C84:  MOVLW  0F
04C86:  ANDWF  x64,F
....................    tempo_u16 = (uint16_t)(tempo_u32); 
04C88:  MOVFF  562,56A
04C8C:  MOVFF  561,569
....................    tenths = tempo_u16/100; 
04C90:  MOVFF  56A,576
04C94:  MOVFF  569,575
04C98:  CLRF   x78
04C9A:  MOVLW  64
04C9C:  MOVWF  x77
04C9E:  MOVLB  0
04CA0:  CALL   4384
04CA4:  MOVFF  01,55E
....................    tempo_u16 -= (uint16_t)(tenths)*100; 
04CA8:  MOVLB  5
04CAA:  CLRF   x6E
04CAC:  MOVFF  55E,56D
04CB0:  MOVFF  56E,570
04CB4:  MOVFF  55E,56F
04CB8:  CLRF   x72
04CBA:  MOVLW  64
04CBC:  MOVWF  x71
04CBE:  MOVLB  0
04CC0:  RCALL  4B3E
04CC2:  MOVF   01,W
04CC4:  MOVLB  5
04CC6:  SUBWF  x69,F
04CC8:  MOVF   02,W
04CCA:  SUBWFB x6A,F
....................    hundredths = tempo_u16/10; 
04CCC:  MOVFF  56A,576
04CD0:  MOVFF  569,575
04CD4:  CLRF   x78
04CD6:  MOVLW  0A
04CD8:  MOVWF  x77
04CDA:  MOVLB  0
04CDC:  CALL   4384
04CE0:  MOVFF  01,55F
....................    thousandths = tempo_u16 % 10; 
04CE4:  MOVFF  56A,576
04CE8:  MOVFF  569,575
04CEC:  MOVLB  5
04CEE:  CLRF   x78
04CF0:  MOVLW  0A
04CF2:  MOVWF  x77
04CF4:  MOVLB  0
04CF6:  CALL   4384
04CFA:  MOVFF  00,560
04CFE:  MOVLB  5
....................  
....................    return ((uint16_t)(volts)*4096 + (uint16_t)(tenths)*256 + (uint16_t)(hundredths)*16 + (uint16_t)(thousandths)); 
04D00:  CLRF   x6E
04D02:  SWAPF  x5D,W
04D04:  MOVWF  x6E
04D06:  CLRF   x6D
04D08:  MOVLW  F0
04D0A:  ANDWF  x6E,F
04D0C:  CLRF   x70
04D0E:  MOVFF  55E,03
04D12:  MOVLW  00
04D14:  ADDWF  x6D,F
04D16:  MOVF   x5E,W
04D18:  ADDWFC x6E,F
04D1A:  CLRF   x70
04D1C:  RLCF   x5F,W
04D1E:  MOVWF  02
04D20:  RLCF   x70,W
04D22:  MOVWF  03
04D24:  RLCF   02,F
04D26:  RLCF   03,F
04D28:  RLCF   02,F
04D2A:  RLCF   03,F
04D2C:  RLCF   02,F
04D2E:  RLCF   03,F
04D30:  MOVLW  F0
04D32:  ANDWF  02,F
04D34:  MOVF   02,W
04D36:  ADDWF  x6D,F
04D38:  MOVF   03,W
04D3A:  ADDWFC x6E,F
04D3C:  CLRF   03
04D3E:  MOVF   x60,W
04D40:  ADDWF  x6D,W
04D42:  MOVWF  01
04D44:  MOVF   x6E,W
04D46:  ADDWFC 03,F
04D48:  MOVFF  03,02
04D4C:  MOVLB  0
04D4E:  GOTO   4E1E (RETURN)
.................... } 
....................  
.................... uint16_t calc_vgen_BCD(uint16_t vref_count) 
.................... { 
....................    /* Takes the voltage count as an input (summed from ADC) 
....................     * and outputs the vgen integer and fractional as a single uint32_t 
....................     * It's output is BCD as follows: 
....................     * volts (.) tenths hundredths thousandths 
....................    */ 
....................    uint8_t volts, tenths, hundredths, thousandths; 
....................  
....................    uint32_t tempo_u32, frac_part; 
....................    uint16_t tempo_u16;   
....................     
....................    uint16_t    bat_frac_part;    // in units of mV 
....................     
....................    // First calculate a single count of the ADC in volts in 12.20 format? 
....................    tempo_u32 = VAL32_FVR_BAT/get_vbatt(0);   // = 1 count in volts in 12.20 format 
*
084F0:  MOVLB  5
084F2:  CLRF   x6A
084F4:  MOVLB  0
084F6:  CALL   42B4
084FA:  MOVFF  02,56E
084FE:  MOVFF  01,56D
08502:  MOVLB  0
08504:  CALL   4818
08508:  MOVLW  9A
0850A:  MOVLB  5
0850C:  MOVWF  x70
0850E:  MOVLW  99
08510:  MOVWF  x6F
08512:  MOVLW  19
08514:  MOVWF  x6E
08516:  MOVLW  95
08518:  MOVWF  x6D
0851A:  MOVFF  03,574
0851E:  MOVFF  02,573
08522:  MOVFF  01,572
08526:  MOVFF  00,571
0852A:  MOVLB  0
0852C:  CALL   484E
08530:  MOVFF  03,570
08534:  MOVFF  02,56F
08538:  MOVFF  01,56E
0853C:  MOVFF  00,56D
08540:  CALL   49AC
08544:  MOVFF  03,561
08548:  MOVFF  02,560
0854C:  MOVFF  01,55F
08550:  MOVFF  00,55E
08554:  CLRF   19
08556:  BTFSC  FF2.7
08558:  BSF    19.7
0855A:  BCF    FF2.7
....................    tempo_u32 *= vref_count;                  // vgen in 12.20 format 
0855C:  MOVFF  561,605
08560:  MOVFF  560,604
08564:  MOVFF  55F,603
08568:  MOVFF  55E,602
0856C:  MOVLB  6
0856E:  CLRF   x09
08570:  CLRF   x08
08572:  MOVFF  559,607
08576:  MOVFF  558,606
0857A:  MOVLB  0
0857C:  CALL   1A3C
08580:  BTFSC  19.7
08582:  BSF    FF2.7
08584:  MOVFF  03,561
08588:  MOVFF  02,560
0858C:  MOVFF  01,55F
08590:  MOVFF  00,55E
....................    tempo_u16 = (uint16_t)(tempo_u32 >> 8); 
08594:  MOVFF  560,567
08598:  MOVFF  55F,566
....................                                              // bat voltage in 4.12 format 
....................    volts = (uint8_t)(tempo_u16 >> 12);       // 2 or 3.....    
0859C:  MOVLB  5
0859E:  SWAPF  x67,W
085A0:  MOVWF  02
085A2:  MOVLW  0F
085A4:  ANDWF  02,F
085A6:  MOVFF  02,55A
....................     
....................    frac_part = (uint32_t)(tempo_u16 & 0x0fff); 
085AA:  MOVF   x67,W
085AC:  ANDLW  0F
085AE:  MOVFF  566,562
085B2:  MOVWF  x63
085B4:  CLRF   x64
085B6:  CLRF   x65
085B8:  CLRF   19
085BA:  BTFSC  FF2.7
085BC:  BSF    19.7
085BE:  BCF    FF2.7
....................                                        // one count of frac_part is 1/4096 volt 
....................                                        // no rounding, full resolution 
....................    tempo_u32 = (frac_part * 1000);     // We ignore the mV rounding issue 
085C0:  MOVFF  565,605
085C4:  MOVFF  564,604
085C8:  MOVFF  563,603
085CC:  MOVFF  562,602
085D0:  MOVLB  6
085D2:  CLRF   x09
085D4:  CLRF   x08
085D6:  MOVLW  03
085D8:  MOVWF  x07
085DA:  MOVLW  E8
085DC:  MOVWF  x06
085DE:  MOVLB  0
085E0:  CALL   1A3C
085E4:  BTFSC  19.7
085E6:  BSF    FF2.7
085E8:  MOVFF  03,561
085EC:  MOVFF  02,560
085F0:  MOVFF  01,55F
085F4:  MOVFF  00,55E
....................                                        //  cuz battery measurement doesn't 
....................                                        //  support even mV resolution 
....................    tempo_u32 >>= 12; 
085F8:  MOVLB  5
085FA:  MOVFF  55F,55E
085FE:  MOVFF  560,55F
08602:  MOVFF  561,560
08606:  CLRF   x61
08608:  RRCF   x61,F
0860A:  RRCF   x60,F
0860C:  RRCF   x5F,F
0860E:  RRCF   x5E,F
08610:  RRCF   x61,F
08612:  RRCF   x60,F
08614:  RRCF   x5F,F
08616:  RRCF   x5E,F
08618:  RRCF   x61,F
0861A:  RRCF   x60,F
0861C:  RRCF   x5F,F
0861E:  RRCF   x5E,F
08620:  RRCF   x61,F
08622:  RRCF   x60,F
08624:  RRCF   x5F,F
08626:  RRCF   x5E,F
08628:  MOVLW  0F
0862A:  ANDWF  x61,F
....................    tempo_u16 = (uint16_t)(tempo_u32); 
0862C:  MOVFF  55F,567
08630:  MOVFF  55E,566
....................    tenths = tempo_u16/100; 
08634:  MOVFF  567,576
08638:  MOVFF  566,575
0863C:  CLRF   x78
0863E:  MOVLW  64
08640:  MOVWF  x77
08642:  MOVLB  0
08644:  CALL   4384
08648:  MOVFF  01,55B
....................    tempo_u16 -= (uint16_t)(tenths)*100; 
0864C:  MOVLB  5
0864E:  CLRF   x6B
08650:  MOVFF  55B,56A
08654:  MOVFF  56B,570
08658:  MOVFF  55B,56F
0865C:  CLRF   x72
0865E:  MOVLW  64
08660:  MOVWF  x71
08662:  MOVLB  0
08664:  CALL   4B3E
08668:  MOVF   01,W
0866A:  MOVLB  5
0866C:  SUBWF  x66,F
0866E:  MOVF   02,W
08670:  SUBWFB x67,F
....................    hundredths = tempo_u16/10; 
08672:  MOVFF  567,576
08676:  MOVFF  566,575
0867A:  CLRF   x78
0867C:  MOVLW  0A
0867E:  MOVWF  x77
08680:  MOVLB  0
08682:  CALL   4384
08686:  MOVFF  01,55C
....................    thousandths = tempo_u16 % 10; 
0868A:  MOVFF  567,576
0868E:  MOVFF  566,575
08692:  MOVLB  5
08694:  CLRF   x78
08696:  MOVLW  0A
08698:  MOVWF  x77
0869A:  MOVLB  0
0869C:  CALL   4384
086A0:  MOVFF  00,55D
086A4:  MOVLB  5
....................  
....................    return ((uint16_t)(volts)*4096 + (uint16_t)(tenths)*256 + (uint16_t)(hundredths)*16 + (uint16_t)(thousandths)); 
086A6:  CLRF   x6B
086A8:  SWAPF  x5A,W
086AA:  MOVWF  x6B
086AC:  CLRF   x6A
086AE:  MOVLW  F0
086B0:  ANDWF  x6B,F
086B2:  CLRF   x6D
086B4:  MOVFF  55B,03
086B8:  MOVLW  00
086BA:  ADDWF  x6A,F
086BC:  MOVF   x5B,W
086BE:  ADDWFC x6B,F
086C0:  CLRF   x6D
086C2:  RLCF   x5C,W
086C4:  MOVWF  02
086C6:  RLCF   x6D,W
086C8:  MOVWF  03
086CA:  RLCF   02,F
086CC:  RLCF   03,F
086CE:  RLCF   02,F
086D0:  RLCF   03,F
086D2:  RLCF   02,F
086D4:  RLCF   03,F
086D6:  MOVLW  F0
086D8:  ANDWF  02,F
086DA:  MOVF   02,W
086DC:  ADDWF  x6A,F
086DE:  MOVF   03,W
086E0:  ADDWFC x6B,F
086E2:  CLRF   03
086E4:  MOVF   x5D,W
086E6:  ADDWF  x6A,W
086E8:  MOVWF  01
086EA:  MOVF   x6B,W
086EC:  ADDWFC 03,F
086EE:  MOVFF  03,02
086F2:  MOVLB  0
086F4:  GOTO   8756 (RETURN)
.................... } 
....................  
.................... uint32_t calc_vbatt(uint16_t vref_count) 
.................... { 
....................    /* Takes the voltage count as an input (summed from ADC) 
....................     * and outputs the battery integer and fractional as a single uint32_t 
....................     * It's output is (in binary) 00000000IIIIIIIIFFFFFFFFFFFFFFFF 
....................     * Where the first 8 bits are 0, the next 8 represent the integer 
....................     * part of the battery, and the next 16 are the fractional part 
....................     */ 
....................    uint32_t tempo_u32, frac_part; 
....................    uint16_t tempo_u16; 
....................     
....................    uint16_t    bat_frac_part;    // in units of .1mV      
....................    uint8_t     bat_int_part; 
....................     
....................    tempo_u32 = VAL32_FVR_BAT/vref_count;   // = 1 count in volts in 12.20 format 
*
049EE:  MOVFF  553,56E
049F2:  MOVFF  552,56D
049F6:  RCALL  4818
049F8:  MOVLW  9A
049FA:  MOVLB  5
049FC:  MOVWF  x70
049FE:  MOVLW  99
04A00:  MOVWF  x6F
04A02:  MOVLW  19
04A04:  MOVWF  x6E
04A06:  MOVLW  95
04A08:  MOVWF  x6D
04A0A:  MOVFF  03,574
04A0E:  MOVFF  02,573
04A12:  MOVFF  01,572
04A16:  MOVFF  00,571
04A1A:  MOVLB  0
04A1C:  RCALL  484E
04A1E:  MOVFF  03,570
04A22:  MOVFF  02,56F
04A26:  MOVFF  01,56E
04A2A:  MOVFF  00,56D
04A2E:  RCALL  49AC
04A30:  MOVFF  03,557
04A34:  MOVFF  02,556
04A38:  MOVFF  01,555
04A3C:  MOVFF  00,554
04A40:  CLRF   19
04A42:  BTFSC  FF2.7
04A44:  BSF    19.7
04A46:  BCF    FF2.7
....................    tempo_u32 *= 1023;                        // bat voltage in 12.20 format 
04A48:  MOVFF  557,605
04A4C:  MOVFF  556,604
04A50:  MOVFF  555,603
04A54:  MOVFF  554,602
04A58:  MOVLB  6
04A5A:  CLRF   x09
04A5C:  CLRF   x08
04A5E:  MOVLW  03
04A60:  MOVWF  x07
04A62:  SETF   x06
04A64:  MOVLB  0
04A66:  CALL   1A3C
04A6A:  BTFSC  19.7
04A6C:  BSF    FF2.7
04A6E:  MOVFF  03,557
04A72:  MOVFF  02,556
04A76:  MOVFF  01,555
04A7A:  MOVFF  00,554
....................    tempo_u16 = (uint16_t)(tempo_u32 >> 8); 
04A7E:  MOVFF  556,55D
04A82:  MOVFF  555,55C
....................                                              // bat voltage in 4.12 format 
....................                                               
....................    //This stores the integer part shifted into the final result                                     
....................    bat_int_part = (uint8_t)(tempo_u16 >> 12);      // 2 or 3..... 
04A86:  MOVLB  5
04A88:  SWAPF  x5D,W
04A8A:  MOVWF  02
04A8C:  MOVLW  0F
04A8E:  ANDWF  02,F
04A90:  MOVFF  02,560
....................    frac_part = (uint32_t)(tempo_u16 & 0x0fff); 
04A94:  MOVF   x5D,W
04A96:  ANDLW  0F
04A98:  MOVFF  55C,558
04A9C:  MOVWF  x59
04A9E:  CLRF   x5A
04AA0:  CLRF   x5B
04AA2:  CLRF   19
04AA4:  BTFSC  FF2.7
04AA6:  BSF    19.7
04AA8:  BCF    FF2.7
....................                                        // one count of frac_part is 1/4096 volt 
....................    tempo_u32 = (frac_part * 10000);    // 
04AAA:  MOVFF  55B,605
04AAE:  MOVFF  55A,604
04AB2:  MOVFF  559,603
04AB6:  MOVFF  558,602
04ABA:  MOVLB  6
04ABC:  CLRF   x09
04ABE:  CLRF   x08
04AC0:  MOVLW  27
04AC2:  MOVWF  x07
04AC4:  MOVLW  10
04AC6:  MOVWF  x06
04AC8:  MOVLB  0
04ACA:  CALL   1A3C
04ACE:  BTFSC  19.7
04AD0:  BSF    FF2.7
04AD2:  MOVFF  03,557
04AD6:  MOVFF  02,556
04ADA:  MOVFF  01,555
04ADE:  MOVFF  00,554
....................    tempo_u32 >>= 12; // divide by 4096. temp32 now = frac part (0 to 9999) 
04AE2:  MOVLB  5
04AE4:  MOVFF  555,554
04AE8:  MOVFF  556,555
04AEC:  MOVFF  557,556
04AF0:  CLRF   x57
04AF2:  RRCF   x57,F
04AF4:  RRCF   x56,F
04AF6:  RRCF   x55,F
04AF8:  RRCF   x54,F
04AFA:  RRCF   x57,F
04AFC:  RRCF   x56,F
04AFE:  RRCF   x55,F
04B00:  RRCF   x54,F
04B02:  RRCF   x57,F
04B04:  RRCF   x56,F
04B06:  RRCF   x55,F
04B08:  RRCF   x54,F
04B0A:  RRCF   x57,F
04B0C:  RRCF   x56,F
04B0E:  RRCF   x55,F
04B10:  RRCF   x54,F
04B12:  MOVLW  0F
04B14:  ANDWF  x57,F
....................    bat_frac_part = (uint16_t)(tempo_u32); 
04B16:  MOVFF  555,55F
04B1A:  MOVFF  554,55E
....................     
....................    return ((((uint32_t)bat_int_part) << 16) | (bat_frac_part)); 
04B1E:  CLRF   x62
04B20:  MOVFF  562,03
04B24:  CLRF   x61
04B26:  CLRF   x62
04B28:  MOVF   x61,W
04B2A:  IORWF  x5E,W
04B2C:  MOVWF  00
04B2E:  MOVF   x62,W
04B30:  IORWF  x5F,W
04B32:  MOVWF  01
04B34:  MOVFF  560,02
04B38:  MOVLB  0
04B3A:  GOTO   4F7A (RETURN)
....................    //return (uint32_t)bat_frac_part; 
.................... } 
....................  
.................... void check_and_deal_with_battery(void) 
.................... // checks the battery voltage (charging and not charging) and decides to turn on 
.................... // charger/off charger send a warning, or send a warning and shutdown. 
.................... { 
....................    uint16_t batt_chrg, batt_no_chrg; 
....................     
....................    // if the valve is not moving (otherwise, abort) 
....................    if (IS_VLV_COASTING) 
*
09478:  MOVF   F8D,F
0947A:  BTFSS  FD8.2
0947C:  BRA    958E
....................    { 
....................       // grab a fresh battery reading 
....................       batt_chrg = get_vbatt(0); 
0947E:  MOVLB  5
09480:  CLRF   x6A
09482:  MOVLB  0
09484:  CALL   42B4
09488:  MOVFF  02,54C
0948C:  MOVFF  01,54B
....................       batt_no_chrg = get_vbatt(1); 
09490:  MOVLW  01
09492:  MOVLB  5
09494:  MOVWF  x6A
09496:  MOVLB  0
09498:  CALL   42B4
0949C:  MOVFF  02,54E
094A0:  MOVFF  01,54D
....................        
....................       // if the battery is dead and system needs to be shutdown 
....................       if (batt_no_chrg > BATTERY_DEAD) 
094A4:  MOVLB  5
094A6:  MOVF   x4E,W
094A8:  SUBLW  05
094AA:  BC    9520
094AC:  XORLW  FF
094AE:  BNZ   94B6
094B0:  MOVF   x4D,W
094B2:  SUBLW  65
094B4:  BC    9520
....................       { 
....................          global_control_loop_mechanism = BRAKE_AND_CHARGE_START; 
094B6:  MOVLB  0
094B8:  CLRF   xC0
....................          // set the error bitfield and message 
....................          global_error_message_bitfield |= ERR_MSG_BATT_DEAD_SLEEP; 
094BA:  MOVLB  4
094BC:  BSF    xF9.0
....................          PUSH_MESSAGE_QUEUE_MACRO(MSG_MOTE_ERROR_MSG); 
094BE:  BCF    F7A.1
094C0:  MOVLW  A0
094C2:  MOVLB  5
094C4:  MOVWF  x54
094C6:  MOVLB  0
094C8:  CALL   51F6
094CC:  BSF    F7A.1
....................          // set the shutdown message and schedule a shutdown 
....................          global_shutdown_cause = ERR_BATT_DEAD_SLEEP;  
094CE:  MOVLW  0C
094D0:  MOVWF  4D
....................          PUSH_PRIORITY_QUEUE(OPEN_VALVE_UNKNOWN_STATE);   
094D2:  MOVLW  3E
094D4:  MOVLB  5
094D6:  MOVWF  x52
094D8:  MOVLB  0
094DA:  CALL   4748
....................          PUSH_TIME_QUEUE(global_rtc_time + 10, SHUTDOWN_SYSTEM);   
094DE:  MOVLW  0A
094E0:  ADDWF  x85,W
094E2:  MOVLB  5
094E4:  MOVWF  x4F
094E6:  MOVLW  00
094E8:  MOVLB  0
094EA:  ADDWFC x86,W
094EC:  MOVLB  5
094EE:  MOVWF  x50
094F0:  MOVLW  00
094F2:  MOVLB  0
094F4:  ADDWFC x87,W
094F6:  MOVLB  5
094F8:  MOVWF  x51
094FA:  MOVLW  00
094FC:  MOVLB  0
094FE:  ADDWFC x88,W
09500:  MOVLB  5
09502:  MOVWF  x52
09504:  MOVWF  x59
09506:  MOVFF  551,558
0950A:  MOVFF  550,557
0950E:  MOVFF  54F,556
09512:  MOVLW  F1
09514:  MOVWF  x5A
09516:  MOVLB  0
09518:  CALL   44A0
....................       } 
0951C:  BRA    958E
0951E:  MOVLB  5
....................       // if the battery is almost dead and the manager needs a warning 
....................       else if (batt_no_chrg > BATTERY_WARN) 
09520:  MOVF   x4E,W
09522:  SUBLW  05
09524:  BC    954C
09526:  XORLW  FF
09528:  BNZ   9530
0952A:  MOVF   x4D,W
0952C:  SUBLW  30
0952E:  BC    954C
....................       { 
....................          global_control_loop_mechanism = BRAKE_AND_CHARGE_START; 
09530:  MOVLB  0
09532:  CLRF   xC0
....................          // set the error bitfield and message 
....................          global_error_message_bitfield |= ERR_MSG_BATT_LOW_WARN; 
09534:  MOVLB  4
09536:  BSF    xF8.7
....................          PUSH_MESSAGE_QUEUE_MACRO(MSG_MOTE_ERROR_MSG); 
09538:  BCF    F7A.1
0953A:  MOVLW  A0
0953C:  MOVLB  5
0953E:  MOVWF  x54
09540:  MOVLB  0
09542:  CALL   51F6
09546:  BSF    F7A.1
....................       } 
09548:  BRA    958E
0954A:  MOVLB  5
....................       // if the battery charging needs to be turned off (is in brake + charge control) 
....................       else if ((batt_chrg < BATTERY_STOP_CHARGING) &&                              \ 
....................          (global_control_loop_mechanism == BRAKE_AND_CHARGE)) 
0954C:  MOVF   x4C,W
0954E:  SUBLW  05
09550:  BNC   956E
09552:  BNZ   955A
09554:  MOVF   x4B,W
09556:  SUBLW  79
09558:  BNC   956E
0955A:  MOVLB  0
0955C:  DECFSZ xC0,W
0955E:  BRA    9562
09560:  BRA    9566
09562:  MOVLB  5
09564:  BRA    956E
....................       { 
....................          global_control_loop_mechanism = BRAKE_ONLY; 
09566:  MOVLW  02
09568:  MOVWF  xC0
....................       } 
0956A:  BRA    958E
0956C:  MOVLB  5
....................       // if the battery charging needs to be turned on (is in brake only control) 
....................       else if ((batt_no_chrg > BATTERY_START_CHARGING) &&                     \ 
....................          (global_control_loop_mechanism == BRAKE_ONLY)) 
0956E:  MOVF   x4E,W
09570:  SUBLW  04
09572:  BC    9590
09574:  XORLW  FF
09576:  BNZ   957E
09578:  MOVF   x4D,W
0957A:  SUBLW  D2
0957C:  BC    9590
0957E:  MOVLB  0
09580:  MOVF   xC0,W
09582:  SUBLW  02
09584:  BTFSC  FD8.2
09586:  BRA    958C
09588:  MOVLB  5
0958A:  BRA    9590
....................       { 
....................          global_control_loop_mechanism = BRAKE_AND_CHARGE_START; 
0958C:  CLRF   xC0
0958E:  MOVLB  5
....................       } 
....................    } 
09590:  MOVLB  0
09592:  GOTO   B1D4 (RETURN)
.................... } 
....................           
....................  
....................  
....................  
....................  
.................... #include "stacks_queues.h"   
.................... void clear_priority_queue() 
.................... { 
....................    uint8_t n; 
....................     
....................    for (n = 0; n < MAX_PRIORITY_QUEUE_ITEMS; n++) 
*
041C0:  MOVLB  5
041C2:  CLRF   x4B
041C4:  MOVF   x4B,W
041C6:  SUBLW  13
041C8:  BNC   41DE
....................    { 
....................       global_priority_queue[n] = EMPTY_PRIORITY_QUEUE; 
041CA:  CLRF   03
041CC:  MOVF   x4B,W
041CE:  ADDLW  6E
041D0:  MOVWF  FE9
041D2:  MOVLW  03
041D4:  ADDWFC 03,W
041D6:  MOVWF  FEA
041D8:  CLRF   FEF
041DA:  INCF   x4B,F
041DC:  BRA    41C4
....................    } 
041DE:  MOVLB  0
041E0:  GOTO   A428 (RETURN)
.................... } 
....................  
.................... uint8_t pop_priority_queue() 
.................... // Checks the priority queue and returns the current item to execute 
.................... { 
....................    uint8_t priority_queue_command_to_execute; 
....................     
....................    //no items in the queue (current location is 0-1) 
....................    if (global_current_priority_queue_location == 255) 
*
05DDC:  MOVLB  3
05DDE:  INCFSZ x82,W
05DE0:  BRA    5DEA
....................    { 
....................       return EMPTY_PRIORITY_QUEUE; 
05DE2:  MOVLW  00
05DE4:  MOVWF  01
05DE6:  BRA    5E14
....................    } 
05DE8:  BRA    5E14
....................    else 
....................    { 
....................       //save the current command to execute 
....................       priority_queue_command_to_execute = global_priority_queue[global_current_priority_queue_location]; 
05DEA:  CLRF   03
05DEC:  MOVF   x82,W
05DEE:  ADDLW  6E
05DF0:  MOVWF  FE9
05DF2:  MOVLW  03
05DF4:  ADDWFC 03,W
05DF6:  MOVWF  FEA
05DF8:  MOVFF  FEF,54B
....................       //erase the current command and decrement the current queue location 
....................       global_priority_queue[global_current_priority_queue_location] = 0; 
05DFC:  CLRF   03
05DFE:  MOVF   x82,W
05E00:  ADDLW  6E
05E02:  MOVWF  FE9
05E04:  MOVLW  03
05E06:  ADDWFC 03,W
05E08:  MOVWF  FEA
05E0A:  CLRF   FEF
....................       global_current_priority_queue_location--; 
05E0C:  DECF   x82,F
....................       //return the command to execute 
....................       return priority_queue_command_to_execute; 
05E0E:  MOVFF  54B,01
05E12:  MOVLB  3
....................    } 
05E14:  MOVLB  0
05E16:  GOTO   A5E6 (RETURN)
.................... } 
....................  
.................... int1 push_priority_queue(uint8_t new_priority_queue_item) 
.................... // pushes a new item into the priority queue and sorts it. 
.................... // returns 1 if everything is good, 0 if queue is full 
.................... { 
....................    uint8_t n; 
....................    
....................    //if queue is full, return 0 
....................    if (global_current_priority_queue_location == (MAX_PRIORITY_QUEUE_ITEMS - 1)) 
*
04748:  MOVLB  3
0474A:  MOVF   x82,W
0474C:  SUBLW  13
0474E:  BNZ   4756
....................    { 
....................       return 0; 
04750:  MOVLW  00
04752:  MOVWF  01
04754:  BRA    480A
....................    } 
....................     
....................    //increment the queue location and 
....................    //set the new item at the top of the queue (will be sorted in a sec) 
....................    global_current_priority_queue_location++; 
04756:  INCF   x82,F
....................    global_priority_queue[global_current_priority_queue_location] = new_priority_queue_item; 
04758:  CLRF   03
0475A:  MOVF   x82,W
0475C:  ADDLW  6E
0475E:  MOVWF  FE9
04760:  MOVLW  03
04762:  ADDWFC 03,W
04764:  MOVWF  FEA
04766:  MOVFF  552,FEF
....................     
....................    //starting at the new current queue location, sort through the queue 
....................    //until the new item is in the right place 
....................    for (n = global_current_priority_queue_location; n > 0; n--) 
0476A:  MOVFF  382,553
0476E:  MOVLB  5
04770:  MOVF   x53,F
04772:  BZ    4804
....................    { 
....................       //if queue items are not sorted properly 
....................       if (global_priority_queue[n] > global_priority_queue[n-1]) 
04774:  CLRF   03
04776:  MOVF   x53,W
04778:  ADDLW  6E
0477A:  MOVWF  FE9
0477C:  MOVLW  03
0477E:  ADDWFC 03,W
04780:  MOVWF  FEA
04782:  MOVFF  FEF,554
04786:  MOVLW  01
04788:  SUBWF  x53,W
0478A:  CLRF   03
0478C:  ADDLW  6E
0478E:  MOVWF  FE9
04790:  MOVLW  03
04792:  ADDWFC 03,W
04794:  MOVWF  FEA
04796:  MOVF   FEF,W
04798:  SUBWF  x54,W
0479A:  BZ    47F6
0479C:  BNC   47F6
....................       { 
....................          //do a swap reusing new queue item variable as a temp 
....................          new_priority_queue_item = global_priority_queue[n]; 
0479E:  CLRF   03
047A0:  MOVF   x53,W
047A2:  ADDLW  6E
047A4:  MOVWF  FE9
047A6:  MOVLW  03
047A8:  ADDWFC 03,W
047AA:  MOVWF  FEA
047AC:  MOVFF  FEF,552
....................          global_priority_queue[n] = global_priority_queue[n-1]; 
047B0:  CLRF   03
047B2:  MOVF   x53,W
047B4:  ADDLW  6E
047B6:  MOVWF  01
047B8:  MOVLW  03
047BA:  ADDWFC 03,F
047BC:  MOVFF  03,555
047C0:  MOVLW  01
047C2:  SUBWF  x53,W
047C4:  CLRF   03
047C6:  ADDLW  6E
047C8:  MOVWF  FE9
047CA:  MOVLW  03
047CC:  ADDWFC 03,W
047CE:  MOVWF  FEA
047D0:  MOVFF  FEF,556
047D4:  MOVFF  555,FEA
047D8:  MOVFF  01,FE9
047DC:  MOVFF  556,FEF
....................          global_priority_queue[n-1] = new_priority_queue_item; 
047E0:  MOVLW  01
047E2:  SUBWF  x53,W
047E4:  CLRF   03
047E6:  ADDLW  6E
047E8:  MOVWF  FE9
047EA:  MOVLW  03
047EC:  ADDWFC 03,W
047EE:  MOVWF  FEA
047F0:  MOVFF  552,FEF
....................       } 
047F4:  BRA    4800
....................       //item is in the proper place (assuming queue always sorted properly) 
....................       else 
....................       { 
....................          return 1; 
047F6:  MOVLW  01
047F8:  MOVWF  01
047FA:  MOVLB  3
047FC:  BRA    480A
047FE:  MOVLB  5
....................       } 
04800:  DECF   x53,F
04802:  BRA    4770
....................    } 
....................    return 1; 
04804:  MOVLW  01
04806:  MOVWF  01
04808:  MOVLB  3
0480A:  MOVLB  0
0480C:  RETURN 0
.................... } 
....................  
.................... void push_priority_queue_ISR(uint8_t new_priority_queue_item) 
.................... // pushes a new item into the priority queue and sorts it. 
.................... // returns 1 if everything is good, 0 if queue is full 
.................... { 
....................    uint8_t n; 
....................    
....................    //if queue is full, return 0 
....................    if (global_current_priority_queue_location == (MAX_PRIORITY_QUEUE_ITEMS - 1)) 
*
0082A:  MOVLB  3
0082C:  MOVF   x82,W
0082E:  SUBLW  13
00830:  BNZ   0834
....................    { 
....................       return; 
00832:  BRA    08D8
....................    } 
....................     
....................    //increment the queue location and 
....................    //set the new item at the top of the queue (will be sorted in a sec) 
....................    global_current_priority_queue_location++; 
00834:  INCF   x82,F
....................    global_priority_queue[global_current_priority_queue_location] = new_priority_queue_item; 
00836:  CLRF   03
00838:  MOVF   x82,W
0083A:  ADDLW  6E
0083C:  MOVWF  FE9
0083E:  MOVLW  03
00840:  ADDWFC 03,W
00842:  MOVWF  FEA
00844:  MOVFF  62C,FEF
....................     
....................    //starting at the new current queue location, sort through the queue 
....................    //until the new item is in the right place 
....................    for (n = global_current_priority_queue_location; n > 0; n--) 
00848:  MOVFF  382,62D
0084C:  MOVLB  6
0084E:  MOVF   x2D,F
00850:  BZ    08D6
....................    { 
....................       //if queue items are not sorted properly 
....................       if (global_priority_queue[n] > global_priority_queue[n-1]) 
00852:  CLRF   03
00854:  MOVF   x2D,W
00856:  ADDLW  6E
00858:  MOVWF  FE9
0085A:  MOVLW  03
0085C:  ADDWFC 03,W
0085E:  MOVWF  FEA
00860:  MOVFF  FEF,62E
00864:  MOVLW  01
00866:  SUBWF  x2D,W
00868:  CLRF   03
0086A:  ADDLW  6E
0086C:  MOVWF  FE9
0086E:  MOVLW  03
00870:  ADDWFC 03,W
00872:  MOVWF  FEA
00874:  MOVF   FEF,W
00876:  SUBWF  x2E,W
00878:  BZ    08D2
0087A:  BNC   08D2
....................       { 
....................          //do a swap reusing new queue item variable as a temp 
....................          new_priority_queue_item = global_priority_queue[n]; 
0087C:  CLRF   03
0087E:  MOVF   x2D,W
00880:  ADDLW  6E
00882:  MOVWF  FE9
00884:  MOVLW  03
00886:  ADDWFC 03,W
00888:  MOVWF  FEA
0088A:  MOVFF  FEF,62C
....................          global_priority_queue[n] = global_priority_queue[n-1]; 
0088E:  CLRF   03
00890:  MOVF   x2D,W
00892:  ADDLW  6E
00894:  MOVWF  01
00896:  MOVLW  03
00898:  ADDWFC 03,F
0089A:  MOVFF  03,62F
0089E:  MOVLW  01
008A0:  SUBWF  x2D,W
008A2:  CLRF   03
008A4:  ADDLW  6E
008A6:  MOVWF  FE9
008A8:  MOVLW  03
008AA:  ADDWFC 03,W
008AC:  MOVWF  FEA
008AE:  MOVFF  FEF,630
008B2:  MOVFF  62F,FEA
008B6:  MOVFF  01,FE9
008BA:  MOVFF  630,FEF
....................          global_priority_queue[n-1] = new_priority_queue_item; 
008BE:  MOVLW  01
008C0:  SUBWF  x2D,W
008C2:  CLRF   03
008C4:  ADDLW  6E
008C6:  MOVWF  FE9
008C8:  MOVLW  03
008CA:  ADDWFC 03,W
008CC:  MOVWF  FEA
008CE:  MOVFF  62C,FEF
....................       } 
008D2:  DECF   x2D,F
008D4:  BRA    084E
008D6:  MOVLB  3
....................    } 
....................    return;  
008D8:  MOVLB  0
008DA:  RETURN 0
.................... } 
....................  
.................... void clear_time_queue() 
.................... { 
....................    uint8_t n; 
....................     
....................    for (n = 0; n < MAX_TIME_QUEUE_ITEMS; n++) 
*
041E4:  MOVLB  5
041E6:  CLRF   x4B
041E8:  MOVF   x4B,W
041EA:  SUBLW  04
041EC:  BNC   423E
....................    { 
....................       global_time_queue[n].pq_priority = 0; 
041EE:  MOVF   x4B,W
041F0:  MULLW  05
041F2:  MOVF   FF3,W
041F4:  CLRF   x4D
041F6:  MOVWF  x4C
041F8:  MOVLW  04
041FA:  ADDWF  x4C,W
041FC:  MOVWF  01
041FE:  MOVLW  00
04200:  ADDWFC x4D,W
04202:  MOVWF  03
04204:  MOVF   01,W
04206:  ADDLW  83
04208:  MOVWF  FE9
0420A:  MOVLW  03
0420C:  ADDWFC 03,W
0420E:  MOVWF  FEA
04210:  CLRF   FEF
....................       global_time_queue[n].time_to_execute = 0; 
04212:  MOVF   x4B,W
04214:  MULLW  05
04216:  MOVF   FF3,W
04218:  CLRF   x4D
0421A:  MOVWF  x4C
0421C:  MOVLW  83
0421E:  ADDWF  x4C,W
04220:  MOVWF  FE9
04222:  MOVLW  03
04224:  ADDWFC x4D,W
04226:  MOVWF  FEA
04228:  MOVF   FEE,F
0422A:  MOVF   FEE,F
0422C:  CLRF   FEC
0422E:  MOVF   FED,F
04230:  CLRF   FEF
04232:  MOVF   FED,F
04234:  CLRF   FEF
04236:  MOVF   FED,F
04238:  CLRF   FEF
0423A:  INCF   x4B,F
0423C:  BRA    41E8
....................    } 
0423E:  MOVLB  0
04240:  GOTO   A42C (RETURN)
.................... } 
....................  
.................... int1 pop_time_queue() 
.................... // Checks the time queue and sends the item to execute to the priority queue 
.................... { 
....................    struct TimeQueueItem time_queue_command_to_execute; 
....................     
....................    //no items in the queue (current location is 0-1) 
....................    if (global_current_time_queue_location == (0-1)) 
....................    { 
....................       return EMPTY_TIME_QUEUE; 
....................    } 
....................    else 
....................    { 
....................       //save the current command to execute 
....................       time_queue_command_to_execute.pq_priority = global_time_queue[global_current_time_queue_location].pq_priority; 
....................        
....................       //erase the current command and decrement the current queue location 
....................       global_time_queue[global_current_time_queue_location].pq_priority = 0; 
....................       global_time_queue[global_current_time_queue_location].time_to_execute = 0; 
....................       global_current_time_queue_location--; 
....................        
....................       //send queue item to the priority queue and return the result from adding it to the PQ 
....................       return push_priority_queue(time_queue_command_to_execute.pq_priority); 
....................    } 
.................... } 
....................  
.................... void pop_time_queue_ISR() 
.................... // Checks the time queue and sends the item to execute to the priority queue 
.................... { 
....................    uint8_t priority; 
....................     
....................    //no items in the queue (current location is 0-1) 
....................    if (global_current_time_queue_location == 255) 
*
02216:  MOVLB  3
02218:  INCFSZ x9C,W
0221A:  BRA    2220
....................    { 
....................       return; 
0221C:  BRA    22B8
....................    } 
0221E:  BRA    22B8
....................    else 
....................    { 
....................       //save the current command to execute 
....................       priority = global_time_queue[global_current_time_queue_location].pq_priority; 
02220:  MOVF   x9C,W
02222:  MULLW  05
02224:  MOVF   FF3,W
02226:  MOVLB  5
02228:  CLRF   xFA
0222A:  MOVWF  xF9
0222C:  MOVLW  04
0222E:  ADDWF  xF9,W
02230:  MOVWF  01
02232:  MOVLW  00
02234:  ADDWFC xFA,W
02236:  MOVWF  03
02238:  MOVF   01,W
0223A:  ADDLW  83
0223C:  MOVWF  FE9
0223E:  MOVLW  03
02240:  ADDWFC 03,W
02242:  MOVWF  FEA
02244:  MOVFF  FEF,5F8
....................        
....................       //erase the current command and decrement the current queue location 
....................       global_time_queue[global_current_time_queue_location].pq_priority = 0; 
02248:  MOVLB  3
0224A:  MOVF   x9C,W
0224C:  MULLW  05
0224E:  MOVF   FF3,W
02250:  MOVLB  5
02252:  CLRF   xFA
02254:  MOVWF  xF9
02256:  MOVLW  04
02258:  ADDWF  xF9,W
0225A:  MOVWF  01
0225C:  MOVLW  00
0225E:  ADDWFC xFA,W
02260:  MOVWF  03
02262:  MOVF   01,W
02264:  ADDLW  83
02266:  MOVWF  FE9
02268:  MOVLW  03
0226A:  ADDWFC 03,W
0226C:  MOVWF  FEA
0226E:  CLRF   FEF
....................       global_time_queue[global_current_time_queue_location].time_to_execute = 0; 
02270:  MOVLB  3
02272:  MOVF   x9C,W
02274:  MULLW  05
02276:  MOVF   FF3,W
02278:  MOVLB  5
0227A:  CLRF   xFA
0227C:  MOVWF  xF9
0227E:  MOVLW  83
02280:  ADDWF  xF9,W
02282:  MOVWF  FE9
02284:  MOVLW  03
02286:  ADDWFC xFA,W
02288:  MOVWF  FEA
0228A:  MOVF   FEE,F
0228C:  MOVF   FEE,F
0228E:  CLRF   FEC
02290:  MOVF   FED,F
02292:  CLRF   FEF
02294:  MOVF   FED,F
02296:  CLRF   FEF
02298:  MOVF   FED,F
0229A:  CLRF   FEF
....................       global_current_time_queue_location--; 
0229C:  MOVLB  3
0229E:  DECF   x9C,F
022A0:  CLRF   19
022A2:  BTFSC  FF2.7
022A4:  BSF    19.7
022A6:  BCF    FF2.7
....................        
....................       //send queue item to the priority queue and return the result from adding it to the PQ 
....................       push_priority_queue_ISR(priority); 
022A8:  MOVFF  5F8,62C
022AC:  MOVLB  0
022AE:  CALL   082A
022B2:  BTFSC  19.7
022B4:  BSF    FF2.7
....................       return; 
022B6:  MOVLB  3
....................    } 
022B8:  MOVLB  0
022BA:  GOTO   2F26 (RETURN)
.................... } 
....................  
.................... int1 push_time_queue(uint32_t time_to_execute, uint8_t priority) 
.................... // pushes a new item into the time queue and sorts it (by time). 
.................... // returns 1 if everything is good, 0 if queue is full 
.................... { 
....................    uint8_t n; 
....................       
....................    //if queue is full, return 0 
....................    if (global_current_time_queue_location == (MAX_TIME_QUEUE_ITEMS - 1)) 
*
044A0:  MOVLB  3
044A2:  MOVF   x9C,W
044A4:  SUBLW  04
044A6:  BNZ   44AE
....................    { 
....................       return 0; 
044A8:  MOVLW  00
044AA:  MOVWF  01
044AC:  BRA    46EA
....................    } 
....................     
....................    // increment the time queue location and 
....................    // set the new item at the top of the queue (will be sorted in a sec) 
....................    global_current_time_queue_location++; 
044AE:  INCF   x9C,F
....................    global_time_queue[global_current_time_queue_location].pq_priority = priority; 
044B0:  MOVF   x9C,W
044B2:  MULLW  05
044B4:  MOVF   FF3,W
044B6:  MOVLB  5
044B8:  CLRF   x5D
044BA:  MOVWF  x5C
044BC:  MOVLW  04
044BE:  ADDWF  x5C,W
044C0:  MOVWF  01
044C2:  MOVLW  00
044C4:  ADDWFC x5D,W
044C6:  MOVWF  03
044C8:  MOVF   01,W
044CA:  ADDLW  83
044CC:  MOVWF  FE9
044CE:  MOVLW  03
044D0:  ADDWFC 03,W
044D2:  MOVWF  FEA
044D4:  MOVFF  55A,FEF
....................    global_time_queue[global_current_time_queue_location].time_to_execute = time_to_execute; 
044D8:  MOVLB  3
044DA:  MOVF   x9C,W
044DC:  MULLW  05
044DE:  MOVF   FF3,W
044E0:  MOVLB  5
044E2:  CLRF   x5D
044E4:  MOVWF  x5C
044E6:  MOVLW  83
044E8:  ADDWF  x5C,W
044EA:  MOVWF  FE9
044EC:  MOVLW  03
044EE:  ADDWFC x5D,W
044F0:  MOVWF  FEA
044F2:  MOVFF  556,FEF
044F6:  MOVFF  557,FEC
044FA:  MOVFF  558,FEC
044FE:  MOVFF  559,FEC
....................     
....................    //starting at the new current queue location, sort through the queue 
....................    //until the new item is in the right place 
....................    for (n = global_current_time_queue_location; n > 0; n--) 
04502:  MOVFF  39C,55B
04506:  MOVF   x5B,F
04508:  BTFSC  FD8.2
0450A:  BRA    46E4
....................    { 
....................       //if queue items are not sorted properly 
....................       if (global_time_queue[n].time_to_execute > global_time_queue[n-1].time_to_execute) 
0450C:  MOVF   x5B,W
0450E:  MULLW  05
04510:  MOVF   FF3,W
04512:  CLRF   x5D
04514:  MOVWF  x5C
04516:  MOVLW  83
04518:  ADDWF  x5C,W
0451A:  MOVWF  FE9
0451C:  MOVLW  03
0451E:  ADDWFC x5D,W
04520:  MOVWF  FEA
04522:  MOVFF  FEF,55E
04526:  MOVFF  FEC,55F
0452A:  MOVFF  FEC,560
0452E:  MOVFF  FEC,561
04532:  MOVLW  01
04534:  SUBWF  x5B,W
04536:  MULLW  05
04538:  MOVF   FF3,W
0453A:  CLRF   x63
0453C:  MOVWF  x62
0453E:  MOVLW  83
04540:  ADDWF  x62,W
04542:  MOVWF  FE9
04544:  MOVLW  03
04546:  ADDWFC x63,W
04548:  MOVWF  FEA
0454A:  MOVFF  FEF,00
0454E:  MOVFF  FEC,01
04552:  MOVFF  FEC,02
04556:  MOVFF  FEC,03
0455A:  MOVF   03,W
0455C:  SUBWF  x61,W
0455E:  BTFSS  FD8.0
04560:  BRA    46D6
04562:  BNZ   4580
04564:  MOVF   02,W
04566:  SUBWF  x60,W
04568:  BTFSS  FD8.0
0456A:  BRA    46D6
0456C:  BNZ   4580
0456E:  MOVF   01,W
04570:  SUBWF  x5F,W
04572:  BTFSS  FD8.0
04574:  BRA    46D6
04576:  BNZ   4580
04578:  MOVF   x5E,W
0457A:  SUBWF  00,W
0457C:  BTFSC  FD8.0
0457E:  BRA    46D6
....................       { 
....................          //do a swap reusing new queue item variable as a temp 
....................          priority = global_time_queue[n].pq_priority; 
04580:  MOVF   x5B,W
04582:  MULLW  05
04584:  MOVF   FF3,W
04586:  CLRF   x5D
04588:  MOVWF  x5C
0458A:  MOVLW  04
0458C:  ADDWF  x5C,W
0458E:  MOVWF  01
04590:  MOVLW  00
04592:  ADDWFC x5D,W
04594:  MOVWF  03
04596:  MOVF   01,W
04598:  ADDLW  83
0459A:  MOVWF  FE9
0459C:  MOVLW  03
0459E:  ADDWFC 03,W
045A0:  MOVWF  FEA
045A2:  MOVFF  FEF,55A
....................          global_time_queue[n].pq_priority = global_time_queue[n-1].pq_priority; 
045A6:  MOVF   x5B,W
045A8:  MULLW  05
045AA:  MOVF   FF3,W
045AC:  CLRF   x5D
045AE:  MOVWF  x5C
045B0:  MOVLW  04
045B2:  ADDWF  x5C,W
045B4:  MOVWF  01
045B6:  MOVLW  00
045B8:  ADDWFC x5D,W
045BA:  MOVWF  03
045BC:  MOVF   01,W
045BE:  ADDLW  83
045C0:  MOVWF  01
045C2:  MOVLW  03
045C4:  ADDWFC 03,F
045C6:  MOVFF  01,55C
045CA:  MOVFF  03,55D
045CE:  MOVLW  01
045D0:  SUBWF  x5B,W
045D2:  MULLW  05
045D4:  MOVF   FF3,W
045D6:  CLRF   x5F
045D8:  MOVWF  x5E
045DA:  MOVLW  04
045DC:  ADDWF  x5E,W
045DE:  MOVWF  01
045E0:  MOVLW  00
045E2:  ADDWFC x5F,W
045E4:  MOVWF  03
045E6:  MOVF   01,W
045E8:  ADDLW  83
045EA:  MOVWF  FE9
045EC:  MOVLW  03
045EE:  ADDWFC 03,W
045F0:  MOVWF  FEA
045F2:  MOVFF  FEF,55E
045F6:  MOVFF  55D,FEA
045FA:  MOVFF  55C,FE9
045FE:  MOVFF  55E,FEF
....................          global_time_queue[n-1].pq_priority = priority; 
04602:  MOVLW  01
04604:  SUBWF  x5B,W
04606:  MULLW  05
04608:  MOVF   FF3,W
0460A:  CLRF   x5D
0460C:  MOVWF  x5C
0460E:  MOVLW  04
04610:  ADDWF  x5C,W
04612:  MOVWF  01
04614:  MOVLW  00
04616:  ADDWFC x5D,W
04618:  MOVWF  03
0461A:  MOVF   01,W
0461C:  ADDLW  83
0461E:  MOVWF  FE9
04620:  MOVLW  03
04622:  ADDWFC 03,W
04624:  MOVWF  FEA
04626:  MOVFF  55A,FEF
....................          time_to_execute = global_time_queue[n].time_to_execute; 
0462A:  MOVF   x5B,W
0462C:  MULLW  05
0462E:  MOVF   FF3,W
04630:  CLRF   x5D
04632:  MOVWF  x5C
04634:  MOVLW  83
04636:  ADDWF  x5C,W
04638:  MOVWF  FE9
0463A:  MOVLW  03
0463C:  ADDWFC x5D,W
0463E:  MOVWF  FEA
04640:  MOVFF  FEF,556
04644:  MOVFF  FEC,557
04648:  MOVFF  FEC,558
0464C:  MOVFF  FEC,559
....................          global_time_queue[n].time_to_execute = global_time_queue[n-1].time_to_execute; 
04650:  MOVF   x5B,W
04652:  MULLW  05
04654:  MOVF   FF3,W
04656:  CLRF   x5D
04658:  MOVWF  x5C
0465A:  MOVLW  83
0465C:  ADDWF  x5C,W
0465E:  MOVWF  01
04660:  MOVLW  03
04662:  ADDWFC x5D,W
04664:  MOVWF  03
04666:  MOVFF  01,55E
0466A:  MOVWF  x5F
0466C:  MOVLW  01
0466E:  SUBWF  x5B,W
04670:  MULLW  05
04672:  MOVF   FF3,W
04674:  CLRF   x61
04676:  MOVWF  x60
04678:  MOVLW  83
0467A:  ADDWF  x60,W
0467C:  MOVWF  FE9
0467E:  MOVLW  03
04680:  ADDWFC x61,W
04682:  MOVWF  FEA
04684:  MOVFF  FEF,00
04688:  MOVFF  FEC,01
0468C:  MOVFF  FEC,02
04690:  MOVFF  FEC,03
04694:  MOVFF  55F,FEA
04698:  MOVFF  55E,FE9
0469C:  MOVFF  00,FEF
046A0:  MOVFF  01,FEC
046A4:  MOVFF  02,FEC
046A8:  MOVFF  03,FEC
....................          global_time_queue[n-1].time_to_execute = time_to_execute; 
046AC:  MOVLW  01
046AE:  SUBWF  x5B,W
046B0:  MULLW  05
046B2:  MOVF   FF3,W
046B4:  CLRF   x5D
046B6:  MOVWF  x5C
046B8:  MOVLW  83
046BA:  ADDWF  x5C,W
046BC:  MOVWF  FE9
046BE:  MOVLW  03
046C0:  ADDWFC x5D,W
046C2:  MOVWF  FEA
046C4:  MOVFF  556,FEF
046C8:  MOVFF  557,FEC
046CC:  MOVFF  558,FEC
046D0:  MOVFF  559,FEC
....................           
....................       } 
046D4:  BRA    46E0
....................       //item is in the proper place (assuming queue always sorted properly) 
....................       else 
....................       { 
....................          return 1; 
046D6:  MOVLW  01
046D8:  MOVWF  01
046DA:  MOVLB  3
046DC:  BRA    46EA
046DE:  MOVLB  5
....................       } 
046E0:  DECF   x5B,F
046E2:  BRA    4506
....................    } 
....................    return 1; 
046E4:  MOVLW  01
046E6:  MOVWF  01
046E8:  MOVLB  3
046EA:  MOVLB  0
046EC:  RETURN 0
.................... } 
....................  
.................... void push_time_queue_ISR(uint32_t time_to_execute, uint8_t priority) 
.................... // pushes a new item into the time queue and sorts it (by time). 
.................... // returns 1 if everything is good, 0 if queue is full 
.................... { 
....................    uint8_t n; 
....................       
....................    //if queue is full, return 0 
....................    if (global_current_time_queue_location == (MAX_TIME_QUEUE_ITEMS - 1)) 
*
01802:  MOVLB  3
01804:  MOVF   x9C,W
01806:  SUBLW  04
01808:  BNZ   180C
....................    { 
....................       return; 
0180A:  BRA    1A38
....................    } 
....................     
....................    // increment the time queue location and 
....................    // set the new item at the top of the queue (will be sorted in a sec) 
....................    global_current_time_queue_location++; 
0180C:  INCF   x9C,F
....................    global_time_queue[global_current_time_queue_location].pq_priority = priority; 
0180E:  MOVF   x9C,W
01810:  MULLW  05
01812:  MOVF   FF3,W
01814:  MOVLB  6
01816:  CLRF   x37
01818:  MOVWF  x36
0181A:  MOVLW  04
0181C:  ADDWF  x36,W
0181E:  MOVWF  01
01820:  MOVLW  00
01822:  ADDWFC x37,W
01824:  MOVWF  03
01826:  MOVF   01,W
01828:  ADDLW  83
0182A:  MOVWF  FE9
0182C:  MOVLW  03
0182E:  ADDWFC 03,W
01830:  MOVWF  FEA
01832:  MOVFF  634,FEF
....................    global_time_queue[global_current_time_queue_location].time_to_execute = time_to_execute; 
01836:  MOVLB  3
01838:  MOVF   x9C,W
0183A:  MULLW  05
0183C:  MOVF   FF3,W
0183E:  MOVLB  6
01840:  CLRF   x37
01842:  MOVWF  x36
01844:  MOVLW  83
01846:  ADDWF  x36,W
01848:  MOVWF  FE9
0184A:  MOVLW  03
0184C:  ADDWFC x37,W
0184E:  MOVWF  FEA
01850:  MOVFF  630,FEF
01854:  MOVFF  631,FEC
01858:  MOVFF  632,FEC
0185C:  MOVFF  633,FEC
....................        
....................    //starting at the new current queue location, sort through the queue 
....................    //until the new item is in the right place 
....................    for (n = global_current_time_queue_location; n > 0; n--) 
01860:  MOVFF  39C,635
01864:  MOVF   x35,F
01866:  BTFSC  FD8.2
01868:  BRA    1A36
....................    { 
....................       //if queue items are not sorted properly 
....................       if (global_time_queue[n].time_to_execute > global_time_queue[n-1].time_to_execute) 
0186A:  MOVF   x35,W
0186C:  MULLW  05
0186E:  MOVF   FF3,W
01870:  CLRF   x37
01872:  MOVWF  x36
01874:  MOVLW  83
01876:  ADDWF  x36,W
01878:  MOVWF  FE9
0187A:  MOVLW  03
0187C:  ADDWFC x37,W
0187E:  MOVWF  FEA
01880:  MOVFF  FEF,638
01884:  MOVFF  FEC,639
01888:  MOVFF  FEC,63A
0188C:  MOVFF  FEC,63B
01890:  MOVLW  01
01892:  SUBWF  x35,W
01894:  MULLW  05
01896:  MOVF   FF3,W
01898:  CLRF   x3D
0189A:  MOVWF  x3C
0189C:  MOVLW  83
0189E:  ADDWF  x3C,W
018A0:  MOVWF  FE9
018A2:  MOVLW  03
018A4:  ADDWFC x3D,W
018A6:  MOVWF  FEA
018A8:  MOVFF  FEF,00
018AC:  MOVFF  FEC,01
018B0:  MOVFF  FEC,02
018B4:  MOVFF  FEC,03
018B8:  MOVF   03,W
018BA:  SUBWF  x3B,W
018BC:  BTFSS  FD8.0
018BE:  BRA    1A32
018C0:  BNZ   18DE
018C2:  MOVF   02,W
018C4:  SUBWF  x3A,W
018C6:  BTFSS  FD8.0
018C8:  BRA    1A32
018CA:  BNZ   18DE
018CC:  MOVF   01,W
018CE:  SUBWF  x39,W
018D0:  BTFSS  FD8.0
018D2:  BRA    1A32
018D4:  BNZ   18DE
018D6:  MOVF   x38,W
018D8:  SUBWF  00,W
018DA:  BTFSC  FD8.0
018DC:  BRA    1A32
....................       { 
....................          //do a swap reusing new queue item variable as a temp 
....................          priority = global_time_queue[n].pq_priority; 
018DE:  MOVF   x35,W
018E0:  MULLW  05
018E2:  MOVF   FF3,W
018E4:  CLRF   x37
018E6:  MOVWF  x36
018E8:  MOVLW  04
018EA:  ADDWF  x36,W
018EC:  MOVWF  01
018EE:  MOVLW  00
018F0:  ADDWFC x37,W
018F2:  MOVWF  03
018F4:  MOVF   01,W
018F6:  ADDLW  83
018F8:  MOVWF  FE9
018FA:  MOVLW  03
018FC:  ADDWFC 03,W
018FE:  MOVWF  FEA
01900:  MOVFF  FEF,634
....................          global_time_queue[n].pq_priority = global_time_queue[n-1].pq_priority; 
01904:  MOVF   x35,W
01906:  MULLW  05
01908:  MOVF   FF3,W
0190A:  CLRF   x37
0190C:  MOVWF  x36
0190E:  MOVLW  04
01910:  ADDWF  x36,W
01912:  MOVWF  01
01914:  MOVLW  00
01916:  ADDWFC x37,W
01918:  MOVWF  03
0191A:  MOVF   01,W
0191C:  ADDLW  83
0191E:  MOVWF  01
01920:  MOVLW  03
01922:  ADDWFC 03,F
01924:  MOVFF  01,636
01928:  MOVFF  03,637
0192C:  MOVLW  01
0192E:  SUBWF  x35,W
01930:  MULLW  05
01932:  MOVF   FF3,W
01934:  CLRF   x39
01936:  MOVWF  x38
01938:  MOVLW  04
0193A:  ADDWF  x38,W
0193C:  MOVWF  01
0193E:  MOVLW  00
01940:  ADDWFC x39,W
01942:  MOVWF  03
01944:  MOVF   01,W
01946:  ADDLW  83
01948:  MOVWF  FE9
0194A:  MOVLW  03
0194C:  ADDWFC 03,W
0194E:  MOVWF  FEA
01950:  MOVFF  FEF,638
01954:  MOVFF  637,FEA
01958:  MOVFF  636,FE9
0195C:  MOVFF  638,FEF
....................          global_time_queue[n-1].pq_priority = priority; 
01960:  MOVLW  01
01962:  SUBWF  x35,W
01964:  MULLW  05
01966:  MOVF   FF3,W
01968:  CLRF   x37
0196A:  MOVWF  x36
0196C:  MOVLW  04
0196E:  ADDWF  x36,W
01970:  MOVWF  01
01972:  MOVLW  00
01974:  ADDWFC x37,W
01976:  MOVWF  03
01978:  MOVF   01,W
0197A:  ADDLW  83
0197C:  MOVWF  FE9
0197E:  MOVLW  03
01980:  ADDWFC 03,W
01982:  MOVWF  FEA
01984:  MOVFF  634,FEF
....................          time_to_execute = global_time_queue[n].time_to_execute; 
01988:  MOVF   x35,W
0198A:  MULLW  05
0198C:  MOVF   FF3,W
0198E:  CLRF   x37
01990:  MOVWF  x36
01992:  MOVLW  83
01994:  ADDWF  x36,W
01996:  MOVWF  FE9
01998:  MOVLW  03
0199A:  ADDWFC x37,W
0199C:  MOVWF  FEA
0199E:  MOVFF  FEF,630
019A2:  MOVFF  FEC,631
019A6:  MOVFF  FEC,632
019AA:  MOVFF  FEC,633
....................          global_time_queue[n].time_to_execute = global_time_queue[n-1].time_to_execute; 
019AE:  MOVF   x35,W
019B0:  MULLW  05
019B2:  MOVF   FF3,W
019B4:  CLRF   x37
019B6:  MOVWF  x36
019B8:  MOVLW  83
019BA:  ADDWF  x36,W
019BC:  MOVWF  01
019BE:  MOVLW  03
019C0:  ADDWFC x37,W
019C2:  MOVWF  03
019C4:  MOVFF  01,638
019C8:  MOVWF  x39
019CA:  MOVLW  01
019CC:  SUBWF  x35,W
019CE:  MULLW  05
019D0:  MOVF   FF3,W
019D2:  CLRF   x3B
019D4:  MOVWF  x3A
019D6:  MOVLW  83
019D8:  ADDWF  x3A,W
019DA:  MOVWF  FE9
019DC:  MOVLW  03
019DE:  ADDWFC x3B,W
019E0:  MOVWF  FEA
019E2:  MOVFF  FEF,00
019E6:  MOVFF  FEC,01
019EA:  MOVFF  FEC,02
019EE:  MOVFF  FEC,03
019F2:  MOVFF  639,FEA
019F6:  MOVFF  638,FE9
019FA:  MOVFF  00,FEF
019FE:  MOVFF  01,FEC
01A02:  MOVFF  02,FEC
01A06:  MOVFF  03,FEC
....................          global_time_queue[n-1].time_to_execute = time_to_execute; 
01A0A:  MOVLW  01
01A0C:  SUBWF  x35,W
01A0E:  MULLW  05
01A10:  MOVF   FF3,W
01A12:  CLRF   x37
01A14:  MOVWF  x36
01A16:  MOVLW  83
01A18:  ADDWF  x36,W
01A1A:  MOVWF  FE9
01A1C:  MOVLW  03
01A1E:  ADDWFC x37,W
01A20:  MOVWF  FEA
01A22:  MOVFF  630,FEF
01A26:  MOVFF  631,FEC
01A2A:  MOVFF  632,FEC
01A2E:  MOVFF  633,FEC
....................           
....................       } 
01A32:  DECF   x35,F
01A34:  BRA    1864
01A36:  MOVLB  3
....................    } 
....................    return; 
01A38:  MOVLB  0
01A3A:  RETURN 0
.................... } 
....................  
.................... void allocate_command_queue(void) 
.................... { 
....................    // allocate the memory for the command queue sprinkler zone settings (can't 
....................    //    easily make a struct array inside a struct in c.) 
....................  
....................    uint8_t n; 
....................     
....................    for (n = 0; n < MAX_COMMAND_QUEUE_ITEMS; n++) 
....................    { 
....................       global_command_queue[n].sprinkler_settings =                            \ 
....................       (struct SprinklerZoneSettingsItem*)                                     \ 
....................       malloc(sizeof (struct SprinklerZoneSettingsItem) * MAX_NUM_SPRINKLER_ZONES); 
....................    } 
.................... } 
....................  
.................... void clear_command_queue(void) 
.................... { 
....................    // clears out the command queue and sets the start times to 0-1 
....................    uint8_t n; 
....................     
....................    // clear the queue compeleted and fill with zeros 
....................    memset(global_command_queue, 0, sizeof global_command_queue); 
....................     
....................    // sets start times to 0-1 (for unsigned int) 
....................    for (n = 0; n < MAX_COMMAND_QUEUE_ITEMS; n++) 
....................    { 
....................       global_command_queue[n].start_time = 0-1; 
....................    } 
....................     
....................    // set the queue location to 0-1 which signifies that there isn't anything 
....................    //    in the queue 
....................    global_current_command_queue_location = 0-1; 
.................... } 
....................  
.................... int1 push_command_queue(struct CommandQueueItem new_command_queue_item) 
.................... // pushes a new item into the command queue and sorts it (by time). 
.................... // returns 1 if everything is good, 0 if queue is full 
.................... { 
....................    uint8_t n; 
....................     
....................    //if queue is full, return 0 
....................    if (global_current_command_queue_location == (MAX_COMMAND_QUEUE_ITEMS - 1)) 
....................    { 
....................       return 0; 
....................    } 
....................     
....................    // increment the command queue location and 
....................    // set the new item at the top of the queue (will be sorted in a sec) 
....................    global_current_command_queue_location++; 
....................    global_command_queue[global_current_command_queue_location] = new_command_queue_item; 
....................     
....................    //starting at the new current queue location, sort through the queue 
....................    //until the new item is in the right place 
....................    for (n = global_current_command_queue_location; n > 0; n--) 
....................    { 
....................       //if queue items are not sorted properly 
....................       if (global_command_queue[n].start_time > global_command_queue[n-1].start_time) 
....................       { 
....................          //do a swap reusing new queue item variable as a temp 
....................          new_command_queue_item = global_time_queue[n]; 
....................          global_time_queue[n] = global_time_queue[n-1]; 
....................          global_time_queue[n-1] = new_command_queue_item; 
....................       } 
....................       //item is in the proper place (assuming queue always sorted properly) 
....................       else 
....................       { 
....................          return 1; 
....................       } 
....................    } 
....................    return 1; 
.................... } 
....................  
.................... void pop_command_queue_ISR() 
.................... // pops a new item off the command queue and sorts it (by time). 
.................... // returns 1 if everything is good, 0 if queue is full 
.................... { 
....................    uint8_t n; 
....................    struct commandQueueItem new_command_queue_item; 
....................     
....................    //if queue is empty, return 0 
....................    if (global_current_command_queue_location == 255) 
....................    { 
....................       return; 
....................    } 
....................     
....................     
....................    // increment the command queue location and 
....................    // set the new item at the top of the queue (will be sorted in a sec) 
....................    global_current_command_queue_location++; 
....................    global_command_queue[global_current_command_queue_location] = new_command_queue_item; 
....................     
....................    //starting at the new current queue location, sort through the queue 
....................    //until the new item is in the right place 
....................    for (n = global_current_command_queue_location; n > 0; n--) 
....................    { 
....................       //if queue items are not sorted properly 
....................       if (global_command_queue[n].start_time > global_command_queue[n-1].start_time) 
....................       { 
....................          //do a swap reusing new queue item variable as a temp 
....................          new_command_queue_item = global_time_queue[n]; 
....................          global_time_queue[n] = global_time_queue[n-1]; 
....................          global_time_queue[n-1] = new_command_queue_item; 
....................       } 
....................       //item is in the proper place (assuming queue always sorted properly) 
....................       else 
....................       { 
....................          return; 
....................       } 
....................    } 
....................    return; 
.................... } 
.................... void clear_sprinkler_queue() 
.................... { 
....................    disable_interrupts(INT_CCP4); 
*
055B2:  BCF    F7A.1
....................    memset(&global_sprinkler_queue, EMPTY_SPINKLER_QUEUE, sizeof(global_sprinkler_queue)); 
055B4:  MOVLW  03
055B6:  MOVWF  FEA
055B8:  MOVLW  9D
055BA:  MOVWF  FE9
055BC:  CLRF   00
055BE:  CLRF   02
055C0:  MOVLW  8C
055C2:  MOVWF  01
055C4:  CALL   22BE
....................    global_current_sprinkler_queue_location = 0-1; 
055C8:  MOVLB  4
055CA:  SETF   x29
....................    global_rpm_set_value = 0; 
055CC:  MOVLB  0
055CE:  CLRF   xAD
055D0:  CLRF   xAC
....................    global_control_loop_mechanism = NO_RPM_CONTROL; 
055D2:  MOVLW  05
055D4:  MOVWF  xC0
....................    enable_interrupts(INT_CCP4); 
055D6:  BSF    F7A.1
055D8:  RETURN 0
.................... } 
....................  
.................... void push_sprinkler_queue(uint32_t start_time,uint32_t end_time,uint16_t vlv_open_amount,uint16_t spin_rate,uint8_t zone_num, uint8_t control_loop_mechanism) 
.................... // pushes a new item into the sprinkler queue and sorts it (by start time). 
.................... // returns 1 if everything is good, 0 if queue is full 
.................... { 
....................    uint8_t n; 
....................    struct SprinklerQueueItem temp_sprinkler_queue_item; 
....................     
....................    // disable CCP4 interrupt (RTC timer) 
....................    disable_interrupts(INT_CCP4); 
*
06E5A:  BCF    F7A.1
....................           
....................    //if queue is full, return 0 
....................    if (global_current_sprinkler_queue_location == (MAX_SPRINKLER_QUEUE_ITEMS - 1)) 
06E5C:  MOVLB  4
06E5E:  MOVF   x29,W
06E60:  SUBLW  09
06E62:  BNZ   6E68
....................    { 
....................       enable_interrupts(INT_CCP4); 
06E64:  BSF    F7A.1
....................       return; 
06E66:  BRA    7094
....................    } 
....................     
....................    // increment the sprinkler queue location and 
....................    // set the new item at the top of the queue (will be sorted in a sec) 
....................    global_current_sprinkler_queue_location++; 
06E68:  INCF   x29,F
....................    global_sprinkler_queue[global_current_sprinkler_queue_location].start_time = start_time; 
06E6A:  MOVF   x29,W
06E6C:  MULLW  0E
06E6E:  MOVF   FF3,W
06E70:  MOVLB  5
06E72:  CLRF   x7C
06E74:  MOVWF  x7B
06E76:  MOVLW  9D
06E78:  ADDWF  x7B,W
06E7A:  MOVWF  FE9
06E7C:  MOVLW  03
06E7E:  ADDWFC x7C,W
06E80:  MOVWF  FEA
06E82:  MOVFF  55E,FEF
06E86:  MOVFF  55F,FEC
06E8A:  MOVFF  560,FEC
06E8E:  MOVFF  561,FEC
....................    global_sprinkler_queue[global_current_sprinkler_queue_location].end_time = end_time; 
06E92:  MOVLB  4
06E94:  MOVF   x29,W
06E96:  MULLW  0E
06E98:  MOVF   FF3,W
06E9A:  MOVLB  5
06E9C:  CLRF   x7C
06E9E:  MOVWF  x7B
06EA0:  MOVLW  04
06EA2:  ADDWF  x7B,W
06EA4:  MOVWF  01
06EA6:  MOVLW  00
06EA8:  ADDWFC x7C,W
06EAA:  MOVWF  03
06EAC:  MOVF   01,W
06EAE:  ADDLW  9D
06EB0:  MOVWF  FE9
06EB2:  MOVLW  03
06EB4:  ADDWFC 03,W
06EB6:  MOVWF  FEA
06EB8:  MOVFF  562,FEF
06EBC:  MOVFF  563,FEC
06EC0:  MOVFF  564,FEC
06EC4:  MOVFF  565,FEC
....................    global_sprinkler_queue[global_current_sprinkler_queue_location].vlv_open_amount = vlv_open_amount; 
06EC8:  MOVLB  4
06ECA:  MOVF   x29,W
06ECC:  MULLW  0E
06ECE:  MOVF   FF3,W
06ED0:  MOVLB  5
06ED2:  CLRF   x7C
06ED4:  MOVWF  x7B
06ED6:  MOVLW  08
06ED8:  ADDWF  x7B,W
06EDA:  MOVWF  01
06EDC:  MOVLW  00
06EDE:  ADDWFC x7C,W
06EE0:  MOVWF  03
06EE2:  MOVF   01,W
06EE4:  ADDLW  9D
06EE6:  MOVWF  FE9
06EE8:  MOVLW  03
06EEA:  ADDWFC 03,W
06EEC:  MOVWF  FEA
06EEE:  MOVFF  567,FEC
06EF2:  MOVF   FED,F
06EF4:  MOVFF  566,FEF
....................    global_sprinkler_queue[global_current_sprinkler_queue_location].spin_rate = spin_rate; 
06EF8:  MOVLB  4
06EFA:  MOVF   x29,W
06EFC:  MULLW  0E
06EFE:  MOVF   FF3,W
06F00:  MOVLB  5
06F02:  CLRF   x7C
06F04:  MOVWF  x7B
06F06:  MOVLW  0A
06F08:  ADDWF  x7B,W
06F0A:  MOVWF  01
06F0C:  MOVLW  00
06F0E:  ADDWFC x7C,W
06F10:  MOVWF  03
06F12:  MOVF   01,W
06F14:  ADDLW  9D
06F16:  MOVWF  FE9
06F18:  MOVLW  03
06F1A:  ADDWFC 03,W
06F1C:  MOVWF  FEA
06F1E:  MOVFF  569,FEC
06F22:  MOVF   FED,F
06F24:  MOVFF  568,FEF
....................    global_sprinkler_queue[global_current_sprinkler_queue_location].zone_num = zone_num; 
06F28:  MOVLB  4
06F2A:  MOVF   x29,W
06F2C:  MULLW  0E
06F2E:  MOVF   FF3,W
06F30:  MOVLB  5
06F32:  CLRF   x7C
06F34:  MOVWF  x7B
06F36:  MOVLW  0C
06F38:  ADDWF  x7B,W
06F3A:  MOVWF  01
06F3C:  MOVLW  00
06F3E:  ADDWFC x7C,W
06F40:  MOVWF  03
06F42:  MOVF   01,W
06F44:  ADDLW  9D
06F46:  MOVWF  FE9
06F48:  MOVLW  03
06F4A:  ADDWFC 03,W
06F4C:  MOVWF  FEA
06F4E:  MOVFF  56A,FEF
....................    global_sprinkler_queue[global_current_sprinkler_queue_location].control_loop_mechanism = control_loop_mechanism; 
06F52:  MOVLB  4
06F54:  MOVF   x29,W
06F56:  MULLW  0E
06F58:  MOVF   FF3,W
06F5A:  MOVLB  5
06F5C:  CLRF   x7C
06F5E:  MOVWF  x7B
06F60:  MOVLW  0D
06F62:  ADDWF  x7B,W
06F64:  MOVWF  01
06F66:  MOVLW  00
06F68:  ADDWFC x7C,W
06F6A:  MOVWF  03
06F6C:  MOVF   01,W
06F6E:  ADDLW  9D
06F70:  MOVWF  FE9
06F72:  MOVLW  03
06F74:  ADDWFC 03,W
06F76:  MOVWF  FEA
06F78:  MOVFF  56B,FEF
....................     
....................     
....................    //starting at the new current queue location, sort through the queue 
....................    //until the new item is in the right place 
....................    for (n = global_current_sprinkler_queue_location; n > 0; n--) 
06F7C:  MOVFF  429,56C
06F80:  MOVF   x6C,F
06F82:  BTFSC  FD8.2
06F84:  BRA    7090
....................    { 
....................       //if queue items are not sorted properly 
....................       if (global_sprinkler_queue[n].start_time > global_sprinkler_queue[n-1].start_time) 
06F86:  MOVF   x6C,W
06F88:  MULLW  0E
06F8A:  MOVF   FF3,W
06F8C:  CLRF   x7C
06F8E:  MOVWF  x7B
06F90:  MOVLW  9D
06F92:  ADDWF  x7B,W
06F94:  MOVWF  FE9
06F96:  MOVLW  03
06F98:  ADDWFC x7C,W
06F9A:  MOVWF  FEA
06F9C:  MOVFF  FEF,57D
06FA0:  MOVFF  FEC,57E
06FA4:  MOVFF  FEC,57F
06FA8:  MOVFF  FEC,580
06FAC:  MOVLW  01
06FAE:  SUBWF  x6C,W
06FB0:  MULLW  0E
06FB2:  MOVF   FF3,W
06FB4:  CLRF   x82
06FB6:  MOVWF  x81
06FB8:  MOVLW  9D
06FBA:  ADDWF  x81,W
06FBC:  MOVWF  FE9
06FBE:  MOVLW  03
06FC0:  ADDWFC x82,W
06FC2:  MOVWF  FEA
06FC4:  MOVFF  FEF,00
06FC8:  MOVFF  FEC,01
06FCC:  MOVFF  FEC,02
06FD0:  MOVFF  FEC,03
06FD4:  MOVF   03,W
06FD6:  SUBWF  x80,W
06FD8:  BNC   7084
06FDA:  BNZ   6FF2
06FDC:  MOVF   02,W
06FDE:  SUBWF  x7F,W
06FE0:  BNC   7084
06FE2:  BNZ   6FF2
06FE4:  MOVF   01,W
06FE6:  SUBWF  x7E,W
06FE8:  BNC   7084
06FEA:  BNZ   6FF2
06FEC:  MOVF   x7D,W
06FEE:  SUBWF  00,W
06FF0:  BC    7084
....................       { 
....................          //do a swap reusing new queue item variable as a temp 
....................          memcpy(&temp_sprinkler_queue_item, &global_sprinkler_queue[n], sizeof(&temp_sprinkler_queue_item)); 
06FF2:  MOVF   x6C,W
06FF4:  MULLW  0E
06FF6:  MOVF   FF3,W
06FF8:  CLRF   03
06FFA:  ADDLW  9D
06FFC:  MOVWF  01
06FFE:  MOVLW  03
07000:  ADDWFC 03,F
07002:  MOVFF  03,FE2
07006:  MOVFF  01,FE1
0700A:  MOVFF  FE6,56D
0700E:  MOVFF  FE6,56E
....................          memcpy(&global_sprinkler_queue[n], &global_sprinkler_queue[n-1], sizeof(&global_sprinkler_queue[n])); 
07012:  MOVF   x6C,W
07014:  MULLW  0E
07016:  MOVF   FF3,W
07018:  CLRF   03
0701A:  ADDLW  9D
0701C:  MOVWF  01
0701E:  MOVLW  03
07020:  ADDWFC 03,F
07022:  MOVFF  01,57B
07026:  MOVFF  03,57C
0702A:  MOVLW  01
0702C:  SUBWF  x6C,W
0702E:  MULLW  0E
07030:  MOVF   FF3,W
07032:  CLRF   03
07034:  ADDLW  9D
07036:  MOVWF  01
07038:  MOVLW  03
0703A:  ADDWFC 03,F
0703C:  MOVFF  01,57D
07040:  MOVFF  03,57E
07044:  MOVFF  57C,FEA
07048:  MOVFF  57B,FE9
0704C:  MOVFF  03,FE2
07050:  MOVFF  01,FE1
07054:  MOVLW  02
07056:  MOVWF  01
07058:  MOVFF  FE6,FEE
0705C:  DECFSZ 01,F
0705E:  BRA    7058
....................          memcpy(&global_sprinkler_queue[n-1], &temp_sprinkler_queue_item, sizeof(&global_sprinkler_queue[n-1])); 
07060:  MOVLW  01
07062:  SUBWF  x6C,W
07064:  MULLW  0E
07066:  MOVF   FF3,W
07068:  CLRF   03
0706A:  ADDLW  9D
0706C:  MOVWF  01
0706E:  MOVLW  03
07070:  ADDWFC 03,F
07072:  MOVFF  03,FEA
07076:  MOVFF  01,FE9
0707A:  MOVFF  56D,FEE
0707E:  MOVFF  56E,FEE
....................           
....................       } 
07082:  BRA    708C
....................       //item is in the proper place (assuming queue always sorted properly) 
....................       else 
....................       { 
....................          enable_interrupts(INT_CCP4); 
07084:  BSF    F7A.1
....................          return; 
07086:  MOVLB  4
07088:  BRA    7094
0708A:  MOVLB  5
....................       } 
0708C:  DECF   x6C,F
0708E:  BRA    6F80
....................    } 
....................    enable_interrupts(INT_CCP4); 
07090:  BSF    F7A.1
07092:  MOVLB  4
....................    return; 
07094:  MOVLB  0
07096:  RETURN 0
.................... } 
....................  
.................... void pop_sprinkler_queue_ISR(void) 
.................... // Checks the sprinkler queue and sets the sprinkler settings of the item on the top of the queue 
.................... { 
....................    //no items in the queue (current location is 0-1) 
....................    if (global_current_sprinkler_queue_location == 255) 
*
02C3A:  MOVLB  4
02C3C:  INCFSZ x29,W
02C3E:  BRA    2C44
....................    { 
....................       return; 
02C40:  BRA    2E42
....................    } 
02C42:  BRA    2E42
....................    // pop top item off queue and onto actual settings 
....................    else 
....................    { 
....................       //erase the current command start time (only important thing) and decrement the current queue location 
....................       global_sprinkler_queue[global_current_sprinkler_queue_location].start_time = 0-1; 
02C44:  MOVF   x29,W
02C46:  MULLW  0E
02C48:  MOVF   FF3,W
02C4A:  MOVLB  5
02C4C:  CLRF   xF9
02C4E:  MOVWF  xF8
02C50:  MOVLW  9D
02C52:  ADDWF  xF8,W
02C54:  MOVWF  FE9
02C56:  MOVLW  03
02C58:  ADDWFC xF9,W
02C5A:  MOVWF  FEA
02C5C:  SETF   00
02C5E:  SETF   01
02C60:  SETF   02
02C62:  SETF   03
02C64:  MOVFF  00,FEF
02C68:  MOVFF  01,FEC
02C6C:  MOVFF  02,FEC
02C70:  MOVFF  03,FEC
....................       global_current_sprinkler_settings_end_time = global_sprinkler_queue[global_current_sprinkler_queue_location].end_time; 
02C74:  MOVLB  4
02C76:  MOVF   x29,W
02C78:  MULLW  0E
02C7A:  MOVF   FF3,W
02C7C:  MOVLB  5
02C7E:  CLRF   xF9
02C80:  MOVWF  xF8
02C82:  MOVLW  04
02C84:  ADDWF  xF8,W
02C86:  MOVWF  01
02C88:  MOVLW  00
02C8A:  ADDWFC xF9,W
02C8C:  MOVWF  03
02C8E:  MOVF   01,W
02C90:  ADDLW  9D
02C92:  MOVWF  FE9
02C94:  MOVLW  03
02C96:  ADDWFC 03,W
02C98:  MOVWF  FEA
02C9A:  MOVFF  FEF,42A
02C9E:  MOVFF  FEC,42B
02CA2:  MOVFF  FEC,42C
02CA6:  MOVFF  FEC,42D
....................       global_sprinkler_queue[global_current_sprinkler_queue_location].end_time = 0; 
02CAA:  MOVLB  4
02CAC:  MOVF   x29,W
02CAE:  MULLW  0E
02CB0:  MOVF   FF3,W
02CB2:  MOVLB  5
02CB4:  CLRF   xF9
02CB6:  MOVWF  xF8
02CB8:  MOVLW  04
02CBA:  ADDWF  xF8,W
02CBC:  MOVWF  01
02CBE:  MOVLW  00
02CC0:  ADDWFC xF9,W
02CC2:  MOVWF  03
02CC4:  MOVF   01,W
02CC6:  ADDLW  9D
02CC8:  MOVWF  FE9
02CCA:  MOVLW  03
02CCC:  ADDWFC 03,W
02CCE:  MOVWF  FEA
02CD0:  MOVF   FEE,F
02CD2:  MOVF   FEE,F
02CD4:  CLRF   FEC
02CD6:  MOVF   FED,F
02CD8:  CLRF   FEF
02CDA:  MOVF   FED,F
02CDC:  CLRF   FEF
02CDE:  MOVF   FED,F
02CE0:  CLRF   FEF
....................       global_valve_position_set_value = global_sprinkler_queue[global_current_sprinkler_queue_location].vlv_open_amount; 
02CE2:  MOVLB  4
02CE4:  MOVF   x29,W
02CE6:  MULLW  0E
02CE8:  MOVF   FF3,W
02CEA:  MOVLB  5
02CEC:  CLRF   xF9
02CEE:  MOVWF  xF8
02CF0:  MOVLW  08
02CF2:  ADDWF  xF8,W
02CF4:  MOVWF  01
02CF6:  MOVLW  00
02CF8:  ADDWFC xF9,W
02CFA:  MOVWF  03
02CFC:  MOVF   01,W
02CFE:  ADDLW  9D
02D00:  MOVWF  FE9
02D02:  MOVLW  03
02D04:  ADDWFC 03,W
02D06:  MOVWF  FEA
02D08:  MOVFF  FEC,C4
02D0C:  MOVF   FED,F
02D0E:  MOVFF  FEF,C3
....................       global_sprinkler_queue[global_current_sprinkler_queue_location].vlv_open_amount = 0; 
02D12:  MOVLB  4
02D14:  MOVF   x29,W
02D16:  MULLW  0E
02D18:  MOVF   FF3,W
02D1A:  MOVLB  5
02D1C:  CLRF   xF9
02D1E:  MOVWF  xF8
02D20:  MOVLW  08
02D22:  ADDWF  xF8,W
02D24:  MOVWF  01
02D26:  MOVLW  00
02D28:  ADDWFC xF9,W
02D2A:  MOVWF  03
02D2C:  MOVF   01,W
02D2E:  ADDLW  9D
02D30:  MOVWF  FE9
02D32:  MOVLW  03
02D34:  ADDWFC 03,W
02D36:  MOVWF  FEA
02D38:  CLRF   FEC
02D3A:  MOVF   FED,F
02D3C:  CLRF   FEF
....................       push_time_queue_ISR(global_rtc_time + 3, MOVE_VALVE); 
02D3E:  MOVLW  03
02D40:  MOVLB  0
02D42:  ADDWF  x85,W
02D44:  MOVLB  5
02D46:  MOVWF  xF8
02D48:  MOVLW  00
02D4A:  MOVLB  0
02D4C:  ADDWFC x86,W
02D4E:  MOVLB  5
02D50:  MOVWF  xF9
02D52:  MOVLW  00
02D54:  MOVLB  0
02D56:  ADDWFC x87,W
02D58:  MOVLB  5
02D5A:  MOVWF  xFA
02D5C:  MOVLW  00
02D5E:  MOVLB  0
02D60:  ADDWFC x88,W
02D62:  MOVLB  5
02D64:  MOVWF  xFB
02D66:  CLRF   19
02D68:  BTFSC  FF2.7
02D6A:  BSF    19.7
02D6C:  BCF    FF2.7
02D6E:  MOVFF  FE8,633
02D72:  MOVFF  5FA,632
02D76:  MOVFF  5F9,631
02D7A:  MOVFF  5F8,630
02D7E:  MOVLW  40
02D80:  MOVLB  6
02D82:  MOVWF  x34
02D84:  MOVLB  0
02D86:  CALL   1802
02D8A:  BTFSC  19.7
02D8C:  BSF    FF2.7
....................       global_rpm_set_value = global_sprinkler_queue[global_current_sprinkler_queue_location].spin_rate; 
02D8E:  MOVLB  4
02D90:  MOVF   x29,W
02D92:  MULLW  0E
02D94:  MOVF   FF3,W
02D96:  MOVLB  5
02D98:  CLRF   xF9
02D9A:  MOVWF  xF8
02D9C:  MOVLW  0A
02D9E:  ADDWF  xF8,W
02DA0:  MOVWF  01
02DA2:  MOVLW  00
02DA4:  ADDWFC xF9,W
02DA6:  MOVWF  03
02DA8:  MOVF   01,W
02DAA:  ADDLW  9D
02DAC:  MOVWF  FE9
02DAE:  MOVLW  03
02DB0:  ADDWFC 03,W
02DB2:  MOVWF  FEA
02DB4:  MOVFF  FEC,AD
02DB8:  MOVF   FED,F
02DBA:  MOVFF  FEF,AC
....................       global_sprinkler_queue[global_current_sprinkler_queue_location].spin_rate = 0; 
02DBE:  MOVLB  4
02DC0:  MOVF   x29,W
02DC2:  MULLW  0E
02DC4:  MOVF   FF3,W
02DC6:  MOVLB  5
02DC8:  CLRF   xF9
02DCA:  MOVWF  xF8
02DCC:  MOVLW  0A
02DCE:  ADDWF  xF8,W
02DD0:  MOVWF  01
02DD2:  MOVLW  00
02DD4:  ADDWFC xF9,W
02DD6:  MOVWF  03
02DD8:  MOVF   01,W
02DDA:  ADDLW  9D
02DDC:  MOVWF  FE9
02DDE:  MOVLW  03
02DE0:  ADDWFC 03,W
02DE2:  MOVWF  FEA
02DE4:  CLRF   FEC
02DE6:  MOVF   FED,F
02DE8:  CLRF   FEF
....................       //global_sprinkler_queue[global_current_sprinkler_queue_location].zone_num; 
....................       global_control_loop_mechanism = global_sprinkler_queue[global_current_sprinkler_queue_location].control_loop_mechanism; 
02DEA:  MOVLB  4
02DEC:  MOVF   x29,W
02DEE:  MULLW  0E
02DF0:  MOVF   FF3,W
02DF2:  MOVLB  5
02DF4:  CLRF   xF9
02DF6:  MOVWF  xF8
02DF8:  MOVLW  0D
02DFA:  ADDWF  xF8,W
02DFC:  MOVWF  01
02DFE:  MOVLW  00
02E00:  ADDWFC xF9,W
02E02:  MOVWF  03
02E04:  MOVF   01,W
02E06:  ADDLW  9D
02E08:  MOVWF  FE9
02E0A:  MOVLW  03
02E0C:  ADDWFC 03,W
02E0E:  MOVWF  FEA
02E10:  MOVFF  FEF,C0
....................       global_sprinkler_queue[global_current_sprinkler_queue_location].control_loop_mechanism = NO_RPM_CONTROL_DYN_MPPC; 
02E14:  MOVLB  4
02E16:  MOVF   x29,W
02E18:  MULLW  0E
02E1A:  MOVF   FF3,W
02E1C:  MOVLB  5
02E1E:  CLRF   xF9
02E20:  MOVWF  xF8
02E22:  MOVLW  0D
02E24:  ADDWF  xF8,W
02E26:  MOVWF  01
02E28:  MOVLW  00
02E2A:  ADDWFC xF9,W
02E2C:  MOVWF  03
02E2E:  MOVF   01,W
02E30:  ADDLW  9D
02E32:  MOVWF  FE9
02E34:  MOVLW  03
02E36:  ADDWFC 03,W
02E38:  MOVWF  FEA
02E3A:  MOVLW  06
02E3C:  MOVWF  FEF
....................       global_current_sprinkler_queue_location--; 
02E3E:  MOVLB  4
02E40:  DECF   x29,F
....................        
....................       return; 
....................    } 
02E42:  MOVLB  0
02E44:  GOTO   308C (RETURN)
.................... } 
....................  
.................... void clear_message_queue(void) 
.................... { 
....................    // disable conflicting interrupts 
....................    disable_interrupts(INT_CCP4);     
*
04244:  BCF    F7A.1
....................    memset(&global_message_queue, EMPTY_MESSAGE_QUEUE, sizeof(global_message_queue)); 
04246:  MOVLW  04
04248:  MOVWF  FEA
0424A:  MOVLW  A7
0424C:  MOVWF  FE9
0424E:  CLRF   00
04250:  CLRF   02
04252:  MOVLW  50
04254:  MOVWF  01
04256:  CALL   22BE
....................    // disable conflicting interrupts 
....................    disable_interrupts(INT_CCP4); 
0425A:  BCF    F7A.1
0425C:  GOTO   A430 (RETURN)
.................... } 
....................  
.................... void pop_message_queue_and_send_ISR(void)  
.................... // Sends the top of the message queue out, re-adds it to the message stack with a 
.................... //    later send time (and attempt number) and sorts it properly.  Since this is 
.................... //    only called out of CCP4, all functions are ISR functions 
.................... {                       
....................     
....................    uint8_t n;                                                    
....................    struct MessageQueueItem temp_message_queue_item;        
....................  
....................    // no items in the queue (current location is 0-1) 
....................    if (global_current_message_queue_location == 255) 
*
028B0:  MOVLB  4
028B2:  INCFSZ xF7,W
028B4:  BRA    28BA
....................    { 
....................       return;   
028B6:  BRA    2C34
....................    } 
028B8:  BRA    2C34
....................    else 
....................    {              
....................       // If it has met or exceeded the maximum number of attempts, delete it off the queue, 
....................       //    set an error bit, and queue an error message. Attempt num is counted from 0 
....................       if (global_message_queue[global_current_message_queue_location].attempt_num >= (MAX_UNSOLICITED_MESSAGE_ATTEMPTS)) 
028BA:  MOVF   xF7,W
028BC:  MULLW  08
028BE:  MOVF   FF3,W
028C0:  MOVLB  6
028C2:  CLRF   x02
028C4:  MOVWF  x01
028C6:  MOVLW  07
028C8:  ADDWF  x01,W
028CA:  MOVWF  01
028CC:  MOVLW  00
028CE:  ADDWFC x02,W
028D0:  MOVWF  03
028D2:  MOVF   01,W
028D4:  ADDLW  A7
028D6:  MOVWF  FE9
028D8:  MOVLW  04
028DA:  ADDWFC 03,W
028DC:  MOVWF  FEA
028DE:  MOVF   FEF,W
028E0:  SUBLW  02
028E2:  BC    2904
....................       { 
....................          remove_message_queue_item_ISR(mote_msgSEQ); 
028E4:  MOVFF  366,602
028E8:  MOVFF  365,601
028EC:  MOVLB  0
028EE:  BRA    22D8
....................          // set an error bit saying a message was missed 
....................          global_error_message_bitfield |= ERR_MSG_UNSOLICITED_MESSAGE_NOT_ACKD; 
028F0:  MOVLB  4
028F2:  BSF    xF8.0
....................          push_message_queue_ISR(MSG_MOTE_ERROR_MSG); 
028F4:  MOVLW  A0
028F6:  MOVLB  6
028F8:  MOVWF  x14
028FA:  MOVLB  0
028FC:  CALL   0C26
....................       } 
02900:  BRA    2C32
02902:  MOVLB  6
....................       // regular message (not @ max attempts)    
....................       else 
....................       {                
....................          // what message type?  
....................          // resend with unsolicited (0x00 identifier) and it's current message seq 
....................          switch(global_message_queue[global_current_message_queue_location].message_type) 
02904:  MOVLB  4
02906:  MOVF   xF7,W
02908:  MULLW  08
0290A:  MOVF   FF3,W
0290C:  MOVLB  6
0290E:  CLRF   x02
02910:  MOVWF  x01
02912:  MOVLW  04
02914:  ADDWF  x01,W
02916:  MOVWF  01
02918:  MOVLW  00
0291A:  ADDWFC x02,W
0291C:  MOVWF  03
0291E:  MOVF   01,W
02920:  ADDLW  A7
02922:  MOVWF  FE9
02924:  MOVLW  04
02926:  ADDWFC 03,W
02928:  MOVWF  FEA
0292A:  MOVF   FEF,W
0292C:  XORLW  91
0292E:  MOVLB  0
02930:  BZ    294C
02932:  XORLW  03
02934:  BZ    2984
02936:  XORLW  06
02938:  BZ    29BC
0293A:  XORLW  02
0293C:  BZ    29F4
0293E:  XORLW  0E
02940:  BTFSC  FD8.2
02942:  BRA    2A2C
02944:  XORLW  38
02946:  BTFSC  FD8.2
02948:  BRA    2A64
0294A:  BRA    2A9A
....................          { 
....................             case MSG_MOTE_HEALTH_REPORT: 
....................                send_health_report_ISR(MSG_MOTE_UNSOLICITED, global_message_queue[global_current_message_queue_location].msg_seq); 
0294C:  MOVLB  4
0294E:  MOVF   xF7,W
02950:  MULLW  08
02952:  MOVF   FF3,W
02954:  MOVLB  6
02956:  CLRF   x02
02958:  MOVWF  x01
0295A:  MOVLW  05
0295C:  ADDWF  x01,W
0295E:  MOVWF  01
02960:  MOVLW  00
02962:  ADDWFC x02,W
02964:  MOVWF  03
02966:  MOVF   01,W
02968:  ADDLW  A7
0296A:  MOVWF  FE9
0296C:  MOVLW  04
0296E:  ADDWFC 03,W
02970:  MOVWF  FEA
02972:  MOVFF  FEC,605
02976:  MOVF   FED,F
02978:  MOVFF  FEF,604
0297C:  CLRF   x03
0297E:  MOVLB  0
02980:  BRA    24F4
....................                break;                                                                           
02982:  BRA    2A9A
....................             case MSG_MOTE_VALVE_REPORT:    
....................                send_valve_report_ISR(MSG_MOTE_UNSOLICITED, global_message_queue[global_current_message_queue_location].msg_seq); 
02984:  MOVLB  4
02986:  MOVF   xF7,W
02988:  MULLW  08
0298A:  MOVF   FF3,W
0298C:  MOVLB  6
0298E:  CLRF   x02
02990:  MOVWF  x01
02992:  MOVLW  05
02994:  ADDWF  x01,W
02996:  MOVWF  01
02998:  MOVLW  00
0299A:  ADDWFC x02,W
0299C:  MOVWF  03
0299E:  MOVF   01,W
029A0:  ADDLW  A7
029A2:  MOVWF  FE9
029A4:  MOVLW  04
029A6:  ADDWFC 03,W
029A8:  MOVWF  FEA
029AA:  MOVFF  FEC,605
029AE:  MOVF   FED,F
029B0:  MOVFF  FEF,604
029B4:  CLRF   x03
029B6:  MOVLB  0
029B8:  BRA    266E
....................                break; 
029BA:  BRA    2A9A
....................             case MSG_MOTE_JOIN_MSG: 
....................                send_join_msg_ISR(MSG_MOTE_UNSOLICITED, global_message_queue[global_current_message_queue_location].msg_seq); 
029BC:  MOVLB  4
029BE:  MOVF   xF7,W
029C0:  MULLW  08
029C2:  MOVF   FF3,W
029C4:  MOVLB  6
029C6:  CLRF   x02
029C8:  MOVWF  x01
029CA:  MOVLW  05
029CC:  ADDWF  x01,W
029CE:  MOVWF  01
029D0:  MOVLW  00
029D2:  ADDWFC x02,W
029D4:  MOVWF  03
029D6:  MOVF   01,W
029D8:  ADDLW  A7
029DA:  MOVWF  FE9
029DC:  MOVLW  04
029DE:  ADDWFC 03,W
029E0:  MOVWF  FEA
029E2:  MOVFF  FEC,605
029E6:  MOVF   FED,F
029E8:  MOVFF  FEF,604
029EC:  CLRF   x03
029EE:  MOVLB  0
029F0:  BRA    27A0
....................                break; 
029F2:  BRA    2A9A
....................             case MSG_MOTE_GPS_POINT_MSG: 
....................                send_gps_point_msg_ISR(MSG_MOTE_UNSOLICITED, global_message_queue[global_current_message_queue_location].msg_seq); 
029F4:  MOVLB  4
029F6:  MOVF   xF7,W
029F8:  MULLW  08
029FA:  MOVF   FF3,W
029FC:  MOVLB  6
029FE:  CLRF   x02
02A00:  MOVWF  x01
02A02:  MOVLW  05
02A04:  ADDWF  x01,W
02A06:  MOVWF  01
02A08:  MOVLW  00
02A0A:  ADDWFC x02,W
02A0C:  MOVWF  03
02A0E:  MOVF   01,W
02A10:  ADDLW  A7
02A12:  MOVWF  FE9
02A14:  MOVLW  04
02A16:  ADDWFC 03,W
02A18:  MOVWF  FEA
02A1A:  MOVFF  FEC,605
02A1E:  MOVF   FED,F
02A20:  MOVFF  FEF,604
02A24:  CLRF   x03
02A26:  MOVLB  0
02A28:  BRA    27FA
....................                break;                                         
02A2A:  BRA    2A9A
....................             case MSG_MOTE_XDCR_READ_MSG:                                                    
....................                send_pressure_xdcr_msg_ISR(MSG_MOTE_UNSOLICITED, global_message_queue[global_current_message_queue_location].msg_seq); 
02A2C:  MOVLB  4
02A2E:  MOVF   xF7,W
02A30:  MULLW  08
02A32:  MOVF   FF3,W
02A34:  MOVLB  6
02A36:  CLRF   x02
02A38:  MOVWF  x01
02A3A:  MOVLW  05
02A3C:  ADDWF  x01,W
02A3E:  MOVWF  01
02A40:  MOVLW  00
02A42:  ADDWFC x02,W
02A44:  MOVWF  03
02A46:  MOVF   01,W
02A48:  ADDLW  A7
02A4A:  MOVWF  FE9
02A4C:  MOVLW  04
02A4E:  ADDWFC 03,W
02A50:  MOVWF  FEA
02A52:  MOVFF  FEC,605
02A56:  MOVF   FED,F
02A58:  MOVFF  FEF,604
02A5C:  CLRF   x03
02A5E:  MOVLB  0
02A60:  BRA    282C
....................                break; 
02A62:  BRA    2A9A
....................             case MSG_MOTE_ERROR_MSG:       
....................                send_error_msg_ISR(MSG_MOTE_UNSOLICITED, global_message_queue[global_current_message_queue_location].msg_seq); 
02A64:  MOVLB  4
02A66:  MOVF   xF7,W
02A68:  MULLW  08
02A6A:  MOVF   FF3,W
02A6C:  MOVLB  6
02A6E:  CLRF   x02
02A70:  MOVWF  x01
02A72:  MOVLW  05
02A74:  ADDWF  x01,W
02A76:  MOVWF  01
02A78:  MOVLW  00
02A7A:  ADDWFC x02,W
02A7C:  MOVWF  03
02A7E:  MOVF   01,W
02A80:  ADDLW  A7
02A82:  MOVWF  FE9
02A84:  MOVLW  04
02A86:  ADDWFC 03,W
02A88:  MOVWF  FEA
02A8A:  MOVFF  FEC,605
02A8E:  MOVF   FED,F
02A90:  MOVFF  FEF,604
02A94:  CLRF   x03
02A96:  MOVLB  0
02A98:  BRA    2866
....................                break; 
....................          } 
....................          // increment attempt number and reschedule it to send at a later time (if not ack'd) 
....................          global_message_queue[global_current_message_queue_location].attempt_num++; 
02A9A:  MOVLB  4
02A9C:  MOVF   xF7,W
02A9E:  MULLW  08
02AA0:  MOVF   FF3,W
02AA2:  MOVLB  6
02AA4:  CLRF   x02
02AA6:  MOVWF  x01
02AA8:  MOVLW  07
02AAA:  ADDWF  x01,W
02AAC:  MOVWF  01
02AAE:  MOVLW  00
02AB0:  ADDWFC x02,W
02AB2:  MOVWF  03
02AB4:  MOVF   01,W
02AB6:  ADDLW  A7
02AB8:  MOVWF  FE9
02ABA:  MOVLW  04
02ABC:  ADDWFC 03,W
02ABE:  MOVWF  FEA
02AC0:  INCF   FEF,F
....................          global_message_queue[global_current_message_queue_location].time_to_send+=MESSAGE_RESEND_WAIT_PERIOD; 
02AC2:  MOVLB  4
02AC4:  MOVF   xF7,W
02AC6:  MULLW  08
02AC8:  MOVF   FF3,W
02ACA:  MOVLB  6
02ACC:  CLRF   x02
02ACE:  MOVWF  x01
02AD0:  MOVLW  A7
02AD2:  ADDWF  x01,W
02AD4:  MOVWF  FE9
02AD6:  MOVLW  04
02AD8:  ADDWFC x02,W
02ADA:  MOVWF  FEA
02ADC:  MOVLW  3C
02ADE:  ADDWF  FEF,W
02AE0:  MOVWF  00
02AE2:  MOVLW  00
02AE4:  ADDWFC FEC,W
02AE6:  MOVWF  01
02AE8:  MOVLW  00
02AEA:  ADDWFC FEC,W
02AEC:  MOVWF  02
02AEE:  MOVLW  00
02AF0:  ADDWFC FEC,W
02AF2:  MOVF   FED,F
02AF4:  MOVF   FED,F
02AF6:  MOVF   FED,F
02AF8:  MOVFF  00,FEF
02AFC:  MOVFF  01,FEC
02B00:  MOVFF  02,FEC
02B04:  MOVWF  FEC
....................           
....................          // starting at the current queue location, sort through the queue 
....................          //    until the item is in the right place 
....................          for (n = global_current_message_queue_location; n > 0; n--)                  
02B06:  MOVFF  4F7,5F8
02B0A:  MOVLB  5
02B0C:  MOVF   xF8,F
02B0E:  BTFSC  FD8.2
02B10:  BRA    2C30
....................          { 
....................             //if queue items are not sorted properly 
....................             if (global_message_queue[n].time_to_send > global_message_queue[n-1].time_to_send) 
02B12:  MOVF   xF8,W
02B14:  MULLW  08
02B16:  MOVF   FF3,W
02B18:  MOVLB  6
02B1A:  CLRF   x02
02B1C:  MOVWF  x01
02B1E:  MOVLW  A7
02B20:  ADDWF  x01,W
02B22:  MOVWF  FE9
02B24:  MOVLW  04
02B26:  ADDWFC x02,W
02B28:  MOVWF  FEA
02B2A:  MOVFF  FEF,603
02B2E:  MOVFF  FEC,604
02B32:  MOVFF  FEC,605
02B36:  MOVFF  FEC,606
02B3A:  MOVLW  01
02B3C:  MOVLB  5
02B3E:  SUBWF  xF8,W
02B40:  MULLW  08
02B42:  MOVF   FF3,W
02B44:  MOVLB  6
02B46:  CLRF   x08
02B48:  MOVWF  x07
02B4A:  MOVLW  A7
02B4C:  ADDWF  x07,W
02B4E:  MOVWF  FE9
02B50:  MOVLW  04
02B52:  ADDWFC x08,W
02B54:  MOVWF  FEA
02B56:  MOVFF  FEF,00
02B5A:  MOVFF  FEC,01
02B5E:  MOVFF  FEC,02
02B62:  MOVFF  FEC,03
02B66:  MOVF   03,W
02B68:  SUBWF  x06,W
02B6A:  BNC   2C24
02B6C:  BNZ   2B84
02B6E:  MOVF   02,W
02B70:  SUBWF  x05,W
02B72:  BNC   2C24
02B74:  BNZ   2B84
02B76:  MOVF   01,W
02B78:  SUBWF  x04,W
02B7A:  BNC   2C24
02B7C:  BNZ   2B84
02B7E:  MOVF   x03,W
02B80:  SUBWF  00,W
02B82:  BC    2C24
....................             { 
....................                //do a swap 
....................                memcpy(&temp_message_queue_item, &global_message_queue[n], sizeof(&temp_message_queue_item)); 
02B84:  MOVLB  5
02B86:  MOVF   xF8,W
02B88:  MULLW  08
02B8A:  MOVF   FF3,W
02B8C:  CLRF   03
02B8E:  ADDLW  A7
02B90:  MOVWF  01
02B92:  MOVLW  04
02B94:  ADDWFC 03,F
02B96:  MOVLB  6
02B98:  MOVFF  03,FE2
02B9C:  MOVFF  01,FE1
02BA0:  MOVFF  FE6,5F9
02BA4:  MOVFF  FE6,5FA
....................                memcpy(&global_message_queue[n], &global_message_queue[n-1], sizeof(&global_message_queue[n])); 
02BA8:  MOVLB  5
02BAA:  MOVF   xF8,W
02BAC:  MULLW  08
02BAE:  MOVF   FF3,W
02BB0:  CLRF   03
02BB2:  ADDLW  A7
02BB4:  MOVWF  01
02BB6:  MOVLW  04
02BB8:  ADDWFC 03,F
02BBA:  MOVFF  01,601
02BBE:  MOVFF  03,602
02BC2:  MOVLW  01
02BC4:  MOVLB  5
02BC6:  SUBWF  xF8,W
02BC8:  MULLW  08
02BCA:  MOVF   FF3,W
02BCC:  CLRF   03
02BCE:  ADDLW  A7
02BD0:  MOVWF  01
02BD2:  MOVLW  04
02BD4:  ADDWFC 03,F
02BD6:  MOVFF  01,603
02BDA:  MOVLB  6
02BDC:  MOVFF  03,604
02BE0:  MOVFF  602,FEA
02BE4:  MOVFF  601,FE9
02BE8:  MOVFF  03,FE2
02BEC:  MOVFF  01,FE1
02BF0:  MOVLW  02
02BF2:  MOVWF  01
02BF4:  MOVFF  FE6,FEE
02BF8:  DECFSZ 01,F
02BFA:  BRA    2BF4
....................                memcpy(&global_message_queue[n-1], &temp_message_queue_item, sizeof(&global_message_queue[n-1])); 
02BFC:  MOVLW  01
02BFE:  MOVLB  5
02C00:  SUBWF  xF8,W
02C02:  MULLW  08
02C04:  MOVF   FF3,W
02C06:  CLRF   03
02C08:  ADDLW  A7
02C0A:  MOVWF  01
02C0C:  MOVLW  04
02C0E:  ADDWFC 03,F
02C10:  MOVLB  6
02C12:  MOVFF  03,FEA
02C16:  MOVFF  01,FE9
02C1A:  MOVFF  5F9,FEE
02C1E:  MOVFF  5FA,FEE
....................             } 
02C22:  BRA    2C2A
....................             //item is in the proper place (assuming queue always sorted properly) 
....................             else 
....................             { 
....................                return; 
02C24:  MOVLB  4
02C26:  BRA    2C34
02C28:  MOVLB  6
....................             } 
02C2A:  MOVLB  5
02C2C:  DECF   xF8,F
02C2E:  BRA    2B0C
02C30:  MOVLB  0
02C32:  MOVLB  4
....................          } 
....................       } 
....................    } 
02C34:  MOVLB  0
02C36:  GOTO   2FA2 (RETURN)
.................... } 
....................                                        
.................... void push_message_queue(uint8_t message_type) 
.................... // pushes a new item (attempt 0) into the message queue and sorts it. 
.................... // returns 1 if everything is good, 0 if queue is full 
.................... {                 
....................    uint8_t n; 
....................    struct MessageQueueItem temp_message_queue_item;                             
....................     
....................    //if queue is full, return 0                                                      
....................    if (global_current_message_queue_location == (MAX_MESSAGE_QUEUE_ITEMS - 1)) 
*
051F6:  MOVLB  4
051F8:  MOVF   xF7,W
051FA:  SUBLW  09
051FC:  BNZ   5200
....................    {                                             
....................       return;    
051FE:  BRA    5506
....................    } 
....................                  
....................                                                                                                  
....................    // if you're trying to add an error message...                    
....................    if (message_type == MSG_MOTE_ERROR_MSG) 
05200:  MOVLB  5
05202:  MOVF   x54,W
05204:  SUBLW  A0
05206:  BTFSS  FD8.2
05208:  BRA    533A
....................    { 
....................       // check to see if it is the same as the last error message added and if it has happened too recently to resend 
....................       if ((global_error_message_bitfield == last_error_message_sent_bitfield) && ((global_rtc_time - last_error_message_sent_rtc_time) < ERR_MESSAGE_WAIT_PERIOD)) 
0520A:  MOVLB  4
0520C:  MOVF   xFC,W
0520E:  SUBWF  xF8,W
05210:  BNZ   527E
05212:  MOVF   xFD,W
05214:  SUBWF  xF9,W
05216:  BNZ   527E
05218:  MOVF   xFE,W
0521A:  SUBWF  xFA,W
0521C:  BNZ   527E
0521E:  MOVF   xFF,W
05220:  SUBWF  xFB,W
05222:  BNZ   527E
05224:  MOVLB  5
05226:  MOVF   x00,W
05228:  MOVLB  0
0522A:  SUBWF  x85,W
0522C:  MOVLB  5
0522E:  MOVWF  x5E
05230:  MOVF   x01,W
05232:  MOVLB  0
05234:  SUBWFB x86,W
05236:  MOVLB  5
05238:  MOVWF  x5F
0523A:  MOVF   x02,W
0523C:  MOVLB  0
0523E:  SUBWFB x87,W
05240:  MOVLB  5
05242:  MOVWF  x60
05244:  MOVF   x03,W
05246:  MOVLB  0
05248:  SUBWFB x88,W
0524A:  MOVLB  5
0524C:  MOVWF  x61
0524E:  MOVF   x61,F
05250:  BTFSC  FD8.2
05252:  BRA    5258
05254:  MOVLB  4
05256:  BRA    527E
05258:  MOVF   x60,F
0525A:  BTFSC  FD8.2
0525C:  BRA    5262
0525E:  MOVLB  4
05260:  BRA    527E
05262:  MOVF   x5F,F
05264:  BTFSC  FD8.2
05266:  BRA    526C
05268:  MOVLB  4
0526A:  BRA    527E
0526C:  MOVF   x5E,W
0526E:  SUBLW  3B
05270:  BTFSC  FD8.0
05272:  BRA    5278
05274:  MOVLB  4
05276:  BRA    527E
....................       {         
....................          return; 
05278:  MOVLB  4
0527A:  BRA    5506
....................       } 
0527C:  BRA    529E
....................       else 
....................       { 
....................          // save the error message bitfield and send time for future comparing and rejecting of duplicate messages 
....................          last_error_message_sent_bitfield = global_error_message_bitfield; 
0527E:  MOVFF  4FB,4FF
05282:  MOVFF  4FA,4FE
05286:  MOVFF  4F9,4FD
0528A:  MOVFF  4F8,4FC
....................          last_error_message_sent_rtc_time = global_rtc_time; 
0528E:  MOVFF  88,503
05292:  MOVFF  87,502
05296:  MOVFF  86,501
0529A:  MOVFF  85,500
....................       }                              
....................       // look through the current queue 
....................       for (n = global_current_message_queue_location; ((n > 0) && (n != 255)); n--) 
0529E:  MOVFF  4F7,555
052A2:  MOVLB  5
052A4:  MOVF   x55,F
052A6:  BZ    533A
052A8:  INCFSZ x55,W
052AA:  BRA    52AE
052AC:  BRA    533A
....................       { 
....................          // if there is already another error message on the queue, replace it 
....................          if (global_message_queue[n].message_type == MSG_MOTE_ERROR_MSG) 
052AE:  MOVF   x55,W
052B0:  MULLW  08
052B2:  MOVF   FF3,W
052B4:  CLRF   x5F
052B6:  MOVWF  x5E
052B8:  MOVLW  04
052BA:  ADDWF  x5E,W
052BC:  MOVWF  01
052BE:  MOVLW  00
052C0:  ADDWFC x5F,W
052C2:  MOVWF  03
052C4:  MOVF   01,W
052C6:  ADDLW  A7
052C8:  MOVWF  FE9
052CA:  MOVLW  04
052CC:  ADDWFC 03,W
052CE:  MOVWF  FEA
052D0:  MOVF   FEF,W
052D2:  SUBLW  A0
052D4:  BNZ   5336
....................          { 
....................             // increase the mote sequence number (new message) 
....................             // the ack from the previous one will basically get ignored 
....................             global_message_queue[n].msg_seq = ++mote_msgSEQ; 
052D6:  MOVF   x55,W
052D8:  MULLW  08
052DA:  MOVF   FF3,W
052DC:  CLRF   x5F
052DE:  MOVWF  x5E
052E0:  MOVLW  05
052E2:  ADDWF  x5E,W
052E4:  MOVWF  01
052E6:  MOVLW  00
052E8:  ADDWFC x5F,W
052EA:  MOVWF  03
052EC:  MOVF   01,W
052EE:  ADDLW  A7
052F0:  MOVWF  FE9
052F2:  MOVLW  04
052F4:  ADDWFC 03,W
052F6:  MOVWF  FEA
052F8:  MOVLB  3
052FA:  INCF   x65,F
052FC:  BTFSC  FD8.2
052FE:  INCF   x66,F
05300:  MOVFF  366,FEC
05304:  MOVF   FED,F
05306:  MOVFF  365,FEF
....................             // reset the attempts to 0 (new message) 
....................             global_message_queue[n].attempt_num = 0;      
0530A:  MOVLB  5
0530C:  MOVF   x55,W
0530E:  MULLW  08
05310:  MOVF   FF3,W
05312:  CLRF   x5F
05314:  MOVWF  x5E
05316:  MOVLW  07
05318:  ADDWF  x5E,W
0531A:  MOVWF  01
0531C:  MOVLW  00
0531E:  ADDWFC x5F,W
05320:  MOVWF  03
05322:  MOVF   01,W
05324:  ADDLW  A7
05326:  MOVWF  FE9
05328:  MOVLW  04
0532A:  ADDWFC 03,W
0532C:  MOVWF  FEA
0532E:  CLRF   FEF
....................             return; 
05330:  MOVLB  4
05332:  BRA    5506
05334:  MOVLB  5
....................          } 
05336:  DECF   x55,F
05338:  BRA    52A4
....................       } 
....................    } 
....................       
....................    // increment the queue location and mote message sequence (always first attempt 
....................    //    at a message in this routine 
....................    global_current_message_queue_location++; 
0533A:  MOVLB  4
0533C:  INCF   xF7,F
....................    mote_msgSEQ++; 
0533E:  MOVLB  3
05340:  INCF   x65,F
05342:  BTFSC  FD8.2
05344:  INCF   x66,F
....................     
....................    //set the new item at the top of the queue (will be sorted in a sec) 
....................    global_message_queue[global_current_message_queue_location].time_to_send = global_rtc_time; 
05346:  MOVLB  4
05348:  MOVF   xF7,W
0534A:  MULLW  08
0534C:  MOVF   FF3,W
0534E:  MOVLB  5
05350:  CLRF   x5F
05352:  MOVWF  x5E
05354:  MOVLW  A7
05356:  ADDWF  x5E,W
05358:  MOVWF  FE9
0535A:  MOVLW  04
0535C:  ADDWFC x5F,W
0535E:  MOVWF  FEA
05360:  MOVFF  85,FEF
05364:  MOVFF  86,FEC
05368:  MOVFF  87,FEC
0536C:  MOVFF  88,FEC
....................    global_message_queue[global_current_message_queue_location].message_type = message_type; 
05370:  MOVLB  4
05372:  MOVF   xF7,W
05374:  MULLW  08
05376:  MOVF   FF3,W
05378:  MOVLB  5
0537A:  CLRF   x5F
0537C:  MOVWF  x5E
0537E:  MOVLW  04
05380:  ADDWF  x5E,W
05382:  MOVWF  01
05384:  MOVLW  00
05386:  ADDWFC x5F,W
05388:  MOVWF  03
0538A:  MOVF   01,W
0538C:  ADDLW  A7
0538E:  MOVWF  FE9
05390:  MOVLW  04
05392:  ADDWFC 03,W
05394:  MOVWF  FEA
05396:  MOVFF  554,FEF
....................    global_message_queue[global_current_message_queue_location].msg_seq = mote_msgSEQ; 
0539A:  MOVLB  4
0539C:  MOVF   xF7,W
0539E:  MULLW  08
053A0:  MOVF   FF3,W
053A2:  MOVLB  5
053A4:  CLRF   x5F
053A6:  MOVWF  x5E
053A8:  MOVLW  05
053AA:  ADDWF  x5E,W
053AC:  MOVWF  01
053AE:  MOVLW  00
053B0:  ADDWFC x5F,W
053B2:  MOVWF  03
053B4:  MOVF   01,W
053B6:  ADDLW  A7
053B8:  MOVWF  FE9
053BA:  MOVLW  04
053BC:  ADDWFC 03,W
053BE:  MOVWF  FEA
053C0:  MOVFF  366,FEC
053C4:  MOVF   FED,F
053C6:  MOVFF  365,FEF
....................    global_message_queue[global_current_message_queue_location].attempt_num = 0;    
053CA:  MOVLB  4
053CC:  MOVF   xF7,W
053CE:  MULLW  08
053D0:  MOVF   FF3,W
053D2:  MOVLB  5
053D4:  CLRF   x5F
053D6:  MOVWF  x5E
053D8:  MOVLW  07
053DA:  ADDWF  x5E,W
053DC:  MOVWF  01
053DE:  MOVLW  00
053E0:  ADDWFC x5F,W
053E2:  MOVWF  03
053E4:  MOVF   01,W
053E6:  ADDLW  A7
053E8:  MOVWF  FE9
053EA:  MOVLW  04
053EC:  ADDWFC 03,W
053EE:  MOVWF  FEA
053F0:  CLRF   FEF
....................           
....................    //starting at the new current queue location, sort through the queue 
....................    //until the new item is in the right place 
....................    for (n = global_current_message_queue_location; n > 0; n--)                    
053F2:  MOVFF  4F7,555
053F6:  MOVF   x55,F
053F8:  BTFSC  FD8.2
053FA:  BRA    5504
....................    {                                                
....................       //if queue items are not sorted properly 
....................       if (global_message_queue[n].time_to_send > global_message_queue[n-1].time_to_send) 
053FC:  MOVF   x55,W
053FE:  MULLW  08
05400:  MOVF   FF3,W
05402:  CLRF   x5F
05404:  MOVWF  x5E
05406:  MOVLW  A7
05408:  ADDWF  x5E,W
0540A:  MOVWF  FE9
0540C:  MOVLW  04
0540E:  ADDWFC x5F,W
05410:  MOVWF  FEA
05412:  MOVFF  FEF,560
05416:  MOVFF  FEC,561
0541A:  MOVFF  FEC,562
0541E:  MOVFF  FEC,563
05422:  MOVLW  01
05424:  SUBWF  x55,W
05426:  MULLW  08
05428:  MOVF   FF3,W
0542A:  CLRF   x65
0542C:  MOVWF  x64
0542E:  MOVLW  A7
05430:  ADDWF  x64,W
05432:  MOVWF  FE9
05434:  MOVLW  04
05436:  ADDWFC x65,W
05438:  MOVWF  FEA
0543A:  MOVFF  FEF,00
0543E:  MOVFF  FEC,01
05442:  MOVFF  FEC,02
05446:  MOVFF  FEC,03
0544A:  MOVF   03,W
0544C:  SUBWF  x63,W
0544E:  BNC   54FA
05450:  BNZ   5468
05452:  MOVF   02,W
05454:  SUBWF  x62,W
05456:  BNC   54FA
05458:  BNZ   5468
0545A:  MOVF   01,W
0545C:  SUBWF  x61,W
0545E:  BNC   54FA
05460:  BNZ   5468
05462:  MOVF   x60,W
05464:  SUBWF  00,W
05466:  BC    54FA
....................       { 
....................          //do a swap 
....................          memcpy(&temp_message_queue_item, &global_message_queue[n], sizeof(&temp_message_queue_item)); 
05468:  MOVF   x55,W
0546A:  MULLW  08
0546C:  MOVF   FF3,W
0546E:  CLRF   03
05470:  ADDLW  A7
05472:  MOVWF  01
05474:  MOVLW  04
05476:  ADDWFC 03,F
05478:  MOVFF  03,FE2
0547C:  MOVFF  01,FE1
05480:  MOVFF  FE6,556
05484:  MOVFF  FE6,557
....................          memcpy(&global_message_queue[n], &global_message_queue[n-1], sizeof(&global_message_queue[n])); 
05488:  MOVF   x55,W
0548A:  MULLW  08
0548C:  MOVF   FF3,W
0548E:  CLRF   03
05490:  ADDLW  A7
05492:  MOVWF  01
05494:  MOVLW  04
05496:  ADDWFC 03,F
05498:  MOVFF  01,55E
0549C:  MOVFF  03,55F
054A0:  MOVLW  01
054A2:  SUBWF  x55,W
054A4:  MULLW  08
054A6:  MOVF   FF3,W
054A8:  CLRF   03
054AA:  ADDLW  A7
054AC:  MOVWF  01
054AE:  MOVLW  04
054B0:  ADDWFC 03,F
054B2:  MOVFF  01,560
054B6:  MOVFF  03,561
054BA:  MOVFF  55F,FEA
054BE:  MOVFF  55E,FE9
054C2:  MOVFF  03,FE2
054C6:  MOVFF  01,FE1
054CA:  MOVLW  02
054CC:  MOVWF  01
054CE:  MOVFF  FE6,FEE
054D2:  DECFSZ 01,F
054D4:  BRA    54CE
....................          memcpy(&global_message_queue[n-1], &temp_message_queue_item, sizeof(&global_message_queue[n-1])); 
054D6:  MOVLW  01
054D8:  SUBWF  x55,W
054DA:  MULLW  08
054DC:  MOVF   FF3,W
054DE:  CLRF   03
054E0:  ADDLW  A7
054E2:  MOVWF  01
054E4:  MOVLW  04
054E6:  ADDWFC 03,F
054E8:  MOVFF  03,FEA
054EC:  MOVFF  01,FE9
054F0:  MOVFF  556,FEE
054F4:  MOVFF  557,FEE
....................       } 
054F8:  BRA    5500
....................       //item is in the proper place (assuming queue always sorted properly) 
....................       else    
....................       {    
....................          return; 
054FA:  MOVLB  4
054FC:  BRA    5506
054FE:  MOVLB  5
....................       } 
05500:  DECF   x55,F
05502:  BRA    53F6
05504:  MOVLB  4
....................    }     
....................    return; 
05506:  MOVLB  0
05508:  RETURN 0
.................... }                        
....................  
.................... void push_message_queue_ISR(uint8_t message_type) 
.................... // pushes a new item (attempt 0) into the message queue and sorts it. 
.................... // returns 1 if everything is good, 0 if queue is full 
.................... // message queue ISR only gets called in the pop message queue ISR so it's only resends of messages 
.................... //    (don't have to worry about error messages getting screwed up because of duplicate rejection logic) 
.................... { 
....................    uint8_t n; 
....................    struct MessageQueueItem temp_message_queue_item; 
....................    
....................    //if queue is full, return 0 
....................    if (global_current_message_queue_location == (MAX_MESSAGE_QUEUE_ITEMS - 1)) 
*
00C26:  MOVLB  4
00C28:  MOVF   xF7,W
00C2A:  SUBLW  09
00C2C:  BNZ   0C30
....................    { 
....................       return; 
00C2E:  BRA    0E9E
....................    } 
....................     
....................    // if you're trying to add an error message... 
....................    if (message_type == MSG_MOTE_ERROR_MSG) 
00C30:  MOVLB  6
00C32:  MOVF   x14,W
00C34:  SUBLW  A0
00C36:  BNZ   0CD2
....................    { 
....................       // look through the current queue 
....................       for (n = global_current_message_queue_location; ((n > 0) && (n != 255)); n--) 
00C38:  MOVFF  4F7,615
00C3C:  MOVF   x15,F
00C3E:  BZ    0CD2
00C40:  INCFSZ x15,W
00C42:  BRA    0C46
00C44:  BRA    0CD2
....................       { 
....................          // if there is already another error message on the queue, replace it 
....................          if (global_message_queue[n].message_type == MSG_MOTE_ERROR_MSG) 
00C46:  MOVF   x15,W
00C48:  MULLW  08
00C4A:  MOVF   FF3,W
00C4C:  CLRF   x1F
00C4E:  MOVWF  x1E
00C50:  MOVLW  04
00C52:  ADDWF  x1E,W
00C54:  MOVWF  01
00C56:  MOVLW  00
00C58:  ADDWFC x1F,W
00C5A:  MOVWF  03
00C5C:  MOVF   01,W
00C5E:  ADDLW  A7
00C60:  MOVWF  FE9
00C62:  MOVLW  04
00C64:  ADDWFC 03,W
00C66:  MOVWF  FEA
00C68:  MOVF   FEF,W
00C6A:  SUBLW  A0
00C6C:  BNZ   0CCE
....................          { 
....................             // increase the mote sequence number (new message) 
....................             // the ack from the previous one will basically get ignored 
....................             global_message_queue[n].msg_seq = ++mote_msgSEQ; 
00C6E:  MOVF   x15,W
00C70:  MULLW  08
00C72:  MOVF   FF3,W
00C74:  CLRF   x1F
00C76:  MOVWF  x1E
00C78:  MOVLW  05
00C7A:  ADDWF  x1E,W
00C7C:  MOVWF  01
00C7E:  MOVLW  00
00C80:  ADDWFC x1F,W
00C82:  MOVWF  03
00C84:  MOVF   01,W
00C86:  ADDLW  A7
00C88:  MOVWF  FE9
00C8A:  MOVLW  04
00C8C:  ADDWFC 03,W
00C8E:  MOVWF  FEA
00C90:  MOVLB  3
00C92:  INCF   x65,F
00C94:  BTFSC  FD8.2
00C96:  INCF   x66,F
00C98:  MOVFF  366,FEC
00C9C:  MOVF   FED,F
00C9E:  MOVFF  365,FEF
....................             // reset the attempts to 0 (new message) 
....................             global_message_queue[n].attempt_num = 0; 
00CA2:  MOVLB  6
00CA4:  MOVF   x15,W
00CA6:  MULLW  08
00CA8:  MOVF   FF3,W
00CAA:  CLRF   x1F
00CAC:  MOVWF  x1E
00CAE:  MOVLW  07
00CB0:  ADDWF  x1E,W
00CB2:  MOVWF  01
00CB4:  MOVLW  00
00CB6:  ADDWFC x1F,W
00CB8:  MOVWF  03
00CBA:  MOVF   01,W
00CBC:  ADDLW  A7
00CBE:  MOVWF  FE9
00CC0:  MOVLW  04
00CC2:  ADDWFC 03,W
00CC4:  MOVWF  FEA
00CC6:  CLRF   FEF
....................             return; 
00CC8:  MOVLB  4
00CCA:  BRA    0E9E
00CCC:  MOVLB  6
....................          } 
00CCE:  DECF   x15,F
00CD0:  BRA    0C3C
....................       } 
....................    } 
....................     
....................    // increment the queue location and mote message sequence (always first attempt 
....................    //    at a message in this routine 
....................    global_current_message_queue_location++; 
00CD2:  MOVLB  4
00CD4:  INCF   xF7,F
....................    mote_msgSEQ++; 
00CD6:  MOVLB  3
00CD8:  INCF   x65,F
00CDA:  BTFSC  FD8.2
00CDC:  INCF   x66,F
....................     
....................    //set the new item at the top of the queue (will be sorted in a sec) 
....................    global_message_queue[global_current_message_queue_location].time_to_send = global_rtc_time; 
00CDE:  MOVLB  4
00CE0:  MOVF   xF7,W
00CE2:  MULLW  08
00CE4:  MOVF   FF3,W
00CE6:  MOVLB  6
00CE8:  CLRF   x1F
00CEA:  MOVWF  x1E
00CEC:  MOVLW  A7
00CEE:  ADDWF  x1E,W
00CF0:  MOVWF  FE9
00CF2:  MOVLW  04
00CF4:  ADDWFC x1F,W
00CF6:  MOVWF  FEA
00CF8:  MOVFF  85,FEF
00CFC:  MOVFF  86,FEC
00D00:  MOVFF  87,FEC
00D04:  MOVFF  88,FEC
....................    global_message_queue[global_current_message_queue_location].message_type = message_type; 
00D08:  MOVLB  4
00D0A:  MOVF   xF7,W
00D0C:  MULLW  08
00D0E:  MOVF   FF3,W
00D10:  MOVLB  6
00D12:  CLRF   x1F
00D14:  MOVWF  x1E
00D16:  MOVLW  04
00D18:  ADDWF  x1E,W
00D1A:  MOVWF  01
00D1C:  MOVLW  00
00D1E:  ADDWFC x1F,W
00D20:  MOVWF  03
00D22:  MOVF   01,W
00D24:  ADDLW  A7
00D26:  MOVWF  FE9
00D28:  MOVLW  04
00D2A:  ADDWFC 03,W
00D2C:  MOVWF  FEA
00D2E:  MOVFF  614,FEF
....................    global_message_queue[global_current_message_queue_location].msg_seq = mote_msgSEQ; 
00D32:  MOVLB  4
00D34:  MOVF   xF7,W
00D36:  MULLW  08
00D38:  MOVF   FF3,W
00D3A:  MOVLB  6
00D3C:  CLRF   x1F
00D3E:  MOVWF  x1E
00D40:  MOVLW  05
00D42:  ADDWF  x1E,W
00D44:  MOVWF  01
00D46:  MOVLW  00
00D48:  ADDWFC x1F,W
00D4A:  MOVWF  03
00D4C:  MOVF   01,W
00D4E:  ADDLW  A7
00D50:  MOVWF  FE9
00D52:  MOVLW  04
00D54:  ADDWFC 03,W
00D56:  MOVWF  FEA
00D58:  MOVFF  366,FEC
00D5C:  MOVF   FED,F
00D5E:  MOVFF  365,FEF
....................    global_message_queue[global_current_message_queue_location].attempt_num = 0; 
00D62:  MOVLB  4
00D64:  MOVF   xF7,W
00D66:  MULLW  08
00D68:  MOVF   FF3,W
00D6A:  MOVLB  6
00D6C:  CLRF   x1F
00D6E:  MOVWF  x1E
00D70:  MOVLW  07
00D72:  ADDWF  x1E,W
00D74:  MOVWF  01
00D76:  MOVLW  00
00D78:  ADDWFC x1F,W
00D7A:  MOVWF  03
00D7C:  MOVF   01,W
00D7E:  ADDLW  A7
00D80:  MOVWF  FE9
00D82:  MOVLW  04
00D84:  ADDWFC 03,W
00D86:  MOVWF  FEA
00D88:  CLRF   FEF
....................     
....................    //starting at the new current queue location, sort through the queue 
....................    //until the new item is in the right place 
....................    for (n = global_current_message_queue_location; n > 0; n--) 
00D8A:  MOVFF  4F7,615
00D8E:  MOVF   x15,F
00D90:  BTFSC  FD8.2
00D92:  BRA    0E9C
....................    { 
....................       //if queue items are not sorted properly 
....................       if (global_message_queue[n].time_to_send > global_message_queue[n-1].time_to_send) 
00D94:  MOVF   x15,W
00D96:  MULLW  08
00D98:  MOVF   FF3,W
00D9A:  CLRF   x1F
00D9C:  MOVWF  x1E
00D9E:  MOVLW  A7
00DA0:  ADDWF  x1E,W
00DA2:  MOVWF  FE9
00DA4:  MOVLW  04
00DA6:  ADDWFC x1F,W
00DA8:  MOVWF  FEA
00DAA:  MOVFF  FEF,620
00DAE:  MOVFF  FEC,621
00DB2:  MOVFF  FEC,622
00DB6:  MOVFF  FEC,623
00DBA:  MOVLW  01
00DBC:  SUBWF  x15,W
00DBE:  MULLW  08
00DC0:  MOVF   FF3,W
00DC2:  CLRF   x25
00DC4:  MOVWF  x24
00DC6:  MOVLW  A7
00DC8:  ADDWF  x24,W
00DCA:  MOVWF  FE9
00DCC:  MOVLW  04
00DCE:  ADDWFC x25,W
00DD0:  MOVWF  FEA
00DD2:  MOVFF  FEF,00
00DD6:  MOVFF  FEC,01
00DDA:  MOVFF  FEC,02
00DDE:  MOVFF  FEC,03
00DE2:  MOVF   03,W
00DE4:  SUBWF  x23,W
00DE6:  BNC   0E92
00DE8:  BNZ   0E00
00DEA:  MOVF   02,W
00DEC:  SUBWF  x22,W
00DEE:  BNC   0E92
00DF0:  BNZ   0E00
00DF2:  MOVF   01,W
00DF4:  SUBWF  x21,W
00DF6:  BNC   0E92
00DF8:  BNZ   0E00
00DFA:  MOVF   x20,W
00DFC:  SUBWF  00,W
00DFE:  BC    0E92
....................       { 
....................          //do a swap 
....................          memcpy(&temp_message_queue_item, &global_message_queue[n], sizeof(&temp_message_queue_item)); 
00E00:  MOVF   x15,W
00E02:  MULLW  08
00E04:  MOVF   FF3,W
00E06:  CLRF   03
00E08:  ADDLW  A7
00E0A:  MOVWF  01
00E0C:  MOVLW  04
00E0E:  ADDWFC 03,F
00E10:  MOVFF  03,FE2
00E14:  MOVFF  01,FE1
00E18:  MOVFF  FE6,616
00E1C:  MOVFF  FE6,617
....................          memcpy(&global_message_queue[n], &global_message_queue[n-1], sizeof(&global_message_queue[n])); 
00E20:  MOVF   x15,W
00E22:  MULLW  08
00E24:  MOVF   FF3,W
00E26:  CLRF   03
00E28:  ADDLW  A7
00E2A:  MOVWF  01
00E2C:  MOVLW  04
00E2E:  ADDWFC 03,F
00E30:  MOVFF  01,61E
00E34:  MOVFF  03,61F
00E38:  MOVLW  01
00E3A:  SUBWF  x15,W
00E3C:  MULLW  08
00E3E:  MOVF   FF3,W
00E40:  CLRF   03
00E42:  ADDLW  A7
00E44:  MOVWF  01
00E46:  MOVLW  04
00E48:  ADDWFC 03,F
00E4A:  MOVFF  01,620
00E4E:  MOVFF  03,621
00E52:  MOVFF  61F,FEA
00E56:  MOVFF  61E,FE9
00E5A:  MOVFF  03,FE2
00E5E:  MOVFF  01,FE1
00E62:  MOVLW  02
00E64:  MOVWF  01
00E66:  MOVFF  FE6,FEE
00E6A:  DECFSZ 01,F
00E6C:  BRA    0E66
....................          memcpy(&global_message_queue[n-1], &temp_message_queue_item, sizeof(&global_message_queue[n-1])); 
00E6E:  MOVLW  01
00E70:  SUBWF  x15,W
00E72:  MULLW  08
00E74:  MOVF   FF3,W
00E76:  CLRF   03
00E78:  ADDLW  A7
00E7A:  MOVWF  01
00E7C:  MOVLW  04
00E7E:  ADDWFC 03,F
00E80:  MOVFF  03,FEA
00E84:  MOVFF  01,FE9
00E88:  MOVFF  616,FEE
00E8C:  MOVFF  617,FEE
....................       } 
00E90:  BRA    0E98
....................       //item is in the proper place (assuming queue always sorted properly) 
....................       else 
....................       { 
....................          return; 
00E92:  MOVLB  4
00E94:  BRA    0E9E
00E96:  MOVLB  6
....................       } 
00E98:  DECF   x15,F
00E9A:  BRA    0D8E
00E9C:  MOVLB  4
....................    } 
....................    return; 
00E9E:  MOVLB  0
00EA0:  RETURN 0
.................... } 
....................  
.................... void remove_message_queue_item(uint16_t msg_seq) 
.................... { 
.................... // Finds the message with the passed msg_seq and removes it from the queue, 
.................... //    shifting all other messages in the queue up 
.................... // Returns 1 if message removed, 0 if not found 
.................... // This function is ONLY run as a result of an ack'd unsolicted message                      
....................  
....................    uint8_t n, m; 
....................     
....................    // no items in the queue (current location is 0-1) 
....................    if (global_current_message_queue_location == 255) 
*
05E54:  MOVLB  4
05E56:  INCFSZ xF7,W
05E58:  BRA    5E5C
....................    {   
....................  
....................       return;   
05E5A:  BRA    5FAC
....................    } 
....................     
....................    // search through the message queue from 0 to the current top of queue 
....................    for (n = 0; n <= global_current_message_queue_location; n++) 
05E5C:  MOVLB  5
05E5E:  CLRF   x54
05E60:  MOVF   x54,W
05E62:  MOVLB  4
05E64:  SUBWF  xF7,W
05E66:  BTFSS  FD8.0
05E68:  BRA    5FAC
....................    { 
....................       // if you find the matching message 
....................       if (global_message_queue[n].msg_seq == msg_seq) 
05E6A:  MOVLB  5
05E6C:  MOVF   x54,W
05E6E:  MULLW  08
05E70:  MOVF   FF3,W
05E72:  CLRF   x57
05E74:  MOVWF  x56
05E76:  MOVLW  05
05E78:  ADDWF  x56,W
05E7A:  MOVWF  01
05E7C:  MOVLW  00
05E7E:  ADDWFC x57,W
05E80:  MOVWF  03
05E82:  MOVF   01,W
05E84:  ADDLW  A7
05E86:  MOVWF  FE9
05E88:  MOVLW  04
05E8A:  ADDWFC 03,W
05E8C:  MOVWF  FEA
05E8E:  MOVFF  FEC,557
05E92:  MOVF   FED,F
05E94:  MOVFF  FEF,556
05E98:  MOVF   x52,W
05E9A:  SUBWF  x56,W
05E9C:  BTFSS  FD8.2
05E9E:  BRA    5FA6
05EA0:  MOVF   x53,W
05EA2:  SUBWF  x57,W
05EA4:  BTFSS  FD8.2
05EA6:  BRA    5FA6
....................       { 
....................          // since this is only run from ack'd messages, we can assume this 
....................          //    means the error message was recieved and we can clear the error 
....................          //    bitfield 
....................          if (global_message_queue[n].message_type == MSG_MOTE_ERROR_MSG) 
05EA8:  MOVF   x54,W
05EAA:  MULLW  08
05EAC:  MOVF   FF3,W
05EAE:  CLRF   x57
05EB0:  MOVWF  x56
05EB2:  MOVLW  04
05EB4:  ADDWF  x56,W
05EB6:  MOVWF  01
05EB8:  MOVLW  00
05EBA:  ADDWFC x57,W
05EBC:  MOVWF  03
05EBE:  MOVF   01,W
05EC0:  ADDLW  A7
05EC2:  MOVWF  FE9
05EC4:  MOVLW  04
05EC6:  ADDWFC 03,W
05EC8:  MOVWF  FEA
05ECA:  MOVF   FEF,W
05ECC:  SUBLW  A0
05ECE:  BNZ   5EDC
....................          { 
....................             global_error_message_bitfield = 0; 
05ED0:  MOVLB  4
05ED2:  CLRF   xFB
05ED4:  CLRF   xFA
05ED6:  CLRF   xF9
05ED8:  CLRF   xF8
05EDA:  MOVLB  5
....................          } 
....................          // shift everything over 1 place starting by overwriting the item 
....................          //    to remove and ending by copying the top of the queue to the next item 
....................          for (m = n; m < (MAX_MESSAGE_QUEUE_ITEMS - 1); m++) 
05EDC:  MOVFF  554,555
05EE0:  MOVF   x55,W
05EE2:  SUBLW  08
05EE4:  BNC   5F6C
....................          { 
....................             memcpy(&global_message_queue[n], global_message_queue[n+1], sizeof(&global_message_queue[n])); 
05EE6:  MOVF   x54,W
05EE8:  MULLW  08
05EEA:  MOVF   FF3,W
05EEC:  CLRF   03
05EEE:  ADDLW  A7
05EF0:  MOVWF  01
05EF2:  MOVLW  04
05EF4:  ADDWFC 03,F
05EF6:  MOVFF  01,556
05EFA:  MOVFF  03,557
05EFE:  MOVLW  01
05F00:  ADDWF  x54,W
05F02:  MULLW  08
05F04:  MOVF   FF3,W
05F06:  CLRF   03
05F08:  ADDLW  A7
05F0A:  MOVWF  FE9
05F0C:  MOVLW  04
05F0E:  ADDWFC 03,W
05F10:  MOVWF  FEA
05F12:  MOVF   FEE,F
05F14:  MOVF   FEE,F
05F16:  MOVF   FEE,F
05F18:  MOVF   FEE,F
05F1A:  MOVF   FEE,F
05F1C:  MOVF   FEE,F
05F1E:  MOVFF  FEC,55F
05F22:  MOVF   FED,F
05F24:  MOVFF  FEF,55E
05F28:  MOVF   FED,F
05F2A:  MOVFF  FEF,55D
05F2E:  MOVF   FED,F
05F30:  MOVFF  FEF,55C
05F34:  MOVF   FED,F
05F36:  MOVFF  FEF,55B
05F3A:  MOVF   FED,F
05F3C:  MOVFF  FEF,55A
05F40:  MOVF   FED,F
05F42:  MOVFF  FEF,559
05F46:  MOVF   FED,F
05F48:  MOVFF  FEF,558
05F4C:  MOVFF  557,FEA
05F50:  MOVFF  01,FE9
05F54:  MOVFF  559,FE2
05F58:  MOVFF  558,FE1
05F5C:  MOVLW  02
05F5E:  MOVWF  01
05F60:  MOVFF  FE6,FEE
05F64:  DECFSZ 01,F
05F66:  BRA    5F60
05F68:  INCF   x55,F
05F6A:  BRA    5EE0
....................          } 
....................          // clear out the last item 
....................          memset(&global_message_queue[global_current_message_queue_location],EMPTY_MESSAGE_QUEUE,sizeof(&global_message_queue[global_current_message_queue_location])); 
05F6C:  MOVLB  4
05F6E:  MOVF   xF7,W
05F70:  MULLW  08
05F72:  MOVF   FF3,W
05F74:  CLRF   03
05F76:  ADDLW  A7
05F78:  MOVWF  01
05F7A:  MOVLW  04
05F7C:  ADDWFC 03,F
05F7E:  MOVFF  01,556
05F82:  MOVLB  5
05F84:  MOVFF  03,557
05F88:  MOVFF  03,FEA
05F8C:  MOVFF  01,FE9
05F90:  CLRF   00
05F92:  CLRF   02
05F94:  MOVLW  02
05F96:  MOVWF  01
05F98:  MOVLB  0
05F9A:  CALL   22BE
....................          // decrement the message queue current position 
....................          global_current_message_queue_location--;  
05F9E:  MOVLB  4
05FA0:  DECF   xF7,F
....................          return; 
05FA2:  BRA    5FAC
05FA4:  MOVLB  5
....................       } 
05FA6:  INCF   x54,F
05FA8:  BRA    5E60
05FAA:  MOVLB  4
....................    } 
....................    return;                      
05FAC:  MOVLB  0
05FAE:  GOTO   7394 (RETURN)
.................... } 
....................  
.................... void remove_message_queue_item_ISR(uint16_t msg_seq) 
.................... { 
.................... // Finds the message with the passed msg_seq and removes it from the queue, 
.................... //    shifting all other messages in the queue up 
.................... // Returns 1 if message removed, 0 if not found 
.................... // This function is ONLY run as a result of a message not getting ack'd after 
.................... //    being resent numerous times 
....................  
....................    uint8_t n, m; 
....................  
....................    // no items in the queue (current location is 0-1) 
....................    if (global_current_message_queue_location == 255) 
*
022D8:  MOVLB  4
022DA:  INCFSZ xF7,W
022DC:  BRA    22E0
....................    { 
....................       return;   
022DE:  BRA    23F6
....................    } 
....................     
....................    // search through the message queue from 0 to the current top of queue 
....................    for (n = 0; n <= global_current_message_queue_location; n++) 
022E0:  MOVLB  6
022E2:  CLRF   x03
022E4:  MOVF   x03,W
022E6:  MOVLB  4
022E8:  SUBWF  xF7,W
022EA:  BTFSS  FD8.0
022EC:  BRA    23F6
....................    { 
....................       // if you find the matching message 
....................       if (global_message_queue[n].msg_seq == msg_seq) 
022EE:  MOVLB  6
022F0:  MOVF   x03,W
022F2:  MULLW  08
022F4:  MOVF   FF3,W
022F6:  CLRF   x06
022F8:  MOVWF  x05
022FA:  MOVLW  05
022FC:  ADDWF  x05,W
022FE:  MOVWF  01
02300:  MOVLW  00
02302:  ADDWFC x06,W
02304:  MOVWF  03
02306:  MOVF   01,W
02308:  ADDLW  A7
0230A:  MOVWF  FE9
0230C:  MOVLW  04
0230E:  ADDWFC 03,W
02310:  MOVWF  FEA
02312:  MOVFF  FEC,606
02316:  MOVF   FED,F
02318:  MOVFF  FEF,605
0231C:  MOVF   x01,W
0231E:  SUBWF  x05,W
02320:  BNZ   23F0
02322:  MOVF   x02,W
02324:  SUBWF  x06,W
02326:  BNZ   23F0
....................       { 
....................          // shift everything over 1 place starting by overwriting the item 
....................          //    to remove and ending by copying the top of the queue to the next item 
....................          for (m = n; m < (MAX_MESSAGE_QUEUE_ITEMS - 1); m++) 
02328:  MOVFF  603,604
0232C:  MOVF   x04,W
0232E:  SUBLW  08
02330:  BNC   23B8
....................          { 
....................             memcpy(&global_message_queue[n], global_message_queue[n+1], sizeof(&global_message_queue[n])); 
02332:  MOVF   x03,W
02334:  MULLW  08
02336:  MOVF   FF3,W
02338:  CLRF   03
0233A:  ADDLW  A7
0233C:  MOVWF  01
0233E:  MOVLW  04
02340:  ADDWFC 03,F
02342:  MOVFF  01,605
02346:  MOVFF  03,606
0234A:  MOVLW  01
0234C:  ADDWF  x03,W
0234E:  MULLW  08
02350:  MOVF   FF3,W
02352:  CLRF   03
02354:  ADDLW  A7
02356:  MOVWF  FE9
02358:  MOVLW  04
0235A:  ADDWFC 03,W
0235C:  MOVWF  FEA
0235E:  MOVF   FEE,F
02360:  MOVF   FEE,F
02362:  MOVF   FEE,F
02364:  MOVF   FEE,F
02366:  MOVF   FEE,F
02368:  MOVF   FEE,F
0236A:  MOVFF  FEC,60E
0236E:  MOVF   FED,F
02370:  MOVFF  FEF,60D
02374:  MOVF   FED,F
02376:  MOVFF  FEF,60C
0237A:  MOVF   FED,F
0237C:  MOVFF  FEF,60B
02380:  MOVF   FED,F
02382:  MOVFF  FEF,60A
02386:  MOVF   FED,F
02388:  MOVFF  FEF,609
0238C:  MOVF   FED,F
0238E:  MOVFF  FEF,608
02392:  MOVF   FED,F
02394:  MOVFF  FEF,607
02398:  MOVFF  606,FEA
0239C:  MOVFF  01,FE9
023A0:  MOVFF  608,FE2
023A4:  MOVFF  607,FE1
023A8:  MOVLW  02
023AA:  MOVWF  01
023AC:  MOVFF  FE6,FEE
023B0:  DECFSZ 01,F
023B2:  BRA    23AC
023B4:  INCF   x04,F
023B6:  BRA    232C
....................          } 
....................          // clear out the last item 
....................          memset(&global_message_queue[global_current_message_queue_location],EMPTY_MESSAGE_QUEUE,sizeof(&global_message_queue[global_current_message_queue_location])); 
023B8:  MOVLB  4
023BA:  MOVF   xF7,W
023BC:  MULLW  08
023BE:  MOVF   FF3,W
023C0:  CLRF   03
023C2:  ADDLW  A7
023C4:  MOVWF  01
023C6:  MOVLW  04
023C8:  ADDWFC 03,F
023CA:  MOVFF  01,605
023CE:  MOVLB  6
023D0:  MOVFF  03,606
023D4:  MOVFF  03,FEA
023D8:  MOVFF  01,FE9
023DC:  CLRF   00
023DE:  CLRF   02
023E0:  MOVLW  02
023E2:  MOVWF  01
023E4:  MOVLB  0
023E6:  RCALL  22BE
....................          // decrement the message queue current position 
....................          global_current_message_queue_location--; 
023E8:  MOVLB  4
023EA:  DECF   xF7,F
....................          return; 
023EC:  BRA    23F6
023EE:  MOVLB  6
....................       } 
023F0:  INCF   x03,F
023F2:  BRA    22E4
023F4:  MOVLB  4
....................    } 
....................    return; 
023F6:  MOVLB  0
023F8:  GOTO   28F0 (RETURN)
.................... } 
....................     
....................  
.................... #include "util.h" 
.................... /* This file contains all functions related to PIC functions 
....................  * 
....................  * 
....................  * 
....................  * 
....................  * 
....................  */ 
....................  
.................... /****************************************/ 
.................... void flash_leds(uint8_t num_of_flashes)                           
.................... { 
....................    uint8_t  n; 
....................     
....................    for (n = 0; n < num_of_flashes; n++) 
....................    { 
....................       LED1_ON 
....................       LED2_ON 
....................       setup_T0_int(T0_50MS); 
....................       while (!TMR0IF); 
....................        
....................       LED1_OFF    
....................       LED2_OFF                       
....................       if (n == (num_of_flashes - 1)) 
....................       { 
....................          return; 
....................       } 
....................       setup_T0_int(T0_50MS); 
....................       while (!TMR0IF);  
....................    }       
.................... } 
.................... void flash_leds_ISR(uint8_t num_of_flashes) 
.................... { 
....................    uint8_t  n; 
....................     
....................    for (n = 0; n < num_of_flashes; n++) 
....................    { 
....................       LED1_ON 
....................       LED2_ON 
....................       setup_T4_int(T4_64MS); 
....................       while (!TMR4IF); 
....................       LED1_OFF 
....................       LED2_OFF 
....................       setup_T4_int(T4_64MS); 
....................       while (!TMR4IF); 
....................    }       
.................... } 
....................  
....................  
.................... void flash_led_1(uint8_t num_of_flashes) 
.................... { 
....................    uint8_t  n; 
....................     
....................    for (n = 0; n < num_of_flashes; n++) 
....................    { 
....................       LED1_ON 
....................       setup_T0_int(T0_100MS); 
....................       while (!TMR0IF); 
....................        
....................       LED1_OFF 
....................       setup_T0_int(T0_100MS); 
....................       while (!TMR0IF);  
....................    }       
.................... } 
....................  
.................... void flash_led_2(uint8_t num_of_flashes) 
.................... { 
....................    uint8_t  n; 
....................     
....................    for (n = 0; n < num_of_flashes; n++) 
*
084B0:  MOVLB  5
084B2:  CLRF   x4C
084B4:  MOVF   x4B,W
084B6:  SUBWF  x4C,W
084B8:  BC    84EA
....................    { 
....................       LED2_ON 
084BA:  BCF    F89.2
....................       setup_T0_int(T0_100MS); 
084BC:  MOVLW  FE
084BE:  MOVWF  x69
084C0:  MOVLW  7A
084C2:  MOVWF  x68
084C4:  MOVLB  0
084C6:  CALL   38C2
....................       while (!TMR0IF); 
084CA:  BTFSS  FF2.2
084CC:  BRA    84CA
....................        
....................       LED2_OFF 
084CE:  BSF    F89.2
....................       setup_T0_int(T0_100MS); 
084D0:  MOVLW  FE
084D2:  MOVLB  5
084D4:  MOVWF  x69
084D6:  MOVLW  7A
084D8:  MOVWF  x68
084DA:  MOVLB  0
084DC:  CALL   38C2
....................       while (!TMR0IF);  
084E0:  BTFSS  FF2.2
084E2:  BRA    84E0
084E4:  MOVLB  5
084E6:  INCF   x4C,F
084E8:  BRA    84B4
....................    }       
084EA:  MOVLB  0
084EC:  GOTO   ADAE (RETURN)
.................... } 
....................  
.................... void happy_lites(void) 
.................... { 
.................... // blink the two leds in a fashion to let the operator know, e.g., 
.................... // that the SW1-initiated search process was successful 
....................    uint8_t  n; 
....................     
....................    for (n=0; n<4; n++) 
*
05034:  MOVLB  5
05036:  CLRF   x63
05038:  MOVF   x63,W
0503A:  SUBLW  03
0503C:  BNC   507E
....................    { 
....................       LED1_ON 
0503E:  BCF    F62.4
05040:  MOVLW  E7
05042:  MOVWF  F93
05044:  BCF    F8A.4
....................        
....................       setup_T0_int(T0_250MS); 
05046:  MOVLW  FC
05048:  MOVWF  x69
0504A:  MOVLW  30
0504C:  MOVWF  x68
0504E:  MOVLB  0
05050:  CALL   38C2
....................       while (!TMR0IF); 
05054:  BTFSS  FF2.2
05056:  BRA    5054
....................        
....................       LED1_OFF 
05058:  MOVLW  F7
0505A:  MOVWF  F93
0505C:  BSF    FF2.3
0505E:  BSF    F62.4
....................       LED2_ON 
05060:  BCF    F89.2
....................        
....................       setup_T0_int(T0_250MS); 
05062:  MOVLW  FC
05064:  MOVLB  5
05066:  MOVWF  x69
05068:  MOVLW  30
0506A:  MOVWF  x68
0506C:  MOVLB  0
0506E:  CALL   38C2
....................       while (!TMR0IF); 
05072:  BTFSS  FF2.2
05074:  BRA    5072
....................        
....................       LED2_OFF 
05076:  BSF    F89.2
05078:  MOVLB  5
0507A:  INCF   x63,F
0507C:  BRA    5038
....................    } 
0507E:  MOVLB  0
05080:  RETURN 0
.................... } 
....................  
.................... char *word_to_4dig_new (uint16_t xword) 
.................... { 
....................    /* Takes a uint16 and converts it to a 4 digit result 
....................     * that is stored in a static char pointer 
....................     */ 
....................      
....................    uint16_t temp_u16; 
....................    static char result[4]; 
....................    ldiv_t      lidiv_temp; 
....................    div_t       idiv_temp; 
....................     
....................    if (xword > 9999) 
....................       return 0; 
....................    else 
....................    {    
....................       lidiv_temp=ldiv(xword,1000); 
....................       result[3] = '0' + lidiv_temp.quot; 
....................       temp_u16 = lidiv_temp.rem; 
....................       lidiv_temp=ldiv(temp_u16,(uint16_t)(100)); 
....................       result[2] = '0' + lidiv_temp.quot; 
....................       idiv_temp = div((uint8_t)(lidiv_temp.rem),10); 
....................       result[1] = '0' + idiv_temp.quot; 
....................       result[0] = '0' + idiv_temp.rem; 
....................       return result; 
....................    } 
.................... } 
....................  
.................... // this routine ain't done yet 
.................... uint16_t convert_rpm_to_period(uint16_t rpm) 
.................... { 
....................    uint16_t period; 
....................    return period; 
.................... } 
.................... uint16_t convert_period_to_rpm(uint16_t period) 
.................... { 
....................    uint32_t rpm_32; 
....................    uint16_t rpm_16; 
....................     
....................    rpm_32 = CCP_PER_RPM/(make32(0,0,make8(period,1), make8(period,0))); 
*
05FF4:  MOVFF  558,55F
05FF8:  MOVFF  557,560
05FFC:  MOVLB  5
05FFE:  CLRF   x64
06000:  CLRF   x63
06002:  MOVFF  558,562
06006:  MOVFF  557,561
0600A:  BCF    FD8.1
0600C:  CLRF   19
0600E:  BTFSC  FF2.7
06010:  BSF    19.7
06012:  BCF    FF2.7
06014:  MOVLW  99
06016:  MOVLB  6
06018:  MOVWF  x19
0601A:  MOVWF  x18
0601C:  MOVWF  x17
0601E:  MOVLW  9A
06020:  MOVWF  x16
06022:  MOVFF  564,61D
06026:  MOVFF  563,61C
0602A:  MOVFF  558,61B
0602E:  MOVFF  557,61A
06032:  MOVLB  0
06034:  CALL   2570
06038:  BTFSC  19.7
0603A:  BSF    FF2.7
0603C:  MOVFF  03,55C
06040:  MOVFF  02,55B
06044:  MOVFF  01,55A
06048:  MOVFF  00,559
....................    rpm_16 = make16(make8(rpm_32,3), make8(rpm_32,2)); 
0604C:  MOVFF  55C,55E
06050:  MOVFF  55B,55D
....................    if (bit_test(rpm_32, 15)) rpm_16++;  
06054:  MOVLB  5
06056:  BTFSS  x5A.7
06058:  BRA    6060
0605A:  INCF   x5D,F
0605C:  BTFSC  FD8.2
0605E:  INCF   x5E,F
....................    return rpm_16; 
06060:  MOVFF  55D,01
06064:  MOVFF  55E,02
06068:  MOVLB  0
0606A:  RETURN 0
.................... } 
.................... uint16_t convert_period_to_rpm_ISR(uint16_t period) 
.................... { 
....................    uint32_t rpm_32; 
....................    uint16_t rpm_16; 
....................     
....................    rpm_32 = CCP_PER_RPM/(make32(0,0,make8(period,1), make8(period,0))); 
*
02604:  MOVFF  609,610
02608:  MOVFF  608,611
0260C:  MOVLB  6
0260E:  CLRF   x15
02610:  CLRF   x14
02612:  MOVFF  609,613
02616:  MOVFF  608,612
0261A:  BCF    FD8.1
0261C:  MOVLW  99
0261E:  MOVWF  x19
02620:  MOVWF  x18
02622:  MOVWF  x17
02624:  MOVLW  9A
02626:  MOVWF  x16
02628:  MOVFF  615,61D
0262C:  MOVFF  614,61C
02630:  MOVFF  609,61B
02634:  MOVFF  608,61A
02638:  MOVLB  0
0263A:  RCALL  2570
0263C:  MOVFF  03,60D
02640:  MOVFF  02,60C
02644:  MOVFF  01,60B
02648:  MOVFF  00,60A
....................    rpm_16 = make16(make8(rpm_32,3), make8(rpm_32,2)); 
0264C:  MOVFF  60D,60F
02650:  MOVFF  60C,60E
....................    if (bit_test(rpm_32, 15)) rpm_16++;  
02654:  MOVLB  6
02656:  BTFSS  x0B.7
02658:  BRA    2660
0265A:  INCF   x0E,F
0265C:  BTFSC  FD8.2
0265E:  INCF   x0F,F
....................    return rpm_16; 
02660:  MOVFF  60E,01
02664:  MOVFF  60F,02
02668:  MOVLB  0
0266A:  GOTO   276C (RETURN)
.................... } 
.................... uint8_t  hi2asc(uint8_t xbyte) 
.................... { 
....................    xbyte >>= 4; 
*
032F4:  MOVLB  5
032F6:  SWAPF  x64,F
032F8:  MOVLW  0F
032FA:  ANDWF  x64,F
....................    if (xbyte < 0x0A) 
032FC:  MOVF   x64,W
032FE:  SUBLW  09
03300:  BNC   3308
....................       xbyte += 0x30; 
03302:  MOVLW  30
03304:  ADDWF  x64,F
03306:  BRA    330C
....................    else 
....................       xbyte += 0x37; 
03308:  MOVLW  37
0330A:  ADDWF  x64,F
....................    return xbyte; 
0330C:  MOVFF  564,01
03310:  MOVLB  0
03312:  RETURN 0
.................... } 
....................  
....................  
.................... uint8_t  lo2asc(uint8_t xbyte) 
.................... { 
....................    xbyte &= 0x0F; 
03314:  MOVLW  0F
03316:  MOVLB  5
03318:  ANDWF  x64,F
....................    if (xbyte < 0x0A) 
0331A:  MOVF   x64,W
0331C:  SUBLW  09
0331E:  BNC   3326
....................       xbyte += 0x30; 
03320:  MOVLW  30
03322:  ADDWF  x64,F
03324:  BRA    332A
....................    else 
....................       xbyte += 0x37; 
03326:  MOVLW  37
03328:  ADDWF  x64,F
....................    return xbyte; 
0332A:  MOVFF  564,01
0332E:  MOVLB  0
03330:  RETURN 0
.................... } 
....................  
....................  
.................... void main() 
*
0A114:  CLRF   FF8
0A116:  BCF    FF0.7
0A118:  BCF    FF1.0
0A11A:  BCF    FA2.3
0A11C:  BCF    FA2.6
0A11E:  BSF    F7C.0
0A120:  BCF    F7C.1
0A122:  BSF    F7C.2
0A124:  BSF    FD0.7
0A126:  BSF    07.7
0A128:  BCF    FB8.3
0A12A:  MOVLW  01
0A12C:  MOVWF  FAF
0A12E:  MOVLW  A6
0A130:  MOVWF  FAC
0A132:  MOVLW  90
0A134:  MOVWF  FAB
0A136:  CLRF   4A
0A138:  CLRF   49
0A13A:  CLRF   48
0A13C:  CLRF   47
0A13E:  CLRF   4C
0A140:  CLRF   4B
0A142:  CLRF   4D
0A144:  CLRF   4E
0A146:  CLRF   54
0A148:  CLRF   55
0A14A:  CLRF   59
0A14C:  CLRF   58
0A14E:  CLRF   57
0A150:  CLRF   56
0A152:  CLRF   5D
0A154:  CLRF   5C
0A156:  CLRF   5B
0A158:  CLRF   5A
0A15A:  CLRF   5F
0A15C:  CLRF   5E
0A15E:  CLRF   x61
0A160:  CLRF   x60
0A162:  CLRF   x63
0A164:  CLRF   x62
0A166:  CLRF   x65
0A168:  CLRF   x64
0A16A:  CLRF   x67
0A16C:  CLRF   x66
0A16E:  CLRF   x69
0A170:  CLRF   x68
0A172:  CLRF   x6B
0A174:  CLRF   x6A
0A176:  CLRF   x6D
0A178:  CLRF   x6C
0A17A:  CLRF   x6F
0A17C:  CLRF   x6E
0A17E:  CLRF   x83
0A180:  MOVLW  01
0A182:  MOVWF  x84
0A184:  CLRF   x88
0A186:  CLRF   x87
0A188:  CLRF   x86
0A18A:  CLRF   x85
0A18C:  CLRF   x8C
0A18E:  CLRF   x8B
0A190:  CLRF   x8A
0A192:  CLRF   x89
0A194:  CLRF   x90
0A196:  CLRF   x8F
0A198:  CLRF   x8E
0A19A:  CLRF   x8D
0A19C:  CLRF   x94
0A19E:  CLRF   x93
0A1A0:  CLRF   x92
0A1A2:  CLRF   x91
0A1A4:  CLRF   x96
0A1A6:  CLRF   x95
0A1A8:  CLRF   xA7
0A1AA:  CLRF   xA9
0A1AC:  CLRF   xA8
0A1AE:  CLRF   xAD
0A1B0:  MOVLW  64
0A1B2:  MOVWF  xAC
0A1B4:  CLRF   xB1
0A1B6:  CLRF   xB0
0A1B8:  CLRF   xAF
0A1BA:  CLRF   xAE
0A1BC:  CLRF   xB3
0A1BE:  CLRF   xB2
0A1C0:  MOVLW  01
0A1C2:  MOVWF  xB5
0A1C4:  MOVLW  90
0A1C6:  MOVWF  xB4
0A1C8:  CLRF   xB7
0A1CA:  CLRF   xB6
0A1CC:  MOVLW  01
0A1CE:  MOVWF  xB9
0A1D0:  MOVLW  90
0A1D2:  MOVWF  xB8
0A1D4:  MOVLW  64
0A1D6:  MOVWF  xBA
0A1D8:  MOVWF  xBB
0A1DA:  CLRF   xBD
0A1DC:  CLRF   xBC
0A1DE:  CLRF   xBF
0A1E0:  CLRF   xBE
0A1E2:  CLRF   xC0
0A1E4:  MOVLW  40
0A1E6:  MOVWF  xC2
0A1E8:  CLRF   xC1
0A1EA:  MOVWF  xC4
0A1EC:  CLRF   xC3
0A1EE:  MOVLW  05
0A1F0:  MOVWF  xC6
0A1F2:  CLRF   xC5
0A1F4:  MOVWF  xC8
0A1F6:  CLRF   xC7
0A1F8:  CLRF   xCA
0A1FA:  CLRF   xC9
0A1FC:  CLRF   xCE
0A1FE:  CLRF   xCD
0A200:  CLRF   xCC
0A202:  CLRF   xCB
0A204:  CLRF   xCF
0A206:  MOVLW  20
0A208:  MOVWF  xD1
0A20A:  CLRF   xD0
0A20C:  SETF   xD3
0A20E:  SETF   xD2
0A210:  CLRF   xD7
0A212:  CLRF   xD6
0A214:  CLRF   xD5
0A216:  CLRF   xD4
0A218:  MOVLB  3
0A21A:  CLRF   x51
0A21C:  CLRF   x52
0A21E:  CLRF   x5F
0A220:  CLRF   x62
0A222:  CLRF   x63
0A224:  CLRF   x64
0A226:  CLRF   x66
0A228:  CLRF   x65
0A22A:  MOVLW  04
0A22C:  MOVWF  x68
0A22E:  MOVLW  CD
0A230:  MOVWF  x67
0A232:  CLRF   x6A
0A234:  CLRF   x69
0A236:  CLRF   x6B
0A238:  CLRF   x6C
0A23A:  CLRF   x6D
0A23C:  SETF   x82
0A23E:  SETF   x9C
0A240:  MOVLB  4
0A242:  SETF   x29
0A244:  SETF   00
0A246:  SETF   01
0A248:  SETF   02
0A24A:  SETF   03
0A24C:  MOVFF  03,42D
0A250:  MOVFF  02,42C
0A254:  MOVFF  01,42B
0A258:  MOVFF  00,42A
0A25C:  SETF   xA6
0A25E:  SETF   xF7
0A260:  CLRF   xFB
0A262:  CLRF   xFA
0A264:  CLRF   xF9
0A266:  CLRF   xF8
0A268:  CLRF   xFF
0A26A:  CLRF   xFE
0A26C:  CLRF   xFD
0A26E:  CLRF   xFC
0A270:  MOVLB  5
0A272:  CLRF   x03
0A274:  CLRF   x02
0A276:  CLRF   x01
0A278:  CLRF   x00
0A27A:  SETF   x04
0A27C:  SETF   x05
0A27E:  MOVLW  10
0A280:  MOVWF  x07
0A282:  CLRF   x06
0A284:  MOVLW  70
0A286:  MOVWF  x09
0A288:  CLRF   x08
0A28A:  CLRF   x0B
0A28C:  MOVLW  18
0A28E:  MOVWF  x0A
0A290:  CLRF   x0D
0A292:  MOVLW  14
0A294:  MOVWF  x0C
0A296:  CLRF   x0F
0A298:  MOVWF  x0E
0A29A:  CLRF   x11
0A29C:  MOVLW  18
0A29E:  MOVWF  x10
0A2A0:  CLRF   x13
0A2A2:  MOVLW  13
0A2A4:  MOVWF  x12
0A2A6:  CLRF   x15
0A2A8:  MOVWF  x14
0A2AA:  CLRF   x17
0A2AC:  MOVLW  1E
0A2AE:  MOVWF  x16
0A2B0:  MOVLW  40
0A2B2:  MOVWF  x19
0A2B4:  CLRF   x18
0A2B6:  MOVLW  70
0A2B8:  MOVWF  x1B
0A2BA:  CLRF   x1A
0A2BC:  MOVLW  08
0A2BE:  MOVWF  x1C
0A2C0:  MOVLW  50
0A2C2:  MOVWF  x1E
0A2C4:  CLRF   x1D
0A2C6:  MOVLW  10
0A2C8:  MOVWF  x20
0A2CA:  CLRF   x1F
0A2CC:  CLRF   x22
0A2CE:  MOVLW  02
0A2D0:  MOVWF  x21
0A2D2:  CLRF   x24
0A2D4:  MOVLW  78
0A2D6:  MOVWF  x23
0A2D8:  MOVLW  04
0A2DA:  MOVWF  x26
0A2DC:  MOVLW  B0
0A2DE:  MOVWF  x25
0A2E0:  CLRF   x27
0A2E2:  BCF    FB8.3
0A2E4:  MOVLW  01
0A2E6:  MOVWF  FAF
0A2E8:  MOVLW  A6
0A2EA:  MOVWF  FAC
0A2EC:  MOVLW  90
0A2EE:  MOVWF  FAB
0A2F0:  BCF    FCB.0
0A2F2:  BCF    FCB.1
0A2F4:  BCF    FCB.3
0A2F6:  MOVLW  06
0A2F8:  MOVWF  FC8
0A2FA:  MOVLW  28
0A2FC:  MOVWF  FC6
0A2FE:  BSF    FC7.7
0A300:  BCF    FC7.6
0A302:  CLRF   x3A
0A304:  CLRF   x39
0A306:  CLRF   x3C
0A308:  CLRF   x3B
0A30A:  CLRF   x3D
0A30C:  CLRF   x3E
0A30E:  MOVLW  01
0A310:  MOVWF  x3F
0A312:  CLRF   x45
0A314:  CLRF   x44
0A316:  CLRF   x47
0A318:  CLRF   x46
0A31A:  MOVLB  F
0A31C:  CLRF   x38
0A31E:  CLRF   x39
0A320:  CLRF   x3A
0A322:  CLRF   x3B
0A324:  CLRF   x3C
0A326:  CLRF   F77
0A328:  CLRF   F78
0A32A:  CLRF   F79
0A32C:  MOVLW  06
0A32E:  MOVWF  36
0A330:  MOVLW  40
0A332:  MOVWF  35
0A334:  MOVLW  08
0A336:  MOVLB  6
0A338:  MOVWF  x41
0A33A:  MOVLW  F4
0A33C:  MOVWF  x40
0A33E:  CLRF   x43
0A340:  CLRF   x42
0A342:  MOVLB  0
0A344:  BRA    A38A
0A346:  DATA 02,00
0A348:  DATA 2F,00
0A34A:  DATA 00,10
0A34C:  DATA 00,37
0A34E:  DATA 44,55
0A350:  DATA 53,54
0A352:  DATA 4E,45
0A354:  DATA 54,57
0A356:  DATA 4F,52
0A358:  DATA 4B,53
0A35A:  DATA 52,4F
0A35C:  DATA 43,4B
0A35E:  DATA 05,00
0A360:  DATA 4F,41
0A362:  DATA 30,30
0A364:  DATA 30,00
0A366:  DATA 10,40
0A368:  DATA 97,00
0A36A:  DATA 14,43
0A36C:  DATA 6E,00
0A36E:  DATA 19,43
0A370:  DATA 83,00
0A372:  DATA 8C,43
0A374:  DATA 9D,00
0A376:  DATA 78,44
0A378:  DATA 2E,00
0A37A:  DATA 50,44
0A37C:  DATA A7,00
0A37E:  DATA 11,45
0A380:  DATA 28,00
0A382:  DATA 04,05
0A384:  DATA 40,00
0A386:  DATA 00,00
0A388:  DATA 00,00
0A38A:  MOVLW  00
0A38C:  MOVWF  FF8
0A38E:  MOVLW  A3
0A390:  MOVWF  FF7
0A392:  MOVLW  46
0A394:  MOVWF  FF6
0A396:  TBLRD*+
0A398:  MOVF   FF5,W
0A39A:  MOVWF  00
0A39C:  XORLW  00
0A39E:  BZ    A3C6
0A3A0:  TBLRD*+
0A3A2:  MOVF   FF5,W
0A3A4:  MOVWF  01
0A3A6:  BTFSC  FE8.7
0A3A8:  BRA    A3B4
0A3AA:  ANDLW  0F
0A3AC:  MOVWF  FEA
0A3AE:  TBLRD*+
0A3B0:  MOVF   FF5,W
0A3B2:  MOVWF  FE9
0A3B4:  BTFSC  01.6
0A3B6:  TBLRD*+
0A3B8:  BTFSS  01.6
0A3BA:  TBLRD*+
0A3BC:  MOVF   FF5,W
0A3BE:  MOVWF  FEE
0A3C0:  DCFSNZ 00,F
0A3C2:  BRA    A396
0A3C4:  BRA    A3B8
0A3C6:  CLRF   FF8
0A3C8:  MOVLB  5
0A3CA:  CLRF   x48
.................... {                                                          
....................    // priority queue item that is to be executed 
....................    uint8_t     priority_queue_item_to_execute = EMPTY_PRIORITY_QUEUE;     
....................    // valve setting that is stored when free spin rate is performed (so you can return to it afterwards) 
....................    uint16_t    pre_fsr_valve_setting;                                          
....................                                         
....................    // set system state to init 
....................    write_system_state(SYSTEM_INIT);               
0A3CC:  CLRF   x4B
0A3CE:  MOVLB  0
0A3D0:  CALL   3286
....................                 
....................    // initalize oscillator and timing of rs232, i2c, delay 
....................    osc_init();          
0A3D4:  GOTO   32E8
....................  
....................    // initalize all variables (not really needed as they are initalized properly when CPU is rebooted)                                                         
....................    //vars_init();                   
....................     
....................    // store string version of firmware version in global_firmware_version_string                                                            
....................    global_firmware_version_string[0] = hi2asc(make8(FIRMWARE_VERSION,1)); 
0A3D8:  MOVLW  E3
0A3DA:  MOVLB  5
0A3DC:  MOVWF  x64
0A3DE:  MOVLB  0
0A3E0:  CALL   32F4
0A3E4:  MOVFF  01,4F
....................    global_firmware_version_string[1] = lo2asc(make8(FIRMWARE_VERSION,1)); 
0A3E8:  MOVLW  E3
0A3EA:  MOVLB  5
0A3EC:  MOVWF  x64
0A3EE:  MOVLB  0
0A3F0:  CALL   3314
0A3F4:  MOVFF  01,50
....................    global_firmware_version_string[2] = hi2asc(make8(FIRMWARE_VERSION,0));       
0A3F8:  MOVLW  13
0A3FA:  MOVLB  5
0A3FC:  MOVWF  x64
0A3FE:  MOVLB  0
0A400:  CALL   32F4
0A404:  MOVFF  01,51
....................    global_firmware_version_string[3] = lo2asc(make8(FIRMWARE_VERSION,0));    
0A408:  MOVLW  13
0A40A:  MOVLB  5
0A40C:  MOVWF  x64
0A40E:  MOVLB  0
0A410:  CALL   3314
0A414:  MOVFF  01,52
....................  
....................    // grab all eeprom values (e.g. vlv cal, sprinkler number, vlv position) 
....................    read_all_eeprom_values();    
0A418:  GOTO   3500
....................     
....................    // load all changeable eeprom variables  
....................    read_all_eeprom_variables();         
0A41C:  GOTO   3638
....................                                 
....................    // initalize all periphs, timers, ccps, ints    
....................    periph_init(); 
0A420:  GOTO   4094
....................                                      
....................    // clear queues     
....................    clear_priority_queue();                                  
0A424:  GOTO   41C0
....................    clear_time_queue(); 
0A428:  GOTO   41E4
....................    clear_message_queue();       
0A42C:  GOTO   4244
....................     
....................    // command queue is not needed/used yet as it is used in conjunction with the "modulation" scheme 
....................    //allocate_command_queue(); 
....................    //clear_command_queue(); 
....................     
....................    // startup rtc, turn on gen_rpm, enable dust chip (check for communication) 
....................    start_rtc();    
0A430:  GOTO   4260
....................    setup_gen_rpm();         
0A434:  GOTO   4292
....................    mote_init(); 
0A438:  GOTO   4494
....................                           
....................    // if cold start was done, reset mote    
....................    if (global_previous_shutdown_cause == COLD_RESTART_REQUEST) 
0A43C:  MOVF   4E,W
0A43E:  SUBLW  0A
0A440:  BNZ   A446
....................    { 
....................       mote_reset();           
0A442:  CALL   46EE
....................    }          
....................                           
....................    // DELETE?                              
....................    enable_interrupts(GLOBAL);                      
0A446:  MOVLW  C0
0A448:  IORWF  FF2,F
....................                                        
....................    // if SW1 is asserted during boot, trigger searching alogrithm                
....................    if (!input(SW1n))              
0A44A:  BTFSC  F81.4
0A44C:  BRA    A4C0
....................    {                                             
....................       // set the system state up for searching for a network (not run) 
....................       write_system_state(SYSTEM_SEARCHING_FOR_NETWORK); 
0A44E:  MOVLW  20
0A450:  MOVLB  5
0A452:  MOVWF  x4B
0A454:  MOVLB  0
0A456:  CALL   3286
....................       strcpy (global_temp_line_buff, "Setup Manager..."); 
0A45A:  CLRF   FEA
0A45C:  MOVLW  70
0A45E:  MOVWF  FE9
0A460:  MOVLW  00
0A462:  CALL   0632
0A466:  TBLRD*-
0A468:  TBLRD*+
0A46A:  MOVF   FF5,W
0A46C:  MOVWF  FEE
0A46E:  IORLW  00
0A470:  BNZ   A468
....................       LCD_line1(global_temp_line_buff); 
0A472:  MOVLB  5
0A474:  CLRF   x64
0A476:  MOVLW  70
0A478:  MOVWF  x63
0A47A:  MOVLB  0
0A47C:  CALL   39B0
....................       strcpy (global_temp_line_buff, "  Release SW1   "); 
0A480:  CLRF   FEA
0A482:  MOVLW  70
0A484:  MOVWF  FE9
0A486:  MOVLW  00
0A488:  CALL   0654
0A48C:  TBLRD*-
0A48E:  TBLRD*+
0A490:  MOVF   FF5,W
0A492:  MOVWF  FEE
0A494:  IORLW  00
0A496:  BNZ   A48E
....................       LCD_line2(global_temp_line_buff);      
0A498:  MOVLB  5
0A49A:  CLRF   x64
0A49C:  MOVLW  70
0A49E:  MOVWF  x63
0A4A0:  MOVLB  0
0A4A2:  CALL   3A0A
....................       // wait for switch release  
....................       while (!input(SW1n));       
0A4A6:  BTFSS  F81.4
0A4A8:  BRA    A4A6
....................       // delay lcd update for a tiny bit                                                                                                                              
....................       global_skip_lcd_update_count = 1; 
0A4AA:  MOVLW  01
0A4AC:  MOVWF  x83
....................       // first part of search alorithm sequence                                                                                       
....................       PUSH_PRIORITY_QUEUE_MACRO(SEARCH_FOR_STRONGEST_1);                  
0A4AE:  BCF    F7A.1
0A4B0:  MOVLW  B1
0A4B2:  MOVLB  5
0A4B4:  MOVWF  x52
0A4B6:  MOVLB  0
0A4B8:  CALL   4748
0A4BC:  BSF    F7A.1
....................    }                                  
0A4BE:  BRA    A5B4
....................     
....................    // normal behavior, check mote status.  Join network if necessary.                                                                                                       
....................    else  
....................    {                                  
....................       // Fun startup splash screen (and clear startup screen) 
....................       //LCD_startup_splash();        
....................       //LCD_clear();                   
....................        
....................       // enable RB4 button press functionality       
....................       setup_rb4_int();         
0A4C0:  GOTO   480E
....................                                                                                     
....................       // dispaly battery voltage (line 0) and restart/shutdown cause (line 1) on screen for a second  
....................       LCD_display_battery_voltage(0);     
0A4C4:  MOVLB  5
0A4C6:  CLRF   x4B
0A4C8:  MOVLB  0
0A4CA:  GOTO   4F58
....................       LCD_display_shutdown_cause(1);             
0A4CE:  MOVLW  01
0A4D0:  MOVLB  5
0A4D2:  MOVWF  x4B
0A4D4:  MOVLB  0
0A4D6:  GOTO   4FDA
....................         
....................       // global_skip_lcd_update_count is our way of letting things stay on the lcd for a moment 
....................       //    You set it to the number of times to skip an LCD update + 1 
....................       //    e.g. setting it to 2 means things stay on the screen for 1-2 seconds and then they are cleared 
....................       //    e.g. setting it to 1 means things are cleared right away 
....................       //    e.g. setting it to 0 (or not setting it) means the LCD screen is just overwritten by LCD update 
....................       global_skip_lcd_update_count = 2;         
0A4DA:  MOVLW  02
0A4DC:  MOVWF  x83
....................        
....................       // all periphs should be initalized (except mote), so system should be ready to run         
....................       write_system_state(SYSTEM_INIT); 
0A4DE:  MOVLB  5
0A4E0:  CLRF   x4B
0A4E2:  MOVLB  0
0A4E4:  CALL   3286
....................                                        
....................       // flash the leds to help identify motes    
....................       happy_lites(); 
0A4E8:  CALL   5034
....................        
....................       // check mote state. If it needs to connect, it will react as it should            
....................       PUSH_TIME_QUEUE_MACRO(global_rtc_time + 5, CHECK_MOTE_STATE);   
0A4EC:  BCF    F7A.1
0A4EE:  MOVLW  05
0A4F0:  ADDWF  x85,W
0A4F2:  MOVLB  5
0A4F4:  MOVWF  x4B
0A4F6:  MOVLW  00
0A4F8:  MOVLB  0
0A4FA:  ADDWFC x86,W
0A4FC:  MOVLB  5
0A4FE:  MOVWF  x4C
0A500:  MOVLW  00
0A502:  MOVLB  0
0A504:  ADDWFC x87,W
0A506:  MOVLB  5
0A508:  MOVWF  x4D
0A50A:  MOVLW  00
0A50C:  MOVLB  0
0A50E:  ADDWFC x88,W
0A510:  MOVLB  5
0A512:  MOVWF  x4E
0A514:  MOVWF  x59
0A516:  MOVFF  54D,558
0A51A:  MOVFF  54C,557
0A51E:  MOVFF  54B,556
0A522:  MOVLW  B4
0A524:  MOVWF  x5A
0A526:  MOVLB  0
0A528:  CALL   44A0
0A52C:  BSF    F7A.1
....................        
....................       // check mote info 
....................       PUSH_TIME_QUEUE_MACRO(global_rtc_time + 10, UPDATE_MOTE_NETWORK_INFO); 
0A52E:  BCF    F7A.1
0A530:  MOVLW  0A
0A532:  ADDWF  x85,W
0A534:  MOVLB  5
0A536:  MOVWF  x4B
0A538:  MOVLW  00
0A53A:  MOVLB  0
0A53C:  ADDWFC x86,W
0A53E:  MOVLB  5
0A540:  MOVWF  x4C
0A542:  MOVLW  00
0A544:  MOVLB  0
0A546:  ADDWFC x87,W
0A548:  MOVLB  5
0A54A:  MOVWF  x4D
0A54C:  MOVLW  00
0A54E:  MOVLB  0
0A550:  ADDWFC x88,W
0A552:  MOVLB  5
0A554:  MOVWF  x4E
0A556:  MOVWF  x59
0A558:  MOVFF  54D,558
0A55C:  MOVFF  54C,557
0A560:  MOVFF  54B,556
0A564:  MOVLW  A4
0A566:  MOVWF  x5A
0A568:  MOVLB  0
0A56A:  CALL   44A0
0A56E:  BSF    F7A.1
....................        
.................... #IFDEF OPEN_VALVE_TO_SETPT_AT_BOOT       
....................       PUSH_TIME_QUEUE_MACRO(global_rtc_time + 15, CLOSE_VALVE_UNKNOWN_STATE); 
0A570:  BCF    F7A.1
0A572:  MOVLW  0F
0A574:  ADDWF  x85,W
0A576:  MOVLB  5
0A578:  MOVWF  x4B
0A57A:  MOVLW  00
0A57C:  MOVLB  0
0A57E:  ADDWFC x86,W
0A580:  MOVLB  5
0A582:  MOVWF  x4C
0A584:  MOVLW  00
0A586:  MOVLB  0
0A588:  ADDWFC x87,W
0A58A:  MOVLB  5
0A58C:  MOVWF  x4D
0A58E:  MOVLW  00
0A590:  MOVLB  0
0A592:  ADDWFC x88,W
0A594:  MOVLB  5
0A596:  MOVWF  x4E
0A598:  MOVWF  x59
0A59A:  MOVFF  54D,558
0A59E:  MOVFF  54C,557
0A5A2:  MOVFF  54B,556
0A5A6:  MOVLW  3F
0A5A8:  MOVWF  x5A
0A5AA:  MOVLB  0
0A5AC:  CALL   44A0
0A5B0:  BSF    F7A.1
....................       // setup WDT for 1 second (plenty long for the control loop (~64ms) to  
.................... #ENDIF 
....................       setup_wdt(WDT_1S);      
0A5B2:  BSF    FD1.0
....................    }                                                                  
....................                                                               
....................    // start the queue/control loop timer 
....................    setup_T2_int(T2_64MS);     
0A5B4:  MOVLB  5
0A5B6:  SETF   x4B
0A5B8:  MOVLB  0
0A5BA:  CALL   5082
....................         
....................      
....................    // HACKY LAB STUFF TO REMOVE LATER 
.................... //   global_valve_position = VLV_PRECALIBRATION_POSITION;  
.................... //   global_valve_position_set_value = VLV_PRECALIBRATION_POSITION;                         
.................... //   global_valve_time_to_close_1024th = DEFAULT_VLV_TIME_TO_CLOSE;                         
.................... //   global_valve_time_to_open_1024th = DEFAULT_VLV_TIME_TO_OPEN;                         
....................                             
....................    while(1)                    
....................    {                
....................       // restart the watchdog timer     
....................       restart_wdt();     
0A5BE:  CLRWDT
....................    
....................                  
.................... ////////////////////Start of Priority Queue Handling/////////////////////////// 
....................                                                                        
....................       // Timer 2 is used to signal the priority queue to check for another item 
....................       //    to execute. This is only done once every 64ms to NOT keep the  
....................       //    system in a state with the interrupts disabled all the time. 
....................       // Timer 2 is also used to time the control loop.  How often the set point 
....................       //    is re-evaluated and adjustments are made to the actual values is 
....................       //    controlled by control_loop_delay_cycles_left within update_control_loop() 
....................        
....................       // if it is time to check priority queue/control loop 
....................       if (TMR2IF)  
0A5C0:  BTFSS  F9E.1
0A5C2:  GOTO   B1D4
....................       {   
....................          // reset the timer 2 queue loop interrupt 
....................          setup_T2_int(T2_64MS);       
0A5C6:  MOVLB  5
0A5C8:  SETF   x4B
0A5CA:  MOVLB  0
0A5CC:  CALL   5082
....................                              
....................          // update the control loop if the system isn't in the system wait (low-power) state 
....................          if (read_system_state() != SYSTEM_IDLE) update_control_loop();            
0A5D0:  CALL   1F4A
0A5D4:  MOVF   01,W
0A5D6:  SUBLW  03
0A5D8:  BTFSS  FD8.2
0A5DA:  GOTO   55DA
....................  
....................          // Safely grab the next item in the priority queue to execute                 
....................          // All interrupts that can modify the queue need to be disabled to                             
....................          //    ensure memory is not corrupted.       
....................          disable_interrupts(INT_CCP4); 
0A5DE:  BCF    F7A.1
....................          disable_interrupts(INT_EXT2);        
0A5E0:  BCF    FF0.4
....................          priority_queue_item_to_execute = pop_priority_queue();    
0A5E2:  GOTO   5DDC
0A5E6:  MOVFF  01,548
....................          enable_interrupts(INT_EXT2);    
0A5EA:  BSF    FF0.4
....................          enable_interrupts(INT_CCP4);              
0A5EC:  BSF    F7A.1
....................                                                        
....................          // execute the priority queue item     
....................          switch (priority_queue_item_to_execute)                                
0A5EE:  MOVLB  5
0A5F0:  MOVF   x48,W
0A5F2:  XORLW  20
0A5F4:  MOVLB  0
0A5F6:  BTFSC  FD8.2
0A5F8:  BRA    A6FE
0A5FA:  XORLW  61
0A5FC:  BTFSC  FD8.2
0A5FE:  BRA    A73E
0A600:  XORLW  70
0A602:  BTFSC  FD8.2
0A604:  BRA    A786
0A606:  XORLW  03
0A608:  BTFSC  FD8.2
0A60A:  BRA    A824
0A60C:  XORLW  01
0A60E:  BTFSC  FD8.2
0A610:  BRA    A848
0A612:  XORLW  07
0A614:  BTFSC  FD8.2
0A616:  BRA    A86E
0A618:  XORLW  01
0A61A:  BTFSC  FD8.2
0A61C:  BRA    A88E
0A61E:  XORLW  03
0A620:  BTFSC  FD8.2
0A622:  BRA    A8B2
0A624:  XORLW  01
0A626:  BTFSC  FD8.2
0A628:  BRA    A9DC
0A62A:  XORLW  0F
0A62C:  BTFSC  FD8.2
0A62E:  BRA    AA0C
0A630:  XORLW  01
0A632:  BTFSC  FD8.2
0A634:  BRA    AA6C
0A636:  XORLW  05
0A638:  BTFSC  FD8.2
0A63A:  BRA    AA7C
0A63C:  XORLW  01
0A63E:  BTFSC  FD8.2
0A640:  BRA    AA9C
0A642:  XORLW  03
0A644:  BTFSC  FD8.2
0A646:  BRA    AABC
0A648:  XORLW  01
0A64A:  BTFSC  FD8.2
0A64C:  BRA    AB0C
0A64E:  XORLW  7F
0A650:  BTFSC  FD8.2
0A652:  BRA    AB5A
0A654:  XORLW  10
0A656:  BTFSC  FD8.2
0A658:  BRA    ACF6
0A65A:  XORLW  01
0A65C:  BTFSC  FD8.2
0A65E:  BRA    ACF8
0A660:  XORLW  04
0A662:  BTFSC  FD8.2
0A664:  BRA    ACFA
0A666:  XORLW  03
0A668:  BTFSC  FD8.2
0A66A:  BRA    AD40
0A66C:  XORLW  82
0A66E:  BTFSC  FD8.2
0A670:  BRA    AD56
0A672:  XORLW  14
0A674:  BTFSC  FD8.2
0A676:  GOTO   ADC8
0A67A:  XORLW  D1
0A67C:  BTFSC  FD8.2
0A67E:  GOTO   ADEA
0A682:  XORLW  01
0A684:  BTFSC  FD8.2
0A686:  GOTO   AE20
0A68A:  XORLW  A4
0A68C:  BTFSC  FD8.2
0A68E:  GOTO   AE70
0A692:  XORLW  01
0A694:  BTFSC  FD8.2
0A696:  GOTO   AE76
0A69A:  XORLW  16
0A69C:  BTFSC  FD8.2
0A69E:  GOTO   AE7C
0A6A2:  XORLW  07
0A6A4:  BTFSC  FD8.2
0A6A6:  GOTO   AE82
0A6AA:  XORLW  05
0A6AC:  BTFSC  FD8.2
0A6AE:  GOTO   AE88
0A6B2:  XORLW  04
0A6B4:  BTFSC  FD8.2
0A6B6:  GOTO   AE8E
0A6BA:  XORLW  07
0A6BC:  BTFSC  FD8.2
0A6BE:  GOTO   AEC8
0A6C2:  XORLW  13
0A6C4:  BTFSC  FD8.2
0A6C6:  GOTO   AECE
0A6CA:  XORLW  03
0A6CC:  BTFSC  FD8.2
0A6CE:  GOTO   AF54
0A6D2:  XORLW  01
0A6D4:  BTFSC  FD8.2
0A6D6:  GOTO   AF88
0A6DA:  XORLW  13
0A6DC:  BTFSC  FD8.2
0A6DE:  GOTO   AFBC
0A6E2:  XORLW  50
0A6E4:  BTFSC  FD8.2
0A6E6:  GOTO   AFC2
0A6EA:  XORLW  01
0A6EC:  BTFSC  FD8.2
0A6EE:  GOTO   B068
0A6F2:  XORLW  F1
0A6F4:  BTFSC  FD8.2
0A6F6:  GOTO   B1D4
0A6FA:  GOTO   B1D4
....................          { 
....................             // Decode a new packet and react/respond appropriately 
....................             case DEAL_WITH_NEW_PACKET:             
....................                // Display that you're dealing with a new packet 
....................                LCD_clear();                                  
0A6FE:  CALL   5E1A
....................                strcpy (global_temp_line_buff, "Deal With Packet"); 
0A702:  CLRF   FEA
0A704:  MOVLW  70
0A706:  MOVWF  FE9
0A708:  MOVLW  00
0A70A:  CALL   0676
0A70E:  TBLRD*-
0A710:  TBLRD*+
0A712:  MOVF   FF5,W
0A714:  MOVWF  FEE
0A716:  IORLW  00
0A718:  BNZ   A710
....................                LCD_line1(global_temp_line_buff); 
0A71A:  MOVLB  5
0A71C:  CLRF   x64
0A71E:  MOVLW  70
0A720:  MOVWF  x63
0A722:  MOVLB  0
0A724:  CALL   39B0
....................                global_skip_lcd_update_count = 2;      
0A728:  MOVLW  02
0A72A:  MOVWF  x83
....................                                                   
....................                // disable ccp4 and mote interrupt so we don't overwrite payload_buff 
....................                //    or have colliding unsolicited messages 
....................                disable_interrupts(INT_CCP4); 
0A72C:  BCF    F7A.1
....................                disable_interrupts(INT_EXT2_H2L); 
0A72E:  BCF    FF0.4
....................                deal_with_packet();  
0A730:  GOTO   7334
....................                enable_interrupts(INT_EXT2_H2L);                        
0A734:  BSF    FF0.4
0A736:  BCF    FF1.4
....................                enable_interrupts(INT_CCP4); 
0A738:  BSF    F7A.1
....................                break; 
0A73A:  GOTO   B1D4
....................                 
....................             // Start the somewhat convoluted calibrate valve routine 
....................             // 1. Open valve VLV_CAL_1_MOVEMENT w/ "starting current" 
....................             // 2. Close valve fully w/ current being "normal closing current" 
....................             // 3. Open valve fully w/ normal current regimes 
....................             // 4. Do free spin rate (not done in here at the moment, just skipped).  
....................             // 5. Close valve fully w/ normal current regimes 
....................             // 6. Send valve calibration response to mote    
....................             // steps and system states are handled in COMP and CCP3 ISR as well  
....................             //    as setting the calibration values       
....................             case MOVE_VALVE_AT_BOOT: 
....................                // open valve slightly at bootup according to define "VLV_BOOT_SETPT" 
....................                // display message on screen 
....................                LCD_clear(); 
0A73E:  CALL   5E1A
....................                strcpy (global_temp_line_buff, "VLV Init @ start"); 
0A742:  CLRF   FEA
0A744:  MOVLW  70
0A746:  MOVWF  FE9
0A748:  MOVLW  00
0A74A:  CALL   0698
0A74E:  TBLRD*-
0A750:  TBLRD*+
0A752:  MOVF   FF5,W
0A754:  MOVWF  FEE
0A756:  IORLW  00
0A758:  BNZ   A750
....................                LCD_line1(global_temp_line_buff); 
0A75A:  MOVLB  5
0A75C:  CLRF   x64
0A75E:  MOVLW  70
0A760:  MOVWF  x63
0A762:  MOVLB  0
0A764:  CALL   39B0
....................                global_skip_lcd_update_count = 2; 
0A768:  MOVLW  02
0A76A:  MOVWF  x83
....................  
.................... /* 
....................                global_valve_time_in_motion_1024ths = 0;      
....................                 
....................                global_valve_position_set_value = VLV_BOOT_SETPT; 
....................                CCP_3 = global_valve_time_to_open_1024th;  
....................                // start the valve opening 
....................                mV_OPENm;          
....................                // setup/turn on the comparator interrupt (also sets up DAC) 
....................                comparator_setup(); 
....................                 
....................                // setup and enable CCP3 as well as it's respective timer 
....................                setup_ccp3(CCP_USE_TIMER1_AND_TIMER2 | CCP_COMPARE_RESET_TIMER); 
....................                setup_timer_1(T1_ENABLE_SOSC | T1_EXTERNAL_SYNC | T1_DIV_BY_1); 
....................                set_timer1(0); 
....................                                                                           
....................                // clear any ccp3 interrupt and enable ccp3 interrupt 
....................                clear_interrupt(INT_CCP3);                
....................                enable_interrupts(INT_CCP3);  
.................... */ 
....................                 
....................                global_valve_position_set_value = VLV_BOOT_SETPT;               
0A76C:  MOVLW  20
0A76E:  MOVWF  xC4
0A770:  CLRF   xC3
....................                 
....................                PUSH_PRIORITY_QUEUE_MACRO(MOVE_VALVE);  
0A772:  BCF    F7A.1
0A774:  MOVLW  40
0A776:  MOVLB  5
0A778:  MOVWF  x52
0A77A:  MOVLB  0
0A77C:  CALL   4748
0A780:  BSF    F7A.1
....................                break; 
0A782:  GOTO   B1D4
....................                 
....................             case CALIBRATE_VALVE_1: 
....................                // Change system state: initial open for calibrate valve routine 
....................                write_system_state(SYSTEM_CAL_VLV_1);     
0A786:  MOVLW  10
0A788:  MOVLB  5
0A78A:  MOVWF  x4B
0A78C:  MOVLB  0
0A78E:  CALL   3286
....................                // display calibration routine on screen      
....................                LCD_clear();                          
0A792:  CALL   5E1A
....................                strcpy (global_temp_line_buff, "VLV Calibration "); 
0A796:  CLRF   FEA
0A798:  MOVLW  70
0A79A:  MOVWF  FE9
0A79C:  MOVLW  00
0A79E:  CALL   06BA
0A7A2:  TBLRD*-
0A7A4:  TBLRD*+
0A7A6:  MOVF   FF5,W
0A7A8:  MOVWF  FEE
0A7AA:  IORLW  00
0A7AC:  BNZ   A7A4
....................                LCD_line1(global_temp_line_buff); 
0A7AE:  MOVLB  5
0A7B0:  CLRF   x64
0A7B2:  MOVLW  70
0A7B4:  MOVWF  x63
0A7B6:  MOVLB  0
0A7B8:  CALL   39B0
....................                strcpy (global_temp_line_buff, "Begining........"); 
0A7BC:  CLRF   FEA
0A7BE:  MOVLW  70
0A7C0:  MOVWF  FE9
0A7C2:  MOVLW  00
0A7C4:  CALL   06DC
0A7C8:  TBLRD*-
0A7CA:  TBLRD*+
0A7CC:  MOVF   FF5,W
0A7CE:  MOVWF  FEE
0A7D0:  IORLW  00
0A7D2:  BNZ   A7CA
....................                LCD_line2(global_temp_line_buff); 
0A7D4:  MOVLB  5
0A7D6:  CLRF   x64
0A7D8:  MOVLW  70
0A7DA:  MOVWF  x63
0A7DC:  MOVLB  0
0A7DE:  CALL   3A0A
....................                global_skip_lcd_update_count = 2;   
0A7E2:  MOVLW  02
0A7E4:  MOVWF  x83
....................                // setup brakes and charging for valve calibration 
....................                // (maximum resistance with no RPM Control) 
....................                global_control_loop_mechanism = NO_RPM_CONTROL_DYN_MPPC; 
0A7E6:  MOVLW  06
0A7E8:  MOVWF  xC0
....................                global_charge_duty_set_value = MAX_CHARGE; 
0A7EA:  MOVLW  01
0A7EC:  MOVWF  xB9
0A7EE:  MOVLW  90
0A7F0:  MOVWF  xB8
....................                global_brake_duty_set_value = MAX_BRK; 
0A7F2:  MOVLW  01
0A7F4:  MOVWF  xB7
0A7F6:  MOVLW  90
0A7F8:  MOVWF  xB6
....................                // put values to default values (45 seconds open/close)                                
....................                global_valve_time_to_close_1024th = DEFAULT_VLV_TIME_TO_CLOSE;  
0A7FA:  MOVLW  05
0A7FC:  MOVWF  xC6
0A7FE:  CLRF   xC5
....................                global_valve_time_to_open_1024th = DEFAULT_VLV_TIME_TO_OPEN;               
0A800:  MOVWF  xC8
0A802:  CLRF   xC7
....................                // Set the global valve position to the default value (middle)                  
....................                // this gives the valve a reference point to open a little from 
....................                global_valve_position = VLV_PRECALIBRATION_POSITION; 
0A804:  MOVLW  40
0A806:  MOVWF  xC2
0A808:  CLRF   xC1
....................                // Set valve position slightly more open than it is and move valve 
....................                global_valve_position_set_value = (VLV_PRECALIBRATION_POSITION +                        \ 
....................                VLV_CAL_1_MOVEMENT); 
0A80A:  MOVLW  60
0A80C:  MOVWF  xC4
0A80E:  CLRF   xC3
....................                PUSH_PRIORITY_QUEUE_MACRO(MOVE_VALVE); 
0A810:  BCF    F7A.1
0A812:  MOVLW  40
0A814:  MOVLB  5
0A816:  MOVWF  x52
0A818:  MOVLB  0
0A81A:  CALL   4748
0A81E:  BSF    F7A.1
....................                break;                                                       
0A820:  GOTO   B1D4
....................                 
....................             case CALIBRATE_VALVE_2:                                                                                                        
....................                // Change system state: fully closed 
....................                write_system_state(SYSTEM_CAL_VLV_2); 
0A824:  MOVLW  11
0A826:  MOVLB  5
0A828:  MOVWF  x4B
0A82A:  MOVLB  0
0A82C:  CALL   3286
....................                // set valve position target to fully closed and move valve 
....................                global_valve_position_set_value = VLV_POSITION_CLOSED; 
0A830:  CLRF   xC4
0A832:  CLRF   xC3
....................                PUSH_PRIORITY_QUEUE_MACRO(MOVE_VALVE);                                  
0A834:  BCF    F7A.1
0A836:  MOVLW  40
0A838:  MOVLB  5
0A83A:  MOVWF  x52
0A83C:  MOVLB  0
0A83E:  CALL   4748
0A842:  BSF    F7A.1
....................                break;    
0A844:  GOTO   B1D4
....................                 
....................             case CALIBRATE_VALVE_3: 
....................                // Change system state: fully closed to fully opened 
....................                write_system_state(SYSTEM_CAL_VLV_3); 
0A848:  MOVLW  12
0A84A:  MOVLB  5
0A84C:  MOVWF  x4B
0A84E:  MOVLB  0
0A850:  CALL   3286
....................                // set valve position target to fully open and move valve 
....................                global_valve_position_set_value = VLV_POSITION_OPENED; 
0A854:  MOVLW  80
0A856:  MOVWF  xC4
0A858:  CLRF   xC3
....................                PUSH_PRIORITY_QUEUE_MACRO(MOVE_VALVE); 
0A85A:  BCF    F7A.1
0A85C:  MOVLW  40
0A85E:  MOVLB  5
0A860:  MOVWF  x52
0A862:  MOVLB  0
0A864:  CALL   4748
0A868:  BSF    F7A.1
....................                break;      
0A86A:  GOTO   B1D4
....................              
....................            case CALIBRATE_VALVE_4:  
....................                // Change system state: FSR (not used at the moment) 
....................                write_system_state(SYSTEM_CAL_VLV_4);  
0A86E:  MOVLW  13
0A870:  MOVLB  5
0A872:  MOVWF  x4B
0A874:  MOVLB  0
0A876:  CALL   3286
....................                // move to the next calibration stage 
....................                PUSH_PRIORITY_QUEUE_MACRO(CALIBRATE_VALVE_5); 
0A87A:  BCF    F7A.1
0A87C:  MOVLW  35
0A87E:  MOVLB  5
0A880:  MOVWF  x52
0A882:  MOVLB  0
0A884:  CALL   4748
0A888:  BSF    F7A.1
....................                break;       
0A88A:  GOTO   B1D4
....................                 
....................             case CALIBRATE_VALVE_5: 
....................                // Change system state: fully opened to fully closed 
....................                write_system_state(SYSTEM_CAL_VLV_5); 
0A88E:  MOVLW  14
0A890:  MOVLB  5
0A892:  MOVWF  x4B
0A894:  MOVLB  0
0A896:  CALL   3286
....................                // set valve position target to fully closed and move valve 
....................                global_valve_position_set_value = VLV_POSITION_CLOSED; 
0A89A:  CLRF   xC4
0A89C:  CLRF   xC3
....................                PUSH_PRIORITY_QUEUE_MACRO(MOVE_VALVE); 
0A89E:  BCF    F7A.1
0A8A0:  MOVLW  40
0A8A2:  MOVLB  5
0A8A4:  MOVWF  x52
0A8A6:  MOVLB  0
0A8A8:  CALL   4748
0A8AC:  BSF    F7A.1
....................                break;      
0A8AE:  GOTO   B1D4
....................              
....................             case CALIBRATE_VALVE_6: 
....................                // Change system state: display calibration and send to manager 
....................                write_system_state(SYSTEM_CAL_VLV_6); 
0A8B2:  MOVLW  15
0A8B4:  MOVLB  5
0A8B6:  MOVWF  x4B
0A8B8:  MOVLB  0
0A8BA:  CALL   3286
....................                // display calibraion on screen 
....................                LCD_clear(); 
0A8BE:  CALL   5E1A
....................                strcpy (global_temp_line_buff, "Close CCP=      "); 
0A8C2:  CLRF   FEA
0A8C4:  MOVLW  70
0A8C6:  MOVWF  FE9
0A8C8:  MOVLW  00
0A8CA:  CALL   06FE
0A8CE:  TBLRD*-
0A8D0:  TBLRD*+
0A8D2:  MOVF   FF5,W
0A8D4:  MOVWF  FEE
0A8D6:  IORLW  00
0A8D8:  BNZ   A8D0
....................                LCD_line1(global_temp_line_buff); 
0A8DA:  MOVLB  5
0A8DC:  CLRF   x64
0A8DE:  MOVLW  70
0A8E0:  MOVWF  x63
0A8E2:  MOVLB  0
0A8E4:  CALL   39B0
....................                strcpy (global_temp_line_buff, "Open CCP =      "); 
0A8E8:  CLRF   FEA
0A8EA:  MOVLW  70
0A8EC:  MOVWF  FE9
0A8EE:  MOVLW  00
0A8F0:  CALL   0720
0A8F4:  TBLRD*-
0A8F6:  TBLRD*+
0A8F8:  MOVF   FF5,W
0A8FA:  MOVWF  FEE
0A8FC:  IORLW  00
0A8FE:  BNZ   A8F6
....................                LCD_line2(global_temp_line_buff); 
0A900:  MOVLB  5
0A902:  CLRF   x64
0A904:  MOVLW  70
0A906:  MOVWF  x63
0A908:  MOVLB  0
0A90A:  CALL   3A0A
....................                LCD_place_uint16(global_valve_time_to_close_1024th,0,11,5); 
0A90E:  MOVFF  C6,564
0A912:  MOVFF  C5,563
0A916:  MOVLB  5
0A918:  CLRF   x65
0A91A:  MOVLW  0B
0A91C:  MOVWF  x66
0A91E:  MOVLW  05
0A920:  MOVWF  x67
0A922:  MOVLB  0
0A924:  CALL   6A3C
....................                LCD_place_uint16(global_valve_time_to_open_1024th,1,11,5); 
0A928:  MOVFF  C8,564
0A92C:  MOVFF  C7,563
0A930:  MOVLW  01
0A932:  MOVLB  5
0A934:  MOVWF  x65
0A936:  MOVLW  0B
0A938:  MOVWF  x66
0A93A:  MOVLW  05
0A93C:  MOVWF  x67
0A93E:  MOVLB  0
0A940:  CALL   6A3C
....................                // put calibration stuff on screen for 4 seconds 
....................                global_skip_lcd_update_count = 5;      
0A944:  MOVLW  05
0A946:  MOVWF  x83
....................                // if valve calibration time is beyond limits, it triggers an error 
....................                //    and throws away the calibration, returning it to the run state. 
....................                if ((global_valve_time_to_close_1024th < ERROR_VLV_CAL_TIME_LO) || \ 
....................                   (global_valve_time_to_open_1024th < ERROR_VLV_CAL_TIME_LO)   || \ 
....................                   (global_valve_time_to_close_1024th > ERROR_VLV_CAL_TIME_HI)  || \ 
....................                   (global_valve_time_to_open_1024th > ERROR_VLV_CAL_TIME_HI)) 
0A948:  MOVF   xC6,W
0A94A:  SUBLW  02
0A94C:  BNC   A956
0A94E:  BNZ   A984
0A950:  MOVF   xC5,W
0A952:  SUBLW  ED
0A954:  BC    A984
0A956:  MOVF   xC8,W
0A958:  SUBLW  02
0A95A:  BNC   A964
0A95C:  BNZ   A984
0A95E:  MOVF   xC7,W
0A960:  SUBLW  ED
0A962:  BC    A984
0A964:  MOVF   xC6,W
0A966:  SUBLW  08
0A968:  BC    A974
0A96A:  XORLW  FF
0A96C:  BNZ   A984
0A96E:  MOVF   xC5,W
0A970:  SUBLW  C4
0A972:  BNC   A984
0A974:  MOVF   xC8,W
0A976:  SUBLW  08
0A978:  BC    A9A8
0A97A:  XORLW  FF
0A97C:  BNZ   A984
0A97E:  MOVF   xC7,W
0A980:  SUBLW  C4
0A982:  BC    A9A8
....................                { 
....................                   // reset valve calibration times to the defaults 
....................                   global_valve_time_to_open_1024th = DEFAULT_VLV_TIME_TO_OPEN; 
0A984:  MOVLW  05
0A986:  MOVWF  xC8
0A988:  CLRF   xC7
....................                   global_valve_time_to_close_1024th = DEFAULT_VLV_TIME_TO_CLOSE; 
0A98A:  MOVWF  xC6
0A98C:  CLRF   xC5
....................                   // change valve position to unknown 
....................                   global_valve_position = VLV_POSITION_UNKNOWN; 
0A98E:  SETF   xC2
0A990:  SETF   xC1
....................                   // set the error bitfield and send an error 
....................                   global_error_message_bitfield |= ERR_MSG_VLV_CAL_FAIL; 
0A992:  MOVLB  4
0A994:  BSF    xF9.1
....................                   PUSH_MESSAGE_QUEUE_MACRO(MSG_MOTE_ERROR_MSG); 
0A996:  BCF    F7A.1
0A998:  MOVLW  A0
0A99A:  MOVLB  5
0A99C:  MOVWF  x54
0A99E:  MOVLB  0
0A9A0:  CALL   51F6
0A9A4:  BSF    F7A.1
....................                } 
0A9A6:  BRA    A9CC
....................                // successful/valid calibration time 
....................                else 
....................                { 
....................                   // update the calibration time 
....................                   global_valve_calibration_utc_time = global_utc_time; 
0A9A8:  MOVFF  8C,CE
0A9AC:  MOVFF  8B,CD
0A9B0:  MOVFF  8A,CC
0A9B4:  MOVFF  89,CB
....................                   // store calibrations in eeprom 
....................                   store_vcal_eeprom_values(); 
0A9B8:  GOTO   829E
....................                   // send an unsolicited valve report to the manager 
....................                   PUSH_MESSAGE_QUEUE_MACRO(MSG_MOTE_VALVE_REPORT); 
0A9BC:  BCF    F7A.1
0A9BE:  MOVLW  92
0A9C0:  MOVLB  5
0A9C2:  MOVWF  x54
0A9C4:  MOVLB  0
0A9C6:  CALL   51F6
0A9CA:  BSF    F7A.1
....................                } 
....................                // put system in run state 
....................                write_system_state(SYSTEM_RUN); 
0A9CC:  MOVLW  02
0A9CE:  MOVLB  5
0A9D0:  MOVWF  x4B
0A9D2:  MOVLB  0
0A9D4:  CALL   3286
....................                break;      
0A9D8:  GOTO   B1D4
....................                             
....................             // FSR IS LARGELY UNTESTED EVEN THOUGH IT'S BASICALLY ALL WRITTEN!                
....................             // move valve to position specified by calibrate FSR routine    
....................             case CALIBRATE_FSR_1: 
....................                // set system state                       
....................                write_system_state(SYSTEM_CAL_FSR_1);                                          
0A9DC:  MOVLW  18
0A9DE:  MOVLB  5
0A9E0:  MOVWF  x4B
0A9E2:  MOVLB  0
0A9E4:  CALL   3286
....................                // save the current valve, so we can return to it later 
....................                pre_fsr_valve_setting = global_valve_position;      
0A9E8:  MOVFF  C2,54A
0A9EC:  MOVFF  C1,549
....................                // move valve to the FSR position                          
....................                global_valve_position_set_value = global_calibrate_fsr_valve_position;  
0A9F0:  MOVFF  D1,C4
0A9F4:  MOVFF  D0,C3
....................                PUSH_PRIORITY_QUEUE_MACRO(MOVE_VALVE);                             
0A9F8:  BCF    F7A.1
0A9FA:  MOVLW  40
0A9FC:  MOVLB  5
0A9FE:  MOVWF  x52
0AA00:  MOVLB  0
0AA02:  CALL   4748
0AA06:  BSF    F7A.1
....................                break;          
0AA08:  GOTO   B1D4
....................                                                                                          
....................             case CALIBRATE_FSR_2: 
....................                // set system state 
....................                write_system_state(SYSTEM_CAL_FSR_2);    
0AA0C:  MOVLW  19
0AA0E:  MOVLB  5
0AA10:  MOVWF  x4B
0AA12:  MOVLB  0
0AA14:  CALL   3286
....................                // disable ccp5 for a quick second 
....................                disable_interrupts(INT_CCP5); 
0AA18:  BCF    F7A.2
....................                // actually measure the FSR and store it  
....................                global_calibrate_fsr_period = global_current_period;    
0AA1A:  MOVFF  A9,D3
0AA1E:  MOVFF  A8,D2
....................                // restore ccp5 
....................                enable_interrupts(INT_CCP5);      
0AA22:  BSF    F7A.2
....................                // store the fsr calibration time 
....................                global_calibrate_fsr_utc_time = global_utc_time;    
0AA24:  MOVFF  8C,D7
0AA28:  MOVFF  8B,D6
0AA2C:  MOVFF  8A,D5
0AA30:  MOVFF  89,D4
....................                                      
....................                // move valve to the FSR position 
....................                global_valve_position_set_value = pre_fsr_valve_setting;   
0AA34:  MOVFF  54A,C4
0AA38:  MOVFF  549,C3
....................                PUSH_PRIORITY_QUEUE_MACRO(MOVE_VALVE);     
0AA3C:  BCF    F7A.1
0AA3E:  MOVLW  40
0AA40:  MOVLB  5
0AA42:  MOVWF  x52
0AA44:  MOVLB  0
0AA46:  CALL   4748
0AA4A:  BSF    F7A.1
....................                                                   
....................                PUSH_MESSAGE_QUEUE_MACRO(MSG_MOTE_VALVE_REPORT); 
0AA4C:  BCF    F7A.1
0AA4E:  MOVLW  92
0AA50:  MOVLB  5
0AA52:  MOVWF  x54
0AA54:  MOVLB  0
0AA56:  CALL   51F6
0AA5A:  BSF    F7A.1
....................                write_system_state(SYSTEM_RUN); 
0AA5C:  MOVLW  02
0AA5E:  MOVLB  5
0AA60:  MOVWF  x4B
0AA62:  MOVLB  0
0AA64:  CALL   3286
....................                break;                                   
0AA68:  GOTO   B1D4
....................                 
....................             case CALIBRATE_FSR_3: 
....................                write_system_state(SYSTEM_CAL_FSR_3); 
0AA6C:  MOVLW  1A
0AA6E:  MOVLB  5
0AA70:  MOVWF  x4B
0AA72:  MOVLB  0
0AA74:  CALL   3286
....................                break;         
0AA78:  GOTO   B1D4
....................             /*    
....................             case CALIBRATE_FSR_4: 
....................                write_system_state(SYSTEM_CAL_FSR_4); 
....................                LCD_clear(); 
....................                LCD_place_uint16(global_valve_position,0,0,5); 
....................                LCD_place_uint16(global_valve_time_to_close_1024th,0,6,5); 
....................                LCD_place_uint16(global_valve_time_to_open_1024th,0,11,5); 
....................                LCD_place_uint16(global_valve_position,1,0,5); 
....................                LCD_place_uint16(global_valve_position,1,11,5); 
....................                LCD_place_uint16(global_valve_position,1,11,5); 
....................                // put calibration stuff on screen for 4 seconds 
....................                global_skip_lcd_update_count = 5; 
....................                global_calibrate_fsr_utc_time 
....................                 
....................                write_system_state(SYSTEM_RUN); 
....................                break;          
....................                */             
....................                 
....................                 
....................             case MOVE_VALVE_MAG_DECOUPLING_RECOVERY: 
....................                // move the valve to VLV_MAGNETIC_COUPLING_FIX 
....................                global_valve_position_set_value = VLV_MAGNETIC_COUPLING_FIX; 
0AA7C:  MOVFF  520,C4
0AA80:  MOVFF  51F,C3
....................                PUSH_PRIORITY_QUEUE_MACRO(MOVE_VALVE); 
0AA84:  BCF    F7A.1
0AA86:  MOVLW  40
0AA88:  MOVLB  5
0AA8A:  MOVWF  x52
0AA8C:  MOVLB  0
0AA8E:  CALL   4748
0AA92:  BSF    F7A.1
....................                // change control loop scheme  
....................                global_control_loop_mechanism = MAG_DECOUPLING_RECOVERY; 
0AA94:  MOVLW  09
0AA96:  MOVWF  xC0
....................                break; 
0AA98:  GOTO   B1D4
....................                 
....................             case MOVE_VALVE_NO_SPIN_RECOVERY: 
....................                // move the valve to VLV_NOT_SPIN_FIX 
....................                global_valve_position_set_value = VLV_NOT_SPIN_FIX; 
0AA9C:  MOVFF  51B,C4
0AAA0:  MOVFF  51A,C3
....................                PUSH_PRIORITY_QUEUE_MACRO(MOVE_VALVE); 
0AAA4:  BCF    F7A.1
0AAA6:  MOVLW  40
0AAA8:  MOVLB  5
0AAAA:  MOVWF  x52
0AAAC:  MOVLB  0
0AAAE:  CALL   4748
0AAB2:  BSF    F7A.1
....................                // change control loop scheme 
....................                global_control_loop_mechanism = NO_SPIN_RECOVERY; 
0AAB4:  MOVLW  08
0AAB6:  MOVWF  xC0
....................                break; 
0AAB8:  GOTO   B1D4
....................                                                
....................             // Opens valve irrespective of the position. Used for shutting down the system (and leaving 
....................             //    the valve open) and for test purposes.  Added very quickly in Nebraska.                  
....................             case OPEN_VALVE_UNKNOWN_STATE:                             
....................                // clear out the time in motion 
....................                global_valve_time_in_motion_1024ths = 0;      
0AABC:  CLRF   xCA
0AABE:  CLRF   xC9
....................                 
....................                global_valve_position_set_value = VLV_POSITION_OPENED; 
0AAC0:  MOVLW  80
0AAC2:  MOVWF  xC4
0AAC4:  CLRF   xC3
....................                CCP_3 = global_valve_time_to_open_1024th;  
0AAC6:  MOVFF  C8,F5F
0AACA:  MOVFF  C7,F5E
....................                // start the valve opening 
....................                mV_OPENm;          
0AACE:  MOVLW  02
0AAD0:  MOVWF  F8D
....................                // setup/turn on the comparator interrupt (also sets up DAC) 
....................                comparator_setup(); 
0AAD2:  CALL   842A
....................                 
....................                // setup and enable CCP3 as well as it's respective timer 
....................                setup_ccp3(CCP_USE_TIMER1_AND_TIMER2 | CCP_COMPARE_RESET_TIMER); 
0AAD6:  MOVLW  0B
0AAD8:  MOVLB  F
0AADA:  MOVWF  x5D
0AADC:  CLRF   x5C
0AADE:  CLRF   x5B
0AAE0:  MOVLW  01
0AAE2:  MOVWF  x5A
0AAE4:  MOVLW  3F
0AAE6:  ANDWF  x49,F
0AAE8:  MOVLW  00
0AAEA:  IORWF  x49,F
....................                setup_timer_1(T1_ENABLE_SOSC | T1_EXTERNAL_SYNC | T1_DIV_BY_1); 
0AAEC:  MOVLW  8B
0AAEE:  MOVWF  FCD
0AAF0:  CLRF   FCC
....................                set_timer1(0); 
0AAF2:  CLRF   FCF
0AAF4:  CLRF   FCE
....................                                                                           
....................                // clear any ccp3 interrupt and enable ccp3 interrupt 
....................                clear_interrupt(INT_CCP3);                
0AAF6:  BCF    F7B.0
....................                enable_interrupts(INT_CCP3);  
0AAF8:  BSF    F7A.0
....................                 
....................                // JG: previously there was no "break;" here.  Rather the 
....................                // following case was MOVE_VALVE. I believe this accomplishes 
....................                // the same thing. 
....................                PUSH_PRIORITY_QUEUE_MACRO(MOVE_VALVE); 
0AAFA:  BCF    F7A.1
0AAFC:  MOVLW  40
0AAFE:  MOVLB  5
0AB00:  MOVWF  x52
0AB02:  MOVLB  0
0AB04:  CALL   4748
0AB08:  BSF    F7A.1
....................                break; 
0AB0A:  BRA    B1D4
....................  
....................              
....................             // Closes valve irrespective of the position. Used for shutting down the system (and leaving 
....................             //    the valve closed) and for test purposes. 
....................             case CLOSE_VALVE_UNKNOWN_STATE:                             
....................                // clear out the time in motion 
....................                global_valve_time_in_motion_1024ths = 0;      
0AB0C:  CLRF   xCA
0AB0E:  CLRF   xC9
....................                 
....................                global_valve_position_set_value = VLV_POSITION_CLOSED; 
0AB10:  CLRF   xC4
0AB12:  CLRF   xC3
....................                CCP_3 = global_valve_time_to_open_1024th;  
0AB14:  MOVFF  C8,F5F
0AB18:  MOVFF  C7,F5E
....................                // start the valve opening 
....................                mV_CLOSEm;          
0AB1C:  MOVLW  01
0AB1E:  MOVWF  F8D
....................                // setup/turn on the comparator interrupt (also sets up DAC) 
....................                comparator_setup(); 
0AB20:  CALL   842A
....................                 
....................                // setup and enable CCP3 as well as it's respective timer 
....................                setup_ccp3(CCP_USE_TIMER1_AND_TIMER2 | CCP_COMPARE_RESET_TIMER); 
0AB24:  MOVLW  0B
0AB26:  MOVLB  F
0AB28:  MOVWF  x5D
0AB2A:  CLRF   x5C
0AB2C:  CLRF   x5B
0AB2E:  MOVLW  01
0AB30:  MOVWF  x5A
0AB32:  MOVLW  3F
0AB34:  ANDWF  x49,F
0AB36:  MOVLW  00
0AB38:  IORWF  x49,F
....................                setup_timer_1(T1_ENABLE_SOSC | T1_EXTERNAL_SYNC | T1_DIV_BY_1); 
0AB3A:  MOVLW  8B
0AB3C:  MOVWF  FCD
0AB3E:  CLRF   FCC
....................                set_timer1(0); 
0AB40:  CLRF   FCF
0AB42:  CLRF   FCE
....................                                                                           
....................                // clear any ccp3 interrupt and enable ccp3 interrupt 
....................                clear_interrupt(INT_CCP3);                
0AB44:  BCF    F7B.0
....................                enable_interrupts(INT_CCP3);    
0AB46:  BSF    F7A.0
....................                PUSH_PRIORITY_QUEUE_MACRO(MOVE_VALVE); 
0AB48:  BCF    F7A.1
0AB4A:  MOVLW  40
0AB4C:  MOVLB  5
0AB4E:  MOVWF  x52
0AB50:  MOVLB  0
0AB52:  CALL   4748
0AB56:  BSF    F7A.1
....................                break;                                     
0AB58:  BRA    B1D4
....................                                             
....................                                             
....................             case MOVE_VALVE:               
....................                // if the system is in the SYSTEM_IDLE state, bump it into the SYSTEM_RUN state. 
....................                if (read_system_state() == SYSTEM_IDLE) write_system_state(SYSTEM_RUN);      
0AB5A:  CALL   1F4A
0AB5E:  MOVF   01,W
0AB60:  SUBLW  03
0AB62:  BNZ   AB70
0AB64:  MOVLW  02
0AB66:  MOVLB  5
0AB68:  MOVWF  x4B
0AB6A:  MOVLB  0
0AB6C:  CALL   3286
....................                                                       
....................                // if system is in an undesireable state, don't move the valve 
....................                //    and send an error message                                   
....................                // Undesirable states such as unkown or init 
.................... #IFNDEF OPEN_VALVE_TO_SETPT_AT_BOOT                
....................                if ((read_system_state() == SYSTEM_STATE_UNKNOWN)||            \ 
....................                   (read_system_state() == SYSTEM_INIT)) 
.................... #ELSE 
....................                if (read_system_state() == SYSTEM_STATE_UNKNOWN) 
0AB70:  CALL   1F4A
0AB74:  INCFSZ 01,W
0AB76:  BRA    AB90
.................... #ENDIF 
....................                { 
....................                   global_error_message_bitfield |= ERR_MSG_INCOMPATIBLE_STATE; 
0AB78:  MOVLB  4
0AB7A:  BSF    xF8.1
....................                   PUSH_MESSAGE_QUEUE_MACRO(MSG_MOTE_ERROR_MSG); 
0AB7C:  BCF    F7A.1
0AB7E:  MOVLW  A0
0AB80:  MOVLB  5
0AB82:  MOVWF  x54
0AB84:  MOVLB  0
0AB86:  CALL   51F6
0AB8A:  BSF    F7A.1
....................                   break;                                  
0AB8C:  BRA    B1D4
....................                } 
0AB8E:  BRA    AC04
....................  
....................                // Jack has changed this test to check if the valve calibration 
....................                //  is stale as per VLV_SECS_TO_STALE_CAL defined parameter 
....................                else if ((read_system_state() == SYSTEM_RUN) &&                \ 
....................                  ((global_utc_time-global_valve_calibration_utc_time)>VLV_SECS_TO_STALE_CAL)) 
0AB90:  CALL   1F4A
0AB94:  MOVF   01,W
0AB96:  SUBLW  02
0AB98:  BNZ   AC04
0AB9A:  MOVF   xCB,W
0AB9C:  SUBWF  x89,W
0AB9E:  MOVLB  5
0ABA0:  MOVWF  x4B
0ABA2:  MOVLB  0
0ABA4:  MOVF   xCC,W
0ABA6:  SUBWFB x8A,W
0ABA8:  MOVLB  5
0ABAA:  MOVWF  x4C
0ABAC:  MOVLB  0
0ABAE:  MOVF   xCD,W
0ABB0:  SUBWFB x8B,W
0ABB2:  MOVLB  5
0ABB4:  MOVWF  x4D
0ABB6:  MOVLB  0
0ABB8:  MOVF   xCE,W
0ABBA:  SUBWFB x8C,W
0ABBC:  MOVLB  5
0ABBE:  MOVWF  x4E
0ABC0:  MOVF   x4E,F
0ABC2:  BNZ   ABF0
0ABC4:  MOVF   x4D,W
0ABC6:  SUBLW  00
0ABC8:  BTFSS  FD8.0
0ABCA:  BRA    ABD0
0ABCC:  MOVLB  0
0ABCE:  BRA    AC04
0ABD0:  XORLW  FF
0ABD2:  BNZ   ABF0
0ABD4:  MOVF   x4C,W
0ABD6:  SUBLW  50
0ABD8:  BTFSS  FD8.0
0ABDA:  BRA    ABE0
0ABDC:  MOVLB  0
0ABDE:  BRA    AC04
0ABE0:  XORLW  FF
0ABE2:  BNZ   ABF0
0ABE4:  MOVF   x4B,W
0ABE6:  SUBLW  80
0ABE8:  BTFSS  FD8.0
0ABEA:  BRA    ABF0
0ABEC:  MOVLB  0
0ABEE:  BRA    AC04
....................                { 
....................                   global_error_message_bitfield |= ERR_MSG_VLV_CAL_STALE; 
0ABF0:  MOVLB  4
0ABF2:  BSF    xF8.2
....................                   PUSH_MESSAGE_QUEUE_MACRO(MSG_MOTE_ERROR_MSG); 
0ABF4:  BCF    F7A.1
0ABF6:  MOVLW  A0
0ABF8:  MOVLB  5
0ABFA:  MOVWF  x54
0ABFC:  MOVLB  0
0ABFE:  CALL   51F6
0AC02:  BSF    F7A.1
.................... #IFNDEF ALLOW_VALVE_SET_WITH_STALE_CAL                   
....................                   break; 
.................... #ENDIF                   
....................                }  
....................  
.................... /* 
....................                // or if you're in the run state and the valve is uncalibrated 
....................                else if ((read_system_state() == SYSTEM_RUN) &&                \ 
....................                   (global_valve_position == VLV_POSITION_UNKNOWN)) 
....................                { 
....................                   global_error_message_bitfield |= ERR_MSG_VLV_NOT_CALIBRATED; 
....................                   PUSH_MESSAGE_QUEUE_MACRO(MSG_MOTE_ERROR_MSG); 
....................                   break; 
....................                } 
.................... */                                            
....................                // if valve movement is not needed (less than one millispan away 
....................                //    and in run state), break out of switch case 
....................                if ((read_system_state() == SYSTEM_RUN) &&                     \ 
....................                (((global_valve_position_set_value - global_valve_position) < 0x20) || \ 
....................                ((global_valve_position - global_valve_position_set_value) < 0x20))) 
0AC04:  CALL   1F4A
0AC08:  MOVF   01,W
0AC0A:  SUBLW  02
0AC0C:  BNZ   AC58
0AC0E:  MOVF   xC1,W
0AC10:  SUBWF  xC3,W
0AC12:  MOVLB  5
0AC14:  MOVWF  x4B
0AC16:  MOVLB  0
0AC18:  MOVF   xC2,W
0AC1A:  SUBWFB xC4,W
0AC1C:  MOVLB  5
0AC1E:  MOVWF  x4C
0AC20:  MOVF   x4C,F
0AC22:  BNZ   AC2A
0AC24:  MOVF   x4B,W
0AC26:  SUBLW  1F
0AC28:  BC    AC54
0AC2A:  MOVLB  0
0AC2C:  MOVF   xC3,W
0AC2E:  SUBWF  xC1,W
0AC30:  MOVLB  5
0AC32:  MOVWF  x4B
0AC34:  MOVLB  0
0AC36:  MOVF   xC4,W
0AC38:  SUBWFB xC2,W
0AC3A:  MOVLB  5
0AC3C:  MOVWF  x4C
0AC3E:  MOVF   x4C,F
0AC40:  BTFSC  FD8.2
0AC42:  BRA    AC48
0AC44:  MOVLB  0
0AC46:  BRA    AC58
0AC48:  MOVF   x4B,W
0AC4A:  SUBLW  1F
0AC4C:  BTFSC  FD8.0
0AC4E:  BRA    AC54
0AC50:  MOVLB  0
0AC52:  BRA    AC58
....................                {                
....................                   break;    
0AC54:  MOVLB  0
0AC56:  BRA    B1D4
....................                }              
....................                                        
....................                // clear out the time in motion 
....................                global_valve_time_in_motion_1024ths = 0;   
0AC58:  CLRF   xCA
0AC5A:  CLRF   xC9
....................                 
....................                // increment the movements since hitting an endstop. Also, check if 
....................                // enough valve movements have happened to warrant a recalibration of 
....................                //    the position of the valve by going towards an endstop 
....................                if ((global_valve_movements_since_endstop++) > VLV_MOVES_BEFORE_RECAL) 
0AC5C:  MOVF   xCF,W
0AC5E:  INCF   xCF,F
0AC60:  SUBLW  19
0AC62:  BC    AC66
....................                { 
.................... #IFNDEF  DISABLE_RECAL_VLV                        
....................                   write_system_state(SYSTEM_RECAL_VLV_MOVES);                         
....................                   // quicker to go to the closed endstop. Start motion. 
....................                   if ((global_valve_position_set_value + global_valve_position) >\ 
....................                      VLV_POSITION_OPENED) 
....................                   { 
....................                      CCP_3 = global_valve_time_to_close_1024th; 
....................                      mV_CLOSEm;                                                                    
....................                   } 
....................                   // quicker to go to the open endstop. Start motion. 
....................                   else    
....................                   { 
....................                      CCP_3 = global_valve_time_to_open_1024th; 
....................                      // don't go to the open endstop to avoid magnetic decoupling 
....................                      //mV_OPENm; 
....................                      mV_CLOSEm; 
....................                   } 
....................  #ENDIF 
....................                } 
0AC64:  BRA    ACCA
....................                 
....................                // regular valve move (without recalibration) 
....................                else 
....................                { 
....................                   // setup CCP3 and put the valve into motion based on target value 
....................                   if (global_valve_position_set_value > global_valve_position) 
0AC66:  MOVF   xC2,W
0AC68:  SUBWF  xC4,W
0AC6A:  BNC   AC82
0AC6C:  BNZ   AC74
0AC6E:  MOVF   xC3,W
0AC70:  SUBWF  xC1,W
0AC72:  BC    AC82
....................                   { 
....................                      CCP_3 = global_valve_time_to_open_1024th; 
0AC74:  MOVFF  C8,F5F
0AC78:  MOVFF  C7,F5E
....................                      mV_OPENm;  
0AC7C:  MOVLW  02
0AC7E:  MOVWF  F8D
....................                   } 
0AC80:  BRA    ACCA
....................                   else if (global_valve_position_set_value < global_valve_position) 
0AC82:  MOVF   xC4,W
0AC84:  SUBWF  xC2,W
0AC86:  BNC   AC9E
0AC88:  BNZ   AC90
0AC8A:  MOVF   xC1,W
0AC8C:  SUBWF  xC3,W
0AC8E:  BC    AC9E
....................                   { 
....................                      CCP_3 = global_valve_time_to_close_1024th; 
0AC90:  MOVFF  C6,F5F
0AC94:  MOVFF  C5,F5E
....................                      mV_CLOSEm; 
0AC98:  MOVLW  01
0AC9A:  MOVWF  F8D
....................                   } 
0AC9C:  BRA    ACCA
....................                   else if (global_valve_position_set_value == VLV_POSITION_OPENED) 
0AC9E:  MOVF   xC3,F
0ACA0:  BNZ   ACB6
0ACA2:  MOVF   xC4,W
0ACA4:  SUBLW  80
0ACA6:  BNZ   ACB6
....................                   { 
....................                      CCP_3 = global_valve_time_to_open_1024th; 
0ACA8:  MOVFF  C8,F5F
0ACAC:  MOVFF  C7,F5E
....................                      mV_OPENm;   
0ACB0:  MOVLW  02
0ACB2:  MOVWF  F8D
....................                   } 
0ACB4:  BRA    ACCA
....................                   else if (global_valve_position_set_value == VLV_POSITION_CLOSED) 
0ACB6:  MOVF   xC3,F
0ACB8:  BNZ   ACCA
0ACBA:  MOVF   xC4,F
0ACBC:  BNZ   ACCA
....................                   { 
....................                      CCP_3 = global_valve_time_to_close_1024th; 
0ACBE:  MOVFF  C6,F5F
0ACC2:  MOVFF  C5,F5E
....................                      mV_CLOSEm; 
0ACC6:  MOVLW  01
0ACC8:  MOVWF  F8D
....................                   }                  
....................                }    
....................                 
....................                // setup/turn on the comparator interrupt (also sets up DAC) 
....................                comparator_setup();                                          
0ACCA:  CALL   842A
....................                 
....................                // setup and enable CCP3 as well as it's respective timer 
....................                setup_ccp3(CCP_USE_TIMER1_AND_TIMER2 | CCP_COMPARE_RESET_TIMER); 
0ACCE:  MOVLW  0B
0ACD0:  MOVLB  F
0ACD2:  MOVWF  x5D
0ACD4:  CLRF   x5C
0ACD6:  CLRF   x5B
0ACD8:  MOVLW  01
0ACDA:  MOVWF  x5A
0ACDC:  MOVLW  3F
0ACDE:  ANDWF  x49,F
0ACE0:  MOVLW  00
0ACE2:  IORWF  x49,F
....................                setup_timer_1(T1_ENABLE_SOSC | T1_EXTERNAL_SYNC | T1_DIV_BY_1); 
0ACE4:  MOVLW  8B
0ACE6:  MOVWF  FCD
0ACE8:  CLRF   FCC
....................                set_timer1(0); 
0ACEA:  CLRF   FCF
0ACEC:  CLRF   FCE
....................                 
....................                // clear any ccp3 interrupt and enable ccp3 interrupt 
....................                clear_interrupt(INT_CCP3); 
0ACEE:  BCF    F7B.0
....................                enable_interrupts(INT_CCP3);            
0ACF0:  BSF    F7A.0
....................                break; 
0ACF2:  MOVLB  0
0ACF4:  BRA    B1D4
....................                 
....................             // Start GPS aquisition 
....................             case START_GPS_AQUISITION: 
....................                break; 
0ACF6:  BRA    B1D4
....................                                                      
....................             // Check GPS for lock 
....................             case CHECK_GPS_FOR_LOCK:     
....................                break;                    
0ACF8:  BRA    B1D4
....................                             
....................             case TAKE_XCDR_MESUREMENT_1: 
....................                // turn on XDCR power (must give ~50ms to settle) 
....................                output_high(XDCR_PWR);                     
0ACFA:  BSF    F8B.5
....................                // queue up the actual meaurement a second later.                    
....................                PUSH_TIME_QUEUE_MACRO(global_rtc_time + 1, TAKE_XCDR_MESUREMENT_2); 
0ACFC:  BCF    F7A.1
0ACFE:  MOVLW  01
0AD00:  ADDWF  x85,W
0AD02:  MOVLB  5
0AD04:  MOVWF  x4B
0AD06:  MOVLW  00
0AD08:  MOVLB  0
0AD0A:  ADDWFC x86,W
0AD0C:  MOVLB  5
0AD0E:  MOVWF  x4C
0AD10:  MOVLW  00
0AD12:  MOVLB  0
0AD14:  ADDWFC x87,W
0AD16:  MOVLB  5
0AD18:  MOVWF  x4D
0AD1A:  MOVLW  00
0AD1C:  MOVLB  0
0AD1E:  ADDWFC x88,W
0AD20:  MOVLB  5
0AD22:  MOVWF  x4E
0AD24:  MOVWF  x59
0AD26:  MOVFF  54D,558
0AD2A:  MOVFF  54C,557
0AD2E:  MOVFF  54B,556
0AD32:  MOVLW  56
0AD34:  MOVWF  x5A
0AD36:  MOVLB  0
0AD38:  CALL   44A0
0AD3C:  BSF    F7A.1
....................                break; 
0AD3E:  BRA    B1D4
....................                                                                                      
....................             case TAKE_XCDR_MESUREMENT_2:    
....................                // take the actual xdcr measurement via the adc (stores the result in global_xdcr_output)     
....................                adc_XDCR_measure();     
0AD40:  GOTO   8458
....................                // add xdcr message to queue                       
....................                PUSH_MESSAGE_QUEUE_MACRO(MSG_MOTE_XDCR_READ_MSG);  
0AD44:  BCF    F7A.1
0AD46:  MOVLW  98
0AD48:  MOVLB  5
0AD4A:  MOVWF  x54
0AD4C:  MOVLB  0
0AD4E:  CALL   51F6
0AD52:  BSF    F7A.1
....................                break;                                             
0AD54:  BRA    B1D4
....................                                         
....................             // Update the LCD 
....................             // In the future, we're going to have "pages" controlled by the switch. 
....................             case LCD_UPDATE:           
....................                // instructed to skip this update (to show other things on screen)          
....................                 
....................                // disable button press interrupt while accessing shared global lcd variables 
.................... //               disable_interrupts(INT_RB);    
....................                 
....................                // check if long press has exceeded time limit and indicate 
....................                //  to user if so 
....................                 
....................                if (sw1_start_time && ((global_rtc_time - sw1_start_time) > SW1_ISR_LONG_PRESS_TIME)) 
0AD56:  MOVF   x91,F
0AD58:  BNZ   AD66
0AD5A:  MOVF   x92,F
0AD5C:  BNZ   AD66
0AD5E:  MOVF   x93,F
0AD60:  BNZ   AD66
0AD62:  MOVF   x94,F
0AD64:  BZ    ADB8
0AD66:  MOVF   x91,W
0AD68:  SUBWF  x85,W
0AD6A:  MOVLB  5
0AD6C:  MOVWF  x4B
0AD6E:  MOVLB  0
0AD70:  MOVF   x92,W
0AD72:  SUBWFB x86,W
0AD74:  MOVLB  5
0AD76:  MOVWF  x4C
0AD78:  MOVLB  0
0AD7A:  MOVF   x93,W
0AD7C:  SUBWFB x87,W
0AD7E:  MOVLB  5
0AD80:  MOVWF  x4D
0AD82:  MOVLB  0
0AD84:  MOVF   x94,W
0AD86:  SUBWFB x88,W
0AD88:  MOVLB  5
0AD8A:  MOVWF  x4E
0AD8C:  MOVF   x4E,F
0AD8E:  BNZ   ADA4
0AD90:  MOVF   x4D,F
0AD92:  BNZ   ADA4
0AD94:  MOVF   x4C,F
0AD96:  BNZ   ADA4
0AD98:  MOVF   x4B,W
0AD9A:  SUBLW  05
0AD9C:  BTFSS  FD8.0
0AD9E:  BRA    ADA4
0ADA0:  MOVLB  0
0ADA2:  BRA    ADB8
....................                { 
....................                   flash_led_2(4); 
0ADA4:  MOVLW  04
0ADA6:  MOVWF  x4B
0ADA8:  MOVLB  0
0ADAA:  GOTO   84B0
....................                   sw1_start_time = 0; 
0ADAE:  CLRF   x94
0ADB0:  CLRF   x93
0ADB2:  CLRF   x92
0ADB4:  CLRF   x91
....................                } 
0ADB6:  BRA    ADC6
....................  
....................                else if (global_skip_lcd_update_count > 1)   
0ADB8:  MOVF   x83,W
0ADBA:  SUBLW  01
0ADBC:  BC    ADC2
....................                {                   
....................                   global_skip_lcd_update_count--;     
0ADBE:  DECF   x83,F
....................                } 
0ADC0:  BRA    ADC6
....................                // either normal update or screen clear and update via function call (for multiple pages)     
....................                else                  
....................                {        
....................                   LCD_update_diplay();             
0ADC2:  GOTO   88EC
....................                } 
....................                 
....................                // disable button press interrupt while accessing shared global lcd variables 
.................... //               enable_interrupts(INT_RB);  
....................                  
....................                break;                                          
0ADC6:  BRA    B1D4
....................                 
....................             // recovers from an i2c bus collision interrupt 
....................             case BUSCOL_RESET:                    
....................                BCL1IF = FALSE; 
0ADC8:  BCF    FA1.3
....................                SSP1IF = TRUE; 
0ADCA:  BSF    F9E.3
....................                i2c_init(TRUE);             
0ADCC:  BCF    FCB.0
0ADCE:  BCF    FCB.1
0ADD0:  BCF    FCB.3
0ADD2:  MOVLW  06
0ADD4:  MOVWF  FC8
0ADD6:  MOVLW  28
0ADD8:  MOVWF  FC6
0ADDA:  BSF    FC7.7
0ADDC:  BCF    FC7.6
....................                if (global_lcd_enabled) LCD_init();   
0ADDE:  BTFSC  xA7.0
0ADE0:  CALL   3A66
....................                enable_interrupts(GLOBAL);          
0ADE4:  MOVLW  C0
0ADE6:  IORWF  FF2,F
....................                break;                                                    
0ADE8:  BRA    B1D4
....................                 
....................             // Reset the mote (triggers a wait for boot event) 
....................             case RESET_MOTE:      
....................                // display on screen what is happening 
....................                LCD_clear();             
0ADEA:  CALL   5E1A
....................                strcpy (global_temp_line_buff, "Resetting Mote!!"); 
0ADEE:  CLRF   FEA
0ADF0:  MOVLW  70
0ADF2:  MOVWF  FE9
0ADF4:  MOVLW  00
0ADF6:  CALL   0742
0ADFA:  TBLRD*-
0ADFC:  TBLRD*+
0ADFE:  MOVF   FF5,W
0AE00:  MOVWF  FEE
0AE02:  IORLW  00
0AE04:  BNZ   ADFC
....................                LCD_line1(global_temp_line_buff); 
0AE06:  MOVLB  5
0AE08:  CLRF   x64
0AE0A:  MOVLW  70
0AE0C:  MOVWF  x63
0AE0E:  MOVLB  0
0AE10:  CALL   39B0
....................                global_skip_lcd_update_count = 2;    
0AE14:  MOVLW  02
0AE16:  MOVWF  x83
....................                // disable mote enabled flag 
....................                global_dust_enabled = 0;      
0AE18:  BCF    xA7.6
....................                // reset the mote    
....................                mote_reset();  
0AE1A:  CALL   46EE
....................                break;                            
0AE1E:  BRA    B1D4
....................              
....................             // Make sure the mote is responding to a boot or shutdown 
....................             case WAIT_FOR_BOOT_EVENT:     
....................                // if the mote didn't respond, set error, open valve, shutdown 
....................                if (global_dust_enabled == 0) 
0AE20:  BTFSC  xA7.6
0AE22:  BRA    AE6E
....................                {         
....................                   //  
....................                   LCD_clear();    
0AE24:  CALL   5E1A
....................                   strcpy (global_temp_line_buff, "Mote is Dead    ");   
0AE28:  CLRF   FEA
0AE2A:  MOVLW  70
0AE2C:  MOVWF  FE9
0AE2E:  MOVLW  00
0AE30:  CALL   0764
0AE34:  TBLRD*-
0AE36:  TBLRD*+
0AE38:  MOVF   FF5,W
0AE3A:  MOVWF  FEE
0AE3C:  IORLW  00
0AE3E:  BNZ   AE36
....................                   LCD_line1(global_temp_line_buff);                   
0AE40:  MOVLB  5
0AE42:  CLRF   x64
0AE44:  MOVLW  70
0AE46:  MOVWF  x63
0AE48:  MOVLB  0
0AE4A:  CALL   39B0
....................                   global_skip_lcd_update_count = 2;   
0AE4E:  MOVLW  02
0AE50:  MOVWF  x83
....................                   // save shutdown cause and queue shutdown 
....................                   global_shutdown_cause = ERR_FAIL_ON_MOTE_RESET; 
0AE52:  MOVLW  01
0AE54:  MOVWF  4D
....................  
....................                   PUSH_PRIORITY_QUEUE(OPEN_VALVE_UNKNOWN_STATE);   
0AE56:  MOVLW  3E
0AE58:  MOVLB  5
0AE5A:  MOVWF  x52
0AE5C:  MOVLB  0
0AE5E:  CALL   4748
....................                   PUSH_PRIORITY_QUEUE(SHUTDOWN_SYSTEM); 
0AE62:  MOVLW  F1
0AE64:  MOVLB  5
0AE66:  MOVWF  x52
0AE68:  MOVLB  0
0AE6A:  CALL   4748
....................                }            
....................                break; 
0AE6E:  BRA    B1D4
....................                 
....................             // Check the mote status and react appropriately 
....................             case CHECK_MOTE_STATE: 
....................                mote_state_check(); 
0AE70:  GOTO   8F64
....................                break; 
0AE74:  BRA    B1D4
....................                 
....................             case CHECK_MOTE_INFO: 
....................                mote_info_check(); 
0AE76:  GOTO   92CE
....................                break; 
0AE7A:  BRA    B1D4
....................                
....................             case UPDATE_MOTE_TIME: 
....................                mote_time_update(); 
0AE7C:  GOTO   935C
....................                break;    
0AE80:  BRA    B1D4
....................                 
....................             case UPDATE_MOTE_NETWORK_INFO: 
....................                get_mote_net_info(); 
0AE82:  GOTO   93EA
....................                break; 
0AE86:  BRA    B1D4
....................                 
....................             // Check's battery voltage, decides to charge, not charge, tell manager 
....................             // about a low voltage state, or to go to deep sleep 
....................             case CHECK_BATTERY_STATE: 
....................                /* 
....................                LCD_clear(); 
....................                LCD_display_battery_voltage(0); 
....................                LCD_place_uint16(get_vbatt(0),1,0,5); 
....................                global_skip_lcd_update_count = 2; 
....................                */         
....................                check_and_deal_with_battery(); 
0AE88:  GOTO   9478
....................                break; 
0AE8C:  BRA    B1D4
....................  
....................             // Added by Jack 2017Feb13 
....................             case SEND_UNSOLICITED_FULL_REPORT: 
....................                send_full_report(MSG_MOTE_UNSOLICITED, global_message_queue[global_current_message_queue_location].msg_seq); 
0AE8E:  MOVLB  4
0AE90:  MOVF   xF7,W
0AE92:  MULLW  08
0AE94:  MOVF   FF3,W
0AE96:  MOVLB  5
0AE98:  CLRF   x4C
0AE9A:  MOVWF  x4B
0AE9C:  MOVLW  05
0AE9E:  ADDWF  x4B,W
0AEA0:  MOVWF  01
0AEA2:  MOVLW  00
0AEA4:  ADDWFC x4C,W
0AEA6:  MOVWF  03
0AEA8:  MOVF   01,W
0AEAA:  ADDLW  A7
0AEAC:  MOVWF  FE9
0AEAE:  MOVLW  04
0AEB0:  ADDWFC 03,W
0AEB2:  MOVWF  FEA
0AEB4:  MOVFF  FEC,554
0AEB8:  MOVF   FED,F
0AEBA:  MOVFF  FEF,553
0AEBE:  CLRF   x52
0AEC0:  MOVLB  0
0AEC2:  CALL   6426
....................                break; 
0AEC6:  BRA    B1D4
....................              
....................              
....................             // Query the mote for the temp and store it 
....................             case CHECK_MOTE_TEMP: 
....................                mote_temp_check(); 
0AEC8:  GOTO   9596
....................                /* 
....................                LCD_clear(); 
....................                strcpy (global_temp_line_buff, "Temp =         C"); 
....................                LCD_line1(global_temp_line_buff); 
....................                LCD_place_uint8(global_mote_temperature,0,7,3); 
....................                global_skip_lcd_update_count = 2; 
....................                */ 
....................                break; 
0AECC:  BRA    B1D4
....................                 
....................             // First part of the search for strongest algorithm 
....................             case SEARCH_FOR_STRONGEST_1: 
....................                LCD_clear(); 
0AECE:  CALL   5E1A
....................                strcpy (global_temp_line_buff, "Search Strong 1 "); 
0AED2:  CLRF   FEA
0AED4:  MOVLW  70
0AED6:  MOVWF  FE9
0AED8:  MOVLW  00
0AEDA:  CALL   0786
0AEDE:  TBLRD*-
0AEE0:  TBLRD*+
0AEE2:  MOVF   FF5,W
0AEE4:  MOVWF  FEE
0AEE6:  IORLW  00
0AEE8:  BNZ   AEE0
....................                LCD_line1(global_temp_line_buff); 
0AEEA:  MOVLB  5
0AEEC:  CLRF   x64
0AEEE:  MOVLW  70
0AEF0:  MOVWF  x63
0AEF2:  MOVLB  0
0AEF4:  CALL   39B0
....................                global_skip_lcd_update_count = 2; 
0AEF8:  MOVLW  02
0AEFA:  MOVWF  x83
....................                // set the state of the system appropriately 
....................                global_system_state = SYSTEM_SEARCHING_FOR_NETWORK; 
0AEFC:  MOVLW  20
0AEFE:  MOVLB  5
0AF00:  MOVWF  x05
....................                PUSH_PRIORITY_QUEUE_MACRO(RESET_MOTE); 
0AF02:  BCF    F7A.1
0AF04:  MOVLW  11
0AF06:  MOVWF  x52
0AF08:  MOVLB  0
0AF0A:  CALL   4748
0AF0E:  BSF    F7A.1
....................                PUSH_TIME_QUEUE_MACRO((global_rtc_time + 10), SEARCH_FOR_STRONGEST_2); 
0AF10:  BCF    F7A.1
0AF12:  MOVLW  0A
0AF14:  ADDWF  x85,W
0AF16:  MOVLB  5
0AF18:  MOVWF  x4B
0AF1A:  MOVLW  00
0AF1C:  MOVLB  0
0AF1E:  ADDWFC x86,W
0AF20:  MOVLB  5
0AF22:  MOVWF  x4C
0AF24:  MOVLW  00
0AF26:  MOVLB  0
0AF28:  ADDWFC x87,W
0AF2A:  MOVLB  5
0AF2C:  MOVWF  x4D
0AF2E:  MOVLW  00
0AF30:  MOVLB  0
0AF32:  ADDWFC x88,W
0AF34:  MOVLB  5
0AF36:  MOVWF  x4E
0AF38:  MOVWF  x59
0AF3A:  MOVFF  54D,558
0AF3E:  MOVFF  54C,557
0AF42:  MOVFF  54B,556
0AF46:  MOVLW  B2
0AF48:  MOVWF  x5A
0AF4A:  MOVLB  0
0AF4C:  CALL   44A0
0AF50:  BSF    F7A.1
....................                break; 
0AF52:  BRA    B1D4
....................                 
....................             // Second part of the search for strongest algorithm    
....................             case SEARCH_FOR_STRONGEST_2: 
....................                LCD_clear(); 
0AF54:  CALL   5E1A
....................                strcpy (global_temp_line_buff, "Search Strong 2 "); 
0AF58:  CLRF   FEA
0AF5A:  MOVLW  70
0AF5C:  MOVWF  FE9
0AF5E:  MOVLW  00
0AF60:  CALL   07A8
0AF64:  TBLRD*-
0AF66:  TBLRD*+
0AF68:  MOVF   FF5,W
0AF6A:  MOVWF  FEE
0AF6C:  IORLW  00
0AF6E:  BNZ   AF66
....................                LCD_line1(global_temp_line_buff); 
0AF70:  MOVLB  5
0AF72:  CLRF   x64
0AF74:  MOVLW  70
0AF76:  MOVWF  x63
0AF78:  MOVLB  0
0AF7A:  CALL   39B0
....................                global_skip_lcd_update_count = 2; 
0AF7E:  MOVLW  02
0AF80:  MOVWF  x83
....................                search_for_strongest(); 
0AF82:  GOTO   99AE
....................                break; 
0AF86:  BRA    B1D4
....................              
....................             // Initalizes a mote join 
....................             case INIT_JOIN: 
....................                LCD_clear(); 
0AF88:  CALL   5E1A
....................                strcpy (global_temp_line_buff, "  Init Join     "); 
0AF8C:  CLRF   FEA
0AF8E:  MOVLW  70
0AF90:  MOVWF  FE9
0AF92:  MOVLW  00
0AF94:  CALL   07CA
0AF98:  TBLRD*-
0AF9A:  TBLRD*+
0AF9C:  MOVF   FF5,W
0AF9E:  MOVWF  FEE
0AFA0:  IORLW  00
0AFA2:  BNZ   AF9A
....................                LCD_line1(global_temp_line_buff); 
0AFA4:  MOVLB  5
0AFA6:  CLRF   x64
0AFA8:  MOVLW  70
0AFAA:  MOVWF  x63
0AFAC:  MOVLB  0
0AFAE:  CALL   39B0
....................                global_skip_lcd_update_count = 2;   
0AFB2:  MOVLW  02
0AFB4:  MOVWF  x83
....................                initiate_join();                                      
0AFB6:  GOTO   9DD6
....................                break; 
0AFBA:  BRA    B1D4
....................              
....................             // not used anymore 
....................             case OPTIMIZE_MPPC: 
....................                adjust_mppc();   
0AFBC:  GOTO   9F50
....................                break;             
0AFC0:  BRA    B1D4
....................                 
....................             // resets the cpu (if all pending messages are sent)    
....................             case CPU_RESET: 
....................                // if the dust network is operational and the message queue is not empty (location at 255) 
....................                //    wait for the message to be ack'd/resent and reschedule the shutdown.  
....................                if ((global_dust_operational == TRUE) && (global_current_message_queue_location != 255)) 
0AFC2:  BTFSS  xA7.7
0AFC4:  BRA    B018
0AFC6:  MOVLB  4
0AFC8:  INCFSZ xF7,W
0AFCA:  BRA    AFD2
0AFCC:  MOVLB  0
0AFCE:  BRA    B018
0AFD0:  MOVLB  4
....................                { 
....................                   PUSH_TIME_QUEUE_MACRO((global_rtc_time + 10), CPU_RESET); 
0AFD2:  BCF    F7A.1
0AFD4:  MOVLW  0A
0AFD6:  MOVLB  0
0AFD8:  ADDWF  x85,W
0AFDA:  MOVLB  5
0AFDC:  MOVWF  x4B
0AFDE:  MOVLW  00
0AFE0:  MOVLB  0
0AFE2:  ADDWFC x86,W
0AFE4:  MOVLB  5
0AFE6:  MOVWF  x4C
0AFE8:  MOVLW  00
0AFEA:  MOVLB  0
0AFEC:  ADDWFC x87,W
0AFEE:  MOVLB  5
0AFF0:  MOVWF  x4D
0AFF2:  MOVLW  00
0AFF4:  MOVLB  0
0AFF6:  ADDWFC x88,W
0AFF8:  MOVLB  5
0AFFA:  MOVWF  x4E
0AFFC:  MOVWF  x59
0AFFE:  MOVFF  54D,558
0B002:  MOVFF  54C,557
0B006:  MOVFF  54B,556
0B00A:  MOVLW  F0
0B00C:  MOVWF  x5A
0B00E:  MOVLB  0
0B010:  CALL   44A0
0B014:  BSF    F7A.1
....................                } 
0B016:  BRA    B066
....................                // if the valve is moving, check again later 
....................                else if (!IS_VLV_COASTING) 
0B018:  MOVF   F8D,F
0B01A:  BZ    B060
....................                {                       
....................                   PUSH_TIME_QUEUE_MACRO((global_rtc_time + 10), CPU_RESET); 
0B01C:  BCF    F7A.1
0B01E:  MOVLW  0A
0B020:  ADDWF  x85,W
0B022:  MOVLB  5
0B024:  MOVWF  x4B
0B026:  MOVLW  00
0B028:  MOVLB  0
0B02A:  ADDWFC x86,W
0B02C:  MOVLB  5
0B02E:  MOVWF  x4C
0B030:  MOVLW  00
0B032:  MOVLB  0
0B034:  ADDWFC x87,W
0B036:  MOVLB  5
0B038:  MOVWF  x4D
0B03A:  MOVLW  00
0B03C:  MOVLB  0
0B03E:  ADDWFC x88,W
0B040:  MOVLB  5
0B042:  MOVWF  x4E
0B044:  MOVWF  x59
0B046:  MOVFF  54D,558
0B04A:  MOVFF  54C,557
0B04E:  MOVFF  54B,556
0B052:  MOVLW  F0
0B054:  MOVWF  x5A
0B056:  MOVLB  0
0B058:  CALL   44A0
0B05C:  BSF    F7A.1
....................                } 
0B05E:  BRA    B066
....................                // All messages are sent 
....................                else 
....................                { 
....................                   // if it does, restart the entire system 
....................                   store_all_eeprom_values(); 
0B060:  CALL   A02A
....................                   reset_cpu(); 
0B064:  RESET
....................                } 
....................                break; 
0B066:  BRA    B1D4
....................                 
....................             // Shuts down the pic for a variety of reasons 
....................             case SHUTDOWN_SYSTEM:                
....................                // if the dust network is operational and the message queue is not empty (location at 255) 
....................                //    wait for the message to be ack'd/resent and reschedule the shutdown. 
....................                // I suppose this has potential to be problamatic, but the network should eventually show 
....................                //    up as non-operational in mote-check or get ack'd at some point, I would hope. 
....................                                                               
....................                global_brake_duty_set_value = NO_BRK; 
0B068:  CLRF   xB7
0B06A:  CLRF   xB6
....................                global_charge_duty_set_value = NO_CHARGE; 
0B06C:  CLRF   xB9
0B06E:  CLRF   xB8
....................                global_control_loop_mechanism = NO_RPM_CONTROL_DYN_MPPC; 
0B070:  MOVLW  06
0B072:  MOVWF  xC0
....................                 
....................                // if the system hasn't moved the brake and charge settings to 0, wait 
....................                if ((global_brake_duty != NO_BRK) || (global_charge_duty != NO_CHARGE)) 
0B074:  MOVF   xB2,F
0B076:  BNZ   B084
0B078:  MOVF   xB3,F
0B07A:  BNZ   B084
0B07C:  MOVF   xB4,F
0B07E:  BNZ   B084
0B080:  MOVF   xB5,F
0B082:  BZ    B088
....................                { 
....................                   break; 
0B084:  BRA    B1D4
....................                }                
0B086:  BRA    B1D2
....................                // if there are still messages to be sent and the mote is working, wait 
....................                else if ((global_dust_operational == TRUE) && (global_current_message_queue_location != 255)) 
0B088:  BTFSS  xA7.7
0B08A:  BRA    B0DE
0B08C:  MOVLB  4
0B08E:  INCFSZ xF7,W
0B090:  BRA    B098
0B092:  MOVLB  0
0B094:  BRA    B0DE
0B096:  MOVLB  4
....................                {                                                 
....................                   PUSH_TIME_QUEUE_MACRO((global_rtc_time + 10), SHUTDOWN_SYSTEM); 
0B098:  BCF    F7A.1
0B09A:  MOVLW  0A
0B09C:  MOVLB  0
0B09E:  ADDWF  x85,W
0B0A0:  MOVLB  5
0B0A2:  MOVWF  x4B
0B0A4:  MOVLW  00
0B0A6:  MOVLB  0
0B0A8:  ADDWFC x86,W
0B0AA:  MOVLB  5
0B0AC:  MOVWF  x4C
0B0AE:  MOVLW  00
0B0B0:  MOVLB  0
0B0B2:  ADDWFC x87,W
0B0B4:  MOVLB  5
0B0B6:  MOVWF  x4D
0B0B8:  MOVLW  00
0B0BA:  MOVLB  0
0B0BC:  ADDWFC x88,W
0B0BE:  MOVLB  5
0B0C0:  MOVWF  x4E
0B0C2:  MOVWF  x59
0B0C4:  MOVFF  54D,558
0B0C8:  MOVFF  54C,557
0B0CC:  MOVFF  54B,556
0B0D0:  MOVLW  F1
0B0D2:  MOVWF  x5A
0B0D4:  MOVLB  0
0B0D6:  CALL   44A0
0B0DA:  BSF    F7A.1
....................                } 
0B0DC:  BRA    B1D2
....................                // if the valve is moving, wait                           
....................                else if (!IS_VLV_COASTING) 
0B0DE:  MOVF   F8D,F
0B0E0:  BZ    B126
....................                { 
....................                   PUSH_TIME_QUEUE_MACRO((global_rtc_time + 10), SHUTDOWN_SYSTEM); 
0B0E2:  BCF    F7A.1
0B0E4:  MOVLW  0A
0B0E6:  ADDWF  x85,W
0B0E8:  MOVLB  5
0B0EA:  MOVWF  x4B
0B0EC:  MOVLW  00
0B0EE:  MOVLB  0
0B0F0:  ADDWFC x86,W
0B0F2:  MOVLB  5
0B0F4:  MOVWF  x4C
0B0F6:  MOVLW  00
0B0F8:  MOVLB  0
0B0FA:  ADDWFC x87,W
0B0FC:  MOVLB  5
0B0FE:  MOVWF  x4D
0B100:  MOVLW  00
0B102:  MOVLB  0
0B104:  ADDWFC x88,W
0B106:  MOVLB  5
0B108:  MOVWF  x4E
0B10A:  MOVWF  x59
0B10C:  MOVFF  54D,558
0B110:  MOVFF  54C,557
0B114:  MOVFF  54B,556
0B118:  MOVLW  F1
0B11A:  MOVWF  x5A
0B11C:  MOVLB  0
0B11E:  CALL   44A0
0B122:  BSF    F7A.1
....................                }                                 
0B124:  BRA    B1D2
....................                // All messages are sent or system is shutting down due to no network connection  
....................                //    and system is in SYSTEM_RUN or SYSTEM_IDLE state  
....................                else if ((read_system_state() == SYSTEM_RUN) || ((read_system_state() == SYSTEM_IDLE))) 
0B126:  CALL   1F4A
0B12A:  MOVF   01,W
0B12C:  SUBLW  02
0B12E:  BZ    B13A
0B130:  CALL   1F4A
0B134:  MOVF   01,W
0B136:  SUBLW  03
0B138:  BNZ   B190
....................                { 
....................                   // try to put the mote to sleep 
....................                   if (mote_sleep() == NO_ERR)          
0B13A:  GOTO   A09E
0B13E:  MOVF   01,F
0B140:  BNZ   B14C
....................                   { 
....................                      // if it does, put the entire system to sleep 
....................                      store_all_eeprom_values(); 
0B142:  CALL   A02A
....................                      deep_sleep(); 
0B146:  CALL   9740
....................                   } 
0B14A:  BRA    B18E
....................                   // otherwise, try again in 10 seconds    
....................                   else 
....................                   { 
....................                      PUSH_TIME_QUEUE_MACRO((global_rtc_time + 10), SHUTDOWN_SYSTEM); 
0B14C:  BCF    F7A.1
0B14E:  MOVLW  0A
0B150:  ADDWF  x85,W
0B152:  MOVLB  5
0B154:  MOVWF  x4B
0B156:  MOVLW  00
0B158:  MOVLB  0
0B15A:  ADDWFC x86,W
0B15C:  MOVLB  5
0B15E:  MOVWF  x4C
0B160:  MOVLW  00
0B162:  MOVLB  0
0B164:  ADDWFC x87,W
0B166:  MOVLB  5
0B168:  MOVWF  x4D
0B16A:  MOVLW  00
0B16C:  MOVLB  0
0B16E:  ADDWFC x88,W
0B170:  MOVLB  5
0B172:  MOVWF  x4E
0B174:  MOVWF  x59
0B176:  MOVFF  54D,558
0B17A:  MOVFF  54C,557
0B17E:  MOVFF  54B,556
0B182:  MOVLW  F1
0B184:  MOVWF  x5A
0B186:  MOVLB  0
0B188:  CALL   44A0
0B18C:  BSF    F7A.1
....................                   } 
....................                } 
0B18E:  BRA    B1D2
....................                // Anything else, just wait 
....................                else 
....................                { 
....................                   PUSH_TIME_QUEUE_MACRO((global_rtc_time + 10), SHUTDOWN_SYSTEM); 
0B190:  BCF    F7A.1
0B192:  MOVLW  0A
0B194:  ADDWF  x85,W
0B196:  MOVLB  5
0B198:  MOVWF  x4B
0B19A:  MOVLW  00
0B19C:  MOVLB  0
0B19E:  ADDWFC x86,W
0B1A0:  MOVLB  5
0B1A2:  MOVWF  x4C
0B1A4:  MOVLW  00
0B1A6:  MOVLB  0
0B1A8:  ADDWFC x87,W
0B1AA:  MOVLB  5
0B1AC:  MOVWF  x4D
0B1AE:  MOVLW  00
0B1B0:  MOVLB  0
0B1B2:  ADDWFC x88,W
0B1B4:  MOVLB  5
0B1B6:  MOVWF  x4E
0B1B8:  MOVWF  x59
0B1BA:  MOVFF  54D,558
0B1BE:  MOVFF  54C,557
0B1C2:  MOVFF  54B,556
0B1C6:  MOVLW  F1
0B1C8:  MOVWF  x5A
0B1CA:  MOVLB  0
0B1CC:  CALL   44A0
0B1D0:  BSF    F7A.1
....................                } 
....................                break; 
0B1D2:  BRA    B1D4
....................                 
....................             // updates  
....................             // Default case (nothing to do)                
....................             case EMPTY_PRIORITY_QUEUE: 
....................                //LCD_place_uint32(global_rtc_time, 1, 0, 10); 
....................                break; 
....................          } 
....................           
....................       } 
0B1D4:  GOTO   A5BE
.................... ////////////////////End of Priority Queue Handling///////////////////////////// 
....................    // end of inifinite while loop 
....................    }    
.................... } 
....................  
....................  
.................... //#PRIORITY COMP, CCP5, EXT2, CCP3, CCP4, BUSCOL 
.................... #PRIORITY CCP5, COMP, CCP3, EXT2, TIMER0, CCP4, BUSCOL, INT_RB, EXT           
....................                                                                      
.................... #INT_RB          
.................... void RB_ISR(void)                                
0B1D8:  SLEEP 
.................... {                           
....................    // Setup in periph init to be called only when RB4 has changed state 
....................    // RB4 is connected to SW1n  
....................     
....................    // keeps track of when the switch was pressed so we can enable the long press functionality      
....................  
....................    if (!input(SW1n)) 
*
007EC:  BTFSC  F81.4
007EE:  BRA    0802
....................    { 
....................       sw1_start_time = global_rtc_time; 
007F0:  MOVFF  88,94
007F4:  MOVFF  87,93
007F8:  MOVFF  86,92
007FC:  MOVFF  85,91
....................       return; 
00800:  BRA    081C
....................    }            
....................     
....................    sw1_start_time = 0; 
00802:  CLRF   x94
00804:  CLRF   x93
00806:  CLRF   x92
00808:  CLRF   x91
....................    // if you're incrementing past the last page, reset to the first page   
....................    if (global_lcd_page_number == TOTAL_LCD_PAGES) 
0080A:  MOVF   x84,W
0080C:  SUBLW  04
0080E:  BNZ   0816
....................    {                                             
....................       global_lcd_page_number = 1;    
00810:  MOVLW  01
00812:  MOVWF  x84
....................    }      
00814:  BRA    0818
....................    // otherwise, just increment the page number 
....................    else     
....................    { 
....................       global_lcd_page_number++; 
00816:  INCF   x84,F
....................    }  
....................     
....................    // trigger a full LCD update (including the contstant parts of the lcd) 
....................    global_skip_lcd_update_count = 1;       
00818:  MOVLW  01
0081A:  MOVWF  x83
....................           
....................    return; 
....................     
....................     
....................        
....................    // not quite ready for prime time long press code (causes boot-looping, but is probably close) 
....................    // if SW1 is depressed (active), take note of the time  
....................     
.................... /*   
....................    if (!input(SW1n)) 
....................    { 
....................       sw1_start_time = global_rtc_time;   
....................    }                                  
....................    // when SW1 is coming back up  
....................    else                   
....................    {                                         
....................       // if the button has been pressed more than SW1_ISR_LONG_PRESS_TIME     
....................       //    do the long-press action 
....................       if ((global_rtc_time - sw1_start_time) > SW1_ISR_LONG_PRESS_TIME) 
....................       {                   
....................          // long-press action 
....................          flash_leds_ISR(2);  
....................       }         
....................                                            
....................       // if the button had been pressed less than SW1_ISR_LONG_PRESS_TIME, increment the page    
....................       else 
....................       {         
....................          // if you're incrementing past the last page, reset to the first page   
....................          if (global_lcd_page_number == TOTAL_LCD_PAGES) 
....................          {                                             
....................             global_lcd_page_number = 1;    
....................          }      
....................          // otherwie, just increment the page number 
....................          else     
....................          { 
....................             global_lcd_page_number++; 
....................          }  
....................                                             
....................          // trigger a full LCD update (including the contstant parts of the lcd) 
....................          global_skip_lcd_update_count = 1;                  
....................       } 
....................       return; 
....................    } 
....................  */ 
....................   
.................... } 
....................  
....................  
0081C:  BCF    FF2.0
0081E:  GOTO   00A0
.................... #INT_EXT 
.................... void vgen_wakeup_ISR(void) 
.................... { 
.................... // runs on wakeup from vgen int 
....................    reset_cpu();                  
00822:  RESET
.................... }                 
....................  
00824:  BCF    FF2.1
00826:  GOTO   015E
.................... #INT_BUSCOL 
.................... void BUSCOL_ISR(void) 
.................... {   
.................... // Catches and recovers from an i2c bus collision  
....................  
....................    // are reenabled in MAIN        
....................    disable_interrupts(GLOBAL); 
*
008DC:  BCF    FF2.6
008DE:  BCF    FF2.7
008E0:  BTFSC  FF2.7
008E2:  BRA    08DE
....................     
....................    // clear bus collision interrupt flag 
....................    BCL1IF = FALSE; 
008E4:  BCF    FA1.3
008E6:  CLRF   19
008E8:  BTFSC  FF2.7
008EA:  BSF    19.7
008EC:  BCF    FF2.7
....................     
....................    // schedule a bus collision reset 
....................    PUSH_PRIORITY_QUEUE_ISR_MACRO(BUSCOL_RESET); 
008EE:  MOVLW  C0
008F0:  MOVLB  6
008F2:  MOVWF  x2C
008F4:  MOVLB  0
008F6:  RCALL  082A
008F8:  BTFSC  19.7
008FA:  BSF    FF2.7
....................  
....................    // if the lcd is connected, reset it 
....................    if (global_lcd_enabled) 
008FC:  BTFSS  xA7.0
008FE:  BRA    090C
....................    {   
....................       output_low(LCD_RESETn); 
00900:  BCF    F8C.2
....................       delay_cycles(64);       // about 1 millisecond 
00902:  MOVLW  15
00904:  MOVWF  00
00906:  DECFSZ 00,F
00908:  BRA    0906
....................       output_high(LCD_RESETn); 
0090A:  BSF    F8C.2
....................    }    
....................     
....................    // send the stack pointer to position 1 (perhaps sort of dangerous) 
....................    STKPTR = 1; 
0090C:  MOVLW  01
0090E:  MOVWF  FFC
.................... } 
....................  
00910:  BCF    FA1.3
00912:  GOTO   00A0
.................... #INT_EXT2  
.................... void mote_interrupt(void) 
.................... {    
.................... // interrupt called when mote rts line gets asserted    
....................    uint8_t     tmp_oscccon, tmp_t2con, tmp_pr2, tmp_t0con; 
....................     
....................    // save the current oscillator setup 
....................    tmp_oscccon = OSCCON; 
*
017D2:  MOVFF  FD3,5F8
....................    tmp_t2con = T2CON; 
017D6:  MOVFF  FBA,5F9
....................    tmp_pr2 = PR2; 
017DA:  MOVFF  FBB,5FA
....................    tmp_t0con = T0CON; 
017DE:  MOVFF  FD5,5FB
....................     
....................    // start primary (3.8Mhz) crystal for UART communication 
....................    fosc_pri_ISR(); 
017E2:  GOTO   0916
....................     
....................    // disable int_ccp4 as (unsolicited) message queue can overwrite payload_buff 
....................    disable_interrupts(INT_CCP4); 
017E6:  BCF    F7A.1
....................                                    
....................    // recieve serial data, respond, and schedule deal with packet if necessary 
....................    deal_with_mote_ISR(); 
017E8:  BRA    1248
....................     
....................    // renable int_ccp4 as we're done touching payload_buff       
....................    enable_interrupts(INT_CCP4);   
017EA:  BSF    F7A.1
....................                                      
....................    // restore the current oscillator 
....................    OSCCON = tmp_oscccon; 
017EC:  MOVFF  5F8,FD3
....................    T2CON = tmp_t2con; 
017F0:  MOVFF  5F9,FBA
....................    T0CON = tmp_t0con; 
017F4:  MOVFF  5FB,FD5
....................    PR2 = tmp_PR2; 
017F8:  MOVFF  5FA,FBB
.................... } 
....................  
....................  
017FC:  BCF    FF0.1
017FE:  GOTO   00A0
.................... #INT_COMP 
.................... void comp1_ISR(void) 
.................... { 
.................... // ISR routine that is called when the comparator current limit is reached 
....................    uint16_t    temp16_frac; 
....................     
....................     // if comarator 1 is tripped (INT_COMP is triggered by comp 1 or 2) 
....................    if (C1OUT) 
*
01A96:  BTFSS  F79.6
01A98:  BRA    1F44
....................    {      
....................       // grab the extra time/2ndary osc ticks since the last 1024th interrupt   
....................       temp16_frac = get_timer1(); 
01A9A:  MOVF   FCE,W
01A9C:  MOVLB  5
01A9E:  MOVWF  xF8
01AA0:  MOVFF  FCF,5F9
....................        
....................       if (global_system_state == SYSTEM_CAL_VLV_1) 
01AA4:  MOVF   x05,W
01AA6:  SUBLW  10
01AA8:  BNZ   1B02
....................       { 
....................          global_valve_position = VLV_POSITION_OPENED; 
01AAA:  MOVLW  80
01AAC:  MOVLB  0
01AAE:  MOVWF  xC2
01AB0:  CLRF   xC1
....................          // queue up the next stage of the calibration 
....................          push_time_queue_ISR(global_rtc_time + 3, CALIBRATE_VALVE_2); 
01AB2:  MOVLW  03
01AB4:  ADDWF  x85,W
01AB6:  MOVLB  5
01AB8:  MOVWF  xFA
01ABA:  MOVLW  00
01ABC:  MOVLB  0
01ABE:  ADDWFC x86,W
01AC0:  MOVLB  5
01AC2:  MOVWF  xFB
01AC4:  MOVLW  00
01AC6:  MOVLB  0
01AC8:  ADDWFC x87,W
01ACA:  MOVLB  5
01ACC:  MOVWF  xFC
01ACE:  MOVLW  00
01AD0:  MOVLB  0
01AD2:  ADDWFC x88,W
01AD4:  MOVLB  5
01AD6:  MOVWF  xFD
01AD8:  CLRF   19
01ADA:  BTFSC  FF2.7
01ADC:  BSF    19.7
01ADE:  BCF    FF2.7
01AE0:  MOVFF  FE8,633
01AE4:  MOVFF  5FC,632
01AE8:  MOVFF  5FB,631
01AEC:  MOVFF  5FA,630
01AF0:  MOVLW  32
01AF2:  MOVLB  6
01AF4:  MOVWF  x34
01AF6:  MOVLB  0
01AF8:  RCALL  1802
01AFA:  BTFSC  19.7
01AFC:  BSF    FF2.7
....................       } 
01AFE:  BRA    1F2C
01B00:  MOVLB  5
....................       // valve closing towards closing endstop pre-calibration 
....................       else if (global_system_state == SYSTEM_CAL_VLV_2) 
01B02:  MOVF   x05,W
01B04:  SUBLW  11
01B06:  BNZ   1B5E
....................       { 
....................          global_valve_position = VLV_POSITION_CLOSED;  
01B08:  MOVLB  0
01B0A:  CLRF   xC2
01B0C:  CLRF   xC1
....................          // queue up the next stage of the calibration 
....................          push_time_queue_ISR(global_rtc_time + 3, CALIBRATE_VALVE_3); 
01B0E:  MOVLW  03
01B10:  ADDWF  x85,W
01B12:  MOVLB  5
01B14:  MOVWF  xFA
01B16:  MOVLW  00
01B18:  MOVLB  0
01B1A:  ADDWFC x86,W
01B1C:  MOVLB  5
01B1E:  MOVWF  xFB
01B20:  MOVLW  00
01B22:  MOVLB  0
01B24:  ADDWFC x87,W
01B26:  MOVLB  5
01B28:  MOVWF  xFC
01B2A:  MOVLW  00
01B2C:  MOVLB  0
01B2E:  ADDWFC x88,W
01B30:  MOVLB  5
01B32:  MOVWF  xFD
01B34:  CLRF   19
01B36:  BTFSC  FF2.7
01B38:  BSF    19.7
01B3A:  BCF    FF2.7
01B3C:  MOVFF  FE8,633
01B40:  MOVFF  5FC,632
01B44:  MOVFF  5FB,631
01B48:  MOVFF  5FA,630
01B4C:  MOVLW  33
01B4E:  MOVLB  6
01B50:  MOVWF  x34
01B52:  MOVLB  0
01B54:  RCALL  1802
01B56:  BTFSC  19.7
01B58:  BSF    FF2.7
....................       } 
01B5A:  BRA    1F2C
01B5C:  MOVLB  5
....................       // valve opening fully from fully closed for calibration 
....................       else if (global_system_state == SYSTEM_CAL_VLV_3) 
01B5E:  MOVF   x05,W
01B60:  SUBLW  12
01B62:  BNZ   1C46
....................       { 
....................          // set the valve position to open 
....................          global_valve_position = VLV_POSITION_OPENED;  
01B64:  MOVLW  80
01B66:  MOVLB  0
01B68:  MOVWF  xC2
01B6A:  CLRF   xC1
....................          // recalculate the valve opening time for each 1024th 
....................          //    (valve movements (1024th) * the time it takes for each 1024th 
....................          //    + the extra time) divided by 1024 
....................          global_valve_time_to_open_1024th =                                   \ 
....................          ((((uint32_t) global_valve_time_in_motion_1024ths * (uint32_t) global_valve_time_to_open_1024th) \ 
....................          + temp16_frac) >> 10); 
01B6C:  MOVLB  5
01B6E:  CLRF   xFD
01B70:  CLRF   xFC
01B72:  MOVFF  CA,5FB
01B76:  MOVFF  C9,5FA
01B7A:  MOVFF  C7,00
01B7E:  MOVFF  C8,01
01B82:  CLRF   02
01B84:  CLRF   03
01B86:  MOVFF  03,601
01B8A:  MOVFF  02,600
01B8E:  MOVFF  C8,5FF
01B92:  MOVFF  C7,5FE
01B96:  MOVFF  5FD,605
01B9A:  MOVFF  5FC,604
01B9E:  MOVFF  CA,603
01BA2:  MOVFF  C9,602
01BA6:  MOVFF  03,609
01BAA:  MOVFF  02,608
01BAE:  MOVFF  C8,607
01BB2:  MOVFF  C7,606
01BB6:  MOVLB  0
01BB8:  RCALL  1A3C
01BBA:  MOVFF  03,5FD
01BBE:  MOVFF  02,5FC
01BC2:  MOVFF  01,5FB
01BC6:  MOVFF  00,5FA
01BCA:  MOVLB  5
01BCC:  MOVF   xF8,W
01BCE:  ADDWF  xFA,F
01BD0:  MOVF   xF9,W
01BD2:  ADDWFC xFB,F
01BD4:  MOVLW  00
01BD6:  ADDWFC xFC,F
01BD8:  ADDWFC xFD,F
01BDA:  RRCF   xFD,W
01BDC:  MOVWF  02
01BDE:  RRCF   xFC,W
01BE0:  MOVWF  01
01BE2:  RRCF   xFB,W
01BE4:  MOVWF  00
01BE6:  RRCF   02,F
01BE8:  RRCF   01,F
01BEA:  RRCF   00,F
01BEC:  MOVFF  00,C7
01BF0:  MOVLB  0
01BF2:  MOVFF  01,C8
....................          // queue up the next stage of the calibration 
....................          push_time_queue_ISR(global_rtc_time + 3, CALIBRATE_VALVE_5); 
01BF6:  MOVLW  03
01BF8:  ADDWF  x85,W
01BFA:  MOVLB  5
01BFC:  MOVWF  xFA
01BFE:  MOVLW  00
01C00:  MOVLB  0
01C02:  ADDWFC x86,W
01C04:  MOVLB  5
01C06:  MOVWF  xFB
01C08:  MOVLW  00
01C0A:  MOVLB  0
01C0C:  ADDWFC x87,W
01C0E:  MOVLB  5
01C10:  MOVWF  xFC
01C12:  MOVLW  00
01C14:  MOVLB  0
01C16:  ADDWFC x88,W
01C18:  MOVLB  5
01C1A:  MOVWF  xFD
01C1C:  CLRF   19
01C1E:  BTFSC  FF2.7
01C20:  BSF    19.7
01C22:  BCF    FF2.7
01C24:  MOVFF  FE8,633
01C28:  MOVFF  5FC,632
01C2C:  MOVFF  5FB,631
01C30:  MOVFF  5FA,630
01C34:  MOVLW  35
01C36:  MOVLB  6
01C38:  MOVWF  x34
01C3A:  MOVLB  0
01C3C:  RCALL  1802
01C3E:  BTFSC  19.7
01C40:  BSF    FF2.7
....................       } 
01C42:  BRA    1F2C
01C44:  MOVLB  5
....................       // valve closing fully from fully open for calibration 
....................       else if (global_system_state == SYSTEM_CAL_VLV_5) 
01C46:  MOVF   x05,W
01C48:  SUBLW  14
01C4A:  BNZ   1D2C
....................       { 
....................          global_valve_position = VLV_POSITION_CLOSED;  
01C4C:  MOVLB  0
01C4E:  CLRF   xC2
01C50:  CLRF   xC1
....................          // recalculate the valve closing time for each 1024th 
....................          //    (valve movements (1024th) * the time it takes for each 1024th 
....................          //    + the extra time) divided by 1024 
....................          global_valve_time_to_close_1024th =                                   \ 
....................          ((((uint32_t) global_valve_time_in_motion_1024ths * (uint32_t) global_valve_time_to_close_1024th) \ 
....................          + temp16_frac) >> 10); 
01C52:  MOVLB  5
01C54:  CLRF   xFD
01C56:  CLRF   xFC
01C58:  MOVFF  CA,5FB
01C5C:  MOVFF  C9,5FA
01C60:  MOVFF  C5,00
01C64:  MOVFF  C6,01
01C68:  CLRF   02
01C6A:  CLRF   03
01C6C:  MOVFF  03,601
01C70:  MOVFF  02,600
01C74:  MOVFF  C6,5FF
01C78:  MOVFF  C5,5FE
01C7C:  MOVFF  5FD,605
01C80:  MOVFF  5FC,604
01C84:  MOVFF  CA,603
01C88:  MOVFF  C9,602
01C8C:  MOVFF  03,609
01C90:  MOVFF  02,608
01C94:  MOVFF  C6,607
01C98:  MOVFF  C5,606
01C9C:  MOVLB  0
01C9E:  RCALL  1A3C
01CA0:  MOVFF  03,5FD
01CA4:  MOVFF  02,5FC
01CA8:  MOVFF  01,5FB
01CAC:  MOVFF  00,5FA
01CB0:  MOVLB  5
01CB2:  MOVF   xF8,W
01CB4:  ADDWF  xFA,F
01CB6:  MOVF   xF9,W
01CB8:  ADDWFC xFB,F
01CBA:  MOVLW  00
01CBC:  ADDWFC xFC,F
01CBE:  ADDWFC xFD,F
01CC0:  RRCF   xFD,W
01CC2:  MOVWF  02
01CC4:  RRCF   xFC,W
01CC6:  MOVWF  01
01CC8:  RRCF   xFB,W
01CCA:  MOVWF  00
01CCC:  RRCF   02,F
01CCE:  RRCF   01,F
01CD0:  RRCF   00,F
01CD2:  MOVFF  00,C5
01CD6:  MOVLB  0
01CD8:  MOVFF  01,C6
....................          // queue up the next stage of the calibration 
....................          push_time_queue_ISR(global_rtc_time + 3, CALIBRATE_VALVE_6); 
01CDC:  MOVLW  03
01CDE:  ADDWF  x85,W
01CE0:  MOVLB  5
01CE2:  MOVWF  xFA
01CE4:  MOVLW  00
01CE6:  MOVLB  0
01CE8:  ADDWFC x86,W
01CEA:  MOVLB  5
01CEC:  MOVWF  xFB
01CEE:  MOVLW  00
01CF0:  MOVLB  0
01CF2:  ADDWFC x87,W
01CF4:  MOVLB  5
01CF6:  MOVWF  xFC
01CF8:  MOVLW  00
01CFA:  MOVLB  0
01CFC:  ADDWFC x88,W
01CFE:  MOVLB  5
01D00:  MOVWF  xFD
01D02:  CLRF   19
01D04:  BTFSC  FF2.7
01D06:  BSF    19.7
01D08:  BCF    FF2.7
01D0A:  MOVFF  FE8,633
01D0E:  MOVFF  5FC,632
01D12:  MOVFF  5FB,631
01D16:  MOVFF  5FA,630
01D1A:  MOVLW  36
01D1C:  MOVLB  6
01D1E:  MOVWF  x34
01D20:  MOVLB  0
01D22:  RCALL  1802
01D24:  BTFSC  19.7
01D26:  BSF    FF2.7
....................       } 
01D28:  BRA    1F2C
01D2A:  MOVLB  5
....................       // we are doing a valve endstop detect that we have a known calibration for. 
....................       // We want to check the positional error (if we are too far away from the 
....................       // endstop in position when the endstop is detected).  This applies to  
....................       // normal moves as well as re-calibration moves. 
....................       else 
....................       { 
....................          // valve has closed/opened fully in preparation of a recalibration of  
....................          //    valve position.  Trigger a move valve to move to the pending valve 
....................          //    set position and set system status to run 
....................          if (global_system_state == SYSTEM_RECAL_VLV_MOVES) 
01D2C:  MOVF   x05,W
01D2E:  SUBLW  16
01D30:  BNZ   1D86
....................          { 
....................             push_time_queue_ISR(global_rtc_time + 3, MOVE_VALVE); 
01D32:  MOVLW  03
01D34:  MOVLB  0
01D36:  ADDWF  x85,W
01D38:  MOVLB  5
01D3A:  MOVWF  xFA
01D3C:  MOVLW  00
01D3E:  MOVLB  0
01D40:  ADDWFC x86,W
01D42:  MOVLB  5
01D44:  MOVWF  xFB
01D46:  MOVLW  00
01D48:  MOVLB  0
01D4A:  ADDWFC x87,W
01D4C:  MOVLB  5
01D4E:  MOVWF  xFC
01D50:  MOVLW  00
01D52:  MOVLB  0
01D54:  ADDWFC x88,W
01D56:  MOVLB  5
01D58:  MOVWF  xFD
01D5A:  CLRF   19
01D5C:  BTFSC  FF2.7
01D5E:  BSF    19.7
01D60:  BCF    FF2.7
01D62:  MOVFF  FE8,633
01D66:  MOVFF  5FC,632
01D6A:  MOVFF  5FB,631
01D6E:  MOVFF  5FA,630
01D72:  MOVLW  40
01D74:  MOVLB  6
01D76:  MOVWF  x34
01D78:  MOVLB  0
01D7A:  RCALL  1802
01D7C:  BTFSC  19.7
01D7E:  BSF    FF2.7
....................             global_system_state = SYSTEM_RUN; 
01D80:  MOVLW  02
01D82:  MOVLB  5
01D84:  MOVWF  x05
....................          } 
....................          // valve is closing 
....................          if ((IS_VLV_CLOSING) && (global_system_state != SYSTEM_INIT)) 
01D86:  DECFSZ F8D,W
01D88:  BRA    1E28
01D8A:  MOVF   x05,F
01D8C:  BZ    1E28
....................          { 
....................             // error checking if valve movement was longer or shorter than expected 
....................             // We accomplish this by seeing if the valve hit an endstop while it was 
....................             //    outside the VLV_NEAR_CLOSED_RANGE_MAX/VLV_NEAR_OPENED_RANGE_MAX 
....................             if (global_valve_position > VLV_NEAR_CLOSED_RANGE_MAX) 
01D8E:  MOVF   x07,W
01D90:  MOVLB  0
01D92:  SUBWF  xC2,W
01D94:  BNC   1E08
01D96:  BNZ   1DA8
01D98:  MOVF   xC1,W
01D9A:  MOVLB  5
01D9C:  SUBWF  x06,W
01D9E:  BTFSS  FD8.0
01DA0:  BRA    1DA6
01DA2:  MOVLB  0
01DA4:  BRA    1E08
01DA6:  MOVLB  0
....................             { 
....................                // put system into run mode (in case it's in valve cal routine) 
....................                global_system_state = SYSTEM_RUN; 
01DA8:  MOVLW  02
01DAA:  MOVLB  5
01DAC:  MOVWF  x05
....................                // set valve to unknown position (uncalibrated) 
....................                global_valve_position = VLV_POSITION_UNKNOWN; 
01DAE:  MOVLB  0
01DB0:  SETF   xC2
01DB2:  SETF   xC1
....................                // set the error bitfield and send an error 
....................                global_error_message_bitfield |= ERR_MSG_VLV_MOVE_FAIL; 
01DB4:  MOVLB  4
01DB6:  BSF    xF9.2
....................                push_time_queue_ISR(global_rtc_time + 1, MSG_MOTE_ERROR_MSG); 
01DB8:  MOVLW  01
01DBA:  MOVLB  0
01DBC:  ADDWF  x85,W
01DBE:  MOVLB  5
01DC0:  MOVWF  xFA
01DC2:  MOVLW  00
01DC4:  MOVLB  0
01DC6:  ADDWFC x86,W
01DC8:  MOVLB  5
01DCA:  MOVWF  xFB
01DCC:  MOVLW  00
01DCE:  MOVLB  0
01DD0:  ADDWFC x87,W
01DD2:  MOVLB  5
01DD4:  MOVWF  xFC
01DD6:  MOVLW  00
01DD8:  MOVLB  0
01DDA:  ADDWFC x88,W
01DDC:  MOVLB  5
01DDE:  MOVWF  xFD
01DE0:  CLRF   19
01DE2:  BTFSC  FF2.7
01DE4:  BSF    19.7
01DE6:  BCF    FF2.7
01DE8:  MOVFF  FE8,633
01DEC:  MOVFF  5FC,632
01DF0:  MOVFF  5FB,631
01DF4:  MOVFF  5FA,630
01DF8:  MOVLW  A0
01DFA:  MOVLB  6
01DFC:  MOVWF  x34
01DFE:  MOVLB  0
01E00:  RCALL  1802
01E02:  BTFSC  19.7
01E04:  BSF    FF2.7
....................             } 
01E06:  BRA    1E24
....................             // was an expected endstop, proceed as usual 
....................             else 
....................             { 
....................                global_valve_position = VLV_POSITION_CLOSED; 
01E08:  CLRF   xC2
01E0A:  CLRF   xC1
01E0C:  CLRF   19
01E0E:  BTFSC  FF2.7
01E10:  BSF    19.7
01E12:  BCF    FF2.7
....................                PUSH_PRIORITY_QUEUE_ISR_MACRO(SEND_UNSOLICITED_FULL_REPORT);  
01E14:  MOVLW  A5
01E16:  MOVLB  6
01E18:  MOVWF  x2C
01E1A:  MOVLB  0
01E1C:  CALL   082A
01E20:  BTFSC  19.7
01E22:  BSF    FF2.7
....................             } 
....................          } 
....................           
....................          // added to accomodate the move valve to set point at boot 
.................... #IFDEF OPEN_VALVE_TO_SETPT_AT_BOOT 
01E24:  BRA    1F2C
01E26:  MOVLB  5
....................          else if ((IS_VLV_CLOSING) && (global_system_state == SYSTEM_INIT)) 
01E28:  DECFSZ F8D,W
01E2A:  BRA    1E8A
01E2C:  MOVF   x05,F
01E2E:  BNZ   1E8A
....................          { 
....................             global_system_state = SYSTEM_RUN; 
01E30:  MOVLW  02
01E32:  MOVWF  x05
....................             global_valve_position = VLV_POSITION_CLOSED; 
01E34:  MOVLB  0
01E36:  CLRF   xC2
01E38:  CLRF   xC1
....................             push_time_queue_ISR(global_rtc_time + 3, MOVE_VALVE_AT_BOOT); 
01E3A:  MOVLW  03
01E3C:  ADDWF  x85,W
01E3E:  MOVLB  5
01E40:  MOVWF  xFA
01E42:  MOVLW  00
01E44:  MOVLB  0
01E46:  ADDWFC x86,W
01E48:  MOVLB  5
01E4A:  MOVWF  xFB
01E4C:  MOVLW  00
01E4E:  MOVLB  0
01E50:  ADDWFC x87,W
01E52:  MOVLB  5
01E54:  MOVWF  xFC
01E56:  MOVLW  00
01E58:  MOVLB  0
01E5A:  ADDWFC x88,W
01E5C:  MOVLB  5
01E5E:  MOVWF  xFD
01E60:  CLRF   19
01E62:  BTFSC  FF2.7
01E64:  BSF    19.7
01E66:  BCF    FF2.7
01E68:  MOVFF  FE8,633
01E6C:  MOVFF  5FC,632
01E70:  MOVFF  5FB,631
01E74:  MOVFF  5FA,630
01E78:  MOVLW  41
01E7A:  MOVLB  6
01E7C:  MOVWF  x34
01E7E:  MOVLB  0
01E80:  RCALL  1802
01E82:  BTFSC  19.7
01E84:  BSF    FF2.7
....................          } 
.................... #ENDIF 
01E86:  BRA    1F2C
01E88:  MOVLB  5
....................          // valve is opening 
....................          else if (IS_VLV_OPENING) 
01E8A:  MOVF   F8D,W
01E8C:  SUBLW  02
01E8E:  BNZ   1F2E
....................          { 
....................             // error checking if valve movement was longer or shorter than expected 
....................             // We accomplish this by seeing if the valve hit an endstop while it was 
....................             //    outside the VLV_NEAR_CLOSED_RANGE_MAX/VLV_NEAR_OPENED_RANGE_MAX 
....................             if (global_valve_position < VLV_NEAR_OPENED_RANGE_MAX) 
01E90:  MOVLB  0
01E92:  MOVF   xC2,W
01E94:  MOVLB  5
01E96:  SUBWF  x09,W
01E98:  BNC   1F0C
01E9A:  BNZ   1EAC
01E9C:  MOVF   x08,W
01E9E:  MOVLB  0
01EA0:  SUBWF  xC1,W
01EA2:  BTFSS  FD8.0
01EA4:  BRA    1EAA
01EA6:  MOVLB  5
01EA8:  BRA    1F0C
01EAA:  MOVLB  5
....................             { 
....................                // put system into run mode (in case it's in valve cal routine) 
....................                global_system_state = SYSTEM_RUN; 
01EAC:  MOVLW  02
01EAE:  MOVWF  x05
....................                // set valve to unknown position (uncalibrated) 
....................                global_valve_position = VLV_POSITION_UNKNOWN; 
01EB0:  MOVLB  0
01EB2:  SETF   xC2
01EB4:  SETF   xC1
....................                // set the error bitfield and send an error 
....................                global_error_message_bitfield |= ERR_MSG_VLV_MOVE_FAIL; 
01EB6:  MOVLB  4
01EB8:  BSF    xF9.2
....................                push_time_queue_ISR(global_rtc_time + 1, MSG_MOTE_ERROR_MSG); 
01EBA:  MOVLW  01
01EBC:  MOVLB  0
01EBE:  ADDWF  x85,W
01EC0:  MOVLB  5
01EC2:  MOVWF  xFA
01EC4:  MOVLW  00
01EC6:  MOVLB  0
01EC8:  ADDWFC x86,W
01ECA:  MOVLB  5
01ECC:  MOVWF  xFB
01ECE:  MOVLW  00
01ED0:  MOVLB  0
01ED2:  ADDWFC x87,W
01ED4:  MOVLB  5
01ED6:  MOVWF  xFC
01ED8:  MOVLW  00
01EDA:  MOVLB  0
01EDC:  ADDWFC x88,W
01EDE:  MOVLB  5
01EE0:  MOVWF  xFD
01EE2:  CLRF   19
01EE4:  BTFSC  FF2.7
01EE6:  BSF    19.7
01EE8:  BCF    FF2.7
01EEA:  MOVFF  FE8,633
01EEE:  MOVFF  5FC,632
01EF2:  MOVFF  5FB,631
01EF6:  MOVFF  5FA,630
01EFA:  MOVLW  A0
01EFC:  MOVLB  6
01EFE:  MOVWF  x34
01F00:  MOVLB  0
01F02:  RCALL  1802
01F04:  BTFSC  19.7
01F06:  BSF    FF2.7
....................             } 
01F08:  BRA    1F2C
01F0A:  MOVLB  5
....................             // was an expected endstop, proceed as usual 
....................             else 
....................             { 
....................                global_valve_position = VLV_POSITION_OPENED;  
01F0C:  MOVLW  80
01F0E:  MOVLB  0
01F10:  MOVWF  xC2
01F12:  CLRF   xC1
01F14:  CLRF   19
01F16:  BTFSC  FF2.7
01F18:  BSF    19.7
01F1A:  BCF    FF2.7
....................                PUSH_PRIORITY_QUEUE_ISR_MACRO(SEND_UNSOLICITED_FULL_REPORT);  
01F1C:  MOVLW  A5
01F1E:  MOVLB  6
01F20:  MOVWF  x2C
01F22:  MOVLB  0
01F24:  CALL   082A
01F28:  BTFSC  19.7
01F2A:  BSF    FF2.7
01F2C:  MOVLB  5
....................             } 
....................          } 
....................       } 
....................        
....................       // Update fixture setting 
....................  
....................                   
....................       // Turn off comparator and dac 
....................       setup_DAC(DAC_OFF); 
01F2E:  MOVLB  F
01F30:  CLRF   x41
....................       setup_comparator(NC_NC_NC_NC); 
01F32:  CLRF   F77
01F34:  MOVLW  04
01F36:  MOVWF  F78
01F38:  MOVWF  F79
....................        
....................       // Turn off CCP3 interrupt      
....................       disable_interrupts(INT_CCP3); 
01F3A:  BCF    F7A.0
....................        
....................       // reset valve movements counter 
....................       global_valve_movements_since_endstop = 0; 
01F3C:  MOVLB  0
01F3E:  CLRF   xCF
....................        
....................       // turn off the motor 
....................       mV_COASTm; 
01F40:  CLRF   F8D
....................  
....................       // put clock speed down to 250khz again 
....................       //fosc_250k_ISR();    
....................        
....................       // turn off comparator interrupt so it isn't triggered on stop 
....................       clear_interrupt(INT_COMP);      
01F42:  BCF    FA1.6
....................    } 
.................... } 
....................  
....................  
.................... /* 
.................... #INT_TIMER0 
.................... void tmr0_ISR(void) 
.................... { 
.................... // may not be enabled during normal operation. 
.................... // Need only for IDLING situation (long winters...) wherein every 35minutes 
.................... //  we wake up and check the battery and set a flag if there is a very low 
.................... //  battery, which then tells the idle_sleep routine to go into deep_sleep. 
.................... // this needs work. 
.................... // 
.................... // We can know if we were idling by simply checking the OSCCON for 31250Hz 
.................... //  operation, which occurs ONLY during the long winter.... 
.................... // 
....................    if (cur_state == DEV_IDLE) 
....................    { 
....................    uint8_t  nn; 
....................    // this interrupt occurred during the sleep_idle state 
....................    // check the battery, if it is so low that we need to turn off the radio, 
....................    //  then be sure to set a flag to make that happen... 
....................    // Deep_Sleep may be the result 
....................       output_high(AUX_PWR); 
....................       ADON = TRUE;         // turn on ADC 
....................       delay_cycles(50);    // insurance 
....................       set_adc_channel(V_MEAS_REF);   
....................       VfvrAD = 0;   
....................       for (nn=0; nn<4; nn++) 
....................          VfvrAD += read_adc(); 
....................       ADON = FALSE; 
....................       output_low(AUX_PWR); 
....................       if (VfvrAD > FVR_NODUST) 
....................          fl_batNODUST = TRUE; 
....................    } 
....................    else 
....................    { 
....................    // any other TIMER0 activities we may want 
....................    } 
.................... } 
.................... */ 
....................  
....................                                                           
01F44:  BCF    FA1.6
01F46:  GOTO   00A0
.................... #INT_CCP3 HIGH 
.................... void ccp3_ISR(void) 
.................... { 
.................... // For use in timing valve motion 
.................... //    -Updates realtime position of valve 
.................... //    -Keeps track of valve movement time (in 1024th of full scale) 
.................... //    -Turns off valve movement when position is reached 
.................... //    -updates DAC level according to position and direction of movement 
.................... // May be used for other functionality if valve is not moving 
.................... // TMR1 dedicated to CCP3 
....................     
....................    //set_timer1(TIMER1_VLV_MOVE_INIT + get_timer1()); 
....................    //temp16_frac = get_timer1();             
....................           
....................    // If the valve is in motion (not in the braked or coast mode)  
....................    if (IS_VLV_CLOSING || IS_VLV_OPENING) 
*
0208E:  DECFSZ F8D,W
02090:  BRA    2094
02092:  BRA    209C
02094:  MOVF   F8D,W
02096:  SUBLW  02
02098:  BTFSS  FD8.2
0209A:  BRA    2210
....................    { 
....................       // add to the time in motion variable 
....................       global_valve_time_in_motion_1024ths++; 
0209C:  INCF   xC9,F
0209E:  BTFSC  FD8.2
020A0:  INCF   xCA,F
....................        
....................       //check for valve movement timeout 
....................       if (global_valve_time_in_motion_1024ths > VALVE_TIMEOUT) 
020A2:  MOVF   xCA,W
020A4:  SUBLW  04
020A6:  BC    2108
020A8:  XORLW  FF
020AA:  BNZ   20B2
020AC:  MOVF   xC9,W
020AE:  SUBLW  DC
020B0:  BC    2108
....................       { 
....................          // turn off comparator interrupt so it isn't triggered on stop 
....................          disable_interrupts(INT_COMP); 
020B2:  BCF    FA0.6
....................                 
....................          // turn off valve movement 
....................          mV_COASTm; 
020B4:  CLRF   F8D
....................           
....................          // Error handling for valve motion timeout 
....................          // put system into run mode (in case it's in valve cal routine) 
....................          global_system_state = SYSTEM_RUN; 
020B6:  MOVLW  02
020B8:  MOVLB  5
020BA:  MOVWF  x05
....................          // set valve to unknown position (uncalibrated) 
....................          global_valve_position = VLV_POSITION_UNKNOWN; 
020BC:  MOVLB  0
020BE:  SETF   xC2
020C0:  SETF   xC1
....................          // set the error bitfield and send an error 
....................          global_error_message_bitfield |= ERR_MSG_VLV_MOVE_FAIL; 
020C2:  MOVLB  4
020C4:  BSF    xF9.2
....................          push_time_queue_ISR(global_rtc_time + 1, MSG_MOTE_ERROR_MSG); 
020C6:  MOVLW  01
020C8:  MOVLB  0
020CA:  ADDWF  x85,W
020CC:  MOVLB  6
020CE:  MOVWF  x2C
020D0:  MOVLW  00
020D2:  MOVLB  0
020D4:  ADDWFC x86,W
020D6:  MOVLB  6
020D8:  MOVWF  x2D
020DA:  MOVLW  00
020DC:  MOVLB  0
020DE:  ADDWFC x87,W
020E0:  MOVLB  6
020E2:  MOVWF  x2E
020E4:  MOVLW  00
020E6:  MOVLB  0
020E8:  ADDWFC x88,W
020EA:  MOVLB  6
020EC:  MOVWF  x2F
020EE:  MOVWF  x33
020F0:  MOVFF  62E,632
020F4:  MOVFF  62D,631
020F8:  MOVFF  62C,630
020FC:  MOVLW  A0
020FE:  MOVWF  x34
02100:  MOVLB  0
02102:  CALL   1802
....................       } 
02106:  BRA    2204
....................        
....................       else if (IS_VLV_CLOSING) 
02108:  DECFSZ F8D,W
0210A:  BRA    215C
....................       {   
....................          //set_timer1(TIMER1_VLV_MOVE_INIT); 
....................          // 0x20 is equal to one 'millispan' 
....................          if (global_valve_position >= 0x20) 
0210C:  MOVF   xC2,F
0210E:  BNZ   2116
02110:  MOVF   xC1,W
02112:  SUBLW  1F
02114:  BC    2120
....................          { 
....................             global_valve_position -= 0x20;     
02116:  MOVLW  20
02118:  SUBWF  xC1,F
0211A:  MOVLW  00
0211C:  SUBWFB xC2,F
....................          } 
0211E:  BRA    2124
....................          // valve is closed, unsigned int thing 
....................          else  
....................          { 
....................             global_valve_position = VLV_POSITION_CLOSED; 
02120:  CLRF   xC2
02122:  CLRF   xC1
....................          } 
....................           
....................          // if system is doing a valve recalibration, ignore valve set position 
....................          //    as it is storing the next valve position to move to 
....................          if (global_system_state == SYSTEM_RECAL_VLV_MOVES) 
02124:  MOVLB  5
02126:  MOVF   x05,W
02128:  SUBLW  16
0212A:  BNZ   212E
....................          { 
....................             break; 
....................          }                        
0212C:  BRA    2158
....................          // we have reached or exceeded the set value/target position and 
....................          //    we aren't trying to reach the endstop 
....................          else if ((global_valve_position <= global_valve_position_set_value)&&\ 
....................          (global_valve_position_set_value != VLV_POSITION_CLOSED)) 
0212E:  MOVLB  0
02130:  MOVF   xC2,W
02132:  SUBWF  xC4,W
02134:  BNC   2156
02136:  BNZ   213E
02138:  MOVF   xC1,W
0213A:  SUBWF  xC3,W
0213C:  BNC   2156
0213E:  MOVF   xC3,F
02140:  BNZ   2146
02142:  MOVF   xC4,F
02144:  BZ    2156
....................          { 
....................             // turn off comparator interrupt so it isn't triggered on stop 
....................             disable_interrupts(INT_COMP); 
02146:  BCF    FA0.6
....................              
....................             // turn off valve movement 
....................             mV_COASTm; 
02148:  CLRF   F8D
....................             // update user with message to manager 
....................             PUSH_PRIORITY_QUEUE_ISR_MACRO(SEND_UNSOLICITED_FULL_REPORT);    
0214A:  MOVLW  A5
0214C:  MOVLB  6
0214E:  MOVWF  x2C
02150:  MOVLB  0
02152:  CALL   082A
02156:  MOVLB  5
....................          } 
....................       } 
02158:  BRA    2206
0215A:  MOVLB  0
....................       else if (IS_VLV_OPENING) 
0215C:  MOVF   F8D,W
0215E:  SUBLW  02
02160:  BNZ   2204
....................       {                   
....................          //0x20 is equal to one 'millispan' 
....................          global_valve_position += 0x20;       
02162:  MOVLW  20
02164:  ADDWF  xC1,F
02166:  MOVLW  00
02168:  ADDWFC xC2,F
....................        
....................          if (global_valve_position > VLV_POSITION_OPENED) 
0216A:  MOVF   xC2,W
0216C:  SUBLW  7F
0216E:  BC    2180
02170:  XORLW  FF
02172:  BNZ   217A
02174:  MOVF   xC1,W
02176:  SUBLW  00
02178:  BC    2180
....................          { 
....................             global_valve_position = VLV_POSITION_OPENED;    
0217A:  MOVLW  80
0217C:  MOVWF  xC2
0217E:  CLRF   xC1
....................          } 
....................           
....................          // if system is doing a valve recalibration, ignore valve set position 
....................          //    as it is storing the next valve position to move to 
....................          if (global_system_state == SYSTEM_RECAL_VLV_MOVES) 
02180:  MOVLB  5
02182:  MOVF   x05,W
02184:  SUBLW  16
02186:  BNZ   218A
....................          { 
....................             break; 
....................          } 
02188:  BRA    2206
....................          // we have reached or exceeded the set value/target position and 
....................          //    we aren't trying to reach the endstop 
....................          else if ((global_valve_position >= global_valve_position_set_value)&&\ 
....................          (global_valve_position_set_value != VLV_POSITION_OPENED)) 
0218A:  MOVLB  0
0218C:  MOVF   xC4,W
0218E:  SUBWF  xC2,W
02190:  BNC   2204
02192:  BNZ   219A
02194:  MOVF   xC3,W
02196:  SUBWF  xC1,W
02198:  BNC   2204
0219A:  MOVF   xC3,F
0219C:  BNZ   21A4
0219E:  MOVF   xC4,W
021A0:  SUBLW  80
021A2:  BZ    2204
....................          { 
....................             // turn off comparator interrupt so it isn't triggered on stop 
....................             disable_interrupts(INT_COMP); 
021A4:  BCF    FA0.6
....................              
....................             // turn off valve movement 
....................             mV_COASTm; 
021A6:  CLRF   F8D
....................  
....................             if (global_system_state != SYSTEM_CAL_VLV_1) 
021A8:  MOVLB  5
021AA:  MOVF   x05,W
021AC:  SUBLW  10
021AE:  BZ    21BE
....................             { 
....................             // update user with message to manager 
....................             PUSH_PRIORITY_QUEUE_ISR_MACRO(SEND_UNSOLICITED_FULL_REPORT);    
021B0:  MOVLW  A5
021B2:  MOVLB  6
021B4:  MOVWF  x2C
021B6:  MOVLB  0
021B8:  CALL   082A
021BC:  MOVLB  5
....................             } 
....................              
....................             // Special case: if we are opening during CALIBRATE_VALVE_1 and 
....................             //    have reached our position, start the next calibration  
....................             //    sequence  
....................             if (global_system_state == SYSTEM_CAL_VLV_1) 
021BE:  MOVF   x05,W
021C0:  SUBLW  10
021C2:  BNZ   2206
....................             { 
....................                push_time_queue_ISR(global_rtc_time + 3, CALIBRATE_VALVE_2); 
021C4:  MOVLW  03
021C6:  MOVLB  0
021C8:  ADDWF  x85,W
021CA:  MOVLB  6
021CC:  MOVWF  x2C
021CE:  MOVLW  00
021D0:  MOVLB  0
021D2:  ADDWFC x86,W
021D4:  MOVLB  6
021D6:  MOVWF  x2D
021D8:  MOVLW  00
021DA:  MOVLB  0
021DC:  ADDWFC x87,W
021DE:  MOVLB  6
021E0:  MOVWF  x2E
021E2:  MOVLW  00
021E4:  MOVLB  0
021E6:  ADDWFC x88,W
021E8:  MOVLB  6
021EA:  MOVWF  x2F
021EC:  MOVWF  x33
021EE:  MOVFF  62E,632
021F2:  MOVFF  62D,631
021F6:  MOVFF  62C,630
021FA:  MOVLW  32
021FC:  MOVWF  x34
021FE:  MOVLB  0
02200:  CALL   1802
02204:  MOVLB  5
....................             } 
....................          } 
....................       }    
....................       // update the dac setting 
....................       set_comp_dac_level_isr(); 
02206:  MOVLB  0
02208:  BRA    1F54
....................        
....................       // update the fixture setting 
....................        
....................       // if the valve is not moving anymore 
....................       if (IS_VLV_COASTING) 
0220A:  MOVF   F8D,F
0220C:  BNZ   2210
....................       { 
....................          // switch back to lower clock, turn off CCP3 interrupt 
....................             //fosc_250k_ISR(); 
....................             //#use delay(clock=250KHZ) 
....................          disable_interrupts(INT_CCP3); 
0220E:  BCF    F7A.0
....................                                                                                                         
....................       } 
....................    } 
.................... } 
....................  
....................  
02210:  BCF    F7B.0
02212:  GOTO   015E
.................... #INT_CCP4 
.................... void ccp4_isr(void)                     
.................... { 
....................    // real time clock interrupts      
....................    // TMR3 dedicated to CCP4      
....................                                                                                       
....................    // increment global system uptime 
....................    global_rtc_time++; 
*
02E84:  MOVLW  01
02E86:  ADDWF  x85,F
02E88:  BTFSC  FD8.0
02E8A:  INCF   x86,F
02E8C:  BTFSC  FD8.2
02E8E:  INCF   x87,F
02E90:  BTFSC  FD8.2
02E92:  INCF   x88,F
....................    // increment utc time if mote is connected 
....................    if (global_dust_enabled) global_utc_time++; 
02E94:  BTFSS  xA7.6
02E96:  BRA    2EA8
02E98:  MOVLW  01
02E9A:  ADDWF  x89,F
02E9C:  BTFSC  FD8.0
02E9E:  INCF   x8A,F
02EA0:  BTFSC  FD8.2
02EA2:  INCF   x8B,F
02EA4:  BTFSC  FD8.2
02EA6:  INCF   x8C,F
....................  
....................    // check if a time queue item needs to be run 
....................    // make sure it isn't polling an empty queue 
....................    while((global_current_time_queue_location != 255) &&                       \ 
....................    (global_current_priority_queue_location != (MAX_PRIORITY_QUEUE_ITEMS - 1)) \ 
....................    && (global_time_queue[global_current_time_queue_location].time_to_execute  \ 
....................    <= global_rtc_time)) 
02EA8:  MOVLB  3
02EAA:  INCFSZ x9C,W
02EAC:  BRA    2EB0
02EAE:  BRA    2F2A
02EB0:  MOVF   x82,W
02EB2:  SUBLW  13
02EB4:  BZ    2F2A
02EB6:  MOVF   x9C,W
02EB8:  MULLW  05
02EBA:  MOVF   FF3,W
02EBC:  MOVLB  5
02EBE:  CLRF   xF9
02EC0:  MOVWF  xF8
02EC2:  MOVLW  83
02EC4:  ADDWF  xF8,W
02EC6:  MOVWF  FE9
02EC8:  MOVLW  03
02ECA:  ADDWFC xF9,W
02ECC:  MOVWF  FEA
02ECE:  MOVFF  FEF,5FA
02ED2:  MOVFF  FEC,5FB
02ED6:  MOVFF  FEC,5FC
02EDA:  MOVFF  FEC,5FD
02EDE:  MOVF   xFD,W
02EE0:  MOVLB  0
02EE2:  SUBWF  x88,W
02EE4:  BTFSC  FD8.0
02EE6:  BRA    2EEC
02EE8:  MOVLB  3
02EEA:  BRA    2F2A
02EEC:  BNZ   2F22
02EEE:  MOVLB  5
02EF0:  MOVF   xFC,W
02EF2:  MOVLB  0
02EF4:  SUBWF  x87,W
02EF6:  BTFSC  FD8.0
02EF8:  BRA    2EFE
02EFA:  MOVLB  3
02EFC:  BRA    2F2A
02EFE:  BNZ   2F22
02F00:  MOVLB  5
02F02:  MOVF   xFB,W
02F04:  MOVLB  0
02F06:  SUBWF  x86,W
02F08:  BTFSC  FD8.0
02F0A:  BRA    2F10
02F0C:  MOVLB  3
02F0E:  BRA    2F2A
02F10:  BNZ   2F22
02F12:  MOVLB  5
02F14:  MOVF   xFA,W
02F16:  MOVLB  0
02F18:  SUBWF  x85,W
02F1A:  BTFSC  FD8.0
02F1C:  BRA    2F22
02F1E:  MOVLB  3
02F20:  BRA    2F2A
....................    {                               
....................       // pop an item off the time queue and push it into the priority queue 
....................       pop_time_queue_ISR();                      
02F22:  GOTO   2216
02F26:  BRA    2EA8
02F28:  MOVLB  3
....................    }                         
....................     
....................    // check if a message queue item needs to be run 
....................    // make sure it isn't polling an empty queue 
....................    while((global_current_message_queue_location != 255) &&                      \ 
....................       (global_message_queue[global_current_message_queue_location].time_to_send \ 
....................       <= global_rtc_time))    
02F2A:  MOVLB  4
02F2C:  INCFSZ xF7,W
02F2E:  BRA    2F32
02F30:  BRA    2FAC
02F32:  MOVF   xF7,W
02F34:  MULLW  08
02F36:  MOVF   FF3,W
02F38:  MOVLB  5
02F3A:  CLRF   xF9
02F3C:  MOVWF  xF8
02F3E:  MOVLW  A7
02F40:  ADDWF  xF8,W
02F42:  MOVWF  FE9
02F44:  MOVLW  04
02F46:  ADDWFC xF9,W
02F48:  MOVWF  FEA
02F4A:  MOVFF  FEF,5FA
02F4E:  MOVFF  FEC,5FB
02F52:  MOVFF  FEC,5FC
02F56:  MOVFF  FEC,5FD
02F5A:  MOVF   xFD,W
02F5C:  MOVLB  0
02F5E:  SUBWF  x88,W
02F60:  BTFSC  FD8.0
02F62:  BRA    2F68
02F64:  MOVLB  4
02F66:  BRA    2FAC
02F68:  BNZ   2F9E
02F6A:  MOVLB  5
02F6C:  MOVF   xFC,W
02F6E:  MOVLB  0
02F70:  SUBWF  x87,W
02F72:  BTFSC  FD8.0
02F74:  BRA    2F7A
02F76:  MOVLB  4
02F78:  BRA    2FAC
02F7A:  BNZ   2F9E
02F7C:  MOVLB  5
02F7E:  MOVF   xFB,W
02F80:  MOVLB  0
02F82:  SUBWF  x86,W
02F84:  BTFSC  FD8.0
02F86:  BRA    2F8C
02F88:  MOVLB  4
02F8A:  BRA    2FAC
02F8C:  BNZ   2F9E
02F8E:  MOVLB  5
02F90:  MOVF   xFA,W
02F92:  MOVLB  0
02F94:  SUBWF  x85,W
02F96:  BTFSC  FD8.0
02F98:  BRA    2F9E
02F9A:  MOVLB  4
02F9C:  BRA    2FAC
....................    {                     
....................       // disable mote interrupt so payload_buf doesn't get overwritten 
....................       disable_interrupts(INT_EXT2_H2L);   
02F9E:  BCF    FF0.4
....................       // send message and requeue it at a later date if not ack'd 
....................       pop_message_queue_and_send_ISR(); 
02FA0:  BRA    28B0
....................       // re-enable mote interrupt                     
....................       enable_interrupts(INT_EXT2_H2L);     
02FA2:  BSF    FF0.4
02FA4:  BCF    FF1.4
02FA6:  MOVLB  3
02FA8:  BRA    2F2A
02FAA:  MOVLB  4
....................    }                                   
....................     
....................     
....................    // check if a sprinkler queue item needs to be run and make sure it isn't polling an empty queue        
....................    // Note: The queue contains things that are to be run, not the current item running.             
....................    while((global_current_sprinkler_queue_location != 255) &&                      \ 
....................       (global_sprinkler_queue[global_current_sprinkler_queue_location].start_time \ 
....................       <= global_utc_time)) 
02FAC:  INCFSZ x29,W
02FAE:  BRA    2FB2
02FB0:  BRA    3090
02FB2:  MOVF   x29,W
02FB4:  MULLW  0E
02FB6:  MOVF   FF3,W
02FB8:  MOVLB  5
02FBA:  CLRF   xF9
02FBC:  MOVWF  xF8
02FBE:  MOVLW  9D
02FC0:  ADDWF  xF8,W
02FC2:  MOVWF  FE9
02FC4:  MOVLW  03
02FC6:  ADDWFC xF9,W
02FC8:  MOVWF  FEA
02FCA:  MOVFF  FEF,5FA
02FCE:  MOVFF  FEC,5FB
02FD2:  MOVFF  FEC,5FC
02FD6:  MOVFF  FEC,5FD
02FDA:  MOVF   xFD,W
02FDC:  MOVLB  0
02FDE:  SUBWF  x8C,W
02FE0:  BTFSC  FD8.0
02FE2:  BRA    2FE8
02FE4:  MOVLB  4
02FE6:  BRA    3090
02FE8:  BNZ   301E
02FEA:  MOVLB  5
02FEC:  MOVF   xFC,W
02FEE:  MOVLB  0
02FF0:  SUBWF  x8B,W
02FF2:  BTFSC  FD8.0
02FF4:  BRA    2FFA
02FF6:  MOVLB  4
02FF8:  BRA    3090
02FFA:  BNZ   301E
02FFC:  MOVLB  5
02FFE:  MOVF   xFB,W
03000:  MOVLB  0
03002:  SUBWF  x8A,W
03004:  BTFSC  FD8.0
03006:  BRA    300C
03008:  MOVLB  4
0300A:  BRA    3090
0300C:  BNZ   301E
0300E:  MOVLB  5
03010:  MOVF   xFA,W
03012:  MOVLB  0
03014:  SUBWF  x89,W
03016:  BTFSC  FD8.0
03018:  BRA    301E
0301A:  MOVLB  4
0301C:  BRA    3090
....................    {   
....................       // if the system is in the SYSTEM_IDLE state, bump it into the SYSTEM_RUN state. 
....................       if (global_system_state == SYSTEM_IDLE) global_system_state = SYSTEM_RUN;       
0301E:  MOVLB  5
03020:  MOVF   x05,W
03022:  SUBLW  03
03024:  BNZ   302A
03026:  MOVLW  02
03028:  MOVWF  x05
....................                                    
....................       // if system is not in run state, do not stop the item.  Send an error  
....................       //    stating that the stop time is delayed 
....................       if (global_system_state != SYSTEM_RUN)                        
0302A:  MOVF   x05,W
0302C:  SUBLW  02
0302E:  BZ    3088
....................       {                       
....................          global_error_message_bitfield |= ERR_MSG_SPINKLER_CMD_DELAYED_INVALID_STATE; 
03030:  MOVLB  4
03032:  BSF    xF9.6
....................          push_time_queue_ISR(global_rtc_time + 1, MSG_MOTE_ERROR_MSG); 
03034:  MOVLW  01
03036:  MOVLB  0
03038:  ADDWF  x85,W
0303A:  MOVLB  5
0303C:  MOVWF  xF8
0303E:  MOVLW  00
03040:  MOVLB  0
03042:  ADDWFC x86,W
03044:  MOVLB  5
03046:  MOVWF  xF9
03048:  MOVLW  00
0304A:  MOVLB  0
0304C:  ADDWFC x87,W
0304E:  MOVLB  5
03050:  MOVWF  xFA
03052:  MOVLW  00
03054:  MOVLB  0
03056:  ADDWFC x88,W
03058:  MOVLB  5
0305A:  MOVWF  xFB
0305C:  CLRF   19
0305E:  BTFSC  FF2.7
03060:  BSF    19.7
03062:  BCF    FF2.7
03064:  MOVFF  FE8,633
03068:  MOVFF  5FA,632
0306C:  MOVFF  5F9,631
03070:  MOVFF  5F8,630
03074:  MOVLW  A0
03076:  MOVLB  6
03078:  MOVWF  x34
0307A:  MOVLB  0
0307C:  CALL   1802
03080:  BTFSC  19.7
03082:  BSF    FF2.7
....................       } 
03084:  BRA    308C
03086:  MOVLB  5
....................       else 
....................       { 
....................          // pop an item off the time queue and push it into the priority queue 
....................          pop_sprinkler_queue_ISR(); 
03088:  MOVLB  0
0308A:  BRA    2C3A
....................       } 
0308C:  MOVLB  4
0308E:  BRA    2FAC
....................    }            
....................                                                                  
....................    // check if a sprinkler queue item needs to be stopped 
....................    if (global_current_sprinkler_settings_end_time <= global_utc_time) 
03090:  MOVF   x2D,W
03092:  MOVLB  0
03094:  SUBWF  x8C,W
03096:  BNC   312A
03098:  BNZ   30BC
0309A:  MOVLB  4
0309C:  MOVF   x2C,W
0309E:  MOVLB  0
030A0:  SUBWF  x8B,W
030A2:  BNC   312A
030A4:  BNZ   30BC
030A6:  MOVLB  4
030A8:  MOVF   x2B,W
030AA:  MOVLB  0
030AC:  SUBWF  x8A,W
030AE:  BNC   312A
030B0:  BNZ   30BC
030B2:  MOVLB  4
030B4:  MOVF   x2A,W
030B6:  MOVLB  0
030B8:  SUBWF  x89,W
030BA:  BNC   312A
....................    {                         
....................       // if the system is in the SYSTEM_IDLE state, bump it into the SYSTEM_RUN state. 
....................       if (global_system_state == SYSTEM_IDLE) global_system_state = SYSTEM_RUN;   
030BC:  MOVLB  5
030BE:  MOVF   x05,W
030C0:  SUBLW  03
030C2:  BNZ   30C8
030C4:  MOVLW  02
030C6:  MOVWF  x05
....................                                                                                            
....................       // if system is not in run state, do not stop the item.  Send an error 
....................       //    stating that the stop time is delayed 
....................       if (global_system_state != SYSTEM_RUN) 
030C8:  MOVF   x05,W
030CA:  SUBLW  02
030CC:  BZ    3126
....................       { 
....................          global_error_message_bitfield |= ERR_MSG_SPINKLER_CMD_DELAYED_INVALID_STATE; 
030CE:  MOVLB  4
030D0:  BSF    xF9.6
....................          push_time_queue_ISR(global_rtc_time + 1, MSG_MOTE_ERROR_MSG); 
030D2:  MOVLW  01
030D4:  MOVLB  0
030D6:  ADDWF  x85,W
030D8:  MOVLB  5
030DA:  MOVWF  xF8
030DC:  MOVLW  00
030DE:  MOVLB  0
030E0:  ADDWFC x86,W
030E2:  MOVLB  5
030E4:  MOVWF  xF9
030E6:  MOVLW  00
030E8:  MOVLB  0
030EA:  ADDWFC x87,W
030EC:  MOVLB  5
030EE:  MOVWF  xFA
030F0:  MOVLW  00
030F2:  MOVLB  0
030F4:  ADDWFC x88,W
030F6:  MOVLB  5
030F8:  MOVWF  xFB
030FA:  CLRF   19
030FC:  BTFSC  FF2.7
030FE:  BSF    19.7
03100:  BCF    FF2.7
03102:  MOVFF  FE8,633
03106:  MOVFF  5FA,632
0310A:  MOVFF  5F9,631
0310E:  MOVFF  5F8,630
03112:  MOVLW  A0
03114:  MOVLB  6
03116:  MOVWF  x34
03118:  MOVLB  0
0311A:  CALL   1802
0311E:  BTFSC  19.7
03120:  BSF    FF2.7
....................       }              
03122:  BRA    312A
03124:  MOVLB  5
....................                                                     
....................       /*  
....................       // if you're stopping the current item and there are no more in the queue, turn off the control 
....................       //    loop.                             
....................       else if (global_current_sprinkler_queue_location == 255) 
....................       {   
....................          global_control_loop_mechanism = NO_SPRINKLER_CONTROL; 
....................       }        
....................       */                                          
....................             
....................       else 
....................       {                   
....................          // stop the current sprinkler setting 
....................          stop_current_spinkler_setting_ISR(); 
03126:  MOVLB  0
03128:  BRA    2E48
....................       }              
....................    } 
....................      
....................      
....................      
....................     
....................    // check to see if system should enter SYSTEM_IDLE (low-power) state 
....................    // 
....................    // First condition for SYSTEM_IDLE: 
....................    //    system already in SYSTEM_RUN    
....................    //    Closed valve (or unknown)        
....................    //    no valve movement 
....................    //    rpm = 0 
....................     
....................    // JACK modified E313 
....................    /* 
....................    if (((global_valve_position == VLV_POSITION_CLOSED) ||                                              \      
....................       (global_valve_position == VLV_POSITION_UNKNOWN)) && (IS_VLV_COASTING) &&                         \ 
....................       ((global_rtc_time - global_last_rpm_value_time) > RPM_TIMEOUT)) 
....................    */ 
....................    if (global_valve_position == VLV_POSITION_CLOSED) 
0312A:  MOVF   xC1,F
0312C:  BNZ   3140
0312E:  MOVF   xC2,F
03130:  BNZ   3140
....................    {                                   
....................       // change processor speed?      
....................       // change state to idle        
....................        if (global_system_state == SYSTEM_RUN)  
03132:  MOVLB  5
03134:  MOVF   x05,W
03136:  SUBLW  02
03138:  BNZ   313E
....................        { 
....................          global_system_state = SYSTEM_IDLE; 
0313A:  MOVLW  03
0313C:  MOVWF  x05
....................          //fosc_31250_ISR();  
....................        } 
....................    }  
0313E:  BRA    314C
....................     
....................    // JG thinks that going into SYSTEM_IDLE should also be triggered when 
....................    // water supply is turned off.  THINK ABOUT THIS... must discuss with BL 
....................     
....................    /* 
....................    // Second condition for SYSTEM_IDLE: 
....................    //    system already in SYSTEM_RUN    
....................    //    global_control_loop_mechanism is in either NO_RPM_CONTROL (test command) or NO_SPRINKLER_CONTROL        
....................    //    no valve movement         
....................    //    brake, charge, and mppc values are at their set points 
....................    else if (((global_control_loop_mechanism == NO_RPM_CONTROL)||                                      \ 
....................       (global_control_loop_mechanism == NO_SPRINKLER_CONTROL)) && (IS_VLV_COASTING) &&                \ 
....................       (global_brake_duty == global_brake_duty_set_value) &&                                           \ 
....................       (global_charge_duty == global_charge_duty_set_value) &&                                         \ 
....................       (global_mppc_value == global_mppc_set_value)) 
....................    {                                               
....................       // change processor speed?  
....................       // change state to idle 
....................       if (global_system_state == SYSTEM_RUN)    
....................       { 
....................          global_system_state = SYSTEM_IDLE; 
....................          //fosc_31250_ISR();  
....................       }                
....................    } 
....................    */ 
....................     
....................    // if above conditions are not met and system is in idle mode, put it into run mode 
....................    else if (global_system_state == SYSTEM_IDLE)          
03140:  MOVLB  5
03142:  MOVF   x05,W
03144:  SUBLW  03
03146:  BNZ   314C
....................    {                                  
....................       // change processor speed?    
....................       // change state to run state       
....................        global_system_state = SYSTEM_RUN;  
03148:  MOVLW  02
0314A:  MOVWF  x05
0314C:  CLRF   19
0314E:  BTFSC  FF2.7
03150:  BSF    19.7
03152:  BCF    FF2.7
....................        //fosc_250k_ISR();  
....................    }                            
....................                                                           
....................      
....................    // update lcd every second                                 
....................    PUSH_PRIORITY_QUEUE_ISR_MACRO(LCD_UPDATE);    
03154:  MOVLW  D4
03156:  MOVLB  6
03158:  MOVWF  x2C
0315A:  MOVLB  0
0315C:  CALL   082A
03160:  BTFSC  19.7
03162:  BSF    FF2.7
....................  
....................    // periodic system checkups (all in one to minimize divides) 
....................    // - mote state (reacts as necessary)    
....................    // - battery state (turns off/on charging, sends warnings, etc.) 
....................    // - mote temp (logs data, sends warnings, etc.) 
....................    // - mote utc time (updates utc time if valid) 
....................    if ((global_rtc_time % PERIODIC_CHECKS_TIME) == 0)      
03164:  MOVF   x85,W
03166:  ANDLW  1F
03168:  MOVLB  5
0316A:  MOVWF  xF8
0316C:  CLRF   xF9
0316E:  CLRF   xFA
03170:  CLRF   xFB
03172:  MOVF   xF8,F
03174:  BNZ   31E4
03176:  MOVF   xF9,F
03178:  BNZ   31E4
0317A:  MOVF   xFA,F
0317C:  BNZ   31E4
0317E:  MOVF   xFB,F
03180:  BNZ   31E4
03182:  CLRF   19
03184:  BTFSC  FF2.7
03186:  BSF    19.7
03188:  BCF    FF2.7
....................    {                                                  
....................       PUSH_PRIORITY_QUEUE_ISR_MACRO(CHECK_MOTE_STATE);  
0318A:  MOVLW  B4
0318C:  MOVLB  6
0318E:  MOVWF  x2C
03190:  MOVLB  0
03192:  CALL   082A
03196:  BTFSC  19.7
03198:  BSF    FF2.7
0319A:  CLRF   19
0319C:  BTFSC  FF2.7
0319E:  BSF    19.7
031A0:  BCF    FF2.7
....................       PUSH_PRIORITY_QUEUE_ISR_MACRO(CHECK_BATTERY_STATE);    
031A2:  MOVLW  A1
031A4:  MOVLB  6
031A6:  MOVWF  x2C
031A8:  MOVLB  0
031AA:  CALL   082A
031AE:  BTFSC  19.7
031B0:  BSF    FF2.7
031B2:  CLRF   19
031B4:  BTFSC  FF2.7
031B6:  BSF    19.7
031B8:  BCF    FF2.7
....................       PUSH_PRIORITY_QUEUE_ISR_MACRO(CHECK_MOTE_TEMP); 
031BA:  MOVLW  A2
031BC:  MOVLB  6
031BE:  MOVWF  x2C
031C0:  MOVLB  0
031C2:  CALL   082A
031C6:  BTFSC  19.7
031C8:  BSF    FF2.7
031CA:  CLRF   19
031CC:  BTFSC  FF2.7
031CE:  BSF    19.7
031D0:  BCF    FF2.7
....................       PUSH_PRIORITY_QUEUE_ISR_MACRO(UPDATE_MOTE_TIME); 
031D2:  MOVLW  A3
031D4:  MOVLB  6
031D6:  MOVWF  x2C
031D8:  MOVLB  0
031DA:  CALL   082A
031DE:  BTFSC  19.7
031E0:  BSF    FF2.7
031E2:  MOVLB  5
....................    }                                                                                                                           
.................... } 
....................  
031E4:  BCF    F7B.1
031E6:  MOVLB  0
031E8:  GOTO   00A0
.................... #INT_CCP5 FAST 
.................... void CCP5_ISR(void) 
.................... { 
.................... // GEN_RPM event capture for determining speed of rotation 
.................... // We need the CCP5 interrupt routine to be very fast because  
.................... //  the sprinkler can be spinning fast enough to generate 500 pulses per sec! 
.................... // With a 250KHz system clock, 2ms may be trouble with the full normal interrupt 
.................... //  overhead.... 
.................... // TMR5 dedicated to CCP5 
....................     
....................    static uint16_t ccp5_value = 0, ccp5_value_prev = 0; 
....................     
....................    // save previous sample  
....................    ccp5_value_prev = ccp5_value; 
031EC:  MOVFF  545,547
031F0:  MOVFF  544,546
....................     
....................    // get current sample      
....................    ccp5_value = CCP_5;          
031F4:  MOVFF  F56,545
031F8:  MOVFF  F55,544
....................                                    
....................    // disable INT_CCP4 to ensure safe grabbing of global_rtc_time                        
....................    disable_interrupts(INT_CCP4);              
031FC:  BCF    F7A.1
....................    // check if a current period measurement is even valid 
....................    if ((global_rtc_time - global_last_rpm_value_time) > RPM_TIMEOUT)   
031FE:  MOVF   xAE,W
03200:  SUBWF  x85,W
03202:  MOVLB  6
03204:  MOVWF  x2C
03206:  MOVLB  0
03208:  MOVF   xAF,W
0320A:  SUBWFB x86,W
0320C:  MOVLB  6
0320E:  MOVWF  x2D
03210:  MOVLB  0
03212:  MOVF   xB0,W
03214:  SUBWFB x87,W
03216:  MOVLB  6
03218:  MOVWF  x2E
0321A:  MOVLB  0
0321C:  MOVF   xB1,W
0321E:  SUBWFB x88,W
03220:  MOVLB  6
03222:  MOVWF  x2F
03224:  MOVF   x2F,F
03226:  BNZ   3248
03228:  MOVF   x2E,F
0322A:  BNZ   3248
0322C:  MOVLB  5
0322E:  MOVF   x22,W
03230:  MOVLB  6
03232:  SUBWF  x2D,W
03234:  BNC   325A
03236:  BNZ   3248
03238:  MOVF   x2C,W
0323A:  MOVLB  5
0323C:  SUBWF  x21,W
0323E:  BTFSS  FD8.0
03240:  BRA    3246
03242:  MOVLB  6
03244:  BRA    325A
03246:  MOVLB  6
....................    { 
....................       // save the last time a measurement was take to figure out if system is spinning outside of this routine.     
....................       global_last_rpm_value_time = global_rtc_time;      
03248:  MOVFF  88,B1
0324C:  MOVFF  87,B0
03250:  MOVFF  86,AF
03254:  MOVFF  85,AE
....................       break;                                          
....................    }                              
03258:  BRA    3270
....................    else            
....................    {                                                                
....................       // calc current difference/global period     
....................       global_current_period = ccp5_value - ccp5_value_prev;       
0325A:  MOVLB  5
0325C:  MOVF   x46,W
0325E:  SUBWF  x44,W
03260:  MOVLB  0
03262:  MOVWF  xA8
03264:  MOVLB  5
03266:  MOVF   x47,W
03268:  SUBWFB x45,W
0326A:  MOVLB  0
0326C:  MOVWF  xA9
0326E:  MOVLB  6
....................    }                                           
....................    // save the last time a measurement was take to figure out if system is spinning outside of this routine.     
....................    global_last_rpm_value_time = global_rtc_time;   
03270:  MOVFF  88,B1
03274:  MOVFF  87,B0
03278:  MOVFF  86,AF
0327C:  MOVFF  85,AE
....................    // re-enable INT_CCP4 after grabbing global rtc time        
....................    enable_interrupts(INT_CCP4);  
03280:  BSF    F7A.1
03282:  BCF    F7B.2
03284:  RETFIE 1
.................... } 
....................                                     

Configuration Fuses:
   Word  1: 8200   HSH NOPLLEN PRIMARY_SW NOFCMEN IESO
   Word  2: 2218   PUT NOBROWNOUT BORV19 WDT_SW WDT256
   Word  3: A800   CCP2B3 NOPBADEN CCP3E0 HFOFST TIMER3B5 CCP2D2 MCLR
   Word  4: 0081   STVREN NOLVP NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
