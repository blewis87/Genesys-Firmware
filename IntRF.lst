CCS PCH C Compiler, Version 5.067, 34367               01-Feb-17 11:10

               Filename:   C:\_PROJ\Jain Irrigation\2017 reset\Firmware\2017-01-31 - E311\IntRF.lst

               ROM used:   42132 bytes (64%)
                           Largest free fragment is 23400
               RAM used:   1355 (35%) at main() level
                           1479 (38%) worst case
               Stack used: 10 locations (5 in main + 5 for interrupts)
               Stack size: 31

*
00000:  GOTO   95E2
*
00008:  GOTO   00EE
0000C:  NOP   
0000E:  NOP   
00010:  NOP   
00012:  NOP   
00014:  NOP   
00016:  NOP   
00018:  MOVWF  04
0001A:  MOVFF  FD8,05
0001E:  MOVFF  FE0,06
00022:  MOVLB  0
00024:  MOVFF  FE9,0C
00028:  MOVFF  FEA,07
0002C:  MOVFF  FE1,08
00030:  MOVFF  FE2,09
00034:  MOVFF  FD9,0A
00038:  MOVFF  FDA,0B
0003C:  MOVFF  FF3,12
00040:  MOVFF  FF4,13
00044:  MOVFF  FFA,14
00048:  MOVFF  FF5,15
0004C:  MOVFF  FF6,16
00050:  MOVFF  FF7,17
00054:  MOVFF  00,0E
00058:  MOVFF  01,0F
0005C:  MOVFF  02,10
00060:  MOVFF  03,11
00064:  BTFSS  FA0.6
00066:  GOTO   0070
0006A:  BTFSC  FA1.6
0006C:  GOTO   198C
00070:  BTFSS  FF0.4
00072:  GOTO   007C
00076:  BTFSC  FF0.1
00078:  GOTO   16C6
0007C:  BTFSS  F7A.1
0007E:  GOTO   0088
00082:  BTFSC  F7B.1
00084:  GOTO   2C74
00088:  BTFSS  FA0.3
0008A:  GOTO   0094
0008E:  BTFSC  FA1.3
00090:  GOTO   0882
00094:  BTFSS  FF2.3
00096:  GOTO   00A0
0009A:  BTFSC  FF2.0
0009C:  GOTO   07A8
000A0:  MOVFF  0E,00
000A4:  MOVFF  0F,01
000A8:  MOVFF  10,02
000AC:  MOVFF  11,03
000B0:  MOVFF  0C,FE9
000B4:  MOVFF  07,FEA
000B8:  BSF    07.7
000BA:  MOVFF  08,FE1
000BE:  MOVFF  09,FE2
000C2:  MOVFF  0A,FD9
000C6:  MOVFF  0B,FDA
000CA:  MOVFF  12,FF3
000CE:  MOVFF  13,FF4
000D2:  MOVFF  14,FFA
000D6:  MOVFF  15,FF5
000DA:  MOVFF  16,FF6
000DE:  MOVFF  17,FF7
000E2:  MOVF   04,W
000E4:  MOVFF  06,FE0
000E8:  MOVFF  05,FD8
000EC:  RETFIE 0
000EE:  MOVWF  1A
000F0:  MOVFF  FD8,1B
000F4:  MOVFF  FE0,1C
000F8:  MOVLB  0
000FA:  MOVFF  FE9,22
000FE:  MOVFF  FEA,1D
00102:  MOVFF  FE1,1E
00106:  MOVFF  FE2,1F
0010A:  MOVFF  FD9,20
0010E:  MOVFF  FDA,21
00112:  MOVFF  FF3,28
00116:  MOVFF  FF4,29
0011A:  MOVFF  FFA,2A
0011E:  MOVFF  FF5,2B
00122:  MOVFF  FF6,2C
00126:  MOVFF  FF7,2D
0012A:  MOVFF  00,24
0012E:  MOVFF  01,25
00132:  MOVFF  02,26
00136:  MOVFF  03,27
0013A:  BTFSS  F7A.2
0013C:  GOTO   0146
00140:  BTFSC  F7B.2
00142:  GOTO   2F5C
00146:  BTFSS  F7A.0
00148:  GOTO   0152
0014C:  BTFSC  F7B.0
0014E:  GOTO   1ED2
00152:  BTFSS  FF2.4
00154:  GOTO   015E
00158:  BTFSC  FF2.1
0015A:  GOTO   07C8
0015E:  MOVFF  24,00
00162:  MOVFF  25,01
00166:  MOVFF  26,02
0016A:  MOVFF  27,03
0016E:  MOVFF  22,FE9
00172:  MOVFF  1D,FEA
00176:  BSF    1D.7
00178:  MOVFF  1E,FE1
0017C:  MOVFF  1F,FE2
00180:  MOVFF  20,FD9
00184:  MOVFF  21,FDA
00188:  MOVFF  28,FF3
0018C:  MOVFF  29,FF4
00190:  MOVFF  2A,FFA
00194:  MOVFF  2B,FF5
00198:  MOVFF  2C,FF6
0019C:  MOVFF  2D,FF7
001A0:  MOVF   1A,W
001A2:  MOVFF  1C,FE0
001A6:  MOVFF  1B,FD8
001AA:  RETFIE 0
.................... // required device includes/settings 
.................... #include <18F46K22.h> 
.................... //////////// Standard Header file for the PIC18F46K22 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F46K22 
001AC:  ADDLW  BA
001AE:  MOVWF  FF6
001B0:  MOVLW  01
001B2:  ADDWFC FF7,F
001B4:  TBLRD*+
001B6:  MOVF   FF5,W
001B8:  RETURN 0
001BA:  DATA 00,00
001BC:  DATA 89,11
001BE:  DATA 12,23
001C0:  DATA 9B,32
001C2:  DATA 24,46
001C4:  DATA AD,57
001C6:  DATA 36,65
001C8:  DATA BF,74
001CA:  DATA 48,8C
001CC:  DATA C1,9D
001CE:  DATA 5A,AF
001D0:  DATA D3,BE
001D2:  DATA 6C,CA
001D4:  DATA E5,DB
001D6:  DATA 7E,E9
001D8:  DATA F7,F8
001DA:  DATA 81,10
001DC:  DATA 08,01
001DE:  DATA 93,33
001E0:  DATA 1A,22
001E2:  DATA A5,56
001E4:  DATA 2C,47
001E6:  DATA B7,75
001E8:  DATA 3E,64
001EA:  DATA C9,9C
001EC:  DATA 40,8D
001EE:  DATA DB,BF
001F0:  DATA 52,AE
001F2:  DATA ED,DA
001F4:  DATA 64,CB
001F6:  DATA FF,F9
001F8:  DATA 76,E8
001FA:  DATA 02,21
001FC:  DATA 8B,30
001FE:  DATA 10,02
00200:  DATA 99,13
00202:  DATA 26,67
00204:  DATA AF,76
00206:  DATA 34,44
00208:  DATA BD,55
0020A:  DATA 4A,AD
0020C:  DATA C3,BC
0020E:  DATA 58,8E
00210:  DATA D1,9F
00212:  DATA 6E,EB
00214:  DATA E7,FA
00216:  DATA 7C,C8
00218:  DATA F5,D9
0021A:  DATA 83,31
0021C:  DATA 0A,20
0021E:  DATA 91,12
00220:  DATA 18,03
00222:  DATA A7,77
00224:  DATA 2E,66
00226:  DATA B5,54
00228:  DATA 3C,45
0022A:  DATA CB,BD
0022C:  DATA 42,AC
0022E:  DATA D9,9E
00230:  DATA 50,8F
00232:  DATA EF,FB
00234:  DATA 66,EA
00236:  DATA FD,D8
00238:  DATA 74,C9
0023A:  DATA 04,42
0023C:  DATA 8D,53
0023E:  DATA 16,61
00240:  DATA 9F,70
00242:  DATA 20,04
00244:  DATA A9,15
00246:  DATA 32,27
00248:  DATA BB,36
0024A:  DATA 4C,CE
0024C:  DATA C5,DF
0024E:  DATA 5E,ED
00250:  DATA D7,FC
00252:  DATA 68,88
00254:  DATA E1,99
00256:  DATA 7A,AB
00258:  DATA F3,BA
0025A:  DATA 85,52
0025C:  DATA 0C,43
0025E:  DATA 97,71
00260:  DATA 1E,60
00262:  DATA A1,14
00264:  DATA 28,05
00266:  DATA B3,37
00268:  DATA 3A,26
0026A:  DATA CD,DE
0026C:  DATA 44,CF
0026E:  DATA DF,FD
00270:  DATA 56,EC
00272:  DATA E9,98
00274:  DATA 60,89
00276:  DATA FB,BB
00278:  DATA 72,AA
0027A:  DATA 06,63
0027C:  DATA 8F,72
0027E:  DATA 14,40
00280:  DATA 9D,51
00282:  DATA 22,25
00284:  DATA AB,34
00286:  DATA 30,06
00288:  DATA B9,17
0028A:  DATA 4E,EF
0028C:  DATA C7,FE
0028E:  DATA 5C,CC
00290:  DATA D5,DD
00292:  DATA 6A,A9
00294:  DATA E3,B8
00296:  DATA 78,8A
00298:  DATA F1,9B
0029A:  DATA 87,73
0029C:  DATA 0E,62
0029E:  DATA 95,50
002A0:  DATA 1C,41
002A2:  DATA A3,35
002A4:  DATA 2A,24
002A6:  DATA B1,16
002A8:  DATA 38,07
002AA:  DATA CF,FF
002AC:  DATA 46,EE
002AE:  DATA DD,DC
002B0:  DATA 54,CD
002B2:  DATA EB,B9
002B4:  DATA 62,A8
002B6:  DATA F9,9A
002B8:  DATA 70,8B
002BA:  DATA 08,84
002BC:  DATA 81,95
002BE:  DATA 1A,A7
002C0:  DATA 93,B6
002C2:  DATA 2C,C2
002C4:  DATA A5,D3
002C6:  DATA 3E,E1
002C8:  DATA B7,F0
002CA:  DATA 40,08
002CC:  DATA C9,19
002CE:  DATA 52,2B
002D0:  DATA DB,3A
002D2:  DATA 64,4E
002D4:  DATA ED,5F
002D6:  DATA 76,6D
002D8:  DATA FF,7C
002DA:  DATA 89,94
002DC:  DATA 00,85
002DE:  DATA 9B,B7
002E0:  DATA 12,A6
002E2:  DATA AD,D2
002E4:  DATA 24,C3
002E6:  DATA BF,F1
002E8:  DATA 36,E0
002EA:  DATA C1,18
002EC:  DATA 48,09
002EE:  DATA D3,3B
002F0:  DATA 5A,2A
002F2:  DATA E5,5E
002F4:  DATA 6C,4F
002F6:  DATA F7,7D
002F8:  DATA 7E,6C
002FA:  DATA 0A,A5
002FC:  DATA 83,B4
002FE:  DATA 18,86
00300:  DATA 91,97
00302:  DATA 2E,E3
00304:  DATA A7,F2
00306:  DATA 3C,C0
00308:  DATA B5,D1
0030A:  DATA 42,29
0030C:  DATA CB,38
0030E:  DATA 50,0A
00310:  DATA D9,1B
00312:  DATA 66,6F
00314:  DATA EF,7E
00316:  DATA 74,4C
00318:  DATA FD,5D
0031A:  DATA 8B,B5
0031C:  DATA 02,A4
0031E:  DATA 99,96
00320:  DATA 10,87
00322:  DATA AF,F3
00324:  DATA 26,E2
00326:  DATA BD,D0
00328:  DATA 34,C1
0032A:  DATA C3,39
0032C:  DATA 4A,28
0032E:  DATA D1,1A
00330:  DATA 58,0B
00332:  DATA E7,7F
00334:  DATA 6E,6E
00336:  DATA F5,5C
00338:  DATA 7C,4D
0033A:  DATA 0C,C6
0033C:  DATA 85,D7
0033E:  DATA 1E,E5
00340:  DATA 97,F4
00342:  DATA 28,80
00344:  DATA A1,91
00346:  DATA 3A,A3
00348:  DATA B3,B2
0034A:  DATA 44,4A
0034C:  DATA CD,5B
0034E:  DATA 56,69
00350:  DATA DF,78
00352:  DATA 60,0C
00354:  DATA E9,1D
00356:  DATA 72,2F
00358:  DATA FB,3E
0035A:  DATA 8D,D6
0035C:  DATA 04,C7
0035E:  DATA 9F,F5
00360:  DATA 16,E4
00362:  DATA A9,90
00364:  DATA 20,81
00366:  DATA BB,B3
00368:  DATA 32,A2
0036A:  DATA C5,5A
0036C:  DATA 4C,4B
0036E:  DATA D7,79
00370:  DATA 5E,68
00372:  DATA E1,1C
00374:  DATA 68,0D
00376:  DATA F3,3F
00378:  DATA 7A,2E
0037A:  DATA 0E,E7
0037C:  DATA 87,F6
0037E:  DATA 1C,C4
00380:  DATA 95,D5
00382:  DATA 2A,A1
00384:  DATA A3,B0
00386:  DATA 38,82
00388:  DATA B1,93
0038A:  DATA 46,6B
0038C:  DATA CF,7A
0038E:  DATA 54,48
00390:  DATA DD,59
00392:  DATA 62,2D
00394:  DATA EB,3C
00396:  DATA 70,0E
00398:  DATA F9,1F
0039A:  DATA 8F,F7
0039C:  DATA 06,E6
0039E:  DATA 9D,D4
003A0:  DATA 14,C5
003A2:  DATA AB,B1
003A4:  DATA 22,A0
003A6:  DATA B9,92
003A8:  DATA 30,83
003AA:  DATA C7,7B
003AC:  DATA 4E,6A
003AE:  DATA D5,58
003B0:  DATA 5C,49
003B2:  DATA E3,3D
003B4:  DATA 6A,2C
003B6:  DATA F1,1E
003B8:  DATA 78,0F
003BA:  CLRF   FF7
003BC:  ADDLW  CA
003BE:  MOVWF  FF6
003C0:  MOVLW  03
003C2:  ADDWFC FF7,F
003C4:  TBLRD*+
003C6:  MOVF   FF5,W
003C8:  RETURN 0
003CA:  DATA 45,6E
003CC:  DATA 74,65
003CE:  DATA 72,20
003D0:  DATA 44,65
003D2:  DATA 65,70
003D4:  DATA 20,53
003D6:  DATA 6C,65
003D8:  DATA 65,70
003DA:  DATA 00,00
003DC:  CLRF   FF7
003DE:  ADDLW  EC
003E0:  MOVWF  FF6
003E2:  MOVLW  03
003E4:  ADDWFC FF7,F
003E6:  TBLRD*+
003E8:  MOVF   FF5,W
003EA:  RETURN 0
003EC:  DATA 52,65
003EE:  DATA 61,73
003F0:  DATA 6F,6E
003F2:  DATA 3A,20
003F4:  DATA 20,20
003F6:  DATA 20,20
003F8:  DATA 20,20
003FA:  DATA 20,20
003FC:  DATA 00,00
003FE:  CLRF   FF7
00400:  ADDLW  0E
00402:  MOVWF  FF6
00404:  MOVLW  04
00406:  ADDWFC FF7,F
00408:  TBLRD*+
0040A:  MOVF   FF5,W
0040C:  RETURN 0
0040E:  DATA 20,53
00410:  DATA 65,61
00412:  DATA 72,63
00414:  DATA 68,69
00416:  DATA 6E,67
00418:  DATA 20,3F
0041A:  DATA 3F,3F
0041C:  DATA 3F,20
0041E:  DATA 00,00
00420:  CLRF   FF7
00422:  ADDLW  30
00424:  MOVWF  FF6
00426:  MOVLW  04
00428:  ADDWFC FF7,F
0042A:  TBLRD*+
0042C:  MOVF   FF5,W
0042E:  RETURN 0
00430:  DATA 6E,6E
00432:  DATA 6E,6E
00434:  DATA 20,69
00436:  DATA 69,69
00438:  DATA 20,73
0043A:  DATA 73,73
0043C:  DATA 20,64
0043E:  DATA 64,64
00440:  DATA 00,00
00442:  CLRF   FF7
00444:  ADDLW  52
00446:  MOVWF  FF6
00448:  MOVLW  04
0044A:  ADDWFC FF7,F
0044C:  TBLRD*+
0044E:  MOVF   FF5,W
00450:  RETURN 0
00452:  DATA 53,57
00454:  DATA 31,20
00456:  DATA 74,6F
00458:  DATA 20,4A
0045A:  DATA 6F,69
0045C:  DATA 6E,20
0045E:  DATA 20,20
00460:  DATA 20,20
00462:  DATA 00,00
00464:  CLRF   FF7
00466:  ADDLW  74
00468:  MOVWF  FF6
0046A:  MOVLW  04
0046C:  ADDWFC FF7,F
0046E:  TBLRD*+
00470:  MOVF   FF5,W
00472:  RETURN 0
00474:  DATA 53,74
00476:  DATA 72,6F
00478:  DATA 6E,67
0047A:  DATA 65,73
0047C:  DATA 74,3A
0047E:  DATA 20,20
00480:  DATA 20,20
00482:  DATA 20,20
00484:  DATA 00,00
00486:  CLRF   FF7
00488:  ADDLW  96
0048A:  MOVWF  FF6
0048C:  MOVLW  04
0048E:  ADDWFC FF7,F
00490:  TBLRD*+
00492:  MOVF   FF5,W
00494:  RETURN 0
00496:  DATA 20,53
00498:  DATA 65,61
0049A:  DATA 72,63
0049C:  DATA 68,20
0049E:  DATA 53,75
004A0:  DATA 63,63
004A2:  DATA 65,73
004A4:  DATA 73,20
004A6:  DATA 00,00
004A8:  CLRF   FF7
004AA:  ADDLW  B8
004AC:  MOVWF  FF6
004AE:  MOVLW  04
004B0:  ADDWFC FF7,F
004B2:  TBLRD*+
004B4:  MOVF   FF5,W
004B6:  RETURN 0
004B8:  DATA 4E,65
004BA:  DATA 78,74
004BC:  DATA 20,6A
004BE:  DATA 6F,69
004C0:  DATA 6E,3A
004C2:  DATA 20,20
004C4:  DATA 20,20
004C6:  DATA 20,20
004C8:  DATA 00,00
004CA:  CLRF   FF7
004CC:  ADDLW  DA
004CE:  MOVWF  FF6
004D0:  MOVLW  04
004D2:  ADDWFC FF7,F
004D4:  TBLRD*+
004D6:  MOVF   FF5,W
004D8:  RETURN 0
004DA:  DATA 20,20
004DC:  DATA 20,20
004DE:  DATA 20,20
004E0:  DATA 20,20
004E2:  DATA 20,20
004E4:  DATA 20,20
004E6:  DATA 20,20
004E8:  DATA 20,20
004EA:  DATA 00,00
004EC:  CLRF   FF7
004EE:  ADDLW  FC
004F0:  MOVWF  FF6
004F2:  MOVLW  04
004F4:  ADDWFC FF7,F
004F6:  TBLRD*+
004F8:  MOVF   FF5,W
004FA:  RETURN 0
004FC:  DATA 56,62
004FE:  DATA 61,74
00500:  DATA 74,20
00502:  DATA 3D,20
00504:  DATA 20,2E
00506:  DATA 20,20
00508:  DATA 20,20
0050A:  DATA 20,56
0050C:  DATA 00,00
0050E:  CLRF   FF7
00510:  ADDLW  1E
00512:  MOVWF  FF6
00514:  MOVLW  05
00516:  ADDWFC FF7,F
00518:  TBLRD*+
0051A:  MOVF   FF5,W
0051C:  RETURN 0
0051E:  DATA 53,68
00520:  DATA 74,64
00522:  DATA 77,6E
00524:  DATA 20,43
00526:  DATA 61,75
00528:  DATA 73,65
0052A:  DATA 3A,20
0052C:  DATA 20,20
0052E:  DATA 00,00
00530:  CLRF   FF7
00532:  ADDLW  40
00534:  MOVWF  FF6
00536:  MOVLW  05
00538:  ADDWFC FF7,F
0053A:  TBLRD*+
0053C:  MOVF   FF5,W
0053E:  RETURN 0
00540:  DATA 76,20
00542:  DATA 20,20
00544:  DATA 20,20
00546:  DATA 20,72
00548:  DATA 20,20
0054A:  DATA 20,20
0054C:  DATA 74,20
0054E:  DATA 20,20
00550:  DATA 00,00
00552:  CLRF   FF7
00554:  ADDLW  62
00556:  MOVWF  FF6
00558:  MOVLW  05
0055A:  ADDWFC FF7,F
0055C:  TBLRD*+
0055E:  MOVF   FF5,W
00560:  RETURN 0
00562:  DATA 63,20
00564:  DATA 20,20
00566:  DATA 20,20
00568:  DATA 20,71
0056A:  DATA 20,20
0056C:  DATA 20,20
0056E:  DATA 61,20
00570:  DATA 20,20
00572:  DATA 00,00
00574:  CLRF   FF7
00576:  ADDLW  84
00578:  MOVWF  FF6
0057A:  MOVLW  05
0057C:  ADDWFC FF7,F
0057E:  TBLRD*+
00580:  MOVF   FF5,W
00582:  RETURN 0
00584:  DATA 6D,20
00586:  DATA 20,20
00588:  DATA 20,20
0058A:  DATA 20,20
0058C:  DATA 6E,20
0058E:  DATA 20,20
00590:  DATA 20,20
00592:  DATA 2A,20
00594:  DATA 00,00
00596:  CLRF   FF7
00598:  ADDLW  A6
0059A:  MOVWF  FF6
0059C:  MOVLW  05
0059E:  ADDWFC FF7,F
005A0:  TBLRD*+
005A2:  MOVF   FF5,W
005A4:  RETURN 0
005A6:  DATA 70,20
005A8:  DATA 20,20
005AA:  DATA 20,20
005AC:  DATA 20,20
005AE:  DATA 2E,20
005B0:  DATA 20,20
005B2:  DATA 20,20
005B4:  DATA 20,20
005B6:  DATA 00,00
005B8:  CLRF   FF7
005BA:  ADDLW  C8
005BC:  MOVWF  FF6
005BE:  MOVLW  05
005C0:  ADDWFC FF7,F
005C2:  TBLRD*+
005C4:  MOVF   FF5,W
005C6:  RETURN 0
005C8:  DATA 2A,2A
005CA:  DATA 2A,00
005CC:  CLRF   FF7
005CE:  ADDLW  DC
005D0:  MOVWF  FF6
005D2:  MOVLW  05
005D4:  ADDWFC FF7,F
005D6:  TBLRD*+
005D8:  MOVF   FF5,W
005DA:  RETURN 0
005DC:  DATA 50,41
005DE:  DATA 47,45
005E0:  DATA 20,33
005E2:  DATA 20,20
005E4:  DATA 20,20
005E6:  DATA 20,20
005E8:  DATA 20,20
005EA:  DATA 20,20
005EC:  DATA 00,00
005EE:  CLRF   FF7
005F0:  ADDLW  FE
005F2:  MOVWF  FF6
005F4:  MOVLW  05
005F6:  ADDWFC FF7,F
005F8:  TBLRD*+
005FA:  MOVF   FF5,W
005FC:  RETURN 0
005FE:  DATA 54,45
00600:  DATA 53,54
00602:  DATA 20,20
00604:  DATA 20,20
00606:  DATA 20,20
00608:  DATA 20,20
0060A:  DATA 20,20
0060C:  DATA 20,20
0060E:  DATA 00,00
00610:  CLRF   FF7
00612:  ADDLW  20
00614:  MOVWF  FF6
00616:  MOVLW  06
00618:  ADDWFC FF7,F
0061A:  TBLRD*+
0061C:  MOVF   FF5,W
0061E:  RETURN 0
00620:  DATA 53,65
00622:  DATA 74,75
00624:  DATA 70,20
00626:  DATA 4D,61
00628:  DATA 6E,61
0062A:  DATA 67,65
0062C:  DATA 72,2E
0062E:  DATA 2E,2E
00630:  DATA 00,00
00632:  CLRF   FF7
00634:  ADDLW  42
00636:  MOVWF  FF6
00638:  MOVLW  06
0063A:  ADDWFC FF7,F
0063C:  TBLRD*+
0063E:  MOVF   FF5,W
00640:  RETURN 0
00642:  DATA 20,20
00644:  DATA 52,65
00646:  DATA 6C,65
00648:  DATA 61,73
0064A:  DATA 65,20
0064C:  DATA 53,57
0064E:  DATA 31,20
00650:  DATA 20,20
00652:  DATA 00,00
00654:  CLRF   FF7
00656:  ADDLW  64
00658:  MOVWF  FF6
0065A:  MOVLW  06
0065C:  ADDWFC FF7,F
0065E:  TBLRD*+
00660:  MOVF   FF5,W
00662:  RETURN 0
00664:  DATA 44,65
00666:  DATA 61,6C
00668:  DATA 20,57
0066A:  DATA 69,74
0066C:  DATA 68,20
0066E:  DATA 50,61
00670:  DATA 63,6B
00672:  DATA 65,74
00674:  DATA 00,00
00676:  CLRF   FF7
00678:  ADDLW  86
0067A:  MOVWF  FF6
0067C:  MOVLW  06
0067E:  ADDWFC FF7,F
00680:  TBLRD*+
00682:  MOVF   FF5,W
00684:  RETURN 0
00686:  DATA 56,4C
00688:  DATA 56,20
0068A:  DATA 43,61
0068C:  DATA 6C,69
0068E:  DATA 62,72
00690:  DATA 61,74
00692:  DATA 69,6F
00694:  DATA 6E,20
00696:  DATA 00,00
00698:  CLRF   FF7
0069A:  ADDLW  A8
0069C:  MOVWF  FF6
0069E:  MOVLW  06
006A0:  ADDWFC FF7,F
006A2:  TBLRD*+
006A4:  MOVF   FF5,W
006A6:  RETURN 0
006A8:  DATA 42,65
006AA:  DATA 67,69
006AC:  DATA 6E,69
006AE:  DATA 6E,67
006B0:  DATA 2E,2E
006B2:  DATA 2E,2E
006B4:  DATA 2E,2E
006B6:  DATA 2E,2E
006B8:  DATA 00,00
006BA:  CLRF   FF7
006BC:  ADDLW  CA
006BE:  MOVWF  FF6
006C0:  MOVLW  06
006C2:  ADDWFC FF7,F
006C4:  TBLRD*+
006C6:  MOVF   FF5,W
006C8:  RETURN 0
006CA:  DATA 43,6C
006CC:  DATA 6F,73
006CE:  DATA 65,20
006D0:  DATA 43,43
006D2:  DATA 50,3D
006D4:  DATA 20,20
006D6:  DATA 20,20
006D8:  DATA 20,20
006DA:  DATA 00,00
006DC:  CLRF   FF7
006DE:  ADDLW  EC
006E0:  MOVWF  FF6
006E2:  MOVLW  06
006E4:  ADDWFC FF7,F
006E6:  TBLRD*+
006E8:  MOVF   FF5,W
006EA:  RETURN 0
006EC:  DATA 4F,70
006EE:  DATA 65,6E
006F0:  DATA 20,43
006F2:  DATA 43,50
006F4:  DATA 20,3D
006F6:  DATA 20,20
006F8:  DATA 20,20
006FA:  DATA 20,20
006FC:  DATA 00,00
006FE:  CLRF   FF7
00700:  ADDLW  0E
00702:  MOVWF  FF6
00704:  MOVLW  07
00706:  ADDWFC FF7,F
00708:  TBLRD*+
0070A:  MOVF   FF5,W
0070C:  RETURN 0
0070E:  DATA 52,65
00710:  DATA 73,65
00712:  DATA 74,74
00714:  DATA 69,6E
00716:  DATA 67,20
00718:  DATA 4D,6F
0071A:  DATA 74,65
0071C:  DATA 21,21
0071E:  DATA 00,00
00720:  CLRF   FF7
00722:  ADDLW  30
00724:  MOVWF  FF6
00726:  MOVLW  07
00728:  ADDWFC FF7,F
0072A:  TBLRD*+
0072C:  MOVF   FF5,W
0072E:  RETURN 0
00730:  DATA 4D,6F
00732:  DATA 74,65
00734:  DATA 20,69
00736:  DATA 73,20
00738:  DATA 44,65
0073A:  DATA 61,64
0073C:  DATA 20,20
0073E:  DATA 20,20
00740:  DATA 00,00
00742:  CLRF   FF7
00744:  ADDLW  52
00746:  MOVWF  FF6
00748:  MOVLW  07
0074A:  ADDWFC FF7,F
0074C:  TBLRD*+
0074E:  MOVF   FF5,W
00750:  RETURN 0
00752:  DATA 53,65
00754:  DATA 61,72
00756:  DATA 63,68
00758:  DATA 20,53
0075A:  DATA 74,72
0075C:  DATA 6F,6E
0075E:  DATA 67,20
00760:  DATA 31,20
00762:  DATA 00,00
00764:  CLRF   FF7
00766:  ADDLW  74
00768:  MOVWF  FF6
0076A:  MOVLW  07
0076C:  ADDWFC FF7,F
0076E:  TBLRD*+
00770:  MOVF   FF5,W
00772:  RETURN 0
00774:  DATA 53,65
00776:  DATA 61,72
00778:  DATA 63,68
0077A:  DATA 20,53
0077C:  DATA 74,72
0077E:  DATA 6F,6E
00780:  DATA 67,20
00782:  DATA 32,20
00784:  DATA 00,00
00786:  CLRF   FF7
00788:  ADDLW  96
0078A:  MOVWF  FF6
0078C:  MOVLW  07
0078E:  ADDWFC FF7,F
00790:  TBLRD*+
00792:  MOVF   FF5,W
00794:  RETURN 0
00796:  DATA 20,20
00798:  DATA 49,6E
0079A:  DATA 69,74
0079C:  DATA 20,4A
0079E:  DATA 6F,69
007A0:  DATA 6E,20
007A2:  DATA 20,20
007A4:  DATA 20,20
007A6:  DATA 00,00
*
01930:  MOVLB  5
01932:  CLRF   x91
01934:  CLRF   x92
01936:  MOVLW  01
01938:  MOVWF  x93
0193A:  CLRF   FDA
0193C:  CLRF   FD9
0193E:  MOVLW  05
01940:  MOVWF  x96
01942:  MOVLW  89
01944:  MOVWF  x95
01946:  MOVLW  05
01948:  MOVWF  FEA
0194A:  MOVLW  8D
0194C:  MOVWF  FE9
0194E:  MOVFF  596,FE2
01952:  MOVFF  595,FE1
01956:  MOVFF  593,594
0195A:  BCF    FD8.0
0195C:  MOVF   FE5,W
0195E:  MULWF  FEE
01960:  MOVF   FF3,W
01962:  ADDWFC x91,F
01964:  MOVF   FF4,W
01966:  ADDWFC x92,F
01968:  DECFSZ x94,F
0196A:  BRA    195A
0196C:  MOVFF  591,FDE
01970:  MOVFF  592,591
01974:  CLRF   x92
01976:  BTFSC  FD8.0
01978:  INCF   x92,F
0197A:  INCF   x95,F
0197C:  BTFSC  FD8.2
0197E:  INCF   x96,F
01980:  INCF   x93,F
01982:  MOVF   x93,W
01984:  SUBLW  05
01986:  BNZ   1946
01988:  MOVLB  0
0198A:  RETURN 0
*
020D6:  TSTFSZ 01
020D8:  BRA    20E0
020DA:  TSTFSZ 02
020DC:  BRA    20E2
020DE:  BRA    20EE
020E0:  INCF   02,F
020E2:  MOVFF  00,FEE
020E6:  DECFSZ 01,F
020E8:  BRA    20E2
020EA:  DECFSZ 02,F
020EC:  BRA    20E2
020EE:  RETURN 0
*
02388:  BTFSC  FD8.1
0238A:  BRA    2394
0238C:  MOVLW  05
0238E:  MOVWF  FEA
02390:  MOVLW  A5
02392:  MOVWF  FE9
02394:  CLRF   00
02396:  CLRF   01
02398:  CLRF   02
0239A:  CLRF   03
0239C:  MOVLB  5
0239E:  CLRF   xA5
023A0:  CLRF   xA6
023A2:  CLRF   xA7
023A4:  CLRF   xA8
023A6:  MOVF   xA4,W
023A8:  IORWF  xA3,W
023AA:  IORWF  xA2,W
023AC:  IORWF  xA1,W
023AE:  BZ    2408
023B0:  MOVLW  20
023B2:  MOVWF  xA9
023B4:  BCF    FD8.0
023B6:  RLCF   x9D,F
023B8:  RLCF   x9E,F
023BA:  RLCF   x9F,F
023BC:  RLCF   xA0,F
023BE:  RLCF   xA5,F
023C0:  RLCF   xA6,F
023C2:  RLCF   xA7,F
023C4:  RLCF   xA8,F
023C6:  MOVF   xA4,W
023C8:  SUBWF  xA8,W
023CA:  BNZ   23DC
023CC:  MOVF   xA3,W
023CE:  SUBWF  xA7,W
023D0:  BNZ   23DC
023D2:  MOVF   xA2,W
023D4:  SUBWF  xA6,W
023D6:  BNZ   23DC
023D8:  MOVF   xA1,W
023DA:  SUBWF  xA5,W
023DC:  BNC   23FC
023DE:  MOVF   xA1,W
023E0:  SUBWF  xA5,F
023E2:  MOVF   xA2,W
023E4:  BTFSS  FD8.0
023E6:  INCFSZ xA2,W
023E8:  SUBWF  xA6,F
023EA:  MOVF   xA3,W
023EC:  BTFSS  FD8.0
023EE:  INCFSZ xA3,W
023F0:  SUBWF  xA7,F
023F2:  MOVF   xA4,W
023F4:  BTFSS  FD8.0
023F6:  INCFSZ xA4,W
023F8:  SUBWF  xA8,F
023FA:  BSF    FD8.0
023FC:  RLCF   00,F
023FE:  RLCF   01,F
02400:  RLCF   02,F
02402:  RLCF   03,F
02404:  DECFSZ xA9,F
02406:  BRA    23B4
02408:  MOVFF  5A5,FEF
0240C:  MOVFF  5A6,FEC
02410:  MOVFF  5A7,FEC
02414:  MOVFF  5A8,FEC
02418:  MOVLB  0
0241A:  RETURN 0
*
0402E:  CLRF   01
04030:  CLRF   02
04032:  CLRF   00
04034:  CLRF   03
04036:  MOVLB  5
04038:  MOVF   x74,W
0403A:  BNZ   4040
0403C:  MOVF   x73,W
0403E:  BZ    4070
04040:  MOVLW  10
04042:  MOVWF  x75
04044:  BCF    FD8.0
04046:  RLCF   x71,F
04048:  RLCF   x72,F
0404A:  RLCF   00,F
0404C:  RLCF   03,F
0404E:  MOVF   x74,W
04050:  SUBWF  03,W
04052:  BNZ   4058
04054:  MOVF   x73,W
04056:  SUBWF  00,W
04058:  BNC   4068
0405A:  MOVF   x73,W
0405C:  SUBWF  00,F
0405E:  BTFSS  FD8.0
04060:  DECF   03,F
04062:  MOVF   x74,W
04064:  SUBWF  03,F
04066:  BSF    FD8.0
04068:  RLCF   01,F
0406A:  RLCF   02,F
0406C:  DECFSZ x75,F
0406E:  BRA    4044
04070:  MOVLB  0
04072:  RETURN 0
*
044B8:  MOVLW  8E
044BA:  MOVWF  00
044BC:  MOVFF  566,01
044C0:  MOVFF  565,02
044C4:  CLRF   03
044C6:  MOVF   01,F
044C8:  BNZ   44DC
044CA:  MOVFF  02,01
044CE:  CLRF   02
044D0:  MOVLW  08
044D2:  SUBWF  00,F
044D4:  MOVF   01,F
044D6:  BNZ   44DC
044D8:  CLRF   00
044DA:  BRA    44EC
044DC:  BCF    FD8.0
044DE:  BTFSC  01.7
044E0:  BRA    44EA
044E2:  RLCF   02,F
044E4:  RLCF   01,F
044E6:  DECF   00,F
044E8:  BRA    44DC
044EA:  BCF    01.7
044EC:  RETURN 0
044EE:  MOVLB  5
044F0:  MOVF   x65,W
044F2:  BTFSC  FD8.2
044F4:  BRA    4640
044F6:  MOVWF  x71
044F8:  MOVF   x69,W
044FA:  BTFSC  FD8.2
044FC:  BRA    4640
044FE:  SUBWF  x71,F
04500:  BNC   450C
04502:  MOVLW  7F
04504:  ADDWF  x71,F
04506:  BTFSC  FD8.0
04508:  BRA    4640
0450A:  BRA    4518
0450C:  MOVLW  81
0450E:  SUBWF  x71,F
04510:  BTFSS  FD8.0
04512:  BRA    4640
04514:  BTFSC  FD8.2
04516:  BRA    4640
04518:  MOVFF  571,00
0451C:  CLRF   01
0451E:  CLRF   02
04520:  CLRF   03
04522:  CLRF   x70
04524:  MOVFF  566,56F
04528:  BSF    x6F.7
0452A:  MOVFF  567,56E
0452E:  MOVFF  568,56D
04532:  MOVLW  19
04534:  MOVWF  x71
04536:  MOVF   x6C,W
04538:  SUBWF  x6D,F
0453A:  BC    4556
0453C:  MOVLW  01
0453E:  SUBWF  x6E,F
04540:  BC    4556
04542:  SUBWF  x6F,F
04544:  BC    4556
04546:  SUBWF  x70,F
04548:  BC    4556
0454A:  INCF   x70,F
0454C:  INCF   x6F,F
0454E:  INCF   x6E,F
04550:  MOVF   x6C,W
04552:  ADDWF  x6D,F
04554:  BRA    45A6
04556:  MOVF   x6B,W
04558:  SUBWF  x6E,F
0455A:  BC    4580
0455C:  MOVLW  01
0455E:  SUBWF  x6F,F
04560:  BC    4580
04562:  SUBWF  x70,F
04564:  BC    4580
04566:  INCF   x70,F
04568:  INCF   x6F,F
0456A:  MOVF   x6B,W
0456C:  ADDWF  x6E,F
0456E:  MOVF   x6C,W
04570:  ADDWF  x6D,F
04572:  BNC   45A6
04574:  INCF   x6E,F
04576:  BNZ   45A6
04578:  INCF   x6F,F
0457A:  BNZ   45A6
0457C:  INCF   x70,F
0457E:  BRA    45A6
04580:  MOVF   x6A,W
04582:  IORLW  80
04584:  SUBWF  x6F,F
04586:  BC    45A4
04588:  MOVLW  01
0458A:  SUBWF  x70,F
0458C:  BC    45A4
0458E:  INCF   x70,F
04590:  MOVF   x6A,W
04592:  IORLW  80
04594:  ADDWF  x6F,F
04596:  MOVF   x6B,W
04598:  ADDWF  x6E,F
0459A:  BNC   456E
0459C:  INCF   x6F,F
0459E:  BNZ   456E
045A0:  INCF   x70,F
045A2:  BRA    456E
045A4:  BSF    03.0
045A6:  DECFSZ x71,F
045A8:  BRA    45AC
045AA:  BRA    45C2
045AC:  BCF    FD8.0
045AE:  RLCF   x6D,F
045B0:  RLCF   x6E,F
045B2:  RLCF   x6F,F
045B4:  RLCF   x70,F
045B6:  BCF    FD8.0
045B8:  RLCF   03,F
045BA:  RLCF   02,F
045BC:  RLCF   01,F
045BE:  RLCF   x72,F
045C0:  BRA    4536
045C2:  BTFSS  x72.0
045C4:  BRA    45D2
045C6:  BCF    FD8.0
045C8:  RRCF   01,F
045CA:  RRCF   02,F
045CC:  RRCF   03,F
045CE:  RRCF   x72,F
045D0:  BRA    45D6
045D2:  DECF   00,F
045D4:  BZ    4640
045D6:  BTFSC  x72.7
045D8:  BRA    4616
045DA:  BCF    FD8.0
045DC:  RLCF   x6D,F
045DE:  RLCF   x6E,F
045E0:  RLCF   x6F,F
045E2:  RLCF   x70,F
045E4:  MOVF   x6C,W
045E6:  SUBWF  x6D,F
045E8:  BC    45F8
045EA:  MOVLW  01
045EC:  SUBWF  x6E,F
045EE:  BC    45F8
045F0:  SUBWF  x6F,F
045F2:  BC    45F8
045F4:  SUBWF  x70,F
045F6:  BNC   462C
045F8:  MOVF   x6B,W
045FA:  SUBWF  x6E,F
045FC:  BC    4608
045FE:  MOVLW  01
04600:  SUBWF  x6F,F
04602:  BC    4608
04604:  SUBWF  x70,F
04606:  BNC   462C
04608:  MOVF   x6A,W
0460A:  IORLW  80
0460C:  SUBWF  x6F,F
0460E:  BC    4616
04610:  MOVLW  01
04612:  SUBWF  x70,F
04614:  BNC   462C
04616:  INCF   03,F
04618:  BNZ   462C
0461A:  INCF   02,F
0461C:  BNZ   462C
0461E:  INCF   01,F
04620:  BNZ   462C
04622:  INCF   00,F
04624:  BZ    4640
04626:  RRCF   01,F
04628:  RRCF   02,F
0462A:  RRCF   03,F
0462C:  MOVFF  566,571
04630:  MOVF   x6A,W
04632:  XORWF  x71,F
04634:  BTFSS  x71.7
04636:  BRA    463C
04638:  BSF    01.7
0463A:  BRA    4648
0463C:  BCF    01.7
0463E:  BRA    4648
04640:  CLRF   00
04642:  CLRF   01
04644:  CLRF   02
04646:  CLRF   03
04648:  MOVLB  0
0464A:  RETURN 0
0464C:  MOVLB  5
0464E:  MOVF   x65,W
04650:  SUBLW  B6
04652:  MOVWF  x65
04654:  CLRF   03
04656:  MOVFF  566,569
0465A:  BSF    x66.7
0465C:  BCF    FD8.0
0465E:  RRCF   x66,F
04660:  RRCF   x67,F
04662:  RRCF   x68,F
04664:  RRCF   03,F
04666:  RRCF   02,F
04668:  RRCF   01,F
0466A:  RRCF   00,F
0466C:  DECFSZ x65,F
0466E:  BRA    465C
04670:  BTFSS  x69.7
04672:  BRA    468A
04674:  COMF   00,F
04676:  COMF   01,F
04678:  COMF   02,F
0467A:  COMF   03,F
0467C:  INCF   00,F
0467E:  BTFSC  FD8.2
04680:  INCF   01,F
04682:  BTFSC  FD8.2
04684:  INCF   02,F
04686:  BTFSC  FD8.2
04688:  INCF   03,F
0468A:  MOVLB  0
0468C:  RETURN 0
*
047DC:  MOVLB  5
047DE:  MOVF   x68,W
047E0:  CLRF   01
047E2:  SUBWF  x67,W
047E4:  BC    47EC
047E6:  MOVFF  567,00
047EA:  BRA    4804
047EC:  CLRF   00
047EE:  MOVLW  08
047F0:  MOVWF  x69
047F2:  RLCF   x67,F
047F4:  RLCF   00,F
047F6:  MOVF   x68,W
047F8:  SUBWF  00,W
047FA:  BTFSC  FD8.0
047FC:  MOVWF  00
047FE:  RLCF   01,F
04800:  DECFSZ x69,F
04802:  BRA    47F2
04804:  MOVLB  0
04806:  RETURN 0
*
04B3C:  MOVLB  5
04B3E:  MOVF   x67,W
04B40:  MULWF  x69
04B42:  MOVFF  FF3,01
04B46:  MOVFF  FF4,00
04B4A:  MULWF  x6A
04B4C:  MOVF   FF3,W
04B4E:  ADDWF  00,F
04B50:  MOVF   x68,W
04B52:  MULWF  x69
04B54:  MOVF   FF3,W
04B56:  ADDWFC 00,W
04B58:  MOVWF  02
04B5A:  MOVLB  0
04B5C:  RETURN 0
*
0595E:  ADDWF  FE8,W
05960:  CLRF   FF7
05962:  RLCF   FF7,F
05964:  ADDLW  79
05966:  MOVWF  FF6
05968:  MOVLW  59
0596A:  ADDWFC FF7,F
0596C:  TBLRD*-
0596E:  MOVF   FF5,W
05970:  MOVWF  FFA
05972:  TBLRD*
05974:  MOVF   FF5,W
05976:  MOVWF  FF9
05978:  DATA DC,53
0597A:  DATA 28,51
0597C:  DATA DC,53
0597E:  DATA 56,59
05980:  DATA 56,59
05982:  DATA 76,56
05984:  DATA 76,56
05986:  DATA 56,59
05988:  DATA 18,58
0598A:  DATA B6,58
*
0793E:  ADDWF  FE8,W
07940:  CLRF   FF7
07942:  RLCF   FF7,F
07944:  ADDLW  59
07946:  MOVWF  FF6
07948:  MOVLW  79
0794A:  ADDWFC FF7,F
0794C:  TBLRD*-
0794E:  MOVF   FF5,W
07950:  MOVWF  FFA
07952:  TBLRD*
07954:  MOVF   FF5,W
07956:  MOVWF  FF9
07958:  DATA 12,6D
0795A:  DATA 28,6D
0795C:  DATA 34,79
0795E:  DATA 34,79
07960:  DATA 34,79
07962:  DATA 34,79
07964:  DATA 34,79
07966:  DATA 34,79
07968:  DATA 34,79
0796A:  DATA 34,79
0796C:  DATA 34,79
0796E:  DATA 34,79
07970:  DATA 34,79
07972:  DATA 34,79
07974:  DATA 34,79
07976:  DATA 2E,6D
07978:  DATA 44,6D
0797A:  DATA 5A,6D
0797C:  DATA 34,79
0797E:  DATA 34,79
07980:  DATA 34,79
07982:  DATA 34,79
07984:  DATA 34,79
07986:  DATA 34,79
07988:  DATA 34,79
0798A:  DATA 34,79
0798C:  DATA 34,79
0798E:  DATA 34,79
07990:  DATA 34,79
07992:  DATA 34,79
07994:  DATA 34,79
07996:  DATA 70,6D
07998:  DATA DE,6D
0799A:  DATA 4C,6E
0799C:  DATA A4,6E
0799E:  DATA 34,79
079A0:  DATA 34,79
079A2:  DATA 34,79
079A4:  DATA 34,79
079A6:  DATA 34,79
079A8:  DATA 34,79
079AA:  DATA 34,79
079AC:  DATA 34,79
079AE:  DATA 34,79
079B0:  DATA 34,79
079B2:  DATA 34,79
079B4:  DATA 34,79
079B6:  DATA 94,6F
079B8:  DATA C6,6F
079BA:  DATA EC,6F
079BC:  DATA 88,70
079BE:  DATA AE,70
079C0:  DATA 1E,72
079C2:  DATA 34,73
079C4:  DATA 34,79
079C6:  DATA 34,79
079C8:  DATA 34,79
079CA:  DATA 34,79
079CC:  DATA 34,79
079CE:  DATA 34,79
079D0:  DATA 34,79
079D2:  DATA 34,79
079D4:  DATA 34,79
079D6:  DATA 84,73
079D8:  DATA 94,74
079DA:  DATA BE,74
079DC:  DATA 0C,76
079DE:  DATA 04,77
079E0:  DATA 1C,79
....................  
.................... #list 
....................  
.................... #device adc=10  
.................... #device high_ints=TRUE 
....................                   
.................... // standard libraries 
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #include <stdint.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... ////                           stdint.h                                //// 
.................... ////                                                                   //// 
.................... //// Standard integer definitions.                                     //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDINT 
....................  
.................... #define _STDINT 
....................  
.................... //////////// exact width 
....................  
.................... typedef signed int8 int8_t; 
.................... typedef unsigned int8 uint8_t; 
.................... typedef signed int16 int16_t; 
.................... typedef unsigned int16 uint16_t; 
.................... typedef signed int32 int32_t; 
.................... typedef unsigned int32 uint32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int24_t; 
.................... //typedef unsigned int24 uint24_t; 
.................... typedef signed int64 int64_t; 
.................... typedef unsigned int64 uint64_t; 
.................... #endif 
....................  
.................... #define INT8_MAX  (127) 
.................... #define INT8_MIN  (-128) 
.................... #define UINT8_MAX (255) 
....................  
.................... #define INT16_MAX  (32767) 
.................... #define INT16_MIN  (-32768) 
.................... #define UINT16_MAX (65535) 
....................  
.................... #define INT32_MAX  (2147483647) 
.................... #define INT32_MIN  (-2147483648) 
.................... #define UINT32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT24_MAX  (8388607) 
.................... //#define INT24_MIN  (-8388608) 
.................... //#define UINT24_MAX (16777215) 
....................  
.................... #define INT64_MAX  (9223372036854775807) 
.................... #define INT64_MIN  (-9223372036854775808) 
.................... #define UINT64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// minimum width 
....................  
.................... typedef signed int8 int_least8_t; 
.................... typedef unsigned int8 uint_least8_t; 
.................... typedef signed int16 int_least16_t; 
.................... typedef unsigned int16 uint_least16_t; 
.................... typedef signed int32 int_least32_t; 
.................... typedef unsigned int32 uint_least32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int_least24_t; 
.................... //typedef unsigned int24 uint_least24_t; 
.................... typedef signed int64 int_least64_t; 
.................... typedef unsigned int64 uint_least64_t; 
.................... #endif 
....................  
.................... #define INT_LEAST8_MAX  (127) 
.................... #define INT_LEAST8_MIN  (-128) 
.................... #define UINT_LEAST8_MAX (255) 
....................  
.................... #define INT_LEAST16_MAX  (32767) 
.................... #define INT_LEAST16_MIN  (-32768) 
.................... #define UINT_LEAST16_MAX (65535) 
....................  
.................... #define INT_LEAST32_MAX  (2147483647) 
.................... #define INT_LEAST32_MIN  (-2147483648) 
.................... #define UINT_LEAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_LEAST24_MAX  (8388607) 
.................... //#define INT_LEAST24_MIN  (-8388608) 
.................... //#define UINT_LEAST24_MAX (16777215) 
....................  
.................... #define INT_LEAST64_MAX  (9223372036854775807) 
.................... #define INT_LEAST64_MIN  (-9223372036854775808) 
.................... #define UINT_LEAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// fastest width 
....................  
.................... #if defined(__PCD__) 
.................... typedef signed int16 int_fast8_t; 
.................... typedef unsigned int16 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (32767) 
.................... #define INT_FAST8_MIN  (-32768) 
.................... #define UINT_FAST8_MAX (65535) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... //typedef signed int24 int_fast24_t; 
.................... //typedef unsigned int24 uint_fast24_t; 
.................... typedef signed int64 int_fast64_t; 
.................... typedef unsigned int64 uint_fast64_t; 
.................... #else 
.................... typedef signed int8 int_fast8_t; 
.................... typedef unsigned int8 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (127) 
.................... #define INT_FAST8_MIN  (-128) 
.................... #define UINT_FAST8_MAX (255) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... #endif 
....................  
.................... typedef signed int32 int_fast32_t; 
.................... typedef unsigned int32 uint_fast32_t; 
....................  
.................... #define INT_FAST16_MAX  (32767) 
.................... #define INT_FAST16_MIN  (-32768) 
.................... #define UINT_FAST16_MAX (65535) 
....................  
.................... #define INT_FAST32_MAX  (2147483647) 
.................... #define INT_FAST32_MIN  (-2147483648) 
.................... #define UINT_FAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_FAST24_MAX  (8388607) 
.................... //#define INT_FAST24_MIN  (-8388608) 
.................... //#define UINT_FAST24_MAX (16777215) 
....................  
.................... #define INT_FAST64_MAX  (9223372036854775807) 
.................... #define INT_FAST64_MIN  (-9223372036854775808) 
.................... #define UINT_FAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... //////////// big enough to hold pointers (OPTIONAL) 
....................  
.................... #if defined(__PCD__) 
....................    typedef unsigned int32 uintptr_t; 
....................    typedef signed int32 intptr_t; 
.................... #else 
....................    typedef unsigned int16 uintptr_t; 
....................    typedef signed int16 intptr_t; 
.................... #endif 
....................  
.................... /// TODO: 
.................... /// INTPTRN_MIN INTPTRN_MAX UINTPTRN_MAX 
....................  
....................  
.................... /////////// greatest width (OPTIONAL) 
....................  
.................... /// TODO 
....................  
.................... /// intmax_t uintmax_t 
....................  
.................... /// INTMAXN_MIN INTMAXN_MAX UINTMAXN_MAX 
....................  
.................... /// INTMAX_C(value) UINTMAX_C(value) 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char **endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char **endptr); 
.................... float64 strtod(char *s,char **endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, (char*)0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char **endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char **endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char **endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... size_t mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
*
04074:  CLRF   19
04076:  BTFSC  FF2.7
04078:  BSF    19.7
0407A:  BCF    FF2.7
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
0407C:  MOVFF  34,58C
04080:  MOVFF  33,58B
04084:  MOVFF  32,58A
04088:  MOVFF  31,589
0408C:  MOVLW  41
0408E:  MOVLB  5
04090:  MOVWF  x90
04092:  MOVLW  C6
04094:  MOVWF  x8F
04096:  MOVLW  4E
04098:  MOVWF  x8E
0409A:  MOVLW  6D
0409C:  MOVWF  x8D
0409E:  MOVLB  0
040A0:  CALL   1930
040A4:  BTFSC  19.7
040A6:  BSF    FF2.7
040A8:  MOVLW  39
040AA:  MOVLB  5
040AC:  ADDWF  00,W
040AE:  MOVWF  31
040B0:  MOVLW  30
040B2:  ADDWFC 01,W
040B4:  MOVWF  32
040B6:  MOVLW  00
040B8:  ADDWFC 02,W
040BA:  MOVWF  33
040BC:  MOVLW  00
040BE:  ADDWFC 03,W
040C0:  MOVWF  34
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
040C2:  MOVFF  33,00
040C6:  MOVFF  34,01
040CA:  CLRF   02
040CC:  CLRF   03
040CE:  MOVFF  34,549
040D2:  MOVFF  33,548
040D6:  MOVFF  34,572
040DA:  MOVFF  33,571
040DE:  MOVLW  7F
040E0:  MOVWF  x74
040E2:  SETF   x73
040E4:  MOVLB  0
040E6:  RCALL  402E
040E8:  MOVFF  00,01
040EC:  MOVFF  03,02
040F0:  GOTO   4132 (RETURN)
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
*
0401A:  MOVFF  54B,34
0401E:  MOVFF  54A,33
04022:  MOVFF  549,32
04026:  MOVFF  548,31
0402A:  GOTO   4130 (RETURN)
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdlibm.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... /*********************************************************************/ 
.................... #ifndef _STDLIBM 
.................... #define _STDLIBM 
....................  
.................... /* Memory Management Functions*/ 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... typedef struct nodet { 
....................    unsigned int8 size; 
....................    unsigned int8 next; }node_t; 
.................... #elif defined(__PCM__) 
.................... typedef struct nodet { 
....................    unsigned int8 size; 
....................    unsigned int16 next; }node_t; 
.................... #elif defined(__PCH__) 
.................... typedef struct nodet { 
....................    unsigned int16 size; 
....................    unsigned int16 next; }node_t; 
.................... #elif defined(__PCD__) 
.................... typedef struct nodet { 
....................    unsigned int16 size; 
....................    unsigned int16 next; }node_t; 
.................... #endif 
....................  
.................... #if !defined(STDLIBM_MANUAL_DYNAMIC_MEMORY) 
....................    #USE DYNAMIC_MEMORY 
.................... #endif 
....................  
.................... #ifndef debug_stdlibm 
....................    #define debug_stdlibm(s) 
.................... #else 
....................    #define __DO_DEBUG_STDLIBM 
....................     
....................    char g_DebugStdlibmStr[50]; 
....................     
....................    #if defined(__PCD__) 
....................       #if (defined(__PIC24E__)||defined(__dsPIC33E__)) 
....................          #define INVALID_MEMORY_LOCATION(x) ((x >= (getenv("RAM")+0x800)) || bit_test(x, 0)) 
....................       #else 
....................          #define INVALID_MEMORY_LOCATION(x) ((x >= (getenv("RAM")+0x1000)) || bit_test(x, 0)) 
....................       #endif 
....................    #else 
....................       #define INVALID_MEMORY_LOCATION(x) (x >= getenv("RAM")) 
....................    #endif 
.................... #endif 
....................  
.................... #if defined(STDLIBM_TRACK_WORST_CASE) 
....................    static size_t _g_StdlibmCurrentBytesUsed = 0; 
....................    static size_t _g_StdlibmWorstCaseBytesUsed = 0; 
....................     
....................    #define _STDLIBM_TRACK_WORST_INC(_x) \ 
....................    do {  \ 
....................       _g_StdlibmCurrentBytesUsed += _x;   \ 
....................       if (_g_StdlibmCurrentBytesUsed > _g_StdlibmWorstCaseBytesUsed) \ 
....................          _g_StdlibmWorstCaseBytesUsed = _g_StdlibmCurrentBytesUsed;  \ 
....................    } while(0) 
....................     
....................    #define _STDLIBM_TRACK_WORST_DEC(_x) _g_StdlibmCurrentBytesUsed-=_x 
.................... #else 
....................    #define _STDLIBM_TRACK_WORST_INC(_x) 
....................    #define _STDLIBM_TRACK_WORST_DEC(_x) 
.................... #endif 
....................  
.................... #include <memmgmt.c> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #if defined(__PCH__) 
....................  #define _MEMMGMT_CSIZE 32768 
....................  #define _MEMMGMT_POS 15 
.................... #elif defined(__PCD__) 
....................    #define _MEMMGMT_CSIZE 32768 
....................    #define _MEMMGMT_POS 15 
.................... #else 
....................    #define _MEMMGMT_CSIZE 127 
....................    #define _MEMMGMT_POS 7 
.................... #endif 
....................  
.................... node_t * create_node(unsigned int16 size, node_t *ptr) // create node at given location 
.................... { 
....................    node_t *result; 
....................    result =ptr; 
....................    result->size=size; 
....................    result->next = NULL; 
....................    return result; 
.................... } 
.................... void update_node(node_t *node, unsigned int16 size) // update the size of given node 
.................... { 
....................    node->size=size; 
.................... } 
....................  
.................... /* Insert node immediately after place */ //old,new 
.................... void insert_node_after(node_t *place, node_t *node)// place the node after another given node 
.................... { 
....................     if (place->next==NULL) 
....................        node->next= NULL; 
....................     else 
....................        node->next=place->next; 
....................     place->next=node; 
.................... } 
....................  
.................... ///////////////////////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... void remove_node(node_t *node) {// remove the given node from the memlist 
....................    node_t *ptr; 
....................    for(ptr=__DYNAMIC_HEAD;ptr->next!=node;ptr=ptr->next); 
....................    ptr->next=node->next; 
....................    node=NULL; 
.................... } 
....................  
.................... ///////////////////////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... #if defined(__DO_DEBUG_STDLIBM) 
.................... void print_list() { // print the current memlist 
....................     node_t *node; 
....................     debug_stdlibm("\r\nThe list is \n\r"); 
....................     for(node = __DYNAMIC_HEAD; node != NULL; node = node->next) 
....................     { 
....................         sprintf(g_DebugStdlibmStr, "H:0x%lx S:0x%lx N:0x%lx\n\r", node, node->size, node->next); 
....................         debug_stdlibm(g_DebugStdlibmStr); 
....................         if (INVALID_MEMORY_LOCATION(node->next)) 
....................         { 
....................            debug_stdlibm("Breaking because of invalid next node\r\n"); 
....................            break; 
....................         }    
....................     } 
....................     sprintf(g_DebugStdlibmStr, "size of node_t %u\r\n",sizeof(node_t)); 
....................     debug_stdlibm(g_DebugStdlibmStr); 
.................... } 
.................... #endif 
....................  
....................  
....................  
....................  
.................... void traverse() 
.................... { 
....................    node_t *node,*temp; 
....................    unsigned int16 nsize,nextsize; 
....................    node=__DYNAMIC_HEAD; 
....................    while(node!=NULL) 
....................    { 
....................      #if defined(__DO_DEBUG_STDLIBM) 
....................       if (INVALID_MEMORY_LOCATION(node)) 
....................       { 
....................          sprintf(g_DebugStdlibmStr, "traverse() invalid node (0x%LX)\r\n", node); 
....................          debug_stdlibm(g_DebugStdlibmStr); 
....................          break; 
....................       }    
....................      #endif 
....................      if(!bit_test(node->size,_MEMMGMT_POS))// node free 
....................       { 
....................          nsize=node->size; 
....................          temp=(unsigned int16)node->next; 
....................         #if defined(__DO_DEBUG_STDLIBM) 
....................          if (INVALID_MEMORY_LOCATION(temp)) 
....................          { 
....................             sprintf(g_DebugStdlibmStr, "traverse() invalid temp (0x%LX)\r\n", node); 
....................             debug_stdlibm(g_DebugStdlibmStr); 
....................             break; 
....................          } 
....................         #endif 
....................          if(!bit_test(temp->size,_MEMMGMT_POS)&& (temp==((unsigned int16)node+nsize+sizeof(node_t))))//next node free and consecutive, so combine 
....................          { 
....................             nextsize=temp->size; 
....................             nsize+=nextsize+sizeof(node_t); 
....................             remove_node(temp); 
....................             update_node(node,nsize); 
....................          } 
....................          else 
....................          node=node->next; 
....................       } 
....................       else 
....................       node=node->next; 
....................    } 
.................... } 
....................  
.................... char *malloc(size_t size) 
.................... { 
....................    node_t *node,*new; 
....................    unsigned int16 nsize; 
....................    #if defined(__PCD__) 
....................    if (size % 2) 
....................       size++; 
....................    #endif 
....................    node=__DYNAMIC_HEAD; 
....................     
....................   #if defined(__DO_DEBUG_STDLIBM) 
....................    sprintf(g_DebugStdlibmStr, "malloc() size=%lu ", size); 
....................    debug_stdlibm(g_DebugStdlibmStr); 
....................   #endif 
....................          
....................    while(node!=NULL) // chk until end of memlist 
....................    { 
....................      #if defined(__DO_DEBUG_STDLIBM) 
....................       if (INVALID_MEMORY_LOCATION(node)) 
....................       { 
....................          sprintf(g_DebugStdlibmStr, " invalid node (0x%LX)\r\n", node); 
....................          debug_stdlibm(g_DebugStdlibmStr); 
....................          print_list(); 
....................          return(0); 
....................       } 
....................      #endif 
....................       if(!bit_test(node->size,_MEMMGMT_POS) && node->size >=size) // node is free and > = req size 
....................       { 
....................          nsize=node->size;    //nsize = size of the node that "node" being pointed at 
....................          if(nsize>size +sizeof(node_t)) //node > req size, so split and add new node to memlist 
....................          { 
....................             new=create_node(nsize-size-sizeof(node_t),(unsigned int16)node+sizeof(node_t)+size); 
....................             insert_node_after(node,new); 
....................             update_node(node,size+_MEMMGMT_CSIZE); 
....................          } 
....................          else//not enough space for new node so use original size 
....................          update_node(node,nsize+_MEMMGMT_CSIZE); 
....................          //end if 
....................          break; 
....................       }//end if 
....................       node=node->next; 
....................    }//end while 
....................    if(node==NULL)// reached end without finding an appropriate node 
....................    { 
....................       debug_stdlibm("Not enough memory for mallocation\r\n"); 
....................       return NULL; 
....................    } 
....................    else 
....................    { 
....................      #if defined(__DO_DEBUG_STDLIBM) 
....................       sprintf(g_DebugStdlibmStr, "%LX\r\n", (char *)node+sizeof(node_t)); 
....................       debug_stdlibm(g_DebugStdlibmStr); 
....................      #endif 
....................       _STDLIBM_TRACK_WORST_INC(size); 
....................       return (char *)node+sizeof(node_t); // return pounsigned int8er to allocated space 
....................    } 
.................... } 
....................  
.................... char *calloc(size_t nmemb,size_t size) 
.................... { 
....................    node_t *node,*new; 
....................    unsigned int16 nsize,resize; 
....................    node=__DYNAMIC_HEAD; 
....................    resize=nmemb*size; 
....................    #if defined(__PCD__) 
....................    if(resize%2) 
....................       resize++; 
....................    #endif 
....................    while(node!=NULL) // chk until end of memlist 
....................    { 
....................      #if defined(__DO_DEBUG_STDLIBM) 
....................       if (INVALID_MEMORY_LOCATION(node)) 
....................       { 
....................          sprintf(g_DebugStdlibmStr, "malloc() invalid node (0x%LX)\r\n", node); 
....................          debug_stdlibm(g_DebugStdlibmStr); 
....................          print_list(); 
....................          return(0); 
....................       } 
....................      #endif 
....................       if(!bit_test(node->size,_MEMMGMT_POS) && node->size >=resize)// node is free and > = req size 
....................       { 
....................          nsize=node->size; 
....................          if(nsize>resize+sizeof(node_t))//node > req size, so split and add new node to memlist 
....................          { 
....................             new=create_node(nsize-resize-sizeof(node_t),(unsigned int16)node+sizeof(node_t)+resize); 
....................             insert_node_after(node,new); 
....................             update_node(node,resize+_MEMMGMT_CSIZE); 
....................          } 
....................          else//not enough space for new node so use original size 
....................          update_node(node,nsize+_MEMMGMT_CSIZE); 
....................          //end if 
....................          break; 
....................       }//end if 
....................       node=node->next; 
....................    }//end while 
....................    if(node==NULL)// reached end without finding an appropriate node 
....................    { 
....................       debug_stdlibm("Not enough memory for callocation\r\n"); 
....................       return NULL; 
....................    } 
....................    else 
....................    { 
....................       memset((unsigned int16)node+sizeof(node_t),0,resize);// initialize to 0 
....................       _STDLIBM_TRACK_WORST_INC(resize); 
....................       return (char *)(unsigned int16)node+sizeof(node_t);// return pounsigned int8er to allocated space 
....................    } 
.................... } 
.................... void free( void * ptr) 
.................... { 
....................    node_t *node; 
....................    unsigned int16 nsize; 
....................  
....................   #if defined(__DO_DEBUG_STDLIBM) 
....................    sprintf(g_DebugStdlibmStr, "free() 0x%LX\r\n", ptr); 
....................    debug_stdlibm(g_DebugStdlibmStr); 
....................   #endif 
....................  
....................    if(ptr==NULL) // not a valid pounsigned int8er 
....................       return; 
....................    else 
....................    { 
....................       node=ptr-sizeof(node_t); 
....................       if(bit_test(node->size,_MEMMGMT_POS))// node occupied 
....................       { 
....................          nsize=node->size-_MEMMGMT_CSIZE; 
....................          update_node(node,nsize); 
....................          ptr=NULL; 
....................          _STDLIBM_TRACK_WORST_DEC(nsize); 
....................       } 
....................       else // wrong input, return 
....................       { 
....................          ptr=NULL; 
....................          return; 
....................       } 
....................    } 
....................    traverse(); 
.................... } 
....................  
.................... char *realloc(void *ptr,size_t size) 
.................... { 
....................    node_t *node,*new,*temp; 
....................    unsigned int16 nsize,nextsize; 
....................    char *newptr; 
....................    #if defined(__PCD__) 
....................    if(size %2) 
....................       size++; 
....................    #endif 
....................    if(ptr==NULL)// null pounsigned int8er, so malloc the req memory 
....................       return(malloc(size)); 
....................    else if(size==0) 
....................    { 
....................       free(ptr); 
....................       return(NULL); 
....................    } 
....................    else 
....................    { 
....................       node=ptr-sizeof(node_t); 
....................       if(bit_test(node->size,_MEMMGMT_POS))// chk if valid pounsigned int8er 
....................       { 
....................          nsize=node->size-_MEMMGMT_CSIZE; 
....................          temp=(unsigned int16)node->next; 
....................          if(nsize>size)// block > req size 
....................          { 
....................         
....................                if(!bit_test(temp->size,_MEMMGMT_POS) && (temp==((unsigned int16)node+nsize+sizeof(node_t))))// next block free and consecutive 
....................                { 
....................                   update_node(node,size+_MEMMGMT_CSIZE); // update block 
....................                   nextsize=temp->size; 
....................                   remove_node(temp); 
....................                   new=create_node(nextsize+(nsize-size),(unsigned int16)node+size+sizeof(node_t)); 
....................                   insert_node_after(node,new); 
....................                   _STDLIBM_TRACK_WORST_DEC(nsize); 
....................                   _STDLIBM_TRACK_WORST_INC(size); 
....................                } 
....................                else if (nsize>size +sizeof(node_t))//node > req size, so split and add new node to memlist 
....................                { 
....................                   update_node(node,size+_MEMMGMT_CSIZE); // update block 
....................                   new=create_node(nsize-size-sizeof(node_t),(unsigned int16)node+sizeof(node_t)+size); 
....................                   insert_node_after(node,new); 
....................                   _STDLIBM_TRACK_WORST_DEC(nsize); 
....................                   _STDLIBM_TRACK_WORST_INC(size); 
....................                } 
....................                else//not enough space for new node so use original size 
....................                update_node(node,nsize+_MEMMGMT_CSIZE); // update block 
....................  
....................          } 
....................          else // block < req size 
....................          { 
....................             if(!bit_test(temp->size,_MEMMGMT_POS) && (temp==((unsigned int16)node+nsize+sizeof(node_t))))// next block free and consecutive 
....................             { 
....................                nextsize=temp->size; 
....................                if(nextsize>=size-nsize) // next block >=difference 
....................                { 
....................                   if(nextsize>size-nsize+sizeof(node_t))//next node > req size, so split and add new node to memlist 
....................                   { 
....................                       update_node(node,size+_MEMMGMT_CSIZE);// update block 
....................                       remove_node(temp); 
....................                       new=create_node(nextsize-(size-nsize),(unsigned int16)node+size+sizeof(node_t)); 
....................                       insert_node_after(node,new); 
....................                      _STDLIBM_TRACK_WORST_DEC(nsize); 
....................                      _STDLIBM_TRACK_WORST_INC(size); 
....................                   } 
....................                   else//not enough space for new node in next node, so use original size 
....................                   { 
....................                       update_node(node,nsize+nextsize+_MEMMGMT_CSIZE);// update block 
....................                       remove_node(temp); 
....................                   } 
....................                } 
....................                else  //next block free but too small for new size 
....................                { 
....................                   newptr = malloc(size);  //use malloc to find new block 
....................                   if(newptr == NULL) 
....................                      return(NULL);        //return NULL if malloc was unable to find new block 
....................                     
....................                   memcpy(newptr, ptr, nsize);   //copy original data to new block 
....................                   free(ptr);                    //free original block 
....................                   return(newptr);               //return new pointer 
....................                } 
....................             } 
....................             else  //next block not free 
....................             { 
....................                newptr = malloc(size);  //use malloc to find new block 
....................                if(newptr == NULL)       
....................                   return(NULL);        //return NULL if malloc was unable to find new block 
....................                 
....................                memcpy(newptr, ptr, nsize);   //copy original data to new block 
....................                free(ptr);                    //free original block 
....................                return(newptr);               //return new pointer 
....................             } 
....................          } 
....................          return (char *)node+sizeof(node_t); // return pounsigned int8er to the reallocated block 
....................       } 
....................       else // not allocated use malloc 
....................       { 
....................          return(malloc(size)); 
....................       } 
....................    } 
....................  } 
....................   
.................... typedef struct 
.................... { 
....................    size_t bytesUsed; 
....................    size_t largestUsedSeg; 
....................    int segmentsUsed; 
....................    size_t bytesFree; 
....................    size_t largestFreeSeg; 
....................    int segmentsFree; 
....................   #if defined(STDLIBM_TRACK_WORST_CASE) 
....................    size_t worstCaseBytesUsed; 
....................   #endif 
.................... } heap_status_t; 
....................  
.................... void GetHeapStatus(heap_status_t *pHeapStatus) 
.................... { 
....................    heap_status_t status; 
....................    node_t *node; 
....................    unsigned int16 nsize; 
....................     
....................    node=__DYNAMIC_HEAD; 
....................     
....................    memset(&status, 0, sizeof(status)); 
....................  
....................    while(node!=NULL) 
....................    { 
....................       nsize = node->size; 
....................       node = node->next; 
....................        
....................       if(!bit_test(nsize, _MEMMGMT_POS)) // node free 
....................       { 
....................          status.bytesFree += nsize; 
....................           
....................          status.segmentsFree++; 
....................           
....................          if (nsize > status.largestFreeSeg) 
....................          { 
....................             status.largestFreeSeg = nsize; 
....................          } 
....................       } 
....................       else 
....................       { 
....................          bit_clear(nsize, _MEMMGMT_POS); 
....................           
....................          status.bytesUsed += nsize; 
....................           
....................          status.segmentsUsed++; 
....................           
....................          if (nsize > status.largestUsedSeg) 
....................          { 
....................             status.largestUsedSeg = nsize; 
....................          } 
....................       } 
....................    } 
....................  
....................   #if defined(STDLIBM_TRACK_WORST_CASE) 
....................    status.worstCaseBytesUsed = _g_StdlibmWorstCaseBytesUsed; 
....................   #endif 
....................  
....................    memcpy(pHeapStatus, &status, sizeof(heap_status_t)); 
.................... } 
.................... #ENDIF 
....................  
....................  
.................... // configuration files   
.................... #include "pic_config.h" 
.................... //IF NO primary oscillator is used, no need for FCMEN or PRIMARY_SW 
.................... // or IESO; also for debug purposes place INTRC at IO pin RA6 
.................... // THINK ABOUT PUT config setting! and transitions out of sleep that require 
.................... // accurate timing for UART 
....................  
.................... /////////////////////Fuses Start/////////////////////////////////////////////// 
.................... #FUSES CCP2B3 //CCP2 input/output multiplexed with RB3 
.................... #FUSES CCP2D2 //CCP2 input/output multiplexed with RD2 
.................... #FUSES CCP3E0 //CCP3 input/output multiplexed with RE0 
.................... #FUSES HFOFST //High Frequency INTRC starts clocking CPU immediately  
.................... #FUSES HSH //High speed Osc, high power 16MHz-25MHz 
.................... #FUSES IESO //Internal External Switch Over mode enabled  
.................... #FUSES MCLR //Master Clear pin enabled  
.................... #FUSES NOBROWNOUT //No brownout reset  
.................... #FUSES NOCPB //No Boot Block code protection  
.................... #FUSES NOCPD //No EE protection  
.................... #FUSES NODEBUG //No Debug mode for ICD 
.................... #FUSES NOEBTR //Memory not protected from table reads  
.................... #FUSES NOEBTRB //Boot block not protected from table reads  
.................... #FUSES NOFCMEN //Fail-safe clock monitor disabled  
.................... #FUSES NOLVP //No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O  
.................... #FUSES NOPBADEN //PORTB pins are configured as digital I/O on RESET 
.................... #FUSES NOPLLEN //4X HW PLL disabled, 4X PLL enabled in software   
.................... #FUSES NOPROTECT //Code not protected from reading  
.................... #FUSES NOWRT //Program memory not write protected  
.................... #FUSES NOWRTB //Boot block not write protected  
.................... #FUSES NOWRTC //configuration not registers write protected  
.................... #FUSES NOWRTD //Data EEPROM not write protected  
.................... #FUSES NOXINST //Extended set extension and Indexed Addressing mode disabled (Legacy mode)  
.................... #FUSES PRIMARY_SW //Primary clock can be disabled in software  
.................... #FUSES PUT //Power Up Timer 
.................... #FUSES STVREN //Stack full/underflow will cause reset 
.................... #FUSES TIMER3B5 //Timer3 Clock In is on pin B5  
.................... #FUSES WDT32768 //Watch Dog Timer uses 1:32768 Postscale  
.................... #FUSES WDT_SW //No Watch Dog Timer, enabled in Software  
.................... //#FUSES WDT //Watch Dog Timer enabled.  
.................... /////////////////////Fuses End///////////////////////////////////////////////// 
....................                                            
.................... /////////////////////Serial and I2C Timing Setup Start///////////////////////// 
.................... #use delay(clock=3,686,400)  
.................... #use RS232 (uart1, baud=115200)        
.................... #use delay(clock=250KHZ) 
.................... // setup i2c for use on 250khz main clock 
.................... #use i2c(master, I2C1, NOINIT, FORCE_HW, SLOW) 
.................... #use  fast_io(all) 
.................... /////////////////////Serial and I2C Timing Setup End/////////////////////////// 
....................  
.................... /////////////////////Special Function Registers Start////////////////////////// 
....................  
.................... #byte    WREG     =  0x0FE8 
.................... #byte    STATUS   =  0x0FD8 
.................... #BIT     CARRY       =  STATUS.0 
....................  
.................... #byte    STKPTR   =  0x0FFC 
.................... #BIT     STKUNF      = STKPTR.6 
.................... #BIT     STKFUL      = STKPTR.7 
....................  
.................... #byte    RCON     =  0x0FD0 
.................... #BIT     IPEN        = RCON.7 
....................  
.................... #byte    INTCON   =  0x0FF2 
.................... #BIT     RBIF        = INTCON.0 
.................... #BIT     INT0IF      = INTCON.1 
.................... #BIT     TMR0IF      = INTCON.2                                                                                                           
.................... #BIT     RBIE        = INTCON.3 
.................... #BIT     INT0IE      = INTCON.4 
.................... #BIT     TMR0IE      = INTCON.5                                                                                                    
.................... #byte    INTCON2  =  0x0FF1 
.................... #BIT     RBPU        = INTCON2.7   
.................... // RBPU lo to allow individual PORTB pullups 
.................... #byte    INTCON3  =  0x0FF0   
.................... #BIT     INT1IF      =  INTCON3.0 
.................... #BIT     INT2IF      =  INTCON3.1 
....................  
.................... #byte    T0CON    =  0x0FD5 
.................... #BIT     TMR0ON      = T0CON.7 
....................  
.................... #byte    OSCCON   =  0x0FD3 
.................... #BIT     SCS0        = OSCCON.0 
.................... #BIT     SCS1        = OSCCON.1 
.................... #BIT     HFIOFS      = OSCCON.2 
.................... #BIT     OSTS        = OSCCON.3 
.................... #BIT     IDLEN       = OSCCON.7 
.................... #byte    OSCCON2  =  0x0FD2 
.................... #BIT     LFIOFS      = OSCCON2.0 
.................... #BIT     MFIOFS      = OSCCON2.1 
.................... #BIT     PRISD       = OSCCON2.2 
.................... #BIT     SOSCGO      = OSCCON2.3 
.................... #BIT     MFIOSEL     = OSCCON2.4 
.................... #BIT     SOSCRUN     = OSCCON2.6 
.................... #BIT     PLLRDY      = OSCCON2.7 
.................... #byte    OSCTUNE  =  0x0F9B 
.................... #BIT     PLLEN       = OSCTUNE.6 
.................... #BIT     INTSRC      = OSCTUNE.7 
....................  
.................... // Timer registers 
.................... #byte    TMR1H    =  0x0FCF 
.................... #byte    TMR1L    =  0x0FCE 
.................... #byte    T1CON    =  0x0FCD 
.................... #BIT     TMR1ON      = T1CON.0 
.................... #byte    T1GCON   =  0x0FCC 
.................... #BIT     T1GGO       = T1GCON.3 
....................  
.................... #byte    T2CON    =  0x0FBA 
.................... #BIT     TMR2ON      = T2CON.2 
.................... #BIT     T2CKPS0     = T2CON.0 
.................... #BIT     T2CKPS1     = T2CON.1 
.................... #byte    PR2      =  0x0FBB 
....................  
.................... #byte    TMR3H    =  0x0FB3 
.................... #byte    TMR3L    =  0x0FB2 
.................... #byte    T3CON    =  0x0FB1 
.................... #BIT     TMR3ON      =  T3CON.0 
.................... #byte    T3GCON   =  0x0FB4 
.................... #BIT     T3GGO       = T3GCON.3 
....................  
.................... #byte    T4CON    =  0x0F51 
.................... #BIT     TMR4ON      = T4CON.2 
.................... #byte    PR4      =  0x0F52 
....................  
....................  
.................... #byte    TMR5H    =  0x0F50 
.................... #byte    TMR5L    =  0x0F4F      
.................... #byte    T5CON    =  0x0F4E 
.................... #BIT     TMR5ON      = T5CON.0 
.................... #byte    T5GCON   =  0x0F4D 
.................... #BIT     T5GGO       = T5GCON.3 
....................  
.................... #byte    T6CON    =  0x0F4A 
.................... #BIT     TMR6ON      = T6CON.2 
.................... #byte    PR6      =  0x0F4B 
....................  
.................... // ADC registers 
.................... #word    ADRES    =  0x0FC3 
.................... #byte    ADCON0   =  0x0FC2 
.................... #BIT     ADON        =  ADCON0.0 
.................... #BIT     ADGO        =  ADCON0.1 
.................... #byte    ADCON2   =  0x0FC0 
.................... #define  ADC_SETUP_DEF  0xFF   // right justified read, 20TAD acquisition time (insurance), FRC 
....................  
.................... // CCP registers       
.................... #byte    CCPR1H   =  0x0FBF 
.................... #byte    CCPR1L   =  0x0FBE 
.................... #byte    CCP1CON  =  0x0FBD 
.................... #byte    CCPR2H   =  0x0F68 
.................... #byte    CCPR2L   =  0x0F67 
.................... #byte    CCP2CON  =  0x0F66 
.................... #byte    CCPR3H   =  0x0F5F 
.................... #byte    CCPR3L   =  0x0F5E 
.................... #byte    CCP3CON  =  0x0F5D 
.................... #byte    CCPR4H   =  0x0F59 
.................... #byte    CCPR4L   =  0x0F58 
.................... #byte    CCP4CON  =  0x0F57 
.................... #byte    CCPR5H   =  0x0F56 
.................... #byte    CCPR5L   =  0x0F55 
.................... #byte    CCP5CON  =  0x0F54 
....................  
.................... #byte    CCPTMRS0 =  0x0F49 
.................... #byte    CCPTMRS1 =  0x0F48 
.................... #byte    PSTR1CON =  0x0FB9 
.................... #byte    BAUDCON1 =  0x0FB8 
....................  
.................... #byte    SPBRGH1  =  0x0FB0 
.................... #byte    SPBRG1   =  0x0FAF 
.................... #byte    RCREG1   =  0x0FAE 
.................... #byte    TXREG1   =  0x0FAD 
.................... #byte    TXSTA1   =  0x0FAC 
.................... #BIT     TRMT1       = TXSTA1.1     // 1: empty xmit reg, 0: xmit in progress 
.................... #byte    RCSTA1   =  0x0FAB 
.................... #BIT     FERR1       = RCSTA1.2 
....................  
.................... #byte    PIR1     =  0x0F9E 
.................... #BIT     TMR1IF      = PIR1.0 
.................... #BIT     TMR2IF      = PIR1.1 
.................... #BIT     SSP1IF      = PIR1.3 
.................... #BIT     ADIF        = PIR1.6 
.................... #byte    PIR2     =  0x0FA1 
.................... #BIT     CCP2IF      = PIR2.0 
.................... #BIT     TMR3IF      = PIR2.1 
.................... #BIT     BCL1IF      = PIR2.3 
.................... #BIT     C1IF        = PIR2.6 
.................... #BIT     OSCFIF      = PIR2.7 
.................... #byte    PIR3     =  0x0FA4 
.................... #BIT     TMR5GIF     = PIR3.2 
.................... #BIT     TMR3GIF     = PIR3.1 
.................... #BIT     TMR1GIF     = PIR3.0 
.................... #byte    PIR4     =  0x0F7B 
.................... #BIT     CCP3IF      = PIR4.0 
.................... #BIT     CCP4IF      = PIR4.1 
.................... #BIT     CCP5IF      = PIR4.2 
.................... #byte    PIR5     =  0x0F7E 
.................... #BIT     TMR4IF      = PIR5.0 
.................... #BIT     TMR5IF      = PIR5.1 
.................... #BIT     TMR6IF      = PIR5.2 
....................  
.................... #byte    PIE1     =  0x0F9D 
.................... #BIT     TMR2IE      =  PIE1.1 
.................... #byte    PIE2     =  0x0FA0 
.................... #BIT     CCP2IE      =  PIE2.0 
.................... #byte    PIE3     =  0x0FA3 
.................... #byte    PIE4     =  0x0F7A 
.................... #byte    PIE5     =  0x0F7D 
....................  
.................... #byte    IPR1     = 0x0F9F 
.................... #byte    IPR2     = 0x0FA2 
.................... #byte    IPR3     = 0x0FA5 
.................... #byte    IPR4     = 0x0F7C 
.................... #byte    IPR5     = 0x0F7F 
....................  
.................... #byte    LATA     =  0x0F89 
.................... #byte    PORTA    =  0x0F80 
.................... #byte    TRISA    =  0x0F92 
.................... #byte    LATB     =  0x0F8A 
.................... #byte    PORTB    =  0x0F81 
.................... #byte    TRISB    =  0x0F93 
.................... #byte    LATC     =  0x0F8B 
.................... #byte    PORTC    =  0x0F82 
.................... #byte    TRISC    =  0x0F94 
.................... #byte    LATD     =  0x0F8C 
.................... #byte    PORTD    =  0x0F83 
.................... #byte    TRISD    =  0x0F95 
.................... #byte    LATE     =  0x0F8D 
.................... #byte    PORTE    =  0x0F84 
.................... #byte    TRISE    =  0x0F96 
....................  
.................... #byte    PSTR2CON =  0x0F63 
.................... #byte    IOCB     =  0x0F62 
.................... #byte    WPUB     =  0x0F61 
.................... #byte    PSTR3CON =  0x0F5A 
....................  
.................... #byte    CM1CON0  =  0x0F79 
.................... #bit     C1ON        = CM1CON0.7 
.................... #bit     C1POL       = CM1CON0.4 
.................... #byte    CM2CON0  =  0x0F78 
.................... #byte    CM2CON1  =  0x0F79 
....................  
.................... #byte    VREFCON0 =  0x0F42 
.................... #bit     FVREN    =  VREFCON0.7     //fixed voltage ref enable 
.................... #bit     FVRST    =  VREFCON0.6     //fixed voltage ref stable 
.................... #bit     FVRS1    =  VREFCON0.5     //fixed voltage select 1 
.................... #bit     FVRS0    =  VREFCON0.4     //fixed voltage select 0 
.................... #byte    VREFCON1 =  0x0F41 
.................... #byte    VREFCON2 =  0x0F40 
....................  
.................... #byte    PMD0     =  0x0F3F 
.................... #byte    PMD1     =  0x0F3E 
.................... #byte    PMD2     =  0x0F3D 
.................... #byte    CTMUICON =  0x0F43 
.................... #byte    CTMUCONL =  0x0F44 
.................... #byte    CTMUCONH =  0x0F45 
.................... #byte    SRCON1   =  0x0F46 
.................... #byte    SRCON0   =  0x0F47 
....................  
.................... #byte    SSP1CON2 =  0x0FC5 
.................... #BIT     SEN         = SSP1CON2.0 
.................... #BIT     PEN         = SSP1CON2.2 
.................... #byte    SSP1CON1 =  0x0FC6 
.................... #BIT     WCOL        = SSP1CON1.7 
.................... #byte    SSP1STAT =  0x0FC7 
.................... #BIT     I2CBUSY     = SSP1STAT.0 
....................  
.................... #define  RCON_INIT    0b00010011 
.................... // OR with RCON to SET BORn, PORn and RIn bits 
....................  
.................... /////////////////////Special Function Registers End//////////////////////////// 
....................  
.................... /////////////////////I/0 Lines and Initialization Start//////////////////////// 
....................   
.................... //  PORTA/B/C _ COLD and TRISA/B/C _ NORM are fine for lowest_pwr() I/O setup 
....................  
.................... ////////////////////ADC channel choices 
.................... #define V_EXT_REF    0        // AN0 = RA0, 1.2V accurate reference 
....................                               // use 1.2V accurate ref for measurements 
.................... #define V_VLVI       1        // AN1 = RA1 
.................... #define V_GEN        12       // AN12 = RB0 (INT0) 
.................... #define V_XDC        13       // Extra IO 1, now used for XDCR measurements 
....................       
.................... #define V_DAC        30       // DAC output may be read by ADC 
.................... #define V_FIXED      31       // 1.024/2.048/4.096V Fixed Reference (internal) 
....................  
....................  
.................... ////////////////////PORT A///////////////////// 
....................  
.................... //    V_EXT_REF    PIN_A0      // external reference, analog AN0 
.................... //    V_VLVI       PIN_A1      // sense line, valve motor current, analog AN1 
.................... #define LED2n        PIN_A2      // RA2 output, active lo 
.................... #define MOTE_RX_CTSn PIN_A3      // RA3 input active lo 
....................                                  //  mote asserts to tell micro it is 
....................                                  //  clear to rcv data from micro; 
....................                                  //  was _DUST_MTCTS 
....................                                  //  set as output, init hi 
.................... #define GPS_PWRn     PIN_A4      // RA4 output, active lo 
.................... #define MOTE_TX_CTSn PIN_A5      // RA5 output, active lo,  
....................                                  //  assert to initiate rcv data from MOTE, 
....................                                  //  byte level handshake; 
....................                                  //  was _DUST_SPCTS                                
.................... //      OSC2         PIN_A6      // xtal osc output connection 
.................... //      OSC1         PIN_A7      // xtal osc input connection 
....................  
.................... #define TRISA_NORM   0b10001011 
....................                                  // A0 analog 
....................                                  // A1 analog 
....................                                  // A2 output 
....................                                  // A3 input 
....................                                  // A4 output 
....................                                  // A5 output 
....................                                  // A6 output 
....................                                  // A7 input 
.................... #define PORTA_INIT   0b01110100 
....................                                  // A0 analog (0) 
....................                                  // A1 analog (0)  
....................                                  // A2 output active lo (1) 
....................                                  // A3 input (0) 
....................                                  // A4 output active lo (1) 
....................                                  // A5 output active lo (1) 
....................                                  // A6 output (1) 
....................                                  // A7 input (0) 
.................... #define PORTA_IDLE   PORTA_INIT 
.................... #define PORTA_DEEP   PORTA_INIT 
....................  
....................  
.................... ////////////////////PORT B//////////////////// 
....................  
.................... #define V_GEN_INT    PIN_B0      // RB0 input, high for significant v_gen; 
....................                                  //  generally analog, but may be input; 
....................                                  //  INT0 
....................                                   
.................... #define GPS_TXRDY    PIN_B1      // RB1 input, high indicates GPS has data 
....................                                  //  ready to transmit to micro 
....................                                   
.................... #define MOTE_TX_RTSn PIN_B2      // RB2 input, active lo 
....................                                  //  mote asserts to tell micro it is 
....................                                  //   ready to send data to micro; 
....................                                  //  was _DUST_MTRTS; INT2    
....................                                   
.................... #define LTC3105_CTRL PIN_B3      // output, active hi, P2A-pwm, 
....................                                  //  shdn/enab input of 3105 
....................                                  //  hi for max chg aggressiveness (lower RPM) 
....................  
.................... #BIT    LTC3105_CTRL_pinstate   = LATB.3 
....................  
....................  
.................... #define SW1n         PIN_B4      // usually an input, active lo 
....................                                  //  note can be IOC 
.................... #define LED1n        PIN_B4      // may become an output, active lo 
....................  
.................... #define ADC_XDCR     PIN_B5      // wired as input (ADC) to analog XDCR signal 
....................                                                                  
.................... #define SPARE2       PIN_B6      // consider as an input (PGC); 
....................                                  //  wired to VLV_XDCR header     
.................... #define SPARE3       PIN_B7      // consider as an input (PGD) 
....................  
.................... #define TRISB_NORM   0b11110111 
....................                                  // B0 input (INT0) 
....................                                  // B1 input (INT1) 
....................                                  // B2 input (INT2) 
....................                                  // B3 output 
....................                                  // B4 input (usually, may become an output) 
....................                                  // B5 input (spare) 
....................                                  // B6 input (PGC) 
....................                                  // B7 input (PGD)                                             
.................... #define TRISB_LED    0b11100111 
....................                                  // same as TRISB_NORM, but PIN_B4 is output 
....................                                                                                 
.................... #define PORTB_INIT   0b00011000 
....................                                  // B0 input (0) 
....................                                  // B1 input (0) 
....................                                  // B2 input (0) 
....................                                  // B3 output (LTC3105_CTRL) hi=fully charge (1) 
....................                                  // B4 usually an input,  
....................                                  //   may be output active lo (1) 
....................                                  // B5 input unused (0) 
....................                                  // B6 may be spare I/O (PGC)  
....................                                  // B7 may be spare I/O (PGD) 
.................... #define PORTB_IDLE   0b00010000  // only difference here is that LTC3105 is 
....................                                  //  shut down              
.................... #define PORTB_DEEP   PORTB_IDLE 
....................  
....................                                    
.................... #define PORTB_PULLUPS            0b00010010 
.................... #define PORTB_PULLUPS_WITH_XDCR  0b00110010             
....................                                  // only MOTE_TX_RTSn (pin B2)  
....................                                  // and SW1/LED1 are pulled up by defualt. 
....................                                  // ADC_XDCR (pin B5) is turned on for a second to detect  
....................                                  //    if the XDCR is plugged in or not during XDCR_init()   
....................                                                                         
....................                                 
....................                                                                                             
.................... ////////////////////PORT C//////////////////// 
....................  
.................... //      SOSCO        PIN_C0      // xtal osc output connection 
.................... //      SOCSI        PIN_C1      // for debug, we can look at frequency here 
.................... #define BRK_CTRLn    PIN_C2      // P1A-pwm, to gates of FETs -- 
....................                                  //  lo for max braking force, hi for no brake 
....................  
.................... #BIT     BRK_pinstate   = LATC.2                               
....................  
.................... //      SCL1         PIN_C3      // I2C clock 
.................... //      SDA1         PIN_C4      // I2C data 
.................... #define XDCR_PWR     PIN_C5      // output, active hi 
.................... //      MOTE_RX      PIN_C6      // UART1 TX output 
.................... //      MOTE_TX      PIN_C7      // UART1 RX input 
....................  
.................... #define TRISC_NORM   0b10011010 
....................                                  // C0 output 
....................                                  // C1 input 
....................                                  // C2 output 
....................                                  // C3/C4 inputs (I2C) 
....................                                  // C5 output 
....................                                  // C6 output (UART TX / MOTE_RX) 
....................                                  // C7 input  (UART RX / MOTE_TX) 
....................  
.................... #define PORTC_INIT   0b01000101 
....................                                  // C0 output (1) 
....................                                  // C1 input (0) 
....................                                  // C2 output (SPD_CTRL hi=no braking) (1) 
....................                                  // C3/4 I2C, init as inputs (0) 
....................                                  // C5 output active hi (0) 
....................                                  // C6 output (1) 
....................                                  // C7 input (0) 
.................... #define PORTC_IDLE   PORTC_INIT 
.................... #define PORTC_DEEP   PORTC_INIT 
....................  
.................... ////////////////////PORT D//////////////////// 
.................... #define GPS_ON       PIN_D0      // output, active hi 
.................... #define MOTE_TIMEn   PIN_D1      // output, active lo, gets time from mote 
.................... #define LCD_RESETn   PIN_D2      // output, active lo 
.................... #define AUX_PWR      PIN_D3      // output, active hi, turns on AUX pwr 
.................... #define MOTE_RESETn  PIN_D4      // output, active lo 
.................... #define MOTE_RX_RTSn PIN_D5      // output, active lo 
....................                                  //  micro asserts to tell mote it is  
....................                                  //   ready to send data to mote 
.................... #define GPS_RX       PIN_D6      // UART2 TX output 
.................... #define GPS_TX       PIN_D7      // UART2 RX input 
....................  
.................... #define TRISD_NORM   0b10000000 
....................                                  // D0 output 
....................                                  // D1 output 
....................                                  // D2 output (spare) 
....................                                  // D3 output 
....................                                  // D4 output 
....................                                  // D5 output 
....................                                  // D6 output 
....................                                  // D7 input 
....................  
.................... #define PORTD_INIT   0b01110110 
....................                                  // D0 output active hi (0) 
....................                                  // D1 output active lo (1) 
....................                                  // D2 output active lo (1) 
....................                                  // D3 output active hi (0) 
....................                                  // D4 output active lo (1) 
....................                                  // D5 output active lo (1) 
....................                                  // D6 output (1) 
....................                                  // D7 input (0) 
.................... #define PORTD_IDLE   PORTD_INIT 
.................... #define PORTD_DEEP   PORTD_INIT 
....................  
.................... ////////////////////PORT E//////////////////// 
.................... #define VLV_CTRL1    PIN_E0      // P3A-pwm, to H-bridge re valve  
.................... #define VLV_CTRL2    PIN_E1      // P3B-pwm, to H-bridge re valve 
.................... #define GEN_RPM      PIN_E2      // CCP5 input 
.................... //       MCLRn       PIN_E3 
....................  
.................... #define TRISE_NORM   0b00001100 
....................                                  // E0 output 
....................                                  // E1 output 
....................                                  // E2 input 
....................                                  // E3 master clear input 
....................  
.................... #define PORTE_INIT   0b00000000 
....................                                  // E0 output (E0,E1 = 00 for coast state) 
....................                                  // E1 output 
....................                                  // E2 input (0) 
....................                                  // E3 input (0) 
.................... #define PORTE_IDLE   PORTE_INIT  // TURNS off the power supply to  
....................                                  //  the valve motor 
.................... #define PORTE_DEEP   PORTE_INIT 
....................  
.................... /////////////////////I/0 Lines and Initialization End////////////////////////// 
....................  
....................  
.................... /////////////////////Timer 0 Start///////////////////////////////////////////// 
....................  
.................... // THESE VALUES ARE DEPENDENT UPON CRYSTAL FREQUENCY 
.................... // Modify with care 
.................... #define  T0_OSC    4340 
.................... // After calibration of 1MHz HFINTOSC timebase to 921.6KHz: 4/Fosc = 4340 nsec 
....................  
.................... // Assume 16 bit timer0 input is FOSC div 128 (timer 0 prescaler) 
.................... // Thus one count every 128*T0_OSC nanoseconds                      
.................... #define T0_SETUP(MS) {  setup_timer_0(T0_DIV_128); \ 
....................                         set_timer0(65536 - (1000000*MS + 64*T0_OSC)/(128*T0_OSC)); } 
.................... // Note roundoff fix                     
.................... // For use with the routine setup_T0_int(*) 
....................  
.................... //Timer 0 options 
.................... #define  T0_500US    65534 
.................... #define  T0_1MS      65536 - 1000/256 
.................... #define  T0_10MS     65536 - 10000/256 
.................... #define  T0_20MS     65536 - 20000/256 
.................... #define  T0_50MS     65536 - 50000/256 
.................... #define  T0_100MS    65536 - 100000/256 
.................... #define  T0_175MS    65536 - 175000/256 
.................... #define  T0_250MS    65536 - 250000/256 
.................... #define  T0_500MS    65536 - 500000/256 
.................... #define  T0_1S       65536 - 1000000/256 
.................... #define  T0_2S       65536 - 2000000/256 
.................... #define  T0_3S       65536 - 3000000/256 
.................... #define  T0_4S       65536 - 4000000/256 
.................... #define  T0_6S       65536 - 6000000/256 
.................... #define  T0_16S      65536 - 16000000/256 
.................... // the max is actually 16.7 seconds 
....................  
.................... /////////////////////Timer 0 End/////////////////////////////////////////////// 
....................  
.................... /////////////////////Timer 2 Start///////////////////////////////////////////// 
....................  
.................... // For use with the routine setup_T2_int(*) 
.................... // The equivalent tick duration for timer2 is 
.................... //  adjusted depending on Fosc to be approx 256usec 
.................... // Timer2 counts up from 0 to match PR2 in order to set int flag 
.................... #define T2_1MS       3 
.................... #define T2_2MS       7 
.................... #define T2_3MS       11 
.................... #define T2_4MS       15 
.................... #define T2_5MS       19 
.................... #define T2_6MS       23 
.................... #define T2_7MS       27 
.................... #define T2_8MS       31 
.................... #define T2_9MS       35 
.................... #define T2_10MS      39 
.................... #define T2_15MS      59 
.................... #define T2_20MS      79 
.................... #define T2_25MS      99 
.................... #define T2_30MS      119 
.................... #define T2_40MS      159 
.................... #define T2_50MS      199 
.................... #define T2_60MS      239 
.................... #define T2_64MS      255 
.................... // cannot set to higher than 64 milliseconds  
....................  
.................... ////////////////////Timer 2 End//////////////////////////////////////////////// 
....................  
.................... /////////////////////Timer 4 Start///////////////////////////////////////////// 
....................  
.................... // For use with the routine setup_T4_int(*) 
.................... // The equivalent tick duration for timer4 is 
.................... //  adjusted depending on Fosc to be approx 256usec 
.................... // Timer4 counts up from 0 to match PR4 in order to set int flag 
.................... #define T4_500US     1 
.................... #define T4_1MS       3 
.................... #define T4_2MS       7 
.................... #define T4_3MS       11 
.................... #define T4_4MS       15 
.................... #define T4_5MS       19 
.................... #define T4_6MS       23 
.................... #define T4_7MS       27 
.................... #define T4_8MS       31 
.................... #define T4_9MS       35 
.................... #define T4_10MS      39 
.................... #define T4_15MS      59 
.................... #define T4_20MS      79 
.................... #define T4_25MS      99 
.................... #define T4_30MS      119 
.................... #define T4_40MS      159 
.................... #define T4_50MS      199 
.................... #define T4_60MS      239 
.................... #define T4_64MS      255 
.................... // cannot set to higher than 64 milliseconds  
....................  
.................... ////////////////////Timer 4 End//////////////////////////////////////////////// 
....................  
.................... ////////////////////LED Defines Start////////////////////////////////////////// 
.................... #define LED1_ON       disable_interrupts(INT_RB); set_tris_b(TRISB_LED); output_low(LED1n); 
.................... #define LED1_OFF      set_tris_b(TRISB_NORM); RBIF=FALSE; enable_interrupts(INT_RB); 
....................  
.................... #define LED2_ON       output_low(LED2n); 
.................... #define LED2_OFF      output_high(LED2n); 
....................  
.................... ////////////////////LED Defines End//////////////////////////////////////////// 
....................  
....................  
....................  
.................... ////////////////////Battery-Voltage Start////////////////////////////////////// 
.................... // magic number based upon 4 samples averages with 1.2V reference! 
.................... // 12.20 format (4.8V) 
.................... #define VAL32_FVR_BAT      4.8 * 1048576 // 5033164.8 = 4CCCCD 
....................  
.................... ////////////////////Battery-Voltage End//////////////////////////////////////// 
....................  
....................  
....................  
.................... ////////////////////Restart Causes Start/////////////////////////////////////// 
.................... /* 
.................... // reset_cause is set to one of these values before any reset_cpu instruction 
....................  
.................... #define WARM_RESTART          0x00  // commanded: joins if needed 
.................... #define SPIN_RESTART          0x10  // generator wakeup from Deep sleep  
....................                                     //  or idle sleep 
....................                                     //  like WARM_RESTART                                         
.................... #define FRC_RJOIN_RESTART     0x20  // commanded to duplicate behavior of 
....................                                     //  unexpected mote state change during 
....................                                     //  RUN; like WARM_RESTART; mote rejoins 
....................                                     //  and informs manager 
.................... #define RJOIN_RESTART         0x30  // unexpected mote state change during 
....................                                     //  RUN; like WARM_RESTART; mote rejoins 
....................                                     //  and informs manager   
.................... #define COLD_RESTART          0x50  // commanded: force join 
.................... */ 
.................... ////////////////////Restart Causes End///////////////////////////////////////// 
....................  
.................... ////////////////////Extra LCD Start//////////////////////////////////////////// 
.................... /* 
.................... // New Haven display part number NHD-C0216CIZ-FSW-FBW-3V3 special characters 
.................... #define  CROSS_CHAR        0xF7 
.................... // small cross 
.................... #define  BOX_CHAR          0xDB 
.................... // rectangle 
.................... #define  TOPLINE_CHAR      0xFF 
.................... // top line designates battery full, no charging needed 
.................... #define  NOTEQU_CHAR       0xFD 
.................... // equ with slash 
.................... #define  NOCHG_CHAR        0xE4 
.................... // c with slash, cent symbol, indicates charger circuit OFF 
.................... #define  MAXCHG_CHAR       'C' 
.................... #define  MINBRAKE_CHAR     'b' 
.................... #define  MAXBRAKE_CHAR     'B' 
.................... // PFHI character, indicates maximum braking force 
.................... #define  NOVLV_CHAR        'v' 
.................... // a PERIOD indicates valve PWM set for NO MOTION 
.................... #define  MAXVLV_CHAR       'V' 
.................... // ! indicates valve PWM set for MAX speed 
....................  
.................... #define  APPOS_CHAR        0x27 
.................... // appostrophe character: ' 
....................  
....................  
.................... //#define  APPROX_CHAR       0x00 
.................... // custom approx equal character loaded at LCD_INIT 
....................  
.................... // custom characters loaded during LCD_INIT 
.................... #define  LEV1_CHAR         0x00 
.................... #define  LEV2_CHAR         0x01 
.................... #define  LEV3_CHAR         '_' 
.................... #define  LEV4_CHAR         0x02 
.................... #define  LEV5_CHAR         0x03 
.................... #define  LEV6_CHAR         '-' 
.................... #define  LEV7_CHAR         0x04 
.................... #define  LEV8_CHAR         0x05 
.................... #define  LEV9_CHAR         0x06 
.................... #define  LEV10_CHAR        0xFF 
....................  
.................... #define  BIGBOX_CHAR       0x07 
.................... #define  WAYLOW_CHAR       0xFB 
.................... // << 
.................... #define  WAYHI_CHAR        0xFC 
.................... // >> 
.................... #define  CIRCLE_CHAR       0xF2 
.................... // small circle 
....................  
.................... */ 
.................... ////////////////////Extra LCD End////////////////////////////////////////////// 
.................... ////////////////////EEPROM Locations Start///////////////////////////////////// 
....................  
.................... // EEPROM LOCATIONS 
.................... #define EE_ADDCHG_DUR      0x0002 
....................    // Configures add-charging time in seconds 
....................    // 2 bytes, low byte at 0x0002 
.................... #define ADDCHG_DUR_DEF     4 
....................    // 4 minutes? 
.................... #define EE_PRECHG_DUR      0x0004 
....................    // Configures precharging time in seconds 
....................    // 2 bytes, low byte at 0x0004 
.................... #define PRECHG_DUR_DEF     10 
....................    // 1.5 minutes?  
.................... #define CHGLOOPS_PER_MIN   110 
....................    // determined experimentally, each loop is about 545 msec 
....................    //  which is a bit longer than I would prefer (!), but oh well. 
....................    //  JG 2015 Jun16 
....................     
.................... // 0x00A thru 0x00F        reserved 
.................... #define EE_NETW_ID         0x0010 
....................    // 2 bytes, low byte at 0x0010; for now, network ID defaults to 0x04CD. 
.................... #define EE_PRENETW_ID      0x0012 
....................    // 2 bytes, low byte at 0x0012; for now, network ID defaults to 0x04CD. 
....................  
....................  
.................... // 0013 reserved 
.................... #define EE_LOCATION     0x0014 
....................    // 2 bytes, low byte at 0x0014; associates sprinkler with particular 
....................    //  physical location on CP 
.................... #define EE_PRELOCATION  0x0016 
....................    // 2 bytes, low byte at 0x0016, previous association of sprinkler with 
....................    //  particular physical location on CP 
....................  
....................    // 0x018 thru 0x01F     reserved 
....................  
.................... // IDLE behavior specified at 0x0020 thru 0x0033 
.................... #define EE_IDLE_OPT        0x0020 
....................    // Configures IDLE behavior.  Applies if battery low during operational 
....................    //  state 
....................    //  0x00  send out Panic Message once when panic level is reached according 
....................    //         to voltage-based algorithm 
....................    //  0x01  send out Panic Message once when panic level is reached according 
....................    //         to charge-based algorithm 
.................... #define MAX_IDLE_OPT       1 
....................    // If manager tries to write any idle_opt value larger than this to EEPROM 
....................    //  a NACK occurs; see above for idle option choices 
.................... #define LEN_IDLE_BLOCK     15 
....................    // There are 15 bytes in the idle block 
....................  
.................... #define EE_IDLE_PROFILE    0x0021 
....................    // Saved only upon entering IDLE state; 
....................    //  profile number which was running or had last been run. 
....................    // 0 for default profile, 1, 2, 3 for controller-specified profile choices 
....................    //  other numbers, use 0 
.................... #define EE_IDLE_STEP       0x0022 
....................    // Saved only upon entering IDLE state; 
....................    //  step number of profile which was running or had last been run. 
....................    //  Step 0xFF indicates that we were not within a profile 
....................    //  Step 0x10 thru 0xFE invalid. 
.................... #define EE_IDLE_STIME      0x0023 
....................    // 2 bytes, low byte at 0x0023, high byte at 0x0024 
....................    // Saved only upon entering IDLE state; 
....................    //  amount of time in seconds that rate was controlled according 
....................    //  to EE_IDLE_STEP at time when IDLE state entered; 
....................    //  set to 0x0000 if EE_IDLE_STEP=0xFF. 
.................... #define EE_IDLE_LOOP       0x0025 
....................    // 2 bytes, low byte at 0x0025, high byte at 0x0026 
....................    // Saved only upon entering IDLE state; 
....................    //  for looping profiles, loop number at time when IDLE state entered; 
....................    //  set to 0x0000 for non-looping profiles, set to 
....................    //  0x0000 if EE_IDLE_STEP=0xFF. (looping beyond 0xFFFF is recorded as 
....................    //  0xFFFF) 
.................... #define EE_IDLE_CHG        0x0027 
....................    // 2 bytes, low byte at 0x0027, high byte at 0x0028 
....................    // Configures used charge in millicoulombs for 
....................    //  charge-based shutdown method (TBD); applies if EE_IDLE.1 is set 
.................... #define EE_IDLE_SHDN_DLY   0x0029 
....................    // 2 bytes, low byte at 0x0029, high byte at 0x002A 
....................    // Configures time in units of 67 secs (TMR0 ints during IDLE) 
....................    //  between sensing of low battery and self-shutdown 
....................  
.................... ////////////////////EEPROM Locations End/////////////////////////////////////// 
.................... //*************************************************************** 
.................... /* 
.................... #define DAY_SECS           24*3600 
....................  
.................... #define VAL32_FVR_BAT      4.8 * 1048576 // 5033164.8 = 4CCCCD 
.................... // magic number based upon 4 samples averages with 1.2V reference! 
.................... // 12.20 format (4.8V) 
....................  
.................... #define NETWORK_ID_DEF  0x04CD 
.................... // 04CD flipped bytes to match received network ID (JG!~?) 
.................... // this is the net_id for BlueBox#0 
.................... #define NETWORK_ID_MAX  NETWORK_ID_DEF + 250 
.................... // We could actually go from 0 (0x04CD) to 254, with 255 being illegal 
.................... //  as what would be read from cleared EEPROM 
....................  
.................... #define MAX_SP_NUM      499 
.................... // based on maximum number of motes that can be supported by Blue Box 
.................... #define MAX_SP_CP       200 
.................... // highest sprinkler number which uses the WARNER VALVE parameters 
.................... //  otherwise uses the BENCH VALVE SIMULATOR parameters 
....................  
.................... // state of charge levels 
....................  
.................... #define R2T             23040 
....................    // 0x00005A00 
....................    // Divide this number by RPM to get the target CCP2 capture value 
....................    //  representative of speed. 
....................    // 23040 RPM/(CCP2-prev_count) = 19200Hz * 6/5, where 19.2KHz is fosc/4, 
....................    //  (1 rising edge occurs per capture event) and 6/5 RPM/Hz is the 
....................    //  generator-dependent relationship between its output frequency and its 
....................    //  RPM. 
....................    // For example, 10RPM results in 2304 counts in the capture register 
.................... #define R2Tx4      R2T*4 
....................  
.................... #define VMOTION_TIMEOUT    60 
.................... // if valve travels longer than this time, a timeout error occurs 
....................  
.................... #define RPM_MIN            4 
.................... #define RPM_MAX            400 
.................... // when target_RPM = 0, we are in a braking mode 
....................  
.................... #define PERIOD_5RPM        4608 
....................  
.................... #define SHUT_DEL_DEF       30 
.................... // default shutdown delay to ensure that all motes get broadcast msg: 30 sec 
.................... // also used to ensure that manager acknowledges errors and first_msg in a  
.................... //  timely manner (else there will be a repeat 
.................... #define REPEAT_LIMIT       4 
.................... // number of times that an unsolicited msg will repeat waiting for an 
.................... //  ACK from the manager. 
....................  
.................... #define STARTUP_DELAY      4 
.................... // delay in units of 1/4 sec at startup before opening valve for 
.................... //  first time 
....................  
.................... #define RSSI_MIN           -64 
.................... // -64 dBm; minimum rssi of an advertising message required 
.................... //   for that network to be a viable net to join 
.................... // BRIAN, this value may be TOO SENSITIVE 
.................... #define LISTEN_TIME        20 
.................... // number of seconds to dwell in promiscuous hi-power listen mode 
.................... //  in search of networks to join when mote has been cold-booted 
.................... // MUST be 1-27 -- 15s is occassionally too short a time 
.................... #define LISTEN_T1          65536 - LISTEN_TIME*2400 
.................... // 76.8KHz clock (19.2KHz counting up at timer1 div8.... 
....................  
....................  
.................... #define TIMER2_SETUP_XTAL        T2_DIV_BY_4, 199, 8 
.................... // for 3.6864MHz xtal, this is the value used in setup_timer_2  
.................... // to achieve 1152Hz PWM frequency (for braking purposes) 
.................... // AND interrupt rate (used for valve algorithms) of 144Hz 
.................... //  (check valve current approx once every 7msec) 
.................... // Increments "RTC" by 7 when keeping track of time (about 0.8% fast!) 
.................... #define FAST_CLK  0 
.................... #define FAST_MS   7 
....................  
.................... #define TIMER2_SETUP_250K        T2_DIV_BY_1, 199, 16 
.................... // for 250KHz internal clock, this is the value used in setup_timer_2  
.................... // to achieve 312.5KHz PWM frequency (for braking purposes) 
.................... // AND interrupt rate of ~104Hz 
.................... // Increments "RTC" by 51 when keeping track of time (about 0.4% slow if  
.................... //    250KHZ internal clock is accurate, which it is not) 
.................... #define MED_CLK   1 
.................... #define MED_MS    51 
....................  
.................... #define TIMER2_SETUP_31K         T1_DIV_BY_1, 199, 4 
.................... // for 31KHz LFINTOSC (inaccurate), this is value used in setup_timner_2 
.................... // to achieve interrupt rate of 9.7Hz (103msec) 
.................... // Not meant to be accurate, no need for variable braking when running at 31KHz 
.................... #define SLOW_CLK  2 
.................... #define SLOW_MS   103 
....................  
.................... //#define TIMER3_CCP2_SETUP       T3_DIV_BY_8 | T3_CCP2 | T3_INTERNAL 
.................... #define TIMER3_CCP2_SETUP       T3_DIV_BY_8 | T3_INTERNAL 
.................... //  This is the value used by setup_timer_3 in order to monitor real time 
.................... //   and to provide a time reference (CCP_2) for measurement of sprinkler RPM. 
.................... // 3.6864MHz div4 div8 = 57.6KHz 
.................... //*****NOTE THIS IS AN ISSUE WITH 3.6864MHz clock 
....................  
.................... #define TIMER3_AD_SETUP           
.................... //  This is the value used by setup_timer_3 in order to automatically 
.................... //   have the ADC monitor the valve current during the initial closure 
.................... //   of the valve. 
.................... //  1.832MHz clock here.  Checks ADC  
....................  
.................... #define CCP1_BRK  CCP_PWM_H_H | CCP_PULSE_STEERING_A | CCP_PULSE_STEERING_SYNC 
.................... //  This is the value used by setup_ccp1 in order to enable PWM-controlled  
.................... //   braking 
.................... #define CCP1_CHG  CCP_PWM_H_H | CCP_PULSE_STEERING_D | CCP_PULSE_STEERING_SYNC 
.................... //  This is value used by setup_cc1 in order to enable PWM-controlled 
.................... //   charging level 
.................... #define CCP1_BOTHn (CCP_PWM_H_H | CCP_PULSE_STEERING_A | CCP_PULSE_STEERING_D | CCP_PULSE_STEERING_SYNC) 
.................... //  This value is sued during transitions to/from full battery situation 
.................... //   CCP_BOTHn provides for charge enable pulse and braking pulsing IN PHASE 
.................... #define CCP1_BOTHi (CCP_PWM_H_L | CCP_PULSE_STEERING_A | CCP_PULSE_STEERING_D | CCP_PULSE_STEERING_SYNC) 
.................... //  CCP_BOTHi provides for charge enable pulse and braking pulsing OUT OF PHASE 
....................  
.................... #define IDLE_LOOP_31       T2_DIV_BY_16,160,1 
.................... // setup for timer2 determines length of lo-power sleeping between 
.................... //  mote message checks -- basically and roughly times the idle loop 
.................... // 31KHz clock, T2 div 16, 160 counts -> 3Hz 
.................... //  thus overflow in about 330 msec 
.................... // For calculating battery check and time check and rejoin timeout, 
.................... //  we assume that each idle loop takes ~400msec.  Longer than 330 because 
.................... //  because of the execution of the steps after timer2 
.................... //  wakes us up and before we go back into idle_sleep.  [150 loops per minute] 
.................... // And note that LFINTOSC is a +/-10% (or so) oscillator, so idle timing 
.................... //  is rough. 
....................  
.................... /* 
.................... #define IDLE_LOOP_76       T2_DIV_BY_16,197,2 
.................... // setup for timer 2 determines length of sleeping between mote 
.................... //  message checks while idling 
.................... // With 76.8KHz clock, timer increments every 833.3usec;  
.................... //  overflows every 198*.833msec = 165msec; interrupts every 330msec 
.................... // (see idle_sleep routine) 
.................... #define IDLE_LOOPS_PERMIN   182 
.................... // This number based on discussion above; change IDLE_LOOP_76 and 
.................... //  IDLE_LOOPS_PERMIN together 
.................... //#define TIMECHK_IDLELOOPS  25 
....................  
.................... #define TIMECHK_IDLEMINS   300 
.................... // DEBUG SETTING FOR TEST: 5 hours.... 
.................... #define TIMECHK_IDLELOOPS  TIMECHK_IDLEMINS*IDLE_LOOPS_PERMIN 
.................... // This amounts to checking network time once every 10 mins. 
....................  
.................... #define TIMCHK_INTERVAL    3600 
.................... // number of seconds between timechecks when knowtime_fl = TRUE 
.................... #define BATCHK_INTERVAL    900 
.................... // number of seconds between battery checks! 
.................... #define BATCHK_MARCH       840 
.................... // what this means is that when there is a marching order change 
.................... //  we preset the batchk_timer to this value... 
.................... // Thus 60 seconds after the valve has been adjusted, we THEN 
.................... //  check battery health (which could lead to a charging on or off  
.................... //  transition..... 
....................  
.................... #define MAX_JOINTIME       1800 
.................... // SHOULD BE ABOUT 1/2 hour or 1800 secs!!!!!! 
.................... // seconds to wait for a join to happen 
.................... ///  even at 1/2 hr, MAY BE TOO SHORT for a full 500 count mesh! 
....................  
.................... #define JOIN_MINSMAX       30 
.................... // Number of minutes that we wait for mote to become operational after  
.................... //  the first join; then we say goodnight 
....................  
.................... #define FIRSTDANCE_INTERVAL   120 
.................... // retry the MSG_IDENTIFIER if no acknowledge within this interval 
....................  
.................... #define REJOIN_INTERVAL       1800 
.................... // number of seconds after which we give up on rejoining! 
.................... */ 
.................... /* 
.................... #define RUN_LOOPS_PERMIN   120 
.................... // assume we are consistently at 500msec per loop 
....................  
.................... #define REJOIN_TIMEOUT     1800 
.................... // number of seconds at which we decide to GIVE up on rejoining! 
.................... #define TIMECHK_RUNSECS    3600 
.................... // check net time every hour 
.................... #define BATCHK_RUNSECS     3600 
.................... // check battery at least every hour 
.................... #define REJOIN_RUNSECS     1800 
.................... // cannot join if have attempted for more than 1/2 hour 
.................... #define REJOIN_DISP_LIM    REJOIN_RUNSECS - 3 
.................... // display REJOIN message during run for 3 seconds after rejoin is 
.................... //  initiated 
....................  
....................  
.................... #define  _ACTIVE_MIN   102 
.................... // if Vdd is 3.3V, this represents .33 volt at the generator 
....................  
.................... #define OPER_BCHK_INTVL    36600 
....................    // check the battery level every OPER_BCHK_INTVL tmr2 interrupts 
....................    //  during operation; 36600 for once every 10 minutes 
....................  
.................... #define FSLEEP_DEL   2 
....................    // wait this number of seconds after receipt of force_warm or force_sleep 
....................    //  manager commands before acting... allows time for ACK 
.................... */ 
....................  
.................... /* 
....................  
.................... #define NO_BRK             0 
.................... #define MAX_BRK            400 
.................... // MAX_BRK for absolute minimum speed 
....................     
.................... // min and max charging aggressiveness values (PWM)    
.................... #define MIN_CHGAGGR        0 
.................... #define MAX_CHGAGGR        400 
....................  
.................... #DEFINE MAX_CHGDUTY        0x320 
....................  
.................... #define MIN_PWM            0 
.................... #define MAX_PWM            400 
....................   
....................  
.................... #define FLAGS1_BNOCH       0x00 
.................... // no charge during BRK control as requested by operator 
....................  
.................... #define FLAGS1_NOFLO       0x01 
....................  
.................... #define FLAGS1_MANRPM      0x02 
.................... // manual set of MPPC (0x0 00-0x1FF), RPM CONTROL 
.................... #define FLAGS1_RPMOLD      0x03 
.................... // old table lookup for RPM control 
....................  
.................... // new adaptive algorith 
.................... #define FLAGS1_DYNLO       0x04 
.................... // most aggressive charging, PWM control of brake 
.................... #define FLAGS1_DYNMID      0x05 
.................... // variable MPPC 0-FF, no brake 
.................... #define FLAGS1_DYNHI       0x06 
.................... // variable PWM control of EN_3105, MPPC = 0xFF, no  brake 
....................  
.................... #define FLAGS1_RNOCH       0x07 
.................... // no charge during RPM control as requested by operator 
....................  
.................... #define FLAGS1_TRANS2F     0x08 
.................... #define FLAGS1_TRANS2N     0x09 
.................... // 08:09 for transitioning states to smooth out battery full situations while 
.................... //  dynamically charging  
....................  
.................... #define FLAGS1_MANBRK      0x0A 
.................... // manual set of MPPC (0x000-0x1FF), NO RPM CONTROL 
.................... #define FLAGS1_BRKOLD      0x0B 
.................... // old formula calc for BRK control 
....................  
.................... #define FLAGS1_MAXCHG      0x0C 
.................... // defined max charging state 
....................  
.................... #define FLAGS1_FREE        0x0D 
.................... // defined state for free spin 
....................  
.................... #define FLAGS1_MANPWM      0x0E 
.................... // manual setting of MPPC and PWM control of 3105 enable 
....................  
.................... #define FLAGS1_DYNFULL     0x0F 
.................... // no charge during BRK control as requested by operator 
....................  
....................    
.................... //#define FLAGS_READY        0x00 
....................  
.................... #define VOPEN_FULL         0x8000 
.................... // Valve to max open 
.................... #define VCLOSE_FULL        0 
.................... #define VUNKNOWN           0xFFFF 
....................  
.................... // RPM increases as cur_MPPC goes from 0 to FF 
.................... #define MPPC_MAX           0x01FF 
.................... #define MPPC_DYNMAX        0xFF 
.................... // value of MPPC during dynamic control mode at which we shift into 
.................... //  hi speed mode wherein we duty cycle modulate the charging circuit! 
.................... #define MPPC_MIN           0x00a 
.................... #define MPPC_ADDCHG        0x0D1 
.................... // This may need to be adjusted if we change the manner in which MPPC is set 
.................... //  during braking. See prep_4_brake reoutine 
....................  
.................... #define MPPC_DUTYLIM       0x320 
....................    // 0x320 = 800 
....................    // maximum duty cycle for charger (special modes) 
....................     
.................... //#define MPPC_CHGOFF        0x1FF 
.................... // What should MPPC be set to when charging is NOT happening?  Does it matter? 
....................  
.................... #define MPPC_DYNCHG    0x0FF 
.................... // This is the default STARTING POINT for the MPPC setpt during dynamic 
.................... //  charging control 
.................... #define MPPC_STEP2F     1 
.................... // This is the MPPC value step change which takes place during transitions 
.................... // from _DYNMID to full battery situation 
.................... #define MPPC_STEP2N     1 
.................... // This is the MPPC value step change which takes place during transitions 
.................... // from full battery situation to Dynamic charging situation 
....................  
.................... #define TRANS_PERSTEP   1 
.................... // This is the target period value step change which takes place during  
.................... // transitions from _DYNMID to full battery situation 
.................... #define TRANS_PWMSTEP   8 
.................... // This is the step change for the PWM when routed to the charger and while 
.................... //  transitioning from _DYNHI to full battery situation 
....................  
.................... #define CHRGING_THRESH     0x0011 
....................    // A/D counts difference between UNLOADED and LOADED Vchg measurement 
....................    // indicates whether or not we are (significantly) charging the battery now. 
....................    // We compare this value to (VchgU-VchgL) where this is in units of ADC 
....................    //  counts -- at 3mV per count, 50mv would be a CHRGING_THRESH of ~17. 
....................  
.................... #define NOSPIN_LIMIT       16 
....................    // Number of ~half-seconds of low or no rotation that must occur in order to 
....................    //  show the nospin display and alert the manager 
....................  
.................... #define NUM_4_STAT         64 
....................    // This is number of rpm measurements to process prior to determination of 
....................    //  AveRPM and Max/Min (~30sec interval) 
....................    // Also signals reporting to the manager 
.................... #define SHIFT_4_STAT       5 
....................    // This is intead of dividing by NUM_4_STAT; change these two values 
....................    //  together 
....................  
.................... #define TEN_MIN            600 
....................    // This is the number of seconds in ten minutes; used to time mandatory 
....................    //  battery checks 
....................  
.................... // defines for prechg_opt 
.................... // TIME or Alternative (voltage-based?) Algorithm utiling regulated RPM 
.................... #define PRECHG_TIME_RPM    0x00 
....................  
....................  
.................... // defines for msg_id (Manager->Mote Payload message ID to Micro) 
.................... #define MSG_FULL              0x01 
.................... #define MSG_WATER_ON          0x02 
.................... #define MSG_WATER_OFF         0x03 
....................    
.................... #define MSG_FORCE_WARM        0x06 
....................  
.................... #define MSG_SHUT_DEL_RD       0x0E 
.................... #define MSG_SHUT_DEL_WR       0x0F 
....................  
.................... #define MSG_FIRMWARE_RD       0x24 
....................  
.................... #define MSG_FORCE_TIME        0x29 
....................  
.................... #define MSG_FORCE_COLD_DEL    0x2B 
.................... #define MSG_FORCE_COLD        0x2C 
....................  
.................... #define MSG_FORCE_REJOIN_DEL  0x2E 
.................... #define MSG_FORCE_REJOIN      0x2F 
....................  
.................... #define MSG_MGR_ACK           0x30 
.................... #define MSG_MGR_NACK          0x31 
....................  
.................... #define MSG_SP_NUM_WR         0x44 
....................  
.................... #define MSG_DEFINE_TEST       0x49 
.................... #define MSG_MARCH1            0x50 
.................... // for IMMEDIATE or future MARCHING ORDER, closed loop RPM, timed valve 
.................... #define MSG_MARCH2            0x51 
.................... // for IMMEDIATE or future MARCHING ORDER, closed RPM and FLOW 
.................... #define MSG_READY             0x52 
.................... #define MSG_TEST              0x53 
.................... #define MSG_DEMO              0x54 
.................... // for immediate open loop setting of valve, brake, charger, etc. 
....................  
.................... #define MSG_REPORT_VALVE      0x59 
....................  
.................... #define MSG_SLEEPNOW          0x5B 
.................... #define MSG_SHUTDOWNC_DEL     0x5C 
.................... #define MSG_SHUTDOWNC         0x5D 
.................... #define MSG_SHUTDOWNO_DEL     0x5E 
.................... #define MSG_SHUTDOWNO         0x5F 
....................  
.................... #define MSG_HEALTH            0x60 
.................... #define MSG_CAL_VALVE         0x61 
.................... // short form of MSG_STD solicited by manager to get LOCATION, STATE, ERRORS 
....................  
.................... // defines for msg_id (Micro to Mote) 
.................... #define MSG_ACK            0x80 
.................... #define MSG_NACK           0x81 
.................... #define MSG_ERROR          0x82 
.................... #define MSG_MICRO_RESPONSE 0x83 
.................... #define MSG_FIRST          0x84 
.................... #define MSG_VCAL           0x85 
....................  
.................... // defines for various unsolicited messages 
.................... #define BATTERRb           7 
.................... //Indicates to LV program that the startup was 
.................... //  rocky due to a DEAD BATTERY! (bit7 set) 
.................... #define LOSPINb            6 
.................... // Indicates to LV program that the freespin speed measured during the  
.................... //  opening dance was less than FREESPIN_MIN (bit6 set) 
.................... #define OCDIFFb            5 
.................... // Indicates to LV program that the 1st open time and the 1st close 
.................... //  time differ by greater than 25% (bit5 set) 
.................... #define REJOINEDb          4 
.................... // Indicates that a rejoin occurred 
....................  
.................... // Note 3:2 carry information about 1st valve open 
.................... // and  1:0 carry information about 1st valve close 
.................... // as follows: 0b00   OK 
.................... //             0b01   timeout 
.................... //             0b10   TOO SHORT of a duration for valve motion 
.................... #define OPENSHORTb         3 
.................... #define OPENLONGb          2 
.................... #define CLOSESHORTb        1 
.................... #define CLOSELONGb         0 
....................  
.................... // defines for error codes as communicated to manager 
.................... #define NO_ERRCODE         0x00 
.................... #define BATOK_ERRCODE      0x03 
....................  
.................... #define FRC_SLEEP_ERRCODE  0x05 
.................... // manager forces system into a sleep state and decommissions the mote 
....................  
.................... #define LOC_ERRCODE        0x21 
.................... #define CPASSOC_ERRCODE    0x22 
.................... #define LOC_CP_ERRCODE     0x23 
....................  
.................... #define ADDCHG_WARNCODE    0x80 
.................... //#define LOWBAT_ERRCODE     0x80 
.................... #define PS_ERRCODE         0x81 
....................          // Vdd too high 
.................... #define WEAKBAT_WARNCODE   0x82 
.................... #define DEADBAT_ERRCODE    0x83 
....................  
.................... // defines for state variable 
.................... #define  DEV_INIT          0x00 
.................... #define  DEV_JOINING       0x01 
.................... #define  DEV_1STEXCH       0x02 
.................... #define  DEV_READY         0x03 
.................... #define  DEV_RUN           0x04 
.................... #define  DEV_PAUSED        0x05 
.................... #define  DEV_IDLE          0x06 
.................... #define  DEV_SLEEP         0x07 
.................... #define  DEV_TEST          0x08 
.................... #define  DEV_DEMO          0x09 
....................  
.................... // defines for vlv_state variable 
.................... #define  VLV_COASTING   0x00 
.................... #define  VLV_CLOSING    0x01 
.................... #define  VLV_OPENING    0x02 
.................... #define  VLV_BRAKING    0x03 
....................  
.................... #define  TYPE_NOXDCR    0x01 
.................... #define  TYPE_XDCR      0x02 
....................  
.................... // defines for sys_state variable 
.................... // F009+ 
.................... // 7:4 - major state indicator 
.................... // 3:0 - minor state indicator 
.................... //       .3 = joining_fl (also set if rejoining fails) 
.................... //       .2 = rejoining_fl 
.................... //       .1 = chgenab_fl 
.................... //       .0 = ctrlRPM_fl 
.................... #define INIT_STATE               0x00 
....................    // OR with joining_fl when established 
....................    // always leads to OPEN1_STATE; 
....................    // NEVER accepts packets (NACK), even if joined 
.................... #define LSTATE_INIT              0x00 
....................  
.................... #define OPEN1_STATE              0x10 
....................    // OR with joining_fl when established 
....................    // always leads to PRECHG_STATE; 
....................    // always from INIT_STATE; 
....................    // May process report commands. 
....................    // [Vmmmm:ss OPENING] countup display 
.................... #define LSTATE_OPEN1   0x01 
....................  
.................... #define PRECHG_STATE             0x22 
....................    // OR with joining_fl when established 
....................    // always leads to CLOSE_STATE; may be in and out quickly if no 
....................    //  precharging is necessary; 
....................    // always from OPEN1_STATE; 
....................    // May process report commands.. 
....................    // [Pmmmm:ss        ] countdown display 
.................... #define LSTATE_PRECHG   0x02 
....................  
.................... #define CLOSE1_STATE             0x32 
....................    // OR with joining_fl when established 
....................    // always leads to JOINING_STATE or READY_STATE; 
....................    // always from PRECHG_STATE; 
....................    // May process report commands. 
....................    // [Vmmmm:ss CLOSING] countup display 
.................... #define LSTATE_CLOSE1   0x03 
....................  
.................... #define JOINING_STATE            0x44 
....................    // always leads to READY_STATE 
....................    // always from CLOSE1_STATE 
....................    // Bypassed if warm start 
....................    // Cannot hear commands. 
....................    // [Jmmmm:ss  moteid] display 
.................... #define LSTATE_JOIN     0x04 
....................  
.................... #define REJOINING_STATE          0x48 
....................    // Leads to READY_ if rejoin is successful 
....................    //  or JFAIL_ if rejoin is unsuccessful 
....................    //  or ADDCHG_ if needed. 
....................    // Drops into this state when we are rejoining 
....................    //  AND there is no pending marching order 
....................    //  Preceeding state READY_ or  
....................    //   short-lived READY_ after completion of marching orders. 
....................    // [Rmmmm:ss  moteid] countup display 
....................    // Cannot hear commands. 
....................    // THINK ABOUT THIS 
....................  
.................... #define DISRUPT1_STATE           0x50 
.................... #define LSTATE_DIS1     0x05 
.................... #define DISRUPT2_STATE           0x60 
.................... #define LSTATE_DIS2     0x06 
.................... #define DISRUPT3_STATE           0x70 
.................... #define LSTATE_DIS3     0x07 
....................  
.................... #define READY_STATE              0x80 
....................    // leads to OPENING_STATE or VADJ_STATE 
....................    //  or to DISRUPT STATE; 
....................    // valve is closed in READY_STATE; 
....................    // from CLOSE1_STATE or or CLOSING_STATE 
....................    // Processes all commands 
....................    // ['yy:ddd:hh:mm:ss] display 
.................... #define LSTATE_READY    0x08 
....................  
.................... #define JFAIL_STATE              0x8C 
....................    // Eventually leads to shutdown of sprinkler 
....................    // Indicates cannot join and we have given up AND all marching orders 
....................    //  have completed 
....................    // Drops into this state from REJOINING_STATE 
....................    // Cannot hear commands. 
....................    // ['yy:ddd:hh:mm:ss] display 
.................... #define LSTATE_JFAIL    0x10 
.................... // band-aid 
....................     
.................... #define OPENING_STATE            0x90 
....................    // OR with rejoining_fl (and joining_fl if failure to join) 
....................    // May be brief if at open-valve end-stop; 
....................    // Leads to either BRK_ or RPM_ or ADDCHG_; 
....................    // From BRK_STATE or RPM_STATE or READY_STATE or PAUSE_STATE or REJOINING_ 
....................    // May process report, param and march commands. 
....................    // [Vmmmm:ss OPENING] countup display 
.................... #define LSTATE_OPENING  0x09 
....................  
.................... #define CLOSING_STATE            0xB2 
....................    // OR with rejoining_fl (and joining_fl if failure to join) 
....................    // May be brief if at close-valve end-stop; 
....................    // Leads to either READY_, PAUSE_. 
....................    // From BRK_STATE or RPM_STATE. 
....................    // May process report, param and march commands. 
....................    // [Vmmmm:ss CLOSING] countup display 
.................... #define LSTATE_CLOSING  0x0B 
....................  
.................... #define VADJ_STATE               0xC0 
....................    // OR with rejoining_fl (and joining_fl if failure to join) 
....................    // May be brief if valve DOES NOT NEED adjustment; 
....................    // Leads to either BRK_STATE or RPM_STATE; 
....................    // From BRK_STATE or RPM_STATE or READY_STATE or PAUSE_STATE 
....................    // May process report, param and march commands. 
....................    // [Vmmmm:ss rrr!RRR] countup display shows current rpm ! desired RPM 
.................... #define LSTATE_VADJ     0x0C 
....................  
.................... #define PAUSE_STATE              0xD0 
....................    // OR with rejoining_fl (and joining_fl if failure to join) 
....................    // Leads to READY_ or OPENING_ or VADJ_ 
....................    // From READY_ or CLOSING_ 
....................    //  (CLOSING_ may have followed BRK_ or RPM_) 
....................    // May process report, param and march commands. 
....................    // either [ mmmm:ss  NOFLOW] countup display  
....................    //     or [Xmmmm:ss  NOFLOW] countdown display if pending order  
.................... #define LSTATE_PAUSE    0x0D 
....................  
.................... #define BRK_STATE                0xE0 
....................    // OR with rejoining_fl (and joining_fl if failure to join) 
....................    //  and OR with chgenab_fl 
....................    // Leads to CLOSING_ or OPENING_ or VADJ_ or READY_; 
....................    // From VADJ_ or OPENING_ 
....................    // May process report, param and march commands. 
....................    // either [ mmmm:ss rrrBbbb] countup display (current RPM B brake force) 
....................    //     or [Xmmmm:ss rrrBbbb] countdown display if pending order   
.................... #define LSTATE_BRK      0x0E 
....................  
.................... #define RPM_STATE       0xF1 
....................    // OR with rejoining_fl (and joining_fl if failure to join) 
....................    //  and OR with chgenab_fl 
....................    // leads to CLOSING_ or OPENING_ or VADJ_ or READY_; 
....................    // from VADJ_STATE or OPENING_STATE 
....................    // May process report, param and march commands. 
....................    // either [ mmmm:ss rrr*RRR] countup display (current RPM / desired RPM) 
....................    //     or [Xmmmm:ss rrr*RRR] countdown display if pending order  
.................... #define LSTATE_RPM      0x0F 
....................  
.................... #define JOIN_MASK       0x0C 
.................... // AND with sys_state to extract both fl_joining and fl_rejoining bits 
.................... #define STATE_MASK      0xF3 
.................... // AND with sys_state to clear both fl_joining and fl_rejoining bits 
.................... #define RPM_CH_MASK     0x03 
.................... // AND with sys_state to extract RPM control bit (0) and charging bit (1) 
....................  
....................  
.................... #define FREESPIN_MIN       60 
.................... // If freespin measured at startup is less than FREESPIN_MIN, then  
.................... //  manager will be informed when UNSOLICITED message is sent 
.................... // See above regarding MSG_UNSOLICITED defines. 
....................  
.................... #define START_BRK          600 
....................    // Some intermediate braking at cold start perior to beginning of precharge 
.................... #define IDLE_BRK           200 
....................    // This is the braking force we apply during idling.... mostly important 
....................    //  for debugging purposes 
....................  
....................  
.................... // IFDEF WARNER we are using Eric's valve 
.................... // otherwise we are using Jake's test fixture 
.................... //#IFDEF   WARNER 
.................... //#define VALVE_STOP         990 
.................... //#ELSE 
.................... //#define VALVE_STOP         960 
.................... //#ENDIF 
....................  
.................... #define VCURLIM            900 
.................... // guess during new board debug Feb 18 2016 
....................  
.................... #define VALVE_STOP_W       990 
.................... #define VALVE_STOP_J       960 
....................    // This is the number of ADC counts below which we assume 
....................    //  the valve motor has hit a stop.  NOTE hardware has a .25 ohm  
....................    //  resistor to Vbat 
....................    // This value will depend on valve drive motor characteristics 
....................    //  *J for test bench; *W for Warner valve 
.................... */ 
.................... //************************************************************************** 
.................... /*    
....................    Experimentation with prototype valves during March/April 2015 brought up 
....................    problems with valve becoming STUCK at an endstop. 
....................    Solutions include:  
....................       1. DO NOT CHECK for excessive current during first few 
....................       nudges when COMING off an endstop 
....................       2. Once valve is moving along (past the initial nudge which overcomes 
....................       inertia) we can check for excessive current sooner in the nudge cycle 
....................    Care must be taken to accomodate various situations which could interfere 
....................       with this approach, such as when nudging is interrupted by the need to 
....................       acknowledge activity at the mote.    
....................   
....................   VALVE_CHKDEL0 is the time in ms to wait after the drive motor is 
....................   turned on before checking if we have excessive current as part of the 
....................   very first nudge which specifically overcomes the startup current 
....................   transient due to inertia 
....................  
....................  VALVE_CHKDEL0 will be dependent upon whether we are using the "WARNER" 
....................   valves or the in-house test fixture   
....................   
....................  VALVE_CHKDEL1 is the normal time in ms to wait after the drive motor is 
....................   turned on before checking if we have excessive current.  The assumption 
....................   for the choice of this value is that we have already overcome the startup 
....................   current transient due to inertia 
....................  
....................  VALVE_CHKNO is the number of nudges during which we DO NOT check for 
....................   excessive current in the case where the valve is specially coming off 
....................   of either the closed or open end stop 
....................  
....................  
....................  Flags specify the situation at hand: 
....................  atstop_fl     TRUE if we are currently at an endstop, this flag 
....................                ensures that the algorithm utilizes VALVE_CHKNO 
....................                 
....................  firstnudge_fl TRUE if we are starting the valve from rest and we are NOT 
....................                at an endstop; ensures that the algorithm utilizes VALVE_CHKDEL1 
....................                 
.................... EXCEPTION and possible issue in the future is the first nudge after  
.................... system startup.  We may or MAY NOT be at an endstop.  So we assume a 
.................... atstop_fl = TRUE.   
....................  
.................... If we are actually FULL OPEN, and get stuck (!) we can 
.................... detect this because the number of steps during initial open will be too few 
.................... (less than 2 or 3) and then we can try again with the atstop_fl set. 
....................  
.................... If we are actually at FULL CLOSED, and get stuck, again the first opening will 
.................... be too few steps and we must then try again with the atstop_fl set..... 
....................  
.................... Thus if after the startup dance, either close_time or open_time are  
.................... "unreasonable", we must simply do it again (although perhaps we could skip 
.................... the precharge if we have a good free-spin value).  This will be optimized 
.................... in a later version of the firmware.  
....................  
.................... condx                      atstop_fl      firstnudge_fl 
.................... ---------------------------------------------------- 
.................... 1st nudge after startup    TRUE           TRUE 
.................... (valve position unknown) 
.................... 1st nudge from endstop     TRUE           FALSE 
.................... 1st nudge norm             FALSE          TRUE 
.................... (or immediately after motion is interrupted by activity from mote) 
.................... subsequence nudges         FALSE          FALSE 
.................... */ 
.................... //*************************************************************************** 
....................  
.................... /* 
....................  
.................... //#define  VALVE_CHKNO       3 
.................... #define VALVE_NOCHK_W     3 
.................... #define VALVE_NOCHK_J     1 
....................  
.................... //#IFDEF   WARNER 
.................... //#define VALVE_ONTIME       150 
.................... //#define VALVE_CHKDEL0      100 
.................... //#ELSE 
.................... //#define VALVE_ONTIME       100 
.................... //#define VALVE_CHKDEL0      50 
.................... //#ENDIF 
....................  
.................... // These values are in milliseconds 
.................... #define VALVE_ONTIME_W     150 
.................... #define VALVE_CHK0_W       100 
.................... #define VALVE_ONTIME_J     100 
.................... #define VALVE_CHK0_J       50 
....................  
.................... // assume 16 bit counter triggered by FOSC div 64 (timer 0 prescaler) 
.................... // Thus one count every 64*T0_OSC nanoseconds 
.................... // Setup timer 0 for div64 and load with the value below for it to time out                         
....................  
.................... #define VALVE_TMR0SET0_W     (65536 - (1000000*(VALVE_ONTIME_W - VALVE_CHK0_W)+32*T0_OSC)/(64*T0_OSC)) 
.................... #define VALVE_TMR0SET0_J     (65536 - (1000000*(VALVE_ONTIME_J - VALVE_CHK0_J)+32*T0_OSC)/(64*T0_OSC)) 
.................... // THUS: if we delay CHK_DEL0 milliseconds, and then set a timer to timeout 
.................... //  according to VALVE_TMR0SET0, we have taken up a full CHUNK's worth of time 
....................  
.................... // once valve is in motion, only wait 20 msec before testing for endstop! 
.................... //  This is arbitrary and conservative. 
.................... #define VALVE_CHKDEL1      20 
.................... #define VALVE_TMR0SET1_W   (65536 - (1000000*(VALVE_ONTIME_W - VALVE_CHKDEL1)+32*T0_OSC)/(64*T0_OSC)) 
.................... #define VALVE_TMR0SET1_J   (65536 - (1000000*(VALVE_ONTIME_J - VALVE_CHKDEL1)+32*T0_OSC)/(64*T0_OSC)) 
.................... // THUS: if we delay CHK_DEL1 milliseconds, and then set a timer to timeout 
.................... //  according to VALVE_TMR0SET1, we have taken up a full CHUNK's worth of time 
....................  
....................    // VALVE_ONTIME is the number of milliseconds that the motor runs between 
....................    //  activity on mote checks 
....................    // VALVE_CHKDEL0 is the number of milliseconds we wait when motor is 
....................    //  first turned on to check for an endstop.  This accounts for the 
....................    //  inertial transient at first turn-on. 
....................     
.................... #define VALVE_ATSTOPDEL    50 
....................  
....................  
.................... #define VALVE_TIM0         (VALVE_ONTIME-VALVE_CHKDEL0) 
.................... // Set TMR0 to overflow after this number of millisecondes 
.................... //  Note that each tick of TMR0 during the move_valve routine is 
.................... //  32/19200 or 1.666 msec or 1667 microseconds 
.................... //  This convenient number is represented by the fraction 3/5 in the  
.................... //   define below 
.................... #define VALVE_TMR0SET0     256 - ((VALVE_TIM0*3)/5)  
.................... // THUS: if we delay CHK_DEL0 milliseconds, and then set a timer to timeout 
.................... //  according to VALVE_TMR0SET0, we have taken up a full CHUNK's worth of time 
....................   
....................  
....................  
....................  
.................... //#IFDEF   WARNER 
.................... //#define VCTR_LIMIT         200 
.................... //#ELSE 
.................... //#define VCTR_LIMIT         175 
.................... //#ENDIF 
....................  
.................... #define VALVE_CTRLIM_W       200 
.................... #define VALVE_CTRLIM_J       175 
.................... // little motions of valve motor should definitely get it to a stop 
.................... //  or to its destination;  if not we time out.  This number is somewhat 
.................... //  arbitrary 
....................  
.................... #define VCLASS2_LIM        38      
.................... // relative to 0 (full close) and 255 (full open) at what limit for  
.................... //  valve desired do we force bouncing off the nearest enstop? 
.................... // 15% would be 38 
.................... #define BOUNCE_OPEN        256-VCLASS2_LIM 
.................... #define BOUNCE_CLOSE       VCLASS2_LIM 
.................... #define V_ENDCTR_LIM       5 
.................... // force an endstop at least every 5 excursions 
....................  
....................  
.................... //#IFDEF   WARNER 
.................... //#define V_SINCEEND_LIM     400  
.................... //#ELSE 
.................... //#define V_SINCEEND_LIM     350 
.................... //#ENDIF 
.................... // force an endstop if cumulative motion has exceeded about 2 full paths 
.................... //  from open to closed 
.................... #define VALVE_SINCELIM_W   400 
.................... #define VALVE_SINCELIM_J   350 
....................  
....................  
.................... #define VFULL_TIM_LIM      7200 
.................... // if this number of seconds has passed since the full open2close or the 
.................... //  full close2open time has been remeasured, then force it. 
....................  
.................... // defines for vset_class variable 
.................... #define BOUNCE0_CL         0x01 
.................... #define BOUNCE0_OP         0x81 
.................... #define BOUNCE1_CL         0x02 
.................... #define BOUNCE1_OP         0x82 
.................... #define BOUNCE2_CL         0x03 
.................... #define BOUNCE2_OP         0x83 
.................... #define BOUNCE3_CL         0x04 
.................... #define BOUNCE3_OP         0x84 
....................  
.................... #define VTOOSHORT          60 
.................... // This is the minimum number of nudges for open to close or close to open 
.................... //  which is acceptable during startup dance.  If not VTOOSHORT, then 
.................... //  no problem is reported during first message after join 
.................... #define FREESPIN_LIM       120 
.................... // This is the minimum RPM which is 'acceptable' for free spin result! 
.................... // If not too slow, then no problem is reported during 
.................... //  first message after join 
....................  
.................... // EEPROM LOCATIONS 
.................... #define EE_ADDCHG_DUR      0x0002 
....................    // Configures add-charging time in seconds 
....................    // 2 bytes, low byte at 0x0002 
.................... #define ADDCHG_DUR_DEF     4 
....................    // 4 minutes? 
.................... #define EE_PRECHG_DUR      0x0004 
....................    // Configures precharging time in seconds 
....................    // 2 bytes, low byte at 0x0004 
.................... #define PRECHG_DUR_DEF     10 
....................    // 1.5 minutes?  
.................... #define CHGLOOPS_PER_MIN   110 
....................    // determined experimentally, each loop is about 545 msec 
....................    //  which is a bit longer than I would prefer (!), but oh well. 
....................    //  JG 2015 Jun16 
....................     
.................... // 0x00A thru 0x00F        reserved 
.................... #define EE_NETW_ID         0x0010 
....................    // 2 bytes, low byte at 0x0010; for now, network ID defaults to 0x04CD. 
.................... #define EE_PRENETW_ID      0x0012 
....................    // 2 bytes, low byte at 0x0012; for now, network ID defaults to 0x04CD. 
....................  
....................  
.................... // 0013 reserved 
.................... #define EE_LOCATION     0x0014 
....................    // 2 bytes, low byte at 0x0014; associates sprinkler with particular 
....................    //  physical location on CP 
.................... #define EE_PRELOCATION  0x0016 
....................    // 2 bytes, low byte at 0x0016, previous association of sprinkler with 
....................    //  particular physical location on CP 
....................  
....................    // 0x018 thru 0x01F     reserved 
....................  
.................... // IDLE behavior specified at 0x0020 thru 0x0033 
.................... #define EE_IDLE_OPT        0x0020 
....................    // Configures IDLE behavior.  Applies if battery low during operational 
....................    //  state 
....................    //  0x00  send out Panic Message once when panic level is reached according 
....................    //         to voltage-based algorithm 
....................    //  0x01  send out Panic Message once when panic level is reached according 
....................    //         to charge-based algorithm 
.................... #define MAX_IDLE_OPT       1 
....................    // If manager tries to write any idle_opt value larger than this to EEPROM 
....................    //  a NACK occurs; see above for idle option choices 
.................... #define LEN_IDLE_BLOCK     15 
....................    // There are 15 bytes in the idle block 
....................  
.................... #define EE_IDLE_PROFILE    0x0021 
....................    // Saved only upon entering IDLE state; 
....................    //  profile number which was running or had last been run. 
....................    // 0 for default profile, 1, 2, 3 for controller-specified profile choices 
....................    //  other numbers, use 0 
.................... #define EE_IDLE_STEP       0x0022 
....................    // Saved only upon entering IDLE state; 
....................    //  step number of profile which was running or had last been run. 
....................    //  Step 0xFF indicates that we were not within a profile 
....................    //  Step 0x10 thru 0xFE invalid. 
.................... #define EE_IDLE_STIME      0x0023 
....................    // 2 bytes, low byte at 0x0023, high byte at 0x0024 
....................    // Saved only upon entering IDLE state; 
....................    //  amount of time in seconds that rate was controlled according 
....................    //  to EE_IDLE_STEP at time when IDLE state entered; 
....................    //  set to 0x0000 if EE_IDLE_STEP=0xFF. 
.................... #define EE_IDLE_LOOP       0x0025 
....................    // 2 bytes, low byte at 0x0025, high byte at 0x0026 
....................    // Saved only upon entering IDLE state; 
....................    //  for looping profiles, loop number at time when IDLE state entered; 
....................    //  set to 0x0000 for non-looping profiles, set to 
....................    //  0x0000 if EE_IDLE_STEP=0xFF. (looping beyond 0xFFFF is recorded as 
....................    //  0xFFFF) 
.................... #define EE_IDLE_CHG        0x0027 
....................    // 2 bytes, low byte at 0x0027, high byte at 0x0028 
....................    // Configures used charge in millicoulombs for 
....................    //  charge-based shutdown method (TBD); applies if EE_IDLE.1 is set 
.................... #define EE_IDLE_SHDN_DLY   0x0029 
....................    // 2 bytes, low byte at 0x0029, high byte at 0x002A 
....................    // Configures time in units of 67 secs (TMR0 ints during IDLE) 
....................    //  between sensing of low battery and self-shutdown 
....................  
....................  
.................... // 0x02F thru 0x033        reserved 
....................  
.................... // PROFILE behavior specified at 0x0034 thru 0x003E 
.................... #define EE_PROFILE_OPT     0x0034 
....................    // Configures PROFILE behavior. 
....................    //  0x00 start profile0 (0x0050-0x007F) from the beginning 
....................    //  0x01 start profile1 (0x0090-0x00BF) from the beginning 
....................    //  0x02 start profile2 (0x00D0-0x00FF) from the beginning 
....................    //  0x03 start profile3 (0x0110-0x013F) from the beginning 
....................    //  0x04 start last used profile (EE_IDLE_PROFILE) from the beginning 
....................    //  0x05 start last used profile (EE_IDLE_PROFILE) from where it stopped 
.................... #define MAX_PROFILE_OPT    0x05 
....................    // profile option value cannot exceed this value 
....................  
....................  
.................... #define EE_SHUT_DEL        0x003E 
....................    // 2 bytes, low byte at 0x003E, high byte at 0x003F 
....................    // number of seconds between MSG_FORCE_COLD_DEL or MSG_SHUTDOWNx_DEL 
....................    //  and actual restart or shutdown 
....................    // For broadcast messages, ensures that all of the motes get the 
....................    //  message before they 'go away' 
....................  
.................... // GENERAL behavior specified at 0x0040 thru 0x004F 
.................... #define EE_GENERAL_OPT     0x0040 
....................    // Configures GENERAL behavior. 
....................    //  0x00 normal operation 
....................    //  0x01 test mode A (debug) 
....................    //  0x02 test mode B (time messages to DUST controller) 
....................    //  0x03 test mode C (debug and time messages) 
.................... #define MAX_GENERAL_OPT    0x03 
....................    // general option value cannot exceed this value 
....................  
.................... // 0x041 thru 0x04F        reserved 
....................  
.................... #define EE_REINFO          0x0050 
....................    // hold last known restart_cause 
....................  
.................... // 0x051 thru 0x05F        reserved 
....................  
.................... #define EE_DEADPROFILE     0x0060 
....................    // If death occurs during profiling, place profile number here (0,1,2,3) 
....................    //  else set to 0xFF 
.................... #define EE_DEADSTEP        0x0061 
....................    // Set to profile step number during which death occurred. 
.................... #define EE_DEADTIME        0x0062 
....................    // 2 bytes indicates how far along we were into the profile step when 
....................    //  dead battery was detected. 
.................... #define EE_DEADSTATE       0x0064 
....................    // system state during which dead battery was detected 
....................  
.................... // 0x065 thru 0x07F        reserved 
....................  
.................... #define EE_ERRORID         0x0080 
....................    // 2 bytes, low byte is the error_id and 
....................    //  high byte is errors1 -- saves last reason for a deep event error 
....................  
.................... #define EE_VSET_CLASS      0x0082 
.................... #define EE_V_ENDCTR        0x0083 
.................... #define EE_V_SINCEEND      0x0084 
.................... #define EE_O_C             0x0086 
.................... #define EE_C_O             0x0088 
....................  
.................... #define EE_RESTART_INFO    0x00A0 
.................... // 0x090 thru 0x0EF        reserved 
....................  
.................... #define EE_PROFILE0        0x00F0 
....................    // This is address of first byte of profile0 (default). 
....................    // May extend to 0x011F. 
....................    // 3 bytes per step, 16 steps.  Each step has 1 byte for RPM and 2 bytes 
....................    //  for duration in seconds.  If duration = 0x0000, then this means 
....................    //  "forever." 
....................    //  If 0x00 <= RPM <= RPM_MIN, then interpret RPM as RPM_MIN. 
....................    //  If RPM_MAX <= RPM <= 0xFF, then interpret RPM as RPM_MAX. 
....................    //  thus RPM = 0x00 and duration = 0xFFFF means single step rpm_min speed forever. 
....................    //  All bytes following duration = 0xFFFF in a profile are ignored. 
....................    //   RPM = 0xFF and duration = 0xFFFF is the end of profile marker for 
....................    //   "repeating" profiles".  0xFF / 0xFFFF cannot be the first step. 
....................    //  for steps preceeding duration = 0xFFFF, duration cannot = 0x0000! 
....................    //  Note that default profile is loaded into EEPROM by firmware 
....................    //   at start if none is present.  Controller can read or write 
....................    //   profiles. 
....................  
.................... // 0x120 thru 0x1EF        reserved 
....................  
.................... #define EE_VDD             0x1F0 
....................    // Two bytes; ADC-based estimate of Vdd (4.12 fixed pt format) 
.................... #define EE_VBATT           0x1F2 
....................    // Two bytes, ADC-based estimate of Vbatt 
.................... #define EE_VGEN            0x1F4 
....................    // Two bytes, ADC-based estimate of Vgen 
.................... #define EE_VSOLAR          0x1F6 
....................    // Two bytes, ADC-based estimate of Vsol 
....................  
....................  
.................... // SCRATCHPAD EEPROM 
....................  
.................... #define EE_DEBUG_1st       0x0200 
.................... #define EE_DEBUG_LAST      0x03F0 
....................  
.................... #define EE_FREE_1st        0x0200 
.................... #define EE_FREE_LAST       0x03BF      // free space never cleared 
.................... #define EE_SCRATCH_1ST     0x03F0 
.................... #define EE_SCRATCH_LAST    0x03F8      // scratch space cleared at start 
....................                                        //  (warm, cold, or xcold) 
....................    // This is the start and end of scrathpad memory in EEPROM.  To be used for 
....................    //  for debug purposes or TBD. 
....................  
.................... #define EE_BOOT_RECORD     0x0200      // new events and time 
.................... #define EE_NETID_TIME      0x0208 
.................... #define EE_MOTEOPER_TIME   0x020C 
.................... #define EE_MOTEIDLE_TIME   0x0210 
.................... #define EE_MSG_RECORD_0    0x0220 
.................... #define EE_MSG_RECORD_END  0x03BF 
....................  
.................... #define EE_SYS_STATE       0x03C0 
....................    // Address of state flags (echoes read only status) 
....................    // Written to EEPROM at significant state transitions 
.................... #define EE_INT_CTR         0x03E8 
....................    // Address of error/alarm flags (as many as 16 bytes) 
....................    // Written to EEPROM at significant state transitions 
.................... #define EE_CUR_PROFILE     0x03F0 
.................... #define EE_MSGBYTES_DBG    0x03F8 
.................... #define EE_PORTB_BIT       0x03F9 
.................... #define EE_PORTB_DIR       0x03FA 
....................  
....................  
....................     
....................  
....................    // for debug only 
....................  
.................... #define DUTYCYCLE_SET      0x40 
.................... // set join duty cycle for mote to this value at startup; approx 15% 
.................... #define SPECIALNV1_00      0x0000 
....................    // for rapid join time during debug, use with pkgen_setnv_special1(**) 
.................... #define SPECIALNV2_00      0x0005 
....................    // for rapid join time during debug, use with pkgen_setnv_special2(**) 
....................    // RAPID: 5 seconds to 0 seconds is a timing range having to do with 
....................    //  looking for advertisements during join 
....................    // NORMAL: 90 to 60 seconds..... 
.................... #define SPECIALNV1_01      0x003C 
....................    // for normal join time during debug, use with pkgen_setnv_special1(**) 
.................... #define SPECIALNV2_01      0x005A 
....................    // for normal join time during debug, use with pkgen_setnv_special2(**) 
....................  
.................... */ 
....................  
....................  
....................       /* signed int properties */ 
.................... #define INT_MAX 32767         /* signed integer minimum*/ 
.................... #define INT_MIN (-32768)      /*signed integer maximum*/ 
....................  
....................       /* signed long properties */ 
.................... #define LONG_MAX 2147483647        /* signed long maximum*/ 
.................... #define LONG_MIN (-2147483648) /* signed long minimum*/ 
....................  
.................... /* 
....................  
.................... // BELOW are constants and defines used in battery check routines 
....................  
.................... #define FVR_NOEE        2455 
.................... // approx 2V, any lower, don't attempt to run the micro or write to EE 
.................... //    fl_bat_NOEE 
.................... //    (BOX_CHAR here and below) 
....................  
.................... #define FVR_NODUST      2332 
.................... // 2.2 V; any lower, don't use the dust module; fl_batNODUST 
.................... //    ('D' here down to FVR_NOEE) 
....................  
.................... #define FVR_TEST        1819        
.................... // 2.7V threshold for testing purposes, display still visible 
....................  
.................... #define FVR_DEAD        1638 
.................... // 3.0V; dead battery, any lower, do not move valve; fl_batDEAD 
.................... //    ('d' here down to FVR_NODUST) 
....................  
.................... #define FVR_WEAK        1534 
.................... // 3.2V; below this point, battery dangerously weak  
.................... //  but can add charge, shout out; fl_batSHOUT, fl_addchg  
.................... //    ('-' here down to FVR_DEAD)) 
....................  
.................... #define FVR_ADDCHG      1511 
.................... // 3.25V; battery weak... below this point add charge, shout out 
.................... //    (! here down to FVR_WEAK); fl_batSHOUT, fl_addchg 
.................... // above this point, battery OK; fl_batOK 
.................... //    ('+' here up to FVR_ADEQUATE) 
....................  
.................... #define FVR_ADEQUATE    1488 
.................... // 3.30V; adequately charged if at or above this point; fl_batOK  
.................... //    ('f' here up to FVR_FULL) 
....................  
.................... #define FVR_FULL        1444 
.................... // 3.40V; battery full at or above this point; fl_batFULL 
.................... //    ('F' here up to FVR_TOOFULL) 
....................  
.................... #define FVR_TOOFULL     1327 
.................... // >=3.7 do not precharge, error condition?; fl_batTOOFULL 
.................... //    (TOPLINE_CHAR here and above) 
....................  
.................... // QCHK_FULL value is compared to 4x 1.2Vref as measured when sprinkler 
.................... //  is running and battery may be charging  (VfvrCAD) 
.................... // If the battery voltage measured during qchk_batt 
.................... //  is such that VfvrCAD < QCHK_FUL [indicates battery fully charged] 
.................... //  then charging will stop, hopefully in a smooth and controlled manner 
.................... //  before the charger hardware cannot charge due to its configuration. 
.................... // After this occurs, charging will not take place until the next marching 
.................... //  order, at which point a chk_batt happens and a different criterion applies. 
.................... // Note that qchk_batt() measures during running and charging! 
.................... // The flag fl_qbatFULL is set and not cleared until the next marching order 
.................... //  is processed. 
.................... #define QCHK_FULL       1391 
.................... // 1023/1391 * 4.8V = 3.53V 
.................... // charging never enabled (fl_qbatFULL set) when VfvrCAD < QCHK_FULL 
.................... //    (chargemark set to TOPLINE_CHAR whenever fl_qbatFULL is set) 
.................... //    (chargemark set to 'c' if !fl_qbatFULL and significant difference 
.................... //     between generator voltage while charging as compared to not charing) 
....................  
.................... #define BATT_HYST       12 
.................... // If the difference between the battery voltage at the start of a new 
.................... //  marching order as compared to the VfvrAD which was measured when 
.................... //  a bat full situation was last determined is greater than this amount, 
.................... //  then we turn charging back on; in other words, if the battery voltage 
.................... //  has dropped during the previous marching order to a great enough extent 
.................... //  AFTER we had already determined that the battery was full, then we turn 
.................... //  charging back on (Rev 030+) 
.................... // Approx a 30mV drop [somewhat arbitrary, but provides a form of hysteresis] 
....................  
.................... #define TM_BATCHK       7200 
....................    // number of seconds maximum between chk_batt() calls; 
....................  
....................  
.................... #define TM_SPINRPT      0xA1 
....................    // arbitrary 8 bit number which, when compared to low byte of seconds ctr 
....................    //  initiates the possible reporting of a spin error (should be greater than 
....................    //  32 seconds because that is the amount of time it takes for the variance 
....................    //  determination to take place (sizeof periods[]) 
....................    // Possible error states include: NOSPIN_ERRCODE, SPEEDLO_ERRCODE, 
....................    //  SPEEDHI_ERRCODE, SPEEDREG_ERRCODE 
....................    // NOSPIN: manager has told us that water is flowing, but 
....................    //  speed is too slow to detect (<~3RPM) 
....................    // SPEEDLO/SPEEDHI: average speed over previous 64 measurements is beyond 
....................    //  limit established (e.g., +/-3%) 
....................    // SPEEDREG: max speed (or min speed) over previous 64 measurements 
....................    //  exceeds limit establihsed (e.g. target+/-6%) 
....................    // In this code, spin checks occur once every 256 seconds, or whenever 
....................    //  requested by the manager (MSG_STATUS_RDONLY). 
....................    // If a problem is detected, an error message immediately goes out one time. 
....................    //  THUS spin errors will be sent at least every 256 seconds 
....................    //  (change later?) 
....................  
.................... #define ONE_WEEK     2235 
....................    // number of 4.51 minute intervals in a week (for DEAD BATT HANDLER) 
....................  
.................... #define DEAD_BATTERY    0xFF 
....................    // indicates that restart event was due to dead battery detection 
....................  
.................... #define GET_A_CHAR(value)   { TMR1L = 0x78;  \ 
....................                               TMR1IF = FALSE;  \ 
....................                               output_low(_DUST_SPCTS);  \ 
....................                               while (!(kbhit() || TMR1IF));  \ 
....................                               errors1 |= RCSTA; \ 
....................                               dust_recive_buffer[value] = RCREG; \ 
....................                               output_high(_DUST_SPCTS); \ 
....................                             } 
.................... #define GET_1_CHAR      { set_timer1(0); \ 
....................                           output_low(_DUST_SPCTS);  \ 
....................                           while (!kbhit() && bit_test(TMR1H,7));  \                          
....................                           *mm = RCREG; \ 
....................                           output_high(_DUST_SPCTS); \  
....................                           mm++; \ 
....................                         } 
....................                          
.................... #define GET_blah_CHAR      { output_low(_DUST_SPCTS);  \ 
....................                           while (!kbhit());  \                          
....................                           *mm = RCREG; \ 
....................                           output_high(_DUST_SPCTS); \  
....................                           mm++; \ 
....................                         } 
....................  
.................... #define GET_32CHARS  {  GET_A_CHAR(0) \ 
....................                         GET_A_CHAR(1) \ 
....................                         GET_A_CHAR(2) \ 
....................                         GET_A_CHAR(3) \ 
....................                         GET_A_CHAR(4) \ 
....................                         GET_A_CHAR(5) \ 
....................                         GET_A_CHAR(6) \ 
....................                         GET_A_CHAR(7) \ 
....................                         GET_A_CHAR(8) \ 
....................                         GET_A_CHAR(9) \ 
....................                         GET_A_CHAR(10) \ 
....................                         GET_A_CHAR(11) \ 
....................                         GET_A_CHAR(12) \ 
....................                         GET_A_CHAR(13) \ 
....................                         GET_A_CHAR(14) \ 
....................                         GET_A_CHAR(15) \ 
....................                         GET_A_CHAR(16) \ 
....................                         GET_A_CHAR(17) \ 
....................                         GET_A_CHAR(18) \ 
....................                         GET_A_CHAR(19) \ 
....................                         GET_A_CHAR(20) \ 
....................                         GET_A_CHAR(21) \ 
....................                         GET_A_CHAR(22) \ 
....................                         GET_A_CHAR(23) \ 
....................                         GET_A_CHAR(24) \ 
....................                         GET_A_CHAR(25) \ 
....................                         GET_A_CHAR(26) \ 
....................                         GET_A_CHAR(27) \ 
....................                         GET_A_CHAR(28) \ 
....................                         GET_A_CHAR(29) \ 
....................                         GET_A_CHAR(30) \ 
....................                         GET_A_CHAR(31) } 
....................                          
.................... #define GET_REST_OF_CHARS  {  GET_1_CHAR \ 
....................                               GET_1_CHAR \ 
....................                               GET_1_CHAR \ 
....................                               GET_1_CHAR \ 
....................                               GET_1_CHAR \ 
....................                               GET_1_CHAR \ 
....................                               GET_1_CHAR \ 
....................                               GET_1_CHAR \ 
....................                               GET_1_CHAR \ 
....................                               GET_1_CHAR \ 
....................                               GET_1_CHAR \ 
....................                               GET_1_CHAR \ 
....................                               GET_1_CHAR \ 
....................                               GET_1_CHAR \ 
....................                               GET_1_CHAR \ 
....................                               GET_1_CHAR \ 
....................                               GET_1_CHAR \ 
....................                               GET_1_CHAR \ 
....................                               GET_1_CHAR \ 
....................                               GET_1_CHAR \ 
....................                               GET_1_CHAR \ 
....................                               GET_1_CHAR \ 
....................                               GET_1_CHAR \ 
....................                               GET_1_CHAR \ 
....................                               GET_1_CHAR \ 
....................                               GET_1_CHAR \ 
....................                               GET_1_CHAR \ 
....................                               GET_1_CHAR \ 
....................                               GET_1_CHAR \ 
....................                               GET_1_CHAR \ 
....................                               GET_1_CHAR \ } 
....................  
....................  
.................... // see MOTETIME.xlsx 
.................... // 1/1/2013 midnight .... 1/1/2062 midnight 
.................... UNSIGNED INT32 CONST YRLUKUP [50] = { 
....................    0x50E22700,0x52C35A80,0x54A48E00,0x5685C180,0x58684680, 
....................    0x5A497A00,0x5C2AAD80,0x5E0BE100,0x5FEE6600,0x61CF9980, 
....................    0x63B0CD00,0x65920080,0x67748580,0x6955B900,0x6B36EC80, 
....................    0x6D182000,0x6EFAA500,0x70DBD880,0x72BD0C00,0x749E3F80, 
....................    0x7680C480,0x7861F800,0x7A432B80,0x7C245F00,0x7E06E400, 
....................    0x7FE81780,0x81C94B00,0x83AA7E80,0x858D0380,0x876E3700, 
....................    0x894F6A80,0x8B309E00,0x8D132300,0x8EF45680,0x90D58A00, 
....................    0x92B6BD80,0x94994280,0x967A7600,0x985BA980,0x9A3CDD00, 
....................    0x9C1F6200,0x9E009580,0x9FE1C900,0xA1C2FC80,0xA3A58180, 
....................    0xA586B500,0xA767E880,0xA9491C00,0xAB2BA100,0xAD0CD480}; 
....................     
....................  
.................... UNSIGNED INT8 CONST BYTE_2_PCT [256] = { 
....................     0, 0, 1, 1, 2, 2, 2, 3, 3, 4, 4, 4, 5, 5, 5, 6,  
....................     6, 7, 7, 7, 8, 8, 9, 9, 9,10,10,11,11,11,12,12, 
....................    13,13,13,14,14,15,15,15,16,16,16,17,17,18,18,18, 
....................    19,19,20,20,20,21,21,22,22,22,23,23,24,24,24,25, 
....................    25,25,26,26,27,27,27,28,28,29,29,29,30,30,31,31, 
....................    31,32,32,33,33,33,34,34,35,35,35,36,36,36,37,37, 
....................    38,38,38,39,39,40,40,40,41,41,42,42,42,43,43,44, 
....................    44,44,45,45,45,46,46,47,47,47,48,48,49,49,49,50, 
....................    50,51,51,51,52,52,53,53,53,54,54,55,55,55,56,56, 
....................    56,57,57,58,58,58,59,59,60,60,60,61,61,62,62,62, 
....................    63,63,64,64,64,65,65,65,66,66,67,67,67,68,68,69, 
....................    69,69,70,70,71,71,71,72,72,73,73,73,74,74,75,75, 
....................    75,76,76,76,77,77,78,78,78,79,79,80,80,80,81,81, 
....................    82,82,82,83,83,84,84,84,85,85,85,86,86,87,87,87, 
....................    88,88,89,89,89,90,90,91,91,91,92,92,93,93,93,94, 
....................    94,95,95,95,96,96,96,97,97,98,98,98,99,99,100,100 }; 
....................     
.................... UNSIGNED INT8 CONST BYTE99_2_10S [100] = { 
....................    '0', '0', '0', '0', '0', '0', '0', '0', '0', '0',  
....................    '1', '1', '1', '1', '1', '1', '1', '1', '1', '1',  
....................    '2', '2', '2', '2', '2', '2', '2', '2', '2', '2',  
....................    '3', '3', '3', '3', '3', '3', '3', '3', '3', '3',  
....................    '4', '4', '4', '4', '4', '4', '4', '4', '4', '4',  
....................    '5', '5', '5', '5', '5', '5', '5', '5', '5', '5',  
....................    '6', '6', '6', '6', '6', '6', '6', '6', '6', '6',  
....................    '7', '7', '7', '7', '7', '7', '7', '7', '7', '7',  
....................    '8', '8', '8', '8', '8', '8', '8', '8', '8', '8',  
....................    '9', '9', '9', '9', '9', '9', '9', '9', '9', '9' }; 
....................  
.................... UNSIGNED INT8 CONST BYTE99_2_1S [100] = { 
....................    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 
....................    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 
....................    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 
....................    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 
....................    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 
....................    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 
....................    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 
....................    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 
....................    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 
....................    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9' }; 
....................     
.................... */ 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... #include "defines.h" 
.................... // defines.h                                                                
.................... // 
.................... // contains all non-pic (and non-dn2500.h) related defines and macros 
....................  
.................... ////////////////////Defines Table of Contents////////////////////////////////// 
.................... //Version 
.................... //Priority Queue 
.................... //Time Queue 
.................... //Command Stack 
.................... //Sprinkler Stack 
.................... //Gen RPM                               
.................... //Control Algorithm 
.................... //Valve                
.................... //XDCR           
.................... //RB ISR         
.................... //I2C Addresses  
.................... //LCD         
.................... //DUST    
.................... //Errors   
....................              
.................... ////////////////////Version//////////////////////////////////////////////////// 
.................... #define FIRMWARE_VERSION 0xE310           
....................                              
.................... ////////////////////NETWORK ID///////////////////////////////////////////////// 
....................  
.................... #define NETWORK_ID_DEF  0x04cd 
.................... // somewhat arbitrary.  Blue box as delivered default net id. 
.................... // Refer to 04cd blue box as center pivot number 0  
....................  
.................... ////////////////////Priority Queue///////////////////////////////////////////// 
.................... // Maximum number of items in priority queue. Each item is 1 byte and in RAM 
.................... // Actual number of items is max - 1 as item 0 is reserved for sorting use 
.................... #define MAX_PRIORITY_QUEUE_ITEMS   20 
....................  
.................... // Priority Queue items (identified by their priority) (1-255) 
.................... // lower number is higher priority 
.................... #define EMPTY_PRIORITY_QUEUE           0x00 
....................  
.................... #define WAIT_FOR_BOOT_EVENT            0x10 
.................... #define RESET_MOTE                     0x11 
....................  
.................... #define DEAL_WITH_NEW_PACKET           0x20 
....................  
.................... #define VALVE_MOVE_ERROR               0x30 
.................... #define CALIBRATE_VALVE_1              0x31 
.................... #define CALIBRATE_VALVE_2              0x32                   
.................... #define CALIBRATE_VALVE_3              0x33 
.................... #define CALIBRATE_VALVE_4              0x34 
.................... #define CALIBRATE_VALVE_5              0x35 
.................... #define CALIBRATE_VALVE_6              0x36 
.................... #define CALIBRATE_FSR_1                0x37 
.................... #define CALIBRATE_FSR_2                0x38            
.................... #define CALIBRATE_FSR_3                0x39 
.................... #define CALIBRATE_FSR_4                0X3A 
.................... #define MOVE_VALVE_MAG_DECOUPLING_RECOVERY 0x3C              
.................... #define MOVE_VALVE_NO_SPIN_RECOVERY        0x3D  
.................... #define OPEN_VALVE_UNKNOWN_STATE       0x3E       
.................... #define MOVE_VALVE                     0x40 
....................  
.................... #define START_GPS_AQUISITION           0x50 
.................... #define CHECK_GPS_FOR_LOCK             0x51  
.................... #define TAKE_XCDR_MESUREMENT_1         0x55 
.................... #define TAKE_XCDR_MESUREMENT_2         0x56   
.................... #define OPTIMIZE_MPPC                  0xA0 
....................  
.................... #define CHECK_BATTERY_STATE            0xA1 
.................... #define CHECK_MOTE_TEMP                0xA2 
.................... #define UPDATE_MOTE_TIME               0xA3 
.................... #define UPDATE_MOTE_NETWORK_INFO       0xA4 
....................  
.................... #define SEARCH_FOR_STRONGEST_1         0xB1 
.................... #define SEARCH_FOR_STRONGEST_2         0xB2 
.................... #define INIT_JOIN                      0xB3 
.................... #define CHECK_MOTE_STATE               0xB4 
.................... #define CHECK_MOTE_INFO                0xB5 
....................  
.................... #define BUSCOL_RESET                   0xC0 
....................  
.................... #define LCD_DISPLAY_RUN_MODULATION     0xD1 
.................... #define LCD_DISPLAY_RUN_NO_MODULATION  0xD2 
.................... #define LCD_DISPLAY_RBUF               0xD3 
.................... #define LCD_UPDATE                     0xD4 
....................  
.................... #define CPU_RESET                      0xF0 
.................... #define SHUTDOWN_SYSTEM                0xF1 
....................  
.................... // Macros used to push things to priority queue 
.................... #define PUSH_PRIORITY_QUEUE_MACRO(x)                                          \ 
.................... {disable_interrupts(INT_CCP4);                                                  \ 
.................... push_priority_queue(x);                                                       \ 
.................... enable_interrupts(INT_CCP4);} 
....................                                   
.................... #define PUSH_PRIORITY_QUEUE_ISR_MACRO(x) {push_priority_queue_ISR(x);}  
....................                                   
.................... ////////////////////Time Queue///////////////////////////////////////////////// 
.................... // Maximum number of items in time queue. Each item is 5 bytes and in RAM 
.................... // Actual number of items is max - 1 as item 0 is reserved for sorting use 
.................... #define MAX_TIME_QUEUE_ITEMS   5 
....................  
.................... // empty spot in the time queue, used as return item to signify empty top spot 
.................... #define EMPTY_TIME_QUEUE 0 
....................  
.................... // struct of individual time queue item 
.................... struct TimeQueueItem  
.................... { 
....................    uint32_t time_to_execute; 
....................    uint8_t pq_priority; 
.................... }; 
....................  
.................... // Macro for pushing items onto the time queue 
.................... #define PUSH_TIME_QUEUE_MACRO(x,y)  {disable_interrupts(INT_CCP4);            \ 
....................                                     push_time_queue(x,y);                     \ 
....................                                     enable_interrupts(INT_CCP4);}   
....................                                  
.................... ////////////////////Periodic checks/updates done in the time queue 
.................... // How often "long-term" checks are done within ccp4 (timer interrupt) in seconds 
....................    // - mote state (reacts as necessary) 
....................    // - battery state (turns off/on charging, sends warnings, etc.) 
....................    // - mote temp (logs data, sends warnings, etc.) 
....................    // - mote utc time (updates utc time if valid) 
.................... #define PERIODIC_CHECKS_TIME      32 
....................  
.................... ////////////////////Command Queue////////////////////////////////////////////// 
.................... // depth of command queue 
.................... #define MAX_COMMAND_QUEUE_ITEMS 10 
....................  
.................... // maximum number of sprinkler zones in each command coming from manager 
.................... #define MAX_NUM_SPRINKLER_ZONES 4 
....................  
.................... // struct for individual sprinkler zone settings 
.................... struct SprinklerZoneSettingsItem 
.................... { 
....................    uint16_t vlv_open_amount; 
....................    uint16_t spin_rate; 
....................    uint8_t duty_cycle; 
.................... }; 
....................  
.................... // struct for a single command (coming from manager) and item in the command 
.................... // queue 
.................... struct CommandQueueItem 
.................... { 
....................    uint32_t start_time; 
....................    uint32_t end_time; 
....................    struct SprinklerZoneSettingsItem* sprinkler_settings; 
....................    uint8_t num_of_zones; 
....................    uint8_t control_loop_mechanism; 
.................... }; 
....................  
.................... ////////////////////Sprinkler Queue//////////////////////////////////////////// 
.................... // depth of sprinkler queue (ONLY SETUP FOR 2 AT THE MOMENT) 
.................... //#define MAX_SPRINKLER_QUEUE_ITEMS 2 
.................... #define MAX_SPRINKLER_QUEUE_ITEMS 10 
....................  
.................... // struct for single sprinkler queue item 
.................... struct SprinklerQueueItem 
.................... { 
....................    uint32_t start_time; 
....................    uint32_t end_time; 
....................    uint16_t vlv_open_amount; 
....................    uint16_t spin_rate; 
....................    uint8_t zone_num; 
....................    uint8_t control_loop_mechanism; 
.................... }; 
....................  
.................... #define EMPTY_SPINKLER_QUEUE 0 
.................... /////////////////////Message Queue///////////////////////////////////////////// 
.................... // depth of message queue 
.................... #define MAX_MESSAGE_QUEUE_ITEMS 10  
....................  
.................... // empty spot in the message queue, used as return item to signify empty top spot 
.................... #define EMPTY_MESSAGE_QUEUE 0 
....................  
.................... // how many times will messages be attempted before an error message/bit is sent/set 
.................... #define MAX_UNSOLICITED_MESSAGE_ATTEMPTS 3 
....................                                                                      
.................... // how long to wait between message reattempts in seconds 
.................... #define MESSAGE_RESEND_WAIT_PERIOD 60 
....................  
.................... // how often identical error messages are able to be resent (if there haven't been any other types of error messages) in seconds 
.................... #define ERR_MESSAGE_WAIT_PERIOD 60                                                             
....................                                                                                             
.................... // struct for single message queue item 
.................... struct MessageQueueItem 
.................... {                                            
....................    uint32_t time_to_send; 
....................    uint8_t message_type; 
....................    uint16_t msg_seq; 
....................    uint8_t attempt_num; 
.................... }; 
....................  
.................... // Macro for pushing items onto the message queue 
.................... #define PUSH_MESSAGE_QUEUE_MACRO(x)  {disable_interrupts(INT_CCP4);           \ 
....................                                        push_message_queue(x);                 \ 
....................                                        enable_interrupts(INT_CCP4);}    
....................                                         
.................... #define PUSH_MESSAGE_QUEUE_ISR_MACRO(x)  {disable_interrupts(INT_CCP4);       \ 
....................                                           push_message_queue_isr(x);              \ 
....................                                           enable_interrupts(INT_CCP4);}                                           
....................                                         
.................... // Macro for deleting items off the message queue 
.................... #define REMOVE_MESSAGE_QUEUE_MACRO(x)  {disable_interrupts(INT_CCP4);         \ 
....................                                        remove_message_queue_item(x);          \ 
....................                                        enable_interrupts(INT_CCP4);}                                        
....................  
.................... /////////////////////Gen RPM/////////////////////////////////////////////////// 
.................... #define CCP_PER_RPM     2576980378L                                      
.................... // 39322 shifted 16 places left 
.................... // The timer used for the RPM measurement (CCP5) is 32.768KHz clock 
.................... // Stepper has 50 poles.... 
.................... // stepper output frequency = 50 * revs/sec = 50/60 * RPM                    
.................... // stepper output period = 1.2 / RPM 
.................... // CCP counter period = 1/32768 
.................... // CCP counts = (1.2/RPM) / (1/32768) = 39321.6 / RPM 
.................... // RPM = 39322/(CCP counts)  
....................                                                            
.................... #define T5_PER_RPM      69120 
.................... // assumes 921.6KHz div4 div4 into TIMER5 (or use of CCP5 with TMR5) 
.................... // assumes that stepper has 50 poles.... 
.................... // stepper output frequency = 50 * revs/sec = 50/60 * RPM 
.................... // stepper output period = 1.2 / RPM 
.................... // CCP counter period = 16/921.6K 
.................... // CCP counts = (1.2/RPM) / (16/921.6K) = 69120 / RPM 
.................... // RPM = 69120/(CCP counts) 
....................  
.................... ////////////////////Control Algorithm Defines////////////////////////////////// 
.................... // Min/Max Value of braking 
.................... #define NO_BRK    0 
.................... #define MAX_BRK   400 
....................  
.................... // Min/Max Value of charging 
.................... #define NO_CHARGE    0 
.................... #define MAX_CHARGE   400 
....................  
.................... // Min/Max Value of MPPC 
.................... #define NO_MPPC    0x07 
.................... #define MAX_MPPC   0xFF 
....................  
.................... // Min/Max setting of rpm 
.................... #define MIN_RPM_SETTING    10  
.................... #define MAX_RPM_SETTING    250 
....................  
.................... // Min/Max Value of fixture dac setting 
.................... // Set DAC on lab fixture to 0xC00 to sink ALL the current from the power 
.................... // source...  750mA (Test fixture setup:  full scale (0x1000) draws 1A 
.................... #define NO_FIXTURE    0x000 
.................... #define MAX_FIXTURE   0xC00 
....................  
.................... // Battery Charging cutoffs (in adc counts summed over 4 samples) 
.................... // When to stop charging the battery (3.5V while charging) 
.................... #define BATTERY_STOP_CHARGING    1402 
.................... // Hysteresis to start charging the battery again (3.3V while NOT charging) 
.................... #define BATTERY_START_CHARGING   1490 
.................... // When to warn the manager that the battery is dying (3.1V while NOT charging) 
.................... #define BATTERY_WARN             1584      
.................... // When to put the mote to sleep (3.0V while NOT charging) 
.................... #define BATTERY_DEAD             1637   
....................  
.................... // defines for global_control_loop_mechanism 
.................... // Shows what is being used to control rpm in control loop 
.................... // No rpm control is generally used for test modes 
.................... // No rpm control fsr will set braking and charging to 0 for FSR Calibration 
.................... // regular mode with both engaged 
.................... #define BRAKE_AND_CHARGE_START      0x00 
.................... // regular mode with charging turned off (due to full battery most likely) 
.................... #define BRAKE_AND_CHARGE            0x01 
.................... // regular mode with charging turned off (due to full battery most likely) 
.................... #define BRAKE_ONLY                  0x02 
.................... // test mode where charging is force off 
.................... #define FORCE_BRAKE_ONLY            0x03 
.................... // test mode where braking is forced off 
.................... #define FORCE_CHARGE_ONLY           0x04 
.................... // test mode where brake and charge are set 
.................... #define NO_RPM_CONTROL              0x05 
.................... // test mode where brake and charge are set and dynamic mppc is used 
.................... #define NO_RPM_CONTROL_DYN_MPPC     0x06 
.................... // FSR calibration (no brake/charge/rpm control) 
.................... #define NO_RPM_CONTROL_FSR          0x07 
.................... // magnetic decoupling recovery 
.................... #define NO_SPIN_RECOVERY            0x08 
.................... // magnetic decoupling recovery             
.................... #define MAG_DECOUPLING_RECOVERY     0x09   
.................... // idle (nothing in the queue). Disable control loop    
.................... #define NO_SPRINKLER_CONTROL        0xFF 
....................  
.................... ////////////////////Valve////////////////////////////////////////////////////// 
.................... // Starting position of the DAC (also works as the eeprom stored inital value) 
.................... #define VLV_POSITION_UNKNOWN         0xFFFF 
.................... // Fully closed valve position 
.................... #define VLV_POSITION_CLOSED          0x0000 
.................... // Fully open valve position      
.................... #define VLV_POSITION_OPENED          0x8000 
....................  
.................... // moved to eeprom stuff 
.................... /* 
.................... // Maximum value of "near closed" range 
.................... #define VLV_NEAR_CLOSED_RANGE_MAX    0x1000 
.................... // Maximum value of "near opened" range 
.................... #define VLV_NEAR_OPENED_RANGE_MAX    0x7000 
.................... */ 
.................... // default valve position for pre-calibration                     
.................... #define VLV_PRECALIBRAION_POSITION   0x4000 
.................... // Amount to move open in calibration routine 1 in units of valve position 
.................... #define VLV_CAL_1_MOVEMENT           0x2000     
....................  
.................... //moved to eeprom stuff 
.................... /* 
.................... // DAC level while opening near the fully open end 
.................... #define DAC_LVL_OPENING_NEAR_OPENED       22        
.................... // DAC level while opening near the fully closed end 
.................... #define DAC_LVL_OPENING_NEAR_CLOSED       15    
.................... // DAC level while closing near the fully open end 
.................... #define DAC_LVL_CLOSING_NEAR_OPENED       15 
.................... // DAC level while closing near the fully closed end 
.................... #define DAC_LVL_CLOSING_NEAR_CLOSED       21 
.................... // DAC level while moving in the middle of the valve range and it's default 
.................... #define DAC_LVL_IN_MIDDLE                 18 
.................... // DAC level for the inital current boost/lowered current limit   
.................... #define DAC_LVL_INIT_CURRENT_BOOST        15             
.................... */ 
....................  
.................... // Valve timeout in millispans (maximum number of millispans that it can move  
.................... //    without error).  1024 is the full range. 
.................... #define VALVE_TIMEOUT                     1500 
....................  
.................... // Number of movements since an endstop before triggering a re-calibration of 
.................... //    endstop position (done before/triggered by a pending move) 
.................... #define VLV_MOVES_BEFORE_RECAL            25          
....................                                               
.................... // moved to eeprom stuff 
.................... /* 
.................... // Amount of millispans that a current boost/lovered dac level is implemented. 
.................... //    This is done outside of the (NEAR_CLOSED/OPEN_RANGE) 
.................... //    @ 45 seconds to close, 30 = 1.3 seconds 
.................... #define VLV_INIT_CURRENT_BOOST_TIME_1024THS   30      
.................... */                                     
....................  
.................... // default time_to_open/close.  This is the number of 2ndary Osccilator ticks 
.................... //    for 1/1024th of the span if the entire open-close takes 45 seconds. 
.................... #define DEFAULT_VLV_TIME_TO_OPEN          1280   
.................... #define DEFAULT_VLV_TIME_TO_CLOSE         1280        
....................     
.................... // if vlv_time_to_close/open is below this number, errors are thrown and calibration  
.................... //     is thrown away.  750 = 23.4375 seconds 
.................... #define ERROR_VLV_CAL_TIME                 750    
....................  
.................... // moved to eeprom stuff 
.................... /* 
.................... // valve not-spinning and magnetic de-coupling defines                                                     
.................... // below this number is the regime where we watch for the vgen not spinning case 
.................... #define VLV_NOT_SPIN_LIMIT                0x6000 
.................... // where we send the valve when we want to fix it.  If it gets fixed before reaching this valve position 
.................... //    it stops. If it does not get fixed by the time it reaches this position, it sends an error and stops. 
.................... #define VLV_NOT_SPIN_FIX                  0x7000 
....................                                             
.................... // above this rpm, consider magnetic coupling or not-spinning fixed 
.................... #define NOT_SPINNING_MAG_DECOUPLING_RPM_FIXED   8        
....................                                                    
.................... // above this number is the regime where we watch for the vgen not spinning case 
.................... #define VLV_MAGNETIC_COUPLING_LIMIT       0x6000        
.................... // where to move the valve at a time when trying to recover  
.................... #define VLV_MAGNETIC_COUPLING_FIX         0x2000          
.................... // amount to move the valve at a time when trying to recover 
....................                                                   
.................... // how many seconds it takes to consider the rpm to be zero (or infitie for higher valve settings)  
.................... // 8 = 7.5 RPM (8 may be max of what ccp5 can handle without overflow)             
.................... #define RPM_TIMEOUT                      8        
.................... */                                                         
....................  
.................... // defines for testing valve state 
.................... #define  IS_VLV_COASTING   (LATE == 0) 
.................... #define  IS_VLV_CLOSING    (LATE == 0x01) 
.................... #define  IS_VLV_OPENING    (LATE == 0x02) 
.................... #define  IS_VLV_BRAKING    (LATE == 0x03) 
....................  
.................... // macros for making the valve move 
.................... #define  mV_COASTm   {LATE=0;} 
.................... #define  mV_CLOSEm   {LATE=0x01;} 
.................... #define  mV_OPENm    {LATE=0x02;} 
.................... #define  mV_BRAKEm   {LATE=0x03;}                                                                                                                      
....................  
.................... ////////////////////XDCR///////////////////////////////////////////////////////  
.................... // limit for detecting if the XDCR is plugged in or not.   
.................... // there is a ~5.6M resistor pulling the line up to vcc. 
.................... // It sums 8 measurements and with the weak pullups is usually around 6200 
.................... // To account for variation, we will set 5000 (around 75 psi on the 100 psi sensor) 
.................... // as the limit to detect it.         
.................... #define XDCR_ADC_OFF_LIMIT 5000      
....................                                                      
.................... ////////////////////RB ISR/////////////////////////////////////////////////////   
.................... // seconds you have to press SW1 until it activate the long press function 
.................... #define SW1_ISR_LONG_PRESS_TIME 5  
....................                                              
.................... ////////////////////I2C Addresses////////////////////////////////////////////// 
.................... #define LCD_ADDRESS 0x7C 
.................... #define XDCR_ADDRESS 0x48         
.................... #define FIXTURE_DAC_ADDRESS 0x40     
....................                                     
.................... ////////////////////LCD Defines////////////////////////////////////////////////     
.................... // total number of lcd pages defined in switch-case in LCD_update_diplay()      
.................... #define TOTAL_LCD_PAGES 3                              
....................                                             
.................... ////////////////////DUST Defines/////////////////////////////////////////////// 
.................... // moved to eeprom stuff 
.................... /*                                             
.................... // amount of seconds for mote to stay searching for advertisements                     
.................... #define MOTE_SEARCH_TIME 120        
.................... // amount of time the mote will stay disconnected from the network before shutting down (900 = 15 min)    
.................... #define MOTE_NETWORK_SHUTDOWN_TIMEOUT 900            
.................... */ 
....................  
.................... // Min temperature before sending a warning/shutdown 
.................... #define MOTE_MIN_TEMP_WARNING   -35 
.................... #define MOTE_MAX_TEMP_WARNING    80                                       
.................... #define MOTE_MIN_TEMP_SHUTDOWN   -40 
.................... #define MOTE_MAX_TEMP_SHUTDOWN   85                                                             
....................  
.................... //Crazy macro for finding control escape 
.................... #define STUFF_BYTE(x, y, z)  { \ 
....................     if ((x==CONTROL_ESCAPE)||(x==FLAG_SEQUENCE)) { \ 
....................         y[z++] = CONTROL_ESCAPE; \ 
....................         y[z++] = x ^ XOR_BYTE; \ 
....................     } else { \ 
....................         y[z++] = x;     \ 
....................     } \ 
.................... } 
....................  
.................... #define STUFF_BYTE_ISR(x, y, z)  { \ 
....................     if ((x==CONTROL_ESCAPE)||(x==FLAG_SEQUENCE)) { \ 
....................         y[z++] = CONTROL_ESCAPE; \ 
....................         y[z++] = x ^ XOR_BYTE; \ 
....................     } else { \ 
....................         y[z++] = x;     \ 
....................     } \ 
.................... } 
....................  
.................... // defines for msg_id (Manager->Mote Payload message ID to Micro) 
.................... #define MSG_MGR_ACK                       0x01 
.................... #define MSG_MGR_NACK                      0x02 
....................                                                           
.................... #define MSG_MGR_FULL_REPORT               0x10 
.................... #define MSG_MGR_HEALTH_REPORT             0x11 
.................... #define MSG_MGR_VALVE_REPORT              0x12 
....................  
.................... #define MSG_MGR_WARM_RESTART              0x20 
.................... #define MSG_MGR_COLD_RESTART              0x21 
.................... #define MSG_MGR_FORCE_REJOIN              0x22 
.................... #define MSG_MGR_SHUTDOWN                  0x23 
....................  
.................... #define MSG_MGR_UPDATE_SP_NUM             0x30 
.................... #define MSG_MGR_CAL_VALVE                 0x31 
.................... #define MSG_MGR_CAL_FSR                   0x32 
.................... #define MSG_MGR_AQUIRE_GPS                0x33 
.................... #define MSG_MGR_UPDATE_EEPROM             0x34  
.................... #define MSG_MGR_READ_EEPROM               0x35  
.................... #define MSG_MGR_READ_XDCR                 0x36 
....................  
.................... #define MSG_MGR_RUN_CMD_NO_MOD            0x40 
.................... #define MSG_MGR_RUN_CMD_MOD               0x41 
.................... #define MSG_MGR_TEST_NO_RPM_CTRL          0x42 
.................... #define MSG_MGR_TEST_RPM_CTRL             0x43 
.................... #define MSG_MGR_DEMO                      0x44 
.................... #define MSG_MGR_CLEAR_SPINKLER_CMD_QUEUE  0x45 
....................  
.................... // defines for msg_id (Micro to Mote) 
.................... #define MSG_MOTE_UNSOLICITED              0x00 
.................... #define MSG_MOTE_ACK                      0x80 
.................... #define MSG_MOTE_NACK                     0x81          
....................  
.................... #define MSG_MOTE_FULL_REPORT              0x90 
.................... #define MSG_MOTE_HEALTH_REPORT            0x91 
.................... #define MSG_MOTE_VALVE_REPORT             0x92                  
.................... #define MSG_MOTE_SPINKLER_CMD_RESPONSE    0x93 
.................... #define MSG_MOTE_JOIN_MSG                 0x94       
.................... #define MSG_MOTE_UPDATE_SP_NUM_RESPONSE   0x95 
.................... #define MSG_MOTE_GPS_POINT_MSG            0x96    
.................... #define MSG_MOTE_EEPROM_READ_RESPONSE     0x97 
.................... #define MSG_MOTE_XDCR_READ_MSG            0x98    
.................... #define MSG_MOTE_ERROR_MSG                0xA0 
....................  
....................  
.................... ////////////////////Status Defines///////////////////////////////////////////// 
.................... ////////////////////Mote Statuses (for global_mote_status) 
.................... /* From jack_dn2500.h 
.................... // Mote Status values 
.................... #define MOTESTATE_INIT           0x00     // Mote is booting. 
.................... #define MOTESTATE_IDLE           0x01     // Mote is accepting config cmds.   
....................                                           //  Upon receiving a join cmd, mote  
....................                                           //  moves into the Searching state. 
....................                                           //  Idle state is low power state. 
.................... #define MOTESTATE_SEARCHING      0x02     // Mote's rcvr is on with a  
....................                                           //  configurable duty cycle while 
....................                                           //  mote is actively searching for net.  
.................... #define MOTESTATE_NEGOTIATING    0x03     // Mote has detected a network  
....................                                           //  and is attempting to connect. 
.................... #define MOTESTATE_CONNECTED      0x04     // Mote has joined the net 
.................... #define MOTESTATE_OPERATIONAL    0x05     // Mote has links to both net mgr and 
....................                                           //  gateway; ready to send data. 
.................... #define MOTESTATE_DISCONNECTED   0x06     // Mote is disconnected. 
.................... #define MOTESTATE_RADIOTEST      0x07 
.................... #define MOTESTATE_PROMISCUOUS    0x08 
.................... #define MOTESTATE_UNKNOWN        0xFF 
.................... */ 
....................  
.................... ////////////////////System States (for global_system_state) 
.................... #define SYSTEM_INIT                       0x00 
.................... #define SYSTEM_PAUSE                      0x01 
.................... #define SYSTEM_RUN                        0x02 
.................... #define SYSTEM_SLEEP                      0x03 
.................... // valve opening a little bit to ensure we dont jam into close endstop 
.................... #define SYSTEM_CAL_VLV_1                  0x10 
.................... // valve closing towards closing endstop pre-calibration 
.................... #define SYSTEM_CAL_VLV_2                  0x11 
.................... // valve opening fully from fully closed for calibration 
.................... #define SYSTEM_CAL_VLV_3                  0x12 
.................... // doing FSR w/ valve fully open 
.................... #define SYSTEM_CAL_VLV_4                  0x13 
.................... // valve closing fully from fully open for calibration 
.................... #define SYSTEM_CAL_VLV_5                  0x14 
.................... // calibration routine is done, send message to manager and prepare system for 
.................... //    idle/run mode 
.................... #define SYSTEM_CAL_VLV_6                  0x15 
.................... // valve is moving towards one of the endstops trying to recalibrate it's position 
.................... #define SYSTEM_RECAL_VLV_MOVES            0x16 
.................... // valve is moving (outside of calibrate valve routine) 
.................... #define SYSTEM_MOVE_VALVE                 0x17 
.................... // Move valve to desired setting 
.................... #define SYSTEM_CAL_FSR_1                  0x18 
.................... // do fsr calibration 
.................... #define SYSTEM_CAL_FSR_2                  0x19 
.................... // move valve back to original position 
.................... #define SYSTEM_CAL_FSR_3                  0x1A 
.................... // fsr is done, send message to manager and restore previous state/run mode 
.................... #define SYSTEM_CAL_FSR_4 
....................  
.................... // system is searching for a network 
.................... #define SYSTEM_SEARCHING_FOR_NETWORK      0x20 
.................... // system is connecting to a network 
.................... #define SYSTEM_CONNECTING_TO_NETWORK      0x21 
.................... // ????? 
.................... #define SYSTEM_STATE_UNKNOWN              0xFF 
....................  
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////////////////////Error Defines////////////////////////////////////////////// 
.................... /////////////////////////////////////////////////////////////////////////////// 
....................  
.................... ////////////////////Deep sleep/shutdown/restart reasons/errors 
.................... // stored in global_shutdown_errors_bitfield and EEPROM and shown on screen before deep sleep 
.................... // no error 
.................... #define NO_ERR                            0x00 
.................... // mote doesn't respond after a reset 
.................... #define ERR_FAIL_ON_MOTE_RESET            0x01 
.................... // mote receives no advertisement from managers 
.................... #define ERR_NO_ADV_WHILE_SEARCHING        0x02 
.................... // mote has set it's network manager id during search succesfully 
.................... #define NEW_NETWORK_ID_SET                0x03 
.................... // mote does not respond properly to a request 
.................... #define ERR_MOTE_UNRESPONSIVE             0x04 
.................... // mote is outside of operating range (defined under dust) 
.................... #define ERR_MOTE_OUT_OF_TEMP_RANGE        0x05 
.................... // network was unable to join properly 
.................... #define ERR_NETWORK_JOIN_FAIL             0x06 
.................... // unable to set join duty on mote properly 
.................... #define ERR_MTJOINDUTY                    0x07 
.................... // unable to join network with joinkey 
.................... #define ERR_MTJOINKEY                     0x08 
.................... // warm restart requested by manager 
.................... #define WARM_RESTART_REQUEST              0x09 
.................... // cold restart requested by manager 
.................... #define COLD_RESTART_REQUEST              0x0A 
.................... // shutdown requested by manager           
.................... #define MANAGER_SHUTDOWN_REQUEST          0x0B 
.................... // battery is dead 
.................... #define ERR_BATT_DEAD_SLEEP               0x0C 
.................... // network timeout 
.................... #define ERR_NO_NETWORK_TIMEOUT            0x0D 
....................  
.................... // freshly programmed (EEPROM defaults to all F,F,F...F) 
.................... #define NEWLY_PROGRAMMED                  0xFF 
....................  
....................  
.................... ////////////////////global error bitfield errors for sending to manager 
.................... // unsolicited message not ack'd after max attempts 
.................... #define ERR_MSG_UNSOLICITED_MESSAGE_NOT_ACKD       0x00000001 
.................... // state incompatible with requested action 
.................... #define ERR_MSG_INCOMPATIBLE_STATE                 0x00000002 
.................... // valve not calibrated (so it can't move to a position) 
.................... #define ERR_MSG_VLV_NOT_CALIBRATED                 0x00000004 
.................... // mote was unresponsive in system (busy likely) 
.................... #define ERR_MSG_MOTE_UNRESPONSIVE                  0x00000008 
.................... // rpm set point is too high to reach (no charging or braking and still no go) 
.................... #define ERR_MSG_RPM_TOO_HIGH_TO_REACH              0x00000010 
.................... // rpm is too low to reach (full charging, braking and still no go) 
.................... #define ERR_MSG_RPM_TOO_LOW_TO_REACH               0x00000020 
.................... // mote temperature is out of range (sleep) 
.................... #define ERR_MSG_MOTE_TEMP_OUT_OF_RANGE             0x00000040 
.................... // battery is low (warning) 
.................... #define ERR_MSG_BATT_LOW_WARN                      0x00000080 
.................... // battery is dead (going to sleep) 
.................... #define ERR_MSG_BATT_DEAD_SLEEP                    0x00000100 
.................... // valve calibration was invalid (too short) 
.................... #define ERR_MSG_VLV_CAL_FAIL                       0x00000200 
.................... // valve hit an endstop outside of the "closing when opened" etc. areas (close to the endstops) 
.................... #define ERR_MSG_VLV_MOVE_FAIL                      0x00000400 
.................... // not spinning condition detected, recovery attempt proceeding 
.................... #define ERR_MSG_NOT_SPINNING                       0x00000800 
.................... // magnetic decoupling condition detected, recovery attempt proceeding 
.................... #define ERR_MSG_MAG_DECOUPLING                     0x00001000                      
.................... // not spinning condition or magnetic decoupling condition recovery failed (going to sleep (another message afterwards)) 
.................... #define ERR_MSG_MAG_NOT_SPIN_RECOVERY_FAILED       0x00002000 
.................... // signal that system is in invalid state to do run command (e.g. cal vlv, recal vlv, fsr) 
.................... #define ERR_MSG_SPINKLER_CMD_DELAYED_INVALID_STATE 0x00004000    
.................... // signal that the mote is going to shutdown/sleep (or with another reason) 
.................... #define ERR_MSG_MOTE_GOING_TO_DEEP_SLEEP           0x80000000 
....................  
.................... /* 
.................... // message needs to be sent now! Disregard message waiting time. 
.................... #define ERR_MSG_HIGH_PRIORITY                    0x80000000 
.................... */ 
....................  
.................... ////////////////////NACK Bitfield Errors 
....................  
.................... // valve position not calibrated 
.................... #define NACK_BITFIELD_VLV_POSITION_UNKNOWN         0x00000001 
.................... // invalid valve setting requested 
.................... #define NACK_BITFIELD_INVALID_VLV_SETTING          0x00000002 
.................... // invalid rpm setting requested 
.................... #define NACK_BITFIELD_INVALID_RPM_SETTING          0x00000004 
.................... // invalid brake pwm setting requested 
.................... #define NACK_BITFIELD_INVALID_BRAKE_SETTING        0x00000008 
.................... // invalid charge pwm setting requested 
.................... #define NACK_BITFIELD_INVALID_CHARGE_SETTING       0x00000010 
.................... // state incompatible with requested action 
.................... #define NACK_BITFIELD_INCOMPATIBLE_STATE           0x00000020 
.................... // battery is too low for requested action 
.................... #define NACK_BITFIELD_BATT_TOO_LOW                 0x00000040 
.................... // don't have the required hardware for requested operation (e.g. gps, xdcr) 
.................... #define NACK_BITFIELD_INVALID_HARDWARE             0x00000080 
.................... // info recived during eeprom update is invalid (invalid range, number of bytes) 
.................... #define NACK_BITFIELD_INVALID_EEPROM_SETTINGS      0x00000100 
.................... // invalid mppc setting requested 
.................... #define NACK_BITFIELD_INVALID_MPPC_SETTING         0x00000200 
....................  
.................... ////////////////////get and send dustmsg_ISR Errors and pkdecode errors 
.................... // Where the errors start (for checking return values in deal_with_mote) 
.................... #define ERR_BAD_PAYLOAD                   249 
.................... #define ERR_DUSTMSG_START_OF_ERRORS       250 
.................... // CRC errors in pkdecode 
.................... #define ERR_DUSTMSG_CRC                   251 
.................... // Timeout on first byte 
.................... #define ERR_DUSTMSG_TIMEOUT               252 
.................... // RS232 errors from getc() 
.................... #define ERR_DUSTMSG_RS232                 253 
.................... // Framing Error 
.................... #define ERR_DUSTMSG_FRAMING_ERROR         254 
.................... // Message < 6 bytes (too short) 
.................... #define ERR_DUSTMSG_MESSAGE_LENGTH        255 
....................  
....................  
.................... #include "function_headers.h"                   
.................... //pic.h 
.................... void fosc_pri(void); 
.................... void fosc_pri_ISR(void); 
.................... void fosc_4m(void); 
.................... void fosc_1m(void); 
.................... void fosc_250k(void); 
.................... void fosc_31250(void); 
.................... void fosc_sec(void); 
.................... void osc_init(void); 
.................... void setup_T0_int(uint16_t value); 
.................... void setup_T2_int(uint8_t value); 
.................... void setup_T4_int(uint8_t value); 
.................... void periph_init(void); 
.................... void vars_init(void);      
.................... void deep_sleep(); 
.................... void start_rtc(void); 
.................... void safeI2C_start(void); 
.................... void safeI2C_write(uint8_t value); 
....................  
.................... //eeprom.h 
.................... uint8_t read_ee1(uint16_t source); 
.................... uint16_t read_ee2(uint16_t source); 
.................... uint32_t read_ee4(uint16_t source); 
.................... void write_ee1(uint16_t dest, uint8_t dat8); 
.................... void write_ee2(uint16_t dest, uint16_t dat16); 
.................... void write_ee4(uint16_t dest, uint32_t dat32); 
.................... void store_all_eeprom_values(void);   
.................... void read_all_eeprom_values(void);                   
.................... void store_vcal_eeprom_values(void);   
.................... void read_all_eeprom_variables(void);                               
....................  
.................... //periph.h (LCD + XDCR) 
.................... //LCD declerations 
.................... void LCD_init(void); 
.................... void LCD_line1(unsigned char *text); 
.................... void LCD_line2(unsigned char *text); 
.................... void LCD_place_text(unsigned char *text, int1 row, uint8_t col, uint8_t length); 
.................... void LCD_place_char(char ascii, int1 row, uint8_t col); 
.................... void LCD_place_uint8(uint8_t num, int1 row, uint8_t col, uint8_t length); 
.................... void LCD_place_uint16(uint16_t num, int1 row, uint8_t col, uint8_t length); 
.................... void LCD_place_uint32(uint32_t num, int1 row, uint8_t col, uint8_t length); 
.................... void LCD_clear(void); 
.................... void LCD_clear_line1(void); 
.................... void LCD_clear_line2(void); 
.................... void LCD_position(int position); 
.................... void LCD_char(char ascii); 
.................... void LCD_shutdown(void); 
.................... void LCD_startup_splash(void); 
.................... void LCD_display_priority_time_stacks(void); 
.................... void LCD_display_priority_time_stacks_2(void); 
.................... void LCD_display_priority_queue(void);    
.................... void LCD_display_message_queue(void);  
.................... void LCD_display_battery_voltage(int1 lcd_line); 
.................... void LCD_display_batt_voltage(int1 lcd_line, uint8_t col, uint8_t precision);      
.................... void LCD_update_diplay(void);      
.................... void XDCR_init(void);   
.................... void adc_XDCR_init(void); 
.................... uint16_t XDCR_measure(void);  
.................... uint16_t adc_XDCR_measure(void);     
.................... void fixture_init(void); 
....................  
.................... //dust.h 
.................... void mote_init(void); 
.................... void mote_reset(void); 
.................... uint8_t mote_sleep(void); 
.................... void search_for_strongest(void); 
.................... void process_advert(void); 
.................... uint8_t initiate_join(void); 
.................... void mote_state_check(void); 
.................... void mote_temp_check(void); 
.................... void mote_time_update(void); 
.................... void init_msgSEQ(void); 
.................... void deal_with_mote_ISR(void); 
.................... uint8_t get_dustmsg_ISR(void); 
.................... void  dust_hdlc_pkgen(uint8_t* prefix, uint8_t size, uint8_t* buf, uint8_t size_buf); 
.................... void  dust_hdlc_pkgen_ISR(uint8_t* prefix, uint8_t size, uint8_t* buf, uint8_t size_buf); 
.................... uint8_t dust_hdlc_pksend(); 
.................... uint8_t dust_hdlc_pksend_ISR(); 
.................... uint8_t dust_hdlc_pkdecode_ISR(uint8_t bytes_to_decode); 
.................... uint16_t fcs_fcs16(uint16_t fcs, uint8_t data); 
.................... uint16_t fcs_fcs16_ISR(uint16_t fcs, uint8_t data); 
.................... static uint16_t fcs_calc(uint8_t* p, uint16_t size); 
.................... static uint16_t fcs_calc_ISR(uint8_t* p, uint16_t size); 
.................... uint8_t deal_with_packet(void); 
.................... void prepare_prefix_and_payload(uint8_t payload_buf_length); 
.................... void prepare_prefix_and_payload_ISR(uint8_t payload_buf_length); 
.................... void generate_message_and_send(); 
.................... void generate_message_and_send_ISR(); 
.................... void send_full_report(uint8_t command_id_in_response_to, uint16_t msg_seq); 
.................... void send_health_report(uint8_t command_id_in_response_to, uint16_t msg_seq); 
.................... void send_valve_report(uint8_t command_id_in_response_to, uint16_t msg_seq); 
.................... void send_sprinkler_cmd_response(uint8_t command_id_in_response_to, uint16_t msg_seq); 
.................... void send_update_sp_num_response(uint8_t command_id_in_response_to, uint16_t msg_seq); 
.................... void send_read_eeprom_response(uint8_t command_id_in_response_to, uint16_t msg_seq, uint16_t eeprom_location, uint32_t eeprom_data);  
.................... void send_pressure_xdcr_msg(uint8_t command_id_in_response_to, uint16_t msg_seq);  
.................... void send_pressure_xdcr_msg_ISR(uint8_t command_id_in_response_to, uint16_t msg_seq);  
.................... void send_ack(uint8_t command_id_in_response_to, uint16_t msg_seq); 
.................... void send_nack(uint8_t command_id_in_response_to, uint16_t msg_seq, uint32_t nack_bitfield); 
.................... void send_health_report_ISR(uint8_t command_id_in_response_to, uint16_t msg_seq); 
.................... void send_valve_report_ISR(uint8_t command_id_in_response_to, uint16_t msg_seq); 
.................... void send_join_msg_ISR(uint8_t command_id_in_response_to, uint16_t msg_seq); 
.................... void send_gps_point_msg_ISR(uint8_t command_id_in_response_to, uint16_t msg_seq); 
.................... void send_error_msg_ISR(uint8_t command_id_in_response_to, uint16_t msg_seq); 
....................  
.................... //util.h 
.................... void flash_leds(uint8_t num_of_flashes); 
.................... void flash_leds_ISR(uint8_t num_of_flashes); 
.................... void happy_lites(void); 
.................... char *word_to_4dig_new (uint16_t xword); 
.................... uint16_t convert_rpm_to_period(uint16_t rpm); 
.................... uint16_t convert_period_to_rpm(uint16_t period); 
.................... uint16_t convert_period_to_rpm_ISR(uint16_t period); 
.................... uint8_t  hi2asc(uint8_t xbyte); 
.................... uint8_t  lo2asc(uint8_t xbyte); 
....................  
.................... //stacks_queues.h 
.................... void clear_priority_queue(); 
.................... uint8_t pop_priority_queue(); 
.................... int1 push_priority_queue(uint8_t new_priority_queue_item); 
.................... void push_priority_queue_ISR(uint8_t new_priority_queue_item); 
.................... void push_priority_queue_ISR2(uint8_t new_priority_queue_item); 
.................... void clear_time_queue(); 
.................... int1 pop_time_queue(); 
.................... void pop_time_queue_ISR(); 
.................... int1 push_time_queue(uint32_t time_to_execute, uint8_t priority); 
.................... void push_time_queue_ISR(uint32_t time_to_execute, uint8_t priority); 
.................... void allocate_command_queue(void); 
.................... void clear_command_queue(void); 
.................... int1 push_command_queue(struct CommandQueueItem new_command_queue_item); 
.................... void clear_message_queue(void); 
.................... void clear_sprinkler_queue(void); 
.................... void push_spinkler_queue(uint32_t start_time,uint32_t end_time,uint16_t vlv_open_amount,uint16_t spin_rate,uint8_t zone_num, uint8_t control_loop_mechanism); 
.................... void pop_sprinkler_queue_ISR(void); 
.................... void pop_message_queue_and_send_ISR(void); 
.................... void push_message_queue(uint8_t message_type); 
.................... void push_message_queue_ISR(uint8_t message_type); 
.................... void remove_message_queue_item(uint16_t msg_seq); 
.................... void remove_message_queue_item_ISR(uint16_t msg_seq); 
....................                                              
.................... //control.h 
.................... void setup_gen_rpm(void); 
.................... uint16_t calc_gen_rpm(void);                           
.................... int1  is_brake_duty_valid(uint16_t value); 
.................... int1  is_charge_duty_valid(uint16_t value); 
.................... int1  is_mppc_valid(uint8_t value); 
.................... int1  is_rpm_setting_valid(uint16_t value); 
.................... void set_brake_duty(uint16_t value); 
.................... void set_charge_duty(uint16_t value);                                  
.................... void set_mppc(uint8_t value); 
.................... void set_fixture_dac(uint16_t dac_value); 
.................... void adjust_brake_for_rpm(uint16_t rpm_set_value); 
.................... void adjust_brake_for_vgen(uint16_t vgen_set_value); 
.................... void adjust_fixture_for_rpm(uint16_t fixture_set_value); 
.................... void setup_control_update_speed_vgen(); 
.................... void adjust_mppc(void);        
.................... void update_control_loop(void); 
.................... void stop_current_spinkler_setting(void); 
.................... void stop_current_spinkler_setting_ISR(void); 
....................  
.................... //battery.h 
.................... uint16_t get_vgen(int1 charge_state); 
.................... uint16_t get_vbatt(int1 charge_state); 
.................... uint16_t get_vbatt_ISR(int1 charge_state); 
.................... uint32_t calc_vbatt(uint16_t vref_count); 
.................... uint16_t calc_vbatt_BCD(uint16_t vref_count); 
.................... void check_and_deal_with_battery(void); 
....................  
.................... //valve.h 
.................... void  cl_valve(void); 
.................... void  op_valve(void); 
.................... void  cl_valve_timed(uint32_t num_ints); 
.................... void  op_valve_timed(uint32_t num_ints); 
.................... void  comparator_setup(void); 
.................... uint16_t calc_valve_movement_time(uint16_t current_location, uint16_t destination); 
.................... void  set_comp_dac_level(void); 
.................... void  set_comp_dac_level_ISR(void); 
.................... int1  is_valve_position_valid(uint16_t value); 
....................  
.................... #include "jack_dn2500.h" 
.................... /* 
....................  * $HeadURL: https://svn/appeng/trunk/dev/src/api/dust_dn2500.h $ 
....................  * $Id: dust_dn2500.h 261 2010-02-19 23:34:29Z kottaway $ 
....................  * 
....................  * Copyright (c) 2006, Dust Networks, Inc 
....................  * All rights reserved. 
....................  * Redistribution and use in source and binary forms, with or without 
....................  * modification, are permitted provided that the following conditions are met: 
....................  * 
....................  *     * Redistributions of source code must retain the above copyright 
....................  *       notice, this list of conditions and the following disclaimer. 
....................  *     * Redistributions in binary form must reproduce the above copyright 
....................  *       notice, this list of conditions and the following disclaimer in the 
....................  *       documentation and/or other materials provided with the distribution. 
....................  *     * Neither the name of Dust Networks, Inc nor the 
....................  *       names of its contributors may be used to endorse or promote products 
....................  *       derived from this software without specific prior written permission. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED BY DUST NETWORKS, INC AND CONTRIBUTORS "AS IS" AND ANY 
....................  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
....................  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
....................  * DISCLAIMED. IN NO EVENT SHALL DUST NETWORKS, INC AND CONTRIBUTORS BE LIABLE FOR ANY 
....................  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
....................  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
....................  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND 
....................  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
....................  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
....................  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  
....................  * 
....................  * This documentation might include technical inaccuracies or other errors.  
....................  * Corrections and improvements might be incorporated in new versions of the  
....................  * documentation. Dust Networks does not assume any liability arising out of  
....................  * the application or use of any products or services and specifically disclaims  
....................  * any and all liability, including without limitation consequential or incidental damages. 
....................  * 
....................  *  
....................  * 
....................  * Dust Networks reserves the right to make corrections, modifications, enhancements, 
....................  * improvements, and other changes to its products or services at any time and to  
....................  * discontinue any product or service without notice. Customers should obtain the  
....................  * latest relevant information before usage and should verify that such information  
....................  * is current and complete. 
....................  */ 
....................   
....................  // NOTE THAT THIS FILE WAS UPDATED TO INCLUDE THE SEARCH capability 
....................  //  now included in the Eterna parts (JG June 2013) 
....................  
.................... /* Max user data size.  This limit is specific to the  
....................  * amount of data that can be sent via radio to/from the Manager. 
....................  * This is not an HDLC limit which might include byte stuffing. 
....................  */ 
.................... #define MAX_USER_DATA_SIZE       94 
....................  
.................... // prior to encoding for transmission 
.................... // cmd(1), len_pkt(1), flags(1), destaddr(2), svc_index(1), appdomain(1), 
.................... // priority(1), reserved(2), sequence_num(1), len_data(1), MAX_USER_DATA_SIZE 
.................... #define MAX_SEND_REQUEST         MAX_USER_DATA_SIZE + 12 
....................  
.................... // include now the delimiters (2), the FCS (w/ byte stuffing could be 4), 
.................... //  of the 12 bytes added above, there may be an extra 2 due to byte stuffing 
.................... //  and the message can be MAX_USER_DATA_SIZE*2 worst case! 
.................... #define MAX_SEND_BUFFER          MAX_USER_DATA_SIZE*2 + 2 + 4 + 12 + 2 
.................... // This adds up to 208! 
....................  
.................... // after decoding the received message 
.................... // cmd(1), len_pkt(1), flags(1), sourceaddr(2), sequence_num(1), len_data(1),  
.................... // MAX_USER_DATA_SIZE 
.................... #define MAX_DATA_RCVD            MAX_USER_DATA_SIZE + 7 
....................  
.................... // prior to decoding, raw rcv data 
.................... // include delimiters (2), the FCS (4 max), of the 7 bytes above there may be 
.................... //  an extra stuffed byte, and the message can be MAX_USER_DATA_SIZE*2! 
.................... #define MAX_RCV_BUFFER           MAX_USER_DATA_SIZE*2 + 2 + 4 + 7 + 1 
.................... // This adds up to 202 
....................   
.................... #define MAX_JOINKEY_SIZE         16 
....................  
.................... #define MAX_BURST_MESSAGE        3 
....................  
.................... #define DESTADDR_GATEWAY         0xF981 
.................... #define DESTADDR_SWAPPED         0x81F9 
.................... #define DESTADDR_HI              0xF9 
.................... #define DESTADDR_LO              0x81 
....................  
.................... // Microprocessor to Mote Commands 
.................... #define CMD_SET            0x01     // Sets param on the mote. 
.................... #define CMD_GET            0x02     // Gets param from mote 
.................... #define CMD_SETNV          0x03     // Stores param in the motes NV 
.................... #define CMD_GETNV          0x04     // Retrieves param from the motes NV 
.................... #define CMD_SEND           0x05     // Packet destined for the network. 
.................... #define CMD_JOIN           0x06     // Requests that mote attempt to join 
.................... #define CMD_DISCONNECT     0x07     // Requests that mote disconnect 
.................... #define CMD_RESET          0x08     // Resets mote. 
.................... #define CMD_SLEEP          0x09     // Shuts down periphs & puts mote to sleep 
.................... #define CMD_TESTRADIOTX    0x0B     // Initiate a series of packet transmissions. 
.................... #define CMD_TESTRADIORX    0x0C     // Test radio reception for a specified chan. 
.................... #define CMD_CLEARNV        0x10     // Resets the motes NV to factory default.. 
.................... #define CMD_SEARCH         0x11     // new Search for networks capability 
....................                                     // (Eterna parts) 
....................  
.................... // Mote to Microprocessor Commands 
.................... #define CMD_TIME           0x0D     // Time and mote state information. 
.................... #define CMD_SERVICE        0x0E     // Notifies micro of changes in service stat. 
.................... #define CMD_EVENT          0x0F     // Notifies micro of new has occurred. 
.................... #define CMD_ADVERT         0x12     // Notifies micro that an adv has been rcvd. 
.................... #define CMD_DATA           0x81     // Packet from the network to the micro. 
....................  
....................  
.................... // Result Codes 
.................... #define RC_OK              0x00     // Operation was successfully completed. 
.................... #define RC_EXE_ERR         0x01     // Reserved. 
.................... #define RC_PARAM_ERR       0x02     // Reserved. 
.................... #define RC_BUSY            0x03     // Operation on this service is in progress. 
.................... #define RC_INVALID_LEN     0x04     // Invalid packet length. 
.................... #define RC_INV_STATE       0x05     // Invalid mote state for command. 
.................... #define RC_UNSUPPORTED     0x06     // Command not supported for hardware. 
.................... #define RC_UNKNOWN_PARAM   0x07     // Unknown parameter value. 
.................... #define RC_UNKNOWN_CMD     0x08     // Unknown command. 
.................... #define RC_WRITE_FAIL      0x09     // Write failure. 
.................... #define RC_READ_FAIL       0x0A     // Read failure. 
.................... #define RC_LOW_VOLTAGE     0x0B     // Voltage check failed. 
.................... #define RC_NO_RESOURCES    0x0C     // No resources (max # services active) 
.................... #define RC_INCOMPLETE_JOIN 0x0D     // Incomplete join information. 
.................... #define RC_NOT_FOUND       0x0E     // Parameter not found. 
.................... #define RC_INVALID_VALUE   0x0F     // Invalid value. 
....................  
....................  
.................... // Parameter Types 
.................... #define PARAM_MACADDR      0x01     // setNV, getNV 
.................... #define PARAM_JOINKEY      0x02     // setNV 
.................... #define PARAM_NETWORKID    0x03     // setNV, getNV 
.................... #define PARAM_TXPOWER      0x04     // set, setNV, getNV 
.................... #define PARAM_POWERINFO    0x05     // setNV, getNV 
.................... #define PARAM_JOINDUTY     0x06     // set 
....................                                     // Allows micro to control  ratio of listen 
....................                                     //  to sleep time during network search 
.................... #define PARAM_BATTLIFE     0x07     // set 
....................                                     // Allows micro to update the remaining  
....................                                     //  battery life that mote reports to mgr 
.................... #define PARAM_SERVICE      0x08     // set. get  
....................                                     // Allows device to initiate service request 
....................                                     //  or update an existing svc 
.................... #define PARAM_SPECIAL1     0x08     // setnv for special join timing, 1st param 
.................... #define PARAM_SPECIAL2     0x09     // setnv for special join timing, 2nd param 
.................... #define PARAM_EVENTMASK    0x0B     // set 
....................                                     // Allows micro to disable events that may  
....................                                     //  be sent in the mote's event notification 
.................... #define PARAM_MOTEINFO     0x0C     // get 
....................                                     // Gets static info about mote hw and sw 
.................... #define PARAM_NETWORKINFO  0x0D     // get 
....................                                     // Gets mote's current net-related params 
.................... #define PARAM_MOTESTATUS   0x0E     // get 
....................                                     // Gets  mote's state and  
....................                                     //  frequently changing information. 
.................... #define PARAM_TIME         0x0F     // get 
.................... #define PARAM_CHARGE       0x10     // get 
....................                                     // Gets  mote's charge consumption. 
.................... #define PARAM_RADIOSTATSRX 0x11     // get 
....................                                     // Gets results of the mote radio rx test 
.................... #define PARAM_TTL          0x13     // get 
....................                                     // Gets "time to live" 
.................... #define PARAM_OTAPLOCK     0x15     // setNV, getNV 
....................                                     // Over-the-air-programming lockout control 
....................  
....................  
.................... // re get service: Service State - note Bit7=0 for no service pending 
.................... //                                          Bit7=1 for service pending 
.................... #define SVCSTATE_INACTIVE        0x00 
.................... #define SVCSTATE_ACTIVE          0x01 
.................... #define SVCSTATE_REQUESTED       0x02 
....................  
.................... // re get/set service: Service Request Flags Bitmask Values 
.................... #define SVCFLAGS_SOURCE          0x01     // Mote is source of data generated. 
.................... #define SVCFLAGS_SINK            0x02     // Mote is receiver of data. 
.................... #define SVCFLAGS_INTERMITTENT    0x04     // Intermittent traffic  
....................                                           //  (as opposed to regular reporting). 
....................  
.................... // Application domain values 
.................... #define APPDOMAIN_PUBLISH        0x00 
.................... #define APPDOMAIN_EVENT          0x01  
.................... #define APPDOMAIN_MAINTENANCE    0x02  
.................... #define APPDOMAIN_BLOCKXFER      0x03 
....................  
.................... // Mote Status values 
.................... #define MOTESTATE_INIT           0x00     // Mote is  booting. 
.................... #define MOTESTATE_IDLE           0x01     // Mote is accepting config cmds.   
....................                                           //  Upon receiving a join cmd, mote  
....................                                           //  moves into the Searching state. 
....................                                           //  Idle state is low power state. 
.................... #define MOTESTATE_SEARCHING      0x02     // Motes rcvr is on with a  
....................                                           //  configurable duty cycle while 
....................                                           //  mote is actively searching for net.  
.................... #define MOTESTATE_NEGOTIATING    0x03     // Mote has detected a network  
....................                                           //  and is attempting to connect. 
.................... #define MOTESTATE_CONNECTED      0x04     // Mote has joined the net 
.................... #define MOTESTATE_OPERATIONAL    0x05     // Mote has links to both net mgr and 
....................                                           //  gateway; ready to send data. 
.................... #define MOTESTATE_DISCONNECTED   0x06     // Mote is disconnected. 
.................... #define MOTESTATE_RADIOTEST      0x07 
.................... #define MOTESTATE_PROMISCUOUS    0x08 
.................... #define MOTESTATE_UNKNOWN        0xFF 
....................  
.................... // mote alarms bit masks 
.................... #define ALARMS_NVERROR           0x01        // Non-volatile error. 
.................... #define ALARMS_LOW_VOLTAGE       0x02        // Mote voltage too low. 
.................... #define ALARMS_OTP               0x04        // One time programmable error 
....................  
....................  
.................... // re get POWERINFO: power source values 
.................... #define PWRSOURCE_LINE           0x00 
.................... #define PWRSOURCE_BATTERY        0x01 
.................... #define PWRSOURCE_SCAVENGE       0x02 
....................  
.................... // re set/get txpower 
.................... #define TXPOWER_MIN              -2       // minimum power; PA off*/ 
.................... #define TXPOWER_MAX              +8       // maximum power; PA on 
....................  
.................... // serviceIndication event codes 
.................... #define SVC_CREATED_UPDATED      0x00 
.................... #define SVC_DELETED              0x01 
.................... #define SVC_REJECTED             0x02 
.................... #define SVC_DELAYED_RESP         0x03 
....................  
.................... // serviceIndication Network Manager Codes 
.................... #define MGRCODE_SUCCESS             0     // no errors 
.................... #define MGRCODE_PARAM_TOOSMALL      4     // ERR: passed param too small 
.................... #define MGRCODE_BYTES_TOOFEW        5     // ERR: too few data bytes rcvd 
.................... #define MGRCODE_DEVICE_ERR          6     // ERR: device-specific cmd error 
.................... #define MGRCODE_SETNEAREST          8     // WARN: set to nearest possible val 
.................... #define MGRCODE_RESTRICTED          16    // ERR: access restricted 
.................... #define MGRCODE_BUSY                32    // ERR: network manager is busy  
.................... #define MGRCODE_DELAYED_ATTEMPT     33    // ERR: delayed response initiated 
....................                                           //      mgr will attempt to add links 
.................... #define MGRCODE_DENIED              65    // ERR: service request denied 
.................... #define MGRCODE_UNKNOWN_SVC         66    // ERR: unknown service flag 
.................... #define MGRCODE_UNKNOWN_APPDOMAIN   67    // ERR: unknown application domain 
.................... #define MGRCODE_UNKNOWN_NICKNAME    68    // ERR: unknown nickname 
....................  
.................... // re set batteryLife 
.................... #define PWRSTAT_NOMINAL             0x00 
.................... #define PWRSTAT_LOW                 0x01 
.................... #define PWRSTAT_CRIT_LOW            0x02 
.................... #define PWRSTAT_RECHARG_LOW         0x03 
.................... #define PWRSTAT_RECHARG_HIGH        0x04 
....................  
.................... #define BOOT_EVENT               0x01010101  // & with new_events_rcvd to 
....................                                              //  determine if boot event 
....................                                              //  occurred 
.................... #define ALARMS_EVENT             0x02020202 
.................... #define TIME_EVENT               0x04040404  // & with new_events_rcvd to 
....................                                              //  determine if UTC time ref 
....................                                              //  from mote has changed 
.................... #define JOIN_FAIL_EVENT          0x08080808 
.................... #define DISCONNECTED_EVENT       0x10101010 
.................... #define OPERATIONAL_EVENT        0x20202020  // mote has gateway to send data 
.................... #define CONFIG_EVENT             0x40404040 
....................  
....................  
.................... // EVENTMASK bit definitions 
.................... #define EVENTMASK_BOOT           0x01        // Mote booted up. 
.................... #define EVENTMASK_ALARMS         0x02        // Value of alarms field changed. 
.................... #define EVENTMASK_TIMECHANGE     0x04        // UTC time reference changed.     
.................... #define EVENTMASK_JOINFAIL       0x08        // Join operation failed. 
.................... #define EVENTMASK_DISCONNECT     0x10        // Mote has disconnected. 
.................... #define EVENTMASK_OPERATIONAL    0x20        // Mote has gateway to send data. 
.................... #define EVENTMASK_CONFIG         0x40        // Write has changed mote config. 
....................  
.................... //  
.................... // #define WRITEPROTECT_DISABLED    0x0         // bit 0 only 
.................... // #define WRITEPROTECT_ENABLED     0x1         // bit 0 only 
.................... // #define WRITEPROTECT_MASK        0x1 
....................  
.................... // FLAG bit masks & defines 
.................... //#define FLAG_TYPE_MASK          0x01 
.................... #define FLAG_TYPE_REQUEST           0x04     // from micro to mote re get/set 
....................                                              //  and re join, reset, etc 
.................... #define FLAG_TYPE_REQUEST2          0x05 
.................... #define FLAG_SEND_REQUEST           0x04     // from micro to mote with send 
....................                                              //  request only 
.................... #define FLAG_TYPE_TEST              0x00     // from micro to mote re 
....................                                              //  testradiorx and testradiotx 
.................... #define FLAG_MOTE_INDICATION        0x00     // from mote to micro re 
....................                                              //  indications: event, service, 
....................                                              //  time 
.................... #define FLAG_TYPE_RESPONSE          0x01 
.................... #define FLAG_MOTECMD_RESPONSE       0x05     // from mote to micro after 
....................                                              //  micro-initiated command 
....................                                              //  e.g. join, reset, send 
.................... #define FLAG_MICROIND_RESPONSE      0x05     // from micro to mote after 
....................                                              //  mote indication to micro 
....................                                              //  time/service/event/data 
.................... #define FLAG_SET_RESPONSE           0x05     // from mote to micro after set 
.................... #define FLAG_GET_RESPONSE           0x05     // from mote to micro after get 
....................                                              //  TEST THIS 
....................  
.................... #define FLAG_ID                     0x02 
.................... #define FLAG_ID_IGNORE              0x04 
.................... #define FLAG_END2END_RESPONSE       0x80 
.................... #define FLAG_TRANSPORT_TYPE_MASK    0x40 
....................  
....................  
.................... #define FLAG_NV_ONLY                   ~0x80 
.................... #define FLAG_NV_RAM                    0x80 
....................  
....................  
.................... // #define WRITE_PROTECT_MODE_OFF     0x00 // write allowed 
.................... // #define WRITE_PROTECT_MODE_ON      0x01 // write not allowed 
....................  
.................... // packet priorities 
.................... #define PRIORITY_LOW    0x00 
.................... #define PRIORITY_MED    0x01 
.................... #define PRIORITY_HI     0x02 
....................  
.................... // Pack on one byte boundaries because we "type cast" the data structures 
.................... //  to a destination buffer (array of bytes). 
....................  
.................... /*  
.................... //Structure Declarations 
.................... #define DUST_DN2500_HEADER  \ 
....................     uint8_t cmd;     \ 
....................     uint8_t len_pkt; \ 
....................     uint8_t flags; 
....................  
....................  
.................... // A structure defined like this represents the first 4 bytes of  
.................... //  send, join, disconnect, reset, sleep, testradioTX/RX, clearNV  
.................... //  (cmd types 5,6,7,8,9,B,C,10) 
.................... #define DUST_DN2500_HEADER_RESPONSE    \ 
....................     uint8_t cmd;     \ 
....................     uint8_t len_pkt; \ 
....................     uint8_t flags;   \ 
....................     uint8_t result; 
....................      
.................... // A structure defined like this represents the first 4 bytes of all  
.................... //  set, get, setNV, getNV responses (cmd types 1,2,3,4) 
.................... #define DUST_DN2500_PARAM_RESPONSE  \ 
....................     uint8_t cmd;     \ 
....................     uint8_t len_pkt; \ 
....................     uint8_t flags;   \ 
....................     uint8_t result;  \ 
....................     uint8_t parameter_type;        /* DUST_DN2500_CMD_[SET|GET]_PARAM_*  
.................... */ 
....................  
.................... typedef union _mote_to_micro 
.................... // cmd types 1,2,3,4;  5,6,7,8,9,B,C,10;  D,E,F,81 
.................... // get/set; send/join/discon/reset/sleep/testradio/clrNV;  time/svc/event/data  
.................... { 
....................    char      dust_rcvd[MAX_DATA_RCVD];    // THIS is the buffer for unstuffed 
....................                                           //  stripped received data 
....................    struct _set_param_response 
....................    // for set txPower, joinDutyCycle, batteryLife, eventMask 
....................    // for setNV macAddress, networkID, txPower, joinKey, powerInfo, OTAPlockout 
....................    //  and special1 and special2 
....................    // Mote response to micro after most set and setNV commands 
....................    { 
....................       uint8_t     cmd;                 // CMD_SET or CMD_SETNV 
....................       uint8_t     len_pkt;             // always 0x01   
....................       uint8_t     flags;               // expect FLAG_SET_RESPONSE 
....................       uint8_t     result;              // RC_* 
....................       uint8_t     param_type;          // PARAM_TXPOWER, PARAM_JOINTDUY, (set) 
....................                                        // PARAM_BATTLIFE, PARAM_EVENTMASK (set) 
....................                                        // PARAM_MACADDR, PARAM_NETWORKID, (setNV) 
....................                                        // PARAM_TXPOWER, PARAM_JOINKEY, (setNV)  
....................                                        // PARAM_POWERINFO, PARAM_OTAPLOCK (setNV) 
....................                                        // PARAM_SPECIAL1, PARAM_SPECIAL2 
....................    }  set_param_response; 
....................     
....................    struct _set_service_response 
....................    // Mote respnse to micro after set service ONLY 
....................    { 
....................       uint8_t     cmd;                 // CMD_SET 
....................       uint8_t     len_pkt;             // always 0x02 
....................       uint8_t     flags;               // expect FLAG_SET_RESPONSE 
....................       uint8_t     result;              // RC_* 
....................       uint8_t     param_type;          // PARAM_SERVICE 
....................       uint8_t     rem_svc_entries; 
....................    }  set_service_response; 
....................     
....................     struct _get_service_response  
....................    { 
....................       uint8_t     cmd;                 // CMD_GET 
....................       uint8_t     len_pkt;             // always 0x0B 
....................       uint8_t     flags;               // expect FLAG_GET_RESPONSE 
....................       uint8_t     result;              // RC_* 
....................       uint8_t     param_type;          // PARAM_SERVICE 
....................       uint8_t     svc_index; 
....................       uint8_t     svc_state;           // SVCSTATE_* 
....................       uint8_t     svc_flags;           // SVCRQST_* 
....................       uint8_t     app_domain;          // APPDOMAIN_* 
....................       uint16_t    destaddr;            // always 0xF981 
....................       uint32_t    time;                // Period/latency: intermittent flag set 
....................    } get_service_response; 
....................     
....................    struct _get_moteinfo_response  
....................    { 
....................       uint8_t     cmd;                 // CMD_GET 
....................       uint8_t     len_pkt;             // always 0x11 
....................       uint8_t     flags;               // expect FLAG_GET_RESPONSE 
....................       uint8_t     result;              // RC_* 
....................       uint8_t     param_type;          // PARAM_MOTEINFO 
....................       uint8_t     api_version; 
....................       uint8_t     serial_number[8]; 
....................       uint8_t     hw_model; 
....................       uint8_t     hw_version; 
....................       uint8_t     sw_major_ver; 
....................       uint8_t     sw_minor_ver; 
....................       uint8_t     sw_patch; 
....................       uint16_t    sw_build; 
....................    }  get_moteinfo_response; 
....................  
....................    struct _get_networkinfo_response 
....................    { 
....................       uint8_t     cmd;                 // CMD_GET 
....................       uint8_t     len_pkt;             // always 0x0D 
....................       uint8_t     flags;               // expect FLAG_GET_RESPONSE 
....................       uint8_t     result;              // RC_* 
....................       uint8_t     param_type;          // PARAM_NETWORKINFO 
....................       uint8_t     macaddr[8]; 
....................       uint16_t    mote_id; 
....................       uint16_t    network_id; 
....................    }  get_networkinfo_response; 
....................  
....................    struct _get_motestatus_response 
....................    { 
....................       uint8_t     cmd;                 // CMD_GET 
....................       uint8_t     len_pkt;             // always 0x0B 
....................       uint8_t     flags;               // expect FLAG_GET_RESPONSE 
....................       uint8_t     result;              // RC_* 
....................       uint8_t     param_type;          // PARAM_MOTESTATUS 
....................       uint8_t     mote_state;          // MOTESTATE_* 
....................       uint8_t     mote_state_reason;   // Reserved -- ignore 
....................       uint16_t    change_counter; 
....................       uint8_t     number_of_parents; 
....................       uint32_t    mote_alarms;         // ALARMS_* 
....................       uint8_t     reserved; 
....................    }  get_motestatus_response; 
....................  
....................    struct _get_time_response 
....................    { 
....................       uint8_t     cmd;                 // CMD_GET 
....................       uint8_t     len_pkt;             // always 0x10 
....................       uint8_t     flags;               // expect FLAG_GET_RESPONSE 
....................       uint8_t     result;              // RC_* 
....................       uint8_t     param_type;          // PARAM_TIME 
....................       uint32_t    utc_sec; 
....................       uint32_t    utc_usec; 
....................       uint8_t     asn[5];              // Absolute Slot No. (10msec slots since 
....................                                        //  boot). 
....................       uint16_t    asn_offset;          // usec into current slot number  
....................    }  get_time_response; 
....................     
....................    struct _get_charge_response 
....................    { 
....................       uint8_t     cmd;                 // CMD_GET 
....................       uint8_t     len_pkt;             // always 0x0B 
....................       uint8_t     flags;               // expect FLAG_GET_RESPONSE 
....................       uint8_t     result;              // RC_* 
....................       uint8_t     param_type;          // PARAM_CHARGE 
....................       uint32_t    charge_mC;           // charge since last reset 
....................       uint32_t    uptime_sec;          // uptime since last reset 
....................       int8_t      temp_celsius; 
....................       uint8_t     temp_frac_celsius;   // Temperature in 1/255 of Celsius 
....................    }  get_charge_response; 
....................     
....................    struct _get_testrx_response 
....................    { 
....................       uint8_t     cmd;                 // CMD_GET 
....................       uint8_t     len_pkt;             // always 0x05 
....................       uint8_t     flags;               // expect FLAG_GET_RESPONSE 
....................       uint8_t     result;              // RC_* 
....................       uint8_t     param_type;          // PARAM_RADIOSTATSRX 
....................       uint16_t    num_of_received_packets; 
....................       uint16_t    num_of_recep_failures; 
....................    }  get_testrx_response; 
....................   
....................    struct _getNV_macaddr_response 
....................    { 
....................       uint8_t     cmd;                 // CMD_GETNV 
....................       uint8_t     len_pkt;             // always 0x09 
....................       uint8_t     flags;               // expect FLAG_GET_RESPONSE 
....................       uint8_t     result;              // RC_* 
....................       uint8_t     param_type;          // PARAM_MACADDR 
....................       uint8_t     macaddr[8]; 
....................    }  getNV_macaddr_response; 
....................     
....................    struct _getNV_networkid_response 
....................    { 
....................       uint8_t     cmd;                 // CMD_GETNV 
....................       uint8_t     len_pkt;             // always 0x03 
....................       uint8_t     flags;               // expect FLAG_GET_RESPONSE 
....................       uint8_t     result;              // RC_NETWORKID 
....................       uint8_t     param_type;          // PARAM_NETWORKID 
....................       uint16_t    network_id; 
....................    }  getNV_networkid_response; 
....................     
....................    struct _getNV_txpower_response 
....................    { 
....................       uint8_t     cmd;                 // CMD_GETNV 
....................       uint8_t     len_pkt;             // always 0x02 
....................       uint8_t     flags;               // expect FLAG_GET_RESPONSE 
....................       uint8_t     result;              // RC_* 
....................       uint8_t     param_type;          // PARAM_TXPOWER 
....................       uint8_t     txpower; 
....................    }  getNV_txpower_response; 
....................     
....................    struct _getNV_powerinfo_response 
....................    { 
....................       uint8_t     cmd;                 // CMD_GETNV 
....................       uint8_t     len_pkt;             // always 0x0C 
....................       uint8_t     flags;               // expect FLAG_GET_RESPONSE 
....................       uint8_t     result;              // RC_* 
....................       uint8_t     param_type;          // PARAM_POWERINFO 
....................       uint8_t     power_source;        // PWRSOURCE_* 
....................       uint16_t    discharge_current_uA; 
....................       uint32_t    discharge_time_sec; 
....................       uint32_t    recharge_time_sec;     
....................    }  getNV_powerinfo_response; 
....................  
....................    struct _getnv_otaplock_response 
....................    { 
....................       uint8_t     cmd;                 // CMD_GETNV 
....................       uint8_t     len_pkt;             // always 0x02 
....................       uint8_t     flags;               // expect FLAG_GET_RESPONSE 
....................       uint8_t     result;              // RC_* 
....................       uint8_t     param_type;          // PARAM_OTAPLOCK 
....................       uint8_t     otaplock; 
....................    }  getnv_otaplock_response; 
....................     
....................    struct _cmd_response 
....................    { 
....................       uint8_t     cmd;                 // CMD_SEND, CMD_JOIN, 
....................                                        // CMD_DISCONNECT, CMD_RESET 
....................                                        // CMD_SLEEP, CMD_TESTRADIOTX, 
....................                                        // CMD_TESTRADIORX, CMD_CLEARNV 
....................       uint8_t     len_pkt;             // always 0x00 
....................       uint8_t     flags;               // always FLAG_MOTECMD_RESPONSE 
....................       uint8_t     result;              // RC_* 
....................    }  cmd_response; 
....................     
....................    struct _time_indication 
....................    // this is what you get from mote when you toggle _DUST_TIME 
....................    { 
....................       uint8_t     cmd;                 // CMD_TIME 
....................       uint8_t     len_pkt;             // always 0x0F 
....................       uint8_t     flags;               // See tables 98 and 1***************** 
....................       uint32_t    utc_sec; 
....................       uint32_t    utc_usec; 
....................       uint8_t     asn[5];              // Absolute Slot No. (10msec slots since 
....................                                        //  boot. 
....................       uint16_t    asn_offset;          // usec into current slot number 
....................    }  time_indication; 
....................     
....................    struct _service_indication 
....................    { 
....................       uint8_t     cmd;                 // CMD_SERVICE 
....................       uint8_t     len_pkt;             // always 0x0C 
....................       uint8_t     flags;               // See tables 98 and 1***************** 
....................       uint8_t     event_code;          // SVC_* 
....................       uint8_t     mgr_code;            // MGRCODE_* 
....................       uint8_t     svc_index; 
....................       uint8_t     svc_state;           // SVCSTATE_* 
....................       uint8_t     svc_flags;           // SVCRQST_* 
....................       uint8_t     app_domain;          // APPDOMAIN_* 
....................       uint16_t    destaddr;            // always 0xF981 
....................       uint32_t    time;                // Period/latency: intermittent flag set 
....................    }  service_indication; 
....................  
....................    struct _events_indication 
....................    { 
....................       uint8_t     cmd;                 // CMD_EVENT 
....................       uint8_t     len_pkt;             // always 0x09 
....................       uint8_t     flags;               // See tables 98 and 1***************** 
....................       uint32_t    new_events;          // EVENTMASK_* (?) 
....................       uint8_t     mote_state;          // MOTESTATE_* 
....................       uint32_t    mote_alarms;         // ALARMS_* 
....................    }  events_indication; 
....................     
....................    struct _advert_indication 
....................    { 
....................       uint8_t     cmd;                 // CMD_EVENT 
....................       uint8_t     len_pkt;             // always 0x09 
....................       uint8_t     flags; 
....................       uint16_t    network_id; 
....................       uint16_t    mote_id; 
....................       uint8_t     rssi;                // rcvd signal strength 
....................       uint8_t     hop_depth;           // (join priority) 
....................    }  advert_indication; 
....................     
....................    struct _data_from_net 
....................    { 
....................       uint8_t     cmd;                 // CMD_DATA 
....................       uint8_t     len_pkt;             // always len_data + 4 
....................       uint8_t     flags;               // See tables 98 and 1***************** 
....................       uint16_t    sourceaddr;          // always 0xF981 
....................       uint8_t     sequence_num;        // sequence number 
....................       uint8_t     len_data;            // packet data length (<=MAX_USER_DATA_SIZE) 
....................       uint8_t     data[MAX_USER_DATA_SIZE]; 
....................                                        // actual received data 
....................    }  data_from_net; 
.................... }  mote_to_micro;  
....................  
.................... /* 
.................... #define dust_dn2500_response_t                              dust_dn2500_param_response_t 
.................... #define dust_dn2500_set_param_tx_power_response_t           dust_dn2500_param_response_t 
.................... #define dust_dn2500_set_param_join_duty_cycle_response_t    dust_dn2500_param_response_t 
.................... #define dust_dn2500_set_param_battery_life_response_t       dust_dn2500_param_response_t 
.................... #define dust_dn2500_set_param_event_mask_response_t         dust_dn2500_param_response_t 
.................... #define dust_dn2500_set_param_write_protect_response_t      dust_dn2500_param_response_t 
.................... #define dust_dn2500_setnv_mac_address_response_t            dust_dn2500_param_response_t 
.................... #define dust_dn2500_setnv_network_id_response_t             dust_dn2500_param_response_t 
.................... #define dust_dn2500_setnv_tx_power_response_t               dust_dn2500_param_response_t 
.................... #define dust_dn2500_setnv_joinkey_response_t                dust_dn2500_param_response_t 
.................... #define dust_dn2500_setnv_otap_lockout_response_t           dust_dn2500_param_response_t 
.................... #define dust_dn2500_setnv_powerinfo_response_t              dust_dn2500_param_response_t 
.................... #define dust_dn2500_setnv_ttl_response_t                    dust_dn2500_param_response_t 
.................... #define dust_dn2500_send_response_t                         dust_dn2500_cmd_response_t 
.................... #define dust_dn2500_join_response_t                         dust_dn2500_cmd_response_t 
.................... #define dust_dn2500_search_response_t                       dust_dn2500_cmd_response_t 
.................... #define dust_dn2500_disconnect_response_t                   dust_dn2500_cmd_response_t 
.................... #define dust_dn2500_reset_response_t                        dust_dn2500_cmd_response_t 
.................... #define dust_dn2500_lowPowerSleep_response_t                dust_dn2500_cmd_response_t 
.................... #define dust_dn2500_testRadioTx_response_t                  dust_dn2500_cmd_response_t 
.................... #define dust_dn2500_testRadioRx_response_t                  dust_dn2500_cmd_response_t 
.................... #define dust_dn2500_clearnv_response_t                      dust_dn2500_cmd_response_t 
.................... #define dust_dn2500_set_param_hart_device_status_response_t dust_dn2500_param_response_t 
.................... #define dust_dn2500_set_param_hart_device_info_response_t   dust_dn2500_param_response_t 
.................... #define dust_dn2500_setnv_hart_antenna_gain_response_t      dust_dn2500_param_response_t 
....................  
.................... // MICRO TO MOTE RESPONSES AFTER TIME/SERVICE/EVENTS INDICATION OR DATA_FROM_NET 
.................... #define dust_dn2500_time_response_t    dust_dn2500_cmd_response_t 
.................... #define dust_dn2500_service_response_t dust_dn2500_cmd_response_t 
.................... #define dust_dn2500_events_response_t  dust_dn2500_cmd_response_t 
.................... #define dust_dn2500_data_response_t    dust_dn2500_cmd_response_t 
....................  
....................  
.................... struct dust_dn2500_cmd_response_t { 
....................     DUST_DN2500_HEADER_RESPONSE 
.................... }; 
.................... struct dust_dn2500_header_t { 
....................     DUST_DN2500_HEADER 
.................... }; 
....................  
.................... // WHAT UP WITH THIS....  hw/sw incompatibilities insurance?? -- ignore for now 
.................... // points to any extra bytes received that are not identified as a "dust" packet  
.................... struct dust_dn2500_unknown_data_t { 
....................    uint8_t*    data; 
....................    uint8_t     len; 
.................... }; 
.................... */ 
....................  
.................... // uint8_t     macaddr[8]; 
.................... uint8_t     joinkey[MAX_JOINKEY_SIZE]={0x44,0x55,0x53,0x54,0x4E,0x45,0x54,0x57,0x4F,0x52,0x4B,0x53,0x52,0x4F,0x43,0x4B}; 
.................... // need these declaration for pkgen_setnv_macaddr 
....................  
.................... /* 
.................... // The following structures exist in RAM as 'global'.  No need to pass 
.................... //  the structure to the packet generation routines defined below 
.................... struct _set_battlife_struct 
.................... // setup up battlife_days and pwrstat prior to pkgen_set_battlife() call 
.................... { 
....................    uint16_t    battlife_days; 
....................    uint8_t     pwrstat;                // PWRSTAT_* 
.................... }  set_battlife_struct; 
....................  
.................... struct _setnv_powerinfo_struct  
.................... // setup pwrsource, discharge_current_uA, discharge_time_sec, 
.................... //  and recharge_time_sec prior to pkgen_setnv_powerinfo() 
.................... { 
....................    uint8_t     pwrsource;              // PWRSOURCE_* 
....................    uint16_t    discharge_current_uA; 
....................    uint32_t    discharge_time_sec; 
....................    uint32_t    recharge_time_sec;     
.................... }  setnv_powerinfo_struct; 
....................  
.................... struct _set_svc_struct 
.................... // setup  svc_index; request_flags, app_domain and time  
.................... //  pwrstat prior to pkgen_set_battlife() call.  No need to setup dest_address 
.................... { 
....................    uint8_t     svc_index; 
....................    uint8_t     request_flags;          // SVCRQST_* 
....................    uint8_t     app_domain;             // APPDOMAIN_* 
....................    uint16_t    destaddr;               // always 0xF981 
....................                                        //  set properly in pkgen_set_service() 
....................    uint32_t    time;                   // Period/latency: intermittent flag set 
.................... }  set_svc_struct; 
....................  
.................... struct testradiotx_struct 
.................... // setup channel and num_packets prior to pkgen_testradiotx() call 
.................... { 
....................    uint8_t     channel;                // 0-15 
....................    uint16_t    num_packets; 
.................... }  testradiotx_struct; 
....................  
.................... struct testradiorx_struct 
.................... // setup channel and time_sec prior to pkgen_testradiorx() call 
.................... { 
....................    uint8_t     channel;                // 0-15  
....................    uint16_t    time_sec;               // rcv packets for this many secs 
.................... }  testradiorx_struct; 
.................... */ 
....................  
....................  
.................... /* ------------------------------------------------------------------------- */ 
.................... #define __swap32(src) (((uint32_t)src<<24)|(((uint32_t)src&0xff00)<<8)| \ 
....................                            (((uint32_t)src>>8)&0xff00)|((uint32_t)src>>24)) 
.................... #define __swap16(src) (((uint16_t)src<<8)|((uint16_t)src>>8)) 
.................... /* ------------------------------------------------------------------------- */ 
....................  
....................  
.................... /* ----------------------  Packet Generation Macros ------------------------ */ 
....................  
.................... /* setParameter<txPower> Request */ 
.................... #define pkgen_set_txpower(power) { \ 
....................     uint8_t prefix[] = {CMD_SET,0x02/*length*/,FLAG_TYPE_REQUEST,PARAM_TXPOWER}; \ 
....................     uint8_t pw       = power; \ 
....................     dust_hdlc_pkgen(prefix, 4, (uint8_t*)&pw, 1); \ 
.................... } 
....................  
.................... /* setParameter<joinDutyCycle> Request */ 
.................... #define pkgen_set_joinduty(cycle) { \ 
....................     uint8_t prefix[] = {CMD_SET,0x02/*length*/,FLAG_TYPE_REQUEST,PARAM_JOINDUTY}; \ 
....................     uint8_t cy       = cycle; \ 
....................     dust_hdlc_pkgen(prefix, 4, (uint8_t*)&cy, 1); \ 
.................... } 
....................  
.................... /* setParameter<batteryLife> Request */ 
.................... // structure is a declared global 
.................... #define pkgen_set_battlife() { \ 
....................     uint8_t  prefix[] = {CMD_SET,0x04/*length*/,FLAG_TYPE_REQUEST,PARAM_BATTLIFE}; \ 
....................     set_battlife_struct.battlife_days = __swap16(set_battlife_struct.battlife_days); \ 
....................     dust_hdlc_pkgen(prefix, 4, (uint8_t*)&set_battlife_struct, 3); \ 
.................... } 
....................  
.................... /* setParameter<service> Request */ 
.................... // structure is a declared global 
.................... #define pkgen_set_service() { \ 
....................     uint8_t  prefix[] = {CMD_SET,0x0A/*length*/,FLAG_TYPE_REQUEST,PARAM_SERVICE}; \ 
....................     set_svc_struct.destaddr = DESTADDR_SWAPPED; \ 
....................     set_svc_struct.time         = __swap32(set_svc_struct.time); \ 
....................     dust_hdlc_pkgen(prefix, 4, (uint8_t*)&set_svc_struct, 9); \ 
.................... } 
....................  
.................... /* setParameter<eventMask> Request */ 
.................... // eventmask is one of EVENTMASK_* 
.................... #define pkgen_set_eventmask(eventmask) { \ 
....................     uint8_t  prefix[] = {CMD_SET,0x05/*length*/,FLAG_TYPE_REQUEST,PARAM_EVENTMASK}; \ 
....................     uint32_t dstem    = __swap32(eventmask); \ 
....................     dust_hdlc_pkgen(prefix, 4, (uint8_t*)&dstem, 4); \ 
.................... } 
....................  
.................... /* getParameter<moteInfo> Request */ 
.................... #define pkgen_get_moteinfo() { \ 
....................     uint8_t cmd[] = {CMD_GET,0x01/*length*/,FLAG_TYPE_REQUEST,PARAM_MOTEINFO}; \ 
....................     dust_hdlc_pkgen((char*)(NULL), 0, cmd, 4); \ 
.................... } 
....................   
.................... /* getParameter<networkInfo> Request */ 
.................... #define pkgen_get_networkinfo() { \ 
....................     uint8_t cmd[] = {CMD_GET,0x01/*length*/,FLAG_TYPE_REQUEST,PARAM_NETWORKINFO}; \ 
....................     dust_hdlc_pkgen((char*)(NULL), 0, cmd, 4); \ 
.................... } 
....................  
.................... /* getParameter<moteStatus> Request */ 
.................... #define pkgen_get_motestatus() { \ 
....................     uint8_t cmd[] = {CMD_GET,0x01/*length*/,FLAG_TYPE_REQUEST,PARAM_MOTESTATUS}; \ 
....................     dust_hdlc_pkgen((char*)(NULL), 0, cmd, 4); \ 
.................... } 
....................  
.................... /* getParameter<time> Request */ 
.................... #define pkgen_get_time() { \ 
....................     uint8_t cmd[] = {CMD_GET,0x01/*length*/,FLAG_TYPE_REQUEST,PARAM_TIME}; \ 
....................     dust_hdlc_pkgen((char*)(NULL), 0, cmd, 4); \ 
.................... } 
....................  
.................... /* getParameter<charge> Request */ 
.................... #define pkgen_get_charge() { \ 
....................     uint8_t cmd[] = {CMD_GET,0x01/*length*/,FLAG_TYPE_REQUEST,PARAM_CHARGE}; \ 
....................     dust_hdlc_pkgen((char*)(NULL), 0, cmd, 4); \ 
.................... } 
....................  
.................... /* getParameter<testRadioRxStats> Request */ 
.................... #define pkgen_get_radiostatsrx() { \ 
....................     uint8_t cmd[] = {CMD_GET,0x01/*length*/,FLAG_TYPE_REQUEST,PARAM_RADIOSTATSRX}; \ 
....................     dust_hdlc_pkgen((char*)(NULL), 0, cmd, 4); \ 
.................... } 
....................  
.................... /* getParameter<service> Request */ 
.................... #define pkgen_get_service(service_idx) { \ 
....................     uint8_t prefix[] = {CMD_GET,0x02/*length*/,FLAG_TYPE_REQUEST,PARAM_SERVICE}; \ 
....................     uint8_t idx      = svc_index; \ 
....................     dust_hdlc_pkgen(prefix, 4, (uint8_t*)&idx, 1); \ 
.................... } 
....................  
.................... /* setNVParameter<macAddress> Request */ 
.................... // macaddr array is declared 
.................... #define pkgen_setnv_macaddr() { \ 
....................     uint8_t prefix[]   = {CMD_SETNV,0x0D/*length*/,FLAG_TYPE_REQUEST, 0x00, 0x00, 0x00, 0x00, PARAM_MACADDR}; \ 
....................     dust_hdlc_pkgen(prefix, 8, macaddr, 8); \ 
.................... } 
....................  
.................... /* setNVParameter<networkID> Request */ 
.................... #define pkgen_setnv_networkid(networkid) { \ 
....................     uint8_t prefix[] = {CMD_SETNV,0x07/*length*/,FLAG_TYPE_REQUEST, 0x00, 0x00, 0x00, 0x00, PARAM_NETWORKID}; \ 
....................     uint16_t net_id  = networkid; \ 
....................     dust_hdlc_pkgen(prefix, 8, (uint8_t*)&net_id, 2); \ 
.................... } 
....................  
.................... /* setNVParameter<txPower> Request */ 
.................... #define pkgen_setnv_txpower(txpower) { \ 
....................     uint8_t prefix[] = {CMD_SETNV,0x06/*length*/,FLAG_TYPE_REQUEST, 0x00, 0x00, 0x00, 0x00, PARAM_TXPOWER}; \ 
....................     uint8_t dst_power  = txpower; \ 
....................     dust_hdlc_pkgen(prefix, 8, (uint8_t*)&dst_power, 1); \ 
.................... } 
....................  
.................... /* setNVParameter<joinKey> Request */ 
.................... // joinkey array is declared 
....................  
.................... #define pkgen_setnv_joinkey(joinkey) { \ 
....................     uint8_t prefix[]   = {CMD_SETNV,0x15/*length*/,FLAG_TYPE_REQUEST, 0x00, 0x00, 0x00, 0x00, PARAM_JOINKEY}; \ 
....................     dust_hdlc_pkgen(prefix, 8, joinkey, 16); \ 
.................... } 
....................  
.................... //#define pkgen_setnv_joinkey(joinkey) { \ 
.................... //      uint8_t prefix[]   = {CMD_SETNV,0x15/*length*/,FLAG_TYPE_REQUEST, 0x00, 0x00, 0x00, 0x00, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}; \ 
.................... //      dust_hdlc_pkgen(prefix, 8,,16); \ 
.................... //} 
....................  
....................  
.................... /* setNVParameter<powerInfo> Request */ 
.................... // structure is a declared global 
.................... #define pkgen_setnv_powerinfo() { \ 
....................     uint8_t prefix[] = {CMD_SETNV,0x10/*length*/,FLAG_TYPE_REQUEST, 0x00, 0x00, 0x00, 0x00, PARAM_POWERINFO}; \ 
....................     setnv_powerinfo_struct.discharge_current_uA     = __swap16(setnv_powerinfo_struct.discharge_current_uA); \ 
....................     setnv_powerinfo_struct.discharge_time_sec       = __swap32(setnv_powerinfo_struct.discharge_time_sec); \ 
....................     setnv_powerinfo_struct.recharge_time_sec        = __swap32(setnv_powerinfo_struct.recharge_time_sec); \ 
....................     dust_hdlc_pkgen(prefix, 8, (uint8_t*)&setnv_powerinfo_struct, 11); \ 
.................... }  
....................  
.................... /* setNVParameter<OTAPlockout> Request */ 
.................... #define pkgen_setnv_otaplock(lockout) { \ 
....................    uint8_t prefix[] = {CMD_SETNV,0x06/*length*/,FLAG_TYPE_REQUEST, 0x00, 0x00, 0x00, 0x00, PARAM_OTAPLOCK}; \ 
....................    uint8_t otaplock = lockout; \ 
....................    dust_hdlc_pkgen(prefix, 8, (uint8_t*)&otaplock, 1); \ 
.................... } 
....................  
.................... /* setNVParameter<SpecialJoinTimingParams> Request */ 
.................... #define pkgen_setnv_special1(special1) { \ 
....................    uint8_t prefix[] = {CMD_SETNV,0x07/*length*/,0x02, 0x67, 0x12, 0x04, 0x04, PARAM_SPECIAL1}; \ 
....................    uint16_t spec_param1  = special1; \ 
....................    dust_hdlc_pkgen(prefix, 8, (uint8_t*)&spec_param1, 2); \ 
.................... } 
....................  
.................... /* setNVParameter<SpecialJoinTimingParams> Request */ 
.................... #define pkgen_setnv_special2(special2) { \ 
....................    uint8_t prefix[] = {CMD_SETNV,0x07/*length*/,0x00, 0x67, 0x12, 0x04, 0x04, PARAM_SPECIAL2}; \ 
....................    uint16_t spec_param2 = special2; \ 
....................    dust_hdlc_pkgen(prefix, 8, (uint8_t*)&spec_param2, 2); \ 
.................... } 
....................  
.................... /* getNVParameter<macAddress> Request */ 
.................... #define pkgen_getnv_macaddr() { \ 
....................     uint8_t cmd[] = {CMD_GETNV,0x05/*length*/,FLAG_TYPE_REQUEST, 0x00, 0x00, 0x00, 0x00, PARAM_MACADDR}; \ 
....................     dust_hdlc_pkgen((char*)(NULL), 0, cmd, 8); \ 
.................... } 
....................  
.................... /* getNVParameter<networkID> Request */ 
.................... #define pkgen_getnv_networkid() { \ 
....................     uint8_t cmd[] = {CMD_GETNV,0x05/*length*/,FLAG_TYPE_REQUEST, 0x00, 0x00, 0x00, 0x00, PARAM_NETWORKID}; \ 
....................     dust_hdlc_pkgen((char*)(NULL), 0, cmd, 8); \ 
.................... } 
....................  
.................... /* getNVParameter<txPower> Request */ 
.................... #define pkgen_getnv_txpower() { \ 
....................     uint8_t cmd[] = {CMD_GETNV,0x05/*length*/,FLAG_TYPE_REQUEST, 0x00, 0x00, 0x00, 0x00, PARAM_TXPOWER}; \ 
....................     dust_hdlc_pkgen((char*)(NULL), 0, cmd, 8); \ 
.................... } 
....................  
.................... /* getNVParameter<powerInfo> Request */ 
.................... #define pkgen_getnv_powerinfo() { \ 
....................     uint8_t cmd[] = {CMD_GETNV,0x05/*length*/,FLAG_TYPE_REQUEST, 0x00, 0x00, 0x00, 0x00, PARAM_POWERINFO}; \ 
....................     dust_hdlc_pkgen((char*)(NULL), 0, cmd, 8); \ 
.................... } 
....................  
.................... /* getNVParameter<OTAPlockout> Request */ 
.................... #define pkgen_getnv_otaplock() { \ 
....................     uint8_t cmd[]   = {CMD_GETNV,0x05/*length*/,FLAG_TYPE_REQUEST, 0x00, 0x00, 0x00, 0x00, PARAM_OTAPLOCK}; \ 
....................     dust_hdlc_pkgen((char*)(NULL), 0, cmd, 8); \ 
.................... } 
....................  
.................... // command to mote to test the radio transmitter 
.................... // structure is a declared global 
.................... #define pkgen_testradiotx() { \ 
....................     uint8_t  prefix[] = {CMD_TESTRADIOTX, 3 /*payload length*/, FLAG_TYPE_TEST}; \ 
....................     testradiotx_struct.num_packets = __swap16(testradiotx_struct.num_packets); \ 
....................     dust_hdlc_pkgen(prefix, 3, (uint8_t*)&testradiotx_struct, 3); \ 
.................... } 
....................  
.................... #define pkgen_testradiorx() { \ 
....................     uint8_t  prefix[] = {CMD_TESTRADIORX, 3 /*payload length*/, FLAG_TYPE_TEST}; \ 
....................     testradiorx_struct.time_sec = __swap16(testradiorx_struct.time_sec); \ 
....................     dust_hdlc_pkgen(prefix, 3, (uint8_t*)&testradiorx_struct, 3); \ 
.................... } 
....................  
.................... /* Join Request */ 
.................... #define pkgen_join() { \ 
....................     uint8_t cmd[]   = {CMD_JOIN,0x00/*payload length*/,FLAG_TYPE_REQUEST}; \ 
....................     dust_hdlc_pkgen((char*)(NULL), 0, cmd, 3); \ 
.................... } 
....................  
.................... /* Disconnect Request */ 
.................... #define pkgen_disconnect() { \ 
....................     uint8_t cmd[]   = {CMD_DISCONNECT,0x00/*payload length*/,FLAG_TYPE_REQUEST}; \ 
....................     dust_hdlc_pkgen((char*)(NULL), 0, cmd, 3); \ 
.................... } 
....................  
.................... /* Reset Request */ 
.................... #define pkgen_reset() { \ 
....................     uint8_t cmd[]   = {CMD_RESET,0x00/*payload length*/,FLAG_TYPE_REQUEST}; \ 
....................     dust_hdlc_pkgen((char*)(NULL), 0, cmd, 3); \ 
.................... } 
....................  
.................... /* lowPowerSleep Request */ 
.................... #define pkgen_sleep() { \ 
....................     uint8_t cmd[]   = {CMD_SLEEP,0x00/*payload length*/,FLAG_TYPE_REQUEST}; \ 
....................     dust_hdlc_pkgen((char*)(NULL), 0, cmd, 3); \ 
.................... } 
....................  
.................... /* ClearNV Request */ 
.................... #define pkgen_clearnv() { \ 
....................     uint8_t cmd[]   = {CMD_CLEARNV,0x00/*payload length*/,FLAG_TYPE_REQUEST}; \ 
....................     ((char*)(NULL), 0, cmd, 3); \ 
.................... } 
....................  
.................... /* Search Request */ 
.................... #define pkgen_search() { \ 
....................     uint8_t cmd[]   = {CMD_SEARCH,0x00/*payload length*/,FLAG_TYPE_REQUEST}; \ 
....................     dust_hdlc_pkgen((char*)(NULL), 0, cmd, 3); \ 
.................... } 
....................  
.................... // MOTE command responses.  The micro sends a response to mote  
.................... //  after having received an indication or a data packet 
....................  
.................... #define pkgen_time_ind_response(result_fl) { \ 
....................     uint8_t prefix[] = {CMD_TIME,0x00};   \ 
....................     uint16_t r        = result_fl; \ 
....................     dust_hdlc_pkgen(prefix, 2, (uint8_t*)&r, 2); \ 
.................... } 
....................  
.................... #define pkgen_service_ind_response(result_fl) { \ 
....................     uint8_t prefix[] = {CMD_SERVICE,0x00}; \ 
....................     uint16_t r       = result_fl; \ 
....................     dust_hdlc_pkgen(prefix, 2, (uint8_t*)&r, 2);  \ 
.................... } 
....................  
.................... #define pkgen_event_ind_response(result_fl) { \ 
....................     uint8_t prefix[] = {CMD_EVENT,0x00};  \ 
....................     uint16_t r        = result_fl; \ 
....................     dust_hdlc_pkgen(prefix, 2, (uint8_t*)&r, 2); \ 
.................... } 
....................  
.................... #define pkgen_advert_ind_response(result_fl) { \ 
....................     uint8_t prefix[] = {CMD_ADVERT,0x00}; \ 
....................     uint16_t r       = result_fl; \ 
....................     dust_hdlc_pkgen(prefix, 2, (uint8_t*)&r, 2); \ 
.................... } 
....................  
.................... #define pkgen_data_rcvd_response(result_fl) { \ 
....................     uint8_t prefix[] = {CMD_DATA,0x00};  \ 
....................     uint16_t r       = result_fl; \ 
....................     dust_hdlc_pkgen(prefix, 2, (uint8_t*)&r, 2); \ 
.................... } 
....................  
.................... // Added by brian 
.................... #define pkgen_mote_ack() { \ 
....................  uint8_t cmd[]   = {(flags_rcvd+1),response_type}; \ 
....................  dust_hdlc_pkgen((cmd_rcvd << 8), 2, cmd, 2); \ 
.................... } 
....................     
.................... //  
.................... /* 
.................... struct dust_dn2500_t { 
....................  
....................     // SET Parameters Responses 
....................     int8_t (*set_param_tx_power_response)(void* handle, struct dust_dn2500_set_param_tx_power_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................     int8_t (*set_param_join_duty_cycle_response)(void* handle, struct dust_dn2500_set_param_join_duty_cycle_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................     int8_t (*set_param_battery_life_response)(void* handle, struct dust_dn2500_set_param_battery_life_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................     int8_t (*set_param_service_response)(void* handle, struct dust_dn2500_set_param_service_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................     int8_t (*set_param_hart_device_status_response)(void* handle, struct dust_dn2500_set_param_hart_device_status_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................     int8_t (*set_param_hart_device_info_response)(void* handle, struct dust_dn2500_set_param_hart_device_info_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................     int8_t (*set_param_event_mask_response)(void* handle, struct dust_dn2500_set_param_event_mask_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................     int8_t (*set_param_write_protect_response)(void* handle, struct dust_dn2500_set_param_write_protect_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................  
....................     int8_t (*get_param_mote_info_response)(void* handle, struct dust_dn2500_get_param_mote_info_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................     int8_t (*get_param_network_info_response)(void* handle, struct dust_dn2500_get_param_network_info_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................     int8_t (*get_param_mote_status_response)(void* handle, struct dust_dn2500_get_param_mote_status_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................     int8_t (*get_param_time_response)(void* handle, struct dust_dn2500_get_param_time_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................     int8_t (*get_param_charge_response)(void* handle, struct dust_dn2500_get_param_charge_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................     int8_t (*get_param_test_radio_rxstats_response)(void* handle, struct dust_dn2500_get_param_test_radio_rxstats_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................     int8_t (*get_param_service_response)(void* handle, struct dust_dn2500_get_param_service_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................  
....................     // Non-Volatile Parameter Responses 
....................     int8_t (*setnv_mac_address_response)(void* handle, struct dust_dn2500_setnv_mac_address_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................     int8_t (*setnv_network_id_response)(void* handle, struct dust_dn2500_setnv_network_id_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................     int8_t (*setnv_tx_power_response)(void* handle, struct dust_dn2500_setnv_tx_power_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................     int8_t (*setnv_joinkey_response)(void* handle, struct dust_dn2500_setnv_joinkey_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................     int8_t (*setnv_powerinfo_response)(void* handle, struct dust_dn2500_setnv_powerinfo_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................     int8_t (*setnv_ttl_response)(void* handle, struct dust_dn2500_setnv_ttl_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................     int8_t (*setnv_hart_antenna_gain)(void* handle, struct dust_dn2500_setnv_hart_antenna_gain_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................     int8_t (*setnv_otap_lockout)(void* handle, struct dust_dn2500_setnv_otap_lockout_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................  
....................     int8_t (*getnv_mac_address_response)(void* handle, struct dust_dn2500_getnv_mac_address_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................     int8_t (*getnv_network_id_response)(void* handle, struct dust_dn2500_getnv_network_id_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................     int8_t (*getnv_tx_power_response)(void* handle, struct dust_dn2500_getnv_tx_power_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................     int8_t (*getnv_powerinfo_response)(void* handle, struct dust_dn2500_getnv_powerinfo_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................     int8_t (*getnv_ttl_response)(void* handle, struct dust_dn2500_getnv_ttl_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................     int8_t (*getnv_hart_antenna_gain)(void* handle, struct dust_dn2500_getnv_hart_antenna_gain_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................     int8_t (*getnv_otap_lockout)(void* handle, struct dust_dn2500_getnv_otap_lockout_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................  
....................     // Command Responses 
....................     int8_t (*send_response)(void* handle, struct dust_dn2500_send_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................     int8_t (*join_response)(void* handle, struct dust_dn2500_join_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................     int8_t (*disconnect_response)(void* handle, struct dust_dn2500_disconnect_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................     int8_t (*search_response)(void* handle, struct dust_dn2500_search_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................     int8_t (*reset_response)(void* handle, struct dust_dn2500_reset_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................     int8_t (*lowPowerSleep_response)(void* handle, struct dust_dn2500_lowPowerSleep_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................     int8_t (*hartPayload_response)(void* handle, struct dust_dn2500_hartPayload_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................     int8_t (*testRadioTx_response)(void* handle, struct dust_dn2500_testRadioTx_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................     int8_t (*testRadioRx_response)(void* handle, struct dust_dn2500_testRadioRx_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................     int8_t (*clearnv_response)(void* handle, struct dust_dn2500_clearnv_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................  
....................     // MOTE commands sent to sensor processor 
....................     int8_t (*time_request)(void* handle, struct dust_dn2500_time_request_t* p, struct dust_dn2500_unknown_data_t* un); 
....................     int8_t (*service_indication)(void* handle, struct dust_dn2500_service_indication_t* p, struct dust_dn2500_unknown_data_t* un); 
....................     int8_t (*events_request)(void* handle, struct dust_dn2500_events_request_t* p, struct dust_dn2500_unknown_data_t* un); 
....................     int8_t (*data_request)(void* handle, struct dust_dn2500_data_request_t* p, struct dust_dn2500_unknown_data_t* un); 
....................  
....................     // Unknown command 
....................     int8_t (*unknown_command)(void* handle, uint8_t* data, uint8_t len); 
....................  
....................     // source buffer 
....................     uint8_t     bf_src[MAX_ENCODED_PACKET_SIZE]; 
....................     uint8_t     len_src; 
....................  
....................     // destination buffer 
....................     uint8_t     bf_dest[MAX_DEST_BUF_SIZE]; 
....................     uint8_t     len_dest; 
....................  
....................     uint8_t     idx; 
....................      
....................  
....................     // Used in case SW version isn't in sync with HW firmware version 
....................    struct dust_dn2500_unknown_data_t unknown; 
.................... }; 
....................  
.................... // Utility commands to queue and clear packet data 
.................... int8_t dust_dn2500_q_clear(struct dust_dn2500_t* ia); 
.................... int8_t dust_dn2500_q_byte(struct dust_dn2500_t* ia, uint8_t byte); 
....................  
.................... // Routine to dispatch incoming packets to callbacks 
.................... int8_t dust_dn2500_dispatcher(struct pappy_t* md, struct dust_dn2500_t* ia, void* handle); 
.................... //user defined 
....................  
.................... */ 
....................  
.................... // HERE ARE ITEMS FROM DUST_HDLC.H 
.................... #define CONTROL_ESCAPE 0x7d 
.................... #define FLAG_SEQUENCE  0x7e 
.................... #define XOR_BYTE       0x20 
....................  
.................... /* Low level routine return values */ 
.................... #define DUST_HDLC_RTN_SUCCESS                     0 
.................... #define DUST_HDLC_RTN_NOT_ENOUGH_BUFFER_SPACE    -1 
.................... #define DUST_HDLC_RTN_BAD_CRC                    -2 
.................... #define DUST_HDLC_RTN_INVALID_PK_DELIMITERS      -3 
....................  
....................  
.................... // HERE ARE ITEMS FROM DUST_HDLC.C 
.................... #define FCS_INITIAL_FCS16 ((uint16_t) 0xffff) 
.................... #define FCS_GOOD_FCS16    ((uint16_t) 0xf0b8) 
....................  
.................... // We will use the routine that takes LESS PROCESSING TIME at the expense 
.................... //  or greater memory usage. 
....................  
.................... // lookup table for calculation of checksum 
.................... UNSIGNED INT16 CONST fcstab[256] =  { 
....................    0x0000, 0x1189, 0x2312, 0x329b, 0x4624, 0x57ad, 0x6536, 0x74bf, 
....................    0x8c48, 0x9dc1, 0xaf5a, 0xbed3, 0xca6c, 0xdbe5, 0xe97e, 0xf8f7, 
....................    0x1081, 0x0108, 0x3393, 0x221a, 0x56a5, 0x472c, 0x75b7, 0x643e, 
....................    0x9cc9, 0x8d40, 0xbfdb, 0xae52, 0xdaed, 0xcb64, 0xf9ff, 0xe876, 
....................    0x2102, 0x308b, 0x0210, 0x1399, 0x6726, 0x76af, 0x4434, 0x55bd, 
....................    0xad4a, 0xbcc3, 0x8e58, 0x9fd1, 0xeb6e, 0xfae7, 0xc87c, 0xd9f5, 
....................    0x3183, 0x200a, 0x1291, 0x0318, 0x77a7, 0x662e, 0x54b5, 0x453c, 
....................    0xbdcb, 0xac42, 0x9ed9, 0x8f50, 0xfbef, 0xea66, 0xd8fd, 0xc974, 
....................    0x4204, 0x538d, 0x6116, 0x709f, 0x0420, 0x15a9, 0x2732, 0x36bb, 
....................    0xce4c, 0xdfc5, 0xed5e, 0xfcd7, 0x8868, 0x99e1, 0xab7a, 0xbaf3, 
....................    0x5285, 0x430c, 0x7197, 0x601e, 0x14a1, 0x0528, 0x37b3, 0x263a, 
....................    0xdecd, 0xcf44, 0xfddf, 0xec56, 0x98e9, 0x8960, 0xbbfb, 0xaa72, 
....................    0x6306, 0x728f, 0x4014, 0x519d, 0x2522, 0x34ab, 0x0630, 0x17b9, 
....................    0xef4e, 0xfec7, 0xcc5c, 0xddd5, 0xa96a, 0xb8e3, 0x8a78, 0x9bf1, 
....................    0x7387, 0x620e, 0x5095, 0x411c, 0x35a3, 0x242a, 0x16b1, 0x0738, 
....................    0xffcf, 0xee46, 0xdcdd, 0xcd54, 0xb9eb, 0xa862, 0x9af9, 0x8b70, 
....................    0x8408, 0x9581, 0xa71a, 0xb693, 0xc22c, 0xd3a5, 0xe13e, 0xf0b7, 
....................    0x0840, 0x19c9, 0x2b52, 0x3adb, 0x4e64, 0x5fed, 0x6d76, 0x7cff, 
....................    0x9489, 0x8500, 0xb79b, 0xa612, 0xd2ad, 0xc324, 0xf1bf, 0xe036, 
....................    0x18c1, 0x0948, 0x3bd3, 0x2a5a, 0x5ee5, 0x4f6c, 0x7df7, 0x6c7e, 
....................    0xa50a, 0xb483, 0x8618, 0x9791, 0xe32e, 0xf2a7, 0xc03c, 0xd1b5, 
....................    0x2942, 0x38cb, 0x0a50, 0x1bd9, 0x6f66, 0x7eef, 0x4c74, 0x5dfd, 
....................    0xb58b, 0xa402, 0x9699, 0x8710, 0xf3af, 0xe226, 0xd0bd, 0xc134, 
....................    0x39c3, 0x284a, 0x1ad1, 0x0b58, 0x7fe7, 0x6e6e, 0x5cf5, 0x4d7c, 
....................    0xc60c, 0xd785, 0xe51e, 0xf497, 0x8028, 0x91a1, 0xa33a, 0xb2b3, 
....................    0x4a44, 0x5bcd, 0x6956, 0x78df, 0x0c60, 0x1de9, 0x2f72, 0x3efb, 
....................    0xd68d, 0xc704, 0xf59f, 0xe416, 0x90a9, 0x8120, 0xb3bb, 0xa232, 
....................    0x5ac5, 0x4b4c, 0x79d7, 0x685e, 0x1ce1, 0x0d68, 0x3ff3, 0x2e7a, 
....................    0xe70e, 0xf687, 0xc41c, 0xd595, 0xa12a, 0xb0a3, 0x8238, 0x93b1, 
....................    0x6b46, 0x7acf, 0x4854, 0x59dd, 0x2d62, 0x3ceb, 0x0e70, 0x1ff9, 
....................    0xf78f, 0xe606, 0xd49d, 0xc514, 0xb1ab, 0xa022, 0x92b9, 0x8330, 
....................    0x7bc7, 0x6a4e, 0x58d5, 0x495c, 0x3de3, 0x2c6a, 0x1ef1, 0x0f78 
.................... }; 
....................  
.................... /* 
.................... // EVEN MORE STUFF NOT RELEVANT TO JACK IMPLEMENTATION 
.................... // ITEMS FROM DUST_DN2500_HANDLER.H 
.................... // I THINK THESE ARE FUNCTION PROTOTYPES! 
.................... // set_parameter response packets received by sensor processor 
.................... int8_t dust_dn2500_set_param_tx_power_response(void* handle, struct dust_dn2500_set_param_tx_power_response_t* p, struct dust_dn2500_unknown_data_t* un); 
.................... int8_t dust_dn2500_set_param_join_duty_cycle_response(void* handle, struct dust_dn2500_set_param_join_duty_cycle_response_t* p, struct dust_dn2500_unknown_data_t* un); 
.................... int8_t dust_dn2500_set_param_battery_life_response(void* handle, struct dust_dn2500_set_param_battery_life_response_t* p, struct dust_dn2500_unknown_data_t* un); 
.................... int8_t dust_dn2500_set_param_service_response(void* handle, struct dust_dn2500_set_param_service_response_t* p, struct dust_dn2500_unknown_data_t* un); 
.................... int8_t dust_dn2500_set_param_event_mask_response(void* handle, struct dust_dn2500_set_param_event_mask_response_t* p, struct dust_dn2500_unknown_data_t* un); 
.................... int8_t dust_dn2500_set_param_hart_device_status_response(void* handle, struct dust_dn2500_set_param_hart_device_status_response_t* p, struct dust_dn2500_unknown_data_t* un); 
.................... int8_t dust_dn2500_set_param_hart_device_info_response(void* handle, struct dust_dn2500_set_param_hart_device_info_response_t* p, struct dust_dn2500_unknown_data_t* un); 
.................... int8_t dust_dn2500_set_param_write_protect_response(void* handle, struct dust_dn2500_set_param_write_protect_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................  
.................... // get_parameter response packets received by sensor processor 
.................... int8_t dust_dn2500_get_param_mote_info_response(void* handle, struct dust_dn2500_get_param_mote_info_response_t* p, struct dust_dn2500_unknown_data_t* un); 
.................... int8_t dust_dn2500_get_param_network_info_response(void* handle, struct dust_dn2500_get_param_network_info_response_t* p, struct dust_dn2500_unknown_data_t* un); 
.................... int8_t dust_dn2500_get_param_mote_status_response(void* handle, struct dust_dn2500_get_param_mote_status_response_t* p, struct dust_dn2500_unknown_data_t* un); 
.................... int8_t dust_dn2500_get_param_service_response(void* handle, struct dust_dn2500_get_param_service_response_t* p, struct dust_dn2500_unknown_data_t* un); 
.................... int8_t dust_dn2500_get_param_time_response(void* handle, struct dust_dn2500_get_param_time_response_t* p, struct dust_dn2500_unknown_data_t* un); 
.................... int8_t dust_dn2500_get_param_charge_response(void* handle, struct dust_dn2500_get_param_charge_response_t* p, struct dust_dn2500_unknown_data_t* un); 
.................... int8_t dust_dn2500_get_param_test_radio_rxstats_response(void* handle, struct dust_dn2500_get_param_test_radio_rxstats_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................  
.................... // get non-volatile response packets received by sensor processor 
.................... int8_t dust_dn2500_getnv_mac_address_response(void* handle, struct dust_dn2500_getnv_mac_address_response_t* p, struct dust_dn2500_unknown_data_t* un); 
.................... int8_t dust_dn2500_getnv_network_id_response(void* handle, struct dust_dn2500_getnv_network_id_response_t* p, struct dust_dn2500_unknown_data_t* un); 
.................... int8_t dust_dn2500_getnv_tx_power_response(void* handle, struct dust_dn2500_getnv_tx_power_response_t* p, struct dust_dn2500_unknown_data_t* un); 
.................... int8_t dust_dn2500_getnv_powerinfo_response(void* handle, struct dust_dn2500_getnv_powerinfo_response_t* p, struct dust_dn2500_unknown_data_t* un); 
.................... int8_t dust_dn2500_getnv_ttl_response(void* handle, struct dust_dn2500_getnv_ttl_response_t* p, struct dust_dn2500_unknown_data_t* un); 
.................... int8_t dust_dn2500_getnv_hart_antenna_gain(void* handle, struct dust_dn2500_getnv_hart_antenna_gain_response_t* p, struct dust_dn2500_unknown_data_t* un); 
.................... int8_t dust_dn2500_getnv_otap_lockout(void* handle, struct dust_dn2500_getnv_otap_lockout_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................  
.................... // set non-volatile response packets received by sensor processor 
.................... int8_t dust_dn2500_setnv_mac_address_response(void* handle, struct dust_dn2500_setnv_mac_address_response_t* p, struct dust_dn2500_unknown_data_t* un); 
.................... int8_t dust_dn2500_setnv_network_id_response(void* handle, struct dust_dn2500_setnv_network_id_response_t* p, struct dust_dn2500_unknown_data_t* un); 
.................... int8_t dust_dn2500_setnv_tx_power_response(void* handle, struct dust_dn2500_setnv_tx_power_response_t* p, struct dust_dn2500_unknown_data_t* un); 
.................... int8_t dust_dn2500_setnv_joinkey_response(void* handle, struct dust_dn2500_setnv_joinkey_response_t* p, struct dust_dn2500_unknown_data_t* un); 
.................... int8_t dust_dn2500_setnv_powerinfo_response(void* handle, struct dust_dn2500_setnv_powerinfo_response_t* p, struct dust_dn2500_unknown_data_t* un); 
.................... int8_t dust_dn2500_setnv_ttl_response(void* handle, struct dust_dn2500_setnv_ttl_response_t* p, struct dust_dn2500_unknown_data_t* un); 
.................... int8_t dust_dn2500_setnv_hart_antenna_gain(void* handle, struct dust_dn2500_setnv_hart_antenna_gain_response_t* p, struct dust_dn2500_unknown_data_t* un); 
.................... int8_t dust_dn2500_setnv_otap_lockout(void* handle, struct dust_dn2500_setnv_otap_lockout_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................  
.................... // motes response packets received by sensor processor 
.................... int8_t dust_dn2500_send_response(void* handle, struct dust_dn2500_send_response_t* p, struct dust_dn2500_unknown_data_t* un); 
.................... int8_t dust_dn2500_join_response(void* handle, struct dust_dn2500_join_response_t* p, struct dust_dn2500_unknown_data_t* un); 
.................... int8_t dust_dn2500_disconnect_response(void* handle, struct dust_dn2500_disconnect_response_t* p, struct dust_dn2500_unknown_data_t* un); 
.................... int8_t dust_dn2500_search_response(void* handle, struct dust_dn2500_search_response_t* p, struct dust_dn2500_unknown_data_t* un); 
.................... int8_t dust_dn2500_reset_response(void* handle, struct dust_dn2500_reset_response_t* p, struct dust_dn2500_unknown_data_t* un); 
.................... int8_t dust_dn2500_lowPowerSleep_response(void* handle, struct dust_dn2500_lowPowerSleep_response_t* p, struct dust_dn2500_unknown_data_t* un); 
.................... int8_t dust_dn2500_testRadioTx_response(void* handle, struct dust_dn2500_testRadioTx_response_t* p, struct dust_dn2500_unknown_data_t* un); 
.................... int8_t dust_dn2500_testRadioRx_response(void* handle, struct dust_dn2500_testRadioRx_response_t* p, struct dust_dn2500_unknown_data_t* un); 
.................... int8_t dust_dn2500_clearnv_response(void* handle, struct dust_dn2500_clearnv_response_t* p, struct dust_dn2500_unknown_data_t* un); 
....................  
.................... // Mote request packets received by sensor processor 
.................... int8_t dust_dn2500_time_request(void* handle, struct dust_dn2500_time_request_t* p, struct dust_dn2500_unknown_data_t* un); 
.................... int8_t dust_dn2500_service_indication(void* handle, struct dust_dn2500_service_indication_t* p, struct dust_dn2500_unknown_data_t* un); 
.................... int8_t dust_dn2500_events_request(void* handle, struct dust_dn2500_events_request_t* p, struct dust_dn2500_unknown_data_t* un); 
.................... int8_t dust_dn2500_data_request(void* handle, struct dust_dn2500_data_request_t* p, struct dust_dn2500_unknown_data_t* un); 
.................... int8_t dust_dn2500_unknown_command(void* handle, uint8_t* data, uint8_t len); 
....................  
.................... */ 
....................  
.................... #include "globals.h"                                
.................... // globals.h 
.................... // 
.................... // This file contains all of the global variables used in the firmware 
.................... //  
.................... // Add to this list carefull and keep it syncronized with vars_init(). 
....................  
.................... ////////////////////Global Variables Table of Contents///////////////////////// 
.................... //Test Globals 
.................... //LCD Globals 
.................... //Time Globals 
.................... //System Parameter Globals 
.................... //Hardware Enabled Globals 
.................... //Control Related Globals 
.................... //Valve Related Globals 
.................... //Mote Globals 
.................... //Priority Queue 
.................... //Time Queue 
.................... //Sprinkler Stack 
.................... //Command Stack                    
.................... //System State Globals 
....................  
.................... //Where to put? 
.................... uint32_t global_last_connected_time = 0;         
.................... uint16_t global_xdcr_output = 0; 
....................  
.................... // global that keeps track of why the system restarted/shutdown 
.................... uint8_t global_shutdown_cause = 0; 
.................... uint8_t global_previous_shutdown_cause = 0; 
....................  
.................... char global_firmware_version_string[5] = {'A','0','0','0',0};       
....................  
.................... ////////////////////Test Globals/////////////////////////////////////////////// 
.................... uint8_t test_global = 0; 
.................... uint8_t test_global_2 = 0; 
.................... uint32_t test_start_time = 0; 
.................... uint32_t test_end_time = 0; 
.................... uint16_t test_valve_open_1 = 0; 
.................... uint16_t test_rpm_1 = 0; 
.................... uint16_t test_duty_cycle_1 = 0; 
.................... uint16_t test_valve_open_2 = 0; 
.................... uint16_t test_rpm_2 = 0; 
.................... uint16_t test_duty_cycle_2 = 0; 
.................... uint16_t test_valve_open_3 = 0; 
.................... uint16_t test_rpm_3 = 0; 
.................... uint16_t test_duty_cycle_3 = 0; 
....................  
....................   
.................... ////////////////////LCD Globals//////////////////////////////////////////////// 
.................... unsigned char global_temp_line_buff[17]; 
.................... char* global_extra_lcd_ptr; 
....................                      
.................... // LCD skip update flag 
.................... // 0 = don't skip 
.................... // 1 = Last update skipped, clear screen and proceed as normal 
.................... // 2-255 = how many skips (plus 1) to skip.  LCD is updated 1/sec, so 4 =  
.................... //    3 seconds of skipping updates. 
.................... uint8_t     global_skip_lcd_update_count = 0;        
....................  
.................... // Current LCD page number 
.................... // 0 = don't display anything? 
.................... // 1-TOTAL_LCD_PAGES = display that page number   
.................... uint8_t     global_lcd_page_number = 0;       
....................                    
.................... ////////////////////Time Globals/////////////////////////////////////////////// 
.................... // keeps track of time since microprocessor has been awake in seconds 
.................... uint32_t global_rtc_time = 0; 
.................... // keeps track of the time within the mote system (taken from mote) 
.................... uint32_t global_utc_time = 0; 
....................  
.................... ////////////////////System Parameter Globals/////////////////////////////////// 
.................... uint16_t global_sprinkler_num = 0; 
....................  
.................... // More globals that we might actually want to keep 
.................... uint8_t     serial_number_rcvd[8] = {0,0,0,0,0,0,0,0}; 
.................... uint8_t     macaddr_rcvd[8] = {0,0,0,0,0,0,0,0}; 
....................  
.................... ////////////////////Hardware Enabled Globals/////////////////////////////////// 
.................... uint8_t  global_hardware_enabled = 0;                                                                
....................    #BIT  global_lcd_enabled         = global_hardware_enabled.0 
....................    #BIT  global_gps_enabled         = global_hardware_enabled.1 
....................    #BIT  global_xcdr_type1_enabled  = global_hardware_enabled.2 
....................    #BIT  global_xcdr_type2_enabled  = global_hardware_enabled.3 
....................    #BIT  global_fixture_enabled     = global_hardware_enabled.4 
....................    #BIT  global_temp1_enabled       = global_hardware_enabled.5 
....................    #BIT  global_dust_enabled        = global_hardware_enabled.6 
....................    #BIT  global_dust_operational    = global_hardware_enabled.7 
....................  
.................... ////////////////////Control Related Globals//////////////////////////////////// 
.................... // keeps track of rpms (updated via interrupt routine) 
.................... uint16_t global_current_period = 0; 
.................... uint16_t global_current_rpm; 
.................... uint16_t global_rpm_set_value = 100; 
.................... uint32_t global_last_rpm_value_time = 0; 
....................  
.................... // keeps track of duty cycles of brake and charge 
.................... uint16_t global_brake_duty = 0; 
.................... uint16_t global_charge_duty = MAX_CHARGE; 
.................... // keeps track of set points for brake and charge duty cycles 
.................... uint16_t global_brake_duty_set_value = 0; 
.................... uint16_t global_charge_duty_set_value = MAX_CHARGE; 
....................  
.................... // keeps track of mppc level 
.................... uint8_t  global_mppc_value = 100; 
.................... uint8_t  global_mppc_set_value = 100; 
.................... // keeps track of vgen 
.................... uint16_t global_vgen = 0; 
.................... // keeps track of fixture dac value 
.................... uint16_t global_fixture_dac_value = NO_FIXTURE; 
....................  
.................... // specifies how the rpm is being controlled (see defines for more info) 
.................... uint8_t global_control_loop_mechanism = NO_RPM_CONTROL_DYN_MPPC; 
....................  
.................... ////////////////////Valve Related Globals////////////////////////////////////// 
.................... // keeps track of current valve position 
.................... uint16_t global_valve_position = VLV_POSITION_UNKNOWN; 
.................... // valve position set point 
.................... //uint16_t global_valve_position_set_value = VLV_POSITION_UNKNOWN; 
.................... uint16_t global_valve_position_set_value = 0x2000; 
.................... // 1/1024th of the time to go from open to close calculated by calibrate valve    
.................... //     routine in units of 2ndary oscillator ticks 
.................... uint16_t global_valve_time_to_close_1024th = DEFAULT_VLV_TIME_TO_CLOSE; 
.................... // 1/1024th of the time to go from close to open calculated by calibrate valve   
.................... //    routine in units of 2ndary oscillator ticks 
.................... uint16_t global_valve_time_to_open_1024th = DEFAULT_VLV_TIME_TO_OPEN; 
.................... // amount of time the valve has been in motion in units of 1/1024ths of a 
.................... //    millispan.  So, not really time, but distance. 
.................... uint16_t global_valve_time_in_motion_1024ths = 0; 
.................... // when the last valve calibration was done, in utc time 
.................... uint32_t global_valve_calibration_utc_time = 0; 
.................... // number of movements since last calibration/endstop  
.................... uint8_t  global_valve_movements_since_endstop = 0; 
....................  
.................... // calibrate FSR valve position (default is 0x2000, but should be set by message) 
.................... uint16_t global_calibrate_fsr_valve_position = 0x2000; 
.................... // calibrate FSR outcome in period (inverse of rpm).  Default/unknown is 0-1 
.................... uint16_t global_calibrate_fsr_period = 0-1; 
.................... // when the last fsr calibration was done, in utc time 
.................... uint32_t global_calibrate_fsr_utc_time = 0; 
....................  
.................... ////////////////////Mote Globals/////////////////////////////////////////////// 
.................... //event flags defined by mote 
.................... uint8_t  event_flags; 
....................    #BIT  fl_boot_event           = event_flags.0 
....................    #BIT  fl_alarm_event          = event_flags.1 
....................    #BIT  fl_time_event           = event_flags.2 
....................    #BIT  fl_joinfail_event       = event_flags.3 
....................    #BIT  fl_disconnected_event   = event_flags.4 
....................    #BIT  fl_operational_event    = event_flags.5 
....................    #BIT  fl_config_event         = event_flags.6 
....................    #BIT  fl_unknown_event        = event_flags.7 
....................  
.................... // Note that bytes_from_mote union contains the stripped unstuffed data 
.................... //  eg, bytes_from_mote.dust_rcvd[128] 
.................... mote_to_micro  bytes_from_mote; 
.................... mote_to_micro* p; 
....................  
.................... // It just can't get bigger than this! 
.................... // pkgen places message to be sent here 
.................... char        dust_send_buffer[MAX_SEND_BUFFER]; 
....................  
.................... // this is only for doing acks and only needs to be  
.................... // MAX_USER_DATA_SIZE*2 + 2 + 4 + 12 + 2 
.................... // MAX_USER_DATA_SIZE is 2 bytes for ack 
.................... char        dust_send_buffer_isr[2*2 + 2 + 4 + 12 + 2]; 
....................  
.................... // THIS is the buffer for RAW rcvd mote 
.................... //  mote packet data 
.................... char        dust_recive_buffer[MAX_RCV_BUFFER + 1]; 
....................  
.................... //  this is place 
.................... //  where the packet to be sent by micro 
.................... //  to NETWORK manager is placed prior 
.................... //  to dust_send_data call 
.................... char        payload_buff[MAX_USER_DATA_SIZE]; 
....................  
.................... // Keeps track of how many bytes to send and passed between pkgen and pksend 
.................... uint8_t num_of_bytes_to_send = 0; 
.................... uint8_t num_of_bytes_to_send_isr = 0; 
....................  
.................... // This is specific to the subroutine 
.................... //  pkgen_send() which creates the message 
.................... //  to be sent from the mote to the net                      
.................... uint8_t     send_prefix[12]; 
....................  
.................... // send_prefix[11] will be set to number of bytes in packet 
.................... // The send_prefix structure is as follows: 
.................... // [0]      CMD_SEND 
.................... // [1]      length of request       - this is payload length + 9 
.................... // [2]      FLAG_SEND_REQUEST 
.................... // [3]/[4]  destination address     - always DESTADDR_HI, DESTADDR_LO 
.................... // [5]      svc_index               - get this from service indication received 
.................... //                                     at join time 
.................... // [6]      APPDOMAIN_MAINTENANCE 
.................... // [7]      PRIORITY_HIGH 
.................... // [8][9]   reserved                - 0x00, 0x00  
.................... // [10]     sequence_num            - always 0xFF for mote-originated packets 
.................... // [11]     payload length          - length of the payload in bytes 
....................  
....................  
.................... // For ensuring a message was recieved properly from mote 
.................... uint8_t result_rcvd = 0; 
....................  
.................... // JG Jan 2017 
.................... int1 fl_alt_LCD; 
....................  
.................... // Flag for going through deal with mote ISR and going to sleep afterwards 
.................... int1 fl_mote_dealt; 
....................  
.................... // Flag for a sucessful get/set response eliminating a few other flags 
.................... int1  global_set_get_response; 
....................  
.................... // FLAGS TO GET RID OF! 
.................... // Flag for receiving an advertisment 
.................... int1  advert_rcvd_fl; 
.................... int1  setnetid_done_fl; 
.................... int1  ack_sent_fl; 
.................... int1  pkt_rcvd_fl; 
.................... int1  joinduty_done_fl; 
.................... int1  gettime_done_fl; 
.................... int1  fl_batNOEE; 
.................... int1  joinkey_done_fl; 
.................... int1  joincmd_done_fl; 
....................  
.................... uint8_t flags_rcvd = 0 ,param_type_rcvd = 0, svc_index_rcvd=0; 
.................... uint16_t mote_msgSEQ = 0; 
....................  
.................... //Globals for when advertisements are received 
.................... uint16_t network_id_rcvd = NETWORK_ID_DEF; 
.................... uint16_t mote_id_rcvd = 0; 
.................... int8_t rssi_rcvd = 0; 
.................... uint8_t hop_depth_rcvd = 0; 
....................  
.................... // global variable that keeps track of the current temperature of the mote.   
.................... //    It is updated every MOTE_CHECKS_TIME seconds 
.................... int8_t global_mote_temperature = 0; 
....................  
.................... ////////////////////Priority Queue///////////////////////////////////////////// 
.................... // Actual priority queue 
.................... volatile uint8_t global_priority_queue[MAX_PRIORITY_QUEUE_ITEMS] = {0}; 
.................... volatile uint8_t global_current_priority_queue_location = (0-1); 
....................  
.................... ////////////////////Time Queue///////////////////////////////////////////////// 
.................... // Actual time queue 
.................... struct TimeQueueItem global_time_queue[MAX_TIME_QUEUE_ITEMS] = {0}; 
.................... uint8_t global_current_time_queue_location = (0-1); 
....................  
.................... ////////////////////Sprinkler Queue//////////////////////////////////////////// 
.................... // Actual sprinkler queue 
.................... struct SprinklerQueueItem global_sprinkler_queue[MAX_SPRINKLER_QUEUE_ITEMS] = {0}; 
.................... uint8_t global_current_sprinkler_queue_location = (0-1); 
.................... // when the current sprinkler command is supposed to end 
.................... uint32_t global_current_sprinkler_settings_end_time = (0-1); 
....................  
.................... ////////////////////Command Queue////////////////////////////////////////////// 
.................... // Actual command queue 
.................... struct CommandQueueItem global_command_queue[MAX_COMMAND_QUEUE_ITEMS] = {0}; 
.................... uint8_t global_current_command_queue_location = (0-1); 
....................  
.................... ////////////////////Message Queue////////////////////////////////////////////// 
.................... // Actual command queue 
.................... struct MessageQueueItem global_message_queue[MAX_MESSAGE_QUEUE_ITEMS] = {0}; 
.................... uint8_t global_current_message_queue_location = (0-1); 
.................... // global variable that stores the current errors encountered that will be sent 
.................... //    to the manager via an unsolicited error message 
.................... uint32_t global_error_message_bitfield = 0; 
....................  
.................... // the last error message's bitfield and send time for stopping reoccuring error messages 
.................... uint32_t last_error_message_sent_bitfield = 0; 
.................... uint32_t last_error_message_sent_rtc_time = 0; 
....................  
.................... ////////////////////System State Variables///////////////////////////////////// 
.................... uint8_t global_mote_state = MOTESTATE_UNKNOWN; 
.................... uint8_t global_system_state = SYSTEM_STATE_UNKNOWN; 
....................  
.................... #include "eeprom.h" 
.................... // EEPROM.h 
.................... // This contains all things related to the EEPROM 
.................... // -functions 
.................... // -#defines for memory locations 
.................... // -#defines conveted to eeprom values to load/store out of EEPROM 
....................  
.................... ////////////////////EEPROM Locations Start/////////////////////////////////////////////////////////////  
....................                                                              
.................... // start of EEPROM locations 
.................... #define EE_START_LOCATION     0x0000 
.................... // Location ID                                                                    
.................... #define EE_SPRINKLER_NUM      0x0000 
.................... // Cause for shutdown/restart 
.................... #define EE_RESTART_CAUSE      0x0002                                               
.................... // Last valve calibrations and time            
.................... #define EE_VLV_TIME_TO_OPEN   0x0004                                      
.................... #define EE_VLV_TIME_TO_CLOSE  0x0006                                             
.................... #define EE_VLV_CAL_UTC_TIME   0x0008                                     
.................... // Last valve position 
.................... #define EE_VLV_POSITION       0x000C                                                    
....................                   
.................... // start of eeprom changable variables                                             
.................... #define EE_VLV_NEAR_CLOSED_RANGE_MAX 0x000E 
.................... #define EE_VLV_NEAR_OPENED_RANGE_MAX 0x0010               
.................... #define EE_DAC_LVL_OPENING_NEAR_OPENED 0x0012   
.................... #define EE_DAC_LVL_OPENING_NEAR_CLOSED 0x0014   
.................... #define EE_DAC_LVL_CLOSING_NEAR_OPENED 0x0016   
.................... #define EE_DAC_LVL_CLOSING_NEAR_CLOSED 0x0018   
.................... #define EE_DAC_LVL_IN_MIDDLE 0x001A 
.................... #define EE_DAC_LVL_INIT_CURRENT_BOOST 0x001C 
.................... #define EE_VLV_INIT_CURRENT_BOOST_TIME_1024THS 0x001E  
.................... #define EE_VLV_NOT_SPIN_LIMIT 0x0020   
.................... #define EE_VLV_NOT_SPIN_FIX 0x0022   
.................... #define EE_NOT_SPINNING_MAG_DECOUPLING_RPM_FIXED 0x0024   
.................... #define EE_VLV_MAGNETIC_COUPLING_LIMIT 0x0026   
.................... #define EE_VLV_MAGNETIC_COUPLING_FIX 0x0028   
.................... #define EE_RPM_TIMEOUT 0x002A 
.................... #define EE_MOTE_SEARCH_TIME 0x002C 
.................... #define EE_MOTE_NETWORK_SHUTDOWN_TIMEOUT 0x002E                                         
.................... // end of eeprom changeable variables 
....................  
.................... // last byte of EEPROM used 
.................... #define EE_END_LOCATION       0x002F     
....................                                           
....................  
.................... ////////////////////EEPROM Locations End/////////////////////////////////////////////////////////////// 
....................  
....................  ////////////////////EEPROM defines->globals Start//////////////////////////////////////////////////////   
.................... // Maximum value of "near closed" range 
.................... uint16_t VLV_NEAR_CLOSED_RANGE_MAX = 0x1000; 
.................... // Maximum value of "near opened" range 
.................... uint16_t VLV_NEAR_OPENED_RANGE_MAX =   0x7000;     
....................                                             
.................... // DAC level while opening near the fully open end 
.................... uint16_t DAC_LVL_OPENING_NEAR_OPENED =      22; 
.................... // DAC level while opening near the fully closed end 
.................... uint16_t DAC_LVL_OPENING_NEAR_CLOSED =      15;    
.................... // DAC level while closing near the fully open end 
.................... uint16_t DAC_LVL_CLOSING_NEAR_OPENED =      15; 
.................... // DAC level while closing near the fully closed end                         
.................... uint16_t DAC_LVL_CLOSING_NEAR_CLOSED =      21;  
.................... // DAC level while moving in the middle of the valve range and it's default 
.................... uint16_t DAC_LVL_IN_MIDDLE =                18;  
.................... // DAC level for the inital current boost/lowered current limit   
.................... uint16_t DAC_LVL_INIT_CURRENT_BOOST =       15;      
....................  
.................... // Amount of millispans that a current boost/lovered dac level is implemented. 
.................... //    This is done outside of the (NEAR_CLOSED/OPEN_RANGE) 
.................... //    @ 45 seconds to close, 30 = 1.3 seconds 
.................... uint16_t VLV_INIT_CURRENT_BOOST_TIME_1024THS =  30;   
....................                                                
.................... // valve not-spinning and magnetic de-coupling defines                                                     
.................... // below this number is the regime where we watch for the not spinning case (low torque)  
.................... uint16_t VLV_NOT_SPIN_LIMIT =               0x4000; 
.................... // where we send the valve when we want to fix it.  If it gets fixed before reaching this valve position 
.................... //    it stops. If it does not get fixed by the time it reaches this position, it sends an error and stops. 
.................... uint16_t VLV_NOT_SPIN_FIX =                 0x7000; 
....................                                                
.................... // above this rpm, consider magnetic coupling or not-spinning fixed 
.................... uint8_t NOT_SPINNING_MAG_DECOUPLING_RPM_FIXED =  8;        
....................                                                    
.................... // above this number is the regime where we watch for the magnetic decoupling 
.................... uint16_t VLV_MAGNETIC_COUPLING_LIMIT =      0x5000;        
.................... // where to move the valve at a time when trying to recover  
.................... uint16_t VLV_MAGNETIC_COUPLING_FIX =        0x1000;              
.................... // amount to move the valve at a time when trying to recover    
....................                                                                            
.................... // how many seconds it takes to consider the rpm to be zero (or infinite for higher valve settings) 
.................... // 8 = 7.5 RPM (8 may be max of what ccp5 can handle without overflow)             
.................... uint16_t RPM_TIMEOUT =                     8; 
....................                                         
.................... // amount of seconds for mote to stay searching for advertisements                     
.................... uint16_t MOTE_SEARCH_TIME = 120;        
.................... // amount of time the mote will stay disconnected from the network before shutting down (1200 = 20 min)                                    
.................... uint16_t MOTE_NETWORK_SHUTDOWN_TIMEOUT = 1200;                      
....................  
.................... ////////////////////EEPROM defines->globals End////////////////////////////////////////////////////////  
....................   
.................... ////////////////////EEPROM Functions Start/////////////////////////////////////////////////////////////  
.................... uint8_t read_ee1(uint16_t source) 
.................... {                                                                  
....................    return read_eeprom(source); 
*
03120:  MOVFF  FF2,552
03124:  BCF    FF2.7
03126:  MOVFF  551,FAA
0312A:  MOVFF  550,FA9
0312E:  BCF    FA6.6
03130:  BCF    FA6.7
03132:  BSF    FA6.0
03134:  MOVF   FA8,W
03136:  MOVLB  5
03138:  BTFSC  x52.7
0313A:  BSF    FF2.7
0313C:  MOVWF  01
0313E:  MOVLB  0
03140:  RETURN 0
.................... }                 
.................... uint16_t read_ee2(uint16_t source) 
.................... { 
....................    return (make16(read_eeprom(source+1), read_eeprom(source))); 
*
03050:  MOVLW  01
03052:  MOVLB  5
03054:  ADDWF  x50,W
03056:  MOVWF  x52
03058:  MOVLW  00
0305A:  ADDWFC x51,W
0305C:  MOVWF  x53
0305E:  MOVFF  FF2,554
03062:  BCF    FF2.7
03064:  MOVFF  553,FAA
03068:  MOVFF  552,FA9
0306C:  BCF    FA6.6
0306E:  BCF    FA6.7
03070:  BSF    FA6.0
03072:  MOVF   FA8,W
03074:  BTFSC  x54.7
03076:  BSF    FF2.7
03078:  MOVWF  x52
0307A:  MOVFF  FF2,553
0307E:  BCF    FF2.7
03080:  MOVFF  551,FAA
03084:  MOVFF  550,FA9
03088:  BCF    FA6.6
0308A:  BCF    FA6.7
0308C:  BSF    FA6.0
0308E:  MOVF   FA8,W
03090:  BTFSC  x53.7
03092:  BSF    FF2.7
03094:  MOVWF  x55
03096:  MOVFF  552,03
0309A:  MOVF   x55,W
0309C:  MOVWF  01
0309E:  MOVF   03,W
030A0:  MOVWF  02
030A2:  MOVLB  0
030A4:  RETURN 0
.................... }  
.................... uint32_t read_ee4(uint16_t source) 
.................... { 
....................    return (make32(read_eeprom(source+3), read_eeprom(source+2), read_eeprom(source+1), read_eeprom(source))); 
*
03174:  MOVLW  03
03176:  MOVLB  5
03178:  ADDWF  x50,W
0317A:  MOVWF  x52
0317C:  MOVLW  00
0317E:  ADDWFC x51,W
03180:  MOVWF  x53
03182:  MOVFF  FF2,554
03186:  BCF    FF2.7
03188:  MOVFF  553,FAA
0318C:  MOVFF  552,FA9
03190:  BCF    FA6.6
03192:  BCF    FA6.7
03194:  BSF    FA6.0
03196:  MOVF   FA8,W
03198:  BTFSC  x54.7
0319A:  BSF    FF2.7
0319C:  MOVWF  x52
0319E:  MOVLW  02
031A0:  ADDWF  x50,W
031A2:  MOVWF  x55
031A4:  MOVLW  00
031A6:  ADDWFC x51,W
031A8:  MOVWF  x56
031AA:  MOVFF  FF2,553
031AE:  BCF    FF2.7
031B0:  MOVFF  556,FAA
031B4:  MOVFF  555,FA9
031B8:  BCF    FA6.6
031BA:  BCF    FA6.7
031BC:  BSF    FA6.0
031BE:  MOVF   FA8,W
031C0:  BTFSC  x53.7
031C2:  BSF    FF2.7
031C4:  MOVWF  x55
031C6:  MOVLW  01
031C8:  ADDWF  x50,W
031CA:  MOVWF  x56
031CC:  MOVLW  00
031CE:  ADDWFC x51,W
031D0:  MOVWF  x57
031D2:  MOVFF  FF2,558
031D6:  BCF    FF2.7
031D8:  MOVFF  557,FAA
031DC:  MOVFF  556,FA9
031E0:  BCF    FA6.6
031E2:  BCF    FA6.7
031E4:  BSF    FA6.0
031E6:  MOVF   FA8,W
031E8:  BTFSC  x58.7
031EA:  BSF    FF2.7
031EC:  MOVWF  x56
031EE:  MOVFF  FF2,557
031F2:  BCF    FF2.7
031F4:  MOVFF  551,FAA
031F8:  MOVFF  550,FA9
031FC:  BCF    FA6.6
031FE:  BCF    FA6.7
03200:  BSF    FA6.0
03202:  MOVF   FA8,W
03204:  BTFSC  x57.7
03206:  BSF    FF2.7
03208:  MOVWF  x59
0320A:  MOVFF  552,03
0320E:  MOVFF  555,02
03212:  MOVFF  556,01
03216:  MOVFF  559,00
0321A:  MOVLB  0
0321C:  RETURN 0
.................... } 
....................  
.................... void write_ee1(uint16_t dest, uint8_t dat8) 
.................... { 
....................    write_eeprom(dest, dat8); 
*
03142:  MOVF   FF2,W
03144:  MOVWF  00
03146:  BCF    FF2.7
03148:  MOVFF  551,FAA
0314C:  MOVFF  550,FA9
03150:  MOVFF  552,FA8
03154:  BCF    FA6.6
03156:  BCF    FA6.7
03158:  BSF    FA6.2
0315A:  MOVLB  F
0315C:  MOVLW  55
0315E:  MOVWF  FA7
03160:  MOVLW  AA
03162:  MOVWF  FA7
03164:  BSF    FA6.1
03166:  BTFSC  FA6.1
03168:  BRA    3166
0316A:  BCF    FA6.2
0316C:  MOVF   00,W
0316E:  IORWF  FF2,F
03170:  MOVLB  0
03172:  RETURN 0
.................... } 
....................  
.................... void write_ee2(uint16_t dest, uint16_t dat16) 
.................... { 
....................    write_eeprom(dest++, make8(dat16,0)); 
*
030A6:  MOVLB  5
030A8:  MOVF   x53,W
030AA:  MOVWF  03
030AC:  MOVF   x52,W
030AE:  INCF   x52,F
030B0:  BTFSC  FD8.2
030B2:  INCF   x53,F
030B4:  MOVWF  x56
030B6:  MOVFF  03,557
030BA:  MOVFF  554,558
030BE:  MOVF   FF2,W
030C0:  MOVWF  00
030C2:  BCF    FF2.7
030C4:  MOVFF  557,FAA
030C8:  MOVFF  556,FA9
030CC:  MOVFF  558,FA8
030D0:  BCF    FA6.6
030D2:  BCF    FA6.7
030D4:  BSF    FA6.2
030D6:  MOVLB  F
030D8:  MOVLW  55
030DA:  MOVWF  FA7
030DC:  MOVLW  AA
030DE:  MOVWF  FA7
030E0:  BSF    FA6.1
030E2:  BTFSC  FA6.1
030E4:  BRA    30E2
030E6:  BCF    FA6.2
030E8:  MOVF   00,W
030EA:  IORWF  FF2,F
....................    write_eeprom(dest, make8(dat16,1)); 
030EC:  MOVFF  555,556
030F0:  MOVFF  FF2,00
030F4:  BCF    FF2.7
030F6:  MOVFF  553,FAA
030FA:  MOVFF  552,FA9
030FE:  MOVFF  555,FA8
03102:  BCF    FA6.6
03104:  BCF    FA6.7
03106:  BSF    FA6.2
03108:  MOVLW  55
0310A:  MOVWF  FA7
0310C:  MOVLW  AA
0310E:  MOVWF  FA7
03110:  BSF    FA6.1
03112:  BTFSC  FA6.1
03114:  BRA    3112
03116:  BCF    FA6.2
03118:  MOVF   00,W
0311A:  IORWF  FF2,F
0311C:  MOVLB  0
0311E:  RETURN 0
.................... } 
....................  
.................... void write_ee4(uint16_t dest, uint32_t dat32) 
.................... { 
....................    write_eeprom(dest++, make8(dat32,0)); 
*
0667A:  MOVLB  5
0667C:  MOVF   x55,W
0667E:  MOVWF  03
06680:  MOVF   x54,W
06682:  INCF   x54,F
06684:  BTFSC  FD8.2
06686:  INCF   x55,F
06688:  MOVWF  x5A
0668A:  MOVFF  03,55B
0668E:  MOVFF  556,55C
06692:  MOVF   FF2,W
06694:  MOVWF  00
06696:  BCF    FF2.7
06698:  MOVFF  55B,FAA
0669C:  MOVFF  55A,FA9
066A0:  MOVFF  55C,FA8
066A4:  BCF    FA6.6
066A6:  BCF    FA6.7
066A8:  BSF    FA6.2
066AA:  MOVLB  F
066AC:  MOVLW  55
066AE:  MOVWF  FA7
066B0:  MOVLW  AA
066B2:  MOVWF  FA7
066B4:  BSF    FA6.1
066B6:  BTFSC  FA6.1
066B8:  BRA    66B6
066BA:  BCF    FA6.2
066BC:  MOVF   00,W
066BE:  IORWF  FF2,F
....................    write_eeprom(dest++, make8(dat32,1)); 
066C0:  MOVLB  5
066C2:  MOVF   x55,W
066C4:  MOVWF  03
066C6:  MOVF   x54,W
066C8:  INCF   x54,F
066CA:  BTFSC  FD8.2
066CC:  INCF   x55,F
066CE:  MOVWF  x5A
066D0:  MOVFF  03,55B
066D4:  MOVFF  557,55C
066D8:  MOVF   FF2,W
066DA:  MOVWF  00
066DC:  BCF    FF2.7
066DE:  MOVFF  55B,FAA
066E2:  MOVFF  55A,FA9
066E6:  MOVFF  55C,FA8
066EA:  BCF    FA6.6
066EC:  BCF    FA6.7
066EE:  BSF    FA6.2
066F0:  MOVLB  F
066F2:  MOVLW  55
066F4:  MOVWF  FA7
066F6:  MOVLW  AA
066F8:  MOVWF  FA7
066FA:  BSF    FA6.1
066FC:  BTFSC  FA6.1
066FE:  BRA    66FC
06700:  BCF    FA6.2
06702:  MOVF   00,W
06704:  IORWF  FF2,F
....................    write_eeprom(dest++, make8(dat32,2)); 
06706:  MOVLB  5
06708:  MOVF   x55,W
0670A:  MOVWF  03
0670C:  MOVF   x54,W
0670E:  INCF   x54,F
06710:  BTFSC  FD8.2
06712:  INCF   x55,F
06714:  MOVWF  x5A
06716:  MOVFF  03,55B
0671A:  MOVFF  558,55C
0671E:  MOVF   FF2,W
06720:  MOVWF  00
06722:  BCF    FF2.7
06724:  MOVFF  55B,FAA
06728:  MOVFF  55A,FA9
0672C:  MOVFF  55C,FA8
06730:  BCF    FA6.6
06732:  BCF    FA6.7
06734:  BSF    FA6.2
06736:  MOVLB  F
06738:  MOVLW  55
0673A:  MOVWF  FA7
0673C:  MOVLW  AA
0673E:  MOVWF  FA7
06740:  BSF    FA6.1
06742:  BTFSC  FA6.1
06744:  BRA    6742
06746:  BCF    FA6.2
06748:  MOVF   00,W
0674A:  IORWF  FF2,F
....................    write_eeprom(dest, make8(dat32,3)); 
0674C:  MOVFF  559,55A
06750:  MOVFF  FF2,00
06754:  BCF    FF2.7
06756:  MOVFF  555,FAA
0675A:  MOVFF  554,FA9
0675E:  MOVFF  559,FA8
06762:  BCF    FA6.6
06764:  BCF    FA6.7
06766:  BSF    FA6.2
06768:  MOVLW  55
0676A:  MOVWF  FA7
0676C:  MOVLW  AA
0676E:  MOVWF  FA7
06770:  BSF    FA6.1
06772:  BTFSC  FA6.1
06774:  BRA    6772
06776:  BCF    FA6.2
06778:  MOVF   00,W
0677A:  IORWF  FF2,F
0677C:  MOVLB  0
0677E:  RETURN 0
.................... }                                              
....................  
.................... void store_all_eeprom_values(void) 
.................... {                                                                                                   
....................  
....................    // store valve calibration times in EEPROM 
....................    write_ee2(EE_VLV_TIME_TO_OPEN, global_valve_time_to_open_1024th); 
*
094F8:  MOVLB  5
094FA:  CLRF   x53
094FC:  MOVLW  04
094FE:  MOVWF  x52
09500:  MOVFF  C0,555
09504:  MOVFF  BF,554
09508:  MOVLB  0
0950A:  CALL   30A6
....................    write_ee2(EE_VLV_TIME_TO_CLOSE, global_valve_time_to_close_1024th); 
0950E:  MOVLB  5
09510:  CLRF   x53
09512:  MOVLW  06
09514:  MOVWF  x52
09516:  MOVFF  BE,555
0951A:  MOVFF  BD,554
0951E:  MOVLB  0
09520:  CALL   30A6
....................    write_ee4(EE_VLV_CAL_UTC_TIME, global_valve_calibration_utc_time); 
09524:  MOVLB  5
09526:  CLRF   x55
09528:  MOVLW  08
0952A:  MOVWF  x54
0952C:  MOVFF  C6,559
09530:  MOVFF  C5,558
09534:  MOVFF  C4,557
09538:  MOVFF  C3,556
0953C:  MOVLB  0
0953E:  CALL   667A
....................    write_ee2(EE_VLV_POSITION, global_valve_position); 
09542:  MOVLB  5
09544:  CLRF   x53
09546:  MOVLW  0C
09548:  MOVWF  x52
0954A:  MOVFF  BA,555
0954E:  MOVFF  B9,554
09552:  MOVLB  0
09554:  CALL   30A6
....................    // save the shutdown/restart reason in EEPROM 
....................    write_ee1(EE_RESTART_CAUSE, global_shutdown_cause);                                         
09558:  MOVLB  5
0955A:  CLRF   x51
0955C:  MOVLW  02
0955E:  MOVWF  x50
09560:  MOVFF  4D,552
09564:  MOVLB  0
09566:  CALL   3142
0956A:  RETURN 0
....................                                                                                              
.................... } 
....................  
....................  
.................... void read_all_eeprom_values(void) 
.................... { 
....................    // if EEPROM is freshly flashed, overwrite sprinkler number with 0 
....................    if (read_ee2(EE_SPRINKLER_NUM) == 0xFFFF) write_ee2(EE_SPRINKLER_NUM,0);      
*
0321E:  MOVLB  5
03220:  CLRF   x51
03222:  CLRF   x50
03224:  MOVLB  0
03226:  RCALL  3050
03228:  MOVFF  02,548
0322C:  MOVFF  01,547
03230:  MOVLB  5
03232:  INCFSZ 01,W
03234:  BRA    3248
03236:  INCFSZ x48,W
03238:  BRA    3248
0323A:  CLRF   x53
0323C:  CLRF   x52
0323E:  CLRF   x55
03240:  CLRF   x54
03242:  MOVLB  0
03244:  RCALL  30A6
03246:  MOVLB  5
....................    // pull the sprinkler number from EEPROM  
....................    global_sprinkler_num = read_ee2(EE_SPRINKLER_NUM); 
03248:  CLRF   x51
0324A:  CLRF   x50
0324C:  MOVLB  0
0324E:  RCALL  3050
03250:  MOVFF  02,8E
03254:  MOVFF  01,8D
....................    // grab the shutdown cause and overwrite it for next time 
....................    global_previous_shutdown_cause = read_ee1(EE_RESTART_CAUSE); 
03258:  MOVLB  5
0325A:  CLRF   x51
0325C:  MOVLW  02
0325E:  MOVWF  x50
03260:  MOVLB  0
03262:  RCALL  3120
03264:  MOVFF  01,4E
....................    write_ee1(EE_RESTART_CAUSE,NO_ERR); 
03268:  MOVLB  5
0326A:  CLRF   x51
0326C:  MOVLW  02
0326E:  MOVWF  x50
03270:  CLRF   x52
03272:  MOVLB  0
03274:  RCALL  3142
....................                                                     
....................    // read valve calibration times and position in EEPROM 
....................    // if freshly flashed, valve position should default to 0xFFFF, which 
....................    // is defined as VLV_POSITION_UNKNOWN 
....................    global_valve_time_to_open_1024th = read_ee2(EE_VLV_TIME_TO_OPEN); 
03276:  MOVLB  5
03278:  CLRF   x51
0327A:  MOVLW  04
0327C:  MOVWF  x50
0327E:  MOVLB  0
03280:  RCALL  3050
03282:  MOVFF  02,C0
03286:  MOVFF  01,BF
....................    global_valve_time_to_close_1024th = read_ee2(EE_VLV_TIME_TO_CLOSE); 
0328A:  MOVLB  5
0328C:  CLRF   x51
0328E:  MOVLW  06
03290:  MOVWF  x50
03292:  MOVLB  0
03294:  RCALL  3050
03296:  MOVFF  02,BE
0329A:  MOVFF  01,BD
....................    global_valve_calibration_utc_time = read_ee4(EE_VLV_CAL_UTC_TIME); 
0329E:  MOVLB  5
032A0:  CLRF   x51
032A2:  MOVLW  08
032A4:  MOVWF  x50
032A6:  MOVLB  0
032A8:  RCALL  3174
032AA:  MOVFF  03,C6
032AE:  MOVFF  02,C5
032B2:  MOVFF  01,C4
032B6:  MOVFF  00,C3
....................    global_valve_position = read_ee2(EE_VLV_POSITION); 
032BA:  MOVLB  5
032BC:  CLRF   x51
032BE:  MOVLW  0C
032C0:  MOVWF  x50
032C2:  MOVLB  0
032C4:  RCALL  3050
032C6:  MOVFF  02,BA
032CA:  MOVFF  01,B9
....................    // store unknown valve position incase it doesn't get stored properly on shutdown/restart 
....................    //    so the position isn't used from before 
....................    write_ee2(EE_VLV_POSITION, VLV_POSITION_UNKNOWN); 
032CE:  MOVLB  5
032D0:  CLRF   x53
032D2:  MOVLW  0C
032D4:  MOVWF  x52
032D6:  SETF   x55
032D8:  SETF   x54
032DA:  MOVLB  0
032DC:  RCALL  30A6
032DE:  GOTO   98E2 (RETURN)
....................  
.................... } 
....................  
.................... void store_vcal_eeprom_values(void) 
.................... {   
....................    // store valve calibration times in EEPROM 
....................    write_ee2(EE_VLV_TIME_TO_OPEN, global_valve_time_to_open_1024th); 
*
079E2:  MOVLB  5
079E4:  CLRF   x53
079E6:  MOVLW  04
079E8:  MOVWF  x52
079EA:  MOVFF  C0,555
079EE:  MOVFF  BF,554
079F2:  MOVLB  0
079F4:  CALL   30A6
....................    write_ee2(EE_VLV_TIME_TO_CLOSE, global_valve_time_to_close_1024th); 
079F8:  MOVLB  5
079FA:  CLRF   x53
079FC:  MOVLW  06
079FE:  MOVWF  x52
07A00:  MOVFF  BE,555
07A04:  MOVFF  BD,554
07A08:  MOVLB  0
07A0A:  CALL   30A6
....................    write_ee4(EE_VLV_CAL_UTC_TIME, global_valve_calibration_utc_time); 
07A0E:  MOVLB  5
07A10:  CLRF   x55
07A12:  MOVLW  08
07A14:  MOVWF  x54
07A16:  MOVFF  C6,559
07A1A:  MOVFF  C5,558
07A1E:  MOVFF  C4,557
07A22:  MOVFF  C3,556
07A26:  MOVLB  0
07A28:  CALL   667A
07A2C:  GOTO   9D92 (RETURN)
.................... }                                                               
....................  
.................... void read_all_eeprom_variables(void)     
.................... {                                        
....................    uint16_t temp_u16; 
....................  
....................    temp_u16 = read_ee2(EE_VLV_NEAR_CLOSED_RANGE_MAX);        
*
032E2:  MOVLB  5
032E4:  CLRF   x51
032E6:  MOVLW  0E
032E8:  MOVWF  x50
032EA:  MOVLB  0
032EC:  RCALL  3050
032EE:  MOVFF  02,548
032F2:  MOVFF  01,547
....................    if (temp_u16 != 0xFFFF) VLV_NEAR_CLOSED_RANGE_MAX = temp_u16;  
032F6:  MOVLB  5
032F8:  INCFSZ x47,W
032FA:  BRA    3302
032FC:  INCFSZ x48,W
032FE:  BRA    3302
03300:  BRA    330A
03302:  MOVFF  548,4FF
03306:  MOVFF  547,4FE
....................     
....................    temp_u16 = read_ee2(EE_VLV_NEAR_OPENED_RANGE_MAX);        
0330A:  CLRF   x51
0330C:  MOVLW  10
0330E:  MOVWF  x50
03310:  MOVLB  0
03312:  RCALL  3050
03314:  MOVFF  02,548
03318:  MOVFF  01,547
....................    if (temp_u16 != 0xFFFF) VLV_NEAR_OPENED_RANGE_MAX = temp_u16; 
0331C:  MOVLB  5
0331E:  INCFSZ x47,W
03320:  BRA    3328
03322:  INCFSZ x48,W
03324:  BRA    3328
03326:  BRA    3330
03328:  MOVFF  548,501
0332C:  MOVFF  547,500
....................     
....................    temp_u16 = read_ee2(EE_DAC_LVL_OPENING_NEAR_OPENED);        
03330:  CLRF   x51
03332:  MOVLW  12
03334:  MOVWF  x50
03336:  MOVLB  0
03338:  RCALL  3050
0333A:  MOVFF  02,548
0333E:  MOVFF  01,547
....................    if (temp_u16 != 0xFFFF) DAC_LVL_OPENING_NEAR_OPENED = temp_u16; 
03342:  MOVLB  5
03344:  INCFSZ x47,W
03346:  BRA    334E
03348:  INCFSZ x48,W
0334A:  BRA    334E
0334C:  BRA    3356
0334E:  MOVFF  548,503
03352:  MOVFF  547,502
....................     
....................    temp_u16 = read_ee2(EE_DAC_LVL_OPENING_NEAR_CLOSED);        
03356:  CLRF   x51
03358:  MOVLW  14
0335A:  MOVWF  x50
0335C:  MOVLB  0
0335E:  RCALL  3050
03360:  MOVFF  02,548
03364:  MOVFF  01,547
....................    if (temp_u16 != 0xFFFF) DAC_LVL_OPENING_NEAR_CLOSED = temp_u16; 
03368:  MOVLB  5
0336A:  INCFSZ x47,W
0336C:  BRA    3374
0336E:  INCFSZ x48,W
03370:  BRA    3374
03372:  BRA    337C
03374:  MOVFF  548,505
03378:  MOVFF  547,504
....................     
....................    temp_u16 = read_ee2(EE_DAC_LVL_CLOSING_NEAR_OPENED);        
0337C:  CLRF   x51
0337E:  MOVLW  16
03380:  MOVWF  x50
03382:  MOVLB  0
03384:  RCALL  3050
03386:  MOVFF  02,548
0338A:  MOVFF  01,547
....................    if (temp_u16 != 0xFFFF) DAC_LVL_CLOSING_NEAR_OPENED = temp_u16; 
0338E:  MOVLB  5
03390:  INCFSZ x47,W
03392:  BRA    339A
03394:  INCFSZ x48,W
03396:  BRA    339A
03398:  BRA    33A2
0339A:  MOVFF  548,507
0339E:  MOVFF  547,506
....................     
....................    temp_u16 = read_ee2(EE_DAC_LVL_CLOSING_NEAR_CLOSED);        
033A2:  CLRF   x51
033A4:  MOVLW  18
033A6:  MOVWF  x50
033A8:  MOVLB  0
033AA:  RCALL  3050
033AC:  MOVFF  02,548
033B0:  MOVFF  01,547
....................    if (temp_u16 != 0xFFFF) DAC_LVL_CLOSING_NEAR_CLOSED = temp_u16; 
033B4:  MOVLB  5
033B6:  INCFSZ x47,W
033B8:  BRA    33C0
033BA:  INCFSZ x48,W
033BC:  BRA    33C0
033BE:  BRA    33C8
033C0:  MOVFF  548,509
033C4:  MOVFF  547,508
....................     
....................    temp_u16 = read_ee2(EE_DAC_LVL_IN_MIDDLE);        
033C8:  CLRF   x51
033CA:  MOVLW  1A
033CC:  MOVWF  x50
033CE:  MOVLB  0
033D0:  RCALL  3050
033D2:  MOVFF  02,548
033D6:  MOVFF  01,547
....................    if (temp_u16 != 0xFFFF) DAC_LVL_IN_MIDDLE = temp_u16; 
033DA:  MOVLB  5
033DC:  INCFSZ x47,W
033DE:  BRA    33E6
033E0:  INCFSZ x48,W
033E2:  BRA    33E6
033E4:  BRA    33EE
033E6:  MOVFF  548,50B
033EA:  MOVFF  547,50A
....................     
....................    temp_u16 = read_ee2(EE_DAC_LVL_INIT_CURRENT_BOOST);        
033EE:  CLRF   x51
033F0:  MOVLW  1C
033F2:  MOVWF  x50
033F4:  MOVLB  0
033F6:  RCALL  3050
033F8:  MOVFF  02,548
033FC:  MOVFF  01,547
....................    if (temp_u16 != 0xFFFF) DAC_LVL_INIT_CURRENT_BOOST = temp_u16; 
03400:  MOVLB  5
03402:  INCFSZ x47,W
03404:  BRA    340C
03406:  INCFSZ x48,W
03408:  BRA    340C
0340A:  BRA    3414
0340C:  MOVFF  548,50D
03410:  MOVFF  547,50C
....................     
....................    temp_u16 = read_ee2(EE_VLV_INIT_CURRENT_BOOST_TIME_1024THS);        
03414:  CLRF   x51
03416:  MOVLW  1E
03418:  MOVWF  x50
0341A:  MOVLB  0
0341C:  RCALL  3050
0341E:  MOVFF  02,548
03422:  MOVFF  01,547
....................    if (temp_u16 != 0xFFFF) VLV_INIT_CURRENT_BOOST_TIME_1024THS = temp_u16; 
03426:  MOVLB  5
03428:  INCFSZ x47,W
0342A:  BRA    3432
0342C:  INCFSZ x48,W
0342E:  BRA    3432
03430:  BRA    343A
03432:  MOVFF  548,50F
03436:  MOVFF  547,50E
....................     
....................    temp_u16 = read_ee2(EE_VLV_NOT_SPIN_LIMIT);        
0343A:  CLRF   x51
0343C:  MOVLW  20
0343E:  MOVWF  x50
03440:  MOVLB  0
03442:  RCALL  3050
03444:  MOVFF  02,548
03448:  MOVFF  01,547
....................    if (temp_u16 != 0xFFFF) VLV_NOT_SPIN_LIMIT = temp_u16; 
0344C:  MOVLB  5
0344E:  INCFSZ x47,W
03450:  BRA    3458
03452:  INCFSZ x48,W
03454:  BRA    3458
03456:  BRA    3460
03458:  MOVFF  548,511
0345C:  MOVFF  547,510
....................     
....................    temp_u16 = read_ee2(EE_VLV_NOT_SPIN_FIX);        
03460:  CLRF   x51
03462:  MOVLW  22
03464:  MOVWF  x50
03466:  MOVLB  0
03468:  RCALL  3050
0346A:  MOVFF  02,548
0346E:  MOVFF  01,547
....................    if (temp_u16 != 0xFFFF) VLV_NOT_SPIN_FIX = temp_u16;   
03472:  MOVLB  5
03474:  INCFSZ x47,W
03476:  BRA    347E
03478:  INCFSZ x48,W
0347A:  BRA    347E
0347C:  BRA    3486
0347E:  MOVFF  548,513
03482:  MOVFF  547,512
....................     
....................    temp_u16 = read_ee2(EE_NOT_SPINNING_MAG_DECOUPLING_RPM_FIXED);        
03486:  CLRF   x51
03488:  MOVLW  24
0348A:  MOVWF  x50
0348C:  MOVLB  0
0348E:  RCALL  3050
03490:  MOVFF  02,548
03494:  MOVFF  01,547
....................    if (temp_u16 != 0xFFFF) NOT_SPINNING_MAG_DECOUPLING_RPM_FIXED = temp_u16;   
03498:  MOVLB  5
0349A:  INCFSZ x47,W
0349C:  BRA    34A4
0349E:  INCFSZ x48,W
034A0:  BRA    34A4
034A2:  BRA    34A8
034A4:  MOVFF  547,514
....................     
....................    temp_u16 = read_ee2(EE_VLV_MAGNETIC_COUPLING_LIMIT);        
034A8:  CLRF   x51
034AA:  MOVLW  26
034AC:  MOVWF  x50
034AE:  MOVLB  0
034B0:  RCALL  3050
034B2:  MOVFF  02,548
034B6:  MOVFF  01,547
....................    if (temp_u16 != 0xFFFF) VLV_MAGNETIC_COUPLING_LIMIT = temp_u16;   
034BA:  MOVLB  5
034BC:  INCFSZ x47,W
034BE:  BRA    34C6
034C0:  INCFSZ x48,W
034C2:  BRA    34C6
034C4:  BRA    34CE
034C6:  MOVFF  548,516
034CA:  MOVFF  547,515
....................     
....................    temp_u16 = read_ee2(EE_VLV_MAGNETIC_COUPLING_FIX);        
034CE:  CLRF   x51
034D0:  MOVLW  28
034D2:  MOVWF  x50
034D4:  MOVLB  0
034D6:  RCALL  3050
034D8:  MOVFF  02,548
034DC:  MOVFF  01,547
....................    if (temp_u16 != 0xFFFF) VLV_MAGNETIC_COUPLING_FIX = temp_u16; 
034E0:  MOVLB  5
034E2:  INCFSZ x47,W
034E4:  BRA    34EC
034E6:  INCFSZ x48,W
034E8:  BRA    34EC
034EA:  BRA    34F4
034EC:  MOVFF  548,518
034F0:  MOVFF  547,517
....................     
....................    temp_u16 = read_ee2(EE_RPM_TIMEOUT);                       
034F4:  CLRF   x51
034F6:  MOVLW  2A
034F8:  MOVWF  x50
034FA:  MOVLB  0
034FC:  RCALL  3050
034FE:  MOVFF  02,548
03502:  MOVFF  01,547
....................    if (temp_u16 != 0xFFFF) RPM_TIMEOUT = temp_u16;   
03506:  MOVLB  5
03508:  INCFSZ x47,W
0350A:  BRA    3512
0350C:  INCFSZ x48,W
0350E:  BRA    3512
03510:  BRA    351A
03512:  MOVFF  548,51A
03516:  MOVFF  547,519
....................     
....................    temp_u16 = read_ee2(EE_MOTE_SEARCH_TIME);        
0351A:  CLRF   x51
0351C:  MOVLW  2C
0351E:  MOVWF  x50
03520:  MOVLB  0
03522:  RCALL  3050
03524:  MOVFF  02,548
03528:  MOVFF  01,547
....................    if (temp_u16 != 0xFFFF) MOTE_SEARCH_TIME = temp_u16;   
0352C:  MOVLB  5
0352E:  INCFSZ x47,W
03530:  BRA    3538
03532:  INCFSZ x48,W
03534:  BRA    3538
03536:  BRA    3540
03538:  MOVFF  548,51C
0353C:  MOVFF  547,51B
....................     
....................    temp_u16 = read_ee2(EE_MOTE_NETWORK_SHUTDOWN_TIMEOUT);        
03540:  CLRF   x51
03542:  MOVLW  2E
03544:  MOVWF  x50
03546:  MOVLB  0
03548:  RCALL  3050
0354A:  MOVFF  02,548
0354E:  MOVFF  01,547
....................    if (temp_u16 != 0xFFFF) MOTE_NETWORK_SHUTDOWN_TIMEOUT = temp_u16;    
03552:  MOVLB  5
03554:  INCFSZ x47,W
03556:  BRA    355E
03558:  INCFSZ x48,W
0355A:  BRA    355E
0355C:  BRA    3566
0355E:  MOVFF  548,51E
03562:  MOVFF  547,51D
03566:  MOVLB  0
03568:  GOTO   98E6 (RETURN)
.................... } 
....................     
....................  
.................... ////////////////////EEPROM Functions End///////////////////////////////////////////////////////////////  
....................                                                                                                     
....................  
....................   
....................  
....................   
.................... // specific headers                    
.................... #include "pic.h" 
.................... // This file contains all functions related to PIC functions and setup 
....................  
.................... //Function Definitions 
....................  
.................... // These defines are used in the oscillator setup subroutines below. 
.................... // Note the situations of concern: 
.................... //    4MHz osc: TMR2 prescale 16, postscale 6, PR2=99;         DIV16_POST6  
.................... //       [PWM freq 625Hz, PWM resolution 400, TMR2 int rate: 9.6ms] 
.................... //    3.6864MHz osc: TMR2 prescale 16, postscale 6, PR2=99;    DIV16_POST6 
.................... //       [PWM freq 576Hz, PWM resolution 400, TMR2 int rate: 10.4ms] 
.................... //    1MHz osc: TMR2 prescale 4, postscale 6, PR2=99;          DIV4_POST6 
.................... //       [PWM freq 625Hz, PWM resolution 400, TMR2 int rate: 9.6ms] 
.................... //    250KHz osc: TMR2 prescale 16, postscale 6, PR2=99;       DIV1_POST6 
.................... //       [PWM freq 625Hz, PWM resolution 400, TMR2 int rate: 9.6ms] 
.................... //    32768Hz osc: TMR2 prescale 1, postscale 1, PR2=79;       DIV1_POST1 
.................... //       [no PWM, TMR2 int rate: 9.8ms] 
.................... //    31250Hz osc: TMR2 prescale 1, postscale 1, PR2=79;       DIV1_POST1 
.................... //       [no PWM, TMR2 int rate: 10.2ms] 
....................  
.................... // SEE p 177 of DS41412F [PIC18(L)F2X/4XK22 datasheet] 
.................... #define  DIV16_POST6    0b00101110 
.................... #define  DIV4_POST6     0b00101101 
.................... #define  DIV1_POST6     0b00101100 
.................... #define  DIV1_POST1     0b00000100 
....................  
.................... // Each of these subroutines 
.................... //    a. save INTCON (high and low global int enab bits) 
.................... //    b. disable global interrupts 
.................... //    c. select the oscillator 
.................... //    d. set up TMR2, which is used to produce the PWM waveforms 
.................... //       and to cause interrupts to checking, e.g., the valve motor current 
.................... //    e. set up delnum param used by the newdel_10ms routine, 
.................... //       which is oscillator-dependent 
.................... //    f. restore INTCON 
....................  
.................... // These routines simply set up OSCCON, T0CON, T2CON, PR2 and osctype. 
....................  
.................... // PR2 is selected to provide a resolution of 400 in the PWM duty cycle 
.................... //  when clock is 250KHz and above. 
.................... // Below 250KHz the duty cycle resolution is unimportant because we would  
.................... //  be idling... 
.................... // The combination of PR2 and T2CON (T2CON includes prescale (1/4/16)  
.................... //  and postscale (..6..) ensures that the TMR2 ints occur at the proper rate  
.................... //  of approx 10ms regardless of the oscillator choice. 
.................... // Finally T0CON is set such that the timer 0 prescaler is selected to provide 
.................... //  TMR0 functionality and accuracy largely independent of oscillator choice: 
.................... //  e.g., at 31250/250k/1m/4m clock, T0CON is set such that the prescaler is  
.................... //   set to 2/16/64/256 thus providing a consistent counting rate of 3906.25Hz 
.................... //   and a programmable overflow time ranging from 256us up to about 16.8s 
.................... //  Accuracy is a bit compromised when running with the 3.6864MHz primary  
.................... //   crystal, but this error is not significant.... (an 8.5% error...) 
....................  
.................... //  Interrupts disabled to prevent reentrancy 
.................... void     fosc_pri(void) 
.................... { 
....................    uint8_t     tmp_intcon; 
....................    tmp_intcon = INTCON & 0xC0; 
*
0110C:  MOVF   FF2,W
0110E:  ANDLW  C0
01110:  MOVLB  5
01112:  MOVWF  xA0
....................    disable_interrupts(GLOBAL); 
01114:  BCF    FF2.6
01116:  BCF    FF2.7
01118:  BTFSC  FF2.7
0111A:  BRA    1116
....................    OSCCON = 0x00;       // select primary xtal oscillator 
0111C:  CLRF   FD3
....................    T0CON = T0_DIV_256;  // 278usec per tick 
0111E:  MOVLW  07
01120:  MOVWF  FD5
....................    T2CON = 0b01110010;  // T2 scale factor 15*16 (248usec per tick equiv) 
01122:  MOVLW  72
01124:  MOVWF  FBA
....................    T4CON = 0b01110010;  // T4 scale factor 15*16 (248usec per tick equiv) 
01126:  MOVLB  F
01128:  MOVWF  x51
....................    PR2 = 99;            
0112A:  MOVLW  63
0112C:  MOVWF  FBB
....................    INTCON |= tmp_intcon; 
0112E:  MOVLB  5
01130:  MOVF   xA0,W
01132:  IORWF  FF2,F
01134:  MOVLB  0
01136:  RETURN 0
.................... } 
....................  
.................... void     fosc_pri_ISR(void) 
.................... { 
....................    uint8_t     tmp_intcon; 
....................    tmp_intcon = INTCON & 0xC0; 
*
008B0:  MOVF   FF2,W
008B2:  ANDLW  C0
008B4:  MOVLB  5
008B6:  MOVWF  x83
....................    disable_interrupts(GLOBAL); 
008B8:  BCF    FF2.6
008BA:  BCF    FF2.7
008BC:  BTFSC  FF2.7
008BE:  BRA    08BA
....................    OSCCON = 0x00;       // select primary xtal oscillator 
008C0:  CLRF   FD3
....................    T0CON = T0_DIV_256;  // 278usec per tick 
008C2:  MOVLW  07
008C4:  MOVWF  FD5
....................    T2CON = 0b01110010;  // T2 scale factor 15*16 (248usec per tick equiv) 
008C6:  MOVLW  72
008C8:  MOVWF  FBA
....................    T4CON = 0b01110010;  // T4 scale factor 15*16 (248usec per tick equiv) 
008CA:  MOVLB  F
008CC:  MOVWF  x51
....................    PR2 = 99; 
008CE:  MOVLW  63
008D0:  MOVWF  FBB
....................    INTCON |= tmp_intcon; 
008D2:  MOVLB  5
008D4:  MOVF   x83,W
008D6:  IORWF  FF2,F
008D8:  MOVLB  0
008DA:  GOTO   16DA (RETURN)
.................... } 
....................  
.................... void     fosc_4m(void) 
.................... { 
....................    uint8_t     tmp_intcon; 
....................    tmp_intcon = INTCON & 0xC0; 
....................    disable_interrupts(GLOBAL); 
....................    OSCCON = 0x52;       // select 4MHz internal oscillator 
....................    T0CON = T0_DIV_256;  // 256usec per tick 
....................    T2CON = 0b01111010;  // T2 scale factor 16x16 (256usec per tick equiv) 
....................    T4CON = 0b01111010;  // T4 scale factor 16x16 (256usec per tick equiv) 
....................    PR2 = 99; 
....................    INTCON |= tmp_intcon; 
.................... } 
....................  
....................  
.................... void     fosc_1m(void) 
.................... { 
....................    uint8_t     tmp_intcon; 
....................    tmp_intcon = INTCON & 0xC0; 
....................    disable_interrupts(GLOBAL); 
....................    OSCCON = 0x32;       // select 1MHz internal oscillator 
....................    T0CON = T0_DIV_64;   // 256usec per tick 
....................    T2CON = 0b00011010;  // T2 scale factor 4*16 (256usec per tick equiv) 
....................    T4CON = 0b00011010;  // T4 scale factor 4*16 (256usec per tick equiv) 
....................    PR2 = 99; 
....................    INTCON |= tmp_intcon; 
.................... } 
....................  
.................... void     fosc_250k(void) 
.................... { 
....................    uint8_t     tmp_intcon; 
....................    tmp_intcon = INTCON & 0xC0; 
*
02FD6:  MOVF   FF2,W
02FD8:  ANDLW  C0
02FDA:  MOVLB  5
02FDC:  MOVWF  x47
....................    disable_interrupts(GLOBAL); 
02FDE:  BCF    FF2.6
02FE0:  BCF    FF2.7
02FE2:  BTFSC  FF2.7
02FE4:  BRA    2FE0
....................    OSCCON = 0x12;       // select 250KHz internal oscillator 
02FE6:  MOVLW  12
02FE8:  MOVWF  FD3
....................    T0CON = T0_DIV_16;   // 256usec per tick 
02FEA:  MOVLW  03
02FEC:  MOVWF  FD5
....................    T2CON = 0b00000010;  // T2 scale factor 1*16 (256usec per tick equiv) 
02FEE:  MOVLW  02
02FF0:  MOVWF  FBA
....................    T4CON = 0b00000010;  // T4 scale factor 1*16 (256usec per tick equiv) 
02FF2:  MOVLB  F
02FF4:  MOVWF  x51
....................    PR2 = 99; 
02FF6:  MOVLW  63
02FF8:  MOVWF  FBB
....................    INTCON |= tmp_intcon; 
02FFA:  MOVLB  5
02FFC:  MOVF   x47,W
02FFE:  IORWF  FF2,F
03000:  MOVLB  0
03002:  GOTO   300E (RETURN)
.................... } 
....................  
.................... void     fosc_250k_ISR(void) 
.................... { 
....................    uint8_t     tmp_intcon; 
....................    tmp_intcon = INTCON & 0xC0; 
....................    disable_interrupts(GLOBAL); 
....................    OSCCON = 0x12;       // select 250KHz internal oscillator 
....................    T0CON = T0_DIV_16;   // 256usec per tick 
....................    T2CON = 0b00000010;  // T2 scale factor 1*16 (256usec per tick equiv) 
....................    T4CON = 0b00000010;  // T4 scale factor 1*16 (256usec per tick equiv) 
....................    PR2 = 99; 
....................    INTCON |= tmp_intcon; 
.................... } 
....................  
.................... void     fosc_31250(void) 
.................... { 
....................    uint8_t     tmp_intcon; 
....................    tmp_intcon = INTCON & 0xC0; 
....................    disable_interrupts(GLOBAL); 
....................    OSCCON = 0x02;       // select 31250Hz internal oscillator 
....................    T0CON = T0_DIV_2;    // 256usec per tick 
....................    T2CON = 0b00001000;  // T2 scale factor 2*1 (256usec per tick equiv) 
....................    T4CON = 0b00001000;  // T4 scale factor 2*1 (256usec per tick equiv) 
....................    PR2 = 79; 
....................    INTCON |= tmp_intcon; 
.................... } 
....................  
.................... void     fosc_sec(void) 
.................... { 
....................    uint8_t     tmp_intcon; 
....................    tmp_intcon = INTCON & 0xC0; 
....................    disable_interrupts(GLOBAL); 
....................    OSCCON = 0x01;       // select secondary xtal oscillator 
....................    T0CON = T0_DIV_2;    // 244usec per tick 
....................    T2CON = 0b00001000;  // T2 scale factor 2*1 (244usec per tick equiv) 
....................    T4CON = 0b00001000;  // T4 scale factor 2*1 (244usec per tick equiv) 
....................    PR2 = 79; 
....................    INTCON |= tmp_intcon; 
.................... } 
....................  
.................... void osc_init(void) 
.................... { 
.................... // initalizes the oscillators/crystals, sets up delays, RS232, and i2c 
....................  
....................     
....................    // set stack pointer to 0 in case things restart 
....................    STKPTR = 0; 
03006:  CLRF   FFC
....................     
....................    #use delay(clock=3,686,400) 
....................    #use RS232 (uart1, baud=115200, ERRORS) 
*
01138:  BTFSS  F9E.4
0113A:  BRA    1138
0113C:  MOVWF  FAD
0113E:  RETURN 0
....................    //#use RS232 (uart2, baud=9600) 
....................     
....................    // start up 32.768KHz xtal oscillator 
....................    SOSCGO = TRUE; 
*
03008:  BSF    FD2.3
....................    // use medium freq internal osc (lower power) for 250KHz and 500KHz choices   
....................    MFIOSEL = TRUE;   
0300A:  BSF    FD2.4
....................     
....................    // switch to main 250k internal osc and setup delay functions                                     
....................    fosc_250k(); 
0300C:  BRA    2FD6
....................    #use delay(clock=250KHZ) 
*
035F0:  MOVLW  05
035F2:  MOVWF  FEA
035F4:  MOVLW  60
035F6:  MOVWF  FE9
035F8:  MOVF   FEF,W
035FA:  BZ    360A
035FC:  MOVLW  13
035FE:  MOVWF  00
03600:  DECFSZ 00,F
03602:  BRA    3600
03604:  NOP   
03606:  DECFSZ FEF,F
03608:  BRA    35FC
0360A:  RETURN 0
....................     
....................    // setup i2c for use on 250khz main clock 
....................    #use i2c(master, I2C1, FORCE_HW, NO_STRETCH, FAST=10000) 
*
0300E:  GOTO   989E (RETURN)
*
0360C:  BCF    FC6.7
0360E:  BCF    F9E.3
03610:  MOVFF  578,FC9
03614:  MOVLW  02
03616:  BTFSC  FC6.7
03618:  BRA    3624
0361A:  BTFSS  F9E.3
0361C:  BRA    361A
0361E:  MOVLW  00
03620:  BTFSC  FC5.6
03622:  MOVLW  01
03624:  MOVWF  01
03626:  RETURN 0
.................... } 
....................  
....................     
....................    // during initialization, except for servicing the mote, the fosc is 
....................    //  always at 250KHz 
....................    // The #use delay above ensures that delay_ms instructions are  
....................    //  compiled properly 
....................    // Built-in compiler delay functionality works fine until mote ints 
....................    //  occur because mote service speeds up the clock and screws up the 
....................    //  compiler built-in delay function..... 
....................  
....................    // The assumption is that I2C communications takes place when system  
....................    //  clock is set to 250KHz 
....................     
.................... void     setup_T0_int(uint16_t value) 
.................... { 
.................... // Use this routine to set up TMR0 such that its flag sets after  
.................... //  the designated time. 
.................... // These are not functions that hang up processing.  They merely ensure 
.................... //  that something takes place before a programmable amount of time passes. 
.................... // 
.................... // Add more possibilities as required.... 
.................... // The defines for "value" can be found in the .h file 
....................    disable_interrupts(GLOBAL); 
*
0356C:  BCF    FF2.6
0356E:  BCF    FF2.7
03570:  BTFSC  FF2.7
03572:  BRA    356E
....................    TMR0ON = FALSE; 
03574:  BCF    FD5.7
....................    set_timer0(value); 
03576:  MOVFF  565,FD7
0357A:  MOVFF  564,FD6
....................    TMR0IF = FALSE; 
0357E:  BCF    FF2.2
....................    TMR0ON = TRUE; 
03580:  BSF    FD5.7
....................    enable_interrupts(GLOBAL); 
03582:  MOVLW  C0
03584:  IORWF  FF2,F
03586:  RETURN 0
.................... } 
....................  
.................... void     setup_T2_int(uint8_t value) 
.................... { 
.................... // Use this routine during ISRs to set up TMR4 such that its flag sets 
.................... //  after the designated time. 
....................    TMR2ON = FALSE; 
*
04B2E:  BCF    FBA.2
....................    set_timer2(0); 
04B30:  CLRF   FBC
....................    PR2 = value; 
04B32:  MOVFF  547,FBB
....................    TMR2IF = FALSE; 
04B36:  BCF    F9E.1
....................    TMR2ON = TRUE; 
04B38:  BSF    FBA.2
04B3A:  RETURN 0
.................... } 
....................  
.................... void     setup_T4_int(uint8_t value) 
.................... { 
.................... // Use this routine during ISRs to set up TMR4 such that its flag sets 
.................... //  after the designated time. 
....................    TMR4ON = FALSE; 
*
008DE:  MOVLB  F
008E0:  BCF    x51.2
....................    set_timer4(0); 
008E2:  CLRF   x53
....................    PR4 = value; 
008E4:  MOVFF  5A0,F52
....................    TMR4IF = FALSE; 
008E8:  BCF    F7E.0
....................    TMR4ON = TRUE; 
008EA:  BSF    x51.2
008EC:  MOVLB  0
008EE:  RETURN 0
.................... } 
....................  
....................  
.................... void periph_init(void) 
.................... {  
....................    /* Initalizes and configures all perhips, ports, timers, etc. 
....................     * Items initalized include: 
....................     * Interrupts 
....................     * GPIOs 
....................     * Pullup resistors (Port B) 
....................     * Unused periphs in pic (turned off for lower power usage) 
....................     * Timers 
....................     * CCPs 
....................     *  
....................     */ 
....................  
....................    // extra insurance that we aren't interrupted while setting up periph    
....................    disable_interrupts(GLOBAL); 
*
03D3E:  BCF    FF2.6
03D40:  BCF    FF2.7
03D42:  BTFSC  FF2.7
03D44:  BRA    3D40
....................     
....................    // get I/O lines and hardware in general into LOWEST POSSIBLE current draw 
....................    setup_vref(VREF_OFF); 
03D46:  MOVLB  F
03D48:  CLRF   x42
....................    setup_dac(DAC_OFF); 
03D4A:  CLRF   x41
....................    setup_adc(ADC_OFF); 
03D4C:  BCF    FC2.0
....................     
....................    // ensure that the CTMU is off 
....................    CTMUICON = 0; 
03D4E:  CLRF   x43
....................    CTMUCONL = 0; 
03D50:  CLRF   x44
....................    CTMUCONH = 0; 
03D52:  CLRF   x45
....................     
....................    // ensure that the SR latch is off 
....................    SRCON0 = 0; 
03D54:  CLRF   x47
....................    SRCON1 = 0; 
03D56:  CLRF   x46
....................  
....................    // turns off comarator. Funny define from PICklkk 
....................    setup_comparator(NC_NC_NC_NC); 
03D58:  CLRF   F77
03D5A:  MOVLW  04
03D5C:  MOVWF  F78
03D5E:  MOVWF  F79
....................     
....................    /* definitively establishes that TMR2 is used to generate PWM frequency 
....................     * for P1x, P2x, P3x 
....................     */ 
....................    CCPTMRS0 = 0; 
03D60:  CLRF   x49
....................    CCPTMRS1 = 0;     
03D62:  CLRF   x48
....................     
....................    /* ADC setup (ports, configuration, reference) 
....................     * to perform an acquisition, select the channel and then turn on the ADC 
....................     * [ADON=TRUE]. Then do a read_adc() 
....................     */ 
....................    setup_adc_ports(sAN0|sAN1|sAN12); 
03D64:  MOVF   FC1,W
03D66:  ANDLW  F0
03D68:  MOVWF  FC1
03D6A:  MOVLW  03
03D6C:  MOVWF  x38
03D6E:  MOVLW  00
03D70:  MOVWF  x3C
03D72:  MOVLW  01
03D74:  MOVWF  x39
03D76:  MOVLW  00
03D78:  MOVWF  x3A
03D7A:  MOVWF  x3B
....................    ADCON2 = ADC_SETUP_DEF; 
03D7C:  SETF   FC0
....................    setup_adc_reference(VSS_VDD); 
03D7E:  BCF    FC1.0
03D80:  BCF    FC1.1
03D82:  BCF    FC1.2
03D84:  BCF    FC1.3
....................     
....................    /* setup pullup resistors on Port B for Mote Uart flow and XDCR detection    
....................     * RB2 (MOTE_TX_RTSn)    
....................     */                    
....................    port_b_pullups(0b00000100); 
03D86:  MOVLW  04
03D88:  MOVWF  F61
03D8A:  BCF    FF1.7
....................                                            
....................    // turns uart off 
....................    setup_uart(FALSE); 
03D8C:  BCF    FAB.7
03D8E:  BCF    FAB.4
03D90:  BCF    FAC.5
....................     
....................    // set the inital state and i/o characteristics for all ports 
....................    output_a(PORTA_INIT);                
03D92:  MOVLW  74
03D94:  MOVWF  F89
....................    output_b(PORTB_INIT); 
03D96:  MOVLW  18
03D98:  MOVWF  F8A
....................    output_c(PORTC_INIT); 
03D9A:  MOVLW  45
03D9C:  MOVWF  F8B
....................    output_d(PORTD_INIT); 
03D9E:  MOVLW  76
03DA0:  MOVWF  F8C
....................    output_e(PORTE_INIT); 
03DA2:  CLRF   F8D
....................    set_tris_a(TRISA_NORM); 
03DA4:  MOVLW  8B
03DA6:  MOVWF  F92
....................    set_tris_b(TRISB_NORM); 
03DA8:  MOVLW  F7
03DAA:  MOVWF  F93
....................    set_tris_c(TRISC_NORM); 
03DAC:  MOVLW  9A
03DAE:  MOVWF  F94
....................    set_tris_d(TRISD_NORM); 
03DB0:  MOVLW  80
03DB2:  MOVWF  F95
....................    set_tris_e(TRISE_NORM); 
03DB4:  BCF    F96.0
03DB6:  BCF    F96.1
03DB8:  BSF    F96.2
03DBA:  BSF    F96.3
....................   
....................    //********************Timers setup start********************     
....................     
....................    // TMR0 for general timing functions 
....................    setup_timer_0(T0_OFF); 
03DBC:  CLRF   FD5
....................     
....................    /* TMR1 is used in valve motion algorithm 
....................     * It is timed by the external secondary (32.768kHz) xtal 
....................     * Initalized in off mode 
....................     */ 
....................    setup_timer_1(T1_ENABLE_SOSC | T1_EXTERNAL | T1_DIV_BY_1); 
03DBE:  MOVLW  8F
03DC0:  MOVWF  FCD
03DC2:  CLRF   FCC
....................    TMR1ON = FALSE; 
03DC4:  BCF    FCD.0
....................    set_timer1(0); 
03DC6:  CLRF   FCF
03DC8:  CLRF   FCE
....................     
....................    /* TMR2 is used in all PWM generation and to produce 
....................     * an interrupt event every approx 16msec if desired 
....................     * TMR2 setup handled by oscillator setup macro above 
....................     * Initalized in off mode 
....................     */ 
....................    TMR2ON = FALSE; 
03DCA:  BCF    FBA.2
....................    set_timer2(0); 
03DCC:  CLRF   FBC
....................     
....................    /* TMR3 is used to count seconds 
....................     * It is timed by the external secondary (32.768kHz) xtal 
....................     * It is set to 8000 and overflows FFFF in 1 second. 
....................     * It is then reset to 8000 after counting 1 second after overflow 
....................     * Initalized in on mode 125ms before overflow (F000) 
....................     */ 
....................    setup_timer_3(T3_ENABLE_SOSC | T3_EXTERNAL | T3_DIV_BY_1);   
03DCE:  CLRF   FB4
03DD0:  MOVWF  FB1
....................    TMR3ON = FALSE; 
03DD2:  BCF    FB1.0
....................    set_timer3(0); 
03DD4:  CLRF   FB3
03DD6:  CLRF   FB2
....................       
....................    // TMR4 is not used 
....................    setup_timer_4(T4_DISABLED,0,1); 
03DD8:  MOVLW  00
03DDA:  MOVWF  x51
03DDC:  MOVLW  00
03DDE:  MOVWF  x52
....................     
....................    /* TMR5 is dedicated to measurement of RPM 
....................     * It is timed by the external secondary (32.768kHz) xtal 
....................     * Initalized in off mode 
....................     */ 
....................    setup_timer_5(T5_ENABLE_SOSC|T5_EXTERNAL|T5_DIV_BY_1); 
03DE0:  CLRF   x4D
03DE2:  MOVLW  8F
03DE4:  MOVWF  x4E
....................    TMR5ON = FALSE; 
03DE6:  BCF    x4E.0
....................    set_timer5(0); 
03DE8:  CLRF   x50
03DEA:  CLRF   x4F
....................     
....................    // TMR6 is not used 
....................    //setup_timer_6(T6_DISABLED,0,1); 
....................    TMR6ON = FALSE; 
03DEC:  BCF    x4A.2
....................    set_timer6(0); 
03DEE:  CLRF   x4C
....................     
....................    // sets up TMR2, TMR0, TMR6 CON   
....................    T0CON = T0_DIV_16;   
03DF0:  MOVLW  03
03DF2:  MOVWF  FD5
....................    T2CON = DIV1_POST6; 
03DF4:  MOVLW  2C
03DF6:  MOVWF  FBA
....................    T6CON = DIV1_POST6;                  
03DF8:  MOVWF  x4A
....................    PR2 = 99; 
03DFA:  MOVLW  63
03DFC:  MOVWF  FBB
....................    PR6 = 99;   
03DFE:  MOVWF  x4B
....................     
....................    //********************Timers setup end********************     
....................     
....................    //********************CCP setup start********************     
....................     
....................    //setup_ccp1(CCP_USE_TIMER1_AND_TIMER2 | CCP_PWM_L_L | CCP_PULSE_STEERING_A); 
....................    // CCP1(pwm with TMR2) and P1A are specifically for braking control. 
....................    // Set as above when in use. 
....................    // When off, the BRK_CTRLn line can be set as an I/O for 
....................    //  either max brake (lo) of min (hi) brake. 
....................    // Note that duty cycle 0 for minimum braking,  
....................    //  duty cycle=400 for (almost) maximum braking. 
....................    setup_ccp1(CCP_OFF);          // CCP1 off for now 
03E00:  MOVLW  F0
03E02:  ANDWF  FBD,F
....................    // P1A (BRAKE_CTRLn) is initialized to brakes off (1) 
....................   
....................    //setup_ccp2(CCP_USE_TIMER1_AND_TIMER2 | CCP_PWM_H_H | CCP_PULSE_STEERING_A); 
....................    // CCP2(pwm with TMR2) and P2A are specifically for control of charging. 
....................    // Set above when in use. 
....................    // When off, the LTC3105_CTRL line can be set as an I/O for  
....................    //  either max charging (hi) or min (lo) charging. 
....................    // Note that duty cycle 0 for no charging, 
....................    //  duty cycle=400 for (almost) max charging. 
....................    setup_ccp2(CCP_OFF);          // CCP2 off for now 
03E04:  ANDWF  F66,F
....................    // P2A (LTC3105_CTRL) is initialized to max charging aggressiveness (1) 
....................     
....................    //setup_ccp3(CCP_USE_TIMER1_AND_TIMER2 | CCP_PWM_L_L | CCP_PULSE_STEERING_A); 
....................    //setup_ccp3(CCP_USE_TIMER1_AND_TIMER2 | CCP_PWM_L_L | CCP_PULSE_STEERING_B); 
....................    //setup_ccp3(CCP_USE_TIMER1_AND_TIMER2 | CCP_COMPARE_RESET_TIMER); 
....................    // CCP3(compare)/TMR1 is for valve timing;  
....................    // CCP3(pwm)/TMR2 if for valve motor speed control 
....................    //Steer output to P3A for closing, steer output to P3B for opening; 
....................    // both VLV_CTRL1 (P3A) and VLV_CTRL2 (P3B) hi for braking; 
....................    // both VLV_CTRL1 (P3A) and VLV_CTRL2 (P3B) lo for coasting; 
....................    // pulse P3A lo while P3B hi for closing, pulse P3B while P3A hi for opening 
....................    //Compare mode used to time valve motion after ramp is finished. 
....................    //  Set CCPf_3 to 0x8000 and start TMR1 for 1sec interrupts; or use other 
....................    //  values for different timings.  General purpose timing when valve not 
....................    //  being timed. 
....................    setup_ccp3(CCP_OFF);          // CCP3 off for now 
03E06:  ANDWF  x5D,F
....................  
....................    //setup_ccp4(CCP_USE_TIMER3_AND_TIMER4 | CCP_COMPARE_RESET_TIMER);  
....................    // CCP4/TMR3 serves only one purpose: the real-time-clock. 
....................    //  Set CCP_4 to 0x8000 and start TMR1 for 1sec interrupts 
....................     
....................    setup_ccp4(CCP_OFF);          // CCP4 off for now 
03E08:  ANDWF  x57,F
....................     
....................    //setup_ccp(CCP_USE_TIMER5_AND_TIMER6 | CCP_CAPTURE_RE); 
....................    // CCP5/TMR5 serves only one purpose: measurement of spin rate.  
....................    setup_ccp5(CCP_OFF); 
03E0A:  ANDWF  x54,F
....................  
....................    //********************CCP setup end********************    
....................     
....................    //********************INT setup start******************   
....................     
....................    /* Diables: 
....................     * Global int (all ints) 
....................     * All peripheral ints 
....................     * TMR0 overflow int 
....................     * INT0 ext int 
....................     * Port B IOC int 
....................     * Clears: 
....................     * TMROIF, INT0IF, RBIF 
....................     */ 
....................    INTCON = 0; 
03E0C:  CLRF   FF2
....................     
....................    // PORTB pullups are enabled 
....................    // INTEDG0,1,2 on falling edge 
....................    // TMR0 and RBIP priority  is low 
....................    INTCON2 = 0; 
03E0E:  CLRF   FF1
....................     
....................    // External INT1, INT2 disabled/cleared and set to low priority                               
....................    INTCON3 = 0; 
03E10:  CLRF   FF0
....................     
....................    // Int priority enabled (part of RCON) 
....................    IPEN = TRUE; 
03E12:  BSF    FD0.7
....................     
....................    // Clear all peripheral interrupts 
....................    PIR1 = 0;                            
03E14:  CLRF   F9E
....................    PIR2 = 0; 
03E16:  CLRF   FA1
....................    PIR3 = 0; 
03E18:  CLRF   FA4
....................    PIR4 = 0; 
03E1A:  CLRF   F7B
....................    PIR5 = 0; 
03E1C:  CLRF   F7E
....................     
....................    // disable all peripheral interrupts 
....................    PIE1 = 0;                           
03E1E:  CLRF   F9D
....................    PIE2 = 0; 
03E20:  CLRF   FA0
....................    PIE3 = 0; 
03E22:  CLRF   FA3
....................    PIE4 = 0; 
03E24:  CLRF   F7A
....................    PIE5 = 0; 
03E26:  CLRF   F7D
....................       
....................    //   IPR1 = 0; 
....................    //   IPR2 = 0; 
....................    //   IPR3 = 0; 
....................    //   IPR4 = 0; 
....................    //   IPR5 = 0; 
....................  
....................    // setup IOC to call INT_RB only on RB4 change                     
....................    IOCB = 0b0001000;                 
03E28:  MOVLW  08
03E2A:  MOVWF  F62
....................                               
....................    //********************INT setup end********************  
....................                                 
....................    // initialize I2C 
....................    i2c_init(TRUE); 
03E2C:  BCF    FCB.0
03E2E:  BCF    FCB.1
03E30:  BCF    FCB.3
03E32:  MOVLW  06
03E34:  MOVWF  FC8
03E36:  MOVLW  28
03E38:  MOVWF  FC6
03E3A:  BSF    FC7.7
03E3C:  BCF    FC7.6
....................                           
....................    // initalizes XDCR, sets global xdcr_enabled 
....................    adc_XDCR_init();                                     
03E3E:  MOVLB  0
03E40:  GOTO   3588
....................          
....................    // initalize LCD, sets global lcd_enabled 
....................    LCD_init(); 
03E44:  RCALL  3710
....................     
....................    // set mppc value to 0                  
....................    set_mppc(global_mppc_value); 
03E46:  MOVFF  B2,550
03E4A:  RCALL  3B96
....................     
....................    // set battery charge cycle to 100%   
....................    set_charge_duty(global_charge_duty); 
03E4C:  MOVFF  AD,553
03E50:  MOVFF  AC,552
03E54:  RCALL  3C22
....................     
....................    // initalize fixture, sets global fixture_enabled 
....................    fixture_init(); 
03E56:  BRA    3CE4
....................     
....................    // Turn on LTC1541 and MCP4452  
....................    output_high(AUX_PWR); 
03E58:  BSF    F8C.3
....................     
....................    /* This iS for power supply settling etc.. 
....................     * pause for 125ms or longer; should not hang; 
....................     */ 
....................    delay_ms(125); 
03E5A:  MOVLW  7D
03E5C:  MOVLB  5
03E5E:  MOVWF  x60
03E60:  MOVLB  0
03E62:  CALL   35F0
03E66:  GOTO   98EA (RETURN)
....................     
....................  
....................      
.................... } 
....................  
.................... void vars_init(void) 
.................... { 
.................... // initalizes all global variables to default values from globals.h 
....................  
.................... ////////////////////Global Variables Table of Contents///////////////////////// 
.................... //Test Globals 
.................... //LCD Globals 
.................... //Time Globals 
.................... //Hardware Enabled Globals 
.................... //Control Related Globals 
.................... //Mote Globals 
.................... //Priority Queue 
.................... //Time Queue 
.................... //Sprinkler Stack 
.................... //Command Stack 
.................... //System State Globals 
....................  
.................... ////////////////////Test Globals/////////////////////////////////////////////// 
....................    test_global = 0; 
....................    test_global_2 = 0; 
....................    test_start_time = 0; 
....................    test_end_time = 0; 
....................    test_valve_open_1 = 0; 
....................    test_rpm_1 = 0; 
....................    test_duty_cycle_1 = 0; 
....................    test_valve_open_2 = 0; 
....................    test_rpm_2 = 0; 
....................    test_duty_cycle_2 = 0; 
....................    test_valve_open_3 = 0; 
....................    test_rpm_3 = 0; 
....................    test_duty_cycle_3 = 0; 
....................   
.................... ////////////////////LCD Globals//////////////////////////////////////////////// 
....................    memset(global_temp_line_buff, 0, sizeof global_temp_line_buff); 
....................    global_extra_lcd_ptr = NULL; 
....................  
.................... ////////////////////Time Globals/////////////////////////////////////////////// 
....................    // keeps track of time since microprocessor has been awake in seconds 
....................    global_rtc_time = 0; 
....................    // keeps track of the time within the mote system (taken from mote) 
....................    global_utc_time = 0; 
....................  
.................... ////////////////////Hardware Enabled Globals/////////////////////////////////// 
....................    global_lcd_enabled = 0; 
....................    global_xcdr_type1_enabled = 0; 
....................    global_xcdr_type2_enabled = 0; 
....................    global_fixture_enabled = 0; 
....................    global_dust_enabled = 0; 
....................  
.................... ////////////////////Control Related Globals//////////////////////////////////// 
....................    // keeps track of rpms (updated via interrupt routine) 
....................    global_current_period = 0; 
....................    global_rpm_set_value = 100; 
....................    // keeps track of duty cycles of brake and charge 
....................    global_brake_duty = 0; 
....................    global_charge_duty = MAX_CHARGE; 
....................    // keeps track of mppc level 
....................    global_mppc_value = 100; 
....................    // keeps track of vgen 
....................    global_vgen = 0; 
....................    // keeps track of fixture dac value 
....................    global_fixture_dac_value = NO_FIXTURE; 
....................  
.................... ////////////////////Valve Related Globals////////////////////////////////////// 
.................... // keeps track of current valve position 
....................    global_valve_position = VLV_POSITION_UNKNOWN; 
....................  
.................... ////////////////////Mote Globals/////////////////////////////////////////////// 
....................    //event flags defined by mote 
....................    event_flags = 0; 
....................  
....................    // Note that bytes_from_mote union contains the stripped unstuffed data 
....................    //  eg, bytes_from_mote.dust_rcvd[128] 
....................     
....................    memset (&bytes_from_mote, 0, sizeof bytes_from_mote); 
....................    p = NULL; 
....................  
....................    // It just can't get bigger than this! 
....................    // pkgen places message to be sent here 
....................    memset(dust_send_buffer, 0, sizeof(dust_send_buffer)); 
....................  
....................    // this is only for doing acks and only needs to be  
....................    // MAX_USER_DATA_SIZE*2 + 2 + 4 + 12 + 2 
....................    // MAX_USER_DATA_SIZE is 2 bytes for ack 
....................    memset(dust_send_buffer_isr, 0, sizeof dust_send_buffer_isr); 
....................  
....................    // THIS is the buffer for RAW rcvd mote 
....................    //  mote packet data 
....................    memset(dust_recive_buffer, 0, sizeof dust_recive_buffer); 
....................  
....................    //  this is place 
....................    //  where the packet to be sent by micro 
....................    //  to NETWORK manager is placed prior 
....................    //  to dust_send_data call 
....................    memset(payload_buff, 0, sizeof payload_buff); 
....................  
....................    // Keeps track of how many bytes to send and passed between pkgen and pksend 
....................    num_of_bytes_to_send = 0; 
....................    num_of_bytes_to_send_isr = 0; 
....................  
....................    // This is specific to the subroutine 
....................    //  pkgen_send() which creates the message 
....................    //  to be sent from the mote to the net                      
....................    send_prefix[0] = CMD_SEND; 
....................    send_prefix[1] = 0; 
....................    send_prefix[2] = FLAG_SEND_REQUEST; 
....................    send_prefix[3] = DESTADDR_HI; 
....................    send_prefix[4] = DESTADDR_LO; 
....................    send_prefix[6] = APPDOMAIN_MAINTENANCE; 
....................    send_prefix[7] = PRIORITY_HI; 
....................    send_prefix[8] = 0; 
....................    send_prefix[9] = 0; 
....................    send_prefix[10] = 0xFF; 
....................    send_prefix[11] = 0; 
....................     
....................    // send_prefix[11] will be set to number of bytes in packet    
....................       // The send_prefix structure is as follows: 
....................       // [0]      CMD_SEND 
....................       // [1]      length of request       - this is payload length + 9 
....................       // [2]      FLAG_SEND_REQUEST 
....................       // [3]/[4]  destination address     - always DESTADDR_HI, DESTADDR_LO 
....................       // [5]      svc_index               - get this from service indication received 
....................       //                                     at join time 
....................       // [6]      APPDOMAIN_MAINTENANCE 
....................       // [7]      PRIORITY_HIGH 
....................       // [8][9]   reserved                - 0x00, 0x00  
....................       // [10]     sequence_num            - always 0xFF for mote-originated packets 
....................       // [11]     payload length          - length of the payload in bytes 
....................  
....................  
....................    // For ensuring a message was recieved properly from mote 
....................    result_rcvd = 0; 
....................  
....................    // Flag for going through deal with mote ISR and going to sleep afterwards 
....................    fl_mote_dealt = 0; 
....................    fl_alt_LCD = 0; 
....................  
....................    // Flag for a sucessful get/set response eliminating a few other flags 
....................    global_set_get_response = 0; 
....................  
....................    // FLAGS TO GET RID OF! 
....................    // Flag for receiving an advertisment 
....................    advert_rcvd_fl = 0; 
....................    setnetid_done_fl = 0; 
....................    ack_sent_fl = 0; 
....................    pkt_rcvd_fl = 0; 
....................    joinduty_done_fl = 0; 
....................    gettime_done_fl = 0; 
....................    fl_batNOEE = 0; 
....................    joinkey_done_fl = 0; 
....................    joincmd_done_fl = 0; 
....................  
....................    flags_rcvd = 0, param_type_rcvd = 0, svc_index_rcvd=0; 
....................    mote_msgSEQ = 0; 
....................  
....................    //Globals for when advertisements are received 
....................    network_id_rcvd = 0; 
....................    mote_id_rcvd = 0; 
....................    rssi_rcvd = 0; 
....................    hop_depth_rcvd = 0; 
....................  
....................    // More globals that we might actually want to keep 
....................    memset(serial_number_rcvd, 0, sizeof serial_number_rcvd); 
....................    memset(macaddr_rcvd, 0, sizeof macaddr_rcvd); 
....................  
.................... ////////////////////Priority Queue///////////////////////////////////////////// 
....................    // Actual priority queue 
....................    memset(global_priority_queue, 0, sizeof global_priority_queue); 
....................    global_current_priority_queue_location = (0-1); 
....................  
.................... ////////////////////Time Queue///////////////////////////////////////////////// 
....................    // Actual time queue 
....................    memset(global_time_queue, 0, sizeof global_time_queue); 
....................    global_current_time_queue_location = (0-1); 
....................  
.................... ////////////////////Sprinkler Queue//////////////////////////////////////////// 
....................    // Actual sprinkler queue 
....................    memset(global_sprinkler_queue, 0, sizeof global_sprinkler_queue); 
....................  
.................... ////////////////////Command Queue////////////////////////////////////////////// 
....................    // Actual command queue 
....................    memset(global_command_queue, 0, sizeof global_command_queue); 
....................  
.................... ////////////////////System State Variables///////////////////////////////////// 
....................    global_mote_state = MOTESTATE_UNKNOWN; 
....................    global_system_state = SYSTEM_STATE_UNKNOWN; 
.................... } 
....................  
.................... void deep_sleep(void) 
.................... {  // zzzzzzz....... 
....................  
.................... // Ways out of deep sleep: MCLR button, V_GEN_INT (int1) 
.................... // SW1 DOES not wake it up... 
....................  
....................    disable_interrupts(GLOBAL); 
*
08C0A:  BCF    FF2.6
08C0C:  BCF    FF2.7
08C0E:  BTFSC  FF2.7
08C10:  BRA    8C0C
....................    strcpy (global_temp_line_buff, "Enter Deep Sleep"); 
08C12:  CLRF   FEA
08C14:  MOVLW  70
08C16:  MOVWF  FE9
08C18:  MOVLW  00
08C1A:  CALL   03BA
08C1E:  TBLRD*-
08C20:  TBLRD*+
08C22:  MOVF   FF5,W
08C24:  MOVWF  FEE
08C26:  IORLW  00
08C28:  BNZ   8C20
....................    LCD_line1(global_temp_line_buff); 
08C2A:  MOVLB  5
08C2C:  CLRF   x60
08C2E:  MOVLW  70
08C30:  MOVWF  x5F
08C32:  MOVLB  0
08C34:  CALL   365A
....................    strcpy (global_temp_line_buff, "Reason:         "); 
08C38:  CLRF   FEA
08C3A:  MOVLW  70
08C3C:  MOVWF  FE9
08C3E:  MOVLW  00
08C40:  CALL   03DC
08C44:  TBLRD*-
08C46:  TBLRD*+
08C48:  MOVF   FF5,W
08C4A:  MOVWF  FEE
08C4C:  IORLW  00
08C4E:  BNZ   8C46
....................    global_temp_line_buff[8] = hi2asc(global_shutdown_cause); 
08C50:  MOVFF  4D,560
08C54:  CALL   3012
08C58:  MOVFF  01,78
....................    global_temp_line_buff[9] = lo2asc(global_shutdown_cause); 
08C5C:  MOVFF  4D,560
08C60:  CALL   3032
08C64:  MOVFF  01,79
....................    LCD_line2(global_temp_line_buff);      
08C68:  MOVLB  5
08C6A:  CLRF   x60
08C6C:  MOVLW  70
08C6E:  MOVWF  x5F
08C70:  MOVLB  0
08C72:  CALL   36B4
....................     
....................    setup_T0_int(T0_6S); 
08C76:  MOVLW  A4
08C78:  MOVLB  5
08C7A:  MOVWF  x65
08C7C:  MOVLW  73
08C7E:  MOVWF  x64
08C80:  MOVLB  0
08C82:  CALL   356C
....................    while (!TMR0IF); 
08C86:  BTFSS  FF2.2
08C88:  BRA    8C86
....................     
....................    LCD_shutdown(); 
08C8A:  BRA    8B92
....................    output_a(PORTA_DEEP); 
08C8C:  MOVLW  74
08C8E:  MOVWF  F89
....................    output_b(PORTB_DEEP); 
08C90:  MOVLW  10
08C92:  MOVWF  F8A
....................    output_c(PORTC_DEEP); 
08C94:  MOVLW  45
08C96:  MOVWF  F8B
....................    output_d(PORTD_DEEP); 
08C98:  MOVLW  76
08C9A:  MOVWF  F8C
....................    output_e(PORTE_DEEP); 
08C9C:  CLRF   F8D
....................    set_tris_a(TRISA_NORM); 
08C9E:  MOVLW  8B
08CA0:  MOVWF  F92
....................    set_tris_b(TRISB_NORM); 
08CA2:  MOVLW  F7
08CA4:  MOVWF  F93
....................    set_tris_c(TRISC_NORM); 
08CA6:  MOVLW  9A
08CA8:  MOVWF  F94
....................    set_tris_d(TRISD_NORM); 
08CAA:  MOVLW  80
08CAC:  MOVWF  F95
....................    set_tris_e(TRISE_NORM); 
08CAE:  BCF    F96.0
08CB0:  BCF    F96.1
08CB2:  BSF    F96.2
08CB4:  BSF    F96.3
....................  
....................    setup_vref(VREF_OFF); 
08CB6:  MOVLB  F
08CB8:  CLRF   x42
....................    setup_dac(DAC_OFF); 
08CBA:  CLRF   x41
....................    setup_adc(ADC_OFF); 
08CBC:  BCF    FC2.0
....................    setup_CCP1(CCP_OFF); 
08CBE:  MOVLW  F0
08CC0:  ANDWF  FBD,F
....................    setup_CCP2(CCP_OFF); 
08CC2:  ANDWF  F66,F
....................    setup_CCP3(CCP_OFF);    
08CC4:  ANDWF  x5D,F
....................    setup_CCP4(CCP_OFF); 
08CC6:  ANDWF  x57,F
....................    setup_CCP5(CCP_OFF); 
08CC8:  ANDWF  x54,F
....................    setup_comparator(NC_NC_NC_NC); 
08CCA:  CLRF   F77
08CCC:  MOVLW  04
08CCE:  MOVWF  F78
08CD0:  MOVWF  F79
....................     
....................    clear_interrupt(INT_TIMER0); 
08CD2:  BCF    FF2.2
....................    setup_timer_1(T1_DISABLED); 
08CD4:  CLRF   FCD
08CD6:  CLRF   FCC
....................    setup_timer_2(T2_DISABLED,0,1); 
08CD8:  MOVLW  00
08CDA:  MOVWF  FBA
08CDC:  MOVLW  00
08CDE:  MOVWF  FBB
....................    setup_timer_3(T3_DISABLED); 
08CE0:  CLRF   FB4
08CE2:  CLRF   FB1
....................    setup_timer_4(T4_DISABLED,0,1); 
08CE4:  MOVWF  x51
08CE6:  MOVLW  00
08CE8:  MOVWF  x52
....................    setup_timer_5(T5_DISABLED); 
08CEA:  CLRF   x4D
08CEC:  CLRF   x4E
....................    setup_timer_6(T6_DISABLED,0,1); 
08CEE:  MOVWF  x4A
08CF0:  MOVLW  00
08CF2:  MOVWF  x4B
....................     
....................    setup_wdt(WDT_OFF);    
08CF4:  BCF    FD1.0
....................  
....................    setup_uart(FALSE); 
08CF6:  BCF    FAB.7
08CF8:  BCF    FAB.4
08CFA:  BCF    FAC.5
....................  
....................    INTCON = 0;                         // TMR0, INT0. IOC ints disabled/cleared 
08CFC:  CLRF   FF2
....................                                        //  High and Low Priority ints disabled 
....................    INTCON2 = 0;                        // RB port change int is low priority 
08CFE:  CLRF   FF1
....................                                        //  PORTB pullups are enabled 
....................    INTCON3 = 0;                        // INT1, INT2 ints disabled/cleared 
08D00:  CLRF   FF0
....................    IPEN = TRUE;                        // Int priority enabled (part of RCON) 
08D02:  BSF    FD0.7
....................     
....................    PIR1 = 0;                           // clear various interrupt flags 
08D04:  CLRF   F9E
....................    PIR2 = 0; 
08D06:  CLRF   FA1
....................    PIR3 = 0; 
08D08:  CLRF   FA4
....................    PIR4 = 0; 
08D0A:  CLRF   F7B
....................    PIR5 = 0; 
08D0C:  CLRF   F7E
....................     
....................    PIE1 = 0;                           // disable various interuupts 
08D0E:  CLRF   F9D
....................    PIE2 = 0; 
08D10:  CLRF   FA0
....................    PIE3 = 0; 
08D12:  CLRF   FA3
....................    PIE4 = 0; 
08D14:  CLRF   F7A
....................    PIE5 = 0; 
08D16:  CLRF   F7D
....................       
....................    IPR1 = 0; 
08D18:  CLRF   F9F
....................    IPR2 = 0; 
08D1A:  CLRF   FA2
....................    IPR3 = 0; 
08D1C:  CLRF   FA5
....................    IPR4 = 0; 
08D1E:  CLRF   F7C
....................    IPR5 = 0;   
08D20:  CLRF   F7F
....................     
....................    IOCB = 0;                     // disable all PORTB interrupt on change 
08D22:  CLRF   F62
....................                                  //  functionality 
....................    setup_adc_ports(NO_ANALOGS);                               
08D24:  MOVF   FC1,W
08D26:  ANDLW  F0
08D28:  MOVWF  FC1
08D2A:  MOVLW  00
08D2C:  MOVWF  x38
08D2E:  MOVWF  x3C
08D30:  MOVWF  x39
08D32:  MOVWF  x3A
08D34:  MOVWF  x3B
....................    clear_interrupt(INT_EXT); 
08D36:  BCF    FF2.1
....................    //clear_interrupt(INT_EXT2); 
....................    enable_interrupts(INT_EXT_L2H);  
08D38:  BSF    FF2.4
08D3A:  BSF    FF1.6
....................    //enable_interrupts(INT_EXT2_H2L);  
....................    enable_interrupts(GLOBAL); 
08D3C:  MOVLW  C0
08D3E:  IORWF  FF2,F
....................    delay_ms(1000);  
08D40:  MOVLW  04
08D42:  MOVLB  5
08D44:  MOVWF  x5F
08D46:  MOVLW  FA
08D48:  MOVWF  x60
08D4A:  MOVLB  0
08D4C:  CALL   35F0
08D50:  MOVLB  5
08D52:  DECFSZ x5F,F
08D54:  BRA    8D46
....................       
....................    sleep(SLEEP_FULL); 
08D56:  MOVFF  FD3,00
08D5A:  BCF    FD3.7
08D5C:  SLEEP 
08D5E:  MOVFF  00,FD3
....................  
....................    //reset_cpu(); 
....................    // wake up because of generator spin or SW1/Hall effect 
....................    if (input(V_GEN_INT)) 
08D62:  BTFSS  F81.0
08D64:  BRA    8D68
....................    { 
....................    //   reset_cause = SPIN_RESTART; 
....................    // otherwise it was the SW1/Hall effect that woke it up 
....................       reset_cpu(); 
08D66:  RESET
....................    } 
08D68:  MOVLB  0
08D6A:  RETURN 0
....................    // deep sleep is exited by a MCLR, or V_GEN_INT (SPIN RESTART) 
....................    // If for some reason it woke up, but not because of a SPIN_RESTART 
....................    //  then simply go back to deep_sleep 
....................     
....................     
.................... }  
....................  
....................  
.................... void start_rtc(void) 
.................... { 
....................    global_rtc_time = 0; 
*
03F0A:  CLRF   x88
03F0C:  CLRF   x87
03F0E:  CLRF   x86
03F10:  CLRF   x85
....................    CCP_4 = 0x8000; 
03F12:  MOVLW  80
03F14:  MOVLB  F
03F16:  MOVWF  x59
03F18:  CLRF   x58
....................    setup_ccp4(CCP_USE_TIMER3_AND_TIMER4 | CCP_COMPARE_RESET_TIMER); 
03F1A:  MOVLW  0B
03F1C:  MOVWF  x57
03F1E:  MOVLW  FC
03F20:  ANDWF  x48,F
03F22:  MOVLW  01
03F24:  IORWF  x48,F
....................    CCP4IF = FALSE; 
03F26:  BCF    F7B.1
....................    setup_timer_3(T3_ENABLE_SOSC | T3_EXTERNAL_SYNC | T3_DIV_BY_1); 
03F28:  CLRF   FB4
03F2A:  MOVLW  8B
03F2C:  MOVWF  FB1
....................    set_timer3(0);    
03F2E:  CLRF   FB3
03F30:  CLRF   FB2
....................    clear_interrupt(INT_CCP4); 
03F32:  BCF    F7B.1
....................    enable_interrupts(INT_CCP4); 
03F34:  BSF    F7A.1
03F36:  MOVLB  0
03F38:  GOTO   98FA (RETURN)
.................... } 
....................  
.................... void safeI2C_start(void) 
.................... { 
....................    setup_T0_int(T0_10MS); 
*
03B44:  MOVLB  5
03B46:  SETF   x65
03B48:  MOVLW  D9
03B4A:  MOVWF  x64
03B4C:  MOVLB  0
03B4E:  RCALL  356C
....................    while (I2CBUSY && !TMR0IF); 
03B50:  BTFSS  FC7.0
03B52:  BRA    3B58
03B54:  BTFSS  FF2.2
03B56:  BRA    3B50
....................    if (!I2CBUSY) 
03B58:  BTFSC  FC7.0
03B5A:  BRA    3B64
....................       i2c_start(); 
03B5C:  BSF    FC5.0
03B5E:  BTFSC  FC5.0
03B60:  BRA    3B5E
03B62:  BRA    3B80
....................    else 
....................    { 
....................       BCL1IF = FALSE; 
03B64:  BCF    FA1.3
....................       WCOL = FALSE; 
03B66:  BCF    FC6.7
....................       i2c_init(TRUE); 
03B68:  BCF    FCB.0
03B6A:  BCF    FCB.1
03B6C:  BCF    FCB.3
03B6E:  MOVLW  06
03B70:  MOVWF  FC8
03B72:  MOVLW  28
03B74:  MOVWF  FC6
03B76:  BSF    FC7.7
03B78:  BCF    FC7.6
....................       i2c_start(); 
03B7A:  BSF    FC5.1
03B7C:  BTFSC  FC5.1
03B7E:  BRA    3B7C
....................    } 
03B80:  RETURN 0
....................        
.................... } 
....................  
.................... void safeI2C_write(uint8_t value) 
.................... { 
....................    // thinking that a spike on the data or clock line is f'ing up 
....................    // i2c transmission, this routine simply looks for the ACK and if 
....................    // it does not see it, tries ONE MORE TIME and one more time only! 
....................    int1  unsuccess_fl; 
....................     
....................    unsuccess_fl = i2c_write(value); 
03B82:  MOVFF  551,578
03B86:  RCALL  360C
03B88:  MOVF   01,W
03B8A:  MOVLB  5
03B8C:  BCF    x52.0
03B8E:  BTFSC  01.0
03B90:  BSF    x52.0
03B92:  MOVLB  0
03B94:  RETURN 0
.................... //   if (unsuccess_fl) 
.................... //      i2c_write(value); 
.................... }                                     
....................  
....................  
....................  
.................... #include "dust.h"                                        
.................... void mote_init(void) 
.................... { 
....................    // sets the mote message sequence to a random number 
....................    init_msgSEQ(); 
*
0413E:  BRA    40F4
....................    // enable appropriate interrupts for mote response 
....................    clear_interrupt(INT_EXT2_H2L); 
04140:  BCF    FF0.1
....................    enable_interrupts(INT_EXT2_H2L); 
04142:  BSF    FF0.4
04144:  BCF    FF1.4
04146:  GOTO   9902 (RETURN)
.................... }    
....................     
.................... void mote_reset(void) 
.................... { 
....................    // Resets the mote, enables interrupts for the mote to respond, and 
....................    // schedules a WAIT_FOR_BOOT_EVENT to see if the mote responded 
....................   
....................    // Force an reset 
....................    output_low(MOTE_RESETn); 
*
04398:  BCF    F8C.4
....................    // definitely long enough at any clock speed 
....................    setup_T0_int(T0_250MS); 
0439A:  MOVLW  FC
0439C:  MOVLB  5
0439E:  MOVWF  x65
043A0:  MOVLW  30
043A2:  MOVWF  x64
043A4:  MOVLB  0
043A6:  CALL   356C
....................    while (!TMR0IF);    
043AA:  BTFSS  FF2.2
043AC:  BRA    43AA
....................    output_high(MOTE_RESETn); 
043AE:  BSF    F8C.4
....................       
....................    // add boot event checkup 
....................    PUSH_TIME_QUEUE_MACRO((global_rtc_time + 6), WAIT_FOR_BOOT_EVENT) 
043B0:  BCF    F7A.1
043B2:  MOVLW  06
043B4:  ADDWF  x85,W
043B6:  MOVLB  5
043B8:  MOVWF  x47
043BA:  MOVLW  00
043BC:  MOVLB  0
043BE:  ADDWFC x86,W
043C0:  MOVLB  5
043C2:  MOVWF  x48
043C4:  MOVLW  00
043C6:  MOVLB  0
043C8:  ADDWFC x87,W
043CA:  MOVLB  5
043CC:  MOVWF  x49
043CE:  MOVLW  00
043D0:  MOVLB  0
043D2:  ADDWFC x88,W
043D4:  MOVLB  5
043D6:  MOVWF  x4A
043D8:  MOVWF  x55
043DA:  MOVFF  549,554
043DE:  MOVFF  548,553
043E2:  MOVFF  547,552
043E6:  MOVLW  10
043E8:  MOVWF  x56
043EA:  MOVLB  0
043EC:  RCALL  414A
043EE:  BSF    F7A.1
043F0:  RETURN 0
.................... } 
....................  
.................... uint8_t mote_sleep(void) 
.................... { 
....................    uint8_t  result_byte; 
....................  
....................    // set the join duty and timeout error handling 
....................    global_set_get_response = FALSE; 
*
0956C:  MOVLB  3
0956E:  BCF    x58.2
....................    pkgen_sleep(); 
09570:  MOVLW  09
09572:  MOVLB  5
09574:  MOVWF  x48
09576:  CLRF   x49
09578:  MOVLW  04
0957A:  MOVWF  x4A
0957C:  CLRF   x62
0957E:  CLRF   x61
09580:  CLRF   x63
09582:  MOVLW  05
09584:  MOVWF  x65
09586:  MOVLW  48
09588:  MOVWF  x64
0958A:  MOVLW  03
0958C:  MOVWF  x66
0958E:  MOVLB  0
09590:  CALL   5C1A
....................    result_byte = dust_hdlc_pksend(); 
09594:  CALL   5EC4
09598:  MOVFF  01,547
....................    setup_T0_int(T0_250MS); 
0959C:  MOVLW  FC
0959E:  MOVLB  5
095A0:  MOVWF  x65
095A2:  MOVLW  30
095A4:  MOVWF  x64
095A6:  MOVLB  0
095A8:  CALL   356C
....................    while (!TMR0IF && !result_byte); 
095AC:  BTFSC  FF2.2
095AE:  BRA    95BE
095B0:  MOVLB  5
095B2:  MOVF   x47,F
095B4:  BTFSS  FD8.2
095B6:  BRA    95BC
095B8:  MOVLB  0
095BA:  BRA    95AC
095BC:  MOVLB  0
....................    if (TMR0IF || result_byte) 
095BE:  BTFSC  FF2.2
095C0:  BRA    95CA
095C2:  MOVLB  5
095C4:  MOVF   x47,F
095C6:  BZ    95CE
095C8:  MOVLB  0
....................    { 
....................       //return ERR_MOTE_UNRESPONSIVE; 
....................    } 
095CA:  BRA    95D6
095CC:  MOVLB  5
....................    else 
....................    { 
....................       return NO_ERR; 
095CE:  MOVLW  00
095D0:  MOVWF  01
095D2:  BRA    95DC
095D4:  MOVLB  0
....................    } 
....................    return NO_ERR; 
095D6:  MOVLW  00
095D8:  MOVWF  01
095DA:  MOVLB  5
095DC:  MOVLB  0
095DE:  GOTO   A3F8 (RETURN)
.................... } 
.................... void     search_for_strongest(void) 
*
08E78:  MOVLW  80
08E7A:  MOVLB  5
08E7C:  MOVWF  x48
08E7E:  CLRF   x4A
08E80:  CLRF   x49
08E82:  CLRF   x4C
08E84:  CLRF   x4B
.................... { 
....................    uint8_t     result_byte; 
....................    int8_t      rssi_best = -128; 
....................    int16_t     net_id_best = 0, net_id_current = 0;; 
....................    uint32_t    search_start_time = 0; 
....................    int1        net_id_selected = 0; 
08E86:  CLRF   x50
08E88:  CLRF   x4F
08E8A:  CLRF   x4E
08E8C:  CLRF   x4D
08E8E:  BCF    x51.0
....................     
....................    strcpy (global_temp_line_buff, " Searching ???? "); 
08E90:  CLRF   FEA
08E92:  MOVLW  70
08E94:  MOVWF  FE9
08E96:  MOVLW  00
08E98:  MOVLB  0
08E9A:  CALL   03FE
08E9E:  TBLRD*-
08EA0:  TBLRD*+
08EA2:  MOVF   FF5,W
08EA4:  MOVWF  FEE
08EA6:  IORLW  00
08EA8:  BNZ   8EA0
....................    LCD_line1(global_temp_line_buff); 
08EAA:  MOVLB  5
08EAC:  CLRF   x60
08EAE:  MOVLW  70
08EB0:  MOVWF  x5F
08EB2:  MOVLB  0
08EB4:  CALL   365A
....................    strcpy (global_temp_line_buff, "nnnn iii sss ddd"); 
08EB8:  CLRF   FEA
08EBA:  MOVLW  70
08EBC:  MOVWF  FE9
08EBE:  MOVLW  00
08EC0:  CALL   0420
08EC4:  TBLRD*-
08EC6:  TBLRD*+
08EC8:  MOVF   FF5,W
08ECA:  MOVWF  FEE
08ECC:  IORLW  00
08ECE:  BNZ   8EC6
....................    LCD_line2(global_temp_line_buff); 
08ED0:  MOVLB  5
08ED2:  CLRF   x60
08ED4:  MOVLW  70
08ED6:  MOVWF  x5F
08ED8:  MOVLB  0
08EDA:  CALL   36B4
....................    
....................    //prepare mote message for searching 
....................    pkgen_search(); 
08EDE:  MOVLW  11
08EE0:  MOVLB  5
08EE2:  MOVWF  x52
08EE4:  CLRF   x53
08EE6:  MOVLW  04
08EE8:  MOVWF  x54
08EEA:  CLRF   x62
08EEC:  CLRF   x61
08EEE:  CLRF   x63
08EF0:  MOVLW  05
08EF2:  MOVWF  x65
08EF4:  MOVLW  52
08EF6:  MOVWF  x64
08EF8:  MOVLW  03
08EFA:  MOVWF  x66
08EFC:  MOVLB  0
08EFE:  CALL   5C1A
....................    result_byte = dust_hdlc_pksend();          
08F02:  CALL   5EC4
08F06:  MOVFF  01,547
....................     
....................    // hangs until search begins or request times out; 
....................    setup_T0_int(T0_250MS); 
08F0A:  MOVLW  FC
08F0C:  MOVLB  5
08F0E:  MOVWF  x65
08F10:  MOVLW  30
08F12:  MOVWF  x64
08F14:  MOVLB  0
08F16:  CALL   356C
....................    while (!TMR0IF && (global_mote_state != MOTESTATE_SEARCHING) && !result_byte); 
08F1A:  BTFSC  FF2.2
08F1C:  BRA    8F3A
08F1E:  MOVLB  4
08F20:  MOVF   xFC,W
08F22:  SUBLW  02
08F24:  BTFSS  FD8.2
08F26:  BRA    8F2C
08F28:  MOVLB  0
08F2A:  BRA    8F3A
08F2C:  MOVLB  5
08F2E:  MOVF   x47,F
08F30:  BTFSS  FD8.2
08F32:  BRA    8F38
08F34:  MOVLB  0
08F36:  BRA    8F1A
08F38:  MOVLB  0
....................     
....................    //  immediately goes to sleep if ERR_MTNOTREADY 
....................    if (TMR0IF || global_mote_state != MOTESTATE_SEARCHING) 
08F3A:  BTFSC  FF2.2
08F3C:  BRA    8F48
08F3E:  MOVLB  4
08F40:  MOVF   xFC,W
08F42:  SUBLW  02
08F44:  BZ    8F50
08F46:  MOVLB  0
....................    { 
....................       global_shutdown_cause = ERR_NO_ADV_WHILE_SEARCHING; 
08F48:  MOVLW  02
08F4A:  MOVWF  4D
....................       deep_sleep();       
08F4C:  RCALL  8C0A
08F4E:  MOVLB  4
....................    } 
....................     
....................     
....................    // Search algorithm continues for MOTE_SEARCH_TIME or until net_id is selected 
....................    search_start_time = global_rtc_time; 
08F50:  MOVFF  88,550
08F54:  MOVFF  87,54F
08F58:  MOVFF  86,54E
08F5C:  MOVFF  85,54D
....................    while((global_rtc_time < (search_start_time + MOTE_SEARCH_TIME)) && !net_id_selected) 
08F60:  MOVLB  5
08F62:  MOVF   x1B,W
08F64:  ADDWF  x4D,W
08F66:  MOVWF  00
08F68:  MOVF   x1C,W
08F6A:  ADDWFC x4E,W
08F6C:  MOVWF  01
08F6E:  MOVLW  00
08F70:  ADDWFC x4F,W
08F72:  MOVWF  02
08F74:  MOVLW  00
08F76:  ADDWFC x50,W
08F78:  MOVWF  03
08F7A:  MOVLB  0
08F7C:  MOVF   x88,W
08F7E:  SUBWF  03,W
08F80:  BTFSS  FD8.0
08F82:  BRA    9134
08F84:  BNZ   8FA2
08F86:  MOVF   x87,W
08F88:  SUBWF  02,W
08F8A:  BTFSS  FD8.0
08F8C:  BRA    9134
08F8E:  BNZ   8FA2
08F90:  MOVF   x86,W
08F92:  SUBWF  01,W
08F94:  BTFSS  FD8.0
08F96:  BRA    9134
08F98:  BNZ   8FA2
08F9A:  MOVF   00,W
08F9C:  SUBWF  x85,W
08F9E:  BTFSC  FD8.0
08FA0:  BRA    9134
08FA2:  MOVLB  5
08FA4:  BTFSS  x51.0
08FA6:  BRA    8FAC
08FA8:  MOVLB  0
08FAA:  BRA    9134
....................    { 
....................       // use SW1 to exit early, give user a chance to select strongest netid 
....................       setup_T0_int(T0_2S); 
08FAC:  MOVLW  E1
08FAE:  MOVWF  x65
08FB0:  MOVLW  7C
08FB2:  MOVWF  x64
08FB4:  MOVLB  0
08FB6:  CALL   356C
....................       while (!TMR0IF) 
08FBA:  BTFSC  FF2.2
08FBC:  BRA    8FE4
....................       { 
....................          if (!input(SW1n))                
08FBE:  BTFSC  F81.4
08FC0:  BRA    8FE2
....................          { 
....................             //wait for 250MS for debounce                    
....................             setup_T0_int(T0_250MS); 
08FC2:  MOVLW  FC
08FC4:  MOVLB  5
08FC6:  MOVWF  x65
08FC8:  MOVLW  30
08FCA:  MOVWF  x64
08FCC:  MOVLB  0
08FCE:  CALL   356C
....................             while (!TMR0IF);                                                  
08FD2:  BTFSS  FF2.2
08FD4:  BRA    8FD2
....................             //check button after 250ms to see if it's still depressed, if so, exit 
....................             if (!input(SW1n)) 
08FD6:  BTFSC  F81.4
08FD8:  BRA    8FE2
....................             { 
....................                net_id_selected = TRUE; 
08FDA:  MOVLB  5
08FDC:  BSF    x51.0
....................                break; 
08FDE:  MOVLB  0
08FE0:  BRA    8FE4
....................             }                                                                
....................          } 
08FE2:  BRA    8FBA
....................       } 
....................        
....................       // if a new advertisement flag is triggered                      
....................       if (advert_rcvd_fl) 
08FE4:  MOVLB  3
08FE6:  BTFSS  x58.3
08FE8:  BRA    912E
....................          { 
....................             //saves current net id 
....................             net_id_current = network_id_rcvd; 
08FEA:  MOVFF  360,54C
08FEE:  MOVFF  35F,54B
....................             //displays information from advertisement 
....................             process_advert(); 
08FF2:  MOVLB  0
08FF4:  BRA    8D6C
....................             //reset advertisement flag 
....................             advert_rcvd_fl = FALSE; 
08FF6:  MOVLB  3
08FF8:  BCF    x58.3
....................  
....................             //if the advertisement came from a manager, give user a chance to  
....................             //select it and exit 
....................             if (mote_id_rcvd == 1) 
08FFA:  DECFSZ x61,W
08FFC:  BRA    912E
08FFE:  MOVF   x62,F
09000:  BTFSS  FD8.2
09002:  BRA    912E
....................             { 
....................                // if lcd is connected, give user a chance to select it 
....................                if (global_lcd_enabled == TRUE) 
09004:  MOVLB  0
09006:  BTFSS  x9F.0
09008:  BRA    909A
....................                { 
....................                   strcpy (global_temp_line_buff, "SW1 to Join     "); 
0900A:  CLRF   FEA
0900C:  MOVLW  70
0900E:  MOVWF  FE9
09010:  MOVLW  00
09012:  CALL   0442
09016:  TBLRD*-
09018:  TBLRD*+
0901A:  MOVF   FF5,W
0901C:  MOVWF  FEE
0901E:  IORLW  00
09020:  BNZ   9018
....................                   global_temp_line_buff[12] = hi2asc(make8(network_id_rcvd,1)); 
09022:  MOVFF  360,55F
09026:  MOVFF  360,560
0902A:  CALL   3012
0902E:  MOVFF  01,7C
....................                   global_temp_line_buff[13] = lo2asc(make8(network_id_rcvd,1)); 
09032:  MOVFF  360,55F
09036:  MOVFF  360,560
0903A:  CALL   3032
0903E:  MOVFF  01,7D
....................                   global_temp_line_buff[14] = hi2asc(make8(network_id_rcvd,0)); 
09042:  MOVFF  35F,55F
09046:  MOVFF  35F,560
0904A:  CALL   3012
0904E:  MOVFF  01,7E
....................                   global_temp_line_buff[15] = lo2asc(make8(network_id_rcvd,0)); 
09052:  MOVFF  35F,55F
09056:  MOVFF  35F,560
0905A:  CALL   3032
0905E:  MOVFF  01,7F
....................                   LCD_line1(global_temp_line_buff); 
09062:  MOVLB  5
09064:  CLRF   x60
09066:  MOVLW  70
09068:  MOVWF  x5F
0906A:  MOVLB  0
0906C:  CALL   365A
....................                    
....................                   // give the user a chance to select the current NetID for 4sec 
....................                   setup_T0_int(T0_4S); 
09070:  MOVLW  C2
09072:  MOVLB  5
09074:  MOVWF  x65
09076:  MOVLW  F7
09078:  MOVWF  x64
0907A:  MOVLB  0
0907C:  CALL   356C
....................                   while (!TMR0IF) 
09080:  BTFSC  FF2.2
09082:  BRA    909A
....................                   {                               
....................                      if (!input(SW1n)) 
09084:  BTFSC  F81.4
09086:  BRA    9098
....................                      { 
....................                         net_id_best = net_id_current; 
09088:  MOVFF  54C,54A
0908C:  MOVFF  54B,549
....................                         net_id_selected = 1; 
09090:  MOVLB  5
09092:  BSF    x51.0
....................                         break; 
09094:  MOVLB  0
09096:  BRA    909A
....................                      } 
09098:  BRA    9080
....................                   } 
....................                } 
....................                 
....................                // store the strongest signal unless user selected network 
....................                if ((rssi_rcvd > rssi_best) && (net_id_selected == FALSE)) 
0909A:  MOVLB  5
0909C:  MOVF   x48,W
0909E:  XORLW  80
090A0:  MOVWF  00
090A2:  MOVLB  3
090A4:  MOVF   x63,W
090A6:  XORLW  80
090A8:  SUBWF  00,W
090AA:  BC    90C4
090AC:  MOVLB  5
090AE:  BTFSS  x51.0
090B0:  BRA    90B6
090B2:  MOVLB  3
090B4:  BRA    90C4
....................                { 
....................                   rssi_best = rssi_rcvd; 
090B6:  MOVFF  363,548
....................                   net_id_best = network_id_rcvd; 
090BA:  MOVFF  360,54A
090BE:  MOVFF  35F,549
090C2:  MOVLB  3
....................                } 
....................                strcpy (global_temp_line_buff, "Strongest:      "); 
090C4:  CLRF   FEA
090C6:  MOVLW  70
090C8:  MOVWF  FE9
090CA:  MOVLW  00
090CC:  MOVLB  0
090CE:  CALL   0464
090D2:  TBLRD*-
090D4:  TBLRD*+
090D6:  MOVF   FF5,W
090D8:  MOVWF  FEE
090DA:  IORLW  00
090DC:  BNZ   90D4
....................                global_temp_line_buff[12] = hi2asc(make8(net_id_best,1)); 
090DE:  MOVFF  54A,55F
090E2:  MOVFF  54A,560
090E6:  CALL   3012
090EA:  MOVFF  01,7C
....................                global_temp_line_buff[13] = lo2asc(make8(net_id_best,1)); 
090EE:  MOVFF  54A,55F
090F2:  MOVFF  54A,560
090F6:  CALL   3032
090FA:  MOVFF  01,7D
....................                global_temp_line_buff[14] = hi2asc(make8(net_id_best,0)); 
090FE:  MOVFF  549,55F
09102:  MOVFF  549,560
09106:  CALL   3012
0910A:  MOVFF  01,7E
....................                global_temp_line_buff[15] = lo2asc(make8(net_id_best,0)); 
0910E:  MOVFF  549,55F
09112:  MOVFF  549,560
09116:  CALL   3032
0911A:  MOVFF  01,7F
....................                LCD_line1(global_temp_line_buff); 
0911E:  MOVLB  5
09120:  CLRF   x60
09122:  MOVLW  70
09124:  MOVWF  x5F
09126:  MOVLB  0
09128:  CALL   365A
0912C:  MOVLB  3
....................             } 
....................          } 
0912E:  MOVLB  4
09130:  BRA    8F60
09132:  MOVLB  0
....................       } 
....................                 
....................    disable_interrupts(GLOBAL); 
09134:  BCF    FF2.6
09136:  BCF    FF2.7
09138:  BTFSC  FF2.7
0913A:  BRA    9136
....................     
....................    net_id_best = __swap16(net_id_best);        // swap the bytes [why?] 
0913C:  MOVFF  549,560
09140:  MOVLB  5
09142:  CLRF   x5F
09144:  MOVF   x4A,W
09146:  CLRF   03
09148:  IORWF  x5F,W
0914A:  MOVWF  00
0914C:  MOVF   03,W
0914E:  IORWF  x49,W
09150:  MOVFF  00,549
09154:  MOVWF  x4A
....................    if (!net_id_best) 
09156:  MOVF   x49,W
09158:  IORWF  x4A,W
0915A:  BNZ   9166
....................    { 
....................       // send to deep sleep as no network was found 
....................       global_shutdown_cause = ERR_NO_ADV_WHILE_SEARCHING; 
0915C:  MOVLW  02
0915E:  MOVWF  4D
....................       deep_sleep(); 
09160:  MOVLB  0
09162:  RCALL  8C0A
09164:  MOVLB  5
....................    } 
....................    
....................    // now set the best network id into the motes NV memory 
....................    pkgen_setnv_networkid(net_id_best); 
09166:  MOVLW  03
09168:  MOVWF  x55
0916A:  MOVLW  07
0916C:  MOVWF  x56
0916E:  MOVLW  04
09170:  MOVWF  x57
09172:  CLRF   x58
09174:  CLRF   x59
09176:  CLRF   x5A
09178:  CLRF   x5B
0917A:  MOVLW  03
0917C:  MOVWF  x5C
0917E:  MOVFF  54A,55E
09182:  MOVFF  549,55D
09186:  MOVLW  05
09188:  MOVWF  x60
0918A:  MOVLW  5D
0918C:  MOVWF  x5F
0918E:  MOVLW  05
09190:  MOVWF  x62
09192:  MOVLW  55
09194:  MOVWF  x61
09196:  MOVLW  08
09198:  MOVWF  x63
0919A:  MOVFF  560,565
0919E:  MOVFF  55F,564
091A2:  MOVLW  02
091A4:  MOVWF  x66
091A6:  MOVLB  0
091A8:  CALL   5C1A
....................    result_byte = dust_hdlc_pksend(); 
091AC:  CALL   5EC4
091B0:  MOVFF  01,547
....................    setup_T0_int(T0_250MS); 
091B4:  MOVLW  FC
091B6:  MOVLB  5
091B8:  MOVWF  x65
091BA:  MOVLW  30
091BC:  MOVWF  x64
091BE:  MOVLB  0
091C0:  CALL   356C
....................    while (!TMR0IF && !setnetid_done_fl && !result_byte); 
091C4:  BTFSC  FF2.2
091C6:  BRA    91E0
091C8:  MOVLB  3
091CA:  BTFSS  x58.4
091CC:  BRA    91D2
091CE:  MOVLB  0
091D0:  BRA    91E0
091D2:  MOVLB  5
091D4:  MOVF   x47,F
091D6:  BTFSS  FD8.2
091D8:  BRA    91DE
091DA:  MOVLB  0
091DC:  BRA    91C4
091DE:  MOVLB  0
....................     
....................    if (TMR0IF || result_byte) 
091E0:  BTFSC  FF2.2
091E2:  BRA    91EC
091E4:  MOVLB  5
091E6:  MOVF   x47,F
091E8:  BZ    91F4
091EA:  MOVLB  0
....................    { 
....................       // send to deep sleep network couldn't be joined 
....................       global_shutdown_cause = ERR_NETWORK_JOIN_FAIL; 
091EC:  MOVLW  06
091EE:  MOVWF  4D
....................       deep_sleep(); 
091F0:  RCALL  8C0A
091F2:  MOVLB  5
....................    } 
....................     
....................    strcpy (global_temp_line_buff, " Search Success "); 
091F4:  CLRF   FEA
091F6:  MOVLW  70
091F8:  MOVWF  FE9
091FA:  MOVLW  00
091FC:  MOVLB  0
091FE:  CALL   0486
09202:  TBLRD*-
09204:  TBLRD*+
09206:  MOVF   FF5,W
09208:  MOVWF  FEE
0920A:  IORLW  00
0920C:  BNZ   9204
....................    LCD_line1(global_temp_line_buff); 
0920E:  MOVLB  5
09210:  CLRF   x60
09212:  MOVLW  70
09214:  MOVWF  x5F
09216:  MOVLB  0
09218:  CALL   365A
....................    strcpy (global_temp_line_buff, "Next join:      "); 
0921C:  CLRF   FEA
0921E:  MOVLW  70
09220:  MOVWF  FE9
09222:  MOVLW  00
09224:  CALL   04A8
09228:  TBLRD*-
0922A:  TBLRD*+
0922C:  MOVF   FF5,W
0922E:  MOVWF  FEE
09230:  IORLW  00
09232:  BNZ   922A
....................    global_temp_line_buff[12] = hi2asc(make8(net_id_best,0)); 
09234:  MOVFF  549,55F
09238:  MOVFF  549,560
0923C:  CALL   3012
09240:  MOVFF  01,7C
....................    global_temp_line_buff[13] = lo2asc(make8(net_id_best,0)); 
09244:  MOVFF  549,55F
09248:  MOVFF  549,560
0924C:  CALL   3032
09250:  MOVFF  01,7D
....................    global_temp_line_buff[14] = hi2asc(make8(net_id_best,1)); 
09254:  MOVFF  54A,55F
09258:  MOVFF  54A,560
0925C:  CALL   3012
09260:  MOVFF  01,7E
....................    global_temp_line_buff[15] = lo2asc(make8(net_id_best,1)); 
09264:  MOVFF  54A,55F
09268:  MOVFF  54A,560
0926C:  CALL   3032
09270:  MOVFF  01,7F
....................    LCD_line2(global_temp_line_buff); 
09274:  MOVLB  5
09276:  CLRF   x60
09278:  MOVLW  70
0927A:  MOVWF  x5F
0927C:  MOVLB  0
0927E:  CALL   36B4
....................  
....................    // Let it sit on the screen for a couple seconds 
....................    setup_T0_int(T0_2S); 
09282:  MOVLW  E1
09284:  MOVLB  5
09286:  MOVWF  x65
09288:  MOVLW  7C
0928A:  MOVWF  x64
0928C:  MOVLB  0
0928E:  CALL   356C
....................    while (!TMR0IF);       
09292:  BTFSS  FF2.2
09294:  BRA    9292
....................     
....................    happy_lites();                                            
09296:  CALL   4ADC
....................                                                  
....................    // send to deep sleep as network id is now set 
....................    global_shutdown_cause |= NEW_NETWORK_ID_SET; 
0929A:  MOVLW  03
0929C:  IORWF  4D,F
....................    deep_sleep(); 
0929E:  RCALL  8C0A
....................     
....................    return; 
092A0:  GOTO   A492 (RETURN)
.................... } 
....................  
.................... void  process_advert(void) 
.................... { 
....................    strcpy (global_temp_line_buff, "                "); 
*
08D6C:  CLRF   FEA
08D6E:  MOVLW  70
08D70:  MOVWF  FE9
08D72:  MOVLW  00
08D74:  CALL   04CA
08D78:  TBLRD*-
08D7A:  TBLRD*+
08D7C:  MOVF   FF5,W
08D7E:  MOVWF  FEE
08D80:  IORLW  00
08D82:  BNZ   8D7A
....................  
....................    global_temp_line_buff[0] = hi2asc(make8(network_id_rcvd,1)); 
08D84:  MOVFF  360,55F
08D88:  MOVFF  360,560
08D8C:  CALL   3012
08D90:  MOVFF  01,70
....................    global_temp_line_buff[1] = lo2asc(make8(network_id_rcvd,1)); 
08D94:  MOVFF  360,55F
08D98:  MOVFF  360,560
08D9C:  CALL   3032
08DA0:  MOVFF  01,71
....................    global_temp_line_buff[2] = hi2asc(make8(network_id_rcvd,0)); 
08DA4:  MOVFF  35F,55F
08DA8:  MOVFF  35F,560
08DAC:  CALL   3012
08DB0:  MOVFF  01,72
....................    global_temp_line_buff[3] = lo2asc(make8(network_id_rcvd,0)); 
08DB4:  MOVFF  35F,55F
08DB8:  MOVFF  35F,560
08DBC:  CALL   3032
08DC0:  MOVFF  01,73
....................    // NOTE network_id_rcvd is swapped when rcvd to simplify 
....................    //  the netID comparisons that take place later 
....................     
....................    LCD_line2(global_temp_line_buff);  
08DC4:  MOVLB  5
08DC6:  CLRF   x60
08DC8:  MOVLW  70
08DCA:  MOVWF  x5F
08DCC:  MOVLB  0
08DCE:  CALL   36B4
....................     
....................    mote_id_rcvd = __swap16(mote_id_rcvd);    // swap the bytes [why?] 
08DD2:  MOVFF  361,560
08DD6:  MOVLB  5
08DD8:  CLRF   x5F
08DDA:  MOVLB  3
08DDC:  MOVF   x62,W
08DDE:  CLRF   03
08DE0:  MOVLB  5
08DE2:  IORWF  x5F,W
08DE4:  MOVLB  3
08DE6:  MOVWF  x61
08DE8:  MOVF   03,W
08DEA:  MOVLB  5
08DEC:  IORWF  x60,W
08DEE:  MOVLB  3
08DF0:  MOVWF  x62
....................     
....................    LCD_place_uint16(mote_id_rcvd, 1, 5, 3); 
08DF2:  MOVFF  362,560
08DF6:  MOVFF  361,55F
08DFA:  MOVLW  01
08DFC:  MOVLB  5
08DFE:  MOVWF  x61
08E00:  MOVLW  05
08E02:  MOVWF  x62
08E04:  MOVLW  03
08E06:  MOVWF  x63
08E08:  MOVLB  0
08E0A:  CALL   4924
....................  
....................     
....................       if (rssi_rcvd >= 0) 
08E0E:  MOVLB  3
08E10:  BTFSC  x63.7
08E12:  BRA    8E34
....................       { 
....................          LCD_place_uint8(((uint8_t)(rssi_rcvd) + 128), 1, 9, 3); 
08E14:  MOVLW  80
08E16:  ADDWF  x63,W
08E18:  MOVLB  5
08E1A:  MOVWF  x5F
08E1C:  MOVWF  x60
08E1E:  MOVLW  01
08E20:  MOVWF  x61
08E22:  MOVLW  09
08E24:  MOVWF  x62
08E26:  MOVLW  03
08E28:  MOVWF  x63
08E2A:  MOVLB  0
08E2C:  CALL   4890
....................       } 
08E30:  BRA    8E5C
08E32:  MOVLB  3
....................       else 
....................       { 
....................          LCD_place_uint8((128 - abs(rssi_rcvd)), 1, 9, 3); 
08E34:  MOVF   x63,W
08E36:  BTFSS  x63.7
08E38:  BRA    8E40
08E3A:  MOVLW  00
08E3C:  BSF    FD8.0
08E3E:  SUBFWB x63,W
08E40:  XORLW  FF
08E42:  ADDLW  81
08E44:  MOVLB  5
08E46:  MOVWF  x5F
08E48:  MOVWF  x60
08E4A:  MOVLW  01
08E4C:  MOVWF  x61
08E4E:  MOVLW  09
08E50:  MOVWF  x62
08E52:  MOVLW  03
08E54:  MOVWF  x63
08E56:  MOVLB  0
08E58:  CALL   4890
....................       } 
....................     
....................    LCD_place_uint8(hop_depth_rcvd, 1, 13, 3); 
08E5C:  MOVFF  364,560
08E60:  MOVLW  01
08E62:  MOVLB  5
08E64:  MOVWF  x61
08E66:  MOVLW  0D
08E68:  MOVWF  x62
08E6A:  MOVLW  03
08E6C:  MOVWF  x63
08E6E:  MOVLB  0
08E70:  CALL   4890
08E74:  GOTO   8FF6 (RETURN)
.................... } 
....................  
.................... uint8_t     initiate_join(void) 
.................... { 
.................... // initiates a join by setting the joinduty to the max   
....................    uint8_t  result_byte; 
....................     
....................    // set the join duty and timeout error handling 
....................    global_set_get_response = FALSE; 
*
092A4:  MOVLB  3
092A6:  BCF    x58.2
....................    pkgen_set_joinduty(0xFF); 
092A8:  MOVLW  01
092AA:  MOVLB  5
092AC:  MOVWF  x48
092AE:  MOVLW  02
092B0:  MOVWF  x49
092B2:  MOVLW  04
092B4:  MOVWF  x4A
092B6:  MOVLW  06
092B8:  MOVWF  x4B
092BA:  SETF   x4C
092BC:  MOVLW  05
092BE:  MOVWF  x62
092C0:  MOVLW  48
092C2:  MOVWF  x61
092C4:  MOVLW  04
092C6:  MOVWF  x63
092C8:  MOVLW  05
092CA:  MOVWF  x65
092CC:  MOVLW  4C
092CE:  MOVWF  x64
092D0:  MOVLW  01
092D2:  MOVWF  x66
092D4:  MOVLB  0
092D6:  CALL   5C1A
....................    result_byte = dust_hdlc_pksend(); 
092DA:  CALL   5EC4
092DE:  MOVFF  01,547
....................    setup_T0_int(T0_250MS); 
092E2:  MOVLW  FC
092E4:  MOVLB  5
092E6:  MOVWF  x65
092E8:  MOVLW  30
092EA:  MOVWF  x64
092EC:  MOVLB  0
092EE:  CALL   356C
....................    while (!TMR0IF && !global_set_get_response && !result_byte); 
092F2:  BTFSC  FF2.2
092F4:  BRA    930E
092F6:  MOVLB  3
092F8:  BTFSS  x58.2
092FA:  BRA    9300
092FC:  MOVLB  0
092FE:  BRA    930E
09300:  MOVLB  5
09302:  MOVF   x47,F
09304:  BTFSS  FD8.2
09306:  BRA    930C
09308:  MOVLB  0
0930A:  BRA    92F2
0930C:  MOVLB  0
....................    if (TMR0IF || result_byte) 
0930E:  BTFSC  FF2.2
09310:  BRA    931A
09312:  MOVLB  5
09314:  MOVF   x47,F
09316:  BZ    9322
09318:  MOVLB  0
....................       return ERR_MTJOINDUTY;  
0931A:  MOVLW  07
0931C:  MOVWF  01
0931E:  BRA    9418
09320:  MOVLB  5
....................     
....................    // set the joinkey and timeout error handling   
....................    global_set_get_response = FALSE; 
09322:  MOVLB  3
09324:  BCF    x58.2
....................    pkgen_setnv_joinkey(joinkey); 
09326:  MOVLW  03
09328:  MOVLB  5
0932A:  MOVWF  x4D
0932C:  MOVLW  15
0932E:  MOVWF  x4E
09330:  MOVLW  04
09332:  MOVWF  x4F
09334:  CLRF   x50
09336:  CLRF   x51
09338:  CLRF   x52
0933A:  CLRF   x53
0933C:  MOVLW  02
0933E:  MOVWF  x54
09340:  MOVLW  05
09342:  MOVWF  x62
09344:  MOVLW  4D
09346:  MOVWF  x61
09348:  MOVLW  08
0934A:  MOVWF  x63
0934C:  CLRF   x65
0934E:  MOVLW  37
09350:  MOVWF  x64
09352:  MOVLW  10
09354:  MOVWF  x66
09356:  MOVLB  0
09358:  CALL   5C1A
....................    result_byte = dust_hdlc_pksend(); 
0935C:  CALL   5EC4
09360:  MOVFF  01,547
....................    setup_T0_int(T0_250MS); 
09364:  MOVLW  FC
09366:  MOVLB  5
09368:  MOVWF  x65
0936A:  MOVLW  30
0936C:  MOVWF  x64
0936E:  MOVLB  0
09370:  CALL   356C
....................    while (!TMR0IF && !global_set_get_response && !result_byte); 
09374:  BTFSC  FF2.2
09376:  BRA    9390
09378:  MOVLB  3
0937A:  BTFSS  x58.2
0937C:  BRA    9382
0937E:  MOVLB  0
09380:  BRA    9390
09382:  MOVLB  5
09384:  MOVF   x47,F
09386:  BTFSS  FD8.2
09388:  BRA    938E
0938A:  MOVLB  0
0938C:  BRA    9374
0938E:  MOVLB  0
....................    if (TMR0IF || result_byte) 
09390:  BTFSC  FF2.2
09392:  BRA    939C
09394:  MOVLB  5
09396:  MOVF   x47,F
09398:  BZ    93A4
0939A:  MOVLB  0
....................       return ERR_MTJOINKEY;   
0939C:  MOVLW  08
0939E:  MOVWF  01
093A0:  BRA    9418
093A2:  MOVLB  5
....................        
....................    // NOTE that we assume that the non-volatile memory of the mote 
....................    //  contains a valid network ID.... 
....................    // The join could fail if blue box not found or if it is trying to join 
....................    //  to a nonvalid network ID 
....................     
....................    // actually send the join command 
....................    global_set_get_response = FALSE; 
093A4:  MOVLB  3
093A6:  BCF    x58.2
....................    pkgen_join(); 
093A8:  MOVLW  06
093AA:  MOVLB  5
093AC:  MOVWF  x55
093AE:  CLRF   x56
093B0:  MOVLW  04
093B2:  MOVWF  x57
093B4:  CLRF   x62
093B6:  CLRF   x61
093B8:  CLRF   x63
093BA:  MOVLW  05
093BC:  MOVWF  x65
093BE:  MOVLW  55
093C0:  MOVWF  x64
093C2:  MOVLW  03
093C4:  MOVWF  x66
093C6:  MOVLB  0
093C8:  CALL   5C1A
....................    result_byte = dust_hdlc_pksend(); 
093CC:  CALL   5EC4
093D0:  MOVFF  01,547
....................    setup_T0_int(T0_250MS); 
093D4:  MOVLW  FC
093D6:  MOVLB  5
093D8:  MOVWF  x65
093DA:  MOVLW  30
093DC:  MOVWF  x64
093DE:  MOVLB  0
093E0:  CALL   356C
....................    while (!TMR0IF && !global_set_get_response && !result_byte); 
093E4:  BTFSC  FF2.2
093E6:  BRA    9400
093E8:  MOVLB  3
093EA:  BTFSS  x58.2
093EC:  BRA    93F2
093EE:  MOVLB  0
093F0:  BRA    9400
093F2:  MOVLB  5
093F4:  MOVF   x47,F
093F6:  BTFSS  FD8.2
093F8:  BRA    93FE
093FA:  MOVLB  0
093FC:  BRA    93E4
093FE:  MOVLB  0
....................    if (TMR0IF || result_byte) 
09400:  BTFSC  FF2.2
09402:  BRA    940C
09404:  MOVLB  5
09406:  MOVF   x47,F
09408:  BZ    9414
0940A:  MOVLB  0
....................       return ERR_NETWORK_JOIN_FAIL; 
0940C:  MOVLW  06
0940E:  MOVWF  01
09410:  BRA    9418
09412:  MOVLB  5
....................      
....................    return NO_ERR; 
09414:  MOVLW  00
09416:  MOVWF  01
09418:  MOVLB  0
0941A:  GOTO   A492 (RETURN)
.................... } 
....................  
.................... void mote_state_check(void) 
.................... { 
.................... // Asks mote what it's status is and responds accordingly (including following 
.................... // up on the mote status later) 
.................... // Restarts mote if needed, triggers join/rejoin if needed, and continues to  
.................... // check status until mote is operational 
....................    uint8_t result_byte; 
....................  
....................    // send the mote status package to the mote 
....................    global_set_get_response = FALSE; 
*
08440:  MOVLB  3
08442:  BCF    x58.2
....................    pkgen_get_motestatus(); 
08444:  MOVLW  02
08446:  MOVLB  5
08448:  MOVWF  x48
0844A:  MOVLW  01
0844C:  MOVWF  x49
0844E:  MOVLW  04
08450:  MOVWF  x4A
08452:  MOVLW  0E
08454:  MOVWF  x4B
08456:  CLRF   x62
08458:  CLRF   x61
0845A:  CLRF   x63
0845C:  MOVLW  05
0845E:  MOVWF  x65
08460:  MOVLW  48
08462:  MOVWF  x64
08464:  MOVLW  04
08466:  MOVWF  x66
08468:  MOVLB  0
0846A:  CALL   5C1A
....................    result_byte = dust_hdlc_pksend();                                               
0846E:  CALL   5EC4
08472:  MOVFF  01,547
....................    setup_T0_int(T0_250MS); 
08476:  MOVLW  FC
08478:  MOVLB  5
0847A:  MOVWF  x65
0847C:  MOVLW  30
0847E:  MOVWF  x64
08480:  MOVLB  0
08482:  CALL   356C
....................    while (!TMR0IF && !global_set_get_response && !result_byte); 
08486:  BTFSC  FF2.2
08488:  BRA    84A2
0848A:  MOVLB  3
0848C:  BTFSS  x58.2
0848E:  BRA    8494
08490:  MOVLB  0
08492:  BRA    84A2
08494:  MOVLB  5
08496:  MOVF   x47,F
08498:  BTFSS  FD8.2
0849A:  BRA    84A0
0849C:  MOVLB  0
0849E:  BRA    8486
084A0:  MOVLB  0
....................     
....................    // if the mote status request fails, trigger a mote reboot 
....................    if (TMR0IF || result_byte) 
084A2:  BTFSC  FF2.2
084A4:  BRA    84AE
084A6:  MOVLB  5
084A8:  MOVF   x47,F
084AA:  BZ    8504
084AC:  MOVLB  0
....................    { 
....................       PUSH_PRIORITY_QUEUE_MACRO(RESET_MOTE); 
084AE:  BCF    F7A.1
084B0:  MOVLW  11
084B2:  MOVLB  5
084B4:  MOVWF  x50
084B6:  MOVLB  0
084B8:  CALL   43F2
084BC:  BSF    F7A.1
....................       PUSH_TIME_QUEUE_MACRO((global_rtc_time + 10), CHECK_MOTE_STATE) 
084BE:  BCF    F7A.1
084C0:  MOVLW  0A
084C2:  ADDWF  x85,W
084C4:  MOVLB  5
084C6:  MOVWF  x4C
084C8:  MOVLW  00
084CA:  MOVLB  0
084CC:  ADDWFC x86,W
084CE:  MOVLB  5
084D0:  MOVWF  x4D
084D2:  MOVLW  00
084D4:  MOVLB  0
084D6:  ADDWFC x87,W
084D8:  MOVLB  5
084DA:  MOVWF  x4E
084DC:  MOVLW  00
084DE:  MOVLB  0
084E0:  ADDWFC x88,W
084E2:  MOVLB  5
084E4:  MOVWF  x4F
084E6:  MOVWF  x55
084E8:  MOVFF  54E,554
084EC:  MOVFF  54D,553
084F0:  MOVFF  54C,552
084F4:  MOVLW  B4
084F6:  MOVWF  x56
084F8:  MOVLB  0
084FA:  CALL   414A
084FE:  BSF    F7A.1
....................    } 
08500:  BRA    8790
08502:  MOVLB  5
....................    // if it has been more than MOTE_NETWORK_SHUTDOWN_TIMEOUT seconds since the mote  
....................    //    returned an operational state, and the mote is in the SYSTEM_RUN state (not looking for a network) 
....................    else if (((global_rtc_time - global_last_connected_time) > MOTE_NETWORK_SHUTDOWN_TIMEOUT) && \ 
....................       (global_system_state == SYSTEM_RUN))    
08504:  MOVF   47,W
08506:  MOVLB  0
08508:  SUBWF  x85,W
0850A:  MOVLB  5
0850C:  MOVWF  x4C
0850E:  MOVF   48,W
08510:  MOVLB  0
08512:  SUBWFB x86,W
08514:  MOVLB  5
08516:  MOVWF  x4D
08518:  MOVF   49,W
0851A:  MOVLB  0
0851C:  SUBWFB x87,W
0851E:  MOVLB  5
08520:  MOVWF  x4E
08522:  MOVF   4A,W
08524:  MOVLB  0
08526:  SUBWFB x88,W
08528:  MOVLB  5
0852A:  MOVWF  x4F
0852C:  MOVF   x4F,F
0852E:  BNZ   8542
08530:  MOVF   x4E,F
08532:  BNZ   8542
08534:  MOVF   x1E,W
08536:  SUBWF  x4D,W
08538:  BNC   85A2
0853A:  BNZ   8542
0853C:  MOVF   x4C,W
0853E:  SUBWF  x1D,W
08540:  BC    85A2
08542:  MOVLB  4
08544:  MOVF   xFD,W
08546:  SUBLW  02
08548:  BTFSC  FD8.2
0854A:  BRA    8550
0854C:  MOVLB  5
0854E:  BRA    85A2
....................    { 
....................          // set the shutdown cause and schedule a shutdown 10 seconds later 
....................          global_shutdown_cause = ERR_NO_NETWORK_TIMEOUT; 
08550:  MOVLW  0D
08552:  MOVWF  4D
....................          PUSH_PRIORITY_QUEUE(OPEN_VALVE_UNKNOWN_STATE);   
08554:  MOVLW  3E
08556:  MOVLB  5
08558:  MOVWF  x50
0855A:  MOVLB  0
0855C:  CALL   43F2
....................          PUSH_TIME_QUEUE(global_rtc_time + 10, SHUTDOWN_SYSTEM);    
08560:  MOVLW  0A
08562:  ADDWF  x85,W
08564:  MOVLB  5
08566:  MOVWF  x4C
08568:  MOVLW  00
0856A:  MOVLB  0
0856C:  ADDWFC x86,W
0856E:  MOVLB  5
08570:  MOVWF  x4D
08572:  MOVLW  00
08574:  MOVLB  0
08576:  ADDWFC x87,W
08578:  MOVLB  5
0857A:  MOVWF  x4E
0857C:  MOVLW  00
0857E:  MOVLB  0
08580:  ADDWFC x88,W
08582:  MOVLB  5
08584:  MOVWF  x4F
08586:  MOVWF  x55
08588:  MOVFF  54E,554
0858C:  MOVFF  54D,553
08590:  MOVFF  54C,552
08594:  MOVLW  F1
08596:  MOVWF  x56
08598:  MOVLB  0
0859A:  CALL   414A
....................    } 
0859E:  BRA    8790
085A0:  MOVLB  5
....................     
....................    // if mote is idle or disconnected, initiate a join and check on mote later 
....................    else if ((global_mote_state == MOTESTATE_IDLE) ||                          \ 
....................       (global_mote_state == MOTESTATE_DISCONNECTED))   
085A2:  MOVLB  4
085A4:  DECFSZ xFC,W
085A6:  BRA    85AA
085A8:  BRA    85B0
085AA:  MOVF   xFC,W
085AC:  SUBLW  06
085AE:  BNZ   8606
....................    { 
....................       PUSH_PRIORITY_QUEUE_MACRO(INIT_JOIN); 
085B0:  BCF    F7A.1
085B2:  MOVLW  B3
085B4:  MOVLB  5
085B6:  MOVWF  x50
085B8:  MOVLB  0
085BA:  CALL   43F2
085BE:  BSF    F7A.1
....................       PUSH_TIME_QUEUE_MACRO((global_rtc_time + 10), CHECK_MOTE_STATE) 
085C0:  BCF    F7A.1
085C2:  MOVLW  0A
085C4:  ADDWF  x85,W
085C6:  MOVLB  5
085C8:  MOVWF  x4C
085CA:  MOVLW  00
085CC:  MOVLB  0
085CE:  ADDWFC x86,W
085D0:  MOVLB  5
085D2:  MOVWF  x4D
085D4:  MOVLW  00
085D6:  MOVLB  0
085D8:  ADDWFC x87,W
085DA:  MOVLB  5
085DC:  MOVWF  x4E
085DE:  MOVLW  00
085E0:  MOVLB  0
085E2:  ADDWFC x88,W
085E4:  MOVLB  5
085E6:  MOVWF  x4F
085E8:  MOVWF  x55
085EA:  MOVFF  54E,554
085EE:  MOVFF  54D,553
085F2:  MOVFF  54C,552
085F6:  MOVLW  B4
085F8:  MOVWF  x56
085FA:  MOVLB  0
085FC:  CALL   414A
08600:  BSF    F7A.1
.................... //      LCD_place_char('D',1,15);     
....................    }                                                          
08602:  BRA    8790
08604:  MOVLB  4
....................     
....................    // if mote is in one of these odd/unwanted modes, trigger reset 
....................    // and a status check (to initiate a join) in the future 
....................    else if ((global_mote_state == MOTESTATE_RADIOTEST) ||                     \ 
....................       (global_mote_state == MOTESTATE_UNKNOWN))                      
08606:  MOVF   xFC,W
08608:  SUBLW  07
0860A:  BZ    8610
0860C:  INCFSZ xFC,W
0860E:  BRA    8666
....................    {    
....................       PUSH_PRIORITY_QUEUE_MACRO(RESET_MOTE); 
08610:  BCF    F7A.1
08612:  MOVLW  11
08614:  MOVLB  5
08616:  MOVWF  x50
08618:  MOVLB  0
0861A:  CALL   43F2
0861E:  BSF    F7A.1
....................       PUSH_TIME_QUEUE_MACRO((global_rtc_time + 10), CHECK_MOTE_STATE) 
08620:  BCF    F7A.1
08622:  MOVLW  0A
08624:  ADDWF  x85,W
08626:  MOVLB  5
08628:  MOVWF  x4C
0862A:  MOVLW  00
0862C:  MOVLB  0
0862E:  ADDWFC x86,W
08630:  MOVLB  5
08632:  MOVWF  x4D
08634:  MOVLW  00
08636:  MOVLB  0
08638:  ADDWFC x87,W
0863A:  MOVLB  5
0863C:  MOVWF  x4E
0863E:  MOVLW  00
08640:  MOVLB  0
08642:  ADDWFC x88,W
08644:  MOVLB  5
08646:  MOVWF  x4F
08648:  MOVWF  x55
0864A:  MOVFF  54E,554
0864E:  MOVFF  54D,553
08652:  MOVFF  54C,552
08656:  MOVLW  B4
08658:  MOVWF  x56
0865A:  MOVLB  0
0865C:  CALL   414A
08660:  BSF    F7A.1
.................... //      LCD_place_char('U',1,15); 
....................    } 
08662:  BRA    8790
08664:  MOVLB  4
....................     
....................    // if mote is in promiscuous listen mode but the system state is not  
....................    //    searching for the network, restart as it's unwanted. 
....................    else if ((global_mote_state == MOTESTATE_PROMISCUOUS) &&                   \ 
....................       (!(global_system_state == SYSTEM_SEARCHING_FOR_NETWORK))) 
08666:  MOVF   xFC,W
08668:  SUBLW  08
0866A:  BNZ   86C8
0866C:  MOVF   xFD,W
0866E:  SUBLW  20
08670:  BZ    86C8
....................    {                                                     
....................       PUSH_PRIORITY_QUEUE_MACRO(RESET_MOTE); 
08672:  BCF    F7A.1
08674:  MOVLW  11
08676:  MOVLB  5
08678:  MOVWF  x50
0867A:  MOVLB  0
0867C:  CALL   43F2
08680:  BSF    F7A.1
....................       PUSH_TIME_QUEUE_MACRO((global_rtc_time + 10), CHECK_MOTE_STATE) 
08682:  BCF    F7A.1
08684:  MOVLW  0A
08686:  ADDWF  x85,W
08688:  MOVLB  5
0868A:  MOVWF  x4C
0868C:  MOVLW  00
0868E:  MOVLB  0
08690:  ADDWFC x86,W
08692:  MOVLB  5
08694:  MOVWF  x4D
08696:  MOVLW  00
08698:  MOVLB  0
0869A:  ADDWFC x87,W
0869C:  MOVLB  5
0869E:  MOVWF  x4E
086A0:  MOVLW  00
086A2:  MOVLB  0
086A4:  ADDWFC x88,W
086A6:  MOVLB  5
086A8:  MOVWF  x4F
086AA:  MOVWF  x55
086AC:  MOVFF  54E,554
086B0:  MOVFF  54D,553
086B4:  MOVFF  54C,552
086B8:  MOVLW  B4
086BA:  MOVWF  x56
086BC:  MOVLB  0
086BE:  CALL   414A
086C2:  BSF    F7A.1
.................... //      LCD_place_char('N',1,15); 
....................    } 
086C4:  BRA    8790
086C6:  MOVLB  4
....................     
....................    // if the mote is booting or initiating a join, check up on it later 
....................    else if ((global_mote_state == MOTESTATE_INIT) ||                          \ 
....................       (global_mote_state == MOTESTATE_SEARCHING) ||                           \ 
....................       (global_mote_state == MOTESTATE_NEGOTIATING) ||                         \ 
....................       (global_mote_state == MOTESTATE_CONNECTED)) 
086C8:  MOVF   xFC,F
086CA:  BZ    86DE
086CC:  MOVF   xFC,W
086CE:  SUBLW  02
086D0:  BZ    86DE
086D2:  MOVF   xFC,W
086D4:  SUBLW  03
086D6:  BZ    86DE
086D8:  MOVF   xFC,W
086DA:  SUBLW  04
086DC:  BNZ   8726
....................    {                                                                                
....................       PUSH_TIME_QUEUE_MACRO((global_rtc_time + 10), CHECK_MOTE_STATE)   
086DE:  BCF    F7A.1
086E0:  MOVLW  0A
086E2:  MOVLB  0
086E4:  ADDWF  x85,W
086E6:  MOVLB  5
086E8:  MOVWF  x4C
086EA:  MOVLW  00
086EC:  MOVLB  0
086EE:  ADDWFC x86,W
086F0:  MOVLB  5
086F2:  MOVWF  x4D
086F4:  MOVLW  00
086F6:  MOVLB  0
086F8:  ADDWFC x87,W
086FA:  MOVLB  5
086FC:  MOVWF  x4E
086FE:  MOVLW  00
08700:  MOVLB  0
08702:  ADDWFC x88,W
08704:  MOVLB  5
08706:  MOVWF  x4F
08708:  MOVWF  x55
0870A:  MOVFF  54E,554
0870E:  MOVFF  54D,553
08712:  MOVFF  54C,552
08716:  MOVLW  B4
08718:  MOVWF  x56
0871A:  MOVLB  0
0871C:  CALL   414A
08720:  BSF    F7A.1
.................... //      LCD_place_char('I',1,15);  
....................    } 
08722:  BRA    8790
08724:  MOVLB  4
....................     
....................    // mote is operational, do nothing 
....................    else if (global_mote_state == MOTESTATE_OPERATIONAL) 
08726:  MOVF   xFC,W
08728:  SUBLW  05
0872A:  BNZ   873E
....................    {  
....................       global_last_connected_time = global_rtc_time; 
0872C:  MOVFF  88,4A
08730:  MOVFF  87,49
08734:  MOVFF  86,48
08738:  MOVFF  85,47
.................... //      LCD_place_char('O',1,15);      
....................       break; 
....................    } 
0873C:  BRA    8792
....................     
....................    // incase there is some other crazy mote status, restart mote and retry 
....................    else 
....................    { 
....................       PUSH_PRIORITY_QUEUE_MACRO(RESET_MOTE); 
0873E:  BCF    F7A.1
08740:  MOVLW  11
08742:  MOVLB  5
08744:  MOVWF  x50
08746:  MOVLB  0
08748:  CALL   43F2
0874C:  BSF    F7A.1
....................       PUSH_TIME_QUEUE_MACRO((global_rtc_time + 10), CHECK_MOTE_STATE) 
0874E:  BCF    F7A.1
08750:  MOVLW  0A
08752:  ADDWF  x85,W
08754:  MOVLB  5
08756:  MOVWF  x4C
08758:  MOVLW  00
0875A:  MOVLB  0
0875C:  ADDWFC x86,W
0875E:  MOVLB  5
08760:  MOVWF  x4D
08762:  MOVLW  00
08764:  MOVLB  0
08766:  ADDWFC x87,W
08768:  MOVLB  5
0876A:  MOVWF  x4E
0876C:  MOVLW  00
0876E:  MOVLB  0
08770:  ADDWFC x88,W
08772:  MOVLB  5
08774:  MOVWF  x4F
08776:  MOVWF  x55
08778:  MOVFF  54E,554
0877C:  MOVFF  54D,553
08780:  MOVFF  54C,552
08784:  MOVLW  B4
08786:  MOVWF  x56
08788:  MOVLB  0
0878A:  CALL   414A
0878E:  BSF    F7A.1
08790:  MOVLB  4
....................    } 
....................    break; 
08792:  MOVLB  0
08794:  GOTO   A492 (RETURN)
.................... } 
....................  
.................... void mote_info_check(void) 
.................... // queries the mote to send back information including mac address (serial no), 
.................... //  hardware model/rev, API version, etc. 
.................... { 
....................    uint8_t result_byte; 
....................     
....................    // if the mote is not enabled/ready exit! 
....................    if (global_dust_enabled == FALSE) return; 
08798:  BTFSS  x9F.6
0879A:  BRA    881E
....................        
....................    // set the response flag 
....................    global_set_get_response = FALSE; 
0879C:  MOVLB  3
0879E:  BCF    x58.2
....................    // generate the message and send the message 
....................     
....................    pkgen_get_moteinfo(); 
087A0:  MOVLW  02
087A2:  MOVLB  5
087A4:  MOVWF  x48
087A6:  MOVLW  01
087A8:  MOVWF  x49
087AA:  MOVLW  04
087AC:  MOVWF  x4A
087AE:  MOVLW  0C
087B0:  MOVWF  x4B
087B2:  CLRF   x62
087B4:  CLRF   x61
087B6:  CLRF   x63
087B8:  MOVLW  05
087BA:  MOVWF  x65
087BC:  MOVLW  48
087BE:  MOVWF  x64
087C0:  MOVLW  04
087C2:  MOVWF  x66
087C4:  MOVLB  0
087C6:  CALL   5C1A
....................    result_byte = dust_hdlc_pksend(); 
087CA:  CALL   5EC4
087CE:  MOVFF  01,547
....................    // set message timeout 
....................    setup_T0_int(T0_250MS); 
087D2:  MOVLW  FC
087D4:  MOVLB  5
087D6:  MOVWF  x65
087D8:  MOVLW  30
087DA:  MOVWF  x64
087DC:  MOVLB  0
087DE:  CALL   356C
....................    while (!TMR0IF && !global_set_get_response && !result_byte); 
087E2:  BTFSC  FF2.2
087E4:  BRA    87FE
087E6:  MOVLB  3
087E8:  BTFSS  x58.2
087EA:  BRA    87F0
087EC:  MOVLB  0
087EE:  BRA    87FE
087F0:  MOVLB  5
087F2:  MOVF   x47,F
087F4:  BTFSS  FD8.2
087F6:  BRA    87FC
087F8:  MOVLB  0
087FA:  BRA    87E2
087FC:  MOVLB  0
....................    // if the message fails, send an error message (kinda pointless though) 
....................    if (TMR0IF || result_byte) 
087FE:  BTFSC  FF2.2
08800:  BRA    880A
08802:  MOVLB  5
08804:  MOVF   x47,F
08806:  BZ    8820
08808:  MOVLB  0
....................    { 
....................       global_error_message_bitfield |= ERR_MOTE_UNRESPONSIVE; 
0880A:  MOVLB  4
0880C:  BSF    xF0.2
....................       PUSH_MESSAGE_QUEUE_MACRO(MSG_MOTE_ERROR_MSG); 
0880E:  BCF    F7A.1
08810:  MOVLW  A0
08812:  MOVLB  5
08814:  MOVWF  x50
08816:  MOVLB  0
08818:  CALL   4D00
0881C:  BSF    F7A.1
0881E:  MOVLB  5
....................    } 
08820:  MOVLB  0
08822:  GOTO   A492 (RETURN)
....................     
.................... } 
....................  
.................... void mote_temp_check(void) 
.................... // queries the mote to send the temperature back and stores it in the global 
.................... //    variable global_mote_temperature  
.................... { 
....................    uint8_t result_byte; 
....................     
....................    // if the mote is not enabled/ready exit! 
....................    if (global_dust_enabled == FALSE) return; 
*
08A60:  BTFSS  x9F.6
08A62:  BRA    8B8A
....................     
....................    // set the response flag 
....................    global_set_get_response = FALSE; 
08A64:  MOVLB  3
08A66:  BCF    x58.2
....................    // generate the message and send the message 
....................    pkgen_get_charge(); 
08A68:  MOVLW  02
08A6A:  MOVLB  5
08A6C:  MOVWF  x48
08A6E:  MOVLW  01
08A70:  MOVWF  x49
08A72:  MOVLW  04
08A74:  MOVWF  x4A
08A76:  MOVLW  10
08A78:  MOVWF  x4B
08A7A:  CLRF   x62
08A7C:  CLRF   x61
08A7E:  CLRF   x63
08A80:  MOVLW  05
08A82:  MOVWF  x65
08A84:  MOVLW  48
08A86:  MOVWF  x64
08A88:  MOVLW  04
08A8A:  MOVWF  x66
08A8C:  MOVLB  0
08A8E:  CALL   5C1A
....................    result_byte = dust_hdlc_pksend(); 
08A92:  CALL   5EC4
08A96:  MOVFF  01,547
....................    // set message timeout 
....................    setup_T0_int(T0_250MS); 
08A9A:  MOVLW  FC
08A9C:  MOVLB  5
08A9E:  MOVWF  x65
08AA0:  MOVLW  30
08AA2:  MOVWF  x64
08AA4:  MOVLB  0
08AA6:  CALL   356C
....................    while (!TMR0IF && !global_set_get_response && !result_byte); 
08AAA:  BTFSC  FF2.2
08AAC:  BRA    8AC6
08AAE:  MOVLB  3
08AB0:  BTFSS  x58.2
08AB2:  BRA    8AB8
08AB4:  MOVLB  0
08AB6:  BRA    8AC6
08AB8:  MOVLB  5
08ABA:  MOVF   x47,F
08ABC:  BTFSS  FD8.2
08ABE:  BRA    8AC4
08AC0:  MOVLB  0
08AC2:  BRA    8AAA
08AC4:  MOVLB  0
....................    // if the message fails, send an error message (kinda pointless though) 
....................    if (TMR0IF || result_byte) 
08AC6:  BTFSC  FF2.2
08AC8:  BRA    8AD2
08ACA:  MOVLB  5
08ACC:  MOVF   x47,F
08ACE:  BZ    8AE8
08AD0:  MOVLB  0
....................    { 
....................       global_error_message_bitfield |= ERR_MOTE_UNRESPONSIVE; 
08AD2:  MOVLB  4
08AD4:  BSF    xF0.2
....................       PUSH_MESSAGE_QUEUE_MACRO(MSG_MOTE_ERROR_MSG); 
08AD6:  BCF    F7A.1
08AD8:  MOVLW  A0
08ADA:  MOVLB  5
08ADC:  MOVWF  x50
08ADE:  MOVLB  0
08AE0:  CALL   4D00
08AE4:  BSF    F7A.1
08AE6:  MOVLB  5
....................    } 
....................     
....................    // if mote temp is outside of operating range, send an error message and queue up a shutdown 
....................    if ((global_mote_temperature < MOTE_MIN_TEMP_SHUTDOWN) || (global_mote_temperature > MOTE_MAX_TEMP_SHUTDOWN)) 
08AE8:  MOVLB  3
08AEA:  MOVF   x65,W
08AEC:  XORLW  80
08AEE:  SUBLW  57
08AF0:  BC    8AFC
08AF2:  BTFSC  x65.7
08AF4:  BRA    8B64
08AF6:  MOVF   x65,W
08AF8:  SUBLW  55
08AFA:  BC    8B64
....................    { 
....................       // set message error bitfield and queue error message 
....................       global_error_message_bitfield |= (ERR_MSG_MOTE_TEMP_OUT_OF_RANGE | ERR_MSG_MOTE_GOING_TO_DEEP_SLEEP); 
08AFC:  MOVLB  4
08AFE:  BSF    xF0.6
08B00:  BSF    xF3.7
....................       PUSH_MESSAGE_QUEUE_MACRO(MSG_MOTE_ERROR_MSG); 
08B02:  BCF    F7A.1
08B04:  MOVLW  A0
08B06:  MOVLB  5
08B08:  MOVWF  x50
08B0A:  MOVLB  0
08B0C:  CALL   4D00
08B10:  BSF    F7A.1
....................        
....................       // set the shutdown cause and schedule a shutdown 10 seconds later 
....................       PUSH_PRIORITY_QUEUE(OPEN_VALVE_UNKNOWN_STATE);   
08B12:  MOVLW  3E
08B14:  MOVLB  5
08B16:  MOVWF  x50
08B18:  MOVLB  0
08B1A:  CALL   43F2
....................       global_shutdown_cause = ERR_MOTE_OUT_OF_TEMP_RANGE; 
08B1E:  MOVLW  05
08B20:  MOVWF  4D
....................       PUSH_TIME_QUEUE(global_rtc_time + 10, SHUTDOWN_SYSTEM); 
08B22:  MOVLW  0A
08B24:  ADDWF  x85,W
08B26:  MOVLB  5
08B28:  MOVWF  x4C
08B2A:  MOVLW  00
08B2C:  MOVLB  0
08B2E:  ADDWFC x86,W
08B30:  MOVLB  5
08B32:  MOVWF  x4D
08B34:  MOVLW  00
08B36:  MOVLB  0
08B38:  ADDWFC x87,W
08B3A:  MOVLB  5
08B3C:  MOVWF  x4E
08B3E:  MOVLW  00
08B40:  MOVLB  0
08B42:  ADDWFC x88,W
08B44:  MOVLB  5
08B46:  MOVWF  x4F
08B48:  MOVWF  x55
08B4A:  MOVFF  54E,554
08B4E:  MOVFF  54D,553
08B52:  MOVFF  54C,552
08B56:  MOVLW  F1
08B58:  MOVWF  x56
08B5A:  MOVLB  0
08B5C:  CALL   414A
....................    } 
08B60:  BRA    8B8A
08B62:  MOVLB  3
....................       // if mote temp is ALMOST outside of operating range, send an error message 
....................    else if ((global_mote_temperature < MOTE_MIN_TEMP_WARNING) || (global_mote_temperature > MOTE_MAX_TEMP_WARNING)) 
08B64:  MOVF   x65,W
08B66:  XORLW  80
08B68:  SUBLW  5C
08B6A:  BC    8B76
08B6C:  BTFSC  x65.7
08B6E:  BRA    8B8C
08B70:  MOVF   x65,W
08B72:  SUBLW  50
08B74:  BC    8B8C
....................    { 
....................       // set message error bitfield and queue error message 
....................       global_error_message_bitfield |= (ERR_MSG_MOTE_TEMP_OUT_OF_RANGE); 
08B76:  MOVLB  4
08B78:  BSF    xF0.6
....................       PUSH_MESSAGE_QUEUE_MACRO(MSG_MOTE_ERROR_MSG); 
08B7A:  BCF    F7A.1
08B7C:  MOVLW  A0
08B7E:  MOVLB  5
08B80:  MOVWF  x50
08B82:  MOVLB  0
08B84:  CALL   4D00
08B88:  BSF    F7A.1
08B8A:  MOVLB  3
....................    } 
08B8C:  MOVLB  0
08B8E:  GOTO   A492 (RETURN)
....................        
.................... } 
....................  
.................... void mote_time_update(void) 
.................... // queries the mote to for the utc time and update the micro's utc time 
.................... { 
....................    uint8_t result_byte; 
....................     
....................    // if the mote is not enabled/ready exit! 
....................    if (global_dust_enabled == FALSE) return; 
*
08826:  BTFSS  x9F.6
08828:  BRA    88AC
....................     
....................    // set the response flag 
....................    global_set_get_response = FALSE; 
0882A:  MOVLB  3
0882C:  BCF    x58.2
....................    // generate the message and send the message 
....................    pkgen_get_time(); 
0882E:  MOVLW  02
08830:  MOVLB  5
08832:  MOVWF  x48
08834:  MOVLW  01
08836:  MOVWF  x49
08838:  MOVLW  04
0883A:  MOVWF  x4A
0883C:  MOVLW  0F
0883E:  MOVWF  x4B
08840:  CLRF   x62
08842:  CLRF   x61
08844:  CLRF   x63
08846:  MOVLW  05
08848:  MOVWF  x65
0884A:  MOVLW  48
0884C:  MOVWF  x64
0884E:  MOVLW  04
08850:  MOVWF  x66
08852:  MOVLB  0
08854:  CALL   5C1A
....................    result_byte = dust_hdlc_pksend(); 
08858:  CALL   5EC4
0885C:  MOVFF  01,547
....................    // set message timeout 
....................    setup_T0_int(T0_250MS); 
08860:  MOVLW  FC
08862:  MOVLB  5
08864:  MOVWF  x65
08866:  MOVLW  30
08868:  MOVWF  x64
0886A:  MOVLB  0
0886C:  CALL   356C
....................    while (!TMR0IF && !global_set_get_response && !result_byte); 
08870:  BTFSC  FF2.2
08872:  BRA    888C
08874:  MOVLB  3
08876:  BTFSS  x58.2
08878:  BRA    887E
0887A:  MOVLB  0
0887C:  BRA    888C
0887E:  MOVLB  5
08880:  MOVF   x47,F
08882:  BTFSS  FD8.2
08884:  BRA    888A
08886:  MOVLB  0
08888:  BRA    8870
0888A:  MOVLB  0
....................    // if the message fails, send an error message (kinda pointless though) 
....................    if (TMR0IF || result_byte) 
0888C:  BTFSC  FF2.2
0888E:  BRA    8898
08890:  MOVLB  5
08892:  MOVF   x47,F
08894:  BZ    88AE
08896:  MOVLB  0
....................    { 
....................       global_error_message_bitfield |= ERR_MOTE_UNRESPONSIVE; 
08898:  MOVLB  4
0889A:  BSF    xF0.2
....................       PUSH_MESSAGE_QUEUE_MACRO(MSG_MOTE_ERROR_MSG); 
0889C:  BCF    F7A.1
0889E:  MOVLW  A0
088A0:  MOVLB  5
088A2:  MOVWF  x50
088A4:  MOVLB  0
088A6:  CALL   4D00
088AA:  BSF    F7A.1
088AC:  MOVLB  5
....................    }      
088AE:  MOVLB  0
088B0:  GOTO   A492 (RETURN)
.................... } 
....................  
.................... void get_mote_net_info(void) 
.................... // queries the mote to get the macaddress 
.................... { 
....................    uint8_t result_byte; 
....................     
....................    // if the mote is not enabled/ready exit! 
....................    if (global_dust_enabled == FALSE) return; 
088B4:  BTFSS  x9F.6
088B6:  BRA    893A
....................     
....................    // set the response flag 
....................    global_set_get_response = FALSE; 
088B8:  MOVLB  3
088BA:  BCF    x58.2
....................    // generate the message and send the message 
....................    pkgen_get_networkinfo(); 
088BC:  MOVLW  02
088BE:  MOVLB  5
088C0:  MOVWF  x48
088C2:  MOVLW  01
088C4:  MOVWF  x49
088C6:  MOVLW  04
088C8:  MOVWF  x4A
088CA:  MOVLW  0D
088CC:  MOVWF  x4B
088CE:  CLRF   x62
088D0:  CLRF   x61
088D2:  CLRF   x63
088D4:  MOVLW  05
088D6:  MOVWF  x65
088D8:  MOVLW  48
088DA:  MOVWF  x64
088DC:  MOVLW  04
088DE:  MOVWF  x66
088E0:  MOVLB  0
088E2:  CALL   5C1A
....................    result_byte = dust_hdlc_pksend(); 
088E6:  CALL   5EC4
088EA:  MOVFF  01,547
....................    // set message timeout 
....................    setup_T0_int(T0_250MS); 
088EE:  MOVLW  FC
088F0:  MOVLB  5
088F2:  MOVWF  x65
088F4:  MOVLW  30
088F6:  MOVWF  x64
088F8:  MOVLB  0
088FA:  CALL   356C
....................    while (!TMR0IF && !global_set_get_response && !result_byte); 
088FE:  BTFSC  FF2.2
08900:  BRA    891A
08902:  MOVLB  3
08904:  BTFSS  x58.2
08906:  BRA    890C
08908:  MOVLB  0
0890A:  BRA    891A
0890C:  MOVLB  5
0890E:  MOVF   x47,F
08910:  BTFSS  FD8.2
08912:  BRA    8918
08914:  MOVLB  0
08916:  BRA    88FE
08918:  MOVLB  0
....................    // if the message fails, send an error message (kinda pointless though) 
....................    if (TMR0IF || result_byte) 
0891A:  BTFSC  FF2.2
0891C:  BRA    8926
0891E:  MOVLB  5
08920:  MOVF   x47,F
08922:  BZ    893C
08924:  MOVLB  0
....................    { 
....................       global_error_message_bitfield |= ERR_MOTE_UNRESPONSIVE; 
08926:  MOVLB  4
08928:  BSF    xF0.2
....................       PUSH_MESSAGE_QUEUE_MACRO(MSG_MOTE_ERROR_MSG); 
0892A:  BCF    F7A.1
0892C:  MOVLW  A0
0892E:  MOVLB  5
08930:  MOVWF  x50
08932:  MOVLB  0
08934:  CALL   4D00
08938:  BSF    F7A.1
0893A:  MOVLB  5
....................    }      
0893C:  MOVLB  0
0893E:  GOTO   A492 (RETURN)
.................... } 
....................  
.................... void init_msgSEQ(void) 
.................... { 
....................    // uses the battery voltage and vgen to seed the random number generator 
....................    srand((get_vbatt(0)<<16) || get_vgen(0)); 
*
040F4:  MOVLB  5
040F6:  CLRF   x53
040F8:  MOVLB  0
040FA:  RCALL  3F5E
040FC:  MOVFF  02,548
04100:  MOVFF  01,547
04104:  MOVLW  00
04106:  CLRF   03
04108:  IORWF  03,W
0410A:  BNZ   411E
0410C:  MOVLB  5
0410E:  CLRF   x53
04110:  MOVLB  0
04112:  RCALL  3FB8
04114:  MOVF   01,W
04116:  IORWF  02,W
04118:  BNZ   411E
0411A:  MOVLW  00
0411C:  BRA    4120
0411E:  MOVLW  01
04120:  MOVLB  5
04122:  MOVWF  x47
04124:  CLRF   x4B
04126:  CLRF   x4A
04128:  CLRF   x49
0412A:  MOVWF  x48
0412C:  MOVLB  0
0412E:  BRA    401A
....................    mote_msgSEQ = (uint16_t)rand(); 
04130:  BRA    4074
04132:  MOVFF  02,35E
04136:  MOVFF  01,35D
0413A:  GOTO   4140 (RETURN)
.................... } 
....................  
.................... void deal_with_mote_ISR(void) 
*
011E2:  MOVLB  5
011E4:  CLRF   x86
011E6:  BCF    x87.0
011E8:  CLRF   x88
011EA:  CLRF   x89
011EC:  CLRF   x8D
011EE:  CLRF   x8C
011F0:  CLRF   x8B
011F2:  CLRF   x8A
011F4:  CLRF   x91
011F6:  CLRF   x90
011F8:  CLRF   x8F
011FA:  CLRF   x8E
011FC:  CLRF   x95
011FE:  CLRF   x94
01200:  CLRF   x93
01202:  CLRF   x92
01204:  CLRF   x96
.................... { 
....................    uint8_t     i; 
....................     
....................    uint16_t    tmp2u16; 
....................     
....................    uint8_t     cmd_rcvd = 0; 
....................    int1        send_ack = FALSE; 
....................     
....................    uint8_t     response_type = 0; 
....................    uint8_t     len_data_rcvd = 0; 
....................    uint32_t    utc_sec_rcvd = 0; 
....................    uint32_t    utc_usec_rcvd = 0; 
....................    uint32_t    new_events_rcvd = 0; 
....................     
....................    // bytes grabbed by get_dustmsg and sent to pkdecode 
....................    uint8_t      num_of_bytes_rcvd_from_mote = 0; 
....................  
....................    // Actually grab the message from the mote 
....................    // gets bytes rcvd(global), dust_recive_buffer, some errors 
....................    num_of_bytes_rcvd_from_mote = get_dustmsg_ISR(); 
01206:  MOVLB  0
01208:  GOTO   08F0
0120C:  MOVFF  01,596
....................     
....................    // Add error handling from get_dustmsg_ISR 
....................    // Send NACK? 
....................    
....................    //decodes the message and returns how many bytes were recived 
....................    dust_hdlc_pkdecode_ISR(num_of_bytes_rcvd_from_mote); 
01210:  MOVFF  596,59B
01214:  BRA    0A7A
....................     
....................    // Add error handling from pkdecode 
....................    // Send NACK? 
....................     
....................    // get the command type 
....................    cmd_rcvd = bytes_from_mote.dust_rcvd[0];         
01216:  MOVFF  D1,586
....................  
....................    // set these for CMD_TIME, _SERVICE, _EVENT, and _DATA 
....................    //   prefix_x[0] = cmd_rcvd; 
....................    //   prefix_x[1] = 0x00; 
....................    flags_rcvd = bytes_from_mote.dust_rcvd[2]; 
0121A:  MOVFF  D3,35A
....................  
....................    response_type = RC_OK; 
0121E:  MOVLB  5
01220:  CLRF   x88
....................     
....................    //  
....................    if (cmd_rcvd == CMD_SET || cmd_rcvd == CMD_GET || \ 
....................        cmd_rcvd == CMD_SETNV || cmd_rcvd == CMD_GETNV || \ 
....................        cmd_rcvd == CMD_SEND || cmd_rcvd == CMD_JOIN || \ 
....................        cmd_rcvd == CMD_DISCONNECT || cmd_rcvd == CMD_RESET || \ 
....................        cmd_rcvd == CMD_SLEEP || cmd_rcvd == CMD_TESTRADIOTX || \ 
....................        cmd_rcvd == CMD_TESTRADIORX || cmd_rcvd == CMD_CLEARNV || \ 
....................        cmd_rcvd == CMD_SEARCH) 
01222:  DECFSZ x86,W
01224:  BRA    1228
01226:  BRA    1270
01228:  MOVF   x86,W
0122A:  SUBLW  02
0122C:  BZ    1270
0122E:  MOVF   x86,W
01230:  SUBLW  03
01232:  BZ    1270
01234:  MOVF   x86,W
01236:  SUBLW  04
01238:  BZ    1270
0123A:  MOVF   x86,W
0123C:  SUBLW  05
0123E:  BZ    1270
01240:  MOVF   x86,W
01242:  SUBLW  06
01244:  BZ    1270
01246:  MOVF   x86,W
01248:  SUBLW  07
0124A:  BZ    1270
0124C:  MOVF   x86,W
0124E:  SUBLW  08
01250:  BZ    1270
01252:  MOVF   x86,W
01254:  SUBLW  09
01256:  BZ    1270
01258:  MOVF   x86,W
0125A:  SUBLW  0B
0125C:  BZ    1270
0125E:  MOVF   x86,W
01260:  SUBLW  0C
01262:  BZ    1270
01264:  MOVF   x86,W
01266:  SUBLW  10
01268:  BZ    1270
0126A:  MOVF   x86,W
0126C:  SUBLW  11
0126E:  BNZ   1274
....................    { 
....................        // we are hoping that result_rcvd = RC_OK) 
....................        result_rcvd = bytes_from_mote.dust_rcvd[3]; 
01270:  MOVFF  D4,357
....................    }    
....................  
....................    // Determine parameter type and if the response was ok for set and get commands 
....................    if (cmd_rcvd == CMD_SET || cmd_rcvd == CMD_GET || \ 
....................        cmd_rcvd == CMD_SETNV || cmd_rcvd == CMD_GETNV) 
01274:  DECFSZ x86,W
01276:  BRA    127A
01278:  BRA    128C
0127A:  MOVF   x86,W
0127C:  SUBLW  02
0127E:  BZ    128C
01280:  MOVF   x86,W
01282:  SUBLW  03
01284:  BZ    128C
01286:  MOVF   x86,W
01288:  SUBLW  04
0128A:  BNZ   129A
....................    {      
....................        param_type_rcvd = bytes_from_mote.dust_rcvd[4]; 
0128C:  MOVFF  D5,35B
....................        // this eliminates a bunch of flags for one response "ok" flag 
....................        if (result_rcvd == RC_OK) global_set_get_response = TRUE; 
01290:  MOVLB  3
01292:  MOVF   x57,F
01294:  BNZ   1298
01296:  BSF    x58.2
01298:  MOVLB  5
....................    } 
....................     
....................    // Main switch for all types of mote messages 
....................    switch (cmd_rcvd) 
0129A:  MOVF   x86,W
0129C:  XORLW  01
0129E:  MOVLB  0
012A0:  BZ    1308
012A2:  XORLW  03
012A4:  BZ    131A
012A6:  XORLW  01
012A8:  BTFSC  FD8.2
012AA:  BRA    1476
012AC:  XORLW  07
012AE:  BTFSC  FD8.2
012B0:  BRA    1488
012B2:  XORLW  01
012B4:  BTFSC  FD8.2
012B6:  BRA    14EE
012B8:  XORLW  02
012BA:  BTFSC  FD8.2
012BC:  BRA    14EE
012BE:  XORLW  0F
012C0:  BTFSC  FD8.2
012C2:  BRA    14EE
012C4:  XORLW  01
012C6:  BTFSC  FD8.2
012C8:  BRA    14EE
012CA:  XORLW  02
012CC:  BTFSC  FD8.2
012CE:  BRA    14EE
012D0:  XORLW  07
012D2:  BTFSC  FD8.2
012D4:  BRA    14EE
012D6:  XORLW  1C
012D8:  BTFSC  FD8.2
012DA:  BRA    14EE
012DC:  XORLW  01
012DE:  BTFSC  FD8.2
012E0:  BRA    14F0
012E2:  XORLW  17
012E4:  BTFSC  FD8.2
012E6:  BRA    1502
012E8:  XORLW  0B
012EA:  BTFSC  FD8.2
012EC:  BRA    1516
012EE:  XORLW  03
012F0:  BTFSC  FD8.2
012F2:  BRA    155E
012F4:  XORLW  01
012F6:  BTFSC  FD8.2
012F8:  BRA    156A
012FA:  XORLW  1D
012FC:  BTFSC  FD8.2
012FE:  BRA    15D0
01300:  XORLW  93
01302:  BTFSC  FD8.2
01304:  BRA    15FC
01306:  BRA    1658
....................    {   
....................       // receipt of response after a SET command 
....................       case  CMD_SET: 
....................          // byte4 is the param_type for all SET responses 
....................          switch (param_type_rcvd) 
01308:  MOVLB  3
0130A:  MOVF   x5B,W
0130C:  XORLW  06
0130E:  MOVLB  0
01310:  BZ    1318
01312:  XORLW  0E
01314:  BZ    131A
01316:  BRA    131A
....................          {   
....................             case  PARAM_JOINDUTY: 
....................                break; 
01318:  BRA    131A
....................             case  PARAM_SERVICE: 
....................                //    save info, no ack 
....................                //    rem_svc_entries_rcvd = \ 
....................                //    bytes_from_mote.set_service_response.rem_svc_entries; 
....................                break; 
....................             default:           
....................          } 
....................           
....................       // receipt of response after a GET command 
....................       case  CMD_GET: 
....................          // byte4 is the param_type for all GET responses 
....................          switch (param_type_rcvd) 
0131A:  MOVLB  3
0131C:  MOVF   x5B,W
0131E:  XORLW  08
01320:  MOVLB  0
01322:  BZ    133E
01324:  XORLW  04
01326:  BZ    1344
01328:  XORLW  01
0132A:  BZ    1388
0132C:  XORLW  03
0132E:  BZ    13E4
01330:  XORLW  01
01332:  BTFSC  FD8.2
01334:  BRA    142C
01336:  XORLW  1F
01338:  BTFSC  FD8.2
0133A:  BRA    1472
0133C:  BRA    1476
....................          {   
....................             case  PARAM_SERVICE: 
....................                svc_index_rcvd = bytes_from_mote.get_service_response.svc_index; 
0133E:  MOVFF  D6,35C
....................                /* 
....................                svc_state_rcvd = bytes_from_mote.get_service_response.svc_state; 
....................                svc_flags_rcvd = bytes_from_mote.get_service_response.svc_flags; 
....................                app_domain_rcvd = \ 
....................                   bytes_from_mote.get_service_response.app_domain; 
....................                */ 
....................                //destaddr_rcvd = bytes_from_mote.get_service_response.destaddr; 
....................                //time_rcvd = bytes_from_mote.get_service_response.time; 
....................                break; 
01342:  BRA    1476
....................  
....................             case  PARAM_MOTEINFO: 
....................                for (i=0; i<8; i++) 
01344:  MOVLB  5
01346:  CLRF   x83
01348:  MOVF   x83,W
0134A:  SUBLW  07
0134C:  BNC   1384
....................                   serial_number_rcvd[i] = \ 
....................                      bytes_from_mote.get_moteinfo_response.serial_number[i]; 
0134E:  CLRF   03
01350:  MOVF   x83,W
01352:  ADDLW  8F
01354:  MOVWF  01
01356:  MOVLW  00
01358:  ADDWFC 03,F
0135A:  MOVFF  01,59B
0135E:  MOVFF  03,59C
01362:  CLRF   03
01364:  MOVF   x83,W
01366:  ADDLW  D7
01368:  MOVWF  FE9
0136A:  MOVLW  00
0136C:  ADDWFC 03,W
0136E:  MOVWF  FEA
01370:  MOVFF  FEF,59D
01374:  MOVFF  59C,FEA
01378:  MOVFF  01,FE9
0137C:  MOVFF  59D,FEF
01380:  INCF   x83,F
01382:  BRA    1348
....................                    
....................                /* 
....................                api_version_rcvd = \ 
....................                   bytes_from_mote.get_moteinfo_response.api_version; 
....................                hw_model_rcvd = bytes_from_mote.get_moteinfo_response.hw_model; 
....................                hw_version_rcvd = \ 
....................                   bytes_from_mote.get_moteinfo_response.hw_version; 
....................                sw_major_ver_rcvd = \ 
....................                   bytes_from_mote.get_moteinfo_response.sw_major_ver; 
....................                sw_minor_ver_rcvd = \ 
....................                   bytes_from_mote.get_moteinfo_response.sw_minor_ver; 
....................                sw_patch_rcvd = bytes_from_mote.get_moteinfo_response.sw_patch; 
....................                sw_build_rcvd = bytes_from_mote.get_moteinfo_response.sw_build; 
....................                */ 
....................                break; 
01384:  MOVLB  0
01386:  BRA    1476
....................  
....................             case  PARAM_NETWORKINFO: 
....................                for (i=0; i<8; i++) 
01388:  MOVLB  5
0138A:  CLRF   x83
0138C:  MOVF   x83,W
0138E:  SUBLW  07
01390:  BNC   13C8
....................                   macaddr_rcvd[i] = \ 
....................                      bytes_from_mote.get_networkinfo_response.macaddr[i]; 
01392:  CLRF   03
01394:  MOVF   x83,W
01396:  ADDLW  97
01398:  MOVWF  01
0139A:  MOVLW  00
0139C:  ADDWFC 03,F
0139E:  MOVFF  01,59B
013A2:  MOVFF  03,59C
013A6:  CLRF   03
013A8:  MOVF   x83,W
013AA:  ADDLW  D6
013AC:  MOVWF  FE9
013AE:  MOVLW  00
013B0:  ADDWFC 03,W
013B2:  MOVWF  FEA
013B4:  MOVFF  FEF,59D
013B8:  MOVFF  59C,FEA
013BC:  MOVFF  01,FE9
013C0:  MOVFF  59D,FEF
013C4:  INCF   x83,F
013C6:  BRA    138C
....................                mote_id_rcvd = bytes_from_mote.get_networkinfo_response.mote_id; 
013C8:  MOVFF  DF,362
013CC:  MOVFF  DE,361
....................                tmp2u16 = bytes_from_mote.get_networkinfo_response.network_id; 
013D0:  MOVFF  E1,585
013D4:  MOVFF  E0,584
....................                network_id_rcvd = make16(make8(tmp2u16,0),make8(tmp2u16,1)); 
013D8:  MOVFF  584,360
013DC:  MOVFF  585,35F
....................  
....................                break; 
013E0:  MOVLB  0
013E2:  BRA    1476
....................  
....................             case  PARAM_MOTESTATUS: 
....................                global_mote_state = bytes_from_mote.get_motestatus_response.mote_state; 
013E4:  MOVFF  D6,4FC
....................                 
....................                // this is where I decide if the mote is alive or not 
....................                global_dust_enabled = TRUE; 
013E8:  BSF    x9F.6
....................                 
....................                // If the mote isn't fully connected (operational) set the global 
....................                //    dust operational bit to false 
....................                if (global_mote_state != MOTESTATE_OPERATIONAL) 
013EA:  MOVLB  4
013EC:  MOVF   xFC,W
013EE:  SUBLW  05
013F0:  BZ    13FA
....................                { 
....................                   global_dust_operational = FALSE; 
013F2:  MOVLB  0
013F4:  BCF    x9F.7
....................                } 
013F6:  BRA    142A
013F8:  MOVLB  4
....................                // If the mote is fully connected... 
....................                else  
....................                { 
....................                   // and it wasn't before... 
....................                   if (global_dust_operational == FALSE) 
013FA:  MOVLB  0
013FC:  BTFSC  x9F.7
013FE:  BRA    142A
....................                   { 
....................   
....................                      // set it to be connected and send a join message! 
....................                      global_dust_operational = TRUE; 
01400:  BSF    x9F.7
....................                      PUSH_MESSAGE_QUEUE_ISR_MACRO(MSG_MOTE_JOIN_MSG); 
01402:  BCF    F7A.1
01404:  MOVLW  94
01406:  MOVLB  5
01408:  MOVWF  x9B
0140A:  MOVLB  0
0140C:  CALL   0BC0
01410:  BSF    F7A.1
....................                      PUSH_PRIORITY_QUEUE_ISR_MACRO(UPDATE_MOTE_TIME); 
01412:  MOVLW  A3
01414:  MOVLB  5
01416:  MOVWF  x9B
01418:  MOVLB  0
0141A:  CALL   07D0
....................                      PUSH_PRIORITY_QUEUE_ISR_MACRO(CHECK_MOTE_TEMP); 
0141E:  MOVLW  A2
01420:  MOVLB  5
01422:  MOVWF  x9B
01424:  MOVLB  0
01426:  CALL   07D0
....................                   } 
....................                }    
....................                //mote_alarms_rcvd = \ 
....................                //   bytes_from_mote.get_motestatus_response.mote_alarms; 
.................... /* 
....................                change_counter_rcvd = \ 
....................                   bytes_from_mote.get_motestatus_response.change_counter; 
....................                number_of_parents_rcvd = \ 
....................                   bytes_from_mote.get_motestatus_response.number_of_parents; 
.................... */ 
....................                break; 
0142A:  BRA    1476
....................  
....................             case  PARAM_TIME: 
....................                utc_sec_rcvd = bytes_from_mote.get_time_response.utc_sec; 
0142C:  MOVFF  D9,58D
01430:  MOVFF  D8,58C
01434:  MOVFF  D7,58B
01438:  MOVFF  D6,58A
....................                global_utc_time = make32(make8(utc_sec_rcvd,0), \ 
....................                  make8(utc_sec_rcvd,1), make8(utc_sec_rcvd,2), \ 
....................                  make8(utc_sec_rcvd,3));     //  **fix byte order** 
0143C:  MOVFF  58A,8C
01440:  MOVFF  58B,8B
01444:  MOVFF  58C,8A
01448:  MOVFF  58D,89
....................                               
....................                utc_usec_rcvd = bytes_from_mote.get_time_response.utc_usec; 
0144C:  MOVFF  DD,591
01450:  MOVFF  DC,590
01454:  MOVFF  DB,58F
01458:  MOVFF  DA,58E
....................                if (mote_msgSEQ == 0) 
0145C:  MOVLB  3
0145E:  MOVF   x5D,F
01460:  BNZ   146E
01462:  MOVF   x5E,F
01464:  BNZ   146E
....................                { 
....................                   mote_msgSEQ = make16(make8(utc_usec_rcvd,2), \                   
....................                      make8(utc_usec_rcvd,3)); 
01466:  MOVFF  590,35E
0146A:  MOVFF  591,35D
....................                } 
....................                // This value is used to establish a "random" value for  
....................                //  the mote message Sequence ID 
.................... /*                
....................                for (i=0; i<5; i++) 
....................                   asn_rcvd[i] = bytes_from_mote.get_time_response.asn[i]; 
....................                asn_offset_rcvd = bytes_from_mote.get_time_response.asn_offset; 
.................... */                
....................                break; 
0146E:  MOVLB  0
01470:  BRA    1476
....................  
....................             case  PARAM_CHARGE: 
....................                //charge_mC_rcvd = bytes_from_mote.get_charge_response.charge_mC; 
....................                //uptime_sec_rcvd = bytes_from_mote.get_charge_response.uptime_sec; 
....................                global_mote_temperature = \ 
....................                   bytes_from_mote.get_charge_response.temp_celsius; 
01472:  MOVFF  DE,365
....................                //temp_frac_celsius_rcvd = \ 
....................                //   bytes_from_mote.get_charge_response.temp_frac_celsius; 
....................                break; 
.................... /* 
....................             case  PARAM_RADIOSTATSRX: 
....................                num_of_received_packets_rcvd = \ 
....................                   bytes_from_mote.get_testrx_response.num_of_received_packets; 
....................                num_of_recep_failures = \ 
....................                   bytes_from_mote.get_testrx_response.num_of_recep_failures; 
....................                break; 
.................... */ 
....................             default: 
....................          } 
....................  
....................       case  CMD_SETNV: 
....................       // receipt of response after a SETNV command 
....................           switch (param_type_rcvd) 
01476:  MOVLB  3
01478:  MOVF   x5B,W
0147A:  XORLW  02
0147C:  MOVLB  0
0147E:  BZ    1486
01480:  XORLW  01
01482:  BZ    1488
01484:  BRA    1488
....................          {  // byte4 is the param_type for all SETNV responses 
....................             /* 
....................             case PARAM_MACADDR: case  PARAM_TXPOWER: \ 
....................             case  PARAM_POWERINFO: case  PARAM_OTAPLOCK: \ 
....................             case PARAM_SPECIAL1: case PARAM_SPECIAL2: 
....................                break; 
....................             */ 
....................             case PARAM_JOINKEY:  
....................                break; 
01486:  BRA    1488
....................             case  PARAM_NETWORKID:  
....................                break; 
....................             default: 
....................          } 
....................  
....................       case  CMD_GETNV: 
....................       // receipt of response after a GETNV command 
....................          switch (param_type_rcvd) 
01488:  MOVLB  3
0148A:  MOVF   x5B,W
0148C:  XORLW  01
0148E:  MOVLB  0
01490:  BZ    1498
01492:  XORLW  02
01494:  BZ    14DA
01496:  BRA    14EE
....................          {  // byte4 is the param_type for all GETNV responses 
....................             case  PARAM_MACADDR: 
....................                for (i=0; i<8; i++) 
01498:  MOVLB  5
0149A:  CLRF   x83
0149C:  MOVF   x83,W
0149E:  SUBLW  07
014A0:  BNC   14D8
....................                   macaddr_rcvd[i] = \ 
....................                      bytes_from_mote.getNV_macaddr_response.macaddr[i]; 
014A2:  CLRF   03
014A4:  MOVF   x83,W
014A6:  ADDLW  97
014A8:  MOVWF  01
014AA:  MOVLW  00
014AC:  ADDWFC 03,F
014AE:  MOVFF  01,59B
014B2:  MOVFF  03,59C
014B6:  CLRF   03
014B8:  MOVF   x83,W
014BA:  ADDLW  D6
014BC:  MOVWF  FE9
014BE:  MOVLW  00
014C0:  ADDWFC 03,W
014C2:  MOVWF  FEA
014C4:  MOVFF  FEF,59D
014C8:  MOVFF  59C,FEA
014CC:  MOVFF  01,FE9
014D0:  MOVFF  59D,FEF
014D4:  INCF   x83,F
014D6:  BRA    149C
....................                break; 
014D8:  BRA    14EC
....................  
....................             case  PARAM_NETWORKID: 
....................                tmp2u16 = bytes_from_mote.getNV_networkid_response.network_id; 
014DA:  MOVFF  D7,585
014DE:  MOVFF  D6,584
....................                network_id_rcvd = make16(make8(tmp2u16,0),make8(tmp2u16,1)); 
014E2:  MOVFF  584,360
014E6:  MOVFF  585,35F
....................                break; 
014EA:  MOVLB  5
014EC:  MOVLB  0
....................  
....................             default: 
....................           } 
....................  
....................       case  CMD_SEND:         case  CMD_DISCONNECT: \ 
....................       case  CMD_RESET:        case  CMD_SLEEP:     case  CMD_TESTRADIOTX: \ 
....................       case  CMD_TESTRADIORX:  case  CMD_CLEARNV: 
....................          // info saved above; receipt of response after any of the 
....................          // the above; no ack 
....................          break; 
014EE:  BRA    1658
....................       case CMD_SEARCH: 
....................          if (result_rcvd == RC_OK) 
014F0:  MOVLB  3
014F2:  MOVF   x57,F
014F4:  BNZ   14FE
....................          { 
....................             global_mote_state= MOTESTATE_SEARCHING; 
014F6:  MOVLW  02
014F8:  MOVLB  4
014FA:  MOVWF  xFC
014FC:  MOVLB  3
....................          } 
....................          break; 
014FE:  MOVLB  0
01500:  BRA    1658
....................       case CMD_JOIN: 
....................          if (result_rcvd == RC_OK) 
01502:  MOVLB  3
01504:  MOVF   x57,F
01506:  BNZ   1510
....................             global_mote_state = MOTESTATE_NEGOTIATING; 
01508:  MOVLW  03
0150A:  MOVLB  4
0150C:  MOVWF  xFC
0150E:  MOVLB  3
....................             joincmd_done_fl = TRUE; 
01510:  BSF    x59.3
....................          break; 
01512:  MOVLB  0
01514:  BRA    1658
....................  
....................       case  CMD_TIME: 
....................       // receipt of response after a _TIME hardware interrupt 
....................          utc_sec_rcvd = bytes_from_mote.time_indication.utc_sec; 
01516:  MOVFF  D7,58D
0151A:  MOVFF  D6,58C
0151E:  MOVFF  D5,58B
01522:  MOVFF  D4,58A
....................          global_utc_time = make32(make8(utc_sec_rcvd,0), \ 
....................          make8(utc_sec_rcvd,1), make8(utc_sec_rcvd,2), \ 
....................          make8(utc_sec_rcvd,3));     //  **fix byte order** 
01526:  MOVFF  58A,8C
0152A:  MOVFF  58B,8B
0152E:  MOVFF  58C,8A
01532:  MOVFF  58D,89
....................          utc_usec_rcvd = bytes_from_mote.time_indication.utc_usec; 
01536:  MOVFF  DB,591
0153A:  MOVFF  DA,590
0153E:  MOVFF  D9,58F
01542:  MOVFF  D8,58E
....................          if (!mote_msgSEQ) 
01546:  MOVLB  3
01548:  MOVF   x5D,W
0154A:  IORWF  x5E,W
0154C:  BNZ   1556
....................          { 
....................             mote_msgSEQ = make16(make8(utc_usec_rcvd,2), \                   
....................                make8(utc_usec_rcvd,3)); 
0154E:  MOVFF  590,35E
01552:  MOVFF  591,35D
....................          } 
....................  
....................          /* 
....................          for (i=0; i<5; i++) 
....................             asn_rcvd[i] = bytes_from_mote.time_indication.asn[i]; 
....................          asn_offset_rcvd = bytes_from_mote.time_indication.asn_offset; 
....................          */ 
....................  
.................... //         dust_hdlc_pkgen(prefix_x, 2, (uint8_t*)&r_x, 2);   // type A 
....................          send_ack = TRUE; 
01556:  MOVLB  5
01558:  BSF    x87.0
....................          break; 
0155A:  MOVLB  0
0155C:  BRA    1658
....................  
....................       case  CMD_SERVICE: 
....................       // receipt of a service indication from from manager 
....................          //event_code_rcvd = bytes_from_mote.service_indication.event_code; 
....................          svc_index_rcvd = bytes_from_mote.service_indication.svc_index; 
0155E:  MOVFF  D6,35C
....................          /* 
....................          mgr_code_rcvd = bytes_from_mote.service_indication.mgr_code; 
....................          svc_state_rcvd = bytes_from_mote.service_indication.svc_state; 
....................          svc_flags_rcvd = bytes_from_mote.service_indication.svc_flags; 
....................          app_domain_rcvd = bytes_from_mote.service_indication.app_domain; 
....................          */ 
....................          //destaddr_rcvd = bytes_from_mote.service_indication.destaddr; 
....................          //time_rcvd = bytes_from_mote.service_indication.time; 
....................  
....................  //        dust_hdlc_pkgen(prefix_x, 2, (uint8_t*)&r_x, 2);   // type A 
....................  
....................          send_ack = TRUE; 
01562:  MOVLB  5
01564:  BSF    x87.0
....................          break; 
01566:  MOVLB  0
01568:  BRA    1658
....................  
....................       case  CMD_EVENT: 
....................       // receipt of an event indication from the mote 
....................          // this is where I decide if the mote is alive or not 
....................          global_dust_enabled = TRUE; 
0156A:  BSF    x9F.6
....................           
....................          new_events_rcvd = bytes_from_mote.events_indication.new_events; 
0156C:  MOVFF  D7,595
01570:  MOVFF  D6,594
01574:  MOVFF  D5,593
01578:  MOVFF  D4,592
....................          global_mote_state = bytes_from_mote.events_indication.mote_state; 
0157C:  MOVFF  D8,4FC
....................           
....................          // If the mote isn't fully connected (operational) set the global 
....................          //    dust operational bit to false 
....................          if (global_mote_state != MOTESTATE_OPERATIONAL) 
01580:  MOVLB  4
01582:  MOVF   xFC,W
01584:  SUBLW  05
01586:  BZ    1590
....................          { 
....................             global_dust_operational = FALSE; 
01588:  MOVLB  0
0158A:  BCF    x9F.7
....................          } 
0158C:  BRA    15C0
0158E:  MOVLB  4
....................          // If the mote is fully connected... 
....................          else  
....................          {                                
....................             // and it wasn't before... 
....................             if (global_dust_operational == FALSE) 
01590:  MOVLB  0
01592:  BTFSC  x9F.7
01594:  BRA    15C0
....................             { 
....................                // set it to be connected and send a join message! 
....................                global_dust_operational = TRUE; 
01596:  BSF    x9F.7
....................                PUSH_MESSAGE_QUEUE_ISR_MACRO(MSG_MOTE_JOIN_MSG); 
01598:  BCF    F7A.1
0159A:  MOVLW  94
0159C:  MOVLB  5
0159E:  MOVWF  x9B
015A0:  MOVLB  0
015A2:  CALL   0BC0
015A6:  BSF    F7A.1
....................                                              
....................                PUSH_PRIORITY_QUEUE_ISR_MACRO(UPDATE_MOTE_TIME); 
015A8:  MOVLW  A3
015AA:  MOVLB  5
015AC:  MOVWF  x9B
015AE:  MOVLB  0
015B0:  CALL   07D0
....................                PUSH_PRIORITY_QUEUE_ISR_MACRO(CHECK_MOTE_TEMP);    
015B4:  MOVLW  A2
015B6:  MOVLB  5
015B8:  MOVWF  x9B
015BA:  MOVLB  0
015BC:  CALL   07D0
....................             } 
....................          } 
....................          //mote_alarms_rcvd = bytes_from_mote.events_indication.mote_alarms; 
....................  
....................          event_flags |= make8(new_events_rcvd,3);  // only last byte has 
015C0:  MOVLB  5
015C2:  MOVF   x95,W
015C4:  MOVLB  0
015C6:  IORWF  xD0,F
....................          // defined events for Eterna 
....................     
....................          send_ack = TRUE;           
015C8:  MOVLB  5
015CA:  BSF    x87.0
....................          break; 
015CC:  MOVLB  0
015CE:  BRA    1658
....................  
....................       case  CMD_ADVERT: 
....................       // receipt of an event indication from the mote 
....................          tmp2u16 = bytes_from_mote.advert_indication.network_id; 
015D0:  MOVFF  D5,585
015D4:  MOVFF  D4,584
....................          network_id_rcvd = make16(make8(tmp2u16,0),make8(tmp2u16,1)); 
015D8:  MOVFF  584,360
015DC:  MOVFF  585,35F
....................          mote_id_rcvd = bytes_from_mote.advert_indication.mote_id; 
015E0:  MOVFF  D7,362
015E4:  MOVFF  D6,361
....................           
....................          rssi_rcvd = bytes_from_mote.advert_indication.rssi; 
015E8:  MOVFF  D8,363
....................          hop_depth_rcvd = bytes_from_mote.advert_indication.hop_depth; 
015EC:  MOVFF  D9,364
....................           
....................          advert_rcvd_fl = TRUE; 
015F0:  MOVLB  3
015F2:  BSF    x58.3
....................    //      dust_hdlc_pkgen(prefix_x, 2, (uint8_t*)&r_x, 2);   // type A 
....................  
....................          send_ack = TRUE; 
015F4:  MOVLB  5
015F6:  BSF    x87.0
....................          break; 
015F8:  MOVLB  0
015FA:  BRA    1658
....................  
....................       case  CMD_DATA: 
....................       // receipt of a data packet payload from the manager 
....................          //sourceaddr_rcvd = bytes_from_mote.data_from_net.sourceaddr; 
....................          //sequence_num_rcvd = bytes_from_mote.data_from_net.sequence_num; 
....................          len_data_rcvd = bytes_from_mote.data_from_net.len_data; 
015FC:  MOVFF  D7,589
....................  
....................          if (len_data_rcvd <= MAX_USER_DATA_SIZE) 
01600:  MOVLB  5
01602:  MOVF   x89,W
01604:  SUBLW  5E
01606:  BNC   1648
....................          { 
....................             for (i=0; i<len_data_rcvd; i++) 
01608:  CLRF   x83
0160A:  MOVF   x89,W
0160C:  SUBWF  x83,W
0160E:  BC    1646
....................               payload_buff[i] = bytes_from_mote.data_from_net.data[i]; 
01610:  CLRF   03
01612:  MOVF   x83,W
01614:  ADDLW  EB
01616:  MOVWF  01
01618:  MOVLW  02
0161A:  ADDWFC 03,F
0161C:  MOVFF  01,59B
01620:  MOVFF  03,59C
01624:  CLRF   03
01626:  MOVF   x83,W
01628:  ADDLW  D8
0162A:  MOVWF  FE9
0162C:  MOVLW  00
0162E:  ADDWFC 03,W
01630:  MOVWF  FEA
01632:  MOVFF  FEF,59D
01636:  MOVFF  59C,FEA
0163A:  MOVFF  01,FE9
0163E:  MOVFF  59D,FEF
01642:  INCF   x83,F
01644:  BRA    160A
....................          } 
01646:  BRA    164C
....................          else 
....................          {     
....................             response_type = RC_INVALID_LEN; 
01648:  MOVLW  04
0164A:  MOVWF  x88
....................          } 
....................           
....................          send_ack = TRUE; 
0164C:  BSF    x87.0
....................  
....................          PUSH_PRIORITY_QUEUE_ISR_MACRO(DEAL_WITH_NEW_PACKET)          
0164E:  MOVLW  20
01650:  MOVWF  x9B
01652:  MOVLB  0
01654:  CALL   07D0
....................          break; 
....................  
....................       default: 
....................    } 
....................  
....................    // Send acks for appropriate messages 
....................     if (send_ack) 
01658:  MOVLB  5
0165A:  BTFSS  x87.0
0165C:  BRA    16C0
....................    { 
....................       // generates the dust message 
....................       uint8_t pkgen_buf[2], cmd_rcvd_buf[2]; 
....................       pkgen_buf[0] = (flags_rcvd+1); 
0165E:  MOVLW  01
01660:  MOVLB  3
01662:  ADDWF  x5A,W
01664:  MOVLB  5
01666:  MOVWF  x97
....................       pkgen_buf[1] = response_type; 
01668:  MOVFF  588,598
....................       cmd_rcvd_buf[0] = cmd_rcvd; 
0166C:  MOVFF  586,599
....................       cmd_rcvd_buf[1] = 0; 
01670:  CLRF   x9A
....................        
....................       dust_hdlc_pkgen_ISR(cmd_rcvd_buf, 2, pkgen_buf , 2); 
01672:  MOVLW  05
01674:  MOVWF  x9C
01676:  MOVLW  99
01678:  MOVWF  x9B
0167A:  MOVLW  02
0167C:  MOVWF  x9D
0167E:  MOVLW  05
01680:  MOVWF  x9F
01682:  MOVLW  97
01684:  MOVWF  x9E
01686:  MOVLW  02
01688:  MOVWF  xA0
0168A:  MOVLB  0
0168C:  CALL   0E7E
....................        
....................       // try 3 times to send the ack 
....................       for (i = 0; i < 3; i++) 
01690:  MOVLB  5
01692:  CLRF   x83
01694:  MOVF   x83,W
01696:  SUBLW  02
01698:  BNC   16C0
....................       { 
....................          // successful ack send 
....................          if (dust_hdlc_pksend_ISR() == NO_ERR)  
0169A:  MOVLB  0
0169C:  RCALL  1140
0169E:  MOVF   01,F
016A0:  BNZ   16AA
....................          { 
....................             break; 
016A2:  MOVLB  5
016A4:  BRA    16C0
....................          } 
016A6:  BRA    16BC
016A8:  MOVLB  0
....................          // wait 50ms and try again 
....................          else 
....................          { 
....................             setup_T4_int(T4_50MS); 
016AA:  MOVLW  C7
016AC:  MOVLB  5
016AE:  MOVWF  xA0
016B0:  MOVLB  0
016B2:  CALL   08DE
....................             while(!TMR4IF);     
016B6:  BTFSS  F7E.0
016B8:  BRA    16B6
016BA:  MOVLB  5
....................          } 
016BC:  INCF   x83,F
016BE:  BRA    1694
....................        
....................       // Add error handling if no ack (not sure how) 
....................       } 
....................    } 
016C0:  MOVLB  0
016C2:  GOTO   16DE (RETURN)
.................... } 
....................  
....................  
.................... uint8_t get_dustmsg_ISR(void) 
*
008F0:  MOVLB  5
008F2:  CLRF   x9B
.................... { 
.................... // After being prompted by a hardware interrupts on the UART lines 
.................... // this routine is called to actually collect the serial data and  
.................... // store it in dust_recive_buffer 
.................... // 
.................... // Returns the number of chars collected (1 char = 1 not 0) or some error code 
.................... // Error Codes: 
.................... // -ERR_GET_DUSTMSG_MESSAGE_LENGTH  
.................... // -ERR_GET_DUSTMSG_FRAMING_ERROR 
....................  
.................... //  When the hardware UART is specified by #use rs232(): 
.................... //  RS232_ERRORS is used only by the getc() function. 
.................... //  RS232_ERRORS is a copy of the RCSTA register except 
.................... //  that Bit 0 is used to indicate a parity error. 
.................... //  RS232 Errors are not yet implemented 
....................  
....................    uint8_t     bytes_rcvd = 0; 
....................     
....................    // Start the UART and pause for initialization 
....................    setup_uart(TRUE);           
008F4:  BSF    FAB.7
008F6:  BSF    FAB.4
008F8:  BSF    FAC.5
....................    setup_T4_int(T4_500US); 
008FA:  MOVLW  01
008FC:  MOVWF  xA0
008FE:  MOVLB  0
00900:  RCALL  08DE
....................    while(!TMR4IF);        
00902:  BTFSS  F7E.0
00904:  BRA    0902
....................     
....................    // recieve up to MAX_RCV_BUFFER  
....................    for (bytes_rcvd = 0; bytes_rcvd < MAX_RCV_BUFFER; bytes_rcvd++) 
00906:  MOVLB  5
00908:  CLRF   x9B
0090A:  MOVF   x9B,W
0090C:  SUBLW  C9
0090E:  BNC   0966
....................    { 
....................       // clear to send a byte 
....................       output_low(MOTE_TX_CTSn);  
00910:  BCF    F89.5
....................        
....................       // setup individual byte timeout and wait for next char 
....................       setup_T4_int(T0_10MS);    
00912:  MOVLW  D9
00914:  MOVWF  xA0
00916:  MOVLB  0
00918:  RCALL  08DE
....................       while (!kbhit() && !TMR4IF);  
0091A:  BTFSC  F9E.5
0091C:  BRA    0922
0091E:  BTFSS  F7E.0
00920:  BRA    091A
....................        
....................       // not clear to send the next byte until we process this one 
....................       output_high(MOTE_TX_CTSn); 
00922:  BSF    F89.5
....................        
....................       // return error on byte timeout 
....................       if (TMR4IF)  
00924:  BTFSS  F7E.0
00926:  BRA    0934
....................       { 
....................          setup_uart(FALSE);  
00928:  BCF    FAB.7
0092A:  BCF    FAB.4
0092C:  BCF    FAC.5
....................          return ERR_DUSTMSG_TIMEOUT; 
0092E:  MOVLW  FC
00930:  MOVWF  01
00932:  BRA    09D6
....................       } 
....................        
....................       // grab the byte from the receive register 
....................       dust_recive_buffer[bytes_rcvd] = RCREG1;         
00934:  CLRF   03
00936:  MOVLB  5
00938:  MOVF   x9B,W
0093A:  ADDLW  20
0093C:  MOVWF  FE9
0093E:  MOVLW  02
00940:  ADDWFC 03,W
00942:  MOVWF  FEA
00944:  MOVFF  FAE,FEF
....................        
....................       // done with getting message, break out of loop 
....................       if ((dust_recive_buffer[bytes_rcvd] == FLAG_SEQUENCE) && (bytes_rcvd != 0)) 
00948:  CLRF   03
0094A:  MOVF   x9B,W
0094C:  ADDLW  20
0094E:  MOVWF  FE9
00950:  MOVLW  02
00952:  ADDWFC 03,W
00954:  MOVWF  FEA
00956:  MOVF   FEF,W
00958:  SUBLW  7E
0095A:  BNZ   0962
0095C:  MOVF   x9B,F
0095E:  BZ    0962
....................       { 
....................          break;          
00960:  BRA    0966
....................       }  
00962:  INCF   x9B,F
00964:  BRA    090A
....................    } 
....................      
....................    // after the message is done, stop the uart 
....................    setup_uart(FALSE);  
00966:  BCF    FAB.7
00968:  BCF    FAB.4
0096A:  BCF    FAC.5
....................     
....................    // Check for errors 
....................    // at this point only possible errors are framing and message length 
....................    // Too long of a message (no ending flag sequence) 
....................    if ((bytes_rcvd == MAX_RCV_BUFFER) && (dust_recive_buffer[bytes_rcvd] != FLAG_SEQUENCE)) 
0096C:  MOVF   x9B,W
0096E:  SUBLW  CA
00970:  BNZ   0992
00972:  CLRF   03
00974:  MOVF   x9B,W
00976:  ADDLW  20
00978:  MOVWF  FE9
0097A:  MOVLW  02
0097C:  ADDWFC 03,W
0097E:  MOVWF  FEA
00980:  MOVF   FEF,W
00982:  SUBLW  7E
00984:  BZ    0992
....................    { 
....................       return ERR_DUSTMSG_MESSAGE_LENGTH; 
00986:  MOVLW  FF
00988:  MOVWF  01
0098A:  MOVLB  0
0098C:  BRA    09D6
....................    } 
0098E:  BRA    09D6
00990:  MOVLB  5
....................    // Too small of a message, return error code 
....................    else if (bytes_rcvd < 5) 
00992:  MOVF   x9B,W
00994:  SUBLW  04
00996:  BNC   09A2
....................    { 
....................       return ERR_DUSTMSG_MESSAGE_LENGTH; 
00998:  MOVLW  FF
0099A:  MOVWF  01
0099C:  MOVLB  0
0099E:  BRA    09D6
....................    } 
009A0:  BRA    09D6
....................    // Framing error, return error code 
....................    else if ((dust_recive_buffer[0] != FLAG_SEQUENCE) || (dust_recive_buffer[bytes_rcvd] != FLAG_SEQUENCE)) 
009A2:  MOVLB  2
009A4:  MOVF   x20,W
009A6:  SUBLW  7E
009A8:  BNZ   09C2
009AA:  CLRF   03
009AC:  MOVLB  5
009AE:  MOVF   x9B,W
009B0:  ADDLW  20
009B2:  MOVWF  FE9
009B4:  MOVLW  02
009B6:  ADDWFC 03,W
009B8:  MOVWF  FEA
009BA:  MOVF   FEF,W
009BC:  SUBLW  7E
009BE:  BZ    09CE
009C0:  MOVLB  2
....................    { 
....................       return ERR_DUSTMSG_FRAMING_ERROR; 
009C2:  MOVLW  FE
009C4:  MOVWF  01
009C6:  MOVLB  0
009C8:  BRA    09D6
....................    } 
009CA:  BRA    09D6
009CC:  MOVLB  5
....................    // all is well, exit normally 
....................    else 
....................    {           
....................       // return how many bytes recieved in actual (starting at 1) number       
....................       return (bytes_rcvd + 1); 
009CE:  MOVLW  01
009D0:  ADDWF  x9B,W
009D2:  MOVWF  01
009D4:  MOVLB  0
....................    } 
009D6:  GOTO   120C (RETURN)
.................... } 
....................  
.................... void dust_hdlc_pkgen(uint8_t* prefix, uint8_t size, \ 
....................                        uint8_t* buf, uint8_t size_buf) 
*
05C1A:  MOVLB  5
05C1C:  CLRF   x68
05C1E:  CLRF   x67
05C20:  CLRF   x69
05C22:  CLRF   x6A
05C24:  CLRF   x6B
.................... { 
.................... // dust_hdlc_pkgen() 
.................... // 
.................... // Generate an HDLC packet ready for a mote. 
.................... // 
.................... // 1. Calc CRC-16 
.................... // 2. Add start delimiters (flag sequence) 
.................... // 3. Byte stuff 0x7e & 0x7d 
.................... // 4. Add end delimiters (flag sequence) 
.................... // 
....................      
....................    uint16_t    fcs16       = 0; 
....................    uint8_t     data8       = 0; 
....................    uint8_t     i           = 0; 
....................    uint8_t     j           = 0; 
....................  
.................... // Step 1 
....................    fcs16 = FCS_INITIAL_FCS16; 
05C26:  SETF   x68
05C28:  SETF   x67
....................     
....................    // FCS the prefix bytes 
....................    for (i = 0; i < size; i++) 
05C2A:  CLRF   x6A
05C2C:  MOVF   x63,W
05C2E:  SUBWF  x6A,W
05C30:  BC    5C6A
....................    { 
....................       fcs16 = fcs_fcs16(fcs16, prefix[i]); 
05C32:  MOVF   x6A,W
05C34:  ADDWF  x61,W
05C36:  MOVWF  FE9
05C38:  MOVLW  00
05C3A:  ADDWFC x62,W
05C3C:  MOVWF  FEA
05C3E:  MOVFF  FEF,5A9
05C42:  CLRF   19
05C44:  BTFSC  FF2.7
05C46:  BSF    19.7
05C48:  BCF    FF2.7
05C4A:  MOVFF  568,5A8
05C4E:  MOVFF  567,5A7
05C52:  MOVLB  0
05C54:  CALL   0E3C
05C58:  BTFSC  19.7
05C5A:  BSF    FF2.7
05C5C:  MOVFF  02,568
05C60:  MOVFF  01,567
05C64:  MOVLB  5
05C66:  INCF   x6A,F
05C68:  BRA    5C2C
....................    } 
....................     
....................    // FCS the data packet bytes 
....................    for (i = 0; i < size_buf; i++) 
05C6A:  CLRF   x6A
05C6C:  MOVF   x66,W
05C6E:  SUBWF  x6A,W
05C70:  BC    5CAA
....................    { 
....................       fcs16 = fcs_fcs16(fcs16, buf[i]); 
05C72:  MOVF   x6A,W
05C74:  ADDWF  x64,W
05C76:  MOVWF  FE9
05C78:  MOVLW  00
05C7A:  ADDWFC x65,W
05C7C:  MOVWF  FEA
05C7E:  MOVFF  FEF,5A9
05C82:  CLRF   19
05C84:  BTFSC  FF2.7
05C86:  BSF    19.7
05C88:  BCF    FF2.7
05C8A:  MOVFF  568,5A8
05C8E:  MOVFF  567,5A7
05C92:  MOVLB  0
05C94:  CALL   0E3C
05C98:  BTFSC  19.7
05C9A:  BSF    FF2.7
05C9C:  MOVFF  02,568
05CA0:  MOVFF  01,567
05CA4:  MOVLB  5
05CA6:  INCF   x6A,F
05CA8:  BRA    5C6C
....................    } 
....................  
....................    // add 1's complement 
....................    fcs16 = ~(fcs16);  
05CAA:  COMF   x67,F
05CAC:  COMF   x68,F
....................  
.................... // Step 2 
....................    //Set initial delimiter 
....................    j = 0; 
05CAE:  CLRF   x6B
....................    dust_send_buffer[j++]  = FLAG_SEQUENCE; 
05CB0:  MOVF   x6B,W
05CB2:  INCF   x6B,F
05CB4:  CLRF   03
05CB6:  ADDLW  38
05CB8:  MOVWF  FE9
05CBA:  MOVLW  01
05CBC:  ADDWFC 03,W
05CBE:  MOVWF  FEA
05CC0:  MOVLW  7E
05CC2:  MOVWF  FEF
....................  
.................... // Step 3 
....................    // Stuff prefix buffer 
....................    for (i = 0; i < size; i++) 
05CC4:  CLRF   x6A
05CC6:  MOVF   x63,W
05CC8:  SUBWF  x6A,W
05CCA:  BC    5D66
....................    { 
....................       STUFF_BYTE(prefix[i], dust_send_buffer, j); 
05CCC:  MOVF   x6A,W
05CCE:  ADDWF  x61,W
05CD0:  MOVWF  FE9
05CD2:  MOVLW  00
05CD4:  ADDWFC x62,W
05CD6:  MOVWF  FEA
05CD8:  MOVF   FEF,W
05CDA:  SUBLW  7D
05CDC:  BZ    5CF0
05CDE:  MOVF   x6A,W
05CE0:  ADDWF  x61,W
05CE2:  MOVWF  FE9
05CE4:  MOVLW  00
05CE6:  ADDWFC x62,W
05CE8:  MOVWF  FEA
05CEA:  MOVF   FEF,W
05CEC:  SUBLW  7E
05CEE:  BNZ   5D38
05CF0:  MOVF   x6B,W
05CF2:  INCF   x6B,F
05CF4:  CLRF   03
05CF6:  ADDLW  38
05CF8:  MOVWF  FE9
05CFA:  MOVLW  01
05CFC:  ADDWFC 03,W
05CFE:  MOVWF  FEA
05D00:  MOVLW  7D
05D02:  MOVWF  FEF
05D04:  MOVF   x6B,W
05D06:  INCF   x6B,F
05D08:  CLRF   03
05D0A:  ADDLW  38
05D0C:  MOVWF  01
05D0E:  MOVLW  01
05D10:  ADDWFC 03,F
05D12:  MOVFF  01,56C
05D16:  MOVFF  03,56D
05D1A:  MOVF   x6A,W
05D1C:  ADDWF  x61,W
05D1E:  MOVWF  FE9
05D20:  MOVLW  00
05D22:  ADDWFC x62,W
05D24:  MOVWF  FEA
05D26:  MOVF   FEF,W
05D28:  XORLW  20
05D2A:  MOVWF  x6E
05D2C:  MOVFF  03,FEA
05D30:  MOVFF  01,FE9
05D34:  MOVWF  FEF
05D36:  BRA    5D62
05D38:  MOVF   x6B,W
05D3A:  INCF   x6B,F
05D3C:  CLRF   03
05D3E:  ADDLW  38
05D40:  MOVWF  01
05D42:  MOVLW  01
05D44:  ADDWFC 03,F
05D46:  MOVF   x6A,W
05D48:  ADDWF  x61,W
05D4A:  MOVWF  FE9
05D4C:  MOVLW  00
05D4E:  ADDWFC x62,W
05D50:  MOVWF  FEA
05D52:  MOVFF  FEF,56E
05D56:  MOVFF  03,FEA
05D5A:  MOVFF  01,FE9
05D5E:  MOVFF  56E,FEF
05D62:  INCF   x6A,F
05D64:  BRA    5CC6
....................    } 
....................  
....................    // Stuff data buffer 
....................    for (i = 0; i < size_buf; i++) 
05D66:  CLRF   x6A
05D68:  MOVF   x66,W
05D6A:  SUBWF  x6A,W
05D6C:  BC    5E08
....................    { 
....................       STUFF_BYTE(buf[i], dust_send_buffer, j); 
05D6E:  MOVF   x6A,W
05D70:  ADDWF  x64,W
05D72:  MOVWF  FE9
05D74:  MOVLW  00
05D76:  ADDWFC x65,W
05D78:  MOVWF  FEA
05D7A:  MOVF   FEF,W
05D7C:  SUBLW  7D
05D7E:  BZ    5D92
05D80:  MOVF   x6A,W
05D82:  ADDWF  x64,W
05D84:  MOVWF  FE9
05D86:  MOVLW  00
05D88:  ADDWFC x65,W
05D8A:  MOVWF  FEA
05D8C:  MOVF   FEF,W
05D8E:  SUBLW  7E
05D90:  BNZ   5DDA
05D92:  MOVF   x6B,W
05D94:  INCF   x6B,F
05D96:  CLRF   03
05D98:  ADDLW  38
05D9A:  MOVWF  FE9
05D9C:  MOVLW  01
05D9E:  ADDWFC 03,W
05DA0:  MOVWF  FEA
05DA2:  MOVLW  7D
05DA4:  MOVWF  FEF
05DA6:  MOVF   x6B,W
05DA8:  INCF   x6B,F
05DAA:  CLRF   03
05DAC:  ADDLW  38
05DAE:  MOVWF  01
05DB0:  MOVLW  01
05DB2:  ADDWFC 03,F
05DB4:  MOVFF  01,56C
05DB8:  MOVFF  03,56D
05DBC:  MOVF   x6A,W
05DBE:  ADDWF  x64,W
05DC0:  MOVWF  FE9
05DC2:  MOVLW  00
05DC4:  ADDWFC x65,W
05DC6:  MOVWF  FEA
05DC8:  MOVF   FEF,W
05DCA:  XORLW  20
05DCC:  MOVWF  x6E
05DCE:  MOVFF  03,FEA
05DD2:  MOVFF  01,FE9
05DD6:  MOVWF  FEF
05DD8:  BRA    5E04
05DDA:  MOVF   x6B,W
05DDC:  INCF   x6B,F
05DDE:  CLRF   03
05DE0:  ADDLW  38
05DE2:  MOVWF  01
05DE4:  MOVLW  01
05DE6:  ADDWFC 03,F
05DE8:  MOVF   x6A,W
05DEA:  ADDWF  x64,W
05DEC:  MOVWF  FE9
05DEE:  MOVLW  00
05DF0:  ADDWFC x65,W
05DF2:  MOVWF  FEA
05DF4:  MOVFF  FEF,56E
05DF8:  MOVFF  03,FEA
05DFC:  MOVFF  01,FE9
05E00:  MOVFF  56E,FEF
05E04:  INCF   x6A,F
05E06:  BRA    5D68
....................    } 
....................  
....................    // Add least significiant byte 1st (RFC 1622). Do byte stuffing. 
....................    data8 = (uint8_t)(fcs16 & 0xff); 
05E08:  MOVFF  567,569
....................    STUFF_BYTE(data8, dust_send_buffer, j); 
05E0C:  MOVF   x69,W
05E0E:  SUBLW  7D
05E10:  BZ    5E18
05E12:  MOVF   x69,W
05E14:  SUBLW  7E
05E16:  BNZ   5E44
05E18:  MOVF   x6B,W
05E1A:  INCF   x6B,F
05E1C:  CLRF   03
05E1E:  ADDLW  38
05E20:  MOVWF  FE9
05E22:  MOVLW  01
05E24:  ADDWFC 03,W
05E26:  MOVWF  FEA
05E28:  MOVLW  7D
05E2A:  MOVWF  FEF
05E2C:  MOVF   x6B,W
05E2E:  INCF   x6B,F
05E30:  CLRF   03
05E32:  ADDLW  38
05E34:  MOVWF  FE9
05E36:  MOVLW  01
05E38:  ADDWFC 03,W
05E3A:  MOVWF  FEA
05E3C:  MOVF   x69,W
05E3E:  XORLW  20
05E40:  MOVWF  FEF
05E42:  BRA    5E58
05E44:  MOVF   x6B,W
05E46:  INCF   x6B,F
05E48:  CLRF   03
05E4A:  ADDLW  38
05E4C:  MOVWF  FE9
05E4E:  MOVLW  01
05E50:  ADDWFC 03,W
05E52:  MOVWF  FEA
05E54:  MOVFF  569,FEF
....................  
....................    // Add most significiant byte 2nd (RFC 1622). Do byte stuffing. 
....................    data8 = (uint8_t)((fcs16>>8) & 0xff); 
05E58:  MOVFF  568,569
....................    STUFF_BYTE(data8, dust_send_buffer, j); 
05E5C:  MOVF   x69,W
05E5E:  SUBLW  7D
05E60:  BZ    5E68
05E62:  MOVF   x69,W
05E64:  SUBLW  7E
05E66:  BNZ   5E94
05E68:  MOVF   x6B,W
05E6A:  INCF   x6B,F
05E6C:  CLRF   03
05E6E:  ADDLW  38
05E70:  MOVWF  FE9
05E72:  MOVLW  01
05E74:  ADDWFC 03,W
05E76:  MOVWF  FEA
05E78:  MOVLW  7D
05E7A:  MOVWF  FEF
05E7C:  MOVF   x6B,W
05E7E:  INCF   x6B,F
05E80:  CLRF   03
05E82:  ADDLW  38
05E84:  MOVWF  FE9
05E86:  MOVLW  01
05E88:  ADDWFC 03,W
05E8A:  MOVWF  FEA
05E8C:  MOVF   x69,W
05E8E:  XORLW  20
05E90:  MOVWF  FEF
05E92:  BRA    5EA8
05E94:  MOVF   x6B,W
05E96:  INCF   x6B,F
05E98:  CLRF   03
05E9A:  ADDLW  38
05E9C:  MOVWF  FE9
05E9E:  MOVLW  01
05EA0:  ADDWFC 03,W
05EA2:  MOVWF  FEA
05EA4:  MOVFF  569,FEF
....................  
.................... // Step 4 
....................    // CHECK_BUF_SIZE(j+1); 
....................    dust_send_buffer[j++]  = FLAG_SEQUENCE; 
05EA8:  MOVF   x6B,W
05EAA:  INCF   x6B,F
05EAC:  CLRF   03
05EAE:  ADDLW  38
05EB0:  MOVWF  FE9
05EB2:  MOVLW  01
05EB4:  ADDWFC 03,W
05EB6:  MOVWF  FEA
05EB8:  MOVLW  7E
05EBA:  MOVWF  FEF
....................  
....................    // Set the number of bytes actually written 
....................    num_of_bytes_to_send = j; 
05EBC:  MOVFF  56B,349
....................     
....................    return; 
05EC0:  MOVLB  0
05EC2:  RETURN 0
.................... } 
....................  
.................... void dust_hdlc_pkgen_ISR(uint8_t* prefix, uint8_t size, \ 
....................                        uint8_t* buf, uint8_t size_buf) 
*
00E7E:  MOVLB  5
00E80:  CLRF   xA2
00E82:  CLRF   xA1
00E84:  CLRF   xA3
00E86:  CLRF   xA4
00E88:  CLRF   xA5
.................... { 
.................... // Generate an HDLC packet ready for a mote. 
.................... // 
.................... // 1. Calc CRC-16 
.................... // 2. Add start delimiters (flag sequence) 
.................... // 3. Byte stuff 0x7e & 0x7d 
.................... // 4. Add end delimiters (flag sequence) 
.................... // 
....................      
....................    uint16_t    fcs16       = 0; 
....................    uint8_t     data8       = 0; 
....................    uint8_t     i           = 0; 
....................    uint8_t     j           = 0; 
....................  
.................... // Step 1 
....................    fcs16 = FCS_INITIAL_FCS16; 
00E8A:  SETF   xA2
00E8C:  SETF   xA1
....................     
....................    // FCS the prefix bytes 
....................    for (i = 0; i < size; i++) 
00E8E:  CLRF   xA4
00E90:  MOVF   x9D,W
00E92:  SUBWF  xA4,W
00E94:  BC    0EC0
....................    { 
....................       fcs16 = fcs_fcs16(fcs16, prefix[i]); 
00E96:  MOVF   xA4,W
00E98:  ADDWF  x9B,W
00E9A:  MOVWF  FE9
00E9C:  MOVLW  00
00E9E:  ADDWFC x9C,W
00EA0:  MOVWF  FEA
00EA2:  MOVFF  FEF,5A9
00EA6:  MOVFF  5A2,5A8
00EAA:  MOVFF  5A1,5A7
00EAE:  MOVLB  0
00EB0:  RCALL  0E3C
00EB2:  MOVFF  02,5A2
00EB6:  MOVFF  01,5A1
00EBA:  MOVLB  5
00EBC:  INCF   xA4,F
00EBE:  BRA    0E90
....................    } 
....................     
....................    // FCS the data packet bytes 
....................    for (i = 0; i < size_buf; i++) 
00EC0:  CLRF   xA4
00EC2:  MOVF   xA0,W
00EC4:  SUBWF  xA4,W
00EC6:  BC    0EF2
....................    { 
....................       fcs16 = fcs_fcs16(fcs16, buf[i]); 
00EC8:  MOVF   xA4,W
00ECA:  ADDWF  x9E,W
00ECC:  MOVWF  FE9
00ECE:  MOVLW  00
00ED0:  ADDWFC x9F,W
00ED2:  MOVWF  FEA
00ED4:  MOVFF  FEF,5A9
00ED8:  MOVFF  5A2,5A8
00EDC:  MOVFF  5A1,5A7
00EE0:  MOVLB  0
00EE2:  RCALL  0E3C
00EE4:  MOVFF  02,5A2
00EE8:  MOVFF  01,5A1
00EEC:  MOVLB  5
00EEE:  INCF   xA4,F
00EF0:  BRA    0EC2
....................    } 
....................  
....................    // add 1's complement 
....................    fcs16 = ~(fcs16);  
00EF2:  COMF   xA1,F
00EF4:  COMF   xA2,F
....................  
.................... // Step 2 
....................    //Set initial delimiter 
....................    j = 0; 
00EF6:  CLRF   xA5
....................    dust_send_buffer_isr[j++]  = FLAG_SEQUENCE; 
00EF8:  MOVF   xA5,W
00EFA:  INCF   xA5,F
00EFC:  CLRF   03
00EFE:  ADDLW  08
00F00:  MOVWF  FE9
00F02:  MOVLW  02
00F04:  ADDWFC 03,W
00F06:  MOVWF  FEA
00F08:  MOVLW  7E
00F0A:  MOVWF  FEF
....................  
.................... // Step 3 
....................    // Stuff prefix buffer 
....................    for (i = 0; i < size; i++) 
00F0C:  CLRF   xA4
00F0E:  MOVF   x9D,W
00F10:  SUBWF  xA4,W
00F12:  BC    0FAE
....................    { 
....................       STUFF_BYTE(prefix[i], dust_send_buffer_isr, j); 
00F14:  MOVF   xA4,W
00F16:  ADDWF  x9B,W
00F18:  MOVWF  FE9
00F1A:  MOVLW  00
00F1C:  ADDWFC x9C,W
00F1E:  MOVWF  FEA
00F20:  MOVF   FEF,W
00F22:  SUBLW  7D
00F24:  BZ    0F38
00F26:  MOVF   xA4,W
00F28:  ADDWF  x9B,W
00F2A:  MOVWF  FE9
00F2C:  MOVLW  00
00F2E:  ADDWFC x9C,W
00F30:  MOVWF  FEA
00F32:  MOVF   FEF,W
00F34:  SUBLW  7E
00F36:  BNZ   0F80
00F38:  MOVF   xA5,W
00F3A:  INCF   xA5,F
00F3C:  CLRF   03
00F3E:  ADDLW  08
00F40:  MOVWF  FE9
00F42:  MOVLW  02
00F44:  ADDWFC 03,W
00F46:  MOVWF  FEA
00F48:  MOVLW  7D
00F4A:  MOVWF  FEF
00F4C:  MOVF   xA5,W
00F4E:  INCF   xA5,F
00F50:  CLRF   03
00F52:  ADDLW  08
00F54:  MOVWF  01
00F56:  MOVLW  02
00F58:  ADDWFC 03,F
00F5A:  MOVFF  01,5A6
00F5E:  MOVFF  03,5A7
00F62:  MOVF   xA4,W
00F64:  ADDWF  x9B,W
00F66:  MOVWF  FE9
00F68:  MOVLW  00
00F6A:  ADDWFC x9C,W
00F6C:  MOVWF  FEA
00F6E:  MOVF   FEF,W
00F70:  XORLW  20
00F72:  MOVWF  xA8
00F74:  MOVFF  03,FEA
00F78:  MOVFF  01,FE9
00F7C:  MOVWF  FEF
00F7E:  BRA    0FAA
00F80:  MOVF   xA5,W
00F82:  INCF   xA5,F
00F84:  CLRF   03
00F86:  ADDLW  08
00F88:  MOVWF  01
00F8A:  MOVLW  02
00F8C:  ADDWFC 03,F
00F8E:  MOVF   xA4,W
00F90:  ADDWF  x9B,W
00F92:  MOVWF  FE9
00F94:  MOVLW  00
00F96:  ADDWFC x9C,W
00F98:  MOVWF  FEA
00F9A:  MOVFF  FEF,5A8
00F9E:  MOVFF  03,FEA
00FA2:  MOVFF  01,FE9
00FA6:  MOVFF  5A8,FEF
00FAA:  INCF   xA4,F
00FAC:  BRA    0F0E
....................    } 
....................  
....................    // Stuff data buffer 
....................    for (i = 0; i < size_buf; i++) 
00FAE:  CLRF   xA4
00FB0:  MOVF   xA0,W
00FB2:  SUBWF  xA4,W
00FB4:  BC    1050
....................    { 
....................       STUFF_BYTE(buf[i], dust_send_buffer_isr, j); 
00FB6:  MOVF   xA4,W
00FB8:  ADDWF  x9E,W
00FBA:  MOVWF  FE9
00FBC:  MOVLW  00
00FBE:  ADDWFC x9F,W
00FC0:  MOVWF  FEA
00FC2:  MOVF   FEF,W
00FC4:  SUBLW  7D
00FC6:  BZ    0FDA
00FC8:  MOVF   xA4,W
00FCA:  ADDWF  x9E,W
00FCC:  MOVWF  FE9
00FCE:  MOVLW  00
00FD0:  ADDWFC x9F,W
00FD2:  MOVWF  FEA
00FD4:  MOVF   FEF,W
00FD6:  SUBLW  7E
00FD8:  BNZ   1022
00FDA:  MOVF   xA5,W
00FDC:  INCF   xA5,F
00FDE:  CLRF   03
00FE0:  ADDLW  08
00FE2:  MOVWF  FE9
00FE4:  MOVLW  02
00FE6:  ADDWFC 03,W
00FE8:  MOVWF  FEA
00FEA:  MOVLW  7D
00FEC:  MOVWF  FEF
00FEE:  MOVF   xA5,W
00FF0:  INCF   xA5,F
00FF2:  CLRF   03
00FF4:  ADDLW  08
00FF6:  MOVWF  01
00FF8:  MOVLW  02
00FFA:  ADDWFC 03,F
00FFC:  MOVFF  01,5A6
01000:  MOVFF  03,5A7
01004:  MOVF   xA4,W
01006:  ADDWF  x9E,W
01008:  MOVWF  FE9
0100A:  MOVLW  00
0100C:  ADDWFC x9F,W
0100E:  MOVWF  FEA
01010:  MOVF   FEF,W
01012:  XORLW  20
01014:  MOVWF  xA8
01016:  MOVFF  03,FEA
0101A:  MOVFF  01,FE9
0101E:  MOVWF  FEF
01020:  BRA    104C
01022:  MOVF   xA5,W
01024:  INCF   xA5,F
01026:  CLRF   03
01028:  ADDLW  08
0102A:  MOVWF  01
0102C:  MOVLW  02
0102E:  ADDWFC 03,F
01030:  MOVF   xA4,W
01032:  ADDWF  x9E,W
01034:  MOVWF  FE9
01036:  MOVLW  00
01038:  ADDWFC x9F,W
0103A:  MOVWF  FEA
0103C:  MOVFF  FEF,5A8
01040:  MOVFF  03,FEA
01044:  MOVFF  01,FE9
01048:  MOVFF  5A8,FEF
0104C:  INCF   xA4,F
0104E:  BRA    0FB0
....................    } 
....................  
....................    // Add least significiant byte 1st (RFC 1622). Do byte stuffing. 
....................    data8 = (uint8_t)(fcs16 & 0xff); 
01050:  MOVFF  5A1,5A3
....................    STUFF_BYTE(data8, dust_send_buffer_isr, j); 
01054:  MOVF   xA3,W
01056:  SUBLW  7D
01058:  BZ    1060
0105A:  MOVF   xA3,W
0105C:  SUBLW  7E
0105E:  BNZ   108C
01060:  MOVF   xA5,W
01062:  INCF   xA5,F
01064:  CLRF   03
01066:  ADDLW  08
01068:  MOVWF  FE9
0106A:  MOVLW  02
0106C:  ADDWFC 03,W
0106E:  MOVWF  FEA
01070:  MOVLW  7D
01072:  MOVWF  FEF
01074:  MOVF   xA5,W
01076:  INCF   xA5,F
01078:  CLRF   03
0107A:  ADDLW  08
0107C:  MOVWF  FE9
0107E:  MOVLW  02
01080:  ADDWFC 03,W
01082:  MOVWF  FEA
01084:  MOVF   xA3,W
01086:  XORLW  20
01088:  MOVWF  FEF
0108A:  BRA    10A0
0108C:  MOVF   xA5,W
0108E:  INCF   xA5,F
01090:  CLRF   03
01092:  ADDLW  08
01094:  MOVWF  FE9
01096:  MOVLW  02
01098:  ADDWFC 03,W
0109A:  MOVWF  FEA
0109C:  MOVFF  5A3,FEF
....................  
....................    // Add most significiant byte 2nd (RFC 1622). Do byte stuffing. 
....................    data8 = (uint8_t)((fcs16>>8) & 0xff); 
010A0:  MOVFF  5A2,5A3
....................    STUFF_BYTE(data8, dust_send_buffer_isr, j); 
010A4:  MOVF   xA3,W
010A6:  SUBLW  7D
010A8:  BZ    10B0
010AA:  MOVF   xA3,W
010AC:  SUBLW  7E
010AE:  BNZ   10DC
010B0:  MOVF   xA5,W
010B2:  INCF   xA5,F
010B4:  CLRF   03
010B6:  ADDLW  08
010B8:  MOVWF  FE9
010BA:  MOVLW  02
010BC:  ADDWFC 03,W
010BE:  MOVWF  FEA
010C0:  MOVLW  7D
010C2:  MOVWF  FEF
010C4:  MOVF   xA5,W
010C6:  INCF   xA5,F
010C8:  CLRF   03
010CA:  ADDLW  08
010CC:  MOVWF  FE9
010CE:  MOVLW  02
010D0:  ADDWFC 03,W
010D2:  MOVWF  FEA
010D4:  MOVF   xA3,W
010D6:  XORLW  20
010D8:  MOVWF  FEF
010DA:  BRA    10F0
010DC:  MOVF   xA5,W
010DE:  INCF   xA5,F
010E0:  CLRF   03
010E2:  ADDLW  08
010E4:  MOVWF  FE9
010E6:  MOVLW  02
010E8:  ADDWFC 03,W
010EA:  MOVWF  FEA
010EC:  MOVFF  5A3,FEF
....................  
.................... // Step 4 
....................    // CHECK_BUF_SIZE(j+1); 
....................    dust_send_buffer_isr[j++]  = FLAG_SEQUENCE; 
010F0:  MOVF   xA5,W
010F2:  INCF   xA5,F
010F4:  CLRF   03
010F6:  ADDLW  08
010F8:  MOVWF  FE9
010FA:  MOVLW  02
010FC:  ADDWFC 03,W
010FE:  MOVWF  FEA
01100:  MOVLW  7E
01102:  MOVWF  FEF
....................  
....................    // Set the number of bytes actually written 
....................    num_of_bytes_to_send_isr = j; 
01104:  MOVFF  5A5,34A
....................     
....................    return; 
01108:  MOVLB  0
0110A:  RETURN 0
.................... } 
....................  
.................... uint8_t dust_hdlc_pksend() 
.................... { 
.................... // This routine actually sends out the packet from the micro to the mote 
....................  
....................    uint8_t     n; 
....................    uint8_t     tmp_oscccon, tmp_t2con, tmp_pr2, tmp_t0con; 
....................     
....................    // save the crystal status for later restore 
....................    tmp_oscccon = OSCCON; 
*
05EC4:  MOVFF  FD3,560
....................    tmp_t2con = T2CON; 
05EC8:  MOVFF  FBA,561
....................    tmp_pr2 = PR2; 
05ECC:  MOVFF  FBB,562
....................    tmp_t0con = T0CON; 
05ED0:  MOVFF  FD5,563
05ED4:  CLRF   19
05ED6:  BTFSC  FF2.7
05ED8:  BSF    19.7
05EDA:  BCF    FF2.7
....................     
....................    // turn on high-speed crystal for UART communication 
....................    fosc_pri(); 
05EDC:  CALL   110C
05EE0:  BTFSC  19.7
05EE2:  BSF    FF2.7
....................  
....................    // prepare mote to recieve data 
....................    output_low(MOTE_RX_RTSn); 
05EE4:  BCF    F8C.5
....................    
....................    // turn on uart and wait for it to initalize 
....................    setup_uart(TRUE);                      
05EE6:  BSF    FAB.7
05EE8:  BSF    FAB.4
05EEA:  BSF    FAC.5
....................    setup_T0_int(T0_500US); 
05EEC:  MOVLB  5
05EEE:  SETF   x65
05EF0:  MOVLW  FE
05EF2:  MOVWF  x64
05EF4:  MOVLB  0
05EF6:  CALL   356C
....................    while(!TMR0IF);    
05EFA:  BTFSS  FF2.2
05EFC:  BRA    5EFA
....................  
....................    // loop for sending out bytes 
....................    for (n = 0; n < num_of_bytes_to_send; n++) 
05EFE:  MOVLB  5
05F00:  CLRF   x5F
05F02:  MOVLB  3
05F04:  MOVF   x49,W
05F06:  MOVLB  5
05F08:  SUBWF  x5F,W
05F0A:  BC    5F56
....................    { 
....................       // setup send timeout for error handling 
....................       setup_T0_int(T0_10MS); 
05F0C:  SETF   x65
05F0E:  MOVLW  D9
05F10:  MOVWF  x64
05F12:  MOVLB  0
05F14:  CALL   356C
....................  
....................       // wait until a transmit is done or timeout error 
....................       while (!TRMT1 && !TMR0IF); 
05F18:  BTFSC  FAC.1
05F1A:  BRA    5F20
05F1C:  BTFSS  FF2.2
05F1E:  BRA    5F18
....................        
....................       // if the timeout occured before the tranmit finished 
....................       if (TMR0IF) 
05F20:  BTFSS  FF2.2
05F22:  BRA    5F34
....................       { 
....................          // tell mote that it is no longer going to recieve data 
....................          output_high(MOTE_RX_RTSn); 
05F24:  BSF    F8C.5
....................          // turn off uart 
....................          setup_uart(FALSE); 
05F26:  BCF    FAB.7
05F28:  BCF    FAB.4
05F2A:  BCF    FAC.5
....................          // return error code 
....................          return ERR_DUSTMSG_TIMEOUT; 
05F2C:  MOVLW  FC
05F2E:  MOVWF  01
05F30:  BRA    5F78
....................       } 
05F32:  BRA    5F50
....................       // if transmit buffer is open 
....................       else 
....................       { 
....................          // send byte to mote 
....................          putc(dust_send_buffer[n]); 
05F34:  CLRF   03
05F36:  MOVLB  5
05F38:  MOVF   x5F,W
05F3A:  ADDLW  38
05F3C:  MOVWF  FE9
05F3E:  MOVLW  01
05F40:  ADDWFC 03,W
05F42:  MOVWF  FEA
05F44:  MOVFF  FEF,564
05F48:  MOVF   x64,W
05F4A:  MOVLB  0
05F4C:  CALL   1138
....................       } 
05F50:  MOVLB  5
05F52:  INCF   x5F,F
05F54:  BRA    5F02
....................    } 
....................     
....................    // wait until the last transmit is done 
....................    while (!TRMT1); 
05F56:  BTFSS  FAC.1
05F58:  BRA    5F56
....................  
....................    // tell mote that it no longer is going to recieve data 
....................    output_high(MOTE_RX_RTSn); 
05F5A:  BSF    F8C.5
....................     
....................    // turn off the uart 
....................    setup_uart(FALSE); 
05F5C:  BCF    FAB.7
05F5E:  BCF    FAB.4
05F60:  BCF    FAC.5
....................     
....................    //fosc_250k(); 
....................    
....................    // restore the crystal status 
....................    OSCCON = tmp_oscccon; 
05F62:  MOVFF  560,FD3
....................    T2CON = tmp_t2con; 
05F66:  MOVFF  561,FBA
....................    T0CON = tmp_t0con; 
05F6A:  MOVFF  563,FD5
....................    PR2 = tmp_PR2; 
05F6E:  MOVFF  562,FBB
....................     
....................    // return no error 
....................    return NO_ERR; 
05F72:  MOVLW  00
05F74:  MOVWF  01
05F76:  MOVLB  0
05F78:  RETURN 0
.................... } 
....................  
.................... uint8_t dust_hdlc_pksend_ISR() 
.................... { 
.................... // We're now running at 3.6864MHz at 115.2K baud 
.................... // This routine actually sends out the packet from the micro to the mote 
....................     
....................    uint8_t     n; 
....................    uint8_t     tmp_oscccon, tmp_t2con, tmp_pr2, tmp_t0con; 
....................     
....................    // save the crystal status for later restore 
....................    tmp_oscccon = OSCCON; 
*
01140:  MOVFF  FD3,59C
....................    tmp_t2con = T2CON; 
01144:  MOVFF  FBA,59D
....................    tmp_pr2 = PR2; 
01148:  MOVFF  FBB,59E
....................    tmp_t0con = T0CON; 
0114C:  MOVFF  FD5,59F
....................     
....................    // turn on high-speed crystal for UART communication 
....................    fosc_pri(); 
01150:  RCALL  110C
....................  
....................    // prepare mote to recieve data 
....................    output_low(MOTE_RX_RTSn); 
01152:  BCF    F8C.5
....................    
....................    // turn on uart and wait for it to initalize 
....................    setup_uart(TRUE);                      
01154:  BSF    FAB.7
01156:  BSF    FAB.4
01158:  BSF    FAC.5
....................    setup_T4_int(T4_500US); 
0115A:  MOVLW  01
0115C:  MOVLB  5
0115E:  MOVWF  xA0
01160:  MOVLB  0
01162:  CALL   08DE
....................    while(!TMR4IF);    
01166:  BTFSS  F7E.0
01168:  BRA    1166
....................  
....................    for (n = 0; n < num_of_bytes_to_send_isr; n++) 
0116A:  MOVLB  5
0116C:  CLRF   x9B
0116E:  MOVLB  3
01170:  MOVF   x4A,W
01172:  MOVLB  5
01174:  SUBWF  x9B,W
01176:  BC    11BE
....................    { 
....................       // setup send timeout for error handling 
....................       setup_T4_int(T4_10MS); 
01178:  MOVLW  27
0117A:  MOVWF  xA0
0117C:  MOVLB  0
0117E:  CALL   08DE
....................  
....................       // wait until a transmit is done or timeout error 
....................       while (!TRMT1 && !TMR4IF); 
01182:  BTFSC  FAC.1
01184:  BRA    118A
01186:  BTFSS  F7E.0
01188:  BRA    1182
....................        
....................       // if the timeout occured before the tranmit finished 
....................       if (TMR4IF) 
0118A:  BTFSS  F7E.0
0118C:  BRA    119E
....................       { 
....................          // tell mote that it is no longer going to recieve data 
....................          output_high(MOTE_RX_RTSn); 
0118E:  BSF    F8C.5
....................          // turn off uart 
....................          setup_uart(FALSE); 
01190:  BCF    FAB.7
01192:  BCF    FAB.4
01194:  BCF    FAC.5
....................          // return error code 
....................          return ERR_DUSTMSG_TIMEOUT; 
01196:  MOVLW  FC
01198:  MOVWF  01
0119A:  BRA    11E0
....................       } 
0119C:  BRA    11B8
....................       // if transmit buffer is open 
....................       else 
....................       { 
....................          // send byte to mote 
....................          putc(dust_send_buffer_isr[n]); 
0119E:  CLRF   03
011A0:  MOVLB  5
011A2:  MOVF   x9B,W
011A4:  ADDLW  08
011A6:  MOVWF  FE9
011A8:  MOVLW  02
011AA:  ADDWFC 03,W
011AC:  MOVWF  FEA
011AE:  MOVFF  FEF,5A0
011B2:  MOVF   xA0,W
011B4:  MOVLB  0
011B6:  RCALL  1138
....................       } 
011B8:  MOVLB  5
011BA:  INCF   x9B,F
011BC:  BRA    116E
....................    } 
....................     
....................    // wait until the last transmit is done 
....................    while (!TRMT1); 
011BE:  BTFSS  FAC.1
011C0:  BRA    11BE
....................  
....................    // tell mote that it no longer is going to recieve data 
....................    output_high(MOTE_RX_RTSn); 
011C2:  BSF    F8C.5
....................     
....................    // turn off the uart 
....................    setup_uart(FALSE); 
011C4:  BCF    FAB.7
011C6:  BCF    FAB.4
011C8:  BCF    FAC.5
....................     
....................    // restore the crystal status 
....................    OSCCON = tmp_oscccon; 
011CA:  MOVFF  59C,FD3
....................    T2CON = tmp_t2con; 
011CE:  MOVFF  59D,FBA
....................    T0CON = tmp_t0con; 
011D2:  MOVFF  59F,FD5
....................    PR2 = tmp_PR2; 
011D6:  MOVFF  59E,FBB
....................     
....................    // return no error 
....................    return NO_ERR; 
011DA:  MOVLW  00
011DC:  MOVWF  01
011DE:  MOVLB  0
011E0:  RETURN 0
.................... } 
....................  
.................... uint8_t dust_hdlc_pkdecode_ISR(uint8_t bytes_to_decode) 
*
00A7A:  MOVLB  5
00A7C:  CLRF   x9D
00A7E:  CLRF   x9C
00A80:  CLRF   xA4
.................... { 
.................... /* 
....................  * Decode an HDLC packet from Mote. 
....................  * 
....................  * NOTE: The destination buffer must contain an extra 
....................  *       2 bytes to hold CRC data.  This requirement 
....................  *       simplifies the code and improves performance. 
....................  * 
....................  * 1. Remove delimiters 
....................  * 2. Unstuff *payload* and CRC bytes 
....................  * 3. Assemble CRC bytes 
....................  * 4. Check CRC 
....................  *  
....................  * Returns error messages or the number of byte decoded 
.................... */ 
....................  
.................... //  Note changes to routine as supplied by Dust: 
.................... //  The buffer and buffer size for the storage of received packet 
.................... //   are hardwired to be dust_recive_buffer[128] for the raw data 
.................... //   and bytes_from_mote.dust_rcvd for the unstuffed and stripped data 
....................  
....................    uint16_t    crc16       = 0; 
....................    uint8_t*    src_ptr; 
....................    uint8_t*    src_ptr_end; 
....................    uint8_t*    dest_ptr; 
....................  
....................    uint8_t      dust_bytes_rcvd = 0; 
....................  
.................... // 1 Check for start/end delimiters 
....................     if ((FLAG_SEQUENCE != dust_recive_buffer[0]) || 
....................         (FLAG_SEQUENCE != dust_recive_buffer[bytes_to_decode-1]))  
00A82:  MOVLB  2
00A84:  MOVF   x20,W
00A86:  SUBLW  7E
00A88:  BNZ   0AA4
00A8A:  MOVLW  01
00A8C:  MOVLB  5
00A8E:  SUBWF  x9B,W
00A90:  CLRF   03
00A92:  ADDLW  20
00A94:  MOVWF  FE9
00A96:  MOVLW  02
00A98:  ADDWFC 03,W
00A9A:  MOVWF  FEA
00A9C:  MOVF   FEF,W
00A9E:  SUBLW  7E
00AA0:  BZ    0AAC
00AA2:  MOVLB  2
....................     { 
....................         // return framing error 
....................         return ERR_DUSTMSG_FRAMING_ERROR; 
00AA4:  MOVLW  FE
00AA6:  MOVWF  01
00AA8:  BRA    0BBA
00AAA:  MOVLB  5
....................     } 
....................  
.................... // 2 Unstuff *payload* and CRC data into destination buffer 
....................     dest_ptr    = bytes_from_mote.dust_rcvd; 
00AAC:  CLRF   xA3
00AAE:  MOVLW  D1
00AB0:  MOVWF  xA2
....................     src_ptr_end = &dust_recive_buffer[bytes_to_decode-1]; 
00AB2:  MOVLW  01
00AB4:  SUBWF  x9B,W
00AB6:  CLRF   03
00AB8:  ADDLW  20
00ABA:  MOVWF  01
00ABC:  MOVLW  02
00ABE:  ADDWFC 03,F
00AC0:  MOVFF  01,5A0
00AC4:  MOVFF  03,5A1
....................     for (src_ptr = &dust_recive_buffer[1]; src_ptr < src_ptr_end; src_ptr++) 
00AC8:  MOVLW  02
00ACA:  MOVWF  x9F
00ACC:  MOVLW  21
00ACE:  MOVWF  x9E
00AD0:  MOVF   x9F,W
00AD2:  SUBWF  xA1,W
00AD4:  BNC   0B46
00AD6:  BNZ   0ADE
00AD8:  MOVF   xA0,W
00ADA:  SUBWF  x9E,W
00ADC:  BC    0B46
....................     { 
....................         if (*src_ptr == CONTROL_ESCAPE) { 
00ADE:  MOVFF  59F,03
00AE2:  MOVFF  59E,FE9
00AE6:  MOVFF  59F,FEA
00AEA:  MOVF   FEF,W
00AEC:  SUBLW  7D
00AEE:  BNZ   0B1C
....................            src_ptr++; /* skip to next byte, which contains the actual data */ 
00AF0:  INCF   x9E,F
00AF2:  BTFSC  FD8.2
00AF4:  INCF   x9F,F
....................             *dest_ptr++ = *src_ptr ^ XOR_BYTE; 
00AF6:  MOVFF  5A3,5A6
00AFA:  MOVF   xA2,W
00AFC:  INCF   xA2,F
00AFE:  BTFSC  FD8.2
00B00:  INCF   xA3,F
00B02:  MOVWF  xA5
00B04:  MOVFF  59E,FE9
00B08:  MOVFF  59F,FEA
00B0C:  MOVF   FEF,W
00B0E:  XORLW  20
00B10:  MOVFF  5A6,FEA
00B14:  MOVFF  5A5,FE9
00B18:  MOVWF  FEF
....................         } 
00B1A:  BRA    0B3E
....................         else 
....................         { 
....................             *dest_ptr++ = *src_ptr; 
00B1C:  MOVFF  5A3,5A6
00B20:  MOVF   xA2,W
00B22:  INCF   xA2,F
00B24:  BTFSC  FD8.2
00B26:  INCF   xA3,F
00B28:  MOVFF  59E,FE9
00B2C:  MOVFF  59F,FEA
00B30:  MOVFF  FEF,5A7
00B34:  MOVFF  5A6,FEA
00B38:  MOVWF  FE9
00B3A:  MOVFF  5A7,FEF
....................         } 
00B3E:  INCF   x9E,F
00B40:  BTFSC  FD8.2
00B42:  INCF   x9F,F
00B44:  BRA    0AD0
....................     } 
....................  
.................... // 3 Assemble CRC 
....................     dest_ptr--;                 /* now points to MSBs */ 
00B46:  MOVF   xA2,W
00B48:  BTFSC  FD8.2
00B4A:  DECF   xA3,F
00B4C:  DECF   xA2,F
....................     crc16 = *dest_ptr-- << 8; 
00B4E:  MOVFF  5A3,03
00B52:  MOVF   xA2,W
00B54:  BTFSC  FD8.2
00B56:  DECF   xA3,F
00B58:  DECF   xA2,F
00B5A:  MOVWF  FE9
00B5C:  MOVFF  03,FEA
00B60:  MOVFF  FEF,59D
00B64:  CLRF   x9C
....................     crc16 += *dest_ptr;         /* add LSBs */ 
00B66:  MOVFF  5A2,FE9
00B6A:  MOVFF  5A3,FEA
00B6E:  MOVF   FEF,W
00B70:  ADDWF  x9C,F
00B72:  MOVLW  00
00B74:  ADDWFC x9D,F
....................  
....................     /* Fill in the number of bytes actually written */ 
....................    dust_bytes_rcvd = (uint8_t)(dest_ptr - bytes_from_mote.dust_rcvd); 
00B76:  MOVLW  D1
00B78:  SUBWF  xA2,W
00B7A:  MOVWF  00
00B7C:  MOVLW  00
00B7E:  SUBWFB xA3,W
00B80:  MOVFF  00,5A4
....................  
.................... // 4 Return error if CRCs don't match       
....................     if (fcs_calc_ISR(bytes_from_mote.dust_rcvd, dust_bytes_rcvd) != crc16 )  
00B84:  CLRF   xA6
00B86:  MOVLW  D1
00B88:  MOVWF  xA5
00B8A:  CLRF   xA8
00B8C:  MOVFF  5A4,5A7
00B90:  MOVLB  0
00B92:  BRA    0A1E
00B94:  MOVFF  02,5A6
00B98:  MOVFF  01,5A5
00B9C:  MOVLB  5
00B9E:  MOVF   x9C,W
00BA0:  SUBWF  01,W
00BA2:  BNZ   0BAA
00BA4:  MOVF   x9D,W
00BA6:  SUBWF  xA6,W
00BA8:  BZ    0BB4
....................     { 
....................        // indicate bad CRC 
....................        return ERR_DUSTMSG_CRC;       
00BAA:  MOVLW  FB
00BAC:  MOVWF  01
00BAE:  MOVLB  2
00BB0:  BRA    0BBA
00BB2:  MOVLB  5
....................     } 
....................    return dust_bytes_rcvd; 
00BB4:  MOVFF  5A4,01
00BB8:  MOVLB  2
00BBA:  MOVLB  0
00BBC:  GOTO   1216 (RETURN)
.................... } 
....................  
.................... uint16_t fcs_fcs16(uint16_t fcs, uint8_t data) 
.................... { 
....................    return (fcs >> 8) ^ fcstab[(fcs ^ data) & 0xff]; 
*
00E3C:  MOVFF  5A8,5AA
00E40:  MOVLB  5
00E42:  CLRF   xAB
00E44:  MOVF   xA7,W
00E46:  XORWF  xA9,W
00E48:  MOVWF  xAC
00E4A:  CLRF   xAD
00E4C:  BCF    FD8.0
00E4E:  RLCF   xAC,W
00E50:  MOVWF  02
00E52:  RLCF   xAD,W
00E54:  MOVWF  03
00E56:  MOVF   02,W
00E58:  MOVFF  03,FF7
00E5C:  MOVLB  0
00E5E:  CALL   01AC
00E62:  TBLRD*+
00E64:  MOVFF  FF5,03
00E68:  MOVLB  5
00E6A:  XORWF  xAA,W
00E6C:  MOVWF  00
00E6E:  MOVF   03,W
00E70:  XORWF  xAB,W
00E72:  MOVWF  03
00E74:  MOVFF  00,01
00E78:  MOVWF  02
00E7A:  MOVLB  0
00E7C:  RETURN 0
.................... } 
....................  
.................... uint16_t fcs_fcs16_ISR(uint16_t fcs, uint8_t data) 
.................... { 
....................    return (fcs >> 8) ^ fcstab[(fcs ^ data) & 0xff]; 
*
009DA:  MOVFF  5AD,5AF
009DE:  MOVLB  5
009E0:  CLRF   xB0
009E2:  MOVF   xAC,W
009E4:  XORWF  xAE,W
009E6:  MOVWF  xB1
009E8:  CLRF   xB2
009EA:  BCF    FD8.0
009EC:  RLCF   xB1,W
009EE:  MOVWF  02
009F0:  RLCF   xB2,W
009F2:  MOVWF  03
009F4:  MOVF   02,W
009F6:  MOVFF  03,FF7
009FA:  MOVLB  0
009FC:  CALL   01AC
00A00:  TBLRD*+
00A02:  MOVFF  FF5,03
00A06:  MOVLB  5
00A08:  XORWF  xAF,W
00A0A:  MOVWF  00
00A0C:  MOVF   03,W
00A0E:  XORWF  xB0,W
00A10:  MOVWF  03
00A12:  MOVFF  00,01
00A16:  MOVWF  02
00A18:  MOVLB  0
00A1A:  GOTO   0A50 (RETURN)
.................... } 
....................  
.................... static uint16_t fcs_calc(uint8_t* p, uint16_t size) 
.................... { 
.................... /* fcs_calc() 
....................  * 
....................  * Calculate the 2 byte CRC-16 value given a buffer. 
....................  * 
....................  * Returns: 
....................  *      2 byte CRC-16 value 
....................  */ 
....................     uint16_t    fcs = 0; 
....................     fcs = FCS_INITIAL_FCS16; 
....................     while (size) { 
....................         fcs = fcs_fcs16(fcs, *p++); 
....................         size--; 
....................     } 
....................     return ~fcs; /* add 1's complement */ 
.................... } 
....................  
.................... static uint16_t fcs_calc_ISR(uint8_t* p, uint16_t size) 
00A1E:  MOVLB  5
00A20:  CLRF   xAA
00A22:  CLRF   xA9
.................... { 
....................     uint16_t    fcs = 0; 
....................     fcs = FCS_INITIAL_FCS16; 
00A24:  SETF   xAA
00A26:  SETF   xA9
....................     while (size) { 
00A28:  MOVF   xA7,W
00A2A:  IORWF  xA8,W
00A2C:  BZ    0A64
....................         fcs = fcs_fcs16_ISR(fcs, *p++); 
00A2E:  MOVFF  5A6,03
00A32:  MOVF   xA5,W
00A34:  INCF   xA5,F
00A36:  BTFSC  FD8.2
00A38:  INCF   xA6,F
00A3A:  MOVWF  FE9
00A3C:  MOVFF  03,FEA
00A40:  MOVFF  FEF,5AE
00A44:  MOVFF  5AA,5AD
00A48:  MOVFF  5A9,5AC
00A4C:  MOVLB  0
00A4E:  BRA    09DA
00A50:  MOVFF  02,5AA
00A54:  MOVFF  01,5A9
....................         size--; 
00A58:  MOVLB  5
00A5A:  MOVF   xA7,W
00A5C:  BTFSC  FD8.2
00A5E:  DECF   xA8,F
00A60:  DECF   xA7,F
00A62:  BRA    0A28
....................     } 
....................     return ~fcs; /* add 1's complement */ 
00A64:  MOVFF  5AA,03
00A68:  COMF   03,F
00A6A:  MOVF   xA9,W
00A6C:  XORLW  FF
00A6E:  MOVWF  01
00A70:  MOVFF  03,02
00A74:  MOVLB  0
00A76:  GOTO   0B94 (RETURN)
.................... } 
....................  
.................... uint8_t deal_with_packet(void) 
.................... { 
....................    uint8_t  command_id_received; 
....................    uint16_t mgr_msgSEQ; 
....................    uint32_t temp_uint32; 
....................    // clear out for use as NACK bitfield each time 
....................    temp_uint32 = 0; 
*
06CC0:  MOVLB  5
06CC2:  CLRF   x4D
06CC4:  CLRF   x4C
06CC6:  CLRF   x4B
06CC8:  CLRF   x4A
....................    static struct CommandQueueItem command_queue_item; 
....................    static struct SprinklerZoneSettingsItem sprinkler_zone_settings_item; 
....................    &command_queue_item.sprinkler_settings = &sprinkler_zone_settings_item; 
06CCA:  MOVLW  05
06CCC:  MOVWF  x29
06CCE:  MOVLW  2C
06CD0:  MOVWF  x28
....................     
....................    // This Dust-recommended prepend for messages (both from manager to mote and 
....................    //    from mote to manager) ensures that we do not conflict with any future 
....................    //    Hart-related aspects.  
....................     
....................    // This prepend is in the same spot for messages going either direction 
....................    // Return with an error if any char is incorrect 
....................    if ((payload_buff[0] != 0x00) || (payload_buff[1] != 0x00) ||              \ 
....................       (payload_buff[2] != 0xFC) || (payload_buff[3] != 0x12)) 
06CD2:  MOVLB  2
06CD4:  MOVF   xEB,F
06CD6:  BNZ   6CE8
06CD8:  MOVF   xEC,F
06CDA:  BNZ   6CE8
06CDC:  MOVF   xED,W
06CDE:  SUBLW  FC
06CE0:  BNZ   6CE8
06CE2:  MOVF   xEE,W
06CE4:  SUBLW  12
06CE6:  BZ    6CF0
....................    {    
....................       return ERR_BAD_PAYLOAD; 
06CE8:  MOVLW  F9
06CEA:  MOVWF  01
06CEC:  GOTO   7938
....................    } 
....................     
....................    // The mgr_msgSEQ, a sequence number used by the manager software to identify 
....................    //    messages which are ACK'd or NACK'd always follows the prepend. 
....................    mgr_msgSEQ = make16(payload_buff[5],payload_buff[4]); 
06CF0:  MOVFF  2F0,549
06CF4:  MOVFF  2EF,548
....................     
....................    // Then comes the msg_rcvd identifier which is the packet's intent, 
....................    //    such as 'give me a full report,' or 'do a warm start.' 
....................    // We leave payload_buff[6] alone so the command ID is identical for the  
....................    //    response message 
....................    command_id_received = payload_buff[6]; 
06CF8:  MOVFF  2F1,547
....................   
....................    // Switch for sorting through different messages recieved 
....................    switch (command_id_received) 
06CFC:  MOVLW  01
06CFE:  MOVLB  5
06D00:  SUBWF  x47,W
06D02:  ADDLW  BB
06D04:  BTFSC  FD8.0
06D06:  GOTO   7936
06D0A:  ADDLW  45
06D0C:  MOVLB  0
06D0E:  GOTO   793E
....................    { 
....................    // Manager ACKs or NACKs unsolicited messages from micro to manager such as: 
....................    //    a. Message at startup 
....................    //    b. ERROR messages 
....................    //    c. Valve calibrate response 
....................    //    d. Bulk data dump 
....................     
.................... //////// Manager ACKs/NACKs//////// 
....................       // Manager ACKs 
....................       case MSG_MGR_ACK: 
....................          // clear off unsolicited message of proper msgSEQ 
....................          REMOVE_MESSAGE_QUEUE_MACRO(mgr_msgSEQ); 
06D12:  BCF    F7A.1
06D14:  MOVFF  549,54F
06D18:  MOVFF  548,54E
06D1C:  GOTO   5A04
06D20:  BSF    F7A.1
....................          break; 
06D22:  MOVLB  5
06D24:  GOTO   7936
....................                                                         
....................       // Manager NACKs    
....................       case MSG_MGR_NACK: 
....................          // Do nothing. Messages will get resent as if it never got acked by 
....................          //    manager 
....................          break;    
06D28:  MOVLB  5
06D2A:  GOTO   7936
....................        
.................... //////// Report Requests//////// 
....................       // Manager requests a full report 
....................       case MSG_MGR_FULL_REPORT: 
....................          send_full_report(command_id_received, mgr_msgSEQ);   
06D2E:  MOVFF  547,54E
06D32:  MOVFF  549,550
06D36:  MOVFF  548,54F
06D3A:  CALL   5FD4
....................          break; 
06D3E:  MOVLB  5
06D40:  GOTO   7936
....................       // Manager requests a health report 
....................       case MSG_MGR_HEALTH_REPORT: 
....................          send_health_report(command_id_received, mgr_msgSEQ); 
06D44:  MOVFF  547,54E
06D48:  MOVFF  549,550
06D4C:  MOVFF  548,54F
06D50:  GOTO   62E8
....................          break; 
06D54:  MOVLB  5
06D56:  GOTO   7936
....................       // Manager requests a valve report 
....................       case MSG_MGR_VALVE_REPORT: 
....................          send_valve_report(command_id_received, mgr_msgSEQ); 
06D5A:  MOVFF  547,54E
06D5E:  MOVFF  549,550
06D62:  MOVFF  548,54F
06D66:  GOTO   6368
....................          break; 
06D6A:  MOVLB  5
06D6C:  GOTO   7936
....................        
.................... //////// Restart/Shutdown Commands////////                                            
....................       // Manager requests a warm restart (micro reboots) 
....................       case MSG_MGR_WARM_RESTART: 
....................          send_ack(command_id_received, mgr_msgSEQ); 
06D70:  MOVFF  547,54E
06D74:  MOVFF  549,550
06D78:  MOVFF  548,54F
06D7C:  CALL   649E
....................          // set the shutdown cause 
....................          global_shutdown_cause = WARM_RESTART_REQUEST; 
06D80:  MOVLW  09
06D82:  MOVWF  4D
....................          // save the shutdown/restart reason in EEPROM 
....................          write_ee1(EE_RESTART_CAUSE, global_shutdown_cause); 
06D84:  MOVLB  5
06D86:  CLRF   x51
06D88:  MOVLW  02
06D8A:  MOVWF  x50
06D8C:  MOVFF  4D,552
06D90:  MOVLB  0
06D92:  CALL   3142
....................          // restart micro                                                         
....................          PUSH_TIME_QUEUE_MACRO(global_rtc_time + 5, CPU_RESET);  
06D96:  BCF    F7A.1
06D98:  MOVLW  05
06D9A:  ADDWF  x85,W
06D9C:  MOVLB  5
06D9E:  MOVWF  x4E
06DA0:  MOVLW  00
06DA2:  MOVLB  0
06DA4:  ADDWFC x86,W
06DA6:  MOVLB  5
06DA8:  MOVWF  x4F
06DAA:  MOVLW  00
06DAC:  MOVLB  0
06DAE:  ADDWFC x87,W
06DB0:  MOVLB  5
06DB2:  MOVWF  x50
06DB4:  MOVLW  00
06DB6:  MOVLB  0
06DB8:  ADDWFC x88,W
06DBA:  MOVLB  5
06DBC:  MOVWF  x51
06DBE:  MOVWF  x55
06DC0:  MOVFF  550,554
06DC4:  MOVFF  54F,553
06DC8:  MOVFF  54E,552
06DCC:  MOVLW  F0
06DCE:  MOVWF  x56
06DD0:  MOVLB  0
06DD2:  CALL   414A
06DD6:  BSF    F7A.1
....................          break;  
06DD8:  MOVLB  5
06DDA:  GOTO   7936
....................       // Manager requests a cold restart (mote and micro reboot)   
....................       case MSG_MGR_COLD_RESTART: 
....................          send_ack(command_id_received, mgr_msgSEQ); 
06DDE:  MOVFF  547,54E
06DE2:  MOVFF  549,550
06DE6:  MOVFF  548,54F
06DEA:  CALL   649E
....................          // set the shutdown cause 
....................          global_shutdown_cause = COLD_RESTART_REQUEST; 
06DEE:  MOVLW  0A
06DF0:  MOVWF  4D
....................          // save the shutdown/restart reason in EEPROM 
....................          write_ee1(EE_RESTART_CAUSE, global_shutdown_cause); 
06DF2:  MOVLB  5
06DF4:  CLRF   x51
06DF6:  MOVLW  02
06DF8:  MOVWF  x50
06DFA:  MOVFF  4D,552
06DFE:  MOVLB  0
06E00:  CALL   3142
....................          // restart micro 
....................          PUSH_TIME_QUEUE_MACRO(global_rtc_time + 5, CPU_RESET); 
06E04:  BCF    F7A.1
06E06:  MOVLW  05
06E08:  ADDWF  x85,W
06E0A:  MOVLB  5
06E0C:  MOVWF  x4E
06E0E:  MOVLW  00
06E10:  MOVLB  0
06E12:  ADDWFC x86,W
06E14:  MOVLB  5
06E16:  MOVWF  x4F
06E18:  MOVLW  00
06E1A:  MOVLB  0
06E1C:  ADDWFC x87,W
06E1E:  MOVLB  5
06E20:  MOVWF  x50
06E22:  MOVLW  00
06E24:  MOVLB  0
06E26:  ADDWFC x88,W
06E28:  MOVLB  5
06E2A:  MOVWF  x51
06E2C:  MOVWF  x55
06E2E:  MOVFF  550,554
06E32:  MOVFF  54F,553
06E36:  MOVFF  54E,552
06E3A:  MOVLW  F0
06E3C:  MOVWF  x56
06E3E:  MOVLB  0
06E40:  CALL   414A
06E44:  BSF    F7A.1
....................          break; 
06E46:  MOVLB  5
06E48:  GOTO   7936
....................       // Manager requests a rejoin (restart mote and rejoin)  
....................       case MSG_MGR_FORCE_REJOIN: 
....................          send_ack(command_id_received, mgr_msgSEQ); 
06E4C:  MOVFF  547,54E
06E50:  MOVFF  549,550
06E54:  MOVFF  548,54F
06E58:  CALL   649E
....................          // schedule rejoin/restart mote 
....................          PUSH_TIME_QUEUE_MACRO(global_rtc_time + 5, RESET_MOTE); 
06E5C:  BCF    F7A.1
06E5E:  MOVLW  05
06E60:  ADDWF  x85,W
06E62:  MOVLB  5
06E64:  MOVWF  x4E
06E66:  MOVLW  00
06E68:  MOVLB  0
06E6A:  ADDWFC x86,W
06E6C:  MOVLB  5
06E6E:  MOVWF  x4F
06E70:  MOVLW  00
06E72:  MOVLB  0
06E74:  ADDWFC x87,W
06E76:  MOVLB  5
06E78:  MOVWF  x50
06E7A:  MOVLW  00
06E7C:  MOVLB  0
06E7E:  ADDWFC x88,W
06E80:  MOVLB  5
06E82:  MOVWF  x51
06E84:  MOVWF  x55
06E86:  MOVFF  550,554
06E8A:  MOVFF  54F,553
06E8E:  MOVFF  54E,552
06E92:  MOVLW  11
06E94:  MOVWF  x56
06E96:  MOVLB  0
06E98:  CALL   414A
06E9C:  BSF    F7A.1
....................          break; 
06E9E:  MOVLB  5
06EA0:  GOTO   7936
....................       // Manager requests a shutdown (deep sleep, move valve to specified position 
....................       //    and at a certain time) 
....................       case MSG_MGR_SHUTDOWN: 
....................          send_ack(command_id_received, mgr_msgSEQ); 
06EA4:  MOVFF  547,54E
06EA8:  MOVFF  549,550
06EAC:  MOVFF  548,54F
06EB0:  CALL   649E
....................          // set valve posisition and move valve 
....................          global_valve_position_set_value = make16(payload_buff[12], payload_buff[11]); 
06EB4:  MOVFF  2F7,BC
06EB8:  MOVFF  2F6,BB
....................          PUSH_PRIORITY_QUEUE_MACRO(MOVE_VALVE); 
06EBC:  BCF    F7A.1
06EBE:  MOVLW  40
06EC0:  MOVLB  5
06EC2:  MOVWF  x50
06EC4:  MOVLB  0
06EC6:  CALL   43F2
06ECA:  BSF    F7A.1
....................          // set the shutdown cause 
....................          global_shutdown_cause = MANAGER_SHUTDOWN_REQUEST; 
06ECC:  MOVLW  0B
06ECE:  MOVWF  4D
....................          // figure out the shutdown time in rtc time (given in utc time or 0 for NOW) 
....................          // temp_uint32 is now the utc shutdown time 
....................          temp_uint32 = make32(payload_buff[10], payload_buff[9],payload_buff[8], payload_buff[7]); 
06ED0:  MOVFF  2F5,54D
06ED4:  MOVFF  2F4,54C
06ED8:  MOVFF  2F3,54B
06EDC:  MOVFF  2F2,54A
....................           
....................          // if shutdown isn't now (time = 0), utc_shutdown_time + rtc_time - utc_time = rtc_shutdown_time 
....................          if (temp_uint32 != 0) 
06EE0:  MOVLB  5
06EE2:  MOVF   x4A,F
06EE4:  BNZ   6EF2
06EE6:  MOVF   x4B,F
06EE8:  BNZ   6EF2
06EEA:  MOVF   x4C,F
06EEC:  BNZ   6EF2
06EEE:  MOVF   x4D,F
06EF0:  BZ    6F60
....................          { 
....................             temp_uint32 += global_rtc_time - global_utc_time; 
06EF2:  MOVLB  0
06EF4:  MOVF   x89,W
06EF6:  SUBWF  x85,W
06EF8:  MOVWF  00
06EFA:  MOVF   x8A,W
06EFC:  SUBWFB x86,W
06EFE:  MOVWF  01
06F00:  MOVF   x8B,W
06F02:  SUBWFB x87,W
06F04:  MOVWF  02
06F06:  MOVF   x8C,W
06F08:  SUBWFB x88,W
06F0A:  MOVWF  03
06F0C:  MOVF   00,W
06F0E:  MOVLB  5
06F10:  ADDWF  x4A,F
06F12:  MOVF   01,W
06F14:  ADDWFC x4B,F
06F16:  MOVF   02,W
06F18:  ADDWFC x4C,F
06F1A:  MOVF   03,W
06F1C:  ADDWFC x4D,F
....................             // in some rare cases, this simple math might give a huge number (more than an hour past current rtc 
....................             //    time.) In that case, time should be now. 
....................             // The rare case would be when there is latency in the network more than the  
....................             //    elapsed rtc time. 
....................             if (temp_uint32 > (global_rtc_time + 3600)) 
06F1E:  MOVLW  10
06F20:  MOVLB  0
06F22:  ADDWF  x85,W
06F24:  MOVWF  00
06F26:  MOVLW  0E
06F28:  ADDWFC x86,W
06F2A:  MOVWF  01
06F2C:  MOVLW  00
06F2E:  ADDWFC x87,W
06F30:  MOVWF  02
06F32:  MOVLW  00
06F34:  ADDWFC x88,W
06F36:  MOVWF  03
06F38:  MOVLB  5
06F3A:  SUBWF  x4D,W
06F3C:  BNC   6F5E
06F3E:  BNZ   6F56
06F40:  MOVF   02,W
06F42:  SUBWF  x4C,W
06F44:  BNC   6F5E
06F46:  BNZ   6F56
06F48:  MOVF   01,W
06F4A:  SUBWF  x4B,W
06F4C:  BNC   6F5E
06F4E:  BNZ   6F56
06F50:  MOVF   x4A,W
06F52:  SUBWF  00,W
06F54:  BC    6F5E
....................             {  
....................                temp_uint32 = 0; 
06F56:  CLRF   x4D
06F58:  CLRF   x4C
06F5A:  CLRF   x4B
06F5C:  CLRF   x4A
....................             } 
....................          } 
06F5E:  BRA    6F70
....................          // shutdown time is now (sent time is 0) 
....................          else 
....................          { 
....................             temp_uint32 = global_rtc_time; 
06F60:  MOVFF  88,54D
06F64:  MOVFF  87,54C
06F68:  MOVFF  86,54B
06F6C:  MOVFF  85,54A
....................          }                                   
....................          // schedule the shutdown 
....................          PUSH_TIME_QUEUE_MACRO(temp_uint32, SHUTDOWN_SYSTEM); 
06F70:  BCF    F7A.1
06F72:  MOVFF  54D,555
06F76:  MOVFF  54C,554
06F7A:  MOVFF  54B,553
06F7E:  MOVFF  54A,552
06F82:  MOVLW  F1
06F84:  MOVWF  x56
06F86:  MOVLB  0
06F88:  CALL   414A
06F8C:  BSF    F7A.1
....................          break; 
06F8E:  MOVLB  5
06F90:  GOTO   7936
....................  
.................... //////// Erraneous Commands//////// 
....................       case MSG_MGR_UPDATE_SP_NUM: 
....................          // update sprinkler number 
....................          // check if number is in a valid range, NACK if no good. 
....................          global_sprinkler_num = make16(payload_buff[8], payload_buff[7]); 
06F94:  MOVFF  2F3,8E
06F98:  MOVFF  2F2,8D
....................          // write sprinkler number 
....................          write_ee2(EE_SPRINKLER_NUM, global_sprinkler_num); 
06F9C:  MOVLB  5
06F9E:  CLRF   x53
06FA0:  CLRF   x52
06FA2:  MOVFF  8E,555
06FA6:  MOVFF  8D,554
06FAA:  MOVLB  0
06FAC:  CALL   30A6
....................          send_update_sp_num_response(command_id_received, mgr_msgSEQ); 
06FB0:  MOVFF  547,54E
06FB4:  MOVFF  549,550
06FB8:  MOVFF  548,54F
06FBC:  GOTO   64C4
....................          break; 
06FC0:  MOVLB  5
06FC2:  GOTO   7936
....................       case MSG_MGR_CAL_VALVE: 
....................          send_ack(command_id_received, mgr_msgSEQ);             
06FC6:  MOVFF  547,54E
06FCA:  MOVFF  549,550
06FCE:  MOVFF  548,54F
06FD2:  CALL   649E
....................          // schedule calibrate valve 
....................          PUSH_PRIORITY_QUEUE_MACRO(CALIBRATE_VALVE_1);    
06FD6:  BCF    F7A.1
06FD8:  MOVLW  31
06FDA:  MOVLB  5
06FDC:  MOVWF  x50
06FDE:  MOVLB  0
06FE0:  CALL   43F2
06FE4:  BSF    F7A.1
....................          break; 
06FE6:  MOVLB  5
06FE8:  GOTO   7936
....................       case MSG_MGR_CAL_FSR: 
....................          if (global_system_state != SYSTEM_RUN)    
06FEC:  MOVLB  4
06FEE:  MOVF   xFD,W
06FF0:  SUBLW  02
06FF2:  BZ    6FFA
....................          { 
....................             temp_uint32 |= NACK_BITFIELD_INCOMPATIBLE_STATE; 
06FF4:  MOVLB  5
06FF6:  BSF    x4A.5
06FF8:  MOVLB  4
....................          }                                                     
....................          if (global_valve_position == VLV_POSITION_UNKNOWN) 
06FFA:  MOVLB  0
06FFC:  INCFSZ xB9,W
06FFE:  BRA    700A
07000:  INCFSZ xBA,W
07002:  BRA    700A
....................          { 
....................             temp_uint32 |= NACK_BITFIELD_VLV_POSITION_UNKNOWN;     
07004:  MOVLB  5
07006:  BSF    x4A.0
07008:  MOVLB  0
....................          } 
....................          if (!is_valve_position_valid(make16(payload_buff[8], payload_buff[7])))    
0700A:  MOVFF  2F3,54F
0700E:  MOVFF  2F2,54E
07012:  MOVFF  2F3,551
07016:  MOVFF  2F2,550
0701A:  CALL   64F8
0701E:  MOVF   01,F
07020:  BNZ   7028
....................          {                                                                       
....................             temp_uint32 |= NACK_BITFIELD_INVALID_VLV_SETTING;                     
07022:  MOVLB  5
07024:  BSF    x4A.1
07026:  MOVLB  0
....................          } 
....................          // if the NACK bitfield contains anything, send the nack instead of proceeding 
....................          if (temp_uint32 != 0)          
07028:  MOVLB  5
0702A:  MOVF   x4A,F
0702C:  BNZ   703A
0702E:  MOVF   x4B,F
07030:  BNZ   703A
07032:  MOVF   x4C,F
07034:  BNZ   703A
07036:  MOVF   x4D,F
07038:  BZ    7060
....................          { 
....................             send_nack(command_id_received, mgr_msgSEQ, temp_uint32); 
0703A:  MOVFF  547,54E
0703E:  MOVFF  549,550
07042:  MOVFF  548,54F
07046:  MOVFF  54D,554
0704A:  MOVFF  54C,553
0704E:  MOVFF  54B,552
07052:  MOVFF  54A,551
07056:  MOVLB  0
07058:  CALL   651A
....................          }                                             
0705C:  BRA    7082
0705E:  MOVLB  5
....................          else                                              
....................          {                  
....................             send_ack(command_id_received, mgr_msgSEQ); 
07060:  MOVFF  547,54E
07064:  MOVFF  549,550
07068:  MOVFF  548,54F
0706C:  MOVLB  0
0706E:  CALL   649E
....................             // schedule calibrate valve                    
....................             PUSH_PRIORITY_QUEUE_MACRO(CALIBRATE_FSR_1);   
07072:  BCF    F7A.1
07074:  MOVLW  37
07076:  MOVLB  5
07078:  MOVWF  x50
0707A:  MOVLB  0
0707C:  CALL   43F2
07080:  BSF    F7A.1
....................          } 
....................          break; 
07082:  MOVLB  5
07084:  GOTO   7936
....................           
....................       case MSG_MGR_AQUIRE_GPS:  
....................          send_ack(command_id_received, mgr_msgSEQ); 
07088:  MOVFF  547,54E
0708C:  MOVFF  549,550
07090:  MOVFF  548,54F
07094:  CALL   649E
....................          // start gps point aquisition                         
....................          PUSH_PRIORITY_QUEUE_MACRO(START_GPS_AQUISITION);               
07098:  BCF    F7A.1
0709A:  MOVLW  50
0709C:  MOVLB  5
0709E:  MOVWF  x50
070A0:  MOVLB  0
070A2:  CALL   43F2
070A6:  BSF    F7A.1
....................          break; 
070A8:  MOVLB  5
070AA:  GOTO   7936
....................                                                                           
....................       case MSG_MGR_UPDATE_EEPROM:                                
....................          LCD_clear();                                                 
070AE:  CALL   59CA
....................          LCD_place_uint16(make16(payload_buff[8], payload_buff[7]),0,0,5);   
070B2:  MOVFF  2F3,54F
070B6:  MOVFF  2F2,54E
070BA:  MOVFF  2F3,560
070BE:  MOVFF  2F2,55F
070C2:  MOVLB  5
070C4:  CLRF   x61
070C6:  CLRF   x62
070C8:  MOVLW  05
070CA:  MOVWF  x63
070CC:  MOVLB  0
070CE:  CALL   4924
....................          LCD_place_uint8(payload_buff[9],0,7,3);          
070D2:  MOVFF  2F4,560
070D6:  MOVLB  5
070D8:  CLRF   x61
070DA:  MOVLW  07
070DC:  MOVWF  x62
070DE:  MOVLW  03
070E0:  MOVWF  x63
070E2:  MOVLB  0
070E4:  CALL   4890
....................          LCD_place_uint32(make32(payload_buff[13],payload_buff[12],payload_buff[11],payload_buff[10]),1,0,8); 
070E8:  MOVFF  2F8,551
070EC:  MOVFF  2F7,550
070F0:  MOVFF  2F6,54F
070F4:  MOVFF  2F5,54E
070F8:  MOVFF  2F8,555
070FC:  MOVFF  2F7,554
07100:  MOVFF  2F6,553
07104:  MOVFF  2F5,552
07108:  MOVLW  01
0710A:  MOVLB  5
0710C:  MOVWF  x56
0710E:  CLRF   x57
07110:  MOVLW  08
07112:  MOVWF  x58
07114:  MOVLB  0
07116:  CALL   6558
....................          global_skip_lcd_update_count = 3;         
0711A:  MOVLW  03
0711C:  MOVWF  x83
....................                                                                                                  
....................          // if eeprom location is outside of the valid range                                      
....................          //    (not in between start and end location (taking into account the number of bytes))    
....................          if ((make16(payload_buff[8], payload_buff[7]) < EE_START_LOCATION) ||                        \                      
....................             ((make16(payload_buff[8], payload_buff[7]) + payload_buff[9] - 1) > EE_END_LOCATION) ||   \                                                
....................             // also check if number of bytes != 1, 2, or 4 
....................             (!((payload_buff[9] == 1) || (payload_buff[9] == 2) || (payload_buff[9] == 4))))        
0711E:  MOVFF  2F3,54F
07122:  MOVFF  2F2,54E
07126:  MOVLB  2
07128:  MOVF   xF4,W
0712A:  MOVLB  5
0712C:  ADDWF  x4E,F
0712E:  MOVLW  00
07130:  ADDWFC x4F,F
07132:  MOVLW  01
07134:  SUBWF  x4E,F
07136:  MOVLW  00
07138:  SUBWFB x4F,F
0713A:  BNZ   7158
0713C:  MOVF   x4E,W
0713E:  SUBLW  2F
07140:  BNC   7158
07142:  MOVLB  2
07144:  DECFSZ xF4,W
07146:  BRA    714A
07148:  BRA    7178
0714A:  MOVF   xF4,W
0714C:  SUBLW  02
0714E:  BZ    7178
07150:  MOVF   xF4,W
07152:  SUBLW  04
07154:  BZ    7178
07156:  MOVLB  5
....................          {                                                                                         
....................             send_nack(command_id_received, mgr_msgSEQ, NACK_BITFIELD_INVALID_EEPROM_SETTINGS);     
07158:  MOVFF  547,54E
0715C:  MOVFF  549,550
07160:  MOVFF  548,54F
07164:  CLRF   x54
07166:  CLRF   x53
07168:  MOVLW  01
0716A:  MOVWF  x52
0716C:  CLRF   x51
0716E:  MOVLB  0
07170:  CALL   651A
....................          }                                                                                            
07174:  BRA    721A
07176:  MOVLB  2
....................          // valid location and number of bytes                      
....................          else                                    
....................          {                                                                                                 
....................             if (payload_buff[9] == 1) 
07178:  DECFSZ xF4,W
0717A:  BRA    719A
....................             { 
....................                write_ee1(make16(payload_buff[8], payload_buff[7]),payload_buff[10]); 
0717C:  MOVFF  2F3,54F
07180:  MOVFF  2F2,54E
07184:  MOVFF  2F3,551
07188:  MOVFF  2F2,550
0718C:  MOVFF  2F5,552
07190:  MOVLB  0
07192:  CALL   3142
....................             } 
07196:  BRA    7206
07198:  MOVLB  2
....................             else if (payload_buff[9] == 2)                
0719A:  MOVF   xF4,W
0719C:  SUBLW  02
0719E:  BNZ   71CA
....................             {                                           
....................                write_ee2(make16(payload_buff[8], payload_buff[7]),make16(payload_buff[11],payload_buff[10])); 
071A0:  MOVFF  2F3,54F
071A4:  MOVFF  2F2,54E
071A8:  MOVFF  2F6,551
071AC:  MOVFF  2F5,550
071B0:  MOVFF  2F3,553
071B4:  MOVFF  2F2,552
071B8:  MOVFF  2F6,555
071BC:  MOVFF  2F5,554
071C0:  MOVLB  0
071C2:  CALL   30A6
....................             } 
071C6:  BRA    7206
071C8:  MOVLB  2
....................             else if (payload_buff[9] == 4)                                            
071CA:  MOVF   xF4,W
071CC:  SUBLW  04
071CE:  BNZ   7208
....................             { 
....................                write_ee4(make16(payload_buff[8], payload_buff[7]),make32(payload_buff[13],payload_buff[12],payload_buff[11],payload_buff[10])); 
071D0:  MOVFF  2F3,54F
071D4:  MOVFF  2F2,54E
071D8:  MOVFF  2F8,553
071DC:  MOVFF  2F7,552
071E0:  MOVFF  2F6,551
071E4:  MOVFF  2F5,550
071E8:  MOVFF  2F3,555
071EC:  MOVFF  2F2,554
071F0:  MOVFF  2F8,559
071F4:  MOVFF  2F7,558
071F8:  MOVFF  2F6,557
071FC:  MOVFF  2F5,556
07200:  MOVLB  0
07202:  CALL   667A
07206:  MOVLB  2
....................             } 
....................             send_ack(command_id_received, mgr_msgSEQ); 
07208:  MOVFF  547,54E
0720C:  MOVFF  549,550
07210:  MOVFF  548,54F
07214:  MOVLB  0
07216:  CALL   649E
....................          } 
....................          break;  
0721A:  MOVLB  5
0721C:  BRA    7936
....................        
....................       case MSG_MGR_READ_EEPROM:                                                                              
....................          // if eeprom location is outside of the valid range                                      
....................          //    (not in between start and end location (taking into account the number of bytes))    
....................          if ((make16(payload_buff[8], payload_buff[7]) < EE_START_LOCATION) ||                        \                      
....................             ((make16(payload_buff[8], payload_buff[7]) + payload_buff[9] - 1) > EE_END_LOCATION) ||   \                                                
....................             // also check if number of bytes != 1, 2, or 4 
....................             (!((payload_buff[9] == 1) || (payload_buff[9] == 2) || (payload_buff[9] == 4))))        
0721E:  MOVFF  2F3,54F
07222:  MOVFF  2F2,54E
07226:  MOVLB  2
07228:  MOVF   xF4,W
0722A:  MOVLB  5
0722C:  ADDWF  x4E,F
0722E:  MOVLW  00
07230:  ADDWFC x4F,F
07232:  MOVLW  01
07234:  SUBWF  x4E,F
07236:  MOVLW  00
07238:  SUBWFB x4F,F
0723A:  BNZ   7258
0723C:  MOVF   x4E,W
0723E:  SUBLW  2F
07240:  BNC   7258
07242:  MOVLB  2
07244:  DECFSZ xF4,W
07246:  BRA    724A
07248:  BRA    7278
0724A:  MOVF   xF4,W
0724C:  SUBLW  02
0724E:  BZ    7278
07250:  MOVF   xF4,W
07252:  SUBLW  04
07254:  BZ    7278
07256:  MOVLB  5
....................          {                                                                                         
....................             send_nack(command_id_received, mgr_msgSEQ, NACK_BITFIELD_INVALID_EEPROM_SETTINGS);     
07258:  MOVFF  547,54E
0725C:  MOVFF  549,550
07260:  MOVFF  548,54F
07264:  CLRF   x54
07266:  CLRF   x53
07268:  MOVLW  01
0726A:  MOVWF  x52
0726C:  CLRF   x51
0726E:  MOVLB  0
07270:  CALL   651A
....................          }                                                                                            
07274:  BRA    7330
07276:  MOVLB  2
....................          // valid location and number of bytes                      
....................          else                                    
....................          {                                                                                                 
....................             if (payload_buff[9] == 1) 
07278:  DECFSZ xF4,W
0727A:  BRA    72A2
....................             {                                 
....................                temp_uint32 = read_ee1(make16(payload_buff[8], payload_buff[7])); 
0727C:  MOVFF  2F3,54F
07280:  MOVFF  2F2,54E
07284:  MOVFF  2F3,551
07288:  MOVFF  2F2,550
0728C:  MOVLB  0
0728E:  CALL   3120
07292:  MOVLB  5
07294:  CLRF   x4D
07296:  CLRF   x4C
07298:  CLRF   x4B
0729A:  MOVFF  01,54A
....................             } 
0729E:  BRA    72FE
072A0:  MOVLB  2
....................             else if (payload_buff[9] == 2)                
072A2:  MOVF   xF4,W
072A4:  SUBLW  02
072A6:  BNZ   72D0
....................             {                                           
....................                temp_uint32 = read_ee2(make16(payload_buff[8], payload_buff[7]));        
072A8:  MOVFF  2F3,54F
072AC:  MOVFF  2F2,54E
072B0:  MOVFF  2F3,551
072B4:  MOVFF  2F2,550
072B8:  MOVLB  0
072BA:  CALL   3050
072BE:  MOVLB  5
072C0:  CLRF   x4D
072C2:  CLRF   x4C
072C4:  MOVFF  02,54B
072C8:  MOVFF  01,54A
....................             } 
072CC:  BRA    72FE
072CE:  MOVLB  2
....................             else if (payload_buff[9] == 4)                                            
072D0:  MOVF   xF4,W
072D2:  SUBLW  04
072D4:  BNZ   72FC
....................             { 
....................                temp_uint32 = read_ee4(make16(payload_buff[8], payload_buff[7])); 
072D6:  MOVFF  2F3,54F
072DA:  MOVFF  2F2,54E
072DE:  MOVFF  2F3,551
072E2:  MOVFF  2F2,550
072E6:  MOVLB  0
072E8:  CALL   3174
072EC:  MOVFF  03,54D
072F0:  MOVFF  02,54C
072F4:  MOVFF  01,54B
072F8:  MOVFF  00,54A
072FC:  MOVLB  5
....................             } 
....................             send_read_eeprom_response(command_id_received, mgr_msgSEQ, make16(payload_buff[8], payload_buff[7]), temp_uint32);   
072FE:  MOVFF  2F3,54F
07302:  MOVFF  2F2,54E
07306:  MOVFF  547,550
0730A:  MOVFF  549,552
0730E:  MOVFF  548,551
07312:  MOVFF  2F3,554
07316:  MOVFF  2F2,553
0731A:  MOVFF  54D,558
0731E:  MOVFF  54C,557
07322:  MOVFF  54B,556
07326:  MOVFF  54A,555
0732A:  MOVLB  0
0732C:  GOTO   6780
....................          } 
....................          break; 
07330:  MOVLB  5
07332:  BRA    7936
....................        
....................       case MSG_MGR_READ_XDCR:                                                     
....................          // if the type1 (fancy expensive all-sensors xdcrs) are connected    
....................          if (global_xcdr_type1_enabled)                                      
07334:  BTFSS  x9F.2
07336:  BRA    735A
....................          {                              
....................             // ack it (yes, because it takes ~50ms for the xdcr to settle, it must be an 
....................             //    unsolicited response that happens later) 
....................             send_ack(command_id_received, mgr_msgSEQ);       
07338:  MOVFF  547,54E
0733C:  MOVFF  549,550
07340:  MOVFF  548,54F
07344:  CALL   649E
....................             // schedule calibrate valve                               
....................             PUSH_PRIORITY_QUEUE_MACRO(TAKE_XCDR_MESUREMENT_1);   
07348:  BCF    F7A.1
0734A:  MOVLW  55
0734C:  MOVLB  5
0734E:  MOVWF  x50
07350:  MOVLB  0
07352:  CALL   43F2
07356:  BSF    F7A.1
....................          }                                       
07358:  BRA    7380
....................          // if a xdcr isn't connected, then nack it! 
....................          else                                
....................          {   
....................             temp_uint32 |= NACK_BITFIELD_INVALID_HARDWARE; 
0735A:  MOVLB  5
0735C:  BSF    x4A.7
....................             send_nack(command_id_received, mgr_msgSEQ, temp_uint32);   
0735E:  MOVFF  547,54E
07362:  MOVFF  549,550
07366:  MOVFF  548,54F
0736A:  MOVFF  54D,554
0736E:  MOVFF  54C,553
07372:  MOVFF  54B,552
07376:  MOVFF  54A,551
0737A:  MOVLB  0
0737C:  CALL   651A
....................          }        
....................          break;                                          
07380:  MOVLB  5
07382:  BRA    7936
....................                                                                      
....................           
.................... //////// Run/Test/Demo Commands////////         
....................       case MSG_MGR_RUN_CMD_NO_MOD: 
....................              
....................          if (global_valve_position == VLV_POSITION_UNKNOWN) 
07384:  INCFSZ xB9,W
07386:  BRA    7392
07388:  INCFSZ xBA,W
0738A:  BRA    7392
....................          { 
....................             temp_uint32 |= NACK_BITFIELD_VLV_POSITION_UNKNOWN; 
0738C:  MOVLB  5
0738E:  BSF    x4A.0
07390:  MOVLB  0
....................          } 
....................          if (!is_valve_position_valid(make16(payload_buff[16], payload_buff[15]))) 
07392:  MOVFF  2FB,54F
07396:  MOVFF  2FA,54E
0739A:  MOVFF  2FB,551
0739E:  MOVFF  2FA,550
073A2:  CALL   64F8
073A6:  MOVF   01,F
073A8:  BNZ   73B0
....................          { 
....................             temp_uint32 |= NACK_BITFIELD_INVALID_VLV_SETTING; 
073AA:  MOVLB  5
073AC:  BSF    x4A.1
073AE:  MOVLB  0
....................          } 
....................          if (!is_rpm_setting_valid(make16(payload_buff[18], payload_buff[17]))) 
073B0:  MOVFF  2FD,54F
073B4:  MOVFF  2FC,54E
073B8:  MOVFF  2FD,551
073BC:  MOVFF  2FC,550
073C0:  CALL   67DA
073C4:  MOVF   01,F
073C6:  BNZ   73CE
....................          { 
....................             temp_uint32 |= NACK_BITFIELD_INVALID_RPM_SETTING; 
073C8:  MOVLB  5
073CA:  BSF    x4A.2
073CC:  MOVLB  0
....................          } 
....................   
....................          // if the NACK bitfield contains anything, send the nack instead of proceeding 
....................          if (temp_uint32 != 0) 
073CE:  MOVLB  5
073D0:  MOVF   x4A,F
073D2:  BNZ   73E0
073D4:  MOVF   x4B,F
073D6:  BNZ   73E0
073D8:  MOVF   x4C,F
073DA:  BNZ   73E0
073DC:  MOVF   x4D,F
073DE:  BZ    7406
....................          { 
....................             send_nack(command_id_received, mgr_msgSEQ, temp_uint32);  
073E0:  MOVFF  547,54E
073E4:  MOVFF  549,550
073E8:  MOVFF  548,54F
073EC:  MOVFF  54D,554
073F0:  MOVFF  54C,553
073F4:  MOVFF  54B,552
073F8:  MOVFF  54A,551
073FC:  MOVLB  0
073FE:  CALL   651A
....................          }      
07402:  BRA    7490
07404:  MOVLB  5
....................          // add non-modulated run command to command queue  
....................          else 
....................          { 
....................             push_spinkler_queue(make32(payload_buff[10],payload_buff[9],payload_buff[8],payload_buff[7]), \ 
....................                make32(payload_buff[14],payload_buff[13],payload_buff[12],payload_buff[11]), \ 
....................                make16(payload_buff[16], payload_buff[15]), make16(payload_buff[18], payload_buff[17]), \ 
....................                0, BRAKE_AND_CHARGE_START); 
07406:  MOVFF  2F5,551
0740A:  MOVFF  2F4,550
0740E:  MOVFF  2F3,54F
07412:  MOVFF  2F2,54E
07416:  MOVFF  2F9,555
0741A:  MOVFF  2F8,554
0741E:  MOVFF  2F7,553
07422:  MOVFF  2F6,552
07426:  MOVFF  2FB,557
0742A:  MOVFF  2FA,556
0742E:  MOVFF  2FD,559
07432:  MOVFF  2FC,558
07436:  MOVFF  2F5,55D
0743A:  MOVFF  2F4,55C
0743E:  MOVFF  2F3,55B
07442:  MOVFF  2F2,55A
07446:  MOVFF  2F9,561
0744A:  MOVFF  2F8,560
0744E:  MOVFF  2F7,55F
07452:  MOVFF  2F6,55E
07456:  MOVFF  2FB,563
0745A:  MOVFF  2FA,562
0745E:  MOVFF  2FD,565
07462:  MOVFF  2FC,564
07466:  CLRF   x66
07468:  CLRF   x67
0746A:  MOVLB  0
0746C:  CALL   6808
....................              
....................             // have the micro check the battery to determine the proper charging 
....................             PUSH_PRIORITY_QUEUE_MACRO(CHECK_BATTERY_STATE);  
07470:  BCF    F7A.1
07472:  MOVLW  A1
07474:  MOVLB  5
07476:  MOVWF  x50
07478:  MOVLB  0
0747A:  CALL   43F2
0747E:  BSF    F7A.1
....................             send_sprinkler_cmd_response(command_id_received, mgr_msgSEQ); 
07480:  MOVFF  547,54E
07484:  MOVFF  549,550
07488:  MOVFF  548,54F
0748C:  GOTO   6A46
....................          } 
....................          break; 
07490:  MOVLB  5
07492:  BRA    7936
....................           
....................       case MSG_MGR_RUN_CMD_MOD: 
....................          // since this isn't implemented, nack it 
....................          temp_uint32 |= NACK_BITFIELD_INCOMPATIBLE_STATE;   
07494:  MOVLB  5
07496:  BSF    x4A.5
....................          send_nack(command_id_received, mgr_msgSEQ, temp_uint32); 
07498:  MOVFF  547,54E
0749C:  MOVFF  549,550
074A0:  MOVFF  548,54F
074A4:  MOVFF  54D,554
074A8:  MOVFF  54C,553
074AC:  MOVFF  54B,552
074B0:  MOVFF  54A,551
074B4:  MOVLB  0
074B6:  CALL   651A
....................                               
....................          // add modulated run command to command queue 
....................          // send_sprinkler_cmd_response(command_id_received, mgr_msgSEQ); 
....................          break; 
074BA:  MOVLB  5
074BC:  BRA    7936
....................                                                    
....................       case MSG_MGR_TEST_NO_RPM_CTRL: 
....................          if (global_system_state != SYSTEM_RUN) 
074BE:  MOVLB  4
074C0:  MOVF   xFD,W
074C2:  SUBLW  02
074C4:  BZ    74CC
....................          { 
....................             temp_uint32 |= NACK_BITFIELD_INCOMPATIBLE_STATE; 
074C6:  MOVLB  5
074C8:  BSF    x4A.5
074CA:  MOVLB  4
....................          } 
....................          if (global_valve_position == VLV_POSITION_UNKNOWN) 
074CC:  MOVLB  0
074CE:  INCFSZ xB9,W
074D0:  BRA    74DC
074D2:  INCFSZ xBA,W
074D4:  BRA    74DC
....................          { 
....................             temp_uint32 |= NACK_BITFIELD_VLV_POSITION_UNKNOWN; 
074D6:  MOVLB  5
074D8:  BSF    x4A.0
074DA:  MOVLB  0
....................          } 
....................          if (!is_valve_position_valid(make16(payload_buff[8], payload_buff[7]))) 
074DC:  MOVFF  2F3,54F
074E0:  MOVFF  2F2,54E
074E4:  MOVFF  2F3,551
074E8:  MOVFF  2F2,550
074EC:  CALL   64F8
074F0:  MOVF   01,F
074F2:  BNZ   74FA
....................          { 
....................             temp_uint32 |= NACK_BITFIELD_INVALID_VLV_SETTING; 
074F4:  MOVLB  5
074F6:  BSF    x4A.1
074F8:  MOVLB  0
....................          }  
....................          if (!is_brake_duty_valid(make16(payload_buff[10], payload_buff[9]))) 
074FA:  MOVFF  2F5,54F
074FE:  MOVFF  2F4,54E
07502:  MOVFF  2F5,551
07506:  MOVFF  2F4,550
0750A:  GOTO   6C5E
0750E:  MOVF   01,F
07510:  BNZ   7518
....................          { 
....................             temp_uint32 |= NACK_BITFIELD_INVALID_BRAKE_SETTING; 
07512:  MOVLB  5
07514:  BSF    x4A.3
07516:  MOVLB  0
....................          } 
....................          if (!is_charge_duty_valid(make16(payload_buff[12], payload_buff[11]))) 
07518:  MOVFF  2F7,54F
0751C:  MOVFF  2F6,54E
07520:  MOVFF  2F7,551
07524:  MOVFF  2F6,550
07528:  GOTO   6C82
0752C:  MOVF   01,F
0752E:  BNZ   7536
....................          { 
....................             temp_uint32 |= NACK_BITFIELD_INVALID_CHARGE_SETTING; 
07530:  MOVLB  5
07532:  BSF    x4A.4
07534:  MOVLB  0
....................          } 
....................          // if in mppc non-dynamic mode, check mppc 
....................          if ((payload_buff[14] == FALSE) && (!is_mppc_valid(payload_buff[13]))) 
07536:  MOVLB  2
07538:  MOVF   xF9,F
0753A:  BNZ   7556
0753C:  MOVFF  2F8,54E
07540:  MOVLB  0
07542:  GOTO   6CA6
07546:  MOVF   01,F
07548:  BTFSC  FD8.2
0754A:  BRA    7550
0754C:  MOVLB  2
0754E:  BRA    7556
....................          { 
....................             temp_uint32 |= NACK_BITFIELD_INVALID_MPPC_SETTING; 
07550:  MOVLB  5
07552:  BSF    x4B.1
07554:  MOVLB  2
....................          } 
....................           
....................          // if the NACK bitfield contains anything, send the nack instead of proceeding 
....................          if (temp_uint32 != 0) 
07556:  MOVLB  5
07558:  MOVF   x4A,F
0755A:  BNZ   7568
0755C:  MOVF   x4B,F
0755E:  BNZ   7568
07560:  MOVF   x4C,F
07562:  BNZ   7568
07564:  MOVF   x4D,F
07566:  BZ    758E
....................          { 
....................             send_nack(command_id_received, mgr_msgSEQ, temp_uint32); 
07568:  MOVFF  547,54E
0756C:  MOVFF  549,550
07570:  MOVFF  548,54F
07574:  MOVFF  54D,554
07578:  MOVFF  54C,553
0757C:  MOVFF  54B,552
07580:  MOVFF  54A,551
07584:  MOVLB  0
07586:  CALL   651A
....................          } 
0758A:  BRA    7608
0758C:  MOVLB  5
....................          // add non-modulated run command to command queue  
....................          else 
....................          { 
....................             // clear queue  
....................             clear_sprinkler_queue(); 
0758E:  MOVLB  0
07590:  CALL   50C0
....................              
....................             // set test parateters with no rpm control 
....................             push_spinkler_queue(0, 0-1,make16(payload_buff[8], payload_buff[7]), 0, \ 
....................                0, NO_RPM_CONTROL); 
07594:  MOVFF  2F3,54F
07598:  MOVFF  2F2,54E
0759C:  MOVLB  5
0759E:  CLRF   x5D
075A0:  CLRF   x5C
075A2:  CLRF   x5B
075A4:  CLRF   x5A
075A6:  SETF   x61
075A8:  SETF   x60
075AA:  SETF   x5F
075AC:  SETF   x5E
075AE:  MOVFF  2F3,563
075B2:  MOVFF  2F2,562
075B6:  CLRF   x65
075B8:  CLRF   x64
075BA:  CLRF   x66
075BC:  MOVLW  05
075BE:  MOVWF  x67
075C0:  MOVLB  0
075C2:  CALL   6808
....................                 
....................             global_brake_duty_set_value = (make16(payload_buff[10], payload_buff[9])); 
075C6:  MOVFF  2F5,AF
075CA:  MOVFF  2F4,AE
....................             global_charge_duty_set_value = (make16(payload_buff[12], payload_buff[11])); 
075CE:  MOVFF  2F7,B1
075D2:  MOVFF  2F6,B0
....................             global_mppc_set_value = payload_buff[13]; 
075D6:  MOVFF  2F8,B3
....................             if (payload_buff[14] == FALSE)  
075DA:  MOVLB  2
075DC:  MOVF   xF9,F
075DE:  BNZ   75EA
....................             { 
....................                global_control_loop_mechanism = NO_RPM_CONTROL; 
075E0:  MOVLW  05
075E2:  MOVLB  0
075E4:  MOVWF  xB8
....................             } 
075E6:  BRA    75F4
075E8:  MOVLB  2
....................             else if (payload_buff[14] == TRUE)  
075EA:  DECFSZ xF9,W
075EC:  BRA    75F6
....................             { 
....................                global_control_loop_mechanism = NO_RPM_CONTROL_DYN_MPPC; 
075EE:  MOVLW  06
075F0:  MOVLB  0
075F2:  MOVWF  xB8
075F4:  MOVLB  2
....................             } 
....................             send_full_report(command_id_received, mgr_msgSEQ); 
075F6:  MOVFF  547,54E
075FA:  MOVFF  549,550
075FE:  MOVFF  548,54F
07602:  MOVLB  0
07604:  CALL   5FD4
....................          } 
....................          break; 
07608:  MOVLB  5
0760A:  BRA    7936
....................           
....................       case MSG_MGR_TEST_RPM_CTRL: 
....................          if (global_system_state != SYSTEM_RUN) 
0760C:  MOVLB  4
0760E:  MOVF   xFD,W
07610:  SUBLW  02
07612:  BZ    761A
....................          { 
....................             temp_uint32 |= NACK_BITFIELD_INCOMPATIBLE_STATE; 
07614:  MOVLB  5
07616:  BSF    x4A.5
07618:  MOVLB  4
....................          } 
....................          if (global_valve_position == VLV_POSITION_UNKNOWN) 
0761A:  MOVLB  0
0761C:  INCFSZ xB9,W
0761E:  BRA    762A
07620:  INCFSZ xBA,W
07622:  BRA    762A
....................          { 
....................             temp_uint32 |= NACK_BITFIELD_VLV_POSITION_UNKNOWN; 
07624:  MOVLB  5
07626:  BSF    x4A.0
07628:  MOVLB  0
....................          } 
....................          if (!is_valve_position_valid(make16(payload_buff[8], payload_buff[7]))) 
0762A:  MOVFF  2F3,54F
0762E:  MOVFF  2F2,54E
07632:  MOVFF  2F3,551
07636:  MOVFF  2F2,550
0763A:  CALL   64F8
0763E:  MOVF   01,F
07640:  BNZ   7648
....................          { 
....................             temp_uint32 |= NACK_BITFIELD_INVALID_VLV_SETTING; 
07642:  MOVLB  5
07644:  BSF    x4A.1
07646:  MOVLB  0
....................          } 
....................          if (!is_rpm_setting_valid(make16(payload_buff[10], payload_buff[9]))) 
07648:  MOVFF  2F5,54F
0764C:  MOVFF  2F4,54E
07650:  MOVFF  2F5,551
07654:  MOVFF  2F4,550
07658:  CALL   67DA
0765C:  MOVF   01,F
0765E:  BNZ   7666
....................          { 
....................             temp_uint32 |= NACK_BITFIELD_INVALID_RPM_SETTING; 
07660:  MOVLB  5
07662:  BSF    x4A.2
07664:  MOVLB  0
....................          } 
....................           
....................          // if the NACK bitfield contains anything, send the nack instead of proceeding 
....................          if (temp_uint32 != 0) 
07666:  MOVLB  5
07668:  MOVF   x4A,F
0766A:  BNZ   7678
0766C:  MOVF   x4B,F
0766E:  BNZ   7678
07670:  MOVF   x4C,F
07672:  BNZ   7678
07674:  MOVF   x4D,F
07676:  BZ    769E
....................          { 
....................             send_nack(command_id_received, mgr_msgSEQ, temp_uint32); 
07678:  MOVFF  547,54E
0767C:  MOVFF  549,550
07680:  MOVFF  548,54F
07684:  MOVFF  54D,554
07688:  MOVFF  54C,553
0768C:  MOVFF  54B,552
07690:  MOVFF  54A,551
07694:  MOVLB  0
07696:  CALL   651A
....................          } 
0769A:  BRA    7700
0769C:  MOVLB  5
....................          // add non-modulated run command to command queue  
....................          else 
....................          { 
....................             // clear queue  
....................             clear_sprinkler_queue(); 
0769E:  MOVLB  0
076A0:  CALL   50C0
....................              
....................             // set test parateters with rpm control 
....................             push_spinkler_queue(0, 0-1,make16(payload_buff[8], payload_buff[7]), \ 
....................                make16(payload_buff[10], payload_buff[9]), 0, BRAKE_AND_CHARGE_START); 
076A4:  MOVFF  2F3,54F
076A8:  MOVFF  2F2,54E
076AC:  MOVFF  2F5,551
076B0:  MOVFF  2F4,550
076B4:  MOVLB  5
076B6:  CLRF   x5D
076B8:  CLRF   x5C
076BA:  CLRF   x5B
076BC:  CLRF   x5A
076BE:  SETF   x61
076C0:  SETF   x60
076C2:  SETF   x5F
076C4:  SETF   x5E
076C6:  MOVFF  2F3,563
076CA:  MOVFF  2F2,562
076CE:  MOVFF  2F5,565
076D2:  MOVFF  2F4,564
076D6:  CLRF   x66
076D8:  CLRF   x67
076DA:  MOVLB  0
076DC:  CALL   6808
....................                 
....................             PUSH_PRIORITY_QUEUE_MACRO(MOVE_VALVE); 
076E0:  BCF    F7A.1
076E2:  MOVLW  40
076E4:  MOVLB  5
076E6:  MOVWF  x50
076E8:  MOVLB  0
076EA:  CALL   43F2
076EE:  BSF    F7A.1
....................             send_full_report(command_id_received, mgr_msgSEQ); 
076F0:  MOVFF  547,54E
076F4:  MOVFF  549,550
076F8:  MOVFF  548,54F
076FC:  CALL   5FD4
....................          } 
....................          break;   
07700:  MOVLB  5
07702:  BRA    7936
....................       case MSG_MGR_DEMO: 
....................          if (global_system_state != SYSTEM_RUN) 
07704:  MOVLB  4
07706:  MOVF   xFD,W
07708:  SUBLW  02
0770A:  BZ    7712
....................          {                
....................             temp_uint32 |= NACK_BITFIELD_INCOMPATIBLE_STATE; 
0770C:  MOVLB  5
0770E:  BSF    x4A.5
07710:  MOVLB  4
....................          } 
....................          if (global_valve_position == VLV_POSITION_UNKNOWN) 
07712:  MOVLB  0
07714:  INCFSZ xB9,W
07716:  BRA    7722
07718:  INCFSZ xBA,W
0771A:  BRA    7722
....................          { 
....................             temp_uint32 |= NACK_BITFIELD_VLV_POSITION_UNKNOWN; 
0771C:  MOVLB  5
0771E:  BSF    x4A.0
07720:  MOVLB  0
....................          } 
....................          // if the NACK bitfield contains anything, send the nack instead of proceeding 
....................          if (temp_uint32 != 0) 
07722:  MOVLB  5
07724:  MOVF   x4A,F
07726:  BNZ   7734
07728:  MOVF   x4B,F
0772A:  BNZ   7734
0772C:  MOVF   x4C,F
0772E:  BNZ   7734
07730:  MOVF   x4D,F
07732:  BZ    775A
....................          { 
....................             send_nack(command_id_received, mgr_msgSEQ, temp_uint32); 
07734:  MOVFF  547,54E
07738:  MOVFF  549,550
0773C:  MOVFF  548,54F
07740:  MOVFF  54D,554
07744:  MOVFF  54C,553
07748:  MOVFF  54B,552
0774C:  MOVFF  54A,551
07750:  MOVLB  0
07752:  CALL   651A
....................          } 
07756:  BRA    791C
07758:  MOVLB  5
....................          else 
....................          { 
....................             clear_sprinkler_queue(); 
0775A:  MOVLB  0
0775C:  CALL   50C0
....................             push_spinkler_queue(global_utc_time, global_utc_time + 30, 0x4000, 100, 0, BRAKE_AND_CHARGE_START); 
07760:  MOVLW  1E
07762:  ADDWF  x89,W
07764:  MOVLB  5
07766:  MOVWF  x4E
07768:  MOVLW  00
0776A:  MOVLB  0
0776C:  ADDWFC x8A,W
0776E:  MOVLB  5
07770:  MOVWF  x4F
07772:  MOVLW  00
07774:  MOVLB  0
07776:  ADDWFC x8B,W
07778:  MOVLB  5
0777A:  MOVWF  x50
0777C:  MOVLW  00
0777E:  MOVLB  0
07780:  ADDWFC x8C,W
07782:  MOVLB  5
07784:  MOVWF  x51
07786:  MOVFF  8C,55D
0778A:  MOVFF  8B,55C
0778E:  MOVFF  8A,55B
07792:  MOVFF  89,55A
07796:  MOVWF  x61
07798:  MOVFF  550,560
0779C:  MOVFF  54F,55F
077A0:  MOVFF  54E,55E
077A4:  MOVLW  40
077A6:  MOVWF  x63
077A8:  CLRF   x62
077AA:  CLRF   x65
077AC:  MOVLW  64
077AE:  MOVWF  x64
077B0:  CLRF   x66
077B2:  CLRF   x67
077B4:  MOVLB  0
077B6:  CALL   6808
....................             push_spinkler_queue(global_utc_time + 30, global_utc_time + 60, 0x4000, 50, 0, BRAKE_AND_CHARGE_START); 
077BA:  MOVLW  1E
077BC:  ADDWF  x89,W
077BE:  MOVLB  5
077C0:  MOVWF  x4E
077C2:  MOVLW  00
077C4:  MOVLB  0
077C6:  ADDWFC x8A,W
077C8:  MOVLB  5
077CA:  MOVWF  x4F
077CC:  MOVLW  00
077CE:  MOVLB  0
077D0:  ADDWFC x8B,W
077D2:  MOVLB  5
077D4:  MOVWF  x50
077D6:  MOVLW  00
077D8:  MOVLB  0
077DA:  ADDWFC x8C,W
077DC:  MOVLB  5
077DE:  MOVWF  x51
077E0:  MOVLW  3C
077E2:  MOVLB  0
077E4:  ADDWF  x89,W
077E6:  MOVLB  5
077E8:  MOVWF  x52
077EA:  MOVLW  00
077EC:  MOVLB  0
077EE:  ADDWFC x8A,W
077F0:  MOVLB  5
077F2:  MOVWF  x53
077F4:  MOVLW  00
077F6:  MOVLB  0
077F8:  ADDWFC x8B,W
077FA:  MOVLB  5
077FC:  MOVWF  x54
077FE:  MOVLW  00
07800:  MOVLB  0
07802:  ADDWFC x8C,W
07804:  MOVLB  5
07806:  MOVWF  x55
07808:  MOVFF  551,55D
0780C:  MOVFF  550,55C
07810:  MOVFF  54F,55B
07814:  MOVFF  54E,55A
07818:  MOVWF  x61
0781A:  MOVFF  554,560
0781E:  MOVFF  553,55F
07822:  MOVFF  552,55E
07826:  MOVLW  40
07828:  MOVWF  x63
0782A:  CLRF   x62
0782C:  CLRF   x65
0782E:  MOVLW  32
07830:  MOVWF  x64
07832:  CLRF   x66
07834:  CLRF   x67
07836:  MOVLB  0
07838:  CALL   6808
....................             push_spinkler_queue(global_utc_time + 60, global_utc_time + 90, 0x4000, 10, 0, BRAKE_AND_CHARGE_START); 
0783C:  MOVLW  3C
0783E:  ADDWF  x89,W
07840:  MOVLB  5
07842:  MOVWF  x4E
07844:  MOVLW  00
07846:  MOVLB  0
07848:  ADDWFC x8A,W
0784A:  MOVLB  5
0784C:  MOVWF  x4F
0784E:  MOVLW  00
07850:  MOVLB  0
07852:  ADDWFC x8B,W
07854:  MOVLB  5
07856:  MOVWF  x50
07858:  MOVLW  00
0785A:  MOVLB  0
0785C:  ADDWFC x8C,W
0785E:  MOVLB  5
07860:  MOVWF  x51
07862:  MOVLW  5A
07864:  MOVLB  0
07866:  ADDWF  x89,W
07868:  MOVLB  5
0786A:  MOVWF  x52
0786C:  MOVLW  00
0786E:  MOVLB  0
07870:  ADDWFC x8A,W
07872:  MOVLB  5
07874:  MOVWF  x53
07876:  MOVLW  00
07878:  MOVLB  0
0787A:  ADDWFC x8B,W
0787C:  MOVLB  5
0787E:  MOVWF  x54
07880:  MOVLW  00
07882:  MOVLB  0
07884:  ADDWFC x8C,W
07886:  MOVLB  5
07888:  MOVWF  x55
0788A:  MOVFF  551,55D
0788E:  MOVFF  550,55C
07892:  MOVFF  54F,55B
07896:  MOVFF  54E,55A
0789A:  MOVWF  x61
0789C:  MOVFF  554,560
078A0:  MOVFF  553,55F
078A4:  MOVFF  552,55E
078A8:  MOVLW  40
078AA:  MOVWF  x63
078AC:  CLRF   x62
078AE:  CLRF   x65
078B0:  MOVLW  0A
078B2:  MOVWF  x64
078B4:  CLRF   x66
078B6:  CLRF   x67
078B8:  MOVLB  0
078BA:  CALL   6808
....................             push_spinkler_queue(global_utc_time + 90, 0-1, VLV_POSITION_CLOSED, 0, 0, BRAKE_AND_CHARGE_START); 
078BE:  MOVLW  5A
078C0:  ADDWF  x89,W
078C2:  MOVLB  5
078C4:  MOVWF  x4E
078C6:  MOVLW  00
078C8:  MOVLB  0
078CA:  ADDWFC x8A,W
078CC:  MOVLB  5
078CE:  MOVWF  x4F
078D0:  MOVLW  00
078D2:  MOVLB  0
078D4:  ADDWFC x8B,W
078D6:  MOVLB  5
078D8:  MOVWF  x50
078DA:  MOVLW  00
078DC:  MOVLB  0
078DE:  ADDWFC x8C,W
078E0:  MOVLB  5
078E2:  MOVWF  x51
078E4:  MOVWF  x5D
078E6:  MOVFF  550,55C
078EA:  MOVFF  54F,55B
078EE:  MOVFF  54E,55A
078F2:  SETF   x61
078F4:  SETF   x60
078F6:  SETF   x5F
078F8:  SETF   x5E
078FA:  CLRF   x63
078FC:  CLRF   x62
078FE:  CLRF   x65
07900:  CLRF   x64
07902:  CLRF   x66
07904:  CLRF   x67
07906:  MOVLB  0
07908:  CALL   6808
....................             send_ack(command_id_received, mgr_msgSEQ); 
0790C:  MOVFF  547,54E
07910:  MOVFF  549,550
07914:  MOVFF  548,54F
07918:  CALL   649E
....................             // add demo mode stuff to commmand queue 
....................          } 
....................       case MSG_MGR_CLEAR_SPINKLER_CMD_QUEUE: 
....................          clear_sprinkler_queue(); 
0791C:  CALL   50C0
....................          send_full_report(command_id_received, mgr_msgSEQ); 
07920:  MOVFF  547,54E
07924:  MOVFF  549,550
07928:  MOVFF  548,54F
0792C:  CALL   5FD4
....................          break;            
07930:  MOVLB  5
07932:  BRA    7936
07934:  MOVLB  5
07936:  MOVLB  2
....................    }     
07938:  MOVLB  0
0793A:  GOTO   9B8C (RETURN)
.................... }  // deal_with_packet 
....................  
....................  
.................... void prepare_prefix_and_payload(uint8_t payload_buf_length) 
.................... { 
....................       // Setup send_prefix 
....................       send_prefix[0] = CMD_SEND; 
*
05B62:  MOVLW  05
05B64:  MOVLB  3
05B66:  MOVWF  x4B
....................       // set the size part of the prefix to payload length + 9 other bytes 
....................       send_prefix[1] = payload_buf_length + 9; 
05B68:  MOVLW  09
05B6A:  MOVLB  5
05B6C:  ADDWF  x59,W
05B6E:  MOVLB  3
05B70:  MOVWF  x4C
....................       send_prefix[2] = FLAG_SEND_REQUEST; 
05B72:  MOVLW  04
05B74:  MOVWF  x4D
....................       send_prefix[3] = DESTADDR_HI; 
05B76:  MOVLW  F9
05B78:  MOVWF  x4E
....................       send_prefix[4] = DESTADDR_LO; 
05B7A:  MOVLW  81
05B7C:  MOVWF  x4F
....................       // setup the ???? 
....................       send_prefix[5] = svc_index_rcvd; 
05B7E:  MOVFF  35C,350
....................       send_prefix[6] = APPDOMAIN_MAINTENANCE; 
05B82:  MOVLW  02
05B84:  MOVWF  x51
....................       send_prefix[7] = PRIORITY_HI; 
05B86:  MOVWF  x52
....................       send_prefix[8] = 0; 
05B88:  CLRF   x53
....................       send_prefix[9] = 0; 
05B8A:  CLRF   x54
....................       send_prefix[10] = 0xFF; 
05B8C:  SETF   x55
....................       send_prefix[11] = payload_buf_length; 
05B8E:  MOVFF  559,356
....................       payload_buff[0] = 0x00; 
05B92:  MOVLB  2
05B94:  CLRF   xEB
....................       payload_buff[1] = 0x00; 
05B96:  CLRF   xEC
....................       payload_buff[2] = 0xFC; 
05B98:  MOVLW  FC
05B9A:  MOVWF  xED
....................       payload_buff[3] = 0x12;  
05B9C:  MOVLW  12
05B9E:  MOVWF  xEE
05BA0:  MOVLB  0
05BA2:  RETURN 0
.................... } 
.................... void prepare_prefix_and_payload_ISR(uint8_t payload_buf_length) 
.................... { 
....................       // Setup send_prefix 
....................       send_prefix[0] = CMD_SEND; 
*
02214:  MOVLW  05
02216:  MOVLB  3
02218:  MOVWF  x4B
....................       // set the size part of the prefix to payload length + 9 other bytes 
....................       send_prefix[1] = payload_buf_length + 9; 
0221A:  MOVLW  09
0221C:  MOVLB  5
0221E:  ADDWF  x8F,W
02220:  MOVLB  3
02222:  MOVWF  x4C
....................       send_prefix[2] = FLAG_SEND_REQUEST; 
02224:  MOVLW  04
02226:  MOVWF  x4D
....................       send_prefix[3] = DESTADDR_HI; 
02228:  MOVLW  F9
0222A:  MOVWF  x4E
....................       send_prefix[4] = DESTADDR_LO; 
0222C:  MOVLW  81
0222E:  MOVWF  x4F
....................       // setup the ???? 
....................       send_prefix[5] = svc_index_rcvd; 
02230:  MOVFF  35C,350
....................       send_prefix[6] = APPDOMAIN_MAINTENANCE; 
02234:  MOVLW  02
02236:  MOVWF  x51
....................       send_prefix[7] = PRIORITY_HI;                                                                       
02238:  MOVWF  x52
....................       send_prefix[8] = 0; 
0223A:  CLRF   x53
....................       send_prefix[9] = 0; 
0223C:  CLRF   x54
....................       send_prefix[10] = 0xFF; 
0223E:  SETF   x55
....................       send_prefix[11] = payload_buf_length; 
02240:  MOVFF  58F,356
....................       payload_buff[0] = 0x00; 
02244:  MOVLB  2
02246:  CLRF   xEB
....................       payload_buff[1] = 0x00; 
02248:  CLRF   xEC
....................       payload_buff[2] = 0xFC;                           
0224A:  MOVLW  FC
0224C:  MOVWF  xED
....................       payload_buff[3] = 0x12;  
0224E:  MOVLW  12
02250:  MOVWF  xEE
02252:  MOVLB  0
02254:  RETURN 0
.................... } 
.................... void generate_message_and_send() 
.................... { 
....................    uint8_t n, res_byte; 
....................    // generate the message 
....................    dust_hdlc_pkgen(send_prefix, 12, payload_buff, send_prefix[11]); 
*
05F7A:  MOVLW  03
05F7C:  MOVLB  5
05F7E:  MOVWF  x62
05F80:  MOVLW  4B
05F82:  MOVWF  x61
05F84:  MOVLW  0C
05F86:  MOVWF  x63
05F88:  MOVLW  02
05F8A:  MOVWF  x65
05F8C:  MOVLW  EB
05F8E:  MOVWF  x64
05F90:  MOVFF  356,566
05F94:  MOVLB  0
05F96:  RCALL  5C1A
....................     
....................    // try to send the message a 3 times 
....................    for (n = 0; n < 3; n++) 
05F98:  MOVLB  5
05F9A:  CLRF   x59
05F9C:  MOVF   x59,W
05F9E:  SUBLW  02
05FA0:  BNC   5FD0
....................    { 
....................       // try to send the message 
....................       res_byte = dust_hdlc_pksend();    
05FA2:  MOVLB  0
05FA4:  RCALL  5EC4
05FA6:  MOVFF  01,55A
....................       // timeout of 50ms if pksend returns an error 
....................       setup_T0_int(T0_50MS); 
05FAA:  MOVLB  5
05FAC:  SETF   x65
05FAE:  MOVLW  3D
05FB0:  MOVWF  x64
05FB2:  MOVLB  0
05FB4:  CALL   356C
....................       // if the message doesn't return no error, try sending again 
....................       while ((res_byte != NO_ERR) && !TMR0IF);        
05FB8:  MOVLB  5
05FBA:  MOVF   x5A,F
05FBC:  BZ    5FC2
05FBE:  BTFSS  FF2.2
05FC0:  BRA    5FBA
....................       if (TMR0IF) 
05FC2:  BTFSS  FF2.2
05FC4:  BRA    5FCA
....................          continue; 
05FC6:  BRA    5FCC
05FC8:  BRA    5FCC
....................       else 
....................          break; 
05FCA:  BRA    5FD0
05FCC:  INCF   x59,F
05FCE:  BRA    5F9C
....................    } 
05FD0:  MOVLB  0
05FD2:  RETURN 0
.................... } 
.................... void generate_message_and_send_ISR() 
.................... { 
....................    uint8_t n, res_byte; 
....................    // generate the message 
....................    dust_hdlc_pkgen_ISR(send_prefix, 12, payload_buff, send_prefix[11]); 
*
022B0:  MOVLW  03
022B2:  MOVLB  5
022B4:  MOVWF  x9C
022B6:  MOVLW  4B
022B8:  MOVWF  x9B
022BA:  MOVLW  0C
022BC:  MOVWF  x9D
022BE:  MOVLW  02
022C0:  MOVWF  x9F
022C2:  MOVLW  EB
022C4:  MOVWF  x9E
022C6:  MOVFF  356,5A0
022CA:  MOVLB  0
022CC:  CALL   0E7E
....................                                     
....................    // try to send the message a 3 times 
....................    for (n = 0; n < 3; n++) 
022D0:  MOVLB  5
022D2:  CLRF   x8F
022D4:  MOVF   x8F,W
022D6:  SUBLW  02
022D8:  BNC   2308
....................    { 
....................       // try to send the message 
....................       res_byte = dust_hdlc_pksend_ISR();    
022DA:  MOVLB  0
022DC:  CALL   1140
022E0:  MOVFF  01,590
....................       // timeout of 50ms if pksend returns an error 
....................       setup_T4_int(T4_50MS);  
022E4:  MOVLW  C7
022E6:  MOVLB  5
022E8:  MOVWF  xA0
022EA:  MOVLB  0
022EC:  CALL   08DE
....................       // if the message doesn't return no error, try sending again 
....................       while ((res_byte != NO_ERR) && !TMR0IF);        
022F0:  MOVLB  5
022F2:  MOVF   x90,F
022F4:  BZ    22FA
022F6:  BTFSS  FF2.2
022F8:  BRA    22F2
....................       if (TMR4IF) 
022FA:  BTFSS  F7E.0
022FC:  BRA    2302
....................          continue; 
022FE:  BRA    2304
02300:  BRA    2304
....................       else 
....................          break; 
02302:  BRA    2308
02304:  INCF   x8F,F
02306:  BRA    22D4
....................    } 
02308:  MOVLB  0
0230A:  RETURN 0
.................... } 
.................... void send_full_report(uint8_t command_id_in_response_to, uint16_t msg_seq) 
.................... { 
....................    uint16_t temp_u16; 
....................    //flash led to help identifying motes  
....................    prepare_prefix_and_payload(58); 
*
05FD4:  MOVLW  3A
05FD6:  MOVLB  5
05FD8:  MOVWF  x59
05FDA:  MOVLB  0
05FDC:  RCALL  5B62
....................    payload_buff[4] = make8(msg_seq,0); 
05FDE:  MOVFF  54F,2EF
05FE2:  MOVLB  2
....................    payload_buff[5] = make8(msg_seq,1); 
05FE4:  MOVFF  550,2F0
05FE8:  MOVLB  2
....................    payload_buff[6] = command_id_in_response_to; 
05FEA:  MOVFF  54E,2F1
....................    payload_buff[7] = MSG_MOTE_FULL_REPORT; 
05FEE:  MOVLW  90
05FF0:  MOVWF  xF2
....................    payload_buff[8] = make8(global_sprinkler_num, 0); 
05FF2:  MOVFF  8D,2F3
05FF6:  MOVLB  2
....................    payload_buff[9] = make8(global_sprinkler_num, 1); 
05FF8:  MOVFF  8E,2F4
05FFC:  MOVLB  2
....................    payload_buff[10] = global_hardware_enabled; 
05FFE:  MOVFF  9F,2F5
....................    payload_buff[11] = global_system_state; 
06002:  MOVFF  4FD,2F6
....................    // vbatt(unchanged charge state) 
....................    temp_u16 = get_vbatt(0); 
06006:  MOVLB  5
06008:  CLRF   x53
0600A:  MOVLB  0
0600C:  CALL   3F5E
06010:  MOVFF  02,552
06014:  MOVFF  01,551
....................    payload_buff[12] = make8(temp_u16, 0); 
06018:  MOVFF  551,2F7
0601C:  MOVLB  2
....................    payload_buff[13] = make8(temp_u16, 1); 
0601E:  MOVFF  552,2F8
06022:  MOVLB  2
....................    // vbatt(no charging)        
....................    temp_u16 = get_vbatt(1); 
06024:  MOVLW  01
06026:  MOVLB  5
06028:  MOVWF  x53
0602A:  MOVLB  0
0602C:  CALL   3F5E
06030:  MOVFF  02,552
06034:  MOVFF  01,551
....................    payload_buff[14] = make8(temp_u16, 0); 
06038:  MOVFF  551,2F9
0603C:  MOVLB  2
....................    payload_buff[15] = make8(temp_u16, 1); 
0603E:  MOVFF  552,2FA
06042:  MOVLB  2
....................    // vgen(unchanged charge state) 
....................    temp_u16 = get_vgen(0); 
06044:  MOVLB  5
06046:  CLRF   x53
06048:  MOVLB  0
0604A:  CALL   3FB8
0604E:  MOVFF  02,552
06052:  MOVFF  01,551
....................    payload_buff[16] = make8(temp_u16, 0); 
06056:  MOVFF  551,2FB
0605A:  MOVLB  2
....................    payload_buff[17] = make8(temp_u16, 1);       
0605C:  MOVFF  552,2FC
06060:  MOVLB  2
....................    disable_interrupts(INT_CCP5);              
06062:  BCF    F7A.2
....................    temp_u16 = convert_period_to_rpm(global_current_period); 
06064:  MOVFF  A1,554
06068:  MOVFF  A0,553
0606C:  MOVLB  0
0606E:  RCALL  5BA4
06070:  MOVFF  02,552
06074:  MOVFF  01,551
....................    enable_interrupts(INT_CCP5); 
06078:  BSF    F7A.2
....................    payload_buff[18] = make8(temp_u16, 0); 
0607A:  MOVFF  551,2FD
0607E:  MOVLB  2
....................    payload_buff[19] = make8(temp_u16, 1);                
06080:  MOVFF  552,2FE
06084:  MOVLB  2
....................    payload_buff[20] = make8(global_rpm_set_value,0); 
06086:  MOVFF  A4,2FF
0608A:  MOVLB  2
....................    payload_buff[21] = make8(global_rpm_set_value,1); 
0608C:  MOVFF  A5,300
06090:  MOVLB  3
....................    disable_interrupts(INT_CCP4); 
06092:  BCF    F7A.1
....................    if (global_current_sprinkler_queue_location != 255) 
06094:  MOVLB  4
06096:  INCFSZ x21,W
06098:  BRA    609C
0609A:  BRA    6102
....................    { 
....................       payload_buff[22] = make8(global_sprinkler_queue[global_current_sprinkler_queue_location].spin_rate,0); 
0609C:  MOVF   x21,W
0609E:  MULLW  0E
060A0:  MOVF   FF3,W
060A2:  MOVLB  5
060A4:  CLRF   x54
060A6:  MOVWF  x53
060A8:  MOVLW  0A
060AA:  ADDWF  x53,W
060AC:  MOVWF  01
060AE:  MOVLW  00
060B0:  ADDWFC x54,W
060B2:  MOVWF  03
060B4:  MOVF   01,W
060B6:  ADDLW  95
060B8:  MOVWF  FE9
060BA:  MOVLW  03
060BC:  ADDWFC 03,W
060BE:  MOVWF  FEA
060C0:  MOVFF  FEC,554
060C4:  MOVF   FED,F
060C6:  MOVFF  FEF,301
060CA:  MOVLB  3
....................       payload_buff[23] = make8(global_sprinkler_queue[global_current_sprinkler_queue_location].spin_rate,1); 
060CC:  MOVLB  4
060CE:  MOVF   x21,W
060D0:  MULLW  0E
060D2:  MOVF   FF3,W
060D4:  MOVLB  5
060D6:  CLRF   x54
060D8:  MOVWF  x53
060DA:  MOVLW  0A
060DC:  ADDWF  x53,W
060DE:  MOVWF  01
060E0:  MOVLW  00
060E2:  ADDWFC x54,W
060E4:  MOVWF  03
060E6:  MOVF   01,W
060E8:  ADDLW  95
060EA:  MOVWF  FE9
060EC:  MOVLW  03
060EE:  ADDWFC 03,W
060F0:  MOVWF  FEA
060F2:  MOVFF  FEC,302
060F6:  MOVF   FED,F
060F8:  MOVFF  FEF,553
060FC:  MOVLB  3
....................    } 
060FE:  BRA    6108
06100:  MOVLB  4
....................    else 
....................    { 
....................       payload_buff[22] = 0; 
06102:  MOVLB  3
06104:  CLRF   x01
....................       payload_buff[23] = 0; 
06106:  CLRF   x02
....................    } 
....................    payload_buff[24] = make8(global_brake_duty,0); 
06108:  MOVFF  AA,303
0610C:  MOVLB  3
....................    payload_buff[25] = make8(global_brake_duty,1); 
0610E:  MOVFF  AB,304
06112:  MOVLB  3
....................    payload_buff[26] = make8(global_brake_duty_set_value,0); 
06114:  MOVFF  AE,305
06118:  MOVLB  3
....................    payload_buff[27] = make8(global_brake_duty_set_value,1); 
0611A:  MOVFF  AF,306
0611E:  MOVLB  3
....................    payload_buff[28] = make8(global_charge_duty,0); 
06120:  MOVFF  AC,307
06124:  MOVLB  3
....................    payload_buff[29] = make8(global_charge_duty,1); 
06126:  MOVFF  AD,308
0612A:  MOVLB  3
....................    payload_buff[30] = make8(global_charge_duty_set_value,0); 
0612C:  MOVFF  B0,309
06130:  MOVLB  3
....................    payload_buff[31] = make8(global_charge_duty_set_value,1); 
06132:  MOVFF  B1,30A
06136:  MOVLB  3
....................    payload_buff[32] = global_mppc_value; 
06138:  MOVFF  B2,30B
....................    payload_buff[33] = global_control_loop_mechanism; 
0613C:  MOVFF  B8,30C
....................    payload_buff[34] = make8(global_calibrate_fsr_valve_position, 0); 
06140:  MOVFF  C8,30D
06144:  MOVLB  3
....................    payload_buff[35] = make8(global_calibrate_fsr_valve_position, 1); 
06146:  MOVFF  C9,30E
0614A:  MOVLB  3
....................    temp_u16 = convert_period_to_rpm(global_calibrate_fsr_period); 
0614C:  MOVFF  CB,554
06150:  MOVFF  CA,553
06154:  MOVLB  0
06156:  RCALL  5BA4
06158:  MOVFF  02,552
0615C:  MOVFF  01,551
....................    payload_buff[36] = make8(temp_u16, 0); 
06160:  MOVFF  551,30F
06164:  MOVLB  3
....................    payload_buff[37] = make8(temp_u16, 1); 
06166:  MOVFF  552,310
0616A:  MOVLB  3
....................    payload_buff[38] = LATE; 
0616C:  MOVFF  F8D,311
....................    payload_buff[39] = make8(global_valve_position,0); 
06170:  MOVFF  B9,312
06174:  MOVLB  3
....................    payload_buff[40] = make8(global_valve_position,1); 
06176:  MOVFF  BA,313
0617A:  MOVLB  3
....................    payload_buff[41] = make8(global_valve_position_set_value,0); 
0617C:  MOVFF  BB,314
06180:  MOVLB  3
....................    payload_buff[42] = make8(global_valve_position_set_value,1); 
06182:  MOVFF  BC,315
06186:  MOVLB  3
....................    if (global_current_sprinkler_queue_location != 255) 
06188:  MOVLB  4
0618A:  INCFSZ x21,W
0618C:  BRA    6190
0618E:  BRA    62A6
....................    { 
....................       payload_buff[43] = make8(global_sprinkler_queue[global_current_sprinkler_queue_location].vlv_open_amount,0); 
06190:  MOVF   x21,W
06192:  MULLW  0E
06194:  MOVF   FF3,W
06196:  MOVLB  5
06198:  CLRF   x54
0619A:  MOVWF  x53
0619C:  MOVLW  08
0619E:  ADDWF  x53,W
061A0:  MOVWF  01
061A2:  MOVLW  00
061A4:  ADDWFC x54,W
061A6:  MOVWF  03
061A8:  MOVF   01,W
061AA:  ADDLW  95
061AC:  MOVWF  FE9
061AE:  MOVLW  03
061B0:  ADDWFC 03,W
061B2:  MOVWF  FEA
061B4:  MOVFF  FEC,554
061B8:  MOVF   FED,F
061BA:  MOVFF  FEF,316
061BE:  MOVLB  3
....................       payload_buff[44] = make8(global_sprinkler_queue[global_current_sprinkler_queue_location].vlv_open_amount,1); 
061C0:  MOVLB  4
061C2:  MOVF   x21,W
061C4:  MULLW  0E
061C6:  MOVF   FF3,W
061C8:  MOVLB  5
061CA:  CLRF   x54
061CC:  MOVWF  x53
061CE:  MOVLW  08
061D0:  ADDWF  x53,W
061D2:  MOVWF  01
061D4:  MOVLW  00
061D6:  ADDWFC x54,W
061D8:  MOVWF  03
061DA:  MOVF   01,W
061DC:  ADDLW  95
061DE:  MOVWF  FE9
061E0:  MOVLW  03
061E2:  ADDWFC 03,W
061E4:  MOVWF  FEA
061E6:  MOVFF  FEC,317
061EA:  MOVF   FED,F
061EC:  MOVFF  FEF,553
061F0:  MOVLB  3
....................       payload_buff[45] = make8(global_sprinkler_queue[global_current_sprinkler_queue_location].start_time,0); 
061F2:  MOVLB  4
061F4:  MOVF   x21,W
061F6:  MULLW  0E
061F8:  MOVF   FF3,W
061FA:  MOVLB  5
061FC:  CLRF   x54
061FE:  MOVWF  x53
06200:  MOVLW  95
06202:  ADDWF  x53,W
06204:  MOVWF  FE9
06206:  MOVLW  03
06208:  ADDWFC x54,W
0620A:  MOVWF  FEA
0620C:  MOVFF  FEF,318
06210:  MOVFF  FEC,556
06214:  MOVFF  FEC,557
06218:  MOVFF  FEC,558
0621C:  MOVLB  3
....................       payload_buff[46] = make8(global_sprinkler_queue[global_current_sprinkler_queue_location].start_time,1); 
0621E:  MOVLB  4
06220:  MOVF   x21,W
06222:  MULLW  0E
06224:  MOVF   FF3,W
06226:  MOVLB  5
06228:  CLRF   x54
0622A:  MOVWF  x53
0622C:  MOVLW  95
0622E:  ADDWF  x53,W
06230:  MOVWF  FE9
06232:  MOVLW  03
06234:  ADDWFC x54,W
06236:  MOVWF  FEA
06238:  MOVFF  FEF,555
0623C:  MOVFF  FEC,319
06240:  MOVFF  FEC,557
06244:  MOVFF  FEC,558
06248:  MOVLB  3
....................       payload_buff[47] = make8(global_sprinkler_queue[global_current_sprinkler_queue_location].start_time,2); 
0624A:  MOVLB  4
0624C:  MOVF   x21,W
0624E:  MULLW  0E
06250:  MOVF   FF3,W
06252:  MOVLB  5
06254:  CLRF   x54
06256:  MOVWF  x53
06258:  MOVLW  95
0625A:  ADDWF  x53,W
0625C:  MOVWF  FE9
0625E:  MOVLW  03
06260:  ADDWFC x54,W
06262:  MOVWF  FEA
06264:  MOVFF  FEF,555
06268:  MOVFF  FEC,556
0626C:  MOVFF  FEC,31A
06270:  MOVFF  FEC,558
06274:  MOVLB  3
....................       payload_buff[48] = make8(global_sprinkler_queue[global_current_sprinkler_queue_location].start_time,3); 
06276:  MOVLB  4
06278:  MOVF   x21,W
0627A:  MULLW  0E
0627C:  MOVF   FF3,W
0627E:  MOVLB  5
06280:  CLRF   x54
06282:  MOVWF  x53
06284:  MOVLW  95
06286:  ADDWF  x53,W
06288:  MOVWF  FE9
0628A:  MOVLW  03
0628C:  ADDWFC x54,W
0628E:  MOVWF  FEA
06290:  MOVFF  FEF,555
06294:  MOVFF  FEC,556
06298:  MOVFF  FEC,557
0629C:  MOVFF  FEC,31B
062A0:  MOVLB  3
....................    } 
062A2:  BRA    62B4
062A4:  MOVLB  4
....................    else 
....................    { 
....................       payload_buff[43] = 0; 
062A6:  MOVLB  3
062A8:  CLRF   x16
....................       payload_buff[44] = 0; 
062AA:  CLRF   x17
....................       payload_buff[45] = 0; 
062AC:  CLRF   x18
....................       payload_buff[46] = 0; 
062AE:  CLRF   x19
....................       payload_buff[47] = 0; 
062B0:  CLRF   x1A
....................       payload_buff[48] = 0; 
062B2:  CLRF   x1B
....................    } 
....................    enable_interrupts(INT_CCP4); 
062B4:  BSF    F7A.1
....................    payload_buff[49] = make8(global_xdcr_output, 0); 
062B6:  MOVFF  4B,31C
....................    payload_buff[50] = make8(global_xdcr_output, 1); 
062BA:  MOVFF  4C,31D
....................    payload_buff[51] = make8(global_rtc_time,0); 
062BE:  MOVFF  85,31E
062C2:  MOVLB  3
....................    payload_buff[52] = make8(global_rtc_time,1); 
062C4:  MOVFF  86,31F
062C8:  MOVLB  3
....................    payload_buff[53] = make8(global_rtc_time,2); 
062CA:  MOVFF  87,320
062CE:  MOVLB  3
....................    payload_buff[54] = make8(global_rtc_time,3); 
062D0:  MOVFF  88,321
062D4:  MOVLB  3
....................    payload_buff[55] = global_previous_shutdown_cause; 
062D6:  MOVFF  4E,322
....................    payload_buff[56] = make8(FIRMWARE_VERSION,0); 
062DA:  MOVLW  10
062DC:  MOVWF  x23
....................    payload_buff[57] = make8(FIRMWARE_VERSION,1);    
062DE:  MOVLW  E3
062E0:  MOVWF  x24
....................    generate_message_and_send(); 
062E2:  MOVLB  0
062E4:  RCALL  5F7A
062E6:  RETURN 0
.................... } 
.................... void send_health_report(uint8_t command_id_in_response_to, uint16_t msg_seq) 
.................... {   
....................    uint16_t temp_u16; 
....................     
....................    prepare_prefix_and_payload(18); 
062E8:  MOVLW  12
062EA:  MOVLB  5
062EC:  MOVWF  x59
062EE:  MOVLB  0
062F0:  RCALL  5B62
....................    payload_buff[4] = make8(msg_seq,0); 
062F2:  MOVFF  54F,2EF
062F6:  MOVLB  2
....................    payload_buff[5] = make8(msg_seq,1); 
062F8:  MOVFF  550,2F0
062FC:  MOVLB  2
....................    payload_buff[6] = command_id_in_response_to; 
062FE:  MOVFF  54E,2F1
....................    payload_buff[7] = MSG_MOTE_HEALTH_REPORT; 
06302:  MOVLW  91
06304:  MOVWF  xF2
....................    payload_buff[8] = make8(global_sprinkler_num, 0); 
06306:  MOVFF  8D,2F3
0630A:  MOVLB  2
....................    payload_buff[9] = make8(global_sprinkler_num, 1); 
0630C:  MOVFF  8E,2F4
06310:  MOVLB  2
....................    payload_buff[10] = global_hardware_enabled; 
06312:  MOVFF  9F,2F5
....................    payload_buff[11] = global_system_state; 
06316:  MOVFF  4FD,2F6
....................    // vbatt(unchanged charge state) 
....................    temp_u16 = get_vbatt(0); 
0631A:  MOVLB  5
0631C:  CLRF   x53
0631E:  MOVLB  0
06320:  CALL   3F5E
06324:  MOVFF  02,552
06328:  MOVFF  01,551
....................    payload_buff[12] = make8(temp_u16, 0); 
0632C:  MOVFF  551,2F7
06330:  MOVLB  2
....................    payload_buff[13] = make8(temp_u16, 1); 
06332:  MOVFF  552,2F8
06336:  MOVLB  2
....................    // vbatt(no charging) 
....................    temp_u16 = get_vbatt(1); 
06338:  MOVLW  01
0633A:  MOVLB  5
0633C:  MOVWF  x53
0633E:  MOVLB  0
06340:  CALL   3F5E
06344:  MOVFF  02,552
06348:  MOVFF  01,551
....................    payload_buff[14] = make8(temp_u16, 0); 
0634C:  MOVFF  551,2F9
06350:  MOVLB  2
....................    payload_buff[15] = make8(temp_u16, 1); 
06352:  MOVFF  552,2FA
06356:  MOVLB  2
....................    payload_buff[16] = global_valve_movements_since_endstop; 
06358:  MOVFF  C7,2FB
....................    // grab the most recent temperature 
....................    payload_buff[17] = global_mote_temperature; 
0635C:  MOVFF  365,2FC
....................    generate_message_and_send(); 
06360:  MOVLB  0
06362:  RCALL  5F7A
06364:  GOTO   6D54 (RETURN)
.................... } 
.................... void send_valve_report(uint8_t command_id_in_response_to, uint16_t msg_seq) 
.................... { 
....................    uint16_t temp_u16; 
....................     
....................    prepare_prefix_and_payload(28); 
06368:  MOVLW  1C
0636A:  MOVLB  5
0636C:  MOVWF  x59
0636E:  MOVLB  0
06370:  CALL   5B62
....................    payload_buff[4] = make8(msg_seq,0); 
06374:  MOVFF  54F,2EF
06378:  MOVLB  2
....................    payload_buff[5] = make8(msg_seq,1); 
0637A:  MOVFF  550,2F0
0637E:  MOVLB  2
....................    payload_buff[6] = command_id_in_response_to;                                                         
06380:  MOVFF  54E,2F1
....................    payload_buff[7] = MSG_MOTE_VALVE_REPORT; 
06384:  MOVLW  92
06386:  MOVWF  xF2
....................    payload_buff[8] = make8(global_sprinkler_num, 0); 
06388:  MOVFF  8D,2F3
0638C:  MOVLB  2
....................    payload_buff[9] = make8(global_sprinkler_num, 1); 
0638E:  MOVFF  8E,2F4
06392:  MOVLB  2
....................    payload_buff[10] = make8(global_valve_position, 0); 
06394:  MOVFF  B9,2F5
06398:  MOVLB  2
....................    payload_buff[11] = make8(global_valve_position, 1); 
0639A:  MOVFF  BA,2F6
0639E:  MOVLB  2
....................    payload_buff[12] = make8((global_valve_time_to_open_1024th << 4), 0); 
063A0:  MOVLB  0
063A2:  RLCF   xBF,W
063A4:  MOVLB  5
063A6:  MOVWF  x53
063A8:  MOVLB  0
063AA:  RLCF   xC0,W
063AC:  MOVLB  5
063AE:  MOVWF  x54
063B0:  RLCF   x53,F
063B2:  RLCF   x54,F
063B4:  RLCF   x53,F
063B6:  RLCF   x54,F
063B8:  RLCF   x53,F
063BA:  RLCF   x54,F
063BC:  MOVLW  F0
063BE:  ANDWF  x53,F
063C0:  MOVFF  553,2F7
063C4:  MOVLB  2
....................    payload_buff[13] = make8((global_valve_time_to_open_1024th << 4), 1); 
063C6:  MOVLB  0
063C8:  RLCF   xBF,W
063CA:  MOVLB  5
063CC:  MOVWF  x53
063CE:  MOVLB  0
063D0:  RLCF   xC0,W
063D2:  MOVLB  5
063D4:  MOVWF  x54
063D6:  RLCF   x53,F
063D8:  RLCF   x54,F
063DA:  RLCF   x53,F
063DC:  RLCF   x54,F
063DE:  RLCF   x53,F
063E0:  RLCF   x54,F
063E2:  MOVLW  F0
063E4:  ANDWF  x53,F
063E6:  MOVFF  554,2F8
063EA:  MOVLB  2
....................    payload_buff[14] = make8((global_valve_time_to_close_1024th << 4), 0); 
063EC:  MOVLB  0
063EE:  RLCF   xBD,W
063F0:  MOVLB  5
063F2:  MOVWF  x53
063F4:  MOVLB  0
063F6:  RLCF   xBE,W
063F8:  MOVLB  5
063FA:  MOVWF  x54
063FC:  RLCF   x53,F
063FE:  RLCF   x54,F
06400:  RLCF   x53,F
06402:  RLCF   x54,F
06404:  RLCF   x53,F
06406:  RLCF   x54,F
06408:  MOVLW  F0
0640A:  ANDWF  x53,F
0640C:  MOVFF  553,2F9
06410:  MOVLB  2
....................    payload_buff[15] = make8((global_valve_time_to_close_1024th << 4), 1); 
06412:  MOVLB  0
06414:  RLCF   xBD,W
06416:  MOVLB  5
06418:  MOVWF  x53
0641A:  MOVLB  0
0641C:  RLCF   xBE,W
0641E:  MOVLB  5
06420:  MOVWF  x54
06422:  RLCF   x53,F
06424:  RLCF   x54,F
06426:  RLCF   x53,F
06428:  RLCF   x54,F
0642A:  RLCF   x53,F
0642C:  RLCF   x54,F
0642E:  MOVLW  F0
06430:  ANDWF  x53,F
06432:  MOVFF  554,2FA
06436:  MOVLB  2
....................    payload_buff[16] = make8(global_valve_calibration_utc_time, 0); 
06438:  MOVFF  C3,2FB
0643C:  MOVLB  2
....................    payload_buff[17] = make8(global_valve_calibration_utc_time, 1); 
0643E:  MOVFF  C4,2FC
06442:  MOVLB  2
....................    payload_buff[18] = make8(global_valve_calibration_utc_time, 2); 
06444:  MOVFF  C5,2FD
06448:  MOVLB  2
....................    payload_buff[19] = make8(global_valve_calibration_utc_time, 3); 
0644A:  MOVFF  C6,2FE
0644E:  MOVLB  2
....................    payload_buff[20] = make8(global_calibrate_fsr_valve_position, 0); 
06450:  MOVFF  C8,2FF
06454:  MOVLB  2
....................    payload_buff[21] = make8(global_calibrate_fsr_valve_position, 1); 
06456:  MOVFF  C9,300
0645A:  MOVLB  3
....................    temp_u16 = convert_period_to_rpm(global_calibrate_fsr_period); 
0645C:  MOVFF  CB,554
06460:  MOVFF  CA,553
06464:  MOVLB  0
06466:  CALL   5BA4
0646A:  MOVFF  02,552
0646E:  MOVFF  01,551
....................    payload_buff[22] = make8(temp_u16, 0); 
06472:  MOVFF  551,301
06476:  MOVLB  3
....................    payload_buff[23] = make8(temp_u16, 1); 
06478:  MOVFF  552,302
0647C:  MOVLB  3
....................    payload_buff[24] = make8(global_calibrate_fsr_utc_time, 0); 
0647E:  MOVFF  CC,303
06482:  MOVLB  3
....................    payload_buff[25] = make8(global_calibrate_fsr_utc_time, 1); 
06484:  MOVFF  CD,304
06488:  MOVLB  3
....................    payload_buff[26] = make8(global_calibrate_fsr_utc_time, 2); 
0648A:  MOVFF  CE,305
0648E:  MOVLB  3
....................    payload_buff[27] = make8(global_calibrate_fsr_utc_time, 3); 
06490:  MOVFF  CF,306
06494:  MOVLB  3
....................    generate_message_and_send(); 
06496:  MOVLB  0
06498:  RCALL  5F7A
0649A:  GOTO   6D6A (RETURN)
.................... } 
.................... void send_sprinkler_cmd_response(uint8_t command_id_in_response_to, uint16_t msg_seq) 
.................... { 
....................    uint16_t temp_u16; 
....................     
....................    prepare_prefix_and_payload(25); 
*
06A46:  MOVLW  19
06A48:  MOVLB  5
06A4A:  MOVWF  x59
06A4C:  MOVLB  0
06A4E:  CALL   5B62
....................    payload_buff[4] = make8(msg_seq,0); 
06A52:  MOVFF  54F,2EF
06A56:  MOVLB  2
....................    payload_buff[5] = make8(msg_seq,1); 
06A58:  MOVFF  550,2F0
06A5C:  MOVLB  2
....................    payload_buff[6] = command_id_in_response_to; 
06A5E:  MOVFF  54E,2F1
....................    payload_buff[7] = MSG_MOTE_SPINKLER_CMD_RESPONSE; 
06A62:  MOVLW  93
06A64:  MOVWF  xF2
....................    payload_buff[8] = make8(global_sprinkler_num, 0); 
06A66:  MOVFF  8D,2F3
06A6A:  MOVLB  2
....................    payload_buff[9] = make8(global_sprinkler_num, 1); 
06A6C:  MOVFF  8E,2F4
06A70:  MOVLB  2
....................    payload_buff[10] = global_hardware_enabled; 
06A72:  MOVFF  9F,2F5
....................    payload_buff[11] = make8(global_rpm_set_value, 0); 
06A76:  MOVFF  A4,2F6
06A7A:  MOVLB  2
....................    payload_buff[12] = make8(global_rpm_set_value, 1); 
06A7C:  MOVFF  A5,2F7
06A80:  MOVLB  2
....................    disable_interrupts(INT_CCP4); 
06A82:  BCF    F7A.1
....................    if (global_current_sprinkler_queue_location != 255) 
06A84:  MOVLB  4
06A86:  INCFSZ x21,W
06A88:  BRA    6A8C
06A8A:  BRA    6AF2
....................    { 
....................       payload_buff[13] = make8(global_sprinkler_queue[global_current_sprinkler_queue_location].spin_rate,0); 
06A8C:  MOVF   x21,W
06A8E:  MULLW  0E
06A90:  MOVF   FF3,W
06A92:  MOVLB  5
06A94:  CLRF   x54
06A96:  MOVWF  x53
06A98:  MOVLW  0A
06A9A:  ADDWF  x53,W
06A9C:  MOVWF  01
06A9E:  MOVLW  00
06AA0:  ADDWFC x54,W
06AA2:  MOVWF  03
06AA4:  MOVF   01,W
06AA6:  ADDLW  95
06AA8:  MOVWF  FE9
06AAA:  MOVLW  03
06AAC:  ADDWFC 03,W
06AAE:  MOVWF  FEA
06AB0:  MOVFF  FEC,554
06AB4:  MOVF   FED,F
06AB6:  MOVFF  FEF,2F8
06ABA:  MOVLB  2
....................       payload_buff[14] = make8(global_sprinkler_queue[global_current_sprinkler_queue_location].spin_rate,1); 
06ABC:  MOVLB  4
06ABE:  MOVF   x21,W
06AC0:  MULLW  0E
06AC2:  MOVF   FF3,W
06AC4:  MOVLB  5
06AC6:  CLRF   x54
06AC8:  MOVWF  x53
06ACA:  MOVLW  0A
06ACC:  ADDWF  x53,W
06ACE:  MOVWF  01
06AD0:  MOVLW  00
06AD2:  ADDWFC x54,W
06AD4:  MOVWF  03
06AD6:  MOVF   01,W
06AD8:  ADDLW  95
06ADA:  MOVWF  FE9
06ADC:  MOVLW  03
06ADE:  ADDWFC 03,W
06AE0:  MOVWF  FEA
06AE2:  MOVFF  FEC,2F9
06AE6:  MOVF   FED,F
06AE8:  MOVFF  FEF,553
06AEC:  MOVLB  2
....................    } 
06AEE:  BRA    6AF8
06AF0:  MOVLB  4
....................    else 
....................    { 
....................       payload_buff[13] = 0; 
06AF2:  MOVLB  2
06AF4:  CLRF   xF8
....................       payload_buff[14] = 0; 
06AF6:  CLRF   xF9
....................    } 
....................    payload_buff[15] = make8(global_valve_position_set_value,0); 
06AF8:  MOVFF  BB,2FA
06AFC:  MOVLB  2
....................    payload_buff[16] = make8(global_valve_position_set_value,1); 
06AFE:  MOVFF  BC,2FB
06B02:  MOVLB  2
....................    if (global_current_sprinkler_queue_location != 255) 
06B04:  MOVLB  4
06B06:  INCFSZ x21,W
06B08:  BRA    6B0C
06B0A:  BRA    6C22
....................    { 
....................       payload_buff[17] = make8(global_sprinkler_queue[global_current_sprinkler_queue_location].vlv_open_amount,0); 
06B0C:  MOVF   x21,W
06B0E:  MULLW  0E
06B10:  MOVF   FF3,W
06B12:  MOVLB  5
06B14:  CLRF   x54
06B16:  MOVWF  x53
06B18:  MOVLW  08
06B1A:  ADDWF  x53,W
06B1C:  MOVWF  01
06B1E:  MOVLW  00
06B20:  ADDWFC x54,W
06B22:  MOVWF  03
06B24:  MOVF   01,W
06B26:  ADDLW  95
06B28:  MOVWF  FE9
06B2A:  MOVLW  03
06B2C:  ADDWFC 03,W
06B2E:  MOVWF  FEA
06B30:  MOVFF  FEC,554
06B34:  MOVF   FED,F
06B36:  MOVFF  FEF,2FC
06B3A:  MOVLB  2
....................       payload_buff[18] = make8(global_sprinkler_queue[global_current_sprinkler_queue_location].vlv_open_amount,1); 
06B3C:  MOVLB  4
06B3E:  MOVF   x21,W
06B40:  MULLW  0E
06B42:  MOVF   FF3,W
06B44:  MOVLB  5
06B46:  CLRF   x54
06B48:  MOVWF  x53
06B4A:  MOVLW  08
06B4C:  ADDWF  x53,W
06B4E:  MOVWF  01
06B50:  MOVLW  00
06B52:  ADDWFC x54,W
06B54:  MOVWF  03
06B56:  MOVF   01,W
06B58:  ADDLW  95
06B5A:  MOVWF  FE9
06B5C:  MOVLW  03
06B5E:  ADDWFC 03,W
06B60:  MOVWF  FEA
06B62:  MOVFF  FEC,2FD
06B66:  MOVF   FED,F
06B68:  MOVFF  FEF,553
06B6C:  MOVLB  2
....................       payload_buff[19] = make8(global_sprinkler_queue[global_current_sprinkler_queue_location].start_time,0); 
06B6E:  MOVLB  4
06B70:  MOVF   x21,W
06B72:  MULLW  0E
06B74:  MOVF   FF3,W
06B76:  MOVLB  5
06B78:  CLRF   x54
06B7A:  MOVWF  x53
06B7C:  MOVLW  95
06B7E:  ADDWF  x53,W
06B80:  MOVWF  FE9
06B82:  MOVLW  03
06B84:  ADDWFC x54,W
06B86:  MOVWF  FEA
06B88:  MOVFF  FEF,2FE
06B8C:  MOVFF  FEC,556
06B90:  MOVFF  FEC,557
06B94:  MOVFF  FEC,558
06B98:  MOVLB  2
....................       payload_buff[20] = make8(global_sprinkler_queue[global_current_sprinkler_queue_location].start_time,1); 
06B9A:  MOVLB  4
06B9C:  MOVF   x21,W
06B9E:  MULLW  0E
06BA0:  MOVF   FF3,W
06BA2:  MOVLB  5
06BA4:  CLRF   x54
06BA6:  MOVWF  x53
06BA8:  MOVLW  95
06BAA:  ADDWF  x53,W
06BAC:  MOVWF  FE9
06BAE:  MOVLW  03
06BB0:  ADDWFC x54,W
06BB2:  MOVWF  FEA
06BB4:  MOVFF  FEF,555
06BB8:  MOVFF  FEC,2FF
06BBC:  MOVFF  FEC,557
06BC0:  MOVFF  FEC,558
06BC4:  MOVLB  2
....................       payload_buff[21] = make8(global_sprinkler_queue[global_current_sprinkler_queue_location].start_time,2); 
06BC6:  MOVLB  4
06BC8:  MOVF   x21,W
06BCA:  MULLW  0E
06BCC:  MOVF   FF3,W
06BCE:  MOVLB  5
06BD0:  CLRF   x54
06BD2:  MOVWF  x53
06BD4:  MOVLW  95
06BD6:  ADDWF  x53,W
06BD8:  MOVWF  FE9
06BDA:  MOVLW  03
06BDC:  ADDWFC x54,W
06BDE:  MOVWF  FEA
06BE0:  MOVFF  FEF,555
06BE4:  MOVFF  FEC,556
06BE8:  MOVFF  FEC,300
06BEC:  MOVFF  FEC,558
06BF0:  MOVLB  3
....................       payload_buff[22] = make8(global_sprinkler_queue[global_current_sprinkler_queue_location].start_time,3); 
06BF2:  MOVLB  4
06BF4:  MOVF   x21,W
06BF6:  MULLW  0E
06BF8:  MOVF   FF3,W
06BFA:  MOVLB  5
06BFC:  CLRF   x54
06BFE:  MOVWF  x53
06C00:  MOVLW  95
06C02:  ADDWF  x53,W
06C04:  MOVWF  FE9
06C06:  MOVLW  03
06C08:  ADDWFC x54,W
06C0A:  MOVWF  FEA
06C0C:  MOVFF  FEF,555
06C10:  MOVFF  FEC,556
06C14:  MOVFF  FEC,557
06C18:  MOVFF  FEC,301
06C1C:  MOVLB  3
....................    } 
06C1E:  BRA    6C32
06C20:  MOVLB  4
....................    else 
....................    { 
....................       payload_buff[17] = 0; 
06C22:  MOVLB  2
06C24:  CLRF   xFC
....................       payload_buff[18] = 0; 
06C26:  CLRF   xFD
....................       payload_buff[19] = 0; 
06C28:  CLRF   xFE
....................       payload_buff[20] = 0; 
06C2A:  CLRF   xFF
....................       payload_buff[21] = 0; 
06C2C:  MOVLB  3
06C2E:  CLRF   x00
....................       payload_buff[22] = 0; 
06C30:  CLRF   x01
....................    } 
....................    enable_interrupts(INT_CCP4); 
06C32:  BSF    F7A.1
....................    // vbatt(no charging) 
....................    temp_u16 = get_vbatt(1); 
06C34:  MOVLW  01
06C36:  MOVLB  5
06C38:  MOVWF  x53
06C3A:  MOVLB  0
06C3C:  CALL   3F5E
06C40:  MOVFF  02,552
06C44:  MOVFF  01,551
....................    payload_buff[23] = make8(temp_u16, 0); 
06C48:  MOVFF  551,302
06C4C:  MOVLB  3
....................    payload_buff[24] = make8(temp_u16, 1); 
06C4E:  MOVFF  552,303
06C52:  MOVLB  3
....................    generate_message_and_send(); 
06C54:  MOVLB  0
06C56:  CALL   5F7A
06C5A:  GOTO   7490 (RETURN)
.................... } 
.................... void send_update_sp_num_response(uint8_t command_id_in_response_to, uint16_t msg_seq) 
.................... { 
....................    prepare_prefix_and_payload(10); 
*
064C4:  MOVLW  0A
064C6:  MOVLB  5
064C8:  MOVWF  x59
064CA:  MOVLB  0
064CC:  CALL   5B62
....................    payload_buff[4] = make8(msg_seq,0); 
064D0:  MOVFF  54F,2EF
064D4:  MOVLB  2
....................    payload_buff[5] = make8(msg_seq,1); 
064D6:  MOVFF  550,2F0
064DA:  MOVLB  2
....................    payload_buff[6] = command_id_in_response_to; 
064DC:  MOVFF  54E,2F1
....................    payload_buff[7] = MSG_MOTE_UPDATE_SP_NUM_RESPONSE; 
064E0:  MOVLW  95
064E2:  MOVWF  xF2
....................    payload_buff[8] = make8(global_sprinkler_num, 0); 
064E4:  MOVFF  8D,2F3
064E8:  MOVLB  2
....................    payload_buff[9] = make8(global_sprinkler_num, 1); 
064EA:  MOVFF  8E,2F4
064EE:  MOVLB  2
....................    generate_message_and_send(); 
064F0:  MOVLB  0
064F2:  RCALL  5F7A
064F4:  GOTO   6FC0 (RETURN)
.................... }        
.................... void send_read_eeprom_response(uint8_t command_id_in_response_to, uint16_t msg_seq, uint16_t eeprom_location, uint32_t eeprom_data)  
.................... { 
....................    prepare_prefix_and_payload(16); 
*
06780:  MOVLW  10
06782:  MOVLB  5
06784:  MOVWF  x59
06786:  MOVLB  0
06788:  CALL   5B62
....................    payload_buff[4] = make8(msg_seq,0);                                                    
0678C:  MOVFF  551,2EF
06790:  MOVLB  2
....................    payload_buff[5] = make8(msg_seq,1); 
06792:  MOVFF  552,2F0
06796:  MOVLB  2
....................    payload_buff[6] = command_id_in_response_to; 
06798:  MOVFF  550,2F1
....................    payload_buff[7] = MSG_MOTE_EEPROM_READ_RESPONSE;  
0679C:  MOVLW  97
0679E:  MOVWF  xF2
....................    payload_buff[8] = make8(global_sprinkler_num, 0); 
067A0:  MOVFF  8D,2F3
067A4:  MOVLB  2
....................    payload_buff[9] = make8(global_sprinkler_num, 1); 
067A6:  MOVFF  8E,2F4
067AA:  MOVLB  2
....................    payload_buff[10] = make8(eeprom_location, 0); 
067AC:  MOVFF  553,2F5
067B0:  MOVLB  2
....................    payload_buff[11] = make8(eeprom_location, 1);   
067B2:  MOVFF  554,2F6
067B6:  MOVLB  2
....................    payload_buff[12] = make8(eeprom_data, 0);                          
067B8:  MOVFF  555,2F7
067BC:  MOVLB  2
....................    payload_buff[13] = make8(eeprom_data, 1);   
067BE:  MOVFF  556,2F8
067C2:  MOVLB  2
....................    payload_buff[14] = make8(eeprom_data, 2);     
067C4:  MOVFF  557,2F9
067C8:  MOVLB  2
....................    payload_buff[15] = make8(eeprom_data, 3);   
067CA:  MOVFF  558,2FA
067CE:  MOVLB  2
....................    generate_message_and_send();    
067D0:  MOVLB  0
067D2:  CALL   5F7A
067D6:  GOTO   7330 (RETURN)
.................... }                
.................... void send_pressure_xdcr_msg(uint8_t command_id_in_response_to, uint16_t msg_seq)    
.................... {                    
....................    prepare_prefix_and_payload(12); 
....................    payload_buff[4] = make8(msg_seq,0);                                                    
....................    payload_buff[5] = make8(msg_seq,1);       
....................    payload_buff[6] = command_id_in_response_to;                    
....................    payload_buff[7] = MSG_MOTE_XDCR_READ_MSG;           
....................    payload_buff[8] = make8(global_sprinkler_num, 0);    
....................    payload_buff[9] = make8(global_sprinkler_num, 1); 
....................    payload_buff[10] = make8(global_xdcr_output, 0);                  
....................    payload_buff[11] = make8(global_xdcr_output, 1);    
....................    generate_message_and_send();                               
.................... }        
.................... void send_ack(uint8_t command_id_in_response_to, uint16_t msg_seq) 
.................... { 
....................    prepare_prefix_and_payload(8); 
*
0649E:  MOVLW  08
064A0:  MOVLB  5
064A2:  MOVWF  x59
064A4:  MOVLB  0
064A6:  CALL   5B62
....................    payload_buff[4] = make8(msg_seq,0); 
064AA:  MOVFF  54F,2EF
064AE:  MOVLB  2
....................    payload_buff[5] = make8(msg_seq,1); 
064B0:  MOVFF  550,2F0
064B4:  MOVLB  2
....................    payload_buff[6] = command_id_in_response_to; 
064B6:  MOVFF  54E,2F1
....................    payload_buff[7] = MSG_MOTE_ACK; 
064BA:  MOVLW  80
064BC:  MOVWF  xF2
....................    generate_message_and_send(); 
064BE:  MOVLB  0
064C0:  RCALL  5F7A
064C2:  RETURN 0
.................... } 
.................... void send_nack(uint8_t command_id_in_response_to, uint16_t msg_seq, uint32_t nack_bitfield) 
.................... { 
....................    prepare_prefix_and_payload(12); 
*
0651A:  MOVLW  0C
0651C:  MOVLB  5
0651E:  MOVWF  x59
06520:  MOVLB  0
06522:  CALL   5B62
....................    payload_buff[4] = make8(msg_seq,0); 
06526:  MOVFF  54F,2EF
0652A:  MOVLB  2
....................    payload_buff[5] = make8(msg_seq,1); 
0652C:  MOVFF  550,2F0
06530:  MOVLB  2
....................    payload_buff[6] = command_id_in_response_to; 
06532:  MOVFF  54E,2F1
....................    payload_buff[7] = MSG_MOTE_NACK; 
06536:  MOVLW  81
06538:  MOVWF  xF2
....................    payload_buff[8] = make8(nack_bitfield, 0); 
0653A:  MOVFF  551,2F3
0653E:  MOVLB  2
....................    payload_buff[9] = make8(nack_bitfield, 1); 
06540:  MOVFF  552,2F4
06544:  MOVLB  2
....................    payload_buff[10] = make8(nack_bitfield, 2); 
06546:  MOVFF  553,2F5
0654A:  MOVLB  2
....................    payload_buff[11] = make8(nack_bitfield, 3); 
0654C:  MOVFF  554,2F6
06550:  MOVLB  2
....................    generate_message_and_send(); 
06552:  MOVLB  0
06554:  RCALL  5F7A
06556:  RETURN 0
.................... }                                        
....................  
.................... // unsolicted responses (only sent within CCP4 ISR) 
.................... void send_health_report_ISR(uint8_t command_id_in_response_to, uint16_t msg_seq) 
.................... { 
....................    uint16_t temp_u16; 
....................     
....................    prepare_prefix_and_payload_ISR(18); 
*
0230C:  MOVLW  12
0230E:  MOVLB  5
02310:  MOVWF  x8F
02312:  MOVLB  0
02314:  RCALL  2214
....................    payload_buff[4] = make8(msg_seq,0); 
02316:  MOVFF  58B,2EF
0231A:  MOVLB  2
....................    payload_buff[5] = make8(msg_seq,1); 
0231C:  MOVFF  58C,2F0
02320:  MOVLB  2
....................    payload_buff[6] = command_id_in_response_to; 
02322:  MOVFF  58A,2F1
....................    payload_buff[7] = MSG_MOTE_HEALTH_REPORT; 
02326:  MOVLW  91
02328:  MOVWF  xF2
....................    payload_buff[8] = make8(global_sprinkler_num, 0); 
0232A:  MOVFF  8D,2F3
0232E:  MOVLB  2
....................    payload_buff[9] = make8(global_sprinkler_num, 1); 
02330:  MOVFF  8E,2F4
02334:  MOVLB  2
....................    payload_buff[10] = global_hardware_enabled; 
02336:  MOVFF  9F,2F5
....................    payload_buff[11] = global_system_state; 
0233A:  MOVFF  4FD,2F6
....................  // vbatt(unchanged charge state) 
....................    temp_u16 = get_vbatt_ISR(0); 
0233E:  MOVLB  5
02340:  CLRF   x8F
02342:  MOVLB  0
02344:  RCALL  2256
02346:  MOVFF  02,58E
0234A:  MOVFF  01,58D
....................    payload_buff[12] = make8(temp_u16, 0); 
0234E:  MOVFF  58D,2F7
02352:  MOVLB  2
....................    payload_buff[13] = make8(temp_u16, 1); 
02354:  MOVFF  58E,2F8
02358:  MOVLB  2
....................    // vbatt(no charging) 
....................    temp_u16 = get_vbatt_ISR(1); 
0235A:  MOVLW  01
0235C:  MOVLB  5
0235E:  MOVWF  x8F
02360:  MOVLB  0
02362:  RCALL  2256
02364:  MOVFF  02,58E
02368:  MOVFF  01,58D
....................    payload_buff[14] = make8(temp_u16, 0); 
0236C:  MOVFF  58D,2F9
02370:  MOVLB  2
....................    payload_buff[15] = make8(temp_u16, 1); 
02372:  MOVFF  58E,2FA
02376:  MOVLB  2
....................    payload_buff[16] = global_valve_movements_since_endstop; 
02378:  MOVFF  C7,2FB
....................    payload_buff[17] = global_mote_temperature; 
0237C:  MOVFF  365,2FC
....................    generate_message_and_send_ISR(); 
02380:  MOVLB  0
02382:  RCALL  22B0
02384:  GOTO   28B2 (RETURN)
.................... } 
.................... void send_valve_report_ISR(uint8_t command_id_in_response_to, uint16_t msg_seq) 
.................... { 
....................    uint16_t temp_u16; 
....................    prepare_prefix_and_payload_ISR(28); 
*
02486:  MOVLW  1C
02488:  MOVLB  5
0248A:  MOVWF  x8F
0248C:  MOVLB  0
0248E:  RCALL  2214
....................    payload_buff[4] = make8(msg_seq,0); 
02490:  MOVFF  58B,2EF
02494:  MOVLB  2
....................    payload_buff[5] = make8(msg_seq,1); 
02496:  MOVFF  58C,2F0
0249A:  MOVLB  2
....................    payload_buff[6] = command_id_in_response_to; 
0249C:  MOVFF  58A,2F1
....................    payload_buff[7] = MSG_MOTE_VALVE_REPORT; 
024A0:  MOVLW  92
024A2:  MOVWF  xF2
....................    payload_buff[8] = make8(global_sprinkler_num, 0); 
024A4:  MOVFF  8D,2F3
024A8:  MOVLB  2
....................    payload_buff[9] = make8(global_sprinkler_num, 1); 
024AA:  MOVFF  8E,2F4
024AE:  MOVLB  2
....................    payload_buff[10] = make8(global_valve_position, 0); 
024B0:  MOVFF  B9,2F5
024B4:  MOVLB  2
....................    payload_buff[11] = make8(global_valve_position, 1); 
024B6:  MOVFF  BA,2F6
024BA:  MOVLB  2
....................    payload_buff[12] = make8((global_valve_time_to_open_1024th << 4), 0); 
024BC:  MOVLB  0
024BE:  RLCF   xBF,W
024C0:  MOVLB  5
024C2:  MOVWF  x8F
024C4:  MOVLB  0
024C6:  RLCF   xC0,W
024C8:  MOVLB  5
024CA:  MOVWF  x90
024CC:  RLCF   x8F,F
024CE:  RLCF   x90,F
024D0:  RLCF   x8F,F
024D2:  RLCF   x90,F
024D4:  RLCF   x8F,F
024D6:  RLCF   x90,F
024D8:  MOVLW  F0
024DA:  ANDWF  x8F,F
024DC:  MOVFF  58F,2F7
024E0:  MOVLB  2
....................    payload_buff[13] = make8((global_valve_time_to_open_1024th << 4), 1); 
024E2:  MOVLB  0
024E4:  RLCF   xBF,W
024E6:  MOVLB  5
024E8:  MOVWF  x8F
024EA:  MOVLB  0
024EC:  RLCF   xC0,W
024EE:  MOVLB  5
024F0:  MOVWF  x90
024F2:  RLCF   x8F,F
024F4:  RLCF   x90,F
024F6:  RLCF   x8F,F
024F8:  RLCF   x90,F
024FA:  RLCF   x8F,F
024FC:  RLCF   x90,F
024FE:  MOVLW  F0
02500:  ANDWF  x8F,F
02502:  MOVFF  590,2F8
02506:  MOVLB  2
....................    payload_buff[14] = make8((global_valve_time_to_close_1024th << 4), 0); 
02508:  MOVLB  0
0250A:  RLCF   xBD,W
0250C:  MOVLB  5
0250E:  MOVWF  x8F
02510:  MOVLB  0
02512:  RLCF   xBE,W
02514:  MOVLB  5
02516:  MOVWF  x90
02518:  RLCF   x8F,F
0251A:  RLCF   x90,F
0251C:  RLCF   x8F,F
0251E:  RLCF   x90,F
02520:  RLCF   x8F,F
02522:  RLCF   x90,F
02524:  MOVLW  F0
02526:  ANDWF  x8F,F
02528:  MOVFF  58F,2F9
0252C:  MOVLB  2
....................    payload_buff[15] = make8((global_valve_time_to_close_1024th << 4), 1); 
0252E:  MOVLB  0
02530:  RLCF   xBD,W
02532:  MOVLB  5
02534:  MOVWF  x8F
02536:  MOVLB  0
02538:  RLCF   xBE,W
0253A:  MOVLB  5
0253C:  MOVWF  x90
0253E:  RLCF   x8F,F
02540:  RLCF   x90,F
02542:  RLCF   x8F,F
02544:  RLCF   x90,F
02546:  RLCF   x8F,F
02548:  RLCF   x90,F
0254A:  MOVLW  F0
0254C:  ANDWF  x8F,F
0254E:  MOVFF  590,2FA
02552:  MOVLB  2
....................    payload_buff[16] = make8(global_valve_calibration_utc_time, 0); 
02554:  MOVFF  C3,2FB
02558:  MOVLB  2
....................    payload_buff[17] = make8(global_valve_calibration_utc_time, 1); 
0255A:  MOVFF  C4,2FC
0255E:  MOVLB  2
....................    payload_buff[18] = make8(global_valve_calibration_utc_time, 2); 
02560:  MOVFF  C5,2FD
02564:  MOVLB  2
....................    payload_buff[19] = make8(global_valve_calibration_utc_time, 3); 
02566:  MOVFF  C6,2FE
0256A:  MOVLB  2
....................    payload_buff[20] = make8(global_calibrate_fsr_valve_position, 0); 
0256C:  MOVFF  C8,2FF
02570:  MOVLB  2
....................    payload_buff[21] = make8(global_calibrate_fsr_valve_position, 1); 
02572:  MOVFF  C9,300
02576:  MOVLB  3
....................    temp_u16 = convert_period_to_rpm_ISR(global_calibrate_fsr_period); 
02578:  MOVFF  CB,590
0257C:  MOVFF  CA,58F
02580:  MOVLB  0
02582:  BRA    241C
02584:  MOVFF  02,58E
02588:  MOVFF  01,58D
....................    payload_buff[22] = make8(temp_u16, 0); 
0258C:  MOVFF  58D,301
02590:  MOVLB  3
....................    payload_buff[23] = make8(temp_u16, 1); 
02592:  MOVFF  58E,302
02596:  MOVLB  3
....................    payload_buff[24] = make8(global_calibrate_fsr_utc_time, 0); 
02598:  MOVFF  CC,303
0259C:  MOVLB  3
....................    payload_buff[25] = make8(global_calibrate_fsr_utc_time, 1); 
0259E:  MOVFF  CD,304
025A2:  MOVLB  3
....................    payload_buff[26] = make8(global_calibrate_fsr_utc_time, 2); 
025A4:  MOVFF  CE,305
025A8:  MOVLB  3
....................    payload_buff[27] = make8(global_calibrate_fsr_utc_time, 3); 
025AA:  MOVFF  CF,306
025AE:  MOVLB  3
....................    generate_message_and_send_ISR(); 
025B0:  MOVLB  0
025B2:  RCALL  22B0
025B4:  GOTO   28B2 (RETURN)
.................... } 
.................... void send_join_msg_ISR(uint8_t command_id_in_response_to, uint16_t msg_seq) 
.................... { 
....................    prepare_prefix_and_payload_ISR(18); 
025B8:  MOVLW  12
025BA:  MOVLB  5
025BC:  MOVWF  x8F
025BE:  MOVLB  0
025C0:  RCALL  2214
....................    payload_buff[4] = make8(msg_seq,0); 
025C2:  MOVFF  58B,2EF
025C6:  MOVLB  2
....................    payload_buff[5] = make8(msg_seq,1); 
025C8:  MOVFF  58C,2F0
025CC:  MOVLB  2
....................    payload_buff[6] = command_id_in_response_to; 
025CE:  MOVFF  58A,2F1
....................    payload_buff[7] = MSG_MOTE_JOIN_MSG; 
025D2:  MOVLW  94
025D4:  MOVWF  xF2
....................    payload_buff[8] = make8(global_sprinkler_num, 0); 
025D6:  MOVFF  8D,2F3
025DA:  MOVLB  2
....................    payload_buff[9] = make8(global_sprinkler_num, 1); 
025DC:  MOVFF  8E,2F4
025E0:  MOVLB  2
....................    payload_buff[10] = global_hardware_enabled; 
025E2:  MOVFF  9F,2F5
....................    payload_buff[11] = make8(global_rtc_time,0); 
025E6:  MOVFF  85,2F6
025EA:  MOVLB  2
....................    payload_buff[12] = make8(global_rtc_time,1); 
025EC:  MOVFF  86,2F7
025F0:  MOVLB  2
....................    payload_buff[13] = make8(global_rtc_time,2); 
025F2:  MOVFF  87,2F8
025F6:  MOVLB  2
....................    payload_buff[14] = make8(global_rtc_time,3);    
025F8:  MOVFF  88,2F9
025FC:  MOVLB  2
....................    payload_buff[15] = global_previous_shutdown_cause; 
025FE:  MOVFF  4E,2FA
....................    payload_buff[16] = make8(FIRMWARE_VERSION,0); 
02602:  MOVLW  10
02604:  MOVWF  xFB
....................    payload_buff[17] = make8(FIRMWARE_VERSION,1);   
02606:  MOVLW  E3
02608:  MOVWF  xFC
....................    generate_message_and_send_ISR(); 
0260A:  MOVLB  0
0260C:  RCALL  22B0
0260E:  GOTO   28B2 (RETURN)
.................... } 
.................... void send_gps_point_msg_ISR(uint8_t command_id_in_response_to, uint16_t msg_seq) 
.................... { 
....................    prepare_prefix_and_payload_ISR(23); 
02612:  MOVLW  17
02614:  MOVLB  5
02616:  MOVWF  x8F
02618:  MOVLB  0
0261A:  RCALL  2214
....................    payload_buff[4] = make8(msg_seq,0); 
0261C:  MOVFF  58B,2EF
02620:  MOVLB  2
....................    payload_buff[5] = make8(msg_seq,1); 
02622:  MOVFF  58C,2F0
02626:  MOVLB  2
....................    payload_buff[6] = command_id_in_response_to; 
02628:  MOVFF  58A,2F1
....................    payload_buff[7] = MSG_MOTE_GPS_POINT_MSG; 
0262C:  MOVLW  96
0262E:  MOVWF  xF2
....................    payload_buff[8] = make8(global_sprinkler_num, 0); 
02630:  MOVFF  8D,2F3
02634:  MOVLB  2
....................    payload_buff[9] = make8(global_sprinkler_num, 1); 
02636:  MOVFF  8E,2F4
0263A:  MOVLB  2
....................    generate_message_and_send_ISR(); 
0263C:  MOVLB  0
0263E:  RCALL  22B0
02640:  GOTO   28B2 (RETURN)
.................... }                  
.................... void send_pressure_xdcr_msg_ISR(uint8_t command_id_in_response_to, uint16_t msg_seq)    
.................... {                          
....................    prepare_prefix_and_payload_ISR(12);  
02644:  MOVLW  0C
02646:  MOVLB  5
02648:  MOVWF  x8F
0264A:  MOVLB  0
0264C:  RCALL  2214
....................    payload_buff[4] = make8(msg_seq,0);                                                    
0264E:  MOVFF  58B,2EF
02652:  MOVLB  2
....................    payload_buff[5] = make8(msg_seq,1);       
02654:  MOVFF  58C,2F0
02658:  MOVLB  2
....................    payload_buff[6] = command_id_in_response_to;                    
0265A:  MOVFF  58A,2F1
....................    payload_buff[7] = MSG_MOTE_XDCR_READ_MSG;     
0265E:  MOVLW  98
02660:  MOVWF  xF2
....................    payload_buff[8] = make8(global_sprinkler_num, 0);    
02662:  MOVFF  8D,2F3
02666:  MOVLB  2
....................    payload_buff[9] = make8(global_sprinkler_num, 1);                        
02668:  MOVFF  8E,2F4
0266C:  MOVLB  2
....................    payload_buff[10] = make8(global_xdcr_output, 0);                  
0266E:  MOVFF  4B,2F5
....................    payload_buff[11] = make8(global_xdcr_output, 1);       
02672:  MOVFF  4C,2F6
....................    generate_message_and_send_ISR();                               
02676:  MOVLB  0
02678:  RCALL  22B0
0267A:  GOTO   28B2 (RETURN)
.................... }  
.................... void send_error_msg_ISR(uint8_t command_id_in_response_to, uint16_t msg_seq) 
.................... { 
....................    prepare_prefix_and_payload_ISR(14); 
0267E:  MOVLW  0E
02680:  MOVLB  5
02682:  MOVWF  x8F
02684:  MOVLB  0
02686:  RCALL  2214
....................    payload_buff[4] = make8(msg_seq,0); 
02688:  MOVFF  58B,2EF
0268C:  MOVLB  2
....................    payload_buff[5] = make8(msg_seq,1); 
0268E:  MOVFF  58C,2F0
02692:  MOVLB  2
....................    payload_buff[6] = command_id_in_response_to; 
02694:  MOVFF  58A,2F1
....................    payload_buff[7] = MSG_MOTE_ERROR_MSG; 
02698:  MOVLW  A0
0269A:  MOVWF  xF2
....................    payload_buff[8] = make8(global_sprinkler_num, 0); 
0269C:  MOVFF  8D,2F3
026A0:  MOVLB  2
....................    payload_buff[9] = make8(global_sprinkler_num, 1); 
026A2:  MOVFF  8E,2F4
026A6:  MOVLB  2
....................    payload_buff[10] = make8(global_error_message_bitfield,0); 
026A8:  MOVFF  4F0,2F5
026AC:  MOVLB  2
....................    payload_buff[11] = make8(global_error_message_bitfield,1); 
026AE:  MOVFF  4F1,2F6
026B2:  MOVLB  2
....................    payload_buff[12] = make8(global_error_message_bitfield,2); 
026B4:  MOVFF  4F2,2F7
026B8:  MOVLB  2
....................    payload_buff[13] = make8(global_error_message_bitfield,3); 
026BA:  MOVFF  4F3,2F8
026BE:  MOVLB  2
....................    generate_message_and_send_ISR(); 
026C0:  MOVLB  0
026C2:  RCALL  22B0
026C4:  GOTO   28B2 (RETURN)
.................... } 
....................  
.................... #include "periph.h"                                                       
.................... // This file contains all functions definitions for the LCD and XDCR 
.................... // The globals.h file is needed 
....................  
.................... ////////////////////LCD Functions Start///////////////////////////////////////// 
....................  
.................... //************************************************************** 
.................... // These routines communicate to the 16x2 LCD display via I2C. * 
.................... // Here are the HEX codes for the 32 display positions:        * 
.................... // Line 1   00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F    * 
.................... // Line 2   40 41 42 43 44 45 46 47 48 49 4A 4B 4C 4D 4E 4F    * 
.................... //************************************************************** 
....................  
.................... void LCD_init(void)    
.................... { 
....................    output_low(LCD_RESETn);                                
*
03710:  BCF    F8C.2
....................    
....................    delay_ms(1); 
03712:  MOVLW  14
03714:  MOVWF  00
03716:  DECFSZ 00,F
03718:  BRA    3716
0371A:  NOP   
....................     
....................    //setup_T0_int(T0_1MS); 
....................    //while (!TMR0IF); 
....................  
....................    output_high(LCD_RESETn); 
0371C:  BSF    F8C.2
....................    //setup_T0_int(T0_100MS); 
....................    //while (!TMR0IF); 
....................     
....................    delay_ms(100); 
0371E:  MOVLW  64
03720:  MOVLB  5
03722:  MOVWF  x60
03724:  MOVLB  0
03726:  RCALL  35F0
....................    i2c_start(); 
03728:  BSF    FC5.1
0372A:  BTFSC  FC5.1
0372C:  BRA    372A
....................     
....................    global_lcd_enabled = !i2c_write(LCD_ADDRESS);    // (0x7C)WRITE LCD address 
0372E:  BCF    x9F.0
03730:  MOVLW  7C
03732:  MOVLB  5
03734:  MOVWF  x78
03736:  MOVLB  0
03738:  RCALL  360C
0373A:  MOVF   01,W
0373C:  BNZ   3740
0373E:  BSF    x9F.0
....................    if (!global_lcd_enabled) 
03740:  BTFSC  x9F.0
03742:  BRA    374C
....................    { 
....................       i2c_stop(); 
03744:  BSF    FC5.2
03746:  BTFSC  FC5.2
03748:  BRA    3746
....................       return; 
0374A:  BRA    3B42
....................    } 
....................  
....................    i2c_write(0x00);              // (0x00)Control byte 
0374C:  MOVLB  5
0374E:  CLRF   x78
03750:  MOVLB  0
03752:  RCALL  360C
....................    i2c_write(0x38);              // (0x38)Function Set: 8 bits, 
03754:  MOVLW  38
03756:  MOVLB  5
03758:  MOVWF  x78
0375A:  MOVLB  0
0375C:  RCALL  360C
....................    i2c_stop();                   //  use Instruction Table 0 
0375E:  BSF    FC5.2
03760:  BTFSC  FC5.2
03762:  BRA    3760
....................    delay_cycles(255); 
03764:  MOVLW  54
03766:  MOVWF  00
03768:  DECFSZ 00,F
0376A:  BRA    3768
0376C:  BRA    376E
....................     
....................    i2c_start(); 
0376E:  BSF    FC5.0
03770:  BTFSC  FC5.0
03772:  BRA    3770
....................    i2c_write(LCD_ADDRESS);     // (0x7C)WRITE LCD address 
03774:  MOVLW  7C
03776:  MOVLB  5
03778:  MOVWF  x78
0377A:  MOVLB  0
0377C:  RCALL  360C
....................    i2c_write(0x00);     // (0x00)Control byte 
0377E:  MOVLB  5
03780:  CLRF   x78
03782:  MOVLB  0
03784:  RCALL  360C
....................    i2c_write(0x40);     // set CG address 0 
03786:  MOVLW  40
03788:  MOVLB  5
0378A:  MOVWF  x78
0378C:  MOVLB  0
0378E:  RCALL  360C
....................    i2c_stop(); 
03790:  BSF    FC5.2
03792:  BTFSC  FC5.2
03794:  BRA    3792
....................    delay_cycles(255); 
03796:  MOVLW  54
03798:  MOVWF  00
0379A:  DECFSZ 00,F
0379C:  BRA    379A
0379E:  BRA    37A0
....................    
....................    i2c_start();         // define special character  
037A0:  BSF    FC5.0
037A2:  BTFSC  FC5.0
037A4:  BRA    37A2
....................    i2c_write(LCD_ADDRESS);     // WRITE LCD address 
037A6:  MOVLW  7C
037A8:  MOVLB  5
037AA:  MOVWF  x78
037AC:  MOVLB  0
037AE:  RCALL  360C
....................    i2c_write(0x40);     // Datasend 
037B0:  MOVLW  40
037B2:  MOVLB  5
037B4:  MOVWF  x78
037B6:  MOVLB  0
037B8:  RCALL  360C
....................     
.................... // special char 0 (LEV1) 
....................    i2c_write(0b00000); 
037BA:  MOVLB  5
037BC:  CLRF   x78
037BE:  MOVLB  0
037C0:  RCALL  360C
....................    i2c_write(0b00000); 
037C2:  MOVLB  5
037C4:  CLRF   x78
037C6:  MOVLB  0
037C8:  RCALL  360C
....................    i2c_write(0b00000); 
037CA:  MOVLB  5
037CC:  CLRF   x78
037CE:  MOVLB  0
037D0:  RCALL  360C
....................    i2c_write(0b00000); 
037D2:  MOVLB  5
037D4:  CLRF   x78
037D6:  MOVLB  0
037D8:  RCALL  360C
....................    i2c_write(0b00000); 
037DA:  MOVLB  5
037DC:  CLRF   x78
037DE:  MOVLB  0
037E0:  RCALL  360C
....................    i2c_write(0b00000); 
037E2:  MOVLB  5
037E4:  CLRF   x78
037E6:  MOVLB  0
037E8:  RCALL  360C
....................    i2c_write(0b00000); 
037EA:  MOVLB  5
037EC:  CLRF   x78
037EE:  MOVLB  0
037F0:  RCALL  360C
....................    i2c_write(0b11111); 
037F2:  MOVLW  1F
037F4:  MOVLB  5
037F6:  MOVWF  x78
037F8:  MOVLB  0
037FA:  RCALL  360C
.................... // special char 1 (LEV2) 
....................    i2c_write(0b00000); 
037FC:  MOVLB  5
037FE:  CLRF   x78
03800:  MOVLB  0
03802:  RCALL  360C
....................    i2c_write(0b00000); 
03804:  MOVLB  5
03806:  CLRF   x78
03808:  MOVLB  0
0380A:  RCALL  360C
....................    i2c_write(0b00000); 
0380C:  MOVLB  5
0380E:  CLRF   x78
03810:  MOVLB  0
03812:  RCALL  360C
....................    i2c_write(0b00000); 
03814:  MOVLB  5
03816:  CLRF   x78
03818:  MOVLB  0
0381A:  RCALL  360C
....................    i2c_write(0b00000); 
0381C:  MOVLB  5
0381E:  CLRF   x78
03820:  MOVLB  0
03822:  RCALL  360C
....................    i2c_write(0b00000); 
03824:  MOVLB  5
03826:  CLRF   x78
03828:  MOVLB  0
0382A:  RCALL  360C
....................    i2c_write(0b11111); 
0382C:  MOVLW  1F
0382E:  MOVLB  5
03830:  MOVWF  x78
03832:  MOVLB  0
03834:  RCALL  360C
....................    i2c_write(0b11111); 
03836:  MOVLW  1F
03838:  MOVLB  5
0383A:  MOVWF  x78
0383C:  MOVLB  0
0383E:  RCALL  360C
.................... // special char 2 (LEV4) 
....................    i2c_write(0b00000); 
03840:  MOVLB  5
03842:  CLRF   x78
03844:  MOVLB  0
03846:  RCALL  360C
....................    i2c_write(0b00000); 
03848:  MOVLB  5
0384A:  CLRF   x78
0384C:  MOVLB  0
0384E:  RCALL  360C
....................    i2c_write(0b00000); 
03850:  MOVLB  5
03852:  CLRF   x78
03854:  MOVLB  0
03856:  RCALL  360C
....................    i2c_write(0b00000); 
03858:  MOVLB  5
0385A:  CLRF   x78
0385C:  MOVLB  0
0385E:  RCALL  360C
....................    i2c_write(0b00000); 
03860:  MOVLB  5
03862:  CLRF   x78
03864:  MOVLB  0
03866:  RCALL  360C
....................    i2c_write(0b11111); 
03868:  MOVLW  1F
0386A:  MOVLB  5
0386C:  MOVWF  x78
0386E:  MOVLB  0
03870:  RCALL  360C
....................    i2c_write(0b00000); 
03872:  MOVLB  5
03874:  CLRF   x78
03876:  MOVLB  0
03878:  RCALL  360C
....................    i2c_write(0b00000); 
0387A:  MOVLB  5
0387C:  CLRF   x78
0387E:  MOVLB  0
03880:  RCALL  360C
.................... // special char 3 (LEV5) 
....................    i2c_write(0b00000); 
03882:  MOVLB  5
03884:  CLRF   x78
03886:  MOVLB  0
03888:  RCALL  360C
....................    i2c_write(0b00000); 
0388A:  MOVLB  5
0388C:  CLRF   x78
0388E:  MOVLB  0
03890:  RCALL  360C
....................    i2c_write(0b00000); 
03892:  MOVLB  5
03894:  CLRF   x78
03896:  MOVLB  0
03898:  RCALL  360C
....................    i2c_write(0b00000); 
0389A:  MOVLB  5
0389C:  CLRF   x78
0389E:  MOVLB  0
038A0:  RCALL  360C
....................    i2c_write(0b11111); 
038A2:  MOVLW  1F
038A4:  MOVLB  5
038A6:  MOVWF  x78
038A8:  MOVLB  0
038AA:  RCALL  360C
....................    i2c_write(0b00000); 
038AC:  MOVLB  5
038AE:  CLRF   x78
038B0:  MOVLB  0
038B2:  RCALL  360C
....................    i2c_write(0b00000); 
038B4:  MOVLB  5
038B6:  CLRF   x78
038B8:  MOVLB  0
038BA:  RCALL  360C
....................    i2c_write(0b00000); 
038BC:  MOVLB  5
038BE:  CLRF   x78
038C0:  MOVLB  0
038C2:  RCALL  360C
.................... // special char 4 (LEV7) 
....................    i2c_write(0b00000); 
038C4:  MOVLB  5
038C6:  CLRF   x78
038C8:  MOVLB  0
038CA:  RCALL  360C
....................    i2c_write(0b00000); 
038CC:  MOVLB  5
038CE:  CLRF   x78
038D0:  MOVLB  0
038D2:  RCALL  360C
....................    i2c_write(0b11111); 
038D4:  MOVLW  1F
038D6:  MOVLB  5
038D8:  MOVWF  x78
038DA:  MOVLB  0
038DC:  RCALL  360C
....................    i2c_write(0b00000); 
038DE:  MOVLB  5
038E0:  CLRF   x78
038E2:  MOVLB  0
038E4:  RCALL  360C
....................    i2c_write(0b00000); 
038E6:  MOVLB  5
038E8:  CLRF   x78
038EA:  MOVLB  0
038EC:  RCALL  360C
....................    i2c_write(0b00000); 
038EE:  MOVLB  5
038F0:  CLRF   x78
038F2:  MOVLB  0
038F4:  RCALL  360C
....................    i2c_write(0b00000); 
038F6:  MOVLB  5
038F8:  CLRF   x78
038FA:  MOVLB  0
038FC:  RCALL  360C
....................    i2c_write(0b00000); 
038FE:  MOVLB  5
03900:  CLRF   x78
03902:  MOVLB  0
03904:  RCALL  360C
.................... // special char 5 (LEV8) 
....................    i2c_write(0b00000); 
03906:  MOVLB  5
03908:  CLRF   x78
0390A:  MOVLB  0
0390C:  RCALL  360C
....................    i2c_write(0b11111); 
0390E:  MOVLW  1F
03910:  MOVLB  5
03912:  MOVWF  x78
03914:  MOVLB  0
03916:  RCALL  360C
....................    i2c_write(0b00000); 
03918:  MOVLB  5
0391A:  CLRF   x78
0391C:  MOVLB  0
0391E:  RCALL  360C
....................    i2c_write(0b00000); 
03920:  MOVLB  5
03922:  CLRF   x78
03924:  MOVLB  0
03926:  RCALL  360C
....................    i2c_write(0b00000); 
03928:  MOVLB  5
0392A:  CLRF   x78
0392C:  MOVLB  0
0392E:  RCALL  360C
....................    i2c_write(0b00000); 
03930:  MOVLB  5
03932:  CLRF   x78
03934:  MOVLB  0
03936:  RCALL  360C
....................    i2c_write(0b00000); 
03938:  MOVLB  5
0393A:  CLRF   x78
0393C:  MOVLB  0
0393E:  RCALL  360C
....................    i2c_write(0b00000); 
03940:  MOVLB  5
03942:  CLRF   x78
03944:  MOVLB  0
03946:  RCALL  360C
.................... // special char 6 (LEV9) 
....................    i2c_write(0b11111); 
03948:  MOVLW  1F
0394A:  MOVLB  5
0394C:  MOVWF  x78
0394E:  MOVLB  0
03950:  RCALL  360C
....................    i2c_write(0b11111); 
03952:  MOVLW  1F
03954:  MOVLB  5
03956:  MOVWF  x78
03958:  MOVLB  0
0395A:  RCALL  360C
....................    i2c_write(0b00000); 
0395C:  MOVLB  5
0395E:  CLRF   x78
03960:  MOVLB  0
03962:  RCALL  360C
....................    i2c_write(0b00000); 
03964:  MOVLB  5
03966:  CLRF   x78
03968:  MOVLB  0
0396A:  RCALL  360C
....................    i2c_write(0b00000); 
0396C:  MOVLB  5
0396E:  CLRF   x78
03970:  MOVLB  0
03972:  RCALL  360C
....................    i2c_write(0b00000); 
03974:  MOVLB  5
03976:  CLRF   x78
03978:  MOVLB  0
0397A:  RCALL  360C
....................    i2c_write(0b00000); 
0397C:  MOVLB  5
0397E:  CLRF   x78
03980:  MOVLB  0
03982:  RCALL  360C
....................    i2c_write(0b00000); 
03984:  MOVLB  5
03986:  CLRF   x78
03988:  MOVLB  0
0398A:  RCALL  360C
....................    // special char 7 (BIGBOX) 
....................    i2c_write(0b11111); 
0398C:  MOVLW  1F
0398E:  MOVLB  5
03990:  MOVWF  x78
03992:  MOVLB  0
03994:  RCALL  360C
....................    i2c_write(0b11111); 
03996:  MOVLW  1F
03998:  MOVLB  5
0399A:  MOVWF  x78
0399C:  MOVLB  0
0399E:  RCALL  360C
....................    i2c_write(0b11111); 
039A0:  MOVLW  1F
039A2:  MOVLB  5
039A4:  MOVWF  x78
039A6:  MOVLB  0
039A8:  RCALL  360C
....................    i2c_write(0b11111); 
039AA:  MOVLW  1F
039AC:  MOVLB  5
039AE:  MOVWF  x78
039B0:  MOVLB  0
039B2:  RCALL  360C
....................    i2c_write(0b11111); 
039B4:  MOVLW  1F
039B6:  MOVLB  5
039B8:  MOVWF  x78
039BA:  MOVLB  0
039BC:  RCALL  360C
....................    i2c_write(0b11111); 
039BE:  MOVLW  1F
039C0:  MOVLB  5
039C2:  MOVWF  x78
039C4:  MOVLB  0
039C6:  RCALL  360C
....................    i2c_write(0b11111); 
039C8:  MOVLW  1F
039CA:  MOVLB  5
039CC:  MOVWF  x78
039CE:  MOVLB  0
039D0:  RCALL  360C
....................    i2c_write(0b00000);  
039D2:  MOVLB  5
039D4:  CLRF   x78
039D6:  MOVLB  0
039D8:  RCALL  360C
....................   
....................    i2c_stop();  
039DA:  BSF    FC5.2
039DC:  BTFSC  FC5.2
039DE:  BRA    39DC
....................  
....................    i2c_start(); 
039E0:  BSF    FC5.0
039E2:  BTFSC  FC5.0
039E4:  BRA    39E2
....................    i2c_write(0x00);              // (0x00)Control byte 
039E6:  MOVLB  5
039E8:  CLRF   x78
039EA:  MOVLB  0
039EC:  RCALL  360C
....................    i2c_write(0x38);              // (0x38)Function Set: 8 bits, 
039EE:  MOVLW  38
039F0:  MOVLB  5
039F2:  MOVWF  x78
039F4:  MOVLB  0
039F6:  RCALL  360C
....................    i2c_stop();                   //  use Instruction Table 0 
039F8:  BSF    FC5.2
039FA:  BTFSC  FC5.2
039FC:  BRA    39FA
....................     
....................    i2c_stop();  
039FE:  BSF    FC5.2
03A00:  BTFSC  FC5.2
03A02:  BRA    3A00
....................    delay_cycles(255); 
03A04:  MOVLW  54
03A06:  MOVWF  00
03A08:  DECFSZ 00,F
03A0A:  BRA    3A08
03A0C:  BRA    3A0E
....................     
....................    i2c_start();                             
03A0E:  BSF    FC5.0
03A10:  BTFSC  FC5.0
03A12:  BRA    3A10
....................    i2c_write(LCD_ADDRESS);     // (0x7C)WRITE LCD address 
03A14:  MOVLW  7C
03A16:  MOVLB  5
03A18:  MOVWF  x78
03A1A:  MOVLB  0
03A1C:  RCALL  360C
....................    i2c_write(0x00);     // (0x00)Control byte 
03A1E:  MOVLB  5
03A20:  CLRF   x78
03A22:  MOVLB  0
03A24:  RCALL  360C
....................    i2c_write(0x38);     // (0x38)Function Set: 8 bits, use Instruction Table 0 
03A26:  MOVLW  38
03A28:  MOVLB  5
03A2A:  MOVWF  x78
03A2C:  MOVLB  0
03A2E:  RCALL  360C
.................... //   delay_ms(40); 
....................    delay_cycles(255); 
03A30:  MOVLW  54
03A32:  MOVWF  00
03A34:  DECFSZ 00,F
03A36:  BRA    3A34
03A38:  BRA    3A3A
....................    i2c_write(0x39);     // (0x39)Function Set: 8 bits, use Instruction Table 1 
03A3A:  MOVLW  39
03A3C:  MOVLB  5
03A3E:  MOVWF  x78
03A40:  MOVLB  0
03A42:  RCALL  360C
.................... //   delay_ms(40); 
....................    delay_cycles(255); 
03A44:  MOVLW  54
03A46:  MOVWF  00
03A48:  DECFSZ 00,F
03A4A:  BRA    3A48
03A4C:  BRA    3A4E
....................    i2c_write(0x14);     // (0x14)Internal OSC frequency 
03A4E:  MOVLW  14
03A50:  MOVLB  5
03A52:  MOVWF  x78
03A54:  MOVLB  0
03A56:  RCALL  360C
....................    i2c_write(0x74);     // (0x78 recommended, JG prefers 0x74)Contrast set 
03A58:  MOVLW  74
03A5A:  MOVLB  5
03A5C:  MOVWF  x78
03A5E:  MOVLB  0
03A60:  RCALL  360C
....................    i2c_write(0x5E);     // (0x5E)ICON display ON, booster ON 
03A62:  MOVLW  5E
03A64:  MOVLB  5
03A66:  MOVWF  x78
03A68:  MOVLB  0
03A6A:  RCALL  360C
....................    i2c_write(0x6D);     // (0x6D)Follower circuit ON 
03A6C:  MOVLW  6D
03A6E:  MOVLB  5
03A70:  MOVWF  x78
03A72:  MOVLB  0
03A74:  RCALL  360C
.................... //   delay_ms(200); 
....................    delay_cycles(255); 
03A76:  MOVLW  54
03A78:  MOVWF  00
03A7A:  DECFSZ 00,F
03A7C:  BRA    3A7A
03A7E:  BRA    3A80
....................    i2c_write(0x0C);     // (0x0C)Entire display ON;  
03A80:  MOVLW  0C
03A82:  MOVLB  5
03A84:  MOVWF  x78
03A86:  MOVLB  0
03A88:  RCALL  360C
....................                         // (0x0F)Entire display ON/blink at cursor 
....................    i2c_write(0x01);     // (0x01)Clear display 
03A8A:  MOVLW  01
03A8C:  MOVLB  5
03A8E:  MOVWF  x78
03A90:  MOVLB  0
03A92:  RCALL  360C
....................    delay_ms(40); 
03A94:  MOVLW  28
03A96:  MOVLB  5
03A98:  MOVWF  x60
03A9A:  MOVLB  0
03A9C:  RCALL  35F0
....................    i2c_write(0x06);     // (0x06)Entry Mode Set 
03A9E:  MOVLW  06
03AA0:  MOVLB  5
03AA2:  MOVWF  x78
03AA4:  MOVLB  0
03AA6:  RCALL  360C
.................... //   delay_ms(40); 
....................    delay_cycles(255); 
03AA8:  MOVLW  54
03AAA:  MOVWF  00
03AAC:  DECFSZ 00,F
03AAE:  BRA    3AAC
03AB0:  BRA    3AB2
....................    i2c_write(0x38); 
03AB2:  MOVLW  38
03AB4:  MOVLB  5
03AB6:  MOVWF  x78
03AB8:  MOVLB  0
03ABA:  RCALL  360C
.................... //   delay_ms(40); 
....................    delay_cycles(255); 
03ABC:  MOVLW  54
03ABE:  MOVWF  00
03AC0:  DECFSZ 00,F
03AC2:  BRA    3AC0
03AC4:  BRA    3AC6
....................    i2c_stop(); 
03AC6:  BSF    FC5.2
03AC8:  BTFSC  FC5.2
03ACA:  BRA    3AC8
....................     
....................  
....................    i2c_start(); 
03ACC:  BSF    FC5.0
03ACE:  BTFSC  FC5.0
03AD0:  BRA    3ACE
....................    i2c_write(LCD_ADDRESS);     // (0x7C)WRITE LCD address 
03AD2:  MOVLW  7C
03AD4:  MOVLB  5
03AD6:  MOVWF  x78
03AD8:  MOVLB  0
03ADA:  RCALL  360C
....................    i2c_write(0x00);     // (0x00)Control byte 
03ADC:  MOVLB  5
03ADE:  CLRF   x78
03AE0:  MOVLB  0
03AE2:  RCALL  360C
....................    i2c_write(0x38);     // (0x38)Function Set: 8 bits, 
03AE4:  MOVLW  38
03AE6:  MOVLB  5
03AE8:  MOVWF  x78
03AEA:  MOVLB  0
03AEC:  RCALL  360C
....................                         //  use Instruction Table 0 
....................    i2c_write(0x18);     // Clear any shift 
03AEE:  MOVLW  18
03AF0:  MOVLB  5
03AF2:  MOVWF  x78
03AF4:  MOVLB  0
03AF6:  RCALL  360C
....................    i2c_write(0x20);     // CGRAM = 0 
03AF8:  MOVLW  20
03AFA:  MOVLB  5
03AFC:  MOVWF  x78
03AFE:  MOVLB  0
03B00:  RCALL  360C
....................    // JG Jan 30 2015 
....................    i2c_write(0x38); 
03B02:  MOVLW  38
03B04:  MOVLB  5
03B06:  MOVWF  x78
03B08:  MOVLB  0
03B0A:  RCALL  360C
....................     
....................    i2c_stop(); 
03B0C:  BSF    FC5.2
03B0E:  BTFSC  FC5.2
03B10:  BRA    3B0E
....................     
....................    strcpy (global_temp_line_buff, "                "); 
03B12:  CLRF   FEA
03B14:  MOVLW  70
03B16:  MOVWF  FE9
03B18:  MOVLW  00
03B1A:  CALL   04CA
03B1E:  TBLRD*-
03B20:  TBLRD*+
03B22:  MOVF   FF5,W
03B24:  MOVWF  FEE
03B26:  IORLW  00
03B28:  BNZ   3B20
....................    LCD_line1(global_temp_line_buff); 
03B2A:  MOVLB  5
03B2C:  CLRF   x60
03B2E:  MOVLW  70
03B30:  MOVWF  x5F
03B32:  MOVLB  0
03B34:  RCALL  365A
....................    LCD_line2(global_temp_line_buff); 
03B36:  MOVLB  5
03B38:  CLRF   x60
03B3A:  MOVLW  70
03B3C:  MOVWF  x5F
03B3E:  MOVLB  0
03B40:  RCALL  36B4
....................  
....................    return; 
03B42:  RETURN 0
.................... } 
....................  
.................... void LCD_line1(unsigned char *text) 
.................... { 
....................    uint8_t  n; 
....................  
....................    if (!global_lcd_enabled) return;   
*
0365A:  BTFSS  x9F.0
0365C:  BRA    36B2
....................    LCD_position(0x00);   // Move to start of first line 
0365E:  MOVLB  5
03660:  CLRF   x76
03662:  MOVLB  0
03664:  RCALL  3628
....................    i2c_start(); 
03666:  BSF    FC5.0
03668:  BTFSC  FC5.0
0366A:  BRA    3668
....................    i2c_write(LCD_ADDRESS);   // WRITE LCD address 
0366C:  MOVLW  7C
0366E:  MOVLB  5
03670:  MOVWF  x78
03672:  MOVLB  0
03674:  RCALL  360C
....................    i2c_write(0x40);    // Datasend 
03676:  MOVLW  40
03678:  MOVLB  5
0367A:  MOVWF  x78
0367C:  MOVLB  0
0367E:  RCALL  360C
....................    for(n=0;n<16;n++) 
03680:  MOVLB  5
03682:  CLRF   x61
03684:  MOVF   x61,W
03686:  SUBLW  0F
03688:  BNC   36AA
....................    { 
....................       i2c_write(*text); 
0368A:  MOVFF  560,03
0368E:  MOVFF  55F,FE9
03692:  MOVFF  560,FEA
03696:  MOVFF  FEF,578
0369A:  MOVLB  0
0369C:  RCALL  360C
....................       ++text; 
0369E:  MOVLB  5
036A0:  INCF   x5F,F
036A2:  BTFSC  FD8.2
036A4:  INCF   x60,F
036A6:  INCF   x61,F
036A8:  BRA    3684
....................    } 
....................    i2c_stop(); 
036AA:  BSF    FC5.2
036AC:  BTFSC  FC5.2
036AE:  BRA    36AC
036B0:  MOVLB  0
036B2:  RETURN 0
.................... } 
....................  
.................... void LCD_line2(unsigned char *text) 
.................... { 
....................    uint8_t  n; 
....................     
....................    if (!global_lcd_enabled) return; 
036B4:  BTFSS  x9F.0
036B6:  BRA    370E
....................    LCD_position(0x40);   // Move to start of second line 
036B8:  MOVLW  40
036BA:  MOVLB  5
036BC:  MOVWF  x76
036BE:  MOVLB  0
036C0:  RCALL  3628
....................    i2c_start(); 
036C2:  BSF    FC5.0
036C4:  BTFSC  FC5.0
036C6:  BRA    36C4
....................    i2c_write(LCD_ADDRESS);   // WRITE LCD address 
036C8:  MOVLW  7C
036CA:  MOVLB  5
036CC:  MOVWF  x78
036CE:  MOVLB  0
036D0:  RCALL  360C
....................    i2c_write(0x40);    // Datasend 
036D2:  MOVLW  40
036D4:  MOVLB  5
036D6:  MOVWF  x78
036D8:  MOVLB  0
036DA:  RCALL  360C
....................    for(n=0;n<16;n++) 
036DC:  MOVLB  5
036DE:  CLRF   x61
036E0:  MOVF   x61,W
036E2:  SUBLW  0F
036E4:  BNC   3706
....................    { 
....................       i2c_write(*text); 
036E6:  MOVFF  560,03
036EA:  MOVFF  55F,FE9
036EE:  MOVFF  560,FEA
036F2:  MOVFF  FEF,578
036F6:  MOVLB  0
036F8:  RCALL  360C
....................       ++text; 
036FA:  MOVLB  5
036FC:  INCF   x5F,F
036FE:  BTFSC  FD8.2
03700:  INCF   x60,F
03702:  INCF   x61,F
03704:  BRA    36E0
....................    } 
....................    i2c_stop(); 
03706:  BSF    FC5.2
03708:  BTFSC  FC5.2
0370A:  BRA    3708
0370C:  MOVLB  0
0370E:  RETURN 0
.................... } 
....................  
.................... void LCD_place_text(unsigned char *text, int1 row, uint8_t col, uint8_t length) 
.................... { 
....................    //places text at a particular position (row (0 or 1), col (0-15)). 
....................    //not much error checking (for speed) on row/col or length (don't cause seg fault) 
....................     
....................    uint8_t n; 
....................     
....................    if (!global_lcd_enabled) return; 
*
04808:  BTFSS  x9F.0
0480A:  BRA    488E
....................    if (col < 16) 
0480C:  MOVLB  5
0480E:  MOVF   x72,W
04810:  SUBLW  0F
04812:  BNC   488C
....................    { 
....................       if (row == 0) LCD_position(col);   //set LCD position (row,col) 
04814:  MOVF   x71,F
04816:  BNZ   4826
04818:  MOVFF  572,576
0481C:  MOVLB  0
0481E:  CALL   3628
04822:  BRA    4834
04824:  MOVLB  5
....................       else LCD_position(0x40 + col); 
04826:  MOVLW  40
04828:  ADDWF  x72,W
0482A:  MOVWF  x75
0482C:  MOVWF  x76
0482E:  MOVLB  0
04830:  CALL   3628
....................        
....................       i2c_start(); 
04834:  BSF    FC5.0
04836:  BTFSC  FC5.0
04838:  BRA    4836
....................       i2c_write(LCD_ADDRESS);   // WRITE LCD address 
0483A:  MOVLW  7C
0483C:  MOVLB  5
0483E:  MOVWF  x78
04840:  MOVLB  0
04842:  CALL   360C
....................       i2c_write(0x40);    // Datasend 
04846:  MOVLW  40
04848:  MOVLB  5
0484A:  MOVWF  x78
0484C:  MOVLB  0
0484E:  CALL   360C
....................       for(n = 0; ((n < length) && ((n + col) < 16)); n++) 
04852:  MOVLB  5
04854:  CLRF   x74
04856:  MOVF   x73,W
04858:  SUBWF  x74,W
0485A:  BC    4886
0485C:  MOVF   x72,W
0485E:  ADDWF  x74,W
04860:  SUBLW  0F
04862:  BNC   4886
....................       { 
....................         i2c_write(*text); 
04864:  MOVFF  570,03
04868:  MOVFF  56F,FE9
0486C:  MOVFF  570,FEA
04870:  MOVFF  FEF,578
04874:  MOVLB  0
04876:  CALL   360C
....................         ++text; 
0487A:  MOVLB  5
0487C:  INCF   x6F,F
0487E:  BTFSC  FD8.2
04880:  INCF   x70,F
04882:  INCF   x74,F
04884:  BRA    4856
....................       } 
....................       i2c_stop(); 
04886:  BSF    FC5.2
04888:  BTFSC  FC5.2
0488A:  BRA    4888
0488C:  MOVLB  0
....................    } 
0488E:  RETURN 0
.................... } 
....................  
.................... void LCD_place_char(char ascii, int1 row, uint8_t col) 
.................... { 
....................    //places a char at a particular position (row (0 or 1), col (0-15)). 
....................    //no error checking (for speed) on row/col (don't cause seg fault) 
....................     
....................    if (!global_lcd_enabled) return; 
*
07C2A:  BTFSS  x9F.0
07C2C:  BRA    7C5C
....................    if (col < 16) 
07C2E:  MOVLB  5
07C30:  MOVF   x54,W
07C32:  SUBLW  0F
07C34:  BNC   7C5E
....................    { 
....................       if (row == 0) LCD_position(col);   //set LCD position (row,col) 
07C36:  MOVF   x53,F
07C38:  BNZ   7C48
07C3A:  MOVFF  554,576
07C3E:  MOVLB  0
07C40:  CALL   3628
07C44:  BRA    7C56
07C46:  MOVLB  5
....................       else LCD_position(0x40 + col); 
07C48:  MOVLW  40
07C4A:  ADDWF  x54,W
07C4C:  MOVWF  x55
07C4E:  MOVWF  x76
07C50:  MOVLB  0
07C52:  CALL   3628
....................        
....................       LCD_char(ascii); 
07C56:  MOVFF  552,555
07C5A:  BRA    7BF6
07C5C:  MOVLB  5
....................    } 
07C5E:  MOVLB  0
07C60:  RETURN 0
.................... } 
....................  
.................... void LCD_place_uint8(uint8_t num, int1 row, uint8_t col, uint8_t length) 
.................... { 
....................    uint8_t n;  
....................     
....................    if (!global_lcd_enabled) return;   
*
04890:  BTFSS  x9F.0
04892:  BRA    491E
....................     
....................    if (length <= 3) 
04894:  MOVLB  5
04896:  MOVF   x63,W
04898:  SUBLW  03
0489A:  BNC   4920
....................    { 
....................       for (n = 0; n < 3; n++) 
0489C:  CLRF   x64
0489E:  MOVF   x64,W
048A0:  SUBLW  02
048A2:  BNC   48E4
....................       { 
....................          *(global_temp_line_buff + (2 - n)) = ('0' + (num%10)); 
048A4:  MOVLW  02
048A6:  BSF    FD8.0
048A8:  SUBFWB x64,W
048AA:  ADDLW  70
048AC:  MOVWF  01
048AE:  CLRF   03
048B0:  BTFSC  FD8.0
048B2:  INCF   03,F
048B4:  MOVWF  FE9
048B6:  MOVFF  03,FEA
048BA:  MOVFF  560,567
048BE:  MOVLW  0A
048C0:  MOVWF  x68
048C2:  MOVLB  0
048C4:  RCALL  47DC
048C6:  MOVF   00,W
048C8:  ADDLW  30
048CA:  MOVWF  FEF
....................          num/=10; 
048CC:  MOVFF  560,567
048D0:  MOVLW  0A
048D2:  MOVLB  5
048D4:  MOVWF  x68
048D6:  MOVLB  0
048D8:  RCALL  47DC
048DA:  MOVFF  01,560
048DE:  MOVLB  5
048E0:  INCF   x64,F
048E2:  BRA    489E
....................       } 
....................       global_extra_lcd_ptr = global_temp_line_buff; 
048E4:  MOVLB  0
048E6:  CLRF   x82
048E8:  MOVLW  70
048EA:  MOVWF  x81
....................       for (n = length; n < 3; n++) 
048EC:  MOVFF  563,564
048F0:  MOVLB  5
048F2:  MOVF   x64,W
048F4:  SUBLW  02
048F6:  BNC   4906
....................       { 
....................          ++global_extra_lcd_ptr; 
048F8:  MOVLB  0
048FA:  INCF   x81,F
048FC:  BTFSC  FD8.2
048FE:  INCF   x82,F
04900:  MOVLB  5
04902:  INCF   x64,F
04904:  BRA    48F2
....................       } 
....................        
....................       LCD_place_text(global_extra_lcd_ptr,row, col, length); 
04906:  MOVFF  82,570
0490A:  MOVFF  81,56F
0490E:  MOVFF  561,571
04912:  MOVFF  562,572
04916:  MOVFF  563,573
0491A:  MOVLB  0
0491C:  RCALL  4808
0491E:  MOVLB  5
....................    }    
04920:  MOVLB  0
04922:  RETURN 0
.................... } 
....................  
.................... void LCD_place_uint16(uint16_t num, int1 row, uint8_t col, uint8_t length) 
.................... { 
....................    uint8_t n;   
....................    char *global_temp_line_buff[5]; 
....................     
....................    if (!global_lcd_enabled) return;   
04924:  BTFSS  x9F.0
04926:  BRA    49CC
....................     
....................    if (length <= 5) 
04928:  MOVLB  5
0492A:  MOVF   x63,W
0492C:  SUBLW  05
0492E:  BNC   49CE
....................    { 
....................       for (n = 0; n < 5; n++) 
04930:  CLRF   x64
04932:  MOVF   x64,W
04934:  SUBLW  04
04936:  BNC   4990
....................       { 
....................          *(global_temp_line_buff + (4 - n)) = ('0' + (num%10)); 
04938:  MOVLW  04
0493A:  BSF    FD8.0
0493C:  SUBFWB x64,W
0493E:  ADDLW  65
04940:  MOVWF  01
04942:  MOVLW  05
04944:  MOVWF  03
04946:  BTFSC  FD8.0
04948:  INCF   03,F
0494A:  MOVFF  01,FE9
0494E:  MOVFF  03,FEA
04952:  MOVFF  560,572
04956:  MOVFF  55F,571
0495A:  CLRF   x74
0495C:  MOVLW  0A
0495E:  MOVWF  x73
04960:  MOVLB  0
04962:  CALL   402E
04966:  MOVF   00,W
04968:  ADDLW  30
0496A:  MOVWF  FEF
....................          num/=10; 
0496C:  MOVFF  560,572
04970:  MOVFF  55F,571
04974:  MOVLB  5
04976:  CLRF   x74
04978:  MOVLW  0A
0497A:  MOVWF  x73
0497C:  MOVLB  0
0497E:  CALL   402E
04982:  MOVFF  02,560
04986:  MOVFF  01,55F
0498A:  MOVLB  5
0498C:  INCF   x64,F
0498E:  BRA    4932
....................       } 
....................       global_extra_lcd_ptr = global_temp_line_buff; 
04990:  MOVLW  05
04992:  MOVLB  0
04994:  MOVWF  x82
04996:  MOVLW  65
04998:  MOVWF  x81
....................       for (n = length; n < 5; n++) 
0499A:  MOVFF  563,564
0499E:  MOVLB  5
049A0:  MOVF   x64,W
049A2:  SUBLW  04
049A4:  BNC   49B4
....................       { 
....................          ++global_extra_lcd_ptr; 
049A6:  MOVLB  0
049A8:  INCF   x81,F
049AA:  BTFSC  FD8.2
049AC:  INCF   x82,F
049AE:  MOVLB  5
049B0:  INCF   x64,F
049B2:  BRA    49A0
....................       } 
....................        
....................       LCD_place_text(global_extra_lcd_ptr,row, col, length); 
049B4:  MOVFF  82,570
049B8:  MOVFF  81,56F
049BC:  MOVFF  561,571
049C0:  MOVFF  562,572
049C4:  MOVFF  563,573
049C8:  MOVLB  0
049CA:  RCALL  4808
049CC:  MOVLB  5
....................    }    
049CE:  MOVLB  0
049D0:  RETURN 0
.................... } 
....................  
.................... void LCD_place_uint32(uint32_t num, int1 row, uint8_t col, uint8_t length) 
.................... { 
....................    uint8_t n;   
....................     
....................    if (!global_lcd_enabled) return;   
*
06558:  BTFSS  x9F.0
0655A:  BRA    6674
....................     
....................    if (length <= 10) 
0655C:  MOVLB  5
0655E:  MOVF   x58,W
06560:  SUBLW  0A
06562:  BTFSS  FD8.0
06564:  BRA    6676
....................    { 
....................       for (n = 0; n < 10; n++) 
06566:  CLRF   x59
06568:  MOVF   x59,W
0656A:  SUBLW  09
0656C:  BNC   6638
....................       { 
....................          *(global_temp_line_buff + (9 - n)) = ('0' + (num%10)); 
0656E:  MOVLW  09
06570:  BSF    FD8.0
06572:  SUBFWB x59,W
06574:  ADDLW  70
06576:  MOVWF  01
06578:  CLRF   03
0657A:  BTFSC  FD8.0
0657C:  INCF   03,F
0657E:  MOVWF  x5A
06580:  MOVFF  03,55B
06584:  MOVFF  FEA,55D
06588:  MOVFF  FE9,55C
0658C:  BSF    FD8.1
0658E:  MOVLW  05
06590:  MOVWF  FEA
06592:  MOVLW  5E
06594:  MOVWF  FE9
06596:  CLRF   19
06598:  BTFSC  FF2.7
0659A:  BSF    19.7
0659C:  BCF    FF2.7
0659E:  MOVFF  555,5A0
065A2:  MOVFF  554,59F
065A6:  MOVFF  553,59E
065AA:  MOVFF  552,59D
065AE:  CLRF   xA4
065B0:  CLRF   xA3
065B2:  CLRF   xA2
065B4:  MOVLW  0A
065B6:  MOVWF  xA1
065B8:  MOVLB  0
065BA:  CALL   2388
065BE:  BTFSC  19.7
065C0:  BSF    FF2.7
065C2:  MOVFF  55E,00
065C6:  MOVFF  55F,01
065CA:  MOVFF  560,02
065CE:  MOVFF  561,03
065D2:  MOVFF  55D,FEA
065D6:  MOVFF  55C,FE9
065DA:  MOVLW  30
065DC:  ADDWF  00,F
065DE:  MOVLW  00
065E0:  ADDWFC 01,F
065E2:  ADDWFC 02,F
065E4:  ADDWFC 03,F
065E6:  MOVFF  55B,FEA
065EA:  MOVFF  55A,FE9
065EE:  MOVFF  00,FEF
....................          num/=10; 
065F2:  BCF    FD8.1
065F4:  CLRF   19
065F6:  BTFSC  FF2.7
065F8:  BSF    19.7
065FA:  BCF    FF2.7
065FC:  MOVFF  555,5A0
06600:  MOVFF  554,59F
06604:  MOVFF  553,59E
06608:  MOVFF  552,59D
0660C:  MOVLB  5
0660E:  CLRF   xA4
06610:  CLRF   xA3
06612:  CLRF   xA2
06614:  MOVLW  0A
06616:  MOVWF  xA1
06618:  MOVLB  0
0661A:  CALL   2388
0661E:  BTFSC  19.7
06620:  BSF    FF2.7
06622:  MOVFF  03,555
06626:  MOVFF  02,554
0662A:  MOVFF  01,553
0662E:  MOVFF  00,552
06632:  MOVLB  5
06634:  INCF   x59,F
06636:  BRA    6568
....................       } 
....................       global_extra_lcd_ptr = global_temp_line_buff; 
06638:  MOVLB  0
0663A:  CLRF   x82
0663C:  MOVLW  70
0663E:  MOVWF  x81
....................       for (n = length; n < 10; n++) 
06640:  MOVFF  558,559
06644:  MOVLB  5
06646:  MOVF   x59,W
06648:  SUBLW  09
0664A:  BNC   665A
....................       { 
....................          ++global_extra_lcd_ptr; 
0664C:  MOVLB  0
0664E:  INCF   x81,F
06650:  BTFSC  FD8.2
06652:  INCF   x82,F
06654:  MOVLB  5
06656:  INCF   x59,F
06658:  BRA    6646
....................       } 
....................        
....................       LCD_place_text(global_extra_lcd_ptr,row, col, length); 
0665A:  MOVFF  82,570
0665E:  MOVFF  81,56F
06662:  MOVFF  556,571
06666:  MOVFF  557,572
0666A:  MOVFF  558,573
0666E:  MOVLB  0
06670:  CALL   4808
06674:  MOVLB  5
....................    }    
06676:  MOVLB  0
06678:  RETURN 0
.................... } 
....................  
.................... void LCD_clear(void) 
.................... { 
....................    if (!global_lcd_enabled) return; 
*
059CA:  BTFSS  x9F.0
059CC:  BRA    5A02
....................     
....................    strcpy (global_temp_line_buff, "                "); 
059CE:  CLRF   FEA
059D0:  MOVLW  70
059D2:  MOVWF  FE9
059D4:  MOVLW  00
059D6:  CALL   04CA
059DA:  TBLRD*-
059DC:  TBLRD*+
059DE:  MOVF   FF5,W
059E0:  MOVWF  FEE
059E2:  IORLW  00
059E4:  BNZ   59DC
....................    LCD_line1(global_temp_line_buff); 
059E6:  MOVLB  5
059E8:  CLRF   x60
059EA:  MOVLW  70
059EC:  MOVWF  x5F
059EE:  MOVLB  0
059F0:  CALL   365A
....................    LCD_line2(global_temp_line_buff); 
059F4:  MOVLB  5
059F6:  CLRF   x60
059F8:  MOVLW  70
059FA:  MOVWF  x5F
059FC:  MOVLB  0
059FE:  CALL   36B4
05A02:  RETURN 0
.................... } 
....................  
.................... void LCD_clear_line1(void) 
.................... { 
....................    if (!global_lcd_enabled) return; 
....................     
....................    strcpy (global_temp_line_buff, "                "); 
....................    LCD_line1(global_temp_line_buff); 
.................... } 
....................  
.................... void LCD_clear_line2(void) 
.................... { 
....................    if (!global_lcd_enabled) return; 
....................     
....................    strcpy (global_temp_line_buff, "                "); 
....................    LCD_line2(global_temp_line_buff); 
.................... } 
....................  
.................... void LCD_position(int position) 
.................... { 
....................    if (!global_lcd_enabled) return; 
*
03628:  BTFSS  x9F.0
0362A:  BRA    3658
....................    i2c_start();                             
0362C:  BSF    FC5.0
0362E:  BTFSC  FC5.0
03630:  BRA    362E
....................    i2c_write(LCD_ADDRESS);     // (0x7C)WRITE LCD address 
03632:  MOVLW  7C
03634:  MOVLB  5
03636:  MOVWF  x78
03638:  MOVLB  0
0363A:  RCALL  360C
....................    i2c_write(0x00);     // (0x00)Control byte 
0363C:  MOVLB  5
0363E:  CLRF   x78
03640:  MOVLB  0
03642:  RCALL  360C
....................    i2c_write(0x80+position); //  
03644:  MOVLW  80
03646:  MOVLB  5
03648:  ADDWF  x76,W
0364A:  MOVWF  x77
0364C:  MOVWF  x78
0364E:  MOVLB  0
03650:  RCALL  360C
....................    i2c_stop(); 
03652:  BSF    FC5.2
03654:  BTFSC  FC5.2
03656:  BRA    3654
03658:  RETURN 0
.................... } 
....................  
.................... void LCD_char(char ascii)    
.................... { 
....................    if (!global_lcd_enabled) return; 
*
07BF6:  BTFSS  x9F.0
07BF8:  BRA    7C26
....................    i2c_start();                             
07BFA:  BSF    FC5.0
07BFC:  BTFSC  FC5.0
07BFE:  BRA    7BFC
....................    i2c_write(LCD_ADDRESS);   // WRITE LCD address 
07C00:  MOVLW  7C
07C02:  MOVLB  5
07C04:  MOVWF  x78
07C06:  MOVLB  0
07C08:  CALL   360C
....................    i2c_write(0x40);    // Datasend 
07C0C:  MOVLW  40
07C0E:  MOVLB  5
07C10:  MOVWF  x78
07C12:  MOVLB  0
07C14:  CALL   360C
....................    i2c_write(ascii);    //  
07C18:  MOVFF  555,578
07C1C:  CALL   360C
....................    i2c_stop(); 
07C20:  BSF    FC5.2
07C22:  BTFSC  FC5.2
07C24:  BRA    7C22
07C26:  GOTO   7C5C (RETURN)
.................... } 
....................  
.................... void LCD_shutdown(void)    
.................... {        
....................  
....................    if (!global_lcd_enabled) return;   
*
08B92:  BTFSS  x9F.0
08B94:  BRA    8C06
....................        
....................    output_low(LCD_RESETn); 
08B96:  BCF    F8C.2
....................    delay_ms(5); 
08B98:  MOVLW  67
08B9A:  MOVWF  00
08B9C:  DECFSZ 00,F
08B9E:  BRA    8B9C
08BA0:  BRA    8BA2
....................    output_high(LCD_RESETn); 
08BA2:  BSF    F8C.2
....................     
....................    i2c_start();                             
08BA4:  BSF    FC5.0
08BA6:  BTFSC  FC5.0
08BA8:  BRA    8BA6
....................    i2c_write(LCD_ADDRESS);     // WRITE LCD address 
08BAA:  MOVLW  7C
08BAC:  MOVLB  5
08BAE:  MOVWF  x78
08BB0:  MOVLB  0
08BB2:  CALL   360C
....................    i2c_write(0x00);     // Control byte 
08BB6:  MOVLB  5
08BB8:  CLRF   x78
08BBA:  MOVLB  0
08BBC:  CALL   360C
....................    i2c_write(0x39);     // Function Set: 8 bits, use Instruction Table 1 
08BC0:  MOVLW  39
08BC2:  MOVLB  5
08BC4:  MOVWF  x78
08BC6:  MOVLB  0
08BC8:  CALL   360C
....................    i2c_write(0x52);     // ICON display OFF, booster OFF 
08BCC:  MOVLW  52
08BCE:  MOVLB  5
08BD0:  MOVWF  x78
08BD2:  MOVLB  0
08BD4:  CALL   360C
....................    i2c_write(0x60);     // Follower circuit OFF 
08BD8:  MOVLW  60
08BDA:  MOVLB  5
08BDC:  MOVWF  x78
08BDE:  MOVLB  0
08BE0:  CALL   360C
....................    i2c_write(0x08);     // Entire display OFF 
08BE4:  MOVLW  08
08BE6:  MOVLB  5
08BE8:  MOVWF  x78
08BEA:  MOVLB  0
08BEC:  CALL   360C
....................    i2c_stop(); 
08BF0:  BSF    FC5.2
08BF2:  BTFSC  FC5.2
08BF4:  BRA    8BF2
....................     
....................    output_low(LCD_RESETn); 
08BF6:  BCF    F8C.2
....................    delay_ms(5); 
08BF8:  MOVLW  67
08BFA:  MOVWF  00
08BFC:  DECFSZ 00,F
08BFE:  BRA    8BFC
08C00:  BRA    8C02
....................    output_high(LCD_RESETn); 
08C02:  BSF    F8C.2
....................    global_lcd_enabled = 0; 
08C04:  BCF    x9F.0
08C06:  GOTO   8C8C (RETURN)
.................... } 
....................  
.................... void LCD_startup_splash(void) 
.................... {                               
....................    uint8_t n; 
....................     
....................    if (!global_lcd_enabled) return; 
....................     
....................    strcpy(global_temp_line_buff, "Jain Genesys    "); 
....................    for (n = 0; n < 16; n++) 
....................       { 
....................       LCD_place_text(global_temp_line_buff,0,(15-n),16); 
....................       setup_T0_int(T0_100MS); 
....................       while (!TMR0IF); 
....................       } 
....................    strcpy(global_temp_line_buff, "Version         ");    
....................    for (n = 0; n < 16; n++) 
....................    { 
....................       LCD_place_text(global_temp_line_buff,1,(15-n),16); 
....................       setup_T0_int(T0_100MS); 
....................       while (!TMR0IF); 
....................    }    
....................    strcpy(global_temp_line_buff, global_firmware_version_string); 
....................    LCD_place_text(global_temp_line_buff,1,8,4); 
....................    setup_T0_int(T0_2S); 
....................    while (!TMR0IF); 
....................    for (n = 0; n < 16; n++) 
....................    { 
....................       LCD_place_char(' ',0,(15-n)); 
....................       LCD_place_char(' ',1,(15-n)); 
....................       setup_T0_int(T0_100MS); 
....................       while (!TMR0IF);  
....................    }    
.................... } 
.................... /* 
.................... void LCD_display_battery_voltage(int1 lcd_line) 
.................... { 
....................    //Grabs and displays battery voltage on LCD 
....................    //Takes the LCD line that it should be displayed 
....................    //on as input. 
....................  
....................     
....................    uint8_t temp_bat_int_part = 0; 
....................    uint16_t temp_bat_fract_part = 0; 
....................    uint32_t temp_bat_both_part = 0; 
....................    char * digit_result; 
....................     
....................    if (!global_lcd_enabled) return; 
....................    //set line buffer to all spaces 
....................    char lcd_line_buff[17] = {' '}; 
....................     
....................    strcpy (lcd_line_buff, "Battery = ?.???V"); 
....................  
....................    // get the battery count (not charging) 
....................    // and convert it to a voltage 
....................    temp_bat_both_part = calc_vbatt(get_vbatt(1)); 
....................    temp_bat_fract_part = (uint16_t) (temp_bat_both_part); 
....................    temp_bat_int_part = (uint8_t) (temp_bat_both_part >> 16); 
....................    digit_result = word_to_4dig_new(temp_bat_fract_part); 
....................     
....................     
....................    if (digit_result != 0) 
....................    { 
....................       lcd_line_buff[10] = '0' + temp_bat_int_part; 
....................       lcd_line_buff[12] = digit_result[3]; 
....................       lcd_line_buff[13] = digit_result[2]; 
....................       lcd_line_buff[14] = digit_result[1]; 
....................    } 
....................    else 
....................    { 
....................       strcpy (lcd_line_buff, "Battery ERROR!  "); 
....................    } 
....................     
....................    if (lcd_line == 0) 
....................    { 
....................       LCD_line1(lcd_line_buff); 
....................    } 
....................    else if (lcd_line == 1) 
....................    { 
....................       LCD_line2(lcd_line_buff); 
....................    } 
.................... } 
....................  
.................... uint32_t LCD_battery_screen(uint16_t vRef) 
.................... { 
.................... //Puts the battery voltage on the LCD across both screens 
.................... // 
.................... } 
....................  
....................  
.................... void LCD_display_revision(int1 lcd_line) 
.................... { 
....................    if (!global_lcd_enabled) return; 
....................    strcpy (line2_buff, "Rev.            "); 
....................    tempo_u8 = make8(FIRMWARE_REV,1); 
....................    line2_buff[4] = hi2asc(tempo_u8); 
....................     
.................... #ifdef  WIP 
....................    line2_buff[4] += 0x20;     // lowercase if work in progress 
.................... #endif 
....................    line2_buff[5] = lo2asc(tempo_u8); 
....................    tempo_u8 = make8(FIRMWARE_REV,0); 
....................    line2_buff[6] = hi2asc(tempo_u8); 
....................    line2_buff[7] = lo2asc(tempo_u8); 
....................   
.................... } 
.................... */ 
....................  
.................... void LCD_display_priority_time_stacks(void) 
.................... {                                            
....................       if (!global_lcd_enabled) return;     
....................        
....................    disable_interrupts(GLOBAL); 
....................    LCD_place_uint8(global_current_priority_queue_location, 0, 0, 3);      
....................        
....................       if (global_current_priority_queue_location != 255) 
....................       {      
....................          LCD_place_uint8(global_priority_queue[global_current_priority_queue_location], 0, 4, 3); 
....................       } 
....................       else 
....................       {       
....................          strcpy (global_temp_line_buff, "   "); 
....................          LCD_place_text(global_temp_line_buff, 0, 4, 3); 
....................       } 
....................        
....................       LCD_place_uint8(global_current_time_queue_location, 0, 8, 3); 
....................        
....................       if (global_current_time_queue_location != 255) 
....................       { 
....................          LCD_place_uint8(global_priority_queue[global_current_time_queue_location], 0, 12, 3); 
....................       } 
....................       else 
....................       {       
....................          strcpy (global_temp_line_buff, "   "); 
....................          LCD_place_text(global_temp_line_buff, 0, 12, 3); 
....................       } 
....................       enable_interrupts(GLOBAL); 
.................... }  
....................  
.................... void LCD_display_priority_time_stacks_2(void) 
.................... { 
....................    uint8_t n; 
....................     
....................    disable_interrupts(INT_CCP4); 
....................    LCD_clear(); 
....................    for (n = 0; n < MAX_TIME_QUEUE_ITEMS; n++) 
....................    { 
....................       LCD_place_uint8(n,0,0,1); 
....................       LCD_place_uint8(global_time_queue[n].pq_priority,0,2,3);                       
....................       LCD_place_uint32(global_time_queue[n].time_to_execute,0,6,5); 
....................       LCD_place_uint8(global_current_time_queue_location, 0, 12, 3);        
....................       setup_T0_int(T0_250MS);                                                       
....................       while (!TMR0IF);     
....................    }                               
....................    enable_interrupts(INT_CCP4);                                  
.................... } 
....................  
.................... void LCD_display_priority_queue(void) 
.................... { 
....................    uint8_t n; 
....................     
....................    disable_interrupts(GLOBAL); 
....................    LCD_clear(); 
....................    for (n = 0; n < MAX_PRIORITY_QUEUE_ITEMS; n++) 
....................    { 
....................       LCD_place_uint8(n,0,0,2); 
....................       LCD_place_uint8(global_priority_queue[n],0,3,3); 
....................       LCD_place_uint8(global_current_priority_queue_location, 0, 7, 3); 
....................       if (global_priority_queue[n] != EMPTY_PRIORITY_QUEUE) 
....................          setup_T0_int(T0_1S); 
....................       while (!TMR0IF); 
....................    } 
....................    enable_interrupts(GLOBAL); 
.................... } 
....................                  
.................... void LCD_display_message_queue(void)  
.................... { 
....................    uint8_t n; 
....................    disable_interrupts(INT_CCP4); 
....................     
....................    for (n = global_current_message_queue_location; n != 255; n--) 
....................    {                                                                                                                          
....................       LCD_clear(); 
....................       LCD_place_uint8(n, 0, 0, 3);                                 
....................       LCD_place_uint32(global_message_queue[n].time_to_send, 0, 4, 10); 
....................       LCD_place_uint8(global_message_queue[n].message_type, 1, 0, 3); 
....................       LCD_place_uint16(global_message_queue[n].msg_seq, 1, 4, 5);  
....................       LCD_place_uint8(global_message_queue[n].attempt_num, 1, 10, 3);  
....................       while(input(SW1n)); 
....................    }                          
....................    LCD_clear(); 
....................    enable_interrupts(INT_CCP4);   
.................... }                                                                        
.................... void LCD_display_battery_voltage(int1 lcd_line) 
.................... {                                            
....................    if (!global_lcd_enabled) return;     
*
049D2:  BTFSS  x9F.0
049D4:  BRA    4A7E
....................        
....................    uint32_t battery_voltage = calc_vbatt(get_vbatt(1)); 
049D6:  MOVLW  01
049D8:  MOVLB  5
049DA:  MOVWF  x53
049DC:  MOVLB  0
049DE:  CALL   3F5E
049E2:  MOVFF  02,54D
049E6:  MOVFF  01,54C
049EA:  MOVFF  02,54F
049EE:  MOVFF  01,54E
049F2:  BRA    468E
049F4:  MOVFF  03,54B
049F8:  MOVFF  02,54A
049FC:  MOVFF  01,549
04A00:  MOVFF  00,548
....................    strcpy (global_temp_line_buff, "Vbatt =  .     V"); 
04A04:  CLRF   FEA
04A06:  MOVLW  70
04A08:  MOVWF  FE9
04A0A:  MOVLW  00
04A0C:  CALL   04EC
04A10:  TBLRD*-
04A12:  TBLRD*+
04A14:  MOVF   FF5,W
04A16:  MOVWF  FEE
04A18:  IORLW  00
04A1A:  BNZ   4A12
....................    if (lcd_line == 0) LCD_line1(global_temp_line_buff); 
04A1C:  MOVLB  5
04A1E:  MOVF   x47,F
04A20:  BNZ   4A32
04A22:  CLRF   x60
04A24:  MOVLW  70
04A26:  MOVWF  x5F
04A28:  MOVLB  0
04A2A:  CALL   365A
04A2E:  BRA    4A3E
04A30:  MOVLB  5
....................    else LCD_line2(global_temp_line_buff); 
04A32:  CLRF   x60
04A34:  MOVLW  70
04A36:  MOVWF  x5F
04A38:  MOVLB  0
04A3A:  CALL   36B4
....................    LCD_place_uint8((uint8_t)(battery_voltage>>16),lcd_line,8,1); 
04A3E:  MOVFF  54A,00
04A42:  MOVFF  54B,01
04A46:  CLRF   02
04A48:  CLRF   03
04A4A:  MOVFF  54A,54D
04A4E:  MOVFF  54A,560
04A52:  MOVFF  547,561
04A56:  MOVLW  08
04A58:  MOVLB  5
04A5A:  MOVWF  x62
04A5C:  MOVLW  01
04A5E:  MOVWF  x63
04A60:  MOVLB  0
04A62:  RCALL  4890
.................... //   LCD_place_uint16((uint16_t)battery_voltage,lcd_line,10,4); 
....................    LCD_place_uint16((uint16_t)battery_voltage,lcd_line,10,4); 
04A64:  MOVFF  549,560
04A68:  MOVFF  548,55F
04A6C:  MOVFF  547,561
04A70:  MOVLW  0A
04A72:  MOVLB  5
04A74:  MOVWF  x62
04A76:  MOVLW  04
04A78:  MOVWF  x63
04A7A:  MOVLB  0
04A7C:  RCALL  4924
04A7E:  GOTO   998C (RETURN)
.................... } 
....................  
.................... void LCD_display_batt_voltage(int1 lcd_line, uint8_t col, uint8_t precision) 
.................... { 
....................    // precision is the number of digits to the right of the decimal pt 
....................    // Valid values are 1, 2, 3 
....................     
....................    if (!global_lcd_enabled) return; 
*
07E5A:  BTFSS  x9F.0
07E5C:  BRA    7FEE
....................  
....................    if (col>15) 
07E5E:  MOVLB  5
07E60:  MOVF   x49,W
07E62:  SUBLW  0F
07E64:  BC    7E6C
....................       return; 
07E66:  MOVLB  0
07E68:  BRA    7FEE
07E6A:  MOVLB  5
....................    if (precision > 3) 
07E6C:  MOVF   x4A,W
07E6E:  SUBLW  03
07E70:  BC    7E76
....................       precision = 3;   
07E72:  MOVLW  03
07E74:  MOVWF  x4A
....................     
....................    if ((precision == 3) && (col > 11)) 
07E76:  MOVF   x4A,W
07E78:  SUBLW  03
07E7A:  BNZ   7E84
07E7C:  MOVF   x49,W
07E7E:  SUBLW  0B
07E80:  BC    7E84
....................       precision--; 
07E82:  DECF   x4A,F
....................    if ((precision == 2) && (col > 12)) 
07E84:  MOVF   x4A,W
07E86:  SUBLW  02
07E88:  BNZ   7E92
07E8A:  MOVF   x49,W
07E8C:  SUBLW  0C
07E8E:  BC    7E92
....................       precision--; 
07E90:  DECF   x4A,F
....................    if ((precision == 1) && (col > 13)) 
07E92:  DECFSZ x4A,W
07E94:  BRA    7E9E
07E96:  MOVF   x49,W
07E98:  SUBLW  0D
07E9A:  BC    7E9E
....................       precision--; 
07E9C:  DECF   x4A,F
....................        
....................    uint16_t battery_voltage_BCD = calc_vbatt_BCD(get_vbatt(1)); 
....................  
....................    uint8_t volts = '0' + (uint8_t)(battery_voltage_BCD >> 12); 
....................    uint8_t tenths = '0' + (uint8_t)((battery_voltage_BCD & 0x0F00) >> 8); 
....................    uint8_t hundredths = '0' + (uint8_t)((battery_voltage_BCD & 0x00F0) >> 4); 
....................    uint8_t thousandths = '0' + (uint8_t)(battery_voltage_BCD & 0x000F); 
07E9E:  MOVLW  01
07EA0:  MOVWF  x53
07EA2:  MOVLB  0
07EA4:  CALL   3F5E
07EA8:  MOVFF  02,552
07EAC:  MOVFF  01,551
07EB0:  MOVFF  02,554
07EB4:  MOVFF  01,553
07EB8:  BRA    7C62
07EBA:  MOVFF  02,54C
07EBE:  MOVFF  01,54B
07EC2:  MOVLB  5
07EC4:  SWAPF  x4C,W
07EC6:  MOVWF  02
07EC8:  CLRF   03
07ECA:  MOVLW  0F
07ECC:  ANDWF  02,F
07ECE:  MOVF   02,W
07ED0:  ADDLW  30
07ED2:  MOVWF  x4D
07ED4:  CLRF   x51
07ED6:  MOVF   x4C,W
07ED8:  ANDLW  0F
07EDA:  MOVWF  x52
07EDC:  CLRF   03
07EDE:  ADDLW  30
07EE0:  MOVWF  x4E
07EE2:  MOVF   x4B,W
07EE4:  ANDLW  F0
07EE6:  MOVWF  x51
07EE8:  CLRF   x52
07EEA:  RRCF   x52,W
07EEC:  MOVWF  03
07EEE:  RRCF   x51,W
07EF0:  MOVWF  02
07EF2:  RRCF   03,F
07EF4:  RRCF   02,F
07EF6:  RRCF   03,F
07EF8:  RRCF   02,F
07EFA:  RRCF   03,F
07EFC:  RRCF   02,F
07EFE:  MOVLW  0F
07F00:  ANDWF  03,F
07F02:  MOVF   02,W
07F04:  ADDLW  30
07F06:  MOVWF  x4F
07F08:  MOVF   x4B,W
07F0A:  ANDLW  0F
07F0C:  MOVWF  00
07F0E:  MOVF   00,W
07F10:  ADDLW  30
07F12:  MOVWF  x50
....................    
....................    switch (precision) 
07F14:  MOVF   x4A,W
07F16:  XORLW  00
07F18:  MOVLB  0
07F1A:  BZ    7F26
07F1C:  XORLW  01
07F1E:  BZ    7F34
07F20:  XORLW  03
07F22:  BZ    7F4E
07F24:  BRA    7F72
....................    { 
....................       case 0: 
....................          if (tenths > '5') 
07F26:  MOVLB  5
07F28:  MOVF   x4E,W
07F2A:  SUBLW  35
07F2C:  BC    7F30
....................             volts++; 
07F2E:  INCF   x4D,F
....................          break; 
07F30:  MOVLB  0
07F32:  BRA    7F72
....................        
....................       case 1: 
....................          if (hundredths > '5') 
07F34:  MOVLB  5
07F36:  MOVF   x4F,W
07F38:  SUBLW  35
07F3A:  BC    7F3E
....................             tenths++; 
07F3C:  INCF   x4E,F
....................          if (tenths > '9' ) 
07F3E:  MOVF   x4E,W
07F40:  SUBLW  39
07F42:  BC    7F4A
....................          { 
....................             volts++; 
07F44:  INCF   x4D,F
....................             tenths = '0'; 
07F46:  MOVLW  30
07F48:  MOVWF  x4E
....................          } 
....................          break; 
07F4A:  MOVLB  0
07F4C:  BRA    7F72
....................  
....................       case 2: 
....................          if (thousandths > '5') 
07F4E:  MOVLB  5
07F50:  MOVF   x50,W
07F52:  SUBLW  35
07F54:  BC    7F58
....................             hundredths++; 
07F56:  INCF   x4F,F
....................          if (hundredths > '9') 
07F58:  MOVF   x4F,W
07F5A:  SUBLW  39
07F5C:  BC    7F64
....................          { 
....................             tenths++; 
07F5E:  INCF   x4E,F
....................             hundredths = '0'; 
07F60:  MOVLW  30
07F62:  MOVWF  x4F
....................          } 
....................          if (tenths > '9') 
07F64:  MOVF   x4E,W
07F66:  SUBLW  39
07F68:  BC    7F70
....................          { 
....................             volts++; 
07F6A:  INCF   x4D,F
....................             tenths = '0'; 
07F6C:  MOVLW  30
07F6E:  MOVWF  x4E
....................          }          
....................          break; 
07F70:  MOVLB  0
....................    } 
....................    
....................    
....................    LCD_place_char (volts, lcd_line, col++); 
07F72:  MOVLB  5
07F74:  MOVF   x49,W
07F76:  INCF   x49,F
07F78:  MOVWF  x51
07F7A:  MOVFF  54D,552
07F7E:  MOVFF  548,553
07F82:  MOVWF  x54
07F84:  MOVLB  0
07F86:  RCALL  7C2A
....................     
....................    if (precision) 
07F88:  MOVLB  5
07F8A:  MOVF   x4A,F
07F8C:  BZ    7FF0
....................    { 
....................       LCD_place_char ('.', lcd_line, col++); 
07F8E:  MOVF   x49,W
07F90:  INCF   x49,F
07F92:  MOVWF  x51
07F94:  MOVLW  2E
07F96:  MOVWF  x52
07F98:  MOVFF  548,553
07F9C:  MOVFF  551,554
07FA0:  MOVLB  0
07FA2:  RCALL  7C2A
....................       LCD_place_char (tenths, lcd_line, col++); 
07FA4:  MOVLB  5
07FA6:  MOVF   x49,W
07FA8:  INCF   x49,F
07FAA:  MOVWF  x51
07FAC:  MOVFF  54E,552
07FB0:  MOVFF  548,553
07FB4:  MOVWF  x54
07FB6:  MOVLB  0
07FB8:  RCALL  7C2A
....................         
....................       if (precision > 1) 
07FBA:  MOVLB  5
07FBC:  MOVF   x4A,W
07FBE:  SUBLW  01
07FC0:  BC    7FD8
....................          LCD_place_char (hundredths, lcd_line, col++); 
07FC2:  MOVF   x49,W
07FC4:  INCF   x49,F
07FC6:  MOVWF  x51
07FC8:  MOVFF  54F,552
07FCC:  MOVFF  548,553
07FD0:  MOVWF  x54
07FD2:  MOVLB  0
07FD4:  RCALL  7C2A
07FD6:  MOVLB  5
....................       if (precision > 2) 
07FD8:  MOVF   x4A,W
07FDA:  SUBLW  02
07FDC:  BC    7FF0
....................          LCD_place_char (thousandths, lcd_line, col); 
07FDE:  MOVFF  550,552
07FE2:  MOVFF  548,553
07FE6:  MOVFF  549,554
07FEA:  MOVLB  0
07FEC:  RCALL  7C2A
07FEE:  MOVLB  5
....................    } 
07FF0:  MOVLB  0
07FF2:  GOTO   83A6 (RETURN)
.................... }     
....................   
....................  
.................... void LCD_display_shutdown_cause(int1 lcd_line)            
.................... {                    
....................    if (!global_lcd_enabled) return;     
*
04A82:  BTFSS  x9F.0
04A84:  BRA    4AD8
....................     
....................    strcpy (global_temp_line_buff, "Shtdwn Cause:   "); 
04A86:  CLRF   FEA
04A88:  MOVLW  70
04A8A:  MOVWF  FE9
04A8C:  MOVLW  00
04A8E:  CALL   050E
04A92:  TBLRD*-
04A94:  TBLRD*+
04A96:  MOVF   FF5,W
04A98:  MOVWF  FEE
04A9A:  IORLW  00
04A9C:  BNZ   4A94
....................    global_temp_line_buff[14] = hi2asc(global_previous_shutdown_cause); 
04A9E:  MOVFF  4E,560
04AA2:  CALL   3012
04AA6:  MOVFF  01,7E
....................    global_temp_line_buff[15] = lo2asc(global_previous_shutdown_cause); 
04AAA:  MOVFF  4E,560
04AAE:  CALL   3032
04AB2:  MOVFF  01,7F
....................    if (lcd_line == 0) LCD_line1(global_temp_line_buff); 
04AB6:  MOVLB  5
04AB8:  MOVF   x47,F
04ABA:  BNZ   4ACC
04ABC:  CLRF   x60
04ABE:  MOVLW  70
04AC0:  MOVWF  x5F
04AC2:  MOVLB  0
04AC4:  CALL   365A
04AC8:  BRA    4AD8
04ACA:  MOVLB  5
....................    else LCD_line2(global_temp_line_buff); 
04ACC:  CLRF   x60
04ACE:  MOVLW  70
04AD0:  MOVWF  x5F
04AD2:  MOVLB  0
04AD4:  CALL   36B4
04AD8:  GOTO   9998 (RETURN)
.................... } 
....................                                      
.................... void LCD_update_diplay(void)            
*
07FF6:  MOVLW  20
07FF8:  MOVLB  5
07FFA:  MOVWF  x47
.................... {                                       
....................    // char for displaying mote state    
....................    char state_char = ' ';                 
....................        
....................    switch(global_lcd_page_number)       
07FFC:  MOVLB  0
07FFE:  MOVF   x84,W
08000:  XORLW  01
08002:  BZ    8012
08004:  XORLW  03
08006:  BTFSC  FD8.2
08008:  BRA    8156
0800A:  XORLW  01
0800C:  BTFSC  FD8.2
0800E:  BRA    83D8
08010:  BRA    8434
....................    {     
....................       // display screen 1     
....................       case 1:                                    
....................          // This is where you should put the stuff that doesn't need to be updated all the time 
....................          // last update was skipped, clear screen and fill screen         
....................          if (global_skip_lcd_update_count == 1) 
08012:  DECFSZ x83,W
08014:  BRA    8068
....................          {                                         
....................             LCD_clear();                                         
08016:  CALL   59CA
....................             global_skip_lcd_update_count = 0;   
0801A:  CLRF   x83
....................             strcpy (global_temp_line_buff, "v      r    t   "); 
0801C:  CLRF   FEA
0801E:  MOVLW  70
08020:  MOVWF  FE9
08022:  MOVLW  00
08024:  CALL   0530
08028:  TBLRD*-
0802A:  TBLRD*+
0802C:  MOVF   FF5,W
0802E:  MOVWF  FEE
08030:  IORLW  00
08032:  BNZ   802A
....................             LCD_line1(global_temp_line_buff);            
08034:  MOVLB  5
08036:  CLRF   x60
08038:  MOVLW  70
0803A:  MOVWF  x5F
0803C:  MOVLB  0
0803E:  CALL   365A
....................             strcpy (global_temp_line_buff, "c      q    a   "); 
08042:  CLRF   FEA
08044:  MOVLW  70
08046:  MOVWF  FE9
08048:  MOVLW  00
0804A:  CALL   0552
0804E:  TBLRD*-
08050:  TBLRD*+
08052:  MOVF   FF5,W
08054:  MOVWF  FEE
08056:  IORLW  00
08058:  BNZ   8050
....................             LCD_line2(global_temp_line_buff);    
0805A:  MOVLB  5
0805C:  CLRF   x60
0805E:  MOVLW  70
08060:  MOVWF  x5F
08062:  MOVLB  0
08064:  CALL   36B4
....................          }                                                  
....................                                 
....................          // This is where you put what you want on the screen                                        
....................          // v indicates Valve position 
....................          // r indicates speed of rotation Rpm 
....................          // t indicates message Type 
....................          // c indicates real-time Clock in seconds 
....................          // q indicates message Queue location 
....................          // a indicates Attempt_num 
....................          LCD_place_uint16(global_valve_position, 0, 1, 5);           
08068:  MOVFF  BA,560
0806C:  MOVFF  B9,55F
08070:  MOVLB  5
08072:  CLRF   x61
08074:  MOVLW  01
08076:  MOVWF  x62
08078:  MOVLW  05
0807A:  MOVWF  x63
0807C:  MOVLB  0
0807E:  CALL   4924
....................          LCD_place_uint16(global_current_rpm,0,8,3);            
08082:  MOVFF  A3,560
08086:  MOVFF  A2,55F
0808A:  MOVLB  5
0808C:  CLRF   x61
0808E:  MOVLW  08
08090:  MOVWF  x62
08092:  MOVLW  03
08094:  MOVWF  x63
08096:  MOVLB  0
08098:  CALL   4924
....................          LCD_place_uint32(global_rtc_time, 1,1,5);                      
0809C:  MOVFF  88,555
080A0:  MOVFF  87,554
080A4:  MOVFF  86,553
080A8:  MOVFF  85,552
080AC:  MOVLW  01
080AE:  MOVLB  5
080B0:  MOVWF  x56
080B2:  MOVWF  x57
080B4:  MOVLW  05
080B6:  MOVWF  x58
080B8:  MOVLB  0
080BA:  CALL   6558
....................          //LCD_place_uint16(global_xdcr_output, 1, 8, 5);                 
....................          //LCD_place_uint32(global_utc_time, 1,1,10);           
....................                                                                                       
....................          LCD_place_uint8(global_current_message_queue_location, 1, 8, 3); 
080BE:  MOVFF  4EF,560
080C2:  MOVLW  01
080C4:  MOVLB  5
080C6:  MOVWF  x61
080C8:  MOVLW  08
080CA:  MOVWF  x62
080CC:  MOVLW  03
080CE:  MOVWF  x63
080D0:  MOVLB  0
080D2:  CALL   4890
....................          if (global_current_message_queue_location != 255) 
080D6:  MOVLB  4
080D8:  INCFSZ xEF,W
080DA:  BRA    80DE
080DC:  BRA    8154
....................          {                              
....................             LCD_place_uint8(global_message_queue[global_current_message_queue_location].message_type,0,13,3); 
080DE:  MOVF   xEF,W
080E0:  MULLW  08
080E2:  MOVF   FF3,W
080E4:  MOVLB  5
080E6:  CLRF   x49
080E8:  MOVWF  x48
080EA:  MOVLW  04
080EC:  ADDWF  x48,W
080EE:  MOVWF  01
080F0:  MOVLW  00
080F2:  ADDWFC x49,W
080F4:  MOVWF  03
080F6:  MOVF   01,W
080F8:  ADDLW  9F
080FA:  MOVWF  FE9
080FC:  MOVLW  04
080FE:  ADDWFC 03,W
08100:  MOVWF  FEA
08102:  MOVFF  FEF,560
08106:  CLRF   x61
08108:  MOVLW  0D
0810A:  MOVWF  x62
0810C:  MOVLW  03
0810E:  MOVWF  x63
08110:  MOVLB  0
08112:  CALL   4890
....................             LCD_place_uint8(global_message_queue[global_current_message_queue_location].attempt_num,1,13,3); 
08116:  MOVLB  4
08118:  MOVF   xEF,W
0811A:  MULLW  08
0811C:  MOVF   FF3,W
0811E:  MOVLB  5
08120:  CLRF   x49
08122:  MOVWF  x48
08124:  MOVLW  07
08126:  ADDWF  x48,W
08128:  MOVWF  01
0812A:  MOVLW  00
0812C:  ADDWFC x49,W
0812E:  MOVWF  03
08130:  MOVF   01,W
08132:  ADDLW  9F
08134:  MOVWF  FE9
08136:  MOVLW  04
08138:  ADDWFC 03,W
0813A:  MOVWF  FEA
0813C:  MOVFF  FEF,560
08140:  MOVLW  01
08142:  MOVWF  x61
08144:  MOVLW  0D
08146:  MOVWF  x62
08148:  MOVLW  03
0814A:  MOVWF  x63
0814C:  MOVLB  0
0814E:  CALL   4890
08152:  MOVLB  4
....................          }    
....................                 
....................       break;  
08154:  BRA    843A
....................       // display screen 2  
....................       case 2:               
....................          // This is where you should put the stuff that doesn't need to be updated all the time 
....................          // last update was skipped, clear screen and fill screen         
....................          if (global_skip_lcd_update_count == 1)   
08156:  DECFSZ x83,W
08158:  BRA    81AC
....................          {                                         
....................             LCD_clear();                                         
0815A:  CALL   59CA
....................             global_skip_lcd_update_count = 0; 
0815E:  CLRF   x83
....................             strcpy (global_temp_line_buff, "m       n     * "); 
08160:  CLRF   FEA
08162:  MOVLW  70
08164:  MOVWF  FE9
08166:  MOVLW  00
08168:  CALL   0574
0816C:  TBLRD*-
0816E:  TBLRD*+
08170:  MOVF   FF5,W
08172:  MOVWF  FEE
08174:  IORLW  00
08176:  BNZ   816E
....................             LCD_line1(global_temp_line_buff);            
08178:  MOVLB  5
0817A:  CLRF   x60
0817C:  MOVLW  70
0817E:  MOVWF  x5F
08180:  MOVLB  0
08182:  CALL   365A
....................             strcpy (global_temp_line_buff, "p       .       "); 
08186:  CLRF   FEA
08188:  MOVLW  70
0818A:  MOVWF  FE9
0818C:  MOVLW  00
0818E:  CALL   0596
08192:  TBLRD*-
08194:  TBLRD*+
08196:  MOVF   FF5,W
08198:  MOVWF  FEE
0819A:  IORLW  00
0819C:  BNZ   8194
....................             LCD_line2(global_temp_line_buff);    
0819E:  MOVLB  5
081A0:  CLRF   x60
081A2:  MOVLW  70
081A4:  MOVWF  x5F
081A6:  MOVLB  0
081A8:  CALL   36B4
....................          }                                                       
....................                     
....................          // This is the place where you put what you want onto the screen 
....................          // m indicates Mote ID (hex) 
....................          // n indicates Net ID (hex) 
....................          // * indicates mote state (Booting, Idle, Searching, 
....................          //                         Negotiating, Connected, 
....................          //                         Operational, Disconnected, 
....................          //                         Radio test, Promiscuous Listen) 
....................          // p indicates sprinkler Position (2 digit pivot#, 3 digit location) 
....................          // . is the decimal pt in the battery voltage (2 decimal precision) 
....................          // final 4 places are for Firmware Rev 1st char A-F (e.g. A123) 
....................          // last four characters of line 2 is the hex firmware 
....................          //  revision, e.g. D308    
....................           
....................          // place the mac address on the LCD 
....................          global_temp_line_buff[0] = hi2asc(macaddr_rcvd[5]); 
081AC:  MOVFF  9C,560
081B0:  CALL   3012
081B4:  MOVFF  01,70
....................          global_temp_line_buff[1] = lo2asc(macaddr_rcvd[5]); 
081B8:  MOVFF  9C,560
081BC:  CALL   3032
081C0:  MOVFF  01,71
....................          global_temp_line_buff[2] = hi2asc(macaddr_rcvd[6]); 
081C4:  MOVFF  9D,560
081C8:  CALL   3012
081CC:  MOVFF  01,72
....................          global_temp_line_buff[3] = lo2asc(macaddr_rcvd[6]); 
081D0:  MOVFF  9D,560
081D4:  CALL   3032
081D8:  MOVFF  01,73
....................          global_temp_line_buff[4] = hi2asc(macaddr_rcvd[7]); 
081DC:  MOVFF  9E,560
081E0:  CALL   3012
081E4:  MOVFF  01,74
....................          global_temp_line_buff[5] = lo2asc(macaddr_rcvd[7]); 
081E8:  MOVFF  9E,560
081EC:  CALL   3032
081F0:  MOVFF  01,75
....................          LCD_place_text(global_temp_line_buff,0,1,6);  
081F4:  MOVLB  5
081F6:  CLRF   x70
081F8:  MOVLW  70
081FA:  MOVWF  x6F
081FC:  CLRF   x71
081FE:  MOVLW  01
08200:  MOVWF  x72
08202:  MOVLW  06
08204:  MOVWF  x73
08206:  MOVLB  0
08208:  CALL   4808
....................                                 
....................          // place the network id on the LCD                        
....................          global_temp_line_buff[0] = hi2asc(make8(network_id_rcvd,1)); 
0820C:  MOVFF  360,548
08210:  MOVFF  360,560
08214:  CALL   3012
08218:  MOVFF  01,70
....................          global_temp_line_buff[1] = lo2asc(make8(network_id_rcvd,1)); 
0821C:  MOVFF  360,548
08220:  MOVFF  360,560
08224:  CALL   3032
08228:  MOVFF  01,71
....................          global_temp_line_buff[2] = hi2asc(make8(network_id_rcvd,0)); 
0822C:  MOVFF  35F,548
08230:  MOVFF  35F,560
08234:  CALL   3012
08238:  MOVFF  01,72
....................          global_temp_line_buff[3] = lo2asc(make8(network_id_rcvd,0)); 
0823C:  MOVFF  35F,548
08240:  MOVFF  35F,560
08244:  CALL   3032
08248:  MOVFF  01,73
....................          LCD_place_text(global_temp_line_buff,0,9,4);        
0824C:  MOVLB  5
0824E:  CLRF   x70
08250:  MOVLW  70
08252:  MOVWF  x6F
08254:  CLRF   x71
08256:  MOVLW  09
08258:  MOVWF  x72
0825A:  MOVLW  04
0825C:  MOVWF  x73
0825E:  MOVLB  0
08260:  CALL   4808
....................           
....................          // put the mote state on the LCD       
....................          switch (global_mote_state) 
08264:  MOVLB  4
08266:  MOVF   xFC,W
08268:  XORLW  00
0826A:  MOVLB  0
0826C:  BZ    8290
0826E:  XORLW  01
08270:  BZ    8298
08272:  XORLW  03
08274:  BZ    82A0
08276:  XORLW  01
08278:  BZ    82A8
0827A:  XORLW  07
0827C:  BZ    82B0
0827E:  XORLW  01
08280:  BZ    82B8
08282:  XORLW  03
08284:  BZ    82C0
08286:  XORLW  01
08288:  BZ    82C8
0828A:  XORLW  0F
0828C:  BZ    82D0
0828E:  BRA    82DA
....................          {               
....................             case MOTESTATE_INIT: 
....................                // booting 
....................                state_char = 'B'; 
08290:  MOVLW  42
08292:  MOVLB  5
08294:  MOVWF  x47
....................                break;   
08296:  BRA    82E0
....................             case MOTESTATE_IDLE: 
....................                state_char = 'I'; 
08298:  MOVLW  49
0829A:  MOVLB  5
0829C:  MOVWF  x47
....................                break;  
0829E:  BRA    82E0
....................             case MOTESTATE_SEARCHING: 
....................                state_char = 'S'; 
082A0:  MOVLW  53
082A2:  MOVLB  5
082A4:  MOVWF  x47
....................                break;      
082A6:  BRA    82E0
....................             case MOTESTATE_NEGOTIATING: 
....................                state_char = 'N'; 
082A8:  MOVLW  4E
082AA:  MOVLB  5
082AC:  MOVWF  x47
....................                break; 
082AE:  BRA    82E0
....................             case MOTESTATE_CONNECTED: 
....................                state_char = 'C'; 
082B0:  MOVLW  43
082B2:  MOVLB  5
082B4:  MOVWF  x47
....................                break;  
082B6:  BRA    82E0
....................             case MOTESTATE_OPERATIONAL: 
....................                state_char = 'O'; 
082B8:  MOVLW  4F
082BA:  MOVLB  5
082BC:  MOVWF  x47
....................                break;  
082BE:  BRA    82E0
....................             case MOTESTATE_DISCONNECTED: 
....................                state_char = 'D'; 
082C0:  MOVLW  44
082C2:  MOVLB  5
082C4:  MOVWF  x47
....................                break;   
082C6:  BRA    82E0
....................             case MOTESTATE_RADIOTEST: 
....................                state_char = 'R'; 
082C8:  MOVLW  52
082CA:  MOVLB  5
082CC:  MOVWF  x47
....................                break;   
082CE:  BRA    82E0
....................             case MOTESTATE_PROMISCUOUS: 
....................                state_char = 'P'; 
082D0:  MOVLW  50
082D2:  MOVLB  5
082D4:  MOVWF  x47
....................                break;  
082D6:  BRA    82E0
082D8:  MOVLB  0
....................             default: 
....................                state_char = '*'; 
082DA:  MOVLW  2A
082DC:  MOVLB  5
082DE:  MOVWF  x47
....................                break;    
....................          }                      
....................          LCD_place_char(state_char, 0, 15);           
082E0:  MOVFF  547,552
082E4:  CLRF   x53
082E6:  MOVLW  0F
082E8:  MOVWF  x54
082EA:  MOVLB  0
082EC:  RCALL  7C2A
....................                   
....................          // put the sprinkler position??? on the LCD                              
....................          strcpy(global_temp_line_buff, "***"); 
082EE:  CLRF   FEA
082F0:  MOVLW  70
082F2:  MOVWF  FE9
082F4:  MOVLW  00
082F6:  CALL   05B8
082FA:  TBLRD*-
082FC:  TBLRD*+
082FE:  MOVF   FF5,W
08300:  MOVWF  FEE
08302:  IORLW  00
08304:  BNZ   82FC
....................          if (state_char == 'O') 
08306:  MOVLB  5
08308:  MOVF   x47,W
0830A:  SUBLW  4F
0830C:  BNZ   833A
....................             LCD_place_uint8((uint8_t)(network_id_rcvd - NETWORK_ID_DEF), 1, 1, 2); 
0830E:  MOVLW  CD
08310:  MOVLB  3
08312:  SUBWF  x5F,W
08314:  MOVWF  00
08316:  MOVLW  04
08318:  SUBWFB x60,W
0831A:  MOVWF  03
0831C:  MOVFF  00,548
08320:  MOVLB  5
08322:  MOVFF  00,560
08326:  MOVLW  01
08328:  MOVWF  x61
0832A:  MOVWF  x62
0832C:  MOVLW  02
0832E:  MOVWF  x63
08330:  MOVLB  0
08332:  CALL   4890
08336:  BRA    8350
08338:  MOVLB  5
....................          else 
....................             LCD_place_text(global_temp_line_buff,1,1,2); 
0833A:  CLRF   x70
0833C:  MOVLW  70
0833E:  MOVWF  x6F
08340:  MOVLW  01
08342:  MOVWF  x71
08344:  MOVWF  x72
08346:  MOVLW  02
08348:  MOVWF  x73
0834A:  MOVLB  0
0834C:  CALL   4808
....................                                        
....................          // put the sprinkler number on the LCD 
....................          if (global_sprinkler_num > 999) 
08350:  MOVF   x8E,W
08352:  SUBLW  02
08354:  BC    837A
08356:  XORLW  FF
08358:  BNZ   8360
0835A:  MOVF   x8D,W
0835C:  SUBLW  E7
0835E:  BC    837A
....................             LCD_place_text(global_temp_line_buff,1,3,3); 
08360:  MOVLB  5
08362:  CLRF   x70
08364:  MOVLW  70
08366:  MOVWF  x6F
08368:  MOVLW  01
0836A:  MOVWF  x71
0836C:  MOVLW  03
0836E:  MOVWF  x72
08370:  MOVWF  x73
08372:  MOVLB  0
08374:  CALL   4808
08378:  BRA    8394
....................          else 
....................             LCD_place_uint16(global_sprinkler_num, 1, 3, 3); 
0837A:  MOVFF  8E,560
0837E:  MOVFF  8D,55F
08382:  MOVLW  01
08384:  MOVLB  5
08386:  MOVWF  x61
08388:  MOVLW  03
0838A:  MOVWF  x62
0838C:  MOVWF  x63
0838E:  MOVLB  0
08390:  CALL   4924
....................           
....................          // put the battery voltage on the LCD 
....................          LCD_display_batt_voltage(1, 7, 2);                 
08394:  MOVLW  01
08396:  MOVLB  5
08398:  MOVWF  x48
0839A:  MOVLW  07
0839C:  MOVWF  x49
0839E:  MOVLW  02
083A0:  MOVWF  x4A
083A2:  MOVLB  0
083A4:  BRA    7E5A
....................           
....................          // put the firmware version on the LCD 
....................          strcpy(global_temp_line_buff, global_firmware_version_string);       
083A6:  CLRF   FEA
083A8:  MOVLW  70
083AA:  MOVWF  FE9
083AC:  CLRF   FE2
083AE:  MOVLW  4F
083B0:  MOVWF  FE1
083B2:  MOVF   FE7,F
083B4:  MOVFF  FE6,FEE
083B8:  BNZ   83B2
....................          LCD_place_text(global_temp_line_buff,1,12,4);   
083BA:  MOVLB  5
083BC:  CLRF   x70
083BE:  MOVLW  70
083C0:  MOVWF  x6F
083C2:  MOVLW  01
083C4:  MOVWF  x71
083C6:  MOVLW  0C
083C8:  MOVWF  x72
083CA:  MOVLW  04
083CC:  MOVWF  x73
083CE:  MOVLB  0
083D0:  CALL   4808
....................                                                              
....................          break;         
083D4:  MOVLB  4
083D6:  BRA    843A
....................        
....................       // extra screen 
....................       case 3: 
....................          // This is where you should put the stuff that doesn't need to be updated all the time  
....................          // last update was skipped, clear screen and fill screen         
....................          if (global_skip_lcd_update_count == 1)   
083D8:  DECFSZ x83,W
083DA:  BRA    842E
....................          {                                         
....................             LCD_clear();                                         
083DC:  CALL   59CA
....................             global_skip_lcd_update_count = 0; 
083E0:  CLRF   x83
....................             strcpy (global_temp_line_buff, "PAGE 3          "); 
083E2:  CLRF   FEA
083E4:  MOVLW  70
083E6:  MOVWF  FE9
083E8:  MOVLW  00
083EA:  CALL   05CC
083EE:  TBLRD*-
083F0:  TBLRD*+
083F2:  MOVF   FF5,W
083F4:  MOVWF  FEE
083F6:  IORLW  00
083F8:  BNZ   83F0
....................             LCD_line1(global_temp_line_buff);            
083FA:  MOVLB  5
083FC:  CLRF   x60
083FE:  MOVLW  70
08400:  MOVWF  x5F
08402:  MOVLB  0
08404:  CALL   365A
....................             strcpy (global_temp_line_buff, "TEST            "); 
08408:  CLRF   FEA
0840A:  MOVLW  70
0840C:  MOVWF  FE9
0840E:  MOVLW  00
08410:  CALL   05EE
08414:  TBLRD*-
08416:  TBLRD*+
08418:  MOVF   FF5,W
0841A:  MOVWF  FEE
0841C:  IORLW  00
0841E:  BNZ   8416
....................             LCD_line2(global_temp_line_buff);    
08420:  MOVLB  5
08422:  CLRF   x60
08424:  MOVLW  70
08426:  MOVWF  x5F
08428:  MOVLB  0
0842A:  CALL   36B4
....................          }                                                   
....................          // stuff to update each time    
....................  
....................       break; 
0842E:  MOVLB  4
08430:  BRA    843A
08432:  MOVLB  0
....................                                                                      
....................       // if somehow global_lcd_page_number get incremented above the last page, clear the LCD    
....................       default: 
....................          LCD_clear();                
08434:  CALL   59CA
....................       break;     
08438:  MOVLB  4
....................    }                                              
0843A:  MOVLB  0
0843C:  GOTO   A0B0 (RETURN)
.................... }       
....................  
....................                                                                                                    
.................... void XDCR_init(void) 
.................... { 
....................    i2c_start(); 
....................  
....................    global_xcdr_type1_enabled = !i2c_write(XDCR_ADDRESS);    // (0x48) WRITE LCD address? 
....................    if (!global_xcdr_type1_enabled) 
....................    { 
....................       i2c_stop();                                     
....................       delay_cycles(255); 
....................       output_low(XDCR_PWR);   
....................       return;                             
....................    }                              
....................    //i2c_write(0b00000000);                                    
....................    i2c_write(0x00);  
....................    i2c_stop();            
....................    // set up the ADC here 
.................... }     
....................                
.................... void adc_XDCR_init(void) 
*
03588:  MOVLB  5
0358A:  CLRF   x49
0358C:  CLRF   x48
.................... {    
....................    uint8_t n; 
....................    uint16_t xdcr_output_sum = 0; 
....................     
....................    // turn on pullup resisitor on xdcr line (so you can check if it's connected)                     
....................    port_b_pullups(PORTB_PULLUPS_WITH_XDCR);   
0358E:  MOVLW  32
03590:  MOVWF  F61
....................     
....................    // turn on XDCR and wait 100ms for the adc to settle (really only 25ms or so is needed) 
....................    output_high(XDCR_PWR);       
03592:  BSF    F8B.5
....................    setup_T0_int(T0_100MS);                                     
03594:  MOVLW  FE
03596:  MOVWF  x65
03598:  MOVLW  7A
0359A:  MOVWF  x64
0359C:  MOVLB  0
0359E:  RCALL  356C
....................    while(!TMR0IF);           
035A0:  BTFSS  FF2.2
035A2:  BRA    35A0
....................               
....................    // turn on ADC                   
....................    ADON = TRUE;                
035A4:  BSF    FC2.0
....................                                    
....................    // set adc to V_EXTRA_IO_1 (pin 7 on header going "across river") 
....................    set_adc_channel(ADC_XDCR);       
035A6:  MOVLW  34
035A8:  MOVWF  01
035AA:  MOVF   FC2,W
035AC:  ANDLW  83
035AE:  IORWF  01,W
035B0:  MOVWF  FC2
....................  
....................    // sum up 8 samples from the adc (.3 ms/sample @ 250Khz clock)                                                                                                                                                                            
....................    for (n = 0; n < 8; n++) 
035B2:  MOVLB  5
035B4:  CLRF   x47
035B6:  MOVF   x47,W
035B8:  SUBLW  07
035BA:  BNC   35CE
....................    {                                                                                                                                                                                                         
....................       xdcr_output_sum += read_adc(); 
035BC:  BSF    FC2.1
035BE:  BTFSC  FC2.1
035C0:  BRA    35BE
035C2:  MOVF   FC3,W
035C4:  ADDWF  x48,F
035C6:  MOVF   FC4,W
035C8:  ADDWFC x49,F
035CA:  INCF   x47,F
035CC:  BRA    35B6
....................    }                     
....................         
....................    // turn off XDCR power 
....................    output_low(XDCR_PWR);  
035CE:  BCF    F8B.5
....................                                                     
....................    // turn off adc                                                                                          
....................    ADON = FALSE;             
035D0:  BCF    FC2.0
....................                                    
....................    if (xdcr_output_sum < XDCR_ADC_OFF_LIMIT) 
035D2:  MOVF   x49,W
035D4:  SUBLW  13
035D6:  BNC   35E6
035D8:  BNZ   35E0
035DA:  MOVF   x48,W
035DC:  SUBLW  87
035DE:  BNC   35E6
....................    { 
....................       global_xcdr_type1_enabled = TRUE;    
035E0:  MOVLB  0
035E2:  BSF    x9F.2
035E4:  MOVLB  5
....................    }                                             
....................                          
....................    // return pullups to normal state (without testing if XDCR is there)                            
....................    port_b_pullups(PORTB_PULLUPS);         
035E6:  MOVLW  12
035E8:  MOVWF  F61
035EA:  MOVLB  0
035EC:  GOTO   3E44 (RETURN)
.................... }                                     
....................  
.................... uint16_t XDCR_measure(void)                                          
.................... {                                          
....................    uint32_t temp_u32;                                           
....................      
....................    i2c_start(); 
....................                                                      
....................    // (0x49) READ ADC address?                 
....................    i2c_write(XDCR_ADDRESS + 1);    
....................                                      
....................    temp_u32 = make32(i2c_read(TRUE), i2c_read(TRUE), i2c_read(FALSE), 0); 
.................... //   LCD_clear();                     
.................... //   LCD_place_uint32(temp_u32,0,0,10);   
.................... //   global_skip_lcd_update_count = 5;               
....................                                       
....................    i2c_stop();                                                          
....................                                             
....................    if ((make8(temp_u32,3) & 0xC0) == 0xC0)  
....................    {                                 
....................       return 0xFFFF;        // saturated top of scale 
....................    }                                                                                     
....................    else if (!(make8(temp_u32,3) & 0xC0))                          
....................    {                                                                           
....................       return 0;             // saturated bottom of scale 
....................    }             
....................    else                                     
....................    {                                                                                                                                                                          
....................       temp_u32 = temp_u32<<2;           // ignore "Bit23 Sig" and "Bit22 MSB" 
.................... //      LCD_clear();                                     
.................... //      LCD_place_uint8(make8(temp_u32,1),1,0,3); 
.................... //     global_skip_lcd_update_count = 5;                                                                                   
....................       return make16(make8(temp_u32,3), make8(temp_u32,2));               
....................    }                                                               
.................... } 
....................  
.................... uint16_t adc_XDCR_measure()     
*
07B9E:  MOVLB  5
07BA0:  CLRF   x49
07BA2:  CLRF   x48
.................... {                           
....................    uint8_t n; 
....................    uint16_t adc_value = 0;                   
....................     
....................    // if the XDCR isn't connected, return 0 (really, you should never see 0 with adc noise)                      
....................    if (!global_xcdr_type1_enabled) return 0;        
07BA4:  MOVLB  0
07BA6:  BTFSC  x9F.2
07BA8:  BRA    7BB2
07BAA:  MOVLW  00
07BAC:  MOVWF  01
07BAE:  MOVWF  02
07BB0:  BRA    7BF0
....................     
....................    // turn on ADC         
....................    ADON = TRUE;                
07BB2:  BSF    FC2.0
....................                                    
....................    // set adc to V_EXTRA_IO_1 (pin 7 on header going "across river" 
....................    set_adc_channel(ADC_XDCR);       
07BB4:  MOVLW  34
07BB6:  MOVWF  01
07BB8:  MOVF   FC2,W
07BBA:  ANDLW  83
07BBC:  IORWF  01,W
07BBE:  MOVWF  FC2
....................                                      
....................    // sum up 8 samples from the adc (.3 ms/sample @ 250Khz clock)                                                                                                                                                                              
....................    for (n=0; n<8; n++) 
07BC0:  MOVLB  5
07BC2:  CLRF   x47
07BC4:  MOVF   x47,W
07BC6:  SUBLW  07
07BC8:  BNC   7BDC
....................    {                                                                                                                                                                                                         
....................       adc_value += read_adc(); 
07BCA:  BSF    FC2.1
07BCC:  BTFSC  FC2.1
07BCE:  BRA    7BCC
07BD0:  MOVF   FC3,W
07BD2:  ADDWF  x48,F
07BD4:  MOVF   FC4,W
07BD6:  ADDWFC x49,F
07BD8:  INCF   x47,F
07BDA:  BRA    7BC4
....................    }                     
....................                       
....................    // turn off XDCR power 
....................    output_low(XDCR_PWR);  
07BDC:  BCF    F8B.5
....................                 
....................    // turn off adc                                                                                          
....................    ADON = FALSE;             
07BDE:  BCF    FC2.0
....................                                                   
....................    // store XDCR output globally (not shifted)                                               
....................    global_xdcr_output = adc_value;         
07BE0:  MOVFF  549,4C
07BE4:  MOVFF  548,4B
....................                     
....................    // return the voltage shifted by 3 bits to scale from (0-1023) * 8 to 0-65535 or close enough     
....................    return global_xdcr_output;                     
07BE8:  MOVFF  4B,01
07BEC:  MOVFF  4C,02
07BF0:  MOVLB  0
07BF2:  GOTO   A090 (RETURN)
.................... } 
....................  
....................  
.................... void  fixture_init()          
.................... { 
....................    uint8_t  resbyte;               
....................    resbyte = 0;                                                                                              
*
03CE4:  MOVLB  5
03CE6:  CLRF   x47
....................     
....................    safeI2C_start();         
03CE8:  MOVLB  0
03CEA:  RCALL  3B44
....................     
....................    resbyte += i2c_write(FIXTURE_DAC_ADDRESS);                 // FIXTURE DAC ADDRESS 
03CEC:  MOVLW  40
03CEE:  MOVLB  5
03CF0:  MOVWF  x78
03CF2:  MOVLB  0
03CF4:  RCALL  360C
03CF6:  MOVF   01,W
03CF8:  MOVLB  5
03CFA:  ADDWF  x47,F
....................  
....................    resbyte += i2c_write (0x60);                // use internal reference 
03CFC:  MOVLW  60
03CFE:  MOVWF  x78
03D00:  MOVLB  0
03D02:  RCALL  360C
03D04:  MOVF   01,W
03D06:  MOVLB  5
03D08:  ADDWF  x47,F
....................    resbyte += i2c_write (0x00);                // set DAC to 0 
03D0A:  CLRF   x78
03D0C:  MOVLB  0
03D0E:  RCALL  360C
03D10:  MOVF   01,W
03D12:  MOVLB  5
03D14:  ADDWF  x47,F
....................    resbyte += i2c_write (0x00);                // low nibble not used (12 bit DAC) 
03D16:  CLRF   x78
03D18:  MOVLB  0
03D1A:  RCALL  360C
03D1C:  MOVF   01,W
03D1E:  MOVLB  5
03D20:  ADDWF  x47,F
....................     
....................    if (resbyte != 0) global_fixture_enabled = TRUE; 
03D22:  MOVF   x47,F
03D24:  BZ    3D2C
03D26:  MOVLB  0
03D28:  BSF    x9F.4
03D2A:  MOVLB  5
....................    i2c_stop(); 
03D2C:  BSF    FC5.2
03D2E:  BTFSC  FC5.2
03D30:  BRA    3D2E
....................     
....................    set_fixture_dac(NO_FIXTURE); 
03D32:  CLRF   x49
03D34:  CLRF   x48
03D36:  MOVLB  0
03D38:  BRA    3C90
03D3A:  GOTO   3E58 (RETURN)
.................... }                              
....................  
.................... #include "control.h"                      
.................... void setup_gen_rpm(void) 
.................... { 
....................    setup_timer_5(T5_ENABLE_SOSC | T5_EXTERNAL_SYNC | T5_DIV_BY_1); 
*
03F3C:  MOVLB  F
03F3E:  CLRF   x4D
03F40:  MOVLW  8B
03F42:  MOVWF  x4E
....................    setup_ccp5(CCP_USE_TIMER5_AND_TIMER6 | CCP_CAPTURE_RE);  
03F44:  CLRF   x54
03F46:  MOVLW  05
03F48:  MOVWF  x54
03F4A:  MOVLW  F3
03F4C:  ANDWF  x48,F
03F4E:  MOVLW  08
03F50:  IORWF  x48,F
....................    clear_interrupt(INT_CCP5);     // insurance 
03F52:  BCF    F7B.2
....................  
....................    disable_interrupts(INT_TIMER5); 
03F54:  BCF    F7D.1
....................    enable_interrupts(INT_CCP5); 
03F56:  BSF    F7A.2
03F58:  MOVLB  0
03F5A:  GOTO   98FE (RETURN)
.................... } 
....................  
.................... uint16_t calc_gen_rpm(void) 
.................... {   
....................    uint16_t current_rpm16; 
....................    uint32_t current_rpm32; 
....................     
....................       
....................    disable_interrupts(INT_CCP5);                 
*
04BE2:  BCF    F7A.2
....................    current_rpm32 = global_last_rpm_value_time; 
04BE4:  MOVFF  A9,555
04BE8:  MOVFF  A8,554
04BEC:  MOVFF  A7,553
04BF0:  MOVFF  A6,552
....................    enable_interrupts(INT_CCP5);        
04BF4:  BSF    F7A.2
....................                                             
....................    // if the last measurement of rpm was more than RPM_TIMEOUT seconds ago 
....................    if ((global_rtc_time - current_rpm32) > RPM_TIMEOUT)            
04BF6:  MOVLB  5
04BF8:  MOVF   x52,W
04BFA:  MOVLB  0
04BFC:  SUBWF  x85,W
04BFE:  MOVLB  5
04C00:  MOVWF  x56
04C02:  MOVF   x53,W
04C04:  MOVLB  0
04C06:  SUBWFB x86,W
04C08:  MOVLB  5
04C0A:  MOVWF  x57
04C0C:  MOVF   x54,W
04C0E:  MOVLB  0
04C10:  SUBWFB x87,W
04C12:  MOVLB  5
04C14:  MOVWF  x58
04C16:  MOVF   x55,W
04C18:  MOVLB  0
04C1A:  SUBWFB x88,W
04C1C:  MOVLB  5
04C1E:  MOVWF  x59
04C20:  MOVF   x59,F
04C22:  BNZ   4C36
04C24:  MOVF   x58,F
04C26:  BNZ   4C36
04C28:  MOVF   x1A,W
04C2A:  SUBWF  x57,W
04C2C:  BNC   4C7A
04C2E:  BNZ   4C36
04C30:  MOVF   x56,W
04C32:  SUBWF  x19,W
04C34:  BC    4C7A
....................    {                                         
....................       if (global_valve_position <= VLV_NOT_SPIN_LIMIT) 
04C36:  MOVLB  0
04C38:  MOVF   xBA,W
04C3A:  MOVLB  5
04C3C:  SUBWF  x11,W
04C3E:  BNC   4C56
04C40:  BNZ   4C4C
04C42:  MOVLB  0
04C44:  MOVF   xB9,W
04C46:  MOVLB  5
04C48:  SUBWF  x10,W
04C4A:  BNC   4C56
....................       { 
....................          return 0;                                
04C4C:  MOVLW  00
04C4E:  MOVWF  01
04C50:  MOVWF  02
04C52:  BRA    4CFA
....................       }                                       
04C54:  BRA    4C74
....................       else if(global_valve_position >= VLV_MAGNETIC_COUPLING_LIMIT) 
04C56:  MOVF   x16,W
04C58:  MOVLB  0
04C5A:  SUBWF  xBA,W
04C5C:  BNC   4C76
04C5E:  BNZ   4C6A
04C60:  MOVLB  5
04C62:  MOVF   x15,W
04C64:  MOVLB  0
04C66:  SUBWF  xB9,W
04C68:  BNC   4C76
....................       { 
....................          return 0-1; 
04C6A:  MOVLW  FF
04C6C:  MOVWF  01
04C6E:  MOVWF  02
04C70:  MOVLB  5
04C72:  BRA    4CFA
04C74:  MOVLB  0
....................       } 
....................    }                                   
04C76:  BRA    4CF2
04C78:  MOVLB  5
....................    // otherwise, calculate rpms as usual 
....................    else 
....................    {  
....................       disable_interrupts(INT_CCP5); 
04C7A:  BCF    F7A.2
....................       current_rpm32 = CCP_PER_RPM/(make32(0,0,make8(global_current_period,1), make8(global_current_period,0)));    
04C7C:  MOVFF  A1,556
04C80:  MOVFF  A0,557
04C84:  CLRF   x5B
04C86:  CLRF   x5A
04C88:  MOVFF  A1,559
04C8C:  MOVFF  A0,558
04C90:  BCF    FD8.1
04C92:  CLRF   19
04C94:  BTFSC  FF2.7
04C96:  BSF    19.7
04C98:  BCF    FF2.7
04C9A:  MOVLW  99
04C9C:  MOVWF  xA0
04C9E:  MOVWF  x9F
04CA0:  MOVWF  x9E
04CA2:  MOVLW  9A
04CA4:  MOVWF  x9D
04CA6:  MOVFF  55B,5A4
04CAA:  MOVFF  55A,5A3
04CAE:  MOVFF  A1,5A2
04CB2:  MOVFF  A0,5A1
04CB6:  MOVLB  0
04CB8:  CALL   2388
04CBC:  BTFSC  19.7
04CBE:  BSF    FF2.7
04CC0:  MOVFF  03,555
04CC4:  MOVFF  02,554
04CC8:  MOVFF  01,553
04CCC:  MOVFF  00,552
....................       enable_interrupts(INT_CCP5); 
04CD0:  BSF    F7A.2
....................       current_rpm16 = make16(make8(current_rpm32,3), make8(current_rpm32,2)); 
04CD2:  MOVFF  555,551
04CD6:  MOVFF  554,550
....................       if (bit_test(current_rpm32, 15)) 
04CDA:  MOVLB  5
04CDC:  BTFSS  x53.7
04CDE:  BRA    4CE6
....................       { 
....................          current_rpm16++; 
04CE0:  INCF   x50,F
04CE2:  BTFSC  FD8.2
04CE4:  INCF   x51,F
....................       } 
....................       return current_rpm16; 
04CE6:  MOVFF  550,01
04CEA:  MOVFF  551,02
04CEE:  BRA    4CFA
04CF0:  MOVLB  0
....................    } 
....................    return 0; 
04CF2:  MOVLW  00
04CF4:  MOVWF  01
04CF6:  MOVWF  02
04CF8:  MOVLB  5
04CFA:  MOVLB  0
04CFC:  GOTO   5110 (RETURN)
.................... } 
....................  
.................... int1  is_brake_duty_valid(uint16_t value) 
.................... // returns true if valid range for brake duty cycle 
.................... { 
....................    if (value > MAX_BRK) return FALSE; 
*
06C5E:  MOVLB  5
06C60:  MOVF   x51,W
06C62:  SUBLW  00
06C64:  BC    6C78
06C66:  XORLW  FF
06C68:  BNZ   6C70
06C6A:  MOVF   x50,W
06C6C:  SUBLW  90
06C6E:  BC    6C78
06C70:  MOVLW  00
06C72:  MOVWF  01
06C74:  BRA    6C7C
06C76:  BRA    6C7C
....................    else if ((value < NO_BRK) && (NO_BRK != 0)) return FALSE; 
....................    else return TRUE; 
06C78:  MOVLW  01
06C7A:  MOVWF  01
06C7C:  MOVLB  0
06C7E:  GOTO   750E (RETURN)
.................... } 
.................... int1  is_charge_duty_valid(uint16_t value) 
.................... // returns true if valid range for charge duty cycle 
.................... { 
....................    if (value > MAX_CHARGE) return FALSE; 
06C82:  MOVLB  5
06C84:  MOVF   x51,W
06C86:  SUBLW  00
06C88:  BC    6C9C
06C8A:  XORLW  FF
06C8C:  BNZ   6C94
06C8E:  MOVF   x50,W
06C90:  SUBLW  90
06C92:  BC    6C9C
06C94:  MOVLW  00
06C96:  MOVWF  01
06C98:  BRA    6CA0
06C9A:  BRA    6CA0
....................    else if ((value < NO_CHARGE) && (NO_CHARGE != 0)) return FALSE; 
....................    else return TRUE; 
06C9C:  MOVLW  01
06C9E:  MOVWF  01
06CA0:  MOVLB  0
06CA2:  GOTO   752C (RETURN)
.................... } 
.................... int1  is_mppc_valid(uint8_t value) 
.................... // returns true if valid range for mppc 
.................... { 
....................    if (value > MAX_MPPC) return FALSE; 
....................    else if ((value < NO_MPPC) && (NO_MPPC != 0)) return FALSE; 
06CA6:  MOVLB  5
06CA8:  MOVF   x4E,W
06CAA:  SUBLW  06
06CAC:  BNC   6CB6
06CAE:  MOVLW  00
06CB0:  MOVWF  01
06CB2:  BRA    6CBA
06CB4:  BRA    6CBA
....................    else return TRUE; 
06CB6:  MOVLW  01
06CB8:  MOVWF  01
06CBA:  MOVLB  0
06CBC:  GOTO   7546 (RETURN)
.................... } 
.................... int1  is_rpm_setting_valid(uint16_t value) 
.................... // returns true if valid range for rpm 
.................... { 
....................    if (value > MAX_RPM_SETTING) return FALSE; 
*
067DA:  MOVLB  5
067DC:  MOVF   x51,F
067DE:  BNZ   67E6
067E0:  MOVF   x50,W
067E2:  SUBLW  FA
067E4:  BC    67EE
067E6:  MOVLW  00
067E8:  MOVWF  01
067EA:  BRA    6804
067EC:  BRA    6804
....................    else if ((value < MIN_RPM_SETTING) && (MIN_RPM_SETTING != 0)) return FALSE; 
067EE:  MOVF   x51,F
067F0:  BNZ   6800
067F2:  MOVF   x50,W
067F4:  SUBLW  09
067F6:  BNC   6800
067F8:  MOVLW  00
067FA:  MOVWF  01
067FC:  BRA    6804
067FE:  BRA    6804
....................    else return TRUE; 
06800:  MOVLW  01
06802:  MOVWF  01
06804:  MOVLB  0
06806:  RETURN 0
.................... } 
.................... void  set_brake_duty(uint16_t value) 
.................... { 
....................    if (value == NO_BRK) 
*
05018:  MOVLB  5
0501A:  MOVF   x52,F
0501C:  BNZ   502A
0501E:  MOVF   x53,F
05020:  BNZ   502A
....................    { 
....................       setup_ccp1(CCP_OFF); 
05022:  MOVLW  F0
05024:  ANDWF  FBD,F
....................       output_high(BRK_CTRLn);    // no braking 
05026:  BSF    F8B.2
....................    } 
05028:  BRA    507A
....................    else if (value == MAX_BRK) 
0502A:  MOVF   x52,W
0502C:  SUBLW  90
0502E:  BNZ   503C
05030:  DECFSZ x53,W
05032:  BRA    503C
....................    { 
....................       setup_ccp1(CCP_OFF); 
05034:  MOVLW  F0
05036:  ANDWF  FBD,F
....................       output_low(BRK_CTRLn);     // maximum braking 
05038:  BCF    F8B.2
....................    } 
0503A:  BRA    507A
....................     
....................    else 
....................    {       
....................       setup_ccp1(CCP_USE_TIMER5_AND_TIMER6 | CCP_PWM_L_L | CCP_PULSE_STEERING_A); 
0503C:  BCF    F8B.2
0503E:  MOVLW  0F
05040:  MOVWF  FBD
05042:  CLRF   FB7
05044:  CLRF   FB6
05046:  MOVLW  01
05048:  MOVWF  FB9
0504A:  MOVLW  FC
0504C:  MOVLB  F
0504E:  ANDWF  x49,F
05050:  MOVLW  02
05052:  IORWF  x49,F
....................       // increase pwm duty1 for slower speed 
....................       CCP1CON |= (make8(value,0) & 0x03) << 4; 
05054:  MOVLB  5
05056:  MOVF   x52,W
05058:  ANDLW  03
0505A:  MOVWF  00
0505C:  SWAPF  00,F
0505E:  MOVLW  F0
05060:  ANDWF  00,F
05062:  MOVF   00,W
05064:  IORWF  FBD,F
....................       CCPR1L = make8((value>>2),0); 
05066:  RRCF   x53,W
05068:  MOVWF  x55
0506A:  RRCF   x52,W
0506C:  MOVWF  x54
0506E:  RRCF   x55,F
05070:  RRCF   x54,F
05072:  MOVLW  3F
05074:  ANDWF  x55,F
05076:  MOVFF  554,FBE
....................    } 
....................     
....................    global_brake_duty = value; 
0507A:  MOVFF  553,AB
0507E:  MOVFF  552,AA
05082:  MOVLB  0
05084:  RETURN 0
.................... } 
....................  
.................... void     set_charge_duty(uint16_t value) 
.................... { 
....................    if (value == NO_CHARGE) 
*
03C22:  MOVLB  5
03C24:  MOVF   x52,F
03C26:  BNZ   3C34
03C28:  MOVF   x53,F
03C2A:  BNZ   3C34
....................    { 
....................       setup_ccp2(CCP_OFF); 
03C2C:  MOVLW  F0
03C2E:  ANDWF  F66,F
....................       output_low(LTC3105_CTRL);     // lo for NO CHARGING 
03C30:  BCF    F8A.3
....................    } 
03C32:  BRA    3C84
....................    else if (value == MAX_CHARGE) 
03C34:  MOVF   x52,W
03C36:  SUBLW  90
03C38:  BNZ   3C46
03C3A:  DECFSZ x53,W
03C3C:  BRA    3C46
....................    { 
....................       setup_ccp2(CCP_OFF); 
03C3E:  MOVLW  F0
03C40:  ANDWF  F66,F
....................       output_high(LTC3105_CTRL);    // maximum charging aggressiveness 
03C42:  BSF    F8A.3
....................    } 
03C44:  BRA    3C84
....................     
....................    else 
....................    {    
....................       //setup_ccp2(CCP_USE_TIMER1_AND_TIMER2 | CCP_PWM_H_H | CCP_PULSE_STEERING_A); 
....................       setup_ccp2(CCP_USE_TIMER5_AND_TIMER6 | CCP_PWM_H_H | CCP_PULSE_STEERING_A); 
03C46:  BCF    F8A.3
03C48:  MOVLW  0C
03C4A:  MOVWF  F66
03C4C:  CLRF   F65
03C4E:  CLRF   F64
03C50:  MOVLW  01
03C52:  MOVWF  F63
03C54:  MOVLW  E7
03C56:  MOVLB  F
03C58:  ANDWF  x49,F
03C5A:  MOVLW  10
03C5C:  IORWF  x49,F
....................       // increase pwm duty2 for slower speed 
....................       CCP2CON |= (make8(value,0) & 0x03) << 4; 
03C5E:  MOVLB  5
03C60:  MOVF   x52,W
03C62:  ANDLW  03
03C64:  MOVWF  00
03C66:  SWAPF  00,F
03C68:  MOVLW  F0
03C6A:  ANDWF  00,F
03C6C:  MOVF   00,W
03C6E:  IORWF  F66,F
....................       CCPR2L = make8((value>>2),0); 
03C70:  RRCF   x53,W
03C72:  MOVWF  x55
03C74:  RRCF   x52,W
03C76:  MOVWF  x54
03C78:  RRCF   x55,F
03C7A:  RRCF   x54,F
03C7C:  MOVLW  3F
03C7E:  ANDWF  x55,F
03C80:  MOVFF  554,F67
....................    } 
....................    global_charge_duty = value; 
03C84:  MOVFF  553,AD
03C88:  MOVFF  552,AC
03C8C:  MOVLB  0
03C8E:  RETURN 0
.................... }                   
....................  
.................... void set_mppc(uint8_t value) 
.................... { 
....................    // for large scale PCBs 
....................     
....................    safeI2C_start(); 
*
03B96:  RCALL  3B44
....................  
....................    safei2c_write(0x58);   // address 
03B98:  MOVLW  58
03B9A:  MOVLB  5
03B9C:  MOVWF  x51
03B9E:  MOVLB  0
03BA0:  RCALL  3B82
....................    safei2c_write(0x00);   // Pot 0 command 
03BA2:  MOVLB  5
03BA4:  CLRF   x51
03BA6:  MOVLB  0
03BA8:  RCALL  3B82
....................    safei2c_write(value);  
03BAA:  MOVFF  550,551
03BAE:  RCALL  3B82
....................    safei2c_write(0x10);   // Pot 1 command 
03BB0:  MOVLW  10
03BB2:  MOVLB  5
03BB4:  MOVWF  x51
03BB6:  MOVLB  0
03BB8:  RCALL  3B82
....................    safei2c_write(value);  
03BBA:  MOVFF  550,551
03BBE:  RCALL  3B82
....................    safei2c_write(0x60);   // Pot 2 command 
03BC0:  MOVLW  60
03BC2:  MOVLB  5
03BC4:  MOVWF  x51
03BC6:  MOVLB  0
03BC8:  RCALL  3B82
....................    safei2c_write(value);  
03BCA:  MOVFF  550,551
03BCE:  RCALL  3B82
....................    safei2c_write(0x70);   // Pot 3 command 
03BD0:  MOVLW  70
03BD2:  MOVLB  5
03BD4:  MOVWF  x51
03BD6:  MOVLB  0
03BD8:  RCALL  3B82
....................    safei2c_write(value);     
03BDA:  MOVFF  550,551
03BDE:  RCALL  3B82
....................    i2c_stop(); 
03BE0:  BSF    FC5.2
03BE2:  BTFSC  FC5.2
03BE4:  BRA    3BE2
....................  
....................    // and connect all four pots 
....................    safeI2C_start(); 
03BE6:  RCALL  3B44
....................     
....................    safei2c_write(0x58);  
03BE8:  MOVLW  58
03BEA:  MOVLB  5
03BEC:  MOVWF  x51
03BEE:  MOVLB  0
03BF0:  RCALL  3B82
....................    safei2c_write(0x40);   // TCON0 
03BF2:  MOVLW  40
03BF4:  MOVLB  5
03BF6:  MOVWF  x51
03BF8:  MOVLB  0
03BFA:  RCALL  3B82
....................    safei2c_write(0xff);   // Connect 0 and 1 
03BFC:  MOVLB  5
03BFE:  SETF   x51
03C00:  MOVLB  0
03C02:  RCALL  3B82
....................    safei2c_write(0xa0);   // TCON1 
03C04:  MOVLW  A0
03C06:  MOVLB  5
03C08:  MOVWF  x51
03C0A:  MOVLB  0
03C0C:  RCALL  3B82
....................    safei2c_write(0xff);   // Connect 2 and 3 
03C0E:  MOVLB  5
03C10:  SETF   x51
03C12:  MOVLB  0
03C14:  RCALL  3B82
....................    i2c_stop(); 
03C16:  BSF    FC5.2
03C18:  BTFSC  FC5.2
03C1A:  BRA    3C18
....................     
....................    global_mppc_value = value; 
03C1C:  MOVFF  550,B2
03C20:  RETURN 0
.................... } 
....................  
.................... void  set_fixture_dac(uint16_t dac_value) 
.................... { 
....................    safeI2C_start(); 
*
03C90:  RCALL  3B44
....................  
.................... //   fl_FIXTURE = !i2c_write(0x40);   // (0x40) Write FIXTURE DAC address 
.................... //   if (!fl_FIXTURE); 
.................... //   { 
.................... //      i2c_stop(); 
.................... //      return; 
.................... //   } 
....................     
....................    safei2c_write(0x40); 
03C92:  MOVLW  40
03C94:  MOVLB  5
03C96:  MOVWF  x51
03C98:  MOVLB  0
03C9A:  RCALL  3B82
....................    safei2c_write(0x30); 
03C9C:  MOVLW  30
03C9E:  MOVLB  5
03CA0:  MOVWF  x51
03CA2:  MOVLB  0
03CA4:  RCALL  3B82
....................  
....................    dac_value <<= 4;        // shift 12 bit value so that MS bit is at bit15  
03CA6:  MOVLB  5
03CA8:  RLCF   x48,F
03CAA:  RLCF   x49,F
03CAC:  RLCF   x48,F
03CAE:  RLCF   x49,F
03CB0:  RLCF   x48,F
03CB2:  RLCF   x49,F
03CB4:  RLCF   x48,F
03CB6:  RLCF   x49,F
03CB8:  MOVLW  F0
03CBA:  ANDWF  x48,F
....................    safei2c_write (make8(dac_value,1));  
03CBC:  MOVFF  549,54A
03CC0:  MOVFF  549,551
03CC4:  MOVLB  0
03CC6:  RCALL  3B82
....................    safei2c_write (make8(dac_value,0)); 
03CC8:  MOVFF  548,54A
03CCC:  MOVFF  548,551
03CD0:  RCALL  3B82
....................    i2c_stop(); 
03CD2:  BSF    FC5.2
03CD4:  BTFSC  FC5.2
03CD6:  BRA    3CD4
....................     
....................    global_fixture_dac_value = dac_value; 
03CD8:  MOVFF  549,B7
03CDC:  MOVFF  548,B6
03CE0:  GOTO   3D3A (RETURN)
.................... } 
....................  
.................... void adjust_brake_for_rpm(uint16_t rpm_set_value) 
.................... { 
....................    if (calc_gen_rpm() < rpm_set_value) 
....................    { 
....................       if (global_brake_duty != NO_BRK) 
....................       { 
....................          global_brake_duty--; 
....................       } 
....................       set_brake_duty(global_brake_duty); 
....................    } 
....................    else if (calc_gen_rpm() > rpm_set_value) 
....................    { 
....................       if (global_brake_duty != MAX_BRK) 
....................       { 
....................          global_brake_duty++; 
....................       } 
....................       set_brake_duty(global_brake_duty); 
....................    } 
.................... } 
....................  
.................... void adjust_brake_for_vgen(uint16_t vgen_set_value) 
.................... { 
....................    if (get_vgen(0) < vgen_set_value) 
....................    { 
....................       if (global_brake_duty != NO_BRK) 
....................       { 
....................          global_brake_duty--; 
....................       } 
....................       set_brake_duty(global_brake_duty); 
....................    } 
....................    else if (get_vgen(0) > vgen_set_value) 
....................    { 
....................       if (global_brake_duty != MAX_BRK) 
....................       { 
....................          global_brake_duty++; 
....................       } 
....................       set_brake_duty(global_brake_duty); 
....................    } 
.................... } 
....................  
....................     
.................... void adjust_fixture_for_rpm(uint16_t fixture_set_value) 
.................... { 
....................    if (calc_gen_rpm() < fixture_set_value) 
....................    { 
....................       if (global_fixture_dac_value != NO_FIXTURE) 
....................       { 
....................          global_fixture_dac_value--; 
....................       } 
....................       set_fixture_dac(global_fixture_dac_value); 
....................    } 
....................    else if (calc_gen_rpm() > fixture_set_value) 
....................    { 
....................       if (global_fixture_dac_value != MAX_FIXTURE) 
....................       { 
....................          global_fixture_dac_value++; 
....................       } 
....................       set_fixture_dac(global_fixture_dac_value); 
....................    } 
.................... }       
....................        
.................... void adjust_mppc(void) 
.................... { 
....................    static uint16_t last_vbatt_measurement = 0; 
....................    static uint16_t current_vbatt_measurement = 0; 
....................    static uint8_t last_mppc_value = 0; 
....................    static uint8_t last_last_mppc_value = 0; 
....................     
....................    // if the battery is full, exit 
....................     
....................     current_vbatt_measurement = get_vbatt(0); 
*
0941E:  MOVLB  5
09420:  CLRF   x53
09422:  MOVLB  0
09424:  CALL   3F5E
09428:  MOVFF  02,534
0942C:  MOVFF  01,533
....................      
....................    // first time to initalize values 
....................    if ((last_vbatt_measurement == 0) || (last_mppc_value == 0)) 
09430:  MOVLB  5
09432:  MOVF   x31,F
09434:  BNZ   943A
09436:  MOVF   x32,F
09438:  BZ    943E
0943A:  MOVF   x35,F
0943C:  BNZ   944A
....................    { 
....................       last_vbatt_measurement = current_vbatt_measurement; 
0943E:  MOVFF  534,532
09442:  MOVFF  533,531
....................       last_mppc_value = global_mppc_value; 
09446:  MOVFF  B2,535
....................    } 
....................    last_last_mppc_value = last_mppc_value; 
0944A:  MOVFF  535,536
....................    last_mppc_value = global_mppc_value; 
0944E:  MOVFF  B2,535
....................        
....................    if (last_vbatt_measurement < current_vbatt_measurement) 
09452:  MOVF   x32,W
09454:  SUBWF  x34,W
09456:  BNC   94A6
09458:  BNZ   9460
0945A:  MOVF   x33,W
0945C:  SUBWF  x31,W
0945E:  BC    94A6
....................    { 
....................       if (last_last_mppc_value < global_mppc_value) 
09460:  MOVLB  0
09462:  MOVF   xB2,W
09464:  MOVLB  5
09466:  SUBWF  x36,W
09468:  BC    947A
....................       { 
....................          if (global_mppc_value != MAX_MPPC) global_mppc_value+=5; 
0946A:  MOVLB  0
0946C:  INCFSZ xB2,W
0946E:  BRA    9472
09470:  BRA    9476
09472:  MOVLW  05
09474:  ADDWF  xB2,F
....................       } 
09476:  BRA    94A2
09478:  MOVLB  5
....................       else if (last_last_mppc_value > global_mppc_value) 
0947A:  MOVF   x36,W
0947C:  MOVLB  0
0947E:  SUBWF  xB2,W
09480:  BC    948E
....................       { 
....................          if (global_mppc_value != NO_MPPC) global_mppc_value-=5; 
09482:  MOVF   xB2,W
09484:  SUBLW  07
09486:  BZ    948C
09488:  MOVLW  05
0948A:  SUBWF  xB2,F
....................       } 
0948C:  BRA    94A2
....................       else 
....................       { 
....................          if (global_mppc_value == NO_MPPC) global_mppc_value++; 
0948E:  MOVF   xB2,W
09490:  SUBLW  07
09492:  BNZ   9498
09494:  INCF   xB2,F
09496:  BRA    94A2
....................          else if (global_mppc_value == MAX_MPPC) global_mppc_value--; 
09498:  INCFSZ xB2,W
0949A:  BRA    94A0
0949C:  DECF   xB2,F
0949E:  BRA    94A2
....................          else global_mppc_value++; 
094A0:  INCF   xB2,F
....................       } 
....................    } 
094A2:  BRA    94E4
094A4:  MOVLB  5
....................    else 
....................    { 
....................       if (last_last_mppc_value > global_mppc_value) 
094A6:  MOVF   x36,W
094A8:  MOVLB  0
094AA:  SUBWF  xB2,W
094AC:  BC    94B8
....................       { 
....................          if (global_mppc_value != MAX_MPPC) global_mppc_value++; 
094AE:  INCFSZ xB2,W
094B0:  BRA    94B4
094B2:  BRA    94B6
094B4:  INCF   xB2,F
....................       } 
094B6:  BRA    94E4
....................       else if (last_last_mppc_value < global_mppc_value) 
094B8:  MOVF   xB2,W
094BA:  MOVLB  5
094BC:  SUBWF  x36,W
094BE:  BC    94CE
....................       { 
....................          if (global_mppc_value != NO_MPPC) global_mppc_value--; 
094C0:  MOVLB  0
094C2:  MOVF   xB2,W
094C4:  SUBLW  07
094C6:  BZ    94CA
094C8:  DECF   xB2,F
....................       } 
094CA:  BRA    94E4
094CC:  MOVLB  5
....................       else 
....................       { 
....................          if (global_mppc_value == NO_MPPC) global_mppc_value++; 
094CE:  MOVLB  0
094D0:  MOVF   xB2,W
094D2:  SUBLW  07
094D4:  BNZ   94DA
094D6:  INCF   xB2,F
094D8:  BRA    94E4
....................          else if (global_mppc_value == MAX_MPPC) global_mppc_value--; 
094DA:  INCFSZ xB2,W
094DC:  BRA    94E2
094DE:  DECF   xB2,F
094E0:  BRA    94E4
....................          else global_mppc_value++; 
094E2:  INCF   xB2,F
....................       } 
....................    } 
....................     
....................    last_vbatt_measurement = current_vbatt_measurement; 
094E4:  MOVFF  534,532
094E8:  MOVFF  533,531
....................    set_mppc(global_mppc_value); 
094EC:  MOVFF  B2,550
094F0:  CALL   3B96
....................    return; 
094F4:  GOTO   A492 (RETURN)
.................... } 
....................  
.................... uint8_t calc_mppc_by_vgen(void) 
.................... { 
....................    int16_t mppc; 
....................    mppc = (((get_vgen(0) - 100) * 20)/100); 
*
04B5E:  MOVLB  5
04B60:  CLRF   x53
04B62:  MOVLB  0
04B64:  CALL   3FB8
04B68:  MOVFF  02,553
04B6C:  MOVFF  01,552
04B70:  MOVLW  64
04B72:  MOVLB  5
04B74:  SUBWF  x52,F
04B76:  MOVLW  00
04B78:  SUBWFB x53,F
04B7A:  MOVFF  553,568
04B7E:  MOVFF  552,567
04B82:  CLRF   x6A
04B84:  MOVLW  14
04B86:  MOVWF  x69
04B88:  MOVLB  0
04B8A:  RCALL  4B3C
04B8C:  MOVFF  02,553
04B90:  MOVFF  01,552
04B94:  MOVFF  02,572
04B98:  MOVFF  01,571
04B9C:  MOVLB  5
04B9E:  CLRF   x74
04BA0:  MOVLW  64
04BA2:  MOVWF  x73
04BA4:  MOVLB  0
04BA6:  CALL   402E
04BAA:  MOVFF  02,551
04BAE:  MOVLB  5
04BB0:  MOVFF  01,550
....................    if (mppc < NO_MPPC) 
04BB4:  BTFSC  x51.7
04BB6:  BRA    4BC2
04BB8:  MOVF   x51,F
04BBA:  BNZ   4BCA
04BBC:  MOVF   x50,W
04BBE:  SUBLW  06
04BC0:  BNC   4BCA
....................    { 
....................       mppc = NO_MPPC; 
04BC2:  CLRF   x51
04BC4:  MOVLW  07
04BC6:  MOVWF  x50
....................    } 
04BC8:  BRA    4BD8
....................    else if (mppc > MAX_MPPC) 
04BCA:  BTFSC  x51.7
04BCC:  BRA    4BD8
04BCE:  MOVF   x51,W
04BD0:  SUBLW  00
04BD2:  BC    4BD8
....................    { 
....................       mppc = MAX_MPPC; 
04BD4:  CLRF   x51
04BD6:  SETF   x50
....................    } 
....................    return mppc; 
04BD8:  MOVFF  550,01
04BDC:  MOVLB  0
04BDE:  GOTO   50F0 (RETURN)
.................... } 
....................  
.................... void update_control_loop(void) 
.................... { 
.................... // Moves the brake duty and charge duty closer to their respective set points 
.................... // How quickly they move towards their set points depends on how far away they 
.................... //    are from the set points. 
....................  
....................    uint16_t rpm_difference, brake_duty_difference, charge_duty_difference; 
....................    uint8_t  duty_change, brake_duty_change, charge_duty_change; 
....................    static uint8_t  control_loop_cycles_to_next_update = 1; 
....................     
....................    /* 
....................    // if the sprinkler has no current commands, exit the control loop                   
....................    if (global_control_loop_mechanism == NO_SPRINKLER_CONTROL)  
....................    { 
....................       return; 
....................    } 
....................    */ 
....................     
....................    // set mppc to dynamic if in any other mode except test mode no rpm (with mppc hard set) 
....................    if (global_control_loop_mechanism != NO_RPM_CONTROL) 
*
050E8:  MOVF   xB8,W
050EA:  SUBLW  05
050EC:  BZ    50F4
....................    { 
....................       global_mppc_set_value = calc_mppc_by_vgen(); 
050EE:  BRA    4B5E
050F0:  MOVFF  01,B3
....................    } 
....................    // set the mppc value              
....................    set_mppc(global_mppc_set_value);   
050F4:  MOVFF  B3,550
050F8:  CALL   3B96
....................     
....................    // if it hasn't been enough cycles to update the control loop, exit 
....................    if (--control_loop_cycles_to_next_update > 0) 
050FC:  MOVLB  5
050FE:  DECF   x37,F
05100:  BZ    5108
....................    { 
....................       return; 
05102:  GOTO   5958
....................    } 
05106:  BRA    510C
....................    // otherwise, set it to the default of 1 
....................    else  
....................    { 
....................       control_loop_cycles_to_next_update = 1; 
05108:  MOVLW  01
0510A:  MOVWF  x37
....................    } 
....................     
....................    // grab the current rpm 
....................    global_current_rpm = calc_gen_rpm(); 
0510C:  MOVLB  0
0510E:  BRA    4BE2
05110:  MOVFF  02,A3
05114:  MOVFF  01,A2
....................     
....................    // decide which regime we are in 
....................    switch (global_control_loop_mechanism) 
05118:  MOVF   xB8,W
0511A:  ADDLW  F6
0511C:  BTFSC  FD8.0
0511E:  GOTO   5956
05122:  ADDLW  0A
05124:  GOTO   595E
....................    { 
....................    // regular brake + charge rpm control 
....................    case BRAKE_AND_CHARGE: 
....................       // calculate the difference in rpm from set point 
....................       rpm_difference = abs((int16_t)global_current_rpm - (int16_t)global_rpm_set_value); 
05128:  MOVF   xA4,W
0512A:  SUBWF  xA2,W
0512C:  MOVLB  5
0512E:  MOVWF  x50
05130:  MOVLB  0
05132:  MOVF   xA5,W
05134:  SUBWFB xA3,W
05136:  MOVLB  5
05138:  MOVWF  x51
0513A:  MOVWF  03
0513C:  MOVF   x50,W
0513E:  BTFSS  x51.7
05140:  BRA    5152
05142:  MOVLW  00
05144:  BSF    FD8.0
05146:  SUBFWB x50,W
05148:  MOVWF  00
0514A:  MOVLW  00
0514C:  SUBFWB x51,W
0514E:  MOVWF  03
05150:  MOVF   00,W
05152:  MOVWF  x47
05154:  MOVFF  03,548
....................        
....................       // calulate how much to change the parameter (either brake or charge, just 
....................       //    reusing brake duty cycle for both) and how often to update based on  
....................       //    rpm difference from setpoint 
....................       if (rpm_difference >= 50)  
05158:  MOVF   x48,F
0515A:  BNZ   5162
0515C:  MOVF   x47,W
0515E:  SUBLW  31
05160:  BC    516C
....................       { 
....................          duty_change = 10; 
05162:  MOVLW  0A
05164:  MOVWF  x4D
....................          control_loop_cycles_to_next_update = 5;               
05166:  MOVLW  05
05168:  MOVWF  x37
....................       } 
0516A:  BRA    51B0
....................       else if (rpm_difference >= 25)  
0516C:  MOVF   x48,F
0516E:  BNZ   5176
05170:  MOVF   x47,W
05172:  SUBLW  18
05174:  BC    5180
....................       { 
....................          duty_change = 5; 
05176:  MOVLW  05
05178:  MOVWF  x4D
....................          control_loop_cycles_to_next_update = 6; 
0517A:  MOVLW  06
0517C:  MOVWF  x37
....................       } 
0517E:  BRA    51B0
....................       else if (rpm_difference >= 10) 
05180:  MOVF   x48,F
05182:  BNZ   518A
05184:  MOVF   x47,W
05186:  SUBLW  09
05188:  BC    5194
....................       { 
....................          duty_change = 4; 
0518A:  MOVLW  04
0518C:  MOVWF  x4D
....................          control_loop_cycles_to_next_update = 7; 
0518E:  MOVLW  07
05190:  MOVWF  x37
....................       } 
05192:  BRA    51B0
....................       else if (rpm_difference >= 5)  
05194:  MOVF   x48,F
05196:  BNZ   519E
05198:  MOVF   x47,W
0519A:  SUBLW  04
0519C:  BC    51A8
....................       { 
....................          duty_change = 2; 
0519E:  MOVLW  02
051A0:  MOVWF  x4D
....................          control_loop_cycles_to_next_update = 8; 
051A2:  MOVLW  08
051A4:  MOVWF  x37
....................       } 
051A6:  BRA    51B0
.................... //      else if (rpm_difference >= 0)  
....................       else 
....................       {   
....................          duty_change = 1; 
051A8:  MOVLW  01
051AA:  MOVWF  x4D
....................          control_loop_cycles_to_next_update = 10; 
051AC:  MOVLW  0A
051AE:  MOVWF  x37
....................       } 
....................        
....................       // Set point is lower than current value (increase braking force) 
....................       if (global_current_rpm > global_rpm_set_value)  
051B0:  MOVLB  0
051B2:  MOVF   xA5,W
051B4:  SUBWF  xA3,W
051B6:  BTFSS  FD8.0
051B8:  BRA    52CE
051BA:  BNZ   51C4
051BC:  MOVF   xA2,W
051BE:  SUBWF  xA4,W
051C0:  BTFSC  FD8.0
051C2:  BRA    52CE
....................       { 
....................          // if we are at max charge already, move to the braking 
....................          if (global_charge_duty == MAX_CHARGE) 
051C4:  MOVF   xAC,W
051C6:  SUBLW  90
051C8:  BNZ   5276
051CA:  DECFSZ xAD,W
051CC:  BRA    5276
....................          { 
....................             // if we are at max brake (and charge) and detecting a magnetic decoupling condition 
....................             if ((global_brake_duty == MAX_BRK) && (global_current_rpm == 0-1)) 
051CE:  MOVF   xAA,W
051D0:  SUBLW  90
051D2:  BNZ   5204
051D4:  DECFSZ xAB,W
051D6:  BRA    5204
051D8:  INCFSZ xA2,W
051DA:  BRA    5204
051DC:  INCFSZ xA3,W
051DE:  BRA    5204
....................             { 
....................                // start magnetic de-coupling fix 
....................                // set an error bit saying magnetic decoupling is detected 
....................                global_error_message_bitfield |= ERR_MSG_MAG_DECOUPLING; 
051E0:  MOVLB  4
051E2:  BSF    xF1.4
....................                // send error message 
....................                PUSH_MESSAGE_QUEUE_MACRO(MSG_MOTE_ERROR_MSG); 
051E4:  BCF    F7A.1
051E6:  MOVLW  A0
051E8:  MOVLB  5
051EA:  MOVWF  x50
051EC:  MOVLB  0
051EE:  RCALL  4D00
051F0:  BSF    F7A.1
....................                // push a MOVE_VALVE_MAG_DECOUPLING_RECOVERY event 
....................                PUSH_PRIORITY_QUEUE_MACRO(MOVE_VALVE_MAG_DECOUPLING_RECOVERY); 
051F2:  BCF    F7A.1
051F4:  MOVLW  3C
051F6:  MOVLB  5
051F8:  MOVWF  x50
051FA:  MOVLB  0
051FC:  CALL   43F2
05200:  BSF    F7A.1
....................             } 
05202:  BRA    5274
....................             // if we are at max brake (and charge) (no decoupling) send an error message 
....................             else if (global_brake_duty == MAX_BRK) 
05204:  MOVF   xAA,W
05206:  SUBLW  90
05208:  BNZ   5222
0520A:  DECFSZ xAB,W
0520C:  BRA    5222
....................             { 
....................                // set an error bit saying rpm was too low to reach 
....................                global_error_message_bitfield |= ERR_MSG_RPM_TOO_LOW_TO_REACH; 
0520E:  MOVLB  4
05210:  BSF    xF0.5
....................                // send error message 
....................                PUSH_MESSAGE_QUEUE_MACRO(MSG_MOTE_ERROR_MSG); 
05212:  BCF    F7A.1
05214:  MOVLW  A0
05216:  MOVLB  5
05218:  MOVWF  x50
0521A:  MOVLB  0
0521C:  RCALL  4D00
0521E:  BSF    F7A.1
....................             } 
05220:  BRA    5274
....................             // if we can't increase charge anymore, set it to max 
....................             else if ((global_brake_duty + duty_change) > MAX_CHARGE) 
05222:  MOVLB  5
05224:  MOVF   x4D,W
05226:  MOVLB  0
05228:  ADDWF  xAA,W
0522A:  MOVLB  5
0522C:  MOVWF  x50
0522E:  MOVLW  00
05230:  MOVLB  0
05232:  ADDWFC xAB,W
05234:  MOVLB  5
05236:  MOVWF  x51
05238:  SUBLW  00
0523A:  BC    5256
0523C:  XORLW  FF
0523E:  BNZ   5246
05240:  MOVF   x50,W
05242:  SUBLW  90
05244:  BC    5256
....................             { 
....................                set_brake_duty(MAX_BRK); 
05246:  MOVLW  01
05248:  MOVWF  x53
0524A:  MOVLW  90
0524C:  MOVWF  x52
0524E:  MOVLB  0
05250:  RCALL  5018
....................             } 
05252:  BRA    5274
05254:  MOVLB  5
....................             // increase braking as per normal 
....................             else 
....................             { 
....................                set_brake_duty(global_brake_duty + duty_change); 
05256:  MOVF   x4D,W
05258:  MOVLB  0
0525A:  ADDWF  xAA,W
0525C:  MOVLB  5
0525E:  MOVWF  x50
05260:  MOVLW  00
05262:  MOVLB  0
05264:  ADDWFC xAB,W
05266:  MOVLB  5
05268:  MOVWF  x51
0526A:  MOVWF  x53
0526C:  MOVFF  550,552
05270:  MOVLB  0
05272:  RCALL  5018
....................             } 
....................          }   
05274:  BRA    52CC
....................          // if we can't increase charge anymore, set it to max 
....................          else if ((global_charge_duty + duty_change) > MAX_CHARGE) 
05276:  MOVLB  5
05278:  MOVF   x4D,W
0527A:  MOVLB  0
0527C:  ADDWF  xAC,W
0527E:  MOVLB  5
05280:  MOVWF  x50
05282:  MOVLW  00
05284:  MOVLB  0
05286:  ADDWFC xAD,W
05288:  MOVLB  5
0528A:  MOVWF  x51
0528C:  SUBLW  00
0528E:  BC    52AC
05290:  XORLW  FF
05292:  BNZ   529A
05294:  MOVF   x50,W
05296:  SUBLW  90
05298:  BC    52AC
....................          { 
....................             set_charge_duty(MAX_CHARGE); 
0529A:  MOVLW  01
0529C:  MOVWF  x53
0529E:  MOVLW  90
052A0:  MOVWF  x52
052A2:  MOVLB  0
052A4:  CALL   3C22
....................          } 
052A8:  BRA    52CC
052AA:  MOVLB  5
....................         // increase charging as per normal 
....................         else 
....................         { 
....................             set_charge_duty(global_charge_duty + duty_change); 
052AC:  MOVF   x4D,W
052AE:  MOVLB  0
052B0:  ADDWF  xAC,W
052B2:  MOVLB  5
052B4:  MOVWF  x50
052B6:  MOVLW  00
052B8:  MOVLB  0
052BA:  ADDWFC xAD,W
052BC:  MOVLB  5
052BE:  MOVWF  x51
052C0:  MOVWF  x53
052C2:  MOVFF  550,552
052C6:  MOVLB  0
052C8:  CALL   3C22
....................         } 
....................       } 
052CC:  BRA    53DA
....................       // Set point is higher than current value (increase braking force) 
....................       else if (global_current_rpm < global_rpm_set_value)  
052CE:  MOVF   xA3,W
052D0:  SUBWF  xA5,W
052D2:  BTFSS  FD8.0
052D4:  BRA    53DA
052D6:  BNZ   52E0
052D8:  MOVF   xA4,W
052DA:  SUBWF  xA2,W
052DC:  BTFSC  FD8.0
052DE:  BRA    53DA
....................       { 
....................          // if we are at min braking already, move to the charging 
....................          if (global_brake_duty == NO_BRK) 
052E0:  MOVF   xAA,F
052E2:  BNZ   538C
052E4:  MOVF   xAB,F
052E6:  BNZ   538C
....................          { 
....................             // if we are at min charge (and brake) and the rpms are 0  
....................             // (a not spinning condition) 
....................             if ((global_charge_duty == NO_CHARGE) && (global_current_rpm == 0)) 
052E8:  MOVF   xAC,F
052EA:  BNZ   531C
052EC:  MOVF   xAD,F
052EE:  BNZ   531C
052F0:  MOVF   xA2,F
052F2:  BNZ   531C
052F4:  MOVF   xA3,F
052F6:  BNZ   531C
....................             { 
....................                // start not spinning recovery 
....................                // set an error bit saying there isn't any spinning 
....................                global_error_message_bitfield |= ERR_MSG_NOT_SPINNING; 
052F8:  MOVLB  4
052FA:  BSF    xF1.3
....................                // send error message to manager 
....................                PUSH_MESSAGE_QUEUE_MACRO(MSG_MOTE_ERROR_MSG); 
052FC:  BCF    F7A.1
052FE:  MOVLW  A0
05300:  MOVLB  5
05302:  MOVWF  x50
05304:  MOVLB  0
05306:  RCALL  4D00
05308:  BSF    F7A.1
....................                // push a MOVE_VALVE_NO_SPIN_RECOVERY event 
....................                PUSH_PRIORITY_QUEUE_MACRO(MOVE_VALVE_NO_SPIN_RECOVERY); 
0530A:  BCF    F7A.1
0530C:  MOVLW  3D
0530E:  MOVLB  5
05310:  MOVWF  x50
05312:  MOVLB  0
05314:  CALL   43F2
05318:  BSF    F7A.1
....................             } 
0531A:  BRA    538A
....................             // if we are at min charge (and brake) send an error message if 
....................             //    the bitfield bit isn't already sent (to avoid sending messages 
....................             //    all the time 
....................             else if (global_charge_duty == NO_CHARGE)  
0531C:  MOVF   xAC,F
0531E:  BNZ   5338
05320:  MOVF   xAD,F
05322:  BNZ   5338
....................             { 
....................                // set an error bit saying rpm was too high to reach 
....................                global_error_message_bitfield |= ERR_MSG_RPM_TOO_HIGH_TO_REACH; 
05324:  MOVLB  4
05326:  BSF    xF0.4
....................                // send error message to manager 
....................                PUSH_MESSAGE_QUEUE_MACRO(MSG_MOTE_ERROR_MSG); 
05328:  BCF    F7A.1
0532A:  MOVLW  A0
0532C:  MOVLB  5
0532E:  MOVWF  x50
05330:  MOVLB  0
05332:  RCALL  4D00
05334:  BSF    F7A.1
....................             } 
05336:  BRA    538A
....................             // if we can't decrease charge anymore, set it to min 
....................             // notice use of unsigned math here  
....................             else if ((global_charge_duty - duty_change) > MAX_CHARGE) 
05338:  MOVLB  5
0533A:  MOVF   x4D,W
0533C:  MOVLB  0
0533E:  SUBWF  xAC,W
05340:  MOVLB  5
05342:  MOVWF  x50
05344:  MOVLW  00
05346:  MOVLB  0
05348:  SUBWFB xAD,W
0534A:  MOVLB  5
0534C:  MOVWF  x51
0534E:  SUBLW  00
05350:  BC    536A
05352:  XORLW  FF
05354:  BNZ   535C
05356:  MOVF   x50,W
05358:  SUBLW  90
0535A:  BC    536A
....................             { 
....................                set_charge_duty(NO_CHARGE); 
0535C:  CLRF   x53
0535E:  CLRF   x52
05360:  MOVLB  0
05362:  CALL   3C22
....................             } 
05366:  BRA    538A
05368:  MOVLB  5
....................             // decrease charging as per normal 
....................             else 
....................             { 
....................                set_charge_duty(global_charge_duty - duty_change); 
0536A:  MOVF   x4D,W
0536C:  MOVLB  0
0536E:  SUBWF  xAC,W
05370:  MOVLB  5
05372:  MOVWF  x50
05374:  MOVLW  00
05376:  MOVLB  0
05378:  SUBWFB xAD,W
0537A:  MOVLB  5
0537C:  MOVWF  x51
0537E:  MOVWF  x53
05380:  MOVFF  550,552
05384:  MOVLB  0
05386:  CALL   3C22
....................             } 
....................          }   
0538A:  BRA    53DA
....................          // if we can't decrease brake anymore, set it to min 
....................          // notice use of unsigned math here  
....................          else if ((global_brake_duty - duty_change) > MAX_BRK) 
0538C:  MOVLB  5
0538E:  MOVF   x4D,W
05390:  MOVLB  0
05392:  SUBWF  xAA,W
05394:  MOVLB  5
05396:  MOVWF  x50
05398:  MOVLW  00
0539A:  MOVLB  0
0539C:  SUBWFB xAB,W
0539E:  MOVLB  5
053A0:  MOVWF  x51
053A2:  SUBLW  00
053A4:  BC    53BC
053A6:  XORLW  FF
053A8:  BNZ   53B0
053AA:  MOVF   x50,W
053AC:  SUBLW  90
053AE:  BC    53BC
....................          { 
....................             set_brake_duty(NO_BRK); 
053B0:  CLRF   x53
053B2:  CLRF   x52
053B4:  MOVLB  0
053B6:  RCALL  5018
....................          } 
053B8:  BRA    53DA
053BA:  MOVLB  5
....................         // decrease braking as per normal 
....................         else 
....................         { 
....................             set_brake_duty(global_brake_duty - duty_change); 
053BC:  MOVF   x4D,W
053BE:  MOVLB  0
053C0:  SUBWF  xAA,W
053C2:  MOVLB  5
053C4:  MOVWF  x50
053C6:  MOVLW  00
053C8:  MOVLB  0
053CA:  SUBWFB xAB,W
053CC:  MOVLB  5
053CE:  MOVWF  x51
053D0:  MOVWF  x53
053D2:  MOVFF  550,552
053D6:  MOVLB  0
053D8:  RCALL  5018
....................         } 
....................       } 
....................       break; 
053DA:  BRA    5956
....................        
....................    // RPM is only controlled by brake (when charger is turned off 
....................    case BRAKE_ONLY: 
....................    case BRAKE_AND_CHARGE_START: 
....................       // calculate the difference in rpm from set point 
....................       rpm_difference = abs((int16_t)global_current_rpm - (int16_t)global_rpm_set_value); 
053DC:  MOVF   xA4,W
053DE:  SUBWF  xA2,W
053E0:  MOVLB  5
053E2:  MOVWF  x50
053E4:  MOVLB  0
053E6:  MOVF   xA5,W
053E8:  SUBWFB xA3,W
053EA:  MOVLB  5
053EC:  MOVWF  x51
053EE:  MOVWF  03
053F0:  MOVF   x50,W
053F2:  BTFSS  x51.7
053F4:  BRA    5406
053F6:  MOVLW  00
053F8:  BSF    FD8.0
053FA:  SUBFWB x50,W
053FC:  MOVWF  00
053FE:  MOVLW  00
05400:  SUBFWB x51,W
05402:  MOVWF  03
05404:  MOVF   00,W
05406:  MOVWF  x47
05408:  MOVFF  03,548
....................        
....................       // calulate how much to change the parameter (either brake or charge, just 
....................       //    reusing brake duty cycle for both) and how often to update based on  
....................       //    rpm difference from setpoint 
....................       if (rpm_difference >= 50)  
0540C:  MOVF   x48,F
0540E:  BNZ   5416
05410:  MOVF   x47,W
05412:  SUBLW  31
05414:  BC    5420
....................       { 
....................          duty_change = 15; 
05416:  MOVLW  0F
05418:  MOVWF  x4D
....................          control_loop_cycles_to_next_update = 5; 
0541A:  MOVLW  05
0541C:  MOVWF  x37
....................       } 
0541E:  BRA    5464
....................       else if (rpm_difference >= 25)  
05420:  MOVF   x48,F
05422:  BNZ   542A
05424:  MOVF   x47,W
05426:  SUBLW  18
05428:  BC    5434
....................       { 
....................          duty_change = 10; 
0542A:  MOVLW  0A
0542C:  MOVWF  x4D
....................          control_loop_cycles_to_next_update = 5; 
0542E:  MOVLW  05
05430:  MOVWF  x37
....................       } 
05432:  BRA    5464
....................       else if (rpm_difference >= 10) 
05434:  MOVF   x48,F
05436:  BNZ   543E
05438:  MOVF   x47,W
0543A:  SUBLW  09
0543C:  BC    5448
....................       { 
....................          duty_change = 5; 
0543E:  MOVLW  05
05440:  MOVWF  x4D
....................          control_loop_cycles_to_next_update = 7; 
05442:  MOVLW  07
05444:  MOVWF  x37
....................       } 
05446:  BRA    5464
....................       else if (rpm_difference >= 5)  
05448:  MOVF   x48,F
0544A:  BNZ   5452
0544C:  MOVF   x47,W
0544E:  SUBLW  04
05450:  BC    545C
....................       { 
....................          duty_change = 2; 
05452:  MOVLW  02
05454:  MOVWF  x4D
....................          control_loop_cycles_to_next_update = 8; 
05456:  MOVLW  08
05458:  MOVWF  x37
....................       } 
0545A:  BRA    5464
.................... //      else if (rpm_difference >= 0)  
....................       else 
....................       {   
....................          duty_change = 1; 
0545C:  MOVLW  01
0545E:  MOVWF  x4D
....................          control_loop_cycles_to_next_update = 8; 
05460:  MOVLW  08
05462:  MOVWF  x37
....................       } 
....................        
....................       // Set point is lower than current value (increase braking force) 
....................       if (global_current_rpm > global_rpm_set_value)  
05464:  MOVLB  0
05466:  MOVF   xA5,W
05468:  SUBWF  xA3,W
0546A:  BNC   551C
0546C:  BNZ   5474
0546E:  MOVF   xA2,W
05470:  SUBWF  xA4,W
05472:  BC    551C
....................       { 
....................       // if we are at max brake (and charge) and detecting a magnetic decoupling condition 
....................          if ((global_brake_duty == MAX_BRK) && (global_current_rpm == 0-1)) 
05474:  MOVF   xAA,W
05476:  SUBLW  90
05478:  BNZ   54AA
0547A:  DECFSZ xAB,W
0547C:  BRA    54AA
0547E:  INCFSZ xA2,W
05480:  BRA    54AA
05482:  INCFSZ xA3,W
05484:  BRA    54AA
....................          { 
....................             // start magnetic de-coupling fix 
....................             // set an error bit saying magnetic decoupling is detected 
....................             global_error_message_bitfield |= ERR_MSG_MAG_DECOUPLING; 
05486:  MOVLB  4
05488:  BSF    xF1.4
....................             // send error message 
....................             PUSH_MESSAGE_QUEUE_MACRO(MSG_MOTE_ERROR_MSG); 
0548A:  BCF    F7A.1
0548C:  MOVLW  A0
0548E:  MOVLB  5
05490:  MOVWF  x50
05492:  MOVLB  0
05494:  RCALL  4D00
05496:  BSF    F7A.1
....................             // push a MOVE_VALVE_MAG_DECOUPLING_RECOVERY event 
....................             PUSH_PRIORITY_QUEUE_MACRO(MOVE_VALVE_MAG_DECOUPLING_RECOVERY); 
05498:  BCF    F7A.1
0549A:  MOVLW  3C
0549C:  MOVLB  5
0549E:  MOVWF  x50
054A0:  MOVLB  0
054A2:  CALL   43F2
054A6:  BSF    F7A.1
....................          } 
054A8:  BRA    551A
....................          // if we are at max brake (and charge) send an error message 
....................          else if (global_brake_duty == MAX_BRK) 
054AA:  MOVF   xAA,W
054AC:  SUBLW  90
054AE:  BNZ   54C8
054B0:  DECFSZ xAB,W
054B2:  BRA    54C8
....................          { 
....................             // set an error bit saying rpm was too low to reach 
....................             global_error_message_bitfield |= ERR_MSG_MAG_DECOUPLING; 
054B4:  MOVLB  4
054B6:  BSF    xF1.4
....................             // send error message 
....................             PUSH_MESSAGE_QUEUE_MACRO(MSG_MOTE_ERROR_MSG); 
054B8:  BCF    F7A.1
054BA:  MOVLW  A0
054BC:  MOVLB  5
054BE:  MOVWF  x50
054C0:  MOVLB  0
054C2:  RCALL  4D00
054C4:  BSF    F7A.1
....................          } 
054C6:  BRA    551A
....................          // if we can't increase charge anymore, set it to max 
....................          else if ((global_brake_duty + duty_change) > MAX_CHARGE) 
054C8:  MOVLB  5
054CA:  MOVF   x4D,W
054CC:  MOVLB  0
054CE:  ADDWF  xAA,W
054D0:  MOVLB  5
054D2:  MOVWF  x50
054D4:  MOVLW  00
054D6:  MOVLB  0
054D8:  ADDWFC xAB,W
054DA:  MOVLB  5
054DC:  MOVWF  x51
054DE:  SUBLW  00
054E0:  BC    54FC
054E2:  XORLW  FF
054E4:  BNZ   54EC
054E6:  MOVF   x50,W
054E8:  SUBLW  90
054EA:  BC    54FC
....................          { 
....................             set_brake_duty(MAX_BRK); 
054EC:  MOVLW  01
054EE:  MOVWF  x53
054F0:  MOVLW  90
054F2:  MOVWF  x52
054F4:  MOVLB  0
054F6:  RCALL  5018
....................          } 
054F8:  BRA    551A
054FA:  MOVLB  5
....................          // increase braking as per normal 
....................          else 
....................          { 
....................             set_brake_duty(global_brake_duty + duty_change); 
054FC:  MOVF   x4D,W
054FE:  MOVLB  0
05500:  ADDWF  xAA,W
05502:  MOVLB  5
05504:  MOVWF  x50
05506:  MOVLW  00
05508:  MOVLB  0
0550A:  ADDWFC xAB,W
0550C:  MOVLB  5
0550E:  MOVWF  x51
05510:  MOVWF  x53
05512:  MOVFF  550,552
05516:  MOVLB  0
05518:  RCALL  5018
....................          } 
....................         
....................       } 
0551A:  BRA    55CC
....................       // Set point is higher than current value (increase braking force) 
....................       else if (global_current_rpm < global_rpm_set_value)  
0551C:  MOVF   xA3,W
0551E:  SUBWF  xA5,W
05520:  BNC   55CC
05522:  BNZ   552A
05524:  MOVF   xA4,W
05526:  SUBWF  xA2,W
05528:  BC    55CC
....................       { 
....................           
....................          // if we are at min charge (and brake) and the rpms are 0  
....................          // (a not spinning condition) 
....................          if (global_brake_duty == NO_BRK && (global_current_rpm == 0)) 
0552A:  MOVF   xAA,F
0552C:  BNZ   5560
0552E:  MOVF   xAB,F
05530:  BNZ   5560
05532:  MOVF   xA2,F
05534:  BNZ   5560
05536:  MOVF   xA3,F
05538:  BNZ   5560
....................          { 
....................             // start not spinning recovery 
....................             // set an error bit saying there isn't any spinning 
....................             global_error_message_bitfield |= ERR_MSG_NOT_SPINNING; 
0553A:  MOVLB  4
0553C:  BSF    xF1.3
....................             // send error message to manager 
....................             PUSH_MESSAGE_QUEUE_MACRO(MSG_MOTE_ERROR_MSG); 
0553E:  BCF    F7A.1
05540:  MOVLW  A0
05542:  MOVLB  5
05544:  MOVWF  x50
05546:  MOVLB  0
05548:  CALL   4D00
0554C:  BSF    F7A.1
....................             // push a MOVE_VALVE_NO_SPIN_RECOVERY event 
....................             PUSH_PRIORITY_QUEUE_MACRO(MOVE_VALVE_NO_SPIN_RECOVERY); 
0554E:  BCF    F7A.1
05550:  MOVLW  3D
05552:  MOVLB  5
05554:  MOVWF  x50
05556:  MOVLB  0
05558:  CALL   43F2
0555C:  BSF    F7A.1
....................          } 
0555E:  BRA    55CC
....................          // if we are at min braking already, move to the charging 
....................          else if (global_brake_duty == NO_BRK) 
05560:  MOVF   xAA,F
05562:  BNZ   557E
05564:  MOVF   xAB,F
05566:  BNZ   557E
....................          { 
....................             // if we are at min charge (and brake) send an error message if 
....................             //    the bitfield bit isn't already sent (to avoid sending messages 
....................             //    all the time 
....................     
....................             // set an error bit saying rpm was too high to reach 
....................             global_error_message_bitfield |= ERR_MSG_RPM_TOO_HIGH_TO_REACH; 
05568:  MOVLB  4
0556A:  BSF    xF0.4
....................             // send error message to manager 
....................             PUSH_MESSAGE_QUEUE_MACRO(MSG_MOTE_ERROR_MSG);   
0556C:  BCF    F7A.1
0556E:  MOVLW  A0
05570:  MOVLB  5
05572:  MOVWF  x50
05574:  MOVLB  0
05576:  CALL   4D00
0557A:  BSF    F7A.1
....................          }   
0557C:  BRA    55CC
....................          // if we can't decrease brake anymore, set it to min 
....................          // notice use of unsigned math here  
....................          else if ((global_brake_duty - duty_change) > MAX_BRK) 
0557E:  MOVLB  5
05580:  MOVF   x4D,W
05582:  MOVLB  0
05584:  SUBWF  xAA,W
05586:  MOVLB  5
05588:  MOVWF  x50
0558A:  MOVLW  00
0558C:  MOVLB  0
0558E:  SUBWFB xAB,W
05590:  MOVLB  5
05592:  MOVWF  x51
05594:  SUBLW  00
05596:  BC    55AE
05598:  XORLW  FF
0559A:  BNZ   55A2
0559C:  MOVF   x50,W
0559E:  SUBLW  90
055A0:  BC    55AE
....................          { 
....................             set_brake_duty(NO_BRK); 
055A2:  CLRF   x53
055A4:  CLRF   x52
055A6:  MOVLB  0
055A8:  RCALL  5018
....................          } 
055AA:  BRA    55CC
055AC:  MOVLB  5
....................         // decrease braking as per normal 
....................         else 
....................         { 
....................             set_brake_duty(global_brake_duty - duty_change); 
055AE:  MOVF   x4D,W
055B0:  MOVLB  0
055B2:  SUBWF  xAA,W
055B4:  MOVLB  5
055B6:  MOVWF  x50
055B8:  MOVLW  00
055BA:  MOVLB  0
055BC:  SUBWFB xAB,W
055BE:  MOVLB  5
055C0:  MOVWF  x51
055C2:  MOVWF  x53
055C4:  MOVFF  550,552
055C8:  MOVLB  0
055CA:  RCALL  5018
....................         } 
....................       } 
....................        
....................       // if we are in the brake only loop and want to turn off charger 
....................       if (global_control_loop_mechanism == BRAKE_ONLY) 
055CC:  MOVF   xB8,W
055CE:  SUBLW  02
055D0:  BNZ   561C
....................       { 
....................          // turn down charging until it is off (slowly) 
....................          if (global_charge_duty != NO_CHARGE) 
055D2:  MOVF   xAC,F
055D4:  BNZ   55DA
055D6:  MOVF   xAD,F
055D8:  BZ    561A
....................          { 
....................             // if gobal_charge_duty is 0-3 (note unsigned int math) 
....................             if ((global_charge_duty - 4) > MAX_CHARGE) 
055DA:  MOVLW  04
055DC:  SUBWF  xAC,W
055DE:  MOVLB  5
055E0:  MOVWF  x50
055E2:  MOVLW  00
055E4:  MOVLB  0
055E6:  SUBWFB xAD,W
055E8:  MOVLB  5
055EA:  MOVWF  x51
055EC:  SUBLW  00
055EE:  BC    5604
055F0:  XORLW  FF
055F2:  BNZ   55FA
055F4:  MOVF   x50,W
055F6:  SUBLW  90
055F8:  BC    5604
....................             { 
....................                // set it to no charge 
....................                global_charge_duty = NO_CHARGE; 
055FA:  MOVLB  0
055FC:  CLRF   xAD
055FE:  CLRF   xAC
....................             } 
05600:  BRA    560E
05602:  MOVLB  5
....................             else 
....................             { 
....................                // otherwise, decrement it by 4 
....................                global_charge_duty -= 4; 
05604:  MOVLW  04
05606:  MOVLB  0
05608:  SUBWF  xAC,F
0560A:  MOVLW  00
0560C:  SUBWFB xAD,F
....................             } 
....................             // set lower charge amount. 
....................             set_charge_duty(global_charge_duty);  
0560E:  MOVFF  AD,553
05612:  MOVFF  AC,552
05616:  CALL   3C22
....................          } 
....................       } 
0561A:  BRA    5674
....................       // if we are trying to turn the charger back on    
....................       else if (global_control_loop_mechanism == BRAKE_AND_CHARGE_START) 
0561C:  MOVF   xB8,F
0561E:  BNZ   5674
....................       {    
....................          // if gobal_charge_duty is almost completely on 
....................          if ((global_charge_duty + 4) >= MAX_CHARGE) 
05620:  MOVLW  04
05622:  ADDWF  xAC,W
05624:  MOVLB  5
05626:  MOVWF  x50
05628:  MOVLW  00
0562A:  MOVLB  0
0562C:  ADDWFC xAD,W
0562E:  MOVLB  5
05630:  MOVWF  x51
05632:  SUBLW  00
05634:  BC    5650
05636:  XORLW  FF
05638:  BNZ   5640
0563A:  MOVF   x50,W
0563C:  SUBLW  8F
0563E:  BC    5650
....................          { 
....................             // set it to max charge 
....................             global_charge_duty = MAX_CHARGE; 
05640:  MOVLW  01
05642:  MOVLB  0
05644:  MOVWF  xAD
05646:  MOVLW  90
05648:  MOVWF  xAC
....................             // change control loop mechanism so it changes on next loop 
....................             global_control_loop_mechanism = BRAKE_AND_CHARGE; 
0564A:  MOVLW  01
0564C:  MOVWF  xB8
....................          } 
0564E:  BRA    5668
....................          // if the braking has turned itself all the way off trying to compensate for 
....................          //    the charging turning on, switch over to the main control loop 
....................          else if(global_brake_duty == NO_BRK) 
05650:  MOVLB  0
05652:  MOVF   xAA,F
05654:  BNZ   5660
05656:  MOVF   xAB,F
05658:  BNZ   5660
....................          { 
....................             // change control loop mechanism 
....................             global_control_loop_mechanism = BRAKE_AND_CHARGE; 
0565A:  MOVLW  01
0565C:  MOVWF  xB8
....................          } 
0565E:  BRA    5668
....................          // otherwise, keep increasing the charge duty cycle. 
....................          else 
....................          { 
....................             // otherwise, decrement it by 4 
....................             global_charge_duty += 4; 
05660:  MOVLW  04
05662:  ADDWF  xAC,F
05664:  MOVLW  00
05666:  ADDWFC xAD,F
....................          } 
....................          // set higher charge amount. 
....................          set_charge_duty(global_charge_duty); 
05668:  MOVFF  AD,553
0566C:  MOVFF  AC,552
05670:  CALL   3C22
....................       } 
....................       break; 
05674:  BRA    5956
....................        
....................        
....................    // If in no rpm test mode 
....................    case NO_RPM_CONTROL_DYN_MPPC: 
....................    case NO_RPM_CONTROL: 
....................  
....................       // move things closer to the set values 
....................       // worst case senario 2.3 seconds to move 400 counts 
....................        
....................       // if difference is >= 200, move by 20  
....................       // if difference is >= 100, move by 10 
....................       // if difference is >= 50, move by 5 
....................       // if difference is >= 10, move by 2 
....................       // if difference is < 10, move by 1 
....................        
....................       brake_duty_difference = abs((int16_t)global_brake_duty - (int16_t)global_brake_duty_set_value); 
05676:  MOVF   xAE,W
05678:  SUBWF  xAA,W
0567A:  MOVLB  5
0567C:  MOVWF  x50
0567E:  MOVLB  0
05680:  MOVF   xAF,W
05682:  SUBWFB xAB,W
05684:  MOVLB  5
05686:  MOVWF  x51
05688:  MOVWF  03
0568A:  MOVF   x50,W
0568C:  BTFSS  x51.7
0568E:  BRA    56A0
05690:  MOVLW  00
05692:  BSF    FD8.0
05694:  SUBFWB x50,W
05696:  MOVWF  00
05698:  MOVLW  00
0569A:  SUBFWB x51,W
0569C:  MOVWF  03
0569E:  MOVF   00,W
056A0:  MOVWF  x49
056A2:  MOVFF  03,54A
....................       charge_duty_difference = abs((int16_t)global_charge_duty - (int16_t)global_charge_duty_set_value); 
056A6:  MOVLB  0
056A8:  MOVF   xB0,W
056AA:  SUBWF  xAC,W
056AC:  MOVLB  5
056AE:  MOVWF  x50
056B0:  MOVLB  0
056B2:  MOVF   xB1,W
056B4:  SUBWFB xAD,W
056B6:  MOVLB  5
056B8:  MOVWF  x51
056BA:  MOVWF  03
056BC:  MOVF   x50,W
056BE:  BTFSS  x51.7
056C0:  BRA    56D2
056C2:  MOVLW  00
056C4:  BSF    FD8.0
056C6:  SUBFWB x50,W
056C8:  MOVWF  00
056CA:  MOVLW  00
056CC:  SUBFWB x51,W
056CE:  MOVWF  03
056D0:  MOVF   00,W
056D2:  MOVWF  x4B
056D4:  MOVFF  03,54C
....................        
....................       if (brake_duty_difference >= 200) brake_duty_change = 20; 
056D8:  MOVF   x4A,F
056DA:  BNZ   56E2
056DC:  MOVF   x49,W
056DE:  SUBLW  C7
056E0:  BC    56E8
056E2:  MOVLW  14
056E4:  MOVWF  x4E
056E6:  BRA    5724
....................       else if (brake_duty_difference >= 100) brake_duty_change = 10; 
056E8:  MOVF   x4A,F
056EA:  BNZ   56F2
056EC:  MOVF   x49,W
056EE:  SUBLW  63
056F0:  BC    56F8
056F2:  MOVLW  0A
056F4:  MOVWF  x4E
056F6:  BRA    5724
....................       else if (brake_duty_difference >= 50) brake_duty_change = 5; 
056F8:  MOVF   x4A,F
056FA:  BNZ   5702
056FC:  MOVF   x49,W
056FE:  SUBLW  31
05700:  BC    5708
05702:  MOVLW  05
05704:  MOVWF  x4E
05706:  BRA    5724
....................       else if (brake_duty_difference >= 10) brake_duty_change = 2; 
05708:  MOVF   x4A,F
0570A:  BNZ   5712
0570C:  MOVF   x49,W
0570E:  SUBLW  09
05710:  BC    5718
05712:  MOVLW  02
05714:  MOVWF  x4E
05716:  BRA    5724
....................       else if (brake_duty_difference > 0) brake_duty_change = 1; 
05718:  MOVF   x49,F
0571A:  BNZ   5720
0571C:  MOVF   x4A,F
0571E:  BZ    5724
05720:  MOVLW  01
05722:  MOVWF  x4E
....................        
....................       if (global_brake_duty > global_brake_duty_set_value)  
05724:  MOVLB  0
05726:  MOVF   xAF,W
05728:  SUBWF  xAB,W
0572A:  BNC   574C
0572C:  BNZ   5734
0572E:  MOVF   xAA,W
05730:  SUBWF  xAE,W
05732:  BC    574C
....................       { 
....................          global_brake_duty-=brake_duty_change; 
05734:  MOVLB  5
05736:  MOVF   x4E,W
05738:  MOVLB  0
0573A:  SUBWF  xAA,F
0573C:  MOVLW  00
0573E:  SUBWFB xAB,F
....................          set_brake_duty(global_brake_duty); 
05740:  MOVFF  AB,553
05744:  MOVFF  AA,552
05748:  RCALL  5018
....................       } 
0574A:  BRA    5770
....................       else if (global_brake_duty < global_brake_duty_set_value) 
0574C:  MOVF   xAB,W
0574E:  SUBWF  xAF,W
05750:  BNC   5770
05752:  BNZ   575A
05754:  MOVF   xAE,W
05756:  SUBWF  xAA,W
05758:  BC    5770
....................       { 
....................          global_brake_duty+=brake_duty_change; 
0575A:  MOVLB  5
0575C:  MOVF   x4E,W
0575E:  MOVLB  0
05760:  ADDWF  xAA,F
05762:  MOVLW  00
05764:  ADDWFC xAB,F
....................          set_brake_duty(global_brake_duty); 
05766:  MOVFF  AB,553
0576A:  MOVFF  AA,552
0576E:  RCALL  5018
....................       } 
....................        
....................       if (charge_duty_difference >= 200) charge_duty_change = 20; 
05770:  MOVLB  5
05772:  MOVF   x4C,F
05774:  BNZ   577C
05776:  MOVF   x4B,W
05778:  SUBLW  C7
0577A:  BC    5782
0577C:  MOVLW  14
0577E:  MOVWF  x4F
05780:  BRA    57BE
....................       else if (charge_duty_difference >= 100) charge_duty_change = 10; 
05782:  MOVF   x4C,F
05784:  BNZ   578C
05786:  MOVF   x4B,W
05788:  SUBLW  63
0578A:  BC    5792
0578C:  MOVLW  0A
0578E:  MOVWF  x4F
05790:  BRA    57BE
....................       else if (charge_duty_difference >= 50) charge_duty_change = 5; 
05792:  MOVF   x4C,F
05794:  BNZ   579C
05796:  MOVF   x4B,W
05798:  SUBLW  31
0579A:  BC    57A2
0579C:  MOVLW  05
0579E:  MOVWF  x4F
057A0:  BRA    57BE
....................       else if (charge_duty_difference >= 10) charge_duty_change = 2; 
057A2:  MOVF   x4C,F
057A4:  BNZ   57AC
057A6:  MOVF   x4B,W
057A8:  SUBLW  09
057AA:  BC    57B2
057AC:  MOVLW  02
057AE:  MOVWF  x4F
057B0:  BRA    57BE
....................       else if (charge_duty_difference > 0) charge_duty_change = 1; 
057B2:  MOVF   x4B,F
057B4:  BNZ   57BA
057B6:  MOVF   x4C,F
057B8:  BZ    57BE
057BA:  MOVLW  01
057BC:  MOVWF  x4F
....................        
....................       if (global_charge_duty > global_charge_duty_set_value)  
057BE:  MOVLB  0
057C0:  MOVF   xB1,W
057C2:  SUBWF  xAD,W
057C4:  BNC   57E8
057C6:  BNZ   57CE
057C8:  MOVF   xAC,W
057CA:  SUBWF  xB0,W
057CC:  BC    57E8
....................       { 
....................          global_charge_duty-=charge_duty_change; 
057CE:  MOVLB  5
057D0:  MOVF   x4F,W
057D2:  MOVLB  0
057D4:  SUBWF  xAC,F
057D6:  MOVLW  00
057D8:  SUBWFB xAD,F
....................          set_charge_duty(global_charge_duty); 
057DA:  MOVFF  AD,553
057DE:  MOVFF  AC,552
057E2:  CALL   3C22
....................       } 
057E6:  BRA    580E
....................       else if (global_charge_duty < global_charge_duty_set_value) 
057E8:  MOVF   xAD,W
057EA:  SUBWF  xB1,W
057EC:  BNC   580E
057EE:  BNZ   57F6
057F0:  MOVF   xB0,W
057F2:  SUBWF  xAC,W
057F4:  BC    580E
....................       { 
....................          global_charge_duty+=charge_duty_change; 
057F6:  MOVLB  5
057F8:  MOVF   x4F,W
057FA:  MOVLB  0
057FC:  ADDWF  xAC,F
057FE:  MOVLW  00
05800:  ADDWFC xAD,F
....................          set_charge_duty(global_charge_duty); 
05802:  MOVFF  AD,553
05806:  MOVFF  AC,552
0580A:  CALL   3C22
....................       } 
....................       control_loop_cycles_to_next_update = 1; 
0580E:  MOVLW  01
05810:  MOVLB  5
05812:  MOVWF  x37
....................       break; 
05814:  MOVLB  0
05816:  BRA    5956
....................    case NO_SPIN_RECOVERY: 
....................       // it's fixed! 
....................       // RPM is above the limit (10), RPM is not MAX (for decoupled condition) and valve is moving. 
....................       if ((global_current_rpm > NOT_SPINNING_MAG_DECOUPLING_RPM_FIXED) && (global_current_rpm !=(0-1)) && (!IS_VLV_COASTING)) 
05818:  MOVF   xA3,F
0581A:  BNZ   5826
0581C:  MOVF   xA2,W
0581E:  MOVLB  5
05820:  SUBWF  x14,W
05822:  BC    5860
05824:  MOVLB  0
05826:  INCFSZ xA2,W
05828:  BRA    5834
0582A:  INCFSZ xA3,W
0582C:  BRA    5834
0582E:  MOVLB  5
05830:  BRA    5860
05832:  MOVLB  0
05834:  MOVF   F8D,F
05836:  BTFSS  FD8.2
05838:  BRA    583E
0583A:  MOVLB  5
0583C:  BRA    5860
....................       { 
....................          //stop the valve movement 
....................          disable_interrupts(INT_CCP3); 
0583E:  BCF    F7A.0
....................          global_valve_position_set_value = global_valve_position; 
05840:  MOVFF  BA,BC
05844:  MOVFF  B9,BB
....................          enable_interrupts(INT_CCP3); 
05848:  BSF    F7A.0
....................          // change control loop back to a normal mode 
....................          global_control_loop_mechanism = BRAKE_AND_CHARGE_START; 
0584A:  CLRF   xB8
....................          // send a valve report to let people know of the new position 
....................          PUSH_MESSAGE_QUEUE_MACRO(MSG_MOTE_VALVE_REPORT); 
0584C:  BCF    F7A.1
0584E:  MOVLW  92
05850:  MOVLB  5
05852:  MOVWF  x50
05854:  MOVLB  0
05856:  CALL   4D00
0585A:  BSF    F7A.1
....................       } 
0585C:  BRA    58B0
0585E:  MOVLB  5
....................       // KINDA MESSY, FIX THIS LATER 
....................       // if the valve is within 5% of valve range (~2 seconds) of the position it's going, 
....................       //    control loop update position is slowed to 100x64ms or 6.4 seconds to give it time to react  
....................       else if ((!IS_VLV_COASTING) && ((global_valve_position_set_value - global_valve_position) < 0x0400)) 
05860:  MOVF   F8D,F
05862:  BZ    5882
05864:  MOVLB  0
05866:  MOVF   xB9,W
05868:  SUBWF  xBB,W
0586A:  MOVLB  5
0586C:  MOVWF  x50
0586E:  MOVLB  0
05870:  MOVF   xBA,W
05872:  SUBWFB xBC,W
05874:  MOVLB  5
05876:  MOVWF  x51
05878:  SUBLW  03
0587A:  BNC   5882
....................       { 
....................          control_loop_cycles_to_next_update = 100; 
0587C:  MOVLW  64
0587E:  MOVWF  x37
....................       } 
05880:  BRA    58B2
....................       // it tried to move the valve a bunch and it didn't fix it :-/ 
....................       else if (IS_VLV_COASTING) 
05882:  MOVF   F8D,F
05884:  BNZ   58B2
....................       { 
....................          // set an error bit saying there isn't any spinning 
....................          global_error_message_bitfield |= ERR_MSG_MAG_NOT_SPIN_RECOVERY_FAILED; 
05886:  MOVLB  4
05888:  BSF    xF1.5
....................          // send error message to manager 
....................          PUSH_MESSAGE_QUEUE_MACRO(MSG_MOTE_ERROR_MSG); 
0588A:  BCF    F7A.1
0588C:  MOVLW  A0
0588E:  MOVLB  5
05890:  MOVWF  x50
05892:  MOVLB  0
05894:  CALL   4D00
05898:  BSF    F7A.1
....................          // stop the current sprinkler setting (also closes valve) and clear the queue 
....................          stop_current_spinkler_setting(); 
0589A:  CALL   5086
....................          clear_sprinkler_queue(); 
0589E:  RCALL  50C0
....................          // send a valve report to let people know of the new position 
....................          PUSH_MESSAGE_QUEUE_MACRO(MSG_MOTE_VALVE_REPORT); 
058A0:  BCF    F7A.1
058A2:  MOVLW  92
058A4:  MOVLB  5
058A6:  MOVWF  x50
058A8:  MOVLB  0
058AA:  CALL   4D00
058AE:  BSF    F7A.1
058B0:  MOVLB  5
....................       } 
....................       break; 
058B2:  MOVLB  0
058B4:  BRA    5956
....................    case MAG_DECOUPLING_RECOVERY: 
....................       // it's fixed! 
....................       // RPM is above the limit (10), RPM is not MAX (for decoupled condition) and valve is moving. 
....................       if ((global_current_rpm > NOT_SPINNING_MAG_DECOUPLING_RPM_FIXED) && (global_current_rpm !=(0-1)) && (!IS_VLV_COASTING)) 
058B6:  MOVF   xA3,F
058B8:  BNZ   58C4
058BA:  MOVF   xA2,W
058BC:  MOVLB  5
058BE:  SUBWF  x14,W
058C0:  BC    5900
058C2:  MOVLB  0
058C4:  INCFSZ xA2,W
058C6:  BRA    58D2
058C8:  INCFSZ xA3,W
058CA:  BRA    58D2
058CC:  MOVLB  5
058CE:  BRA    5900
058D0:  MOVLB  0
058D2:  MOVF   F8D,F
058D4:  BTFSS  FD8.2
058D6:  BRA    58DC
058D8:  MOVLB  5
058DA:  BRA    5900
....................       { 
....................          //stop the valve movement 
....................          disable_interrupts(INT_CCP3); 
058DC:  BCF    F7A.0
....................          global_valve_position_set_value = global_valve_position; 
058DE:  MOVFF  BA,BC
058E2:  MOVFF  B9,BB
....................          enable_interrupts(INT_CCP3); 
058E6:  BSF    F7A.0
....................          // change control loop back to a normal mode 
....................          global_control_loop_mechanism = BRAKE_AND_CHARGE_START; 
058E8:  CLRF   xB8
....................          // send a valve report to let people know of the new position 
....................          PUSH_MESSAGE_QUEUE_MACRO(MSG_MOTE_VALVE_REPORT); 
058EA:  BCF    F7A.1
058EC:  MOVLW  92
058EE:  MOVLB  5
058F0:  MOVWF  x50
058F2:  MOVLB  0
058F4:  CALL   4D00
058F8:  BSF    F7A.1
....................          // put the control algorithm into a non-rpm controlled state (sort of an idle state) 
....................          global_control_loop_mechanism = BRAKE_AND_CHARGE_START; 
058FA:  CLRF   xB8
....................       } 
058FC:  BRA    5952
058FE:  MOVLB  5
....................       // KINDA MESSY, FIX THIS LATER 
....................       // if the valve is within 5% of valve range (~2 seconds) of the position it's going, 
....................       //    control loop update position is slowed to 100x64ms or 6.4 seconds to give it time to react  
....................       else if ((!IS_VLV_COASTING) && ((global_valve_position - global_valve_position_set_value) < 0x0400)) 
05900:  MOVF   F8D,F
05902:  BZ    5922
05904:  MOVLB  0
05906:  MOVF   xBB,W
05908:  SUBWF  xB9,W
0590A:  MOVLB  5
0590C:  MOVWF  x50
0590E:  MOVLB  0
05910:  MOVF   xBC,W
05912:  SUBWFB xBA,W
05914:  MOVLB  5
05916:  MOVWF  x51
05918:  SUBLW  03
0591A:  BNC   5922
....................       { 
....................          control_loop_cycles_to_next_update = 100; 
0591C:  MOVLW  64
0591E:  MOVWF  x37
....................       } 
05920:  BRA    5954
....................       // it tried to move the valve a bunch and it didn't fix it :-/ 
....................       else if (IS_VLV_COASTING) 
05922:  MOVF   F8D,F
05924:  BNZ   5954
....................       { 
....................          // set an error bit saying there isn't any spinning 
....................          global_error_message_bitfield |= ERR_MSG_MAG_NOT_SPIN_RECOVERY_FAILED; 
05926:  MOVLB  4
05928:  BSF    xF1.5
....................          // send error message to manager 
....................          PUSH_MESSAGE_QUEUE_MACRO(MSG_MOTE_ERROR_MSG); 
0592A:  BCF    F7A.1
0592C:  MOVLW  A0
0592E:  MOVLB  5
05930:  MOVWF  x50
05932:  MOVLB  0
05934:  CALL   4D00
05938:  BSF    F7A.1
....................          // stop the current sprinkler setting (also closes valve) and clear the queue 
....................          stop_current_spinkler_setting(); 
0593A:  CALL   5086
....................          clear_sprinkler_queue(); 
0593E:  CALL   50C0
....................          // send a valve report to let people know of the new position 
....................          PUSH_MESSAGE_QUEUE_MACRO(MSG_MOTE_VALVE_REPORT); 
05942:  BCF    F7A.1
05944:  MOVLW  92
05946:  MOVLB  5
05948:  MOVWF  x50
0594A:  MOVLB  0
0594C:  CALL   4D00
05950:  BSF    F7A.1
05952:  MOVLB  5
....................       } 
....................       break; 
05954:  MOVLB  0
05956:  MOVLB  5
....................    }      
....................    return; 
05958:  MOVLB  0
0595A:  GOTO   9A5A (RETURN)
.................... } 
....................  
.................... void stop_current_spinkler_setting(void) 
.................... { 
....................    global_current_sprinkler_settings_end_time = 0-1; 
*
05086:  SETF   00
05088:  SETF   01
0508A:  SETF   02
0508C:  SETF   03
0508E:  MOVFF  03,425
05092:  MOVFF  02,424
05096:  MOVFF  01,423
0509A:  MOVFF  00,422
0509E:  CLRF   19
050A0:  BTFSC  FF2.7
050A2:  BSF    19.7
050A4:  BCF    FF2.7
....................    PUSH_PRIORITY_QUEUE_ISR(OPEN_VALVE_UNKNOWN_STATE); 
050A6:  MOVLW  3E
050A8:  MOVLB  5
050AA:  MOVWF  x9B
050AC:  MOVLB  0
050AE:  CALL   07D0
050B2:  BTFSC  19.7
050B4:  BSF    FF2.7
....................    global_rpm_set_value = 0; 
050B6:  CLRF   xA5
050B8:  CLRF   xA4
....................    //global_sprinkler_queue[global_current_sprinkler_queue_location].zone_num; 
....................    global_control_loop_mechanism = NO_RPM_CONTROL; 
050BA:  MOVLW  05
050BC:  MOVWF  xB8
050BE:  RETURN 0
.................... } 
.................... void stop_current_spinkler_setting_ISR(void) 
.................... { 
....................    global_current_sprinkler_settings_end_time = 0-1; 
*
02C44:  SETF   00
02C46:  SETF   01
02C48:  SETF   02
02C4A:  SETF   03
02C4C:  MOVFF  03,425
02C50:  MOVFF  02,424
02C54:  MOVFF  01,423
02C58:  MOVFF  00,422
....................    PUSH_PRIORITY_QUEUE_ISR_MACRO(OPEN_VALVE_UNKNOWN_STATE);           
02C5C:  MOVLW  3E
02C5E:  MOVLB  5
02C60:  MOVWF  x9B
02C62:  MOVLB  0
02C64:  CALL   07D0
....................    global_rpm_set_value = 0; 
02C68:  CLRF   xA5
02C6A:  CLRF   xA4
....................    //global_sprinkler_queue[global_current_sprinkler_queue_location].zone_num; 
....................    global_control_loop_mechanism = NO_RPM_CONTROL; 
02C6C:  MOVLW  05
02C6E:  MOVWF  xB8
02C70:  GOTO   2EFA (RETURN)
.................... }                                                         
....................  
.................... #include "valve.h"        
.................... void  comparator_setup(void) 
.................... { 
.................... // Sets up and enables the comparator for current limit detection when moving 
.................... //    valve 
....................     
....................    // turns off comparator 
....................    setup_comparator(NC_NC_NC_NC); 
*
07B70:  CLRF   F77
07B72:  MOVLW  04
07B74:  MOVWF  F78
07B76:  MOVWF  F79
....................     
....................    // Sets up the DAC for a range of VDD-VSS 
....................    setup_DAC(DAC_VSS_VDD); 
07B78:  MOVLW  80
07B7A:  MOVLB  F
07B7C:  MOVWF  x41
....................     
....................    // sets up an appropriate dac level depending on movement direction and  
....................    //    valve position 
....................    set_comp_dac_level(); 
07B7E:  MOVLB  0
07B80:  BRA    7A30
....................     
....................    // delay for comparator to setup? 
....................    delay_cycles(5); 
07B82:  BRA    7B84
07B84:  BRA    7B86
07B86:  NOP   
....................     
....................    // CP1 compares VLV_I at its neg input to the DAC output 
....................    // CP2 off at power up and stays off 
....................    setup_comparator(CP1_A1_DAC); 
07B88:  CLRF   F77
07B8A:  CLRF   F78
07B8C:  MOVLW  85
07B8E:  MOVWF  F79
07B90:  MOVF   F92,W
07B92:  IORLW  02
07B94:  MOVWF  F92
07B96:  MOVF   F93,W
....................                                      
....................    // clear the comparator interrupt and enable it 
....................    clear_interrupt(INT_COMP); 
07B98:  BCF    FA1.6
....................    enable_interrupts(INT_COMP); 
07B9A:  BSF    FA0.6
07B9C:  RETURN 0
.................... } 
....................  
....................  
.................... uint16_t calc_valve_movement_time(uint16_t current_location, uint16_t destination) 
.................... { 
.................... // calculates the amount of time it takes to make the move from  
.................... //    current location to destination and returns it in seconds (7.9 format) 
....................  
....................    uint32_t temp_u32; 
....................     
....................    // if valve is going to open 
....................    if (current_location < destination) 
....................    { 
....................       temp_u32 = ((uint32_t)(destination - current_location) * (uint32_t)(global_valve_time_to_open_1024th));  
....................    }   
....................    // if valve is going to close or not move at all 
....................    else if (current_location >= destination) 
....................    { 
....................       temp_u32 = ((uint32_t)(current_location - destination) * (uint32_t)(global_valve_time_to_close_1024th));  
....................    }   
....................     
....................    // now 8.24 format; convert to 16 bit 7.9 format (seconds) 
....................    if (bit_test(temp_u32,14)) 
....................    { 
....................       temp_u32 += 0x8000; 
....................    } 
....................    // return the time in 7.9 format (seconds) 
....................    return(uint16_t)(temp_u32 >> 15); 
.................... } 
....................  
.................... void set_comp_dac_level(void) 
.................... { 
.................... // sets the dac level for the comparator for different situations/vlv positions 
....................  
....................    // if valve is just begining to move and outside of the "almost close/opened" 
....................    //    regime.  DAC level is lowered to allow for more current draw. 
....................    if ((global_valve_time_in_motion_1024ths <= VLV_INIT_CURRENT_BOOST_TIME_1024THS)    \ 
....................       && (!(global_valve_position < VLV_NEAR_CLOSED_RANGE_MAX)) &&                     \ 
....................       (!(global_valve_position > VLV_NEAR_OPENED_RANGE_MAX))) 
*
07A30:  MOVF   xC2,W
07A32:  MOVLB  5
07A34:  SUBWF  x0F,W
07A36:  BNC   7A86
07A38:  BNZ   7A44
07A3A:  MOVLB  0
07A3C:  MOVF   xC1,W
07A3E:  MOVLB  5
07A40:  SUBWF  x0E,W
07A42:  BNC   7A86
07A44:  MOVLB  0
07A46:  MOVF   xBA,W
07A48:  MOVLB  4
07A4A:  SUBWF  xFF,W
07A4C:  BNC   7A64
07A4E:  BTFSC  FD8.2
07A50:  BRA    7A56
07A52:  MOVLB  5
07A54:  BRA    7A86
07A56:  MOVF   xFE,W
07A58:  MOVLB  0
07A5A:  SUBWF  xB9,W
07A5C:  BTFSC  FD8.0
07A5E:  BRA    7A64
07A60:  MOVLB  5
07A62:  BRA    7A86
07A64:  MOVLB  5
07A66:  MOVF   x01,W
07A68:  MOVLB  0
07A6A:  SUBWF  xBA,W
07A6C:  BNC   7A80
07A6E:  BTFSC  FD8.2
07A70:  BRA    7A76
07A72:  MOVLB  5
07A74:  BRA    7A86
07A76:  MOVF   xB9,W
07A78:  MOVLB  5
07A7A:  SUBWF  x00,W
07A7C:  BNC   7A86
07A7E:  MOVLB  0
....................    { 
....................       dac_write(DAC_LVL_INIT_CURRENT_BOOST); 
07A80:  MOVFF  50C,F40
....................    } 
07A84:  BRA    7B6A
....................     
....................    // initial valve open (for a few seconds) 
....................    else if (global_system_state == SYSTEM_CAL_VLV_1) 
07A86:  MOVLB  4
07A88:  MOVF   xFD,W
07A8A:  SUBLW  10
07A8C:  BNZ   7A94
....................    { 
....................       dac_write(DAC_LVL_IN_MIDDLE); 
07A8E:  MOVFF  50A,F40
....................    } 
07A92:  BRA    7B6A
....................     
....................    // inital valve close (don't know where we are exactly) 
....................    else if (global_system_state == SYSTEM_CAL_VLV_2) 
07A94:  MOVF   xFD,W
07A96:  SUBLW  11
07A98:  BNZ   7AC4
....................    { 
....................       // normally, during this state, the valve position should be unknown 
....................  
....................       // if the valve is almost (or fully) open after the inital open push aka 
....................       //    it hit the open endstop 
....................       if (global_valve_position > VLV_NEAR_OPENED_RANGE_MAX) 
07A9A:  MOVLB  5
07A9C:  MOVF   x01,W
07A9E:  MOVLB  0
07AA0:  SUBWF  xBA,W
07AA2:  BNC   7ABC
07AA4:  BNZ   7AB6
07AA6:  MOVF   xB9,W
07AA8:  MOVLB  5
07AAA:  SUBWF  x00,W
07AAC:  BTFSS  FD8.0
07AAE:  BRA    7AB4
07AB0:  MOVLB  0
07AB2:  BRA    7ABC
07AB4:  MOVLB  0
....................       { 
....................          dac_write(DAC_LVL_CLOSING_NEAR_OPENED); 
07AB6:  MOVFF  506,F40
....................       } 
07ABA:  BRA    7AC0
....................       // otherwise, position is unknown and will be assumed to be closing near 
....................       //    the closed endstop.  DAC level will be set as such to get a  
....................       //    consistent calibration 
....................       else 
....................       { 
....................          dac_write(DAC_LVL_CLOSING_NEAR_CLOSED); 
07ABC:  MOVFF  508,F40
....................       } 
....................    } 
07AC0:  BRA    7B6A
07AC2:  MOVLB  4
....................     
....................    // valve closing 
....................    else if (IS_VLV_CLOSING) 
07AC4:  DECFSZ F8D,W
07AC6:  BRA    7B14
....................    { 
....................       // valve is almost closed (or closed) and closing 
....................       if (global_valve_position < VLV_NEAR_CLOSED_RANGE_MAX) 
07AC8:  MOVLB  0
07ACA:  MOVF   xBA,W
07ACC:  MOVLB  4
07ACE:  SUBWF  xFF,W
07AD0:  BNC   7AEA
07AD2:  BNZ   7AE4
07AD4:  MOVF   xFE,W
07AD6:  MOVLB  0
07AD8:  SUBWF  xB9,W
07ADA:  BTFSS  FD8.0
07ADC:  BRA    7AE2
07ADE:  MOVLB  4
07AE0:  BRA    7AEA
07AE2:  MOVLB  4
....................       { 
....................          dac_write(DAC_LVL_CLOSING_NEAR_CLOSED); 
07AE4:  MOVFF  508,F40
....................       } 
07AE8:  BRA    7B12
....................       // valve is almost open (or open) and closing 
....................       else if (global_valve_position > VLV_NEAR_OPENED_RANGE_MAX) 
07AEA:  MOVLB  5
07AEC:  MOVF   x01,W
07AEE:  MOVLB  0
07AF0:  SUBWF  xBA,W
07AF2:  BNC   7B0C
07AF4:  BNZ   7B06
07AF6:  MOVF   xB9,W
07AF8:  MOVLB  5
07AFA:  SUBWF  x00,W
07AFC:  BTFSS  FD8.0
07AFE:  BRA    7B04
07B00:  MOVLB  0
07B02:  BRA    7B0C
07B04:  MOVLB  0
....................       { 
....................          dac_write(DAC_LVL_CLOSING_NEAR_OPENED); 
07B06:  MOVFF  506,F40
....................       } 
07B0A:  BRA    7B10
....................       // valve is in the middle somewhere 
....................       else 
....................       { 
....................          dac_write(DAC_LVL_IN_MIDDLE); 
07B0C:  MOVFF  50A,F40
07B10:  MOVLB  4
....................       } 
....................    } 
07B12:  BRA    7B6A
....................     
....................    // valve opening 
....................    else if (IS_VLV_OPENING) 
07B14:  MOVF   F8D,W
07B16:  SUBLW  02
07B18:  BNZ   7B66
....................    { 
....................       // valve is almost closed (or closed) and opening 
....................       if (global_valve_position < VLV_NEAR_CLOSED_RANGE_MAX) 
07B1A:  MOVLB  0
07B1C:  MOVF   xBA,W
07B1E:  MOVLB  4
07B20:  SUBWF  xFF,W
07B22:  BNC   7B3C
07B24:  BNZ   7B36
07B26:  MOVF   xFE,W
07B28:  MOVLB  0
07B2A:  SUBWF  xB9,W
07B2C:  BTFSS  FD8.0
07B2E:  BRA    7B34
07B30:  MOVLB  4
07B32:  BRA    7B3C
07B34:  MOVLB  4
....................       { 
....................          dac_write(DAC_LVL_OPENING_NEAR_CLOSED); 
07B36:  MOVFF  504,F40
....................       } 
07B3A:  BRA    7B64
....................       // valve is almost open (or open) and opening 
....................       else if (global_valve_position > VLV_NEAR_OPENED_RANGE_MAX) 
07B3C:  MOVLB  5
07B3E:  MOVF   x01,W
07B40:  MOVLB  0
07B42:  SUBWF  xBA,W
07B44:  BNC   7B5E
07B46:  BNZ   7B58
07B48:  MOVF   xB9,W
07B4A:  MOVLB  5
07B4C:  SUBWF  x00,W
07B4E:  BTFSS  FD8.0
07B50:  BRA    7B56
07B52:  MOVLB  0
07B54:  BRA    7B5E
07B56:  MOVLB  0
....................       { 
....................          dac_write(DAC_LVL_OPENING_NEAR_OPENED); 
07B58:  MOVFF  502,F40
....................       } 
07B5C:  BRA    7B62
....................       // valve is in the middle somewhere 
....................       else 
....................       { 
....................          dac_write(DAC_LVL_IN_MIDDLE); 
07B5E:  MOVFF  50A,F40
07B62:  MOVLB  4
....................       } 
....................    } 
07B64:  BRA    7B6A
....................     
....................    // other cases (like if this accidentally gets called before valve is 
....................    //    actually moving, although it should get picked up by the initial  
....................    //    boost case 
....................    else 
....................    { 
....................       dac_write(DAC_LVL_IN_MIDDLE); 
07B66:  MOVFF  50A,F40
07B6A:  MOVLB  0
....................    } 
07B6C:  GOTO   7B82 (RETURN)
.................... } 
....................  
....................  
.................... void set_comp_dac_level_ISR(void) 
.................... { 
.................... // sets the dac level for the comparator for different situations/vlv positions 
....................  
....................    // if valve is just begining to move and outside of the "almost close/opened" 
....................    //    regime.  DAC level is lowered to allow for more current draw. 
....................    if ((global_valve_time_in_motion_1024ths <= VLV_INIT_CURRENT_BOOST_TIME_1024THS) \ 
....................       && (!(global_valve_position < VLV_NEAR_CLOSED_RANGE_MAX)) &&            \ 
....................       (!(global_valve_position > VLV_NEAR_OPENED_RANGE_MAX))) 
*
01D92:  MOVF   xC2,W
01D94:  MOVLB  5
01D96:  SUBWF  x0F,W
01D98:  BNC   1DE8
01D9A:  BNZ   1DA6
01D9C:  MOVLB  0
01D9E:  MOVF   xC1,W
01DA0:  MOVLB  5
01DA2:  SUBWF  x0E,W
01DA4:  BNC   1DE8
01DA6:  MOVLB  0
01DA8:  MOVF   xBA,W
01DAA:  MOVLB  4
01DAC:  SUBWF  xFF,W
01DAE:  BNC   1DC6
01DB0:  BTFSC  FD8.2
01DB2:  BRA    1DB8
01DB4:  MOVLB  5
01DB6:  BRA    1DE8
01DB8:  MOVF   xFE,W
01DBA:  MOVLB  0
01DBC:  SUBWF  xB9,W
01DBE:  BTFSC  FD8.0
01DC0:  BRA    1DC6
01DC2:  MOVLB  5
01DC4:  BRA    1DE8
01DC6:  MOVLB  5
01DC8:  MOVF   x01,W
01DCA:  MOVLB  0
01DCC:  SUBWF  xBA,W
01DCE:  BNC   1DE2
01DD0:  BTFSC  FD8.2
01DD2:  BRA    1DD8
01DD4:  MOVLB  5
01DD6:  BRA    1DE8
01DD8:  MOVF   xB9,W
01DDA:  MOVLB  5
01DDC:  SUBWF  x00,W
01DDE:  BNC   1DE8
01DE0:  MOVLB  0
....................    { 
....................       dac_write(DAC_LVL_INIT_CURRENT_BOOST); 
01DE2:  MOVFF  50C,F40
....................    } 
01DE6:  BRA    1ECC
....................     
....................    // initial valve open (for a few seconds) 
....................    else if (global_system_state == SYSTEM_CAL_VLV_1) 
01DE8:  MOVLB  4
01DEA:  MOVF   xFD,W
01DEC:  SUBLW  10
01DEE:  BNZ   1DF6
....................    { 
....................       dac_write(DAC_LVL_IN_MIDDLE); 
01DF0:  MOVFF  50A,F40
....................    } 
01DF4:  BRA    1ECC
....................     
....................    // inital valve close (don't know where we are exactly) 
....................    else if (global_system_state == SYSTEM_CAL_VLV_2) 
01DF6:  MOVF   xFD,W
01DF8:  SUBLW  11
01DFA:  BNZ   1E26
....................    { 
....................       // normally, during this state, the valve position should be unknown 
....................  
....................       // if the valve is almost (or fully) open after the inital open push aka 
....................       //    it hit the open endstop 
....................       if (global_valve_position > VLV_NEAR_OPENED_RANGE_MAX) 
01DFC:  MOVLB  5
01DFE:  MOVF   x01,W
01E00:  MOVLB  0
01E02:  SUBWF  xBA,W
01E04:  BNC   1E1E
01E06:  BNZ   1E18
01E08:  MOVF   xB9,W
01E0A:  MOVLB  5
01E0C:  SUBWF  x00,W
01E0E:  BTFSS  FD8.0
01E10:  BRA    1E16
01E12:  MOVLB  0
01E14:  BRA    1E1E
01E16:  MOVLB  0
....................       { 
....................          dac_write(DAC_LVL_CLOSING_NEAR_OPENED); 
01E18:  MOVFF  506,F40
....................       } 
01E1C:  BRA    1E22
....................       // otherwise, position is unknown and will be assumed to be closing near 
....................       //    the closed endstop.  DAC level will be set as such to get a  
....................       //    consistent calibration 
....................       else 
....................       { 
....................          dac_write(DAC_LVL_CLOSING_NEAR_CLOSED); 
01E1E:  MOVFF  508,F40
....................       } 
....................    } 
01E22:  BRA    1ECC
01E24:  MOVLB  4
....................     
....................    // valve closing 
....................    else if (IS_VLV_CLOSING) 
01E26:  DECFSZ F8D,W
01E28:  BRA    1E76
....................    { 
....................       // valve is almost closed (or closed) and closing 
....................       if (global_valve_position < VLV_NEAR_CLOSED_RANGE_MAX) 
01E2A:  MOVLB  0
01E2C:  MOVF   xBA,W
01E2E:  MOVLB  4
01E30:  SUBWF  xFF,W
01E32:  BNC   1E4C
01E34:  BNZ   1E46
01E36:  MOVF   xFE,W
01E38:  MOVLB  0
01E3A:  SUBWF  xB9,W
01E3C:  BTFSS  FD8.0
01E3E:  BRA    1E44
01E40:  MOVLB  4
01E42:  BRA    1E4C
01E44:  MOVLB  4
....................       { 
....................          dac_write(DAC_LVL_CLOSING_NEAR_CLOSED); 
01E46:  MOVFF  508,F40
....................       } 
01E4A:  BRA    1E74
....................       // valve is almost open (or open) and closing 
....................       else if (global_valve_position > VLV_NEAR_OPENED_RANGE_MAX) 
01E4C:  MOVLB  5
01E4E:  MOVF   x01,W
01E50:  MOVLB  0
01E52:  SUBWF  xBA,W
01E54:  BNC   1E6E
01E56:  BNZ   1E68
01E58:  MOVF   xB9,W
01E5A:  MOVLB  5
01E5C:  SUBWF  x00,W
01E5E:  BTFSS  FD8.0
01E60:  BRA    1E66
01E62:  MOVLB  0
01E64:  BRA    1E6E
01E66:  MOVLB  0
....................       { 
....................          dac_write(DAC_LVL_CLOSING_NEAR_OPENED); 
01E68:  MOVFF  506,F40
....................       } 
01E6C:  BRA    1E72
....................       // valve is in the middle somewhere 
....................       else 
....................       { 
....................          dac_write(DAC_LVL_IN_MIDDLE); 
01E6E:  MOVFF  50A,F40
01E72:  MOVLB  4
....................       } 
....................    } 
01E74:  BRA    1ECC
....................     
....................    // valve opening 
....................    else if (IS_VLV_OPENING) 
01E76:  MOVF   F8D,W
01E78:  SUBLW  02
01E7A:  BNZ   1EC8
....................    { 
....................       // valve is almost closed (or closed) and opening 
....................       if (global_valve_position < VLV_NEAR_CLOSED_RANGE_MAX) 
01E7C:  MOVLB  0
01E7E:  MOVF   xBA,W
01E80:  MOVLB  4
01E82:  SUBWF  xFF,W
01E84:  BNC   1E9E
01E86:  BNZ   1E98
01E88:  MOVF   xFE,W
01E8A:  MOVLB  0
01E8C:  SUBWF  xB9,W
01E8E:  BTFSS  FD8.0
01E90:  BRA    1E96
01E92:  MOVLB  4
01E94:  BRA    1E9E
01E96:  MOVLB  4
....................       { 
....................          dac_write(DAC_LVL_OPENING_NEAR_CLOSED); 
01E98:  MOVFF  504,F40
....................       } 
01E9C:  BRA    1EC6
....................       // valve is almost open (or open) and opening 
....................       else if (global_valve_position > VLV_NEAR_OPENED_RANGE_MAX) 
01E9E:  MOVLB  5
01EA0:  MOVF   x01,W
01EA2:  MOVLB  0
01EA4:  SUBWF  xBA,W
01EA6:  BNC   1EC0
01EA8:  BNZ   1EBA
01EAA:  MOVF   xB9,W
01EAC:  MOVLB  5
01EAE:  SUBWF  x00,W
01EB0:  BTFSS  FD8.0
01EB2:  BRA    1EB8
01EB4:  MOVLB  0
01EB6:  BRA    1EC0
01EB8:  MOVLB  0
....................       { 
....................          dac_write(DAC_LVL_OPENING_NEAR_OPENED); 
01EBA:  MOVFF  502,F40
....................       } 
01EBE:  BRA    1EC4
....................       // valve is in the middle somewhere 
....................       else 
....................       { 
....................          dac_write(DAC_LVL_IN_MIDDLE); 
01EC0:  MOVFF  50A,F40
01EC4:  MOVLB  4
....................       } 
....................    } 
01EC6:  BRA    1ECC
....................     
....................    // other cases (like if this accidentally gets called before valve is 
....................    //    actually moving, although it should get picked up by the initial  
....................    //    boost case 
....................    else 
....................    { 
....................       dac_write(DAC_LVL_IN_MIDDLE); 
01EC8:  MOVFF  50A,F40
01ECC:  MOVLB  0
....................    } 
01ECE:  GOTO   202E (RETURN)
.................... } 
....................  
.................... int1 is_valve_position_valid(uint16_t value) 
.................... // returns true if valid range for valve 
.................... { 
....................    if (value > VLV_POSITION_OPENED) return FALSE; 
*
064F8:  MOVLB  5
064FA:  MOVF   x51,W
064FC:  SUBLW  7F
064FE:  BC    6512
06500:  XORLW  FF
06502:  BNZ   650A
06504:  MOVF   x50,W
06506:  SUBLW  00
06508:  BC    6512
0650A:  MOVLW  00
0650C:  MOVWF  01
0650E:  BRA    6516
06510:  BRA    6516
....................    else if ((value < VLV_POSITION_CLOSED) && (VLV_POSITION_CLOSED != 0)) return FALSE; 
....................    else return TRUE; 
06512:  MOVLW  01
06514:  MOVWF  01
06516:  MOVLB  0
06518:  RETURN 0
.................... } 
....................  
.................... #include "battery.h"                                                           
.................... // JG 
.................... uint16_t get_vbatt(int1 charge_state) 
*
03F5E:  MOVLB  5
03F60:  CLRF   x56
03F62:  CLRF   x55
.................... { 
....................    /* Samples the V_EXT_REF to get the battery voltage 
....................     * and returns a uint16_t of the sum of 4 samples 
....................     * charge_state defines if you want the LTC3105 to be: 
....................     * 0 - original state 
....................     * 1 - not charging 
....................     */ 
....................                                                           
....................    uint8_t nn; 
....................    uint16_t v_batt_value = 0; 
....................    int1     tmp_RB3; 
....................    uint8_t  tmp_ccp2con; 
....................     
....................    // save state of RB3, which includes the LTC3105_CTRL line 
....................    tmp_ccp2con = CCP2CON;        
03F64:  MOVFF  F66,558
....................     
....................    // save state of CCP2, which controls charging aggressiveness 
....................    // note that CCP2 will have control of the pin unless it is OFF 
....................    tmp_RB3 = LTC3105_CTRL_pinstate;  
03F68:  BCF    x57.0
03F6A:  BTFSC  F8A.3
03F6C:  BSF    x57.0
....................     
....................    // turn on ADC 
....................    ADON = TRUE;          
03F6E:  BSF    FC2.0
....................     
....................    // set adc to VREF 
....................    set_adc_channel(V_EXT_REF); 
03F70:  MOVLW  00
03F72:  MOVWF  01
03F74:  MOVF   FC2,W
03F76:  ANDLW  83
03F78:  IORWF  01,W
03F7A:  MOVWF  FC2
....................     
....................    // alter the charge state if necessary 
....................    // charge state off 
....................    if (charge_state == 1) 
03F7C:  DECFSZ x53,W
03F7E:  BRA    3F86
....................    { 
....................       setup_ccp2(CCP_OFF);    
03F80:  MOVLW  F0
03F82:  ANDWF  F66,F
....................       output_low(LTC3105_CTRL); 
03F84:  BCF    F8A.3
....................    } 
....................     
....................    // sum up 4 samples from the adc 
....................    for (nn=0; nn<4; nn++) 
03F86:  CLRF   x54
03F88:  MOVF   x54,W
03F8A:  SUBLW  03
03F8C:  BNC   3FA0
....................    { 
....................       v_batt_value += read_adc(); 
03F8E:  BSF    FC2.1
03F90:  BTFSC  FC2.1
03F92:  BRA    3F90
03F94:  MOVF   FC3,W
03F96:  ADDWF  x55,F
03F98:  MOVF   FC4,W
03F9A:  ADDWFC x56,F
03F9C:  INCF   x54,F
03F9E:  BRA    3F88
....................    } 
....................     
....................    // Now return charger to its previous state 
....................    LTC3105_CTRL_pinstate = tmp_RB3; 
03FA0:  BCF    F8A.3
03FA2:  BTFSC  x57.0
03FA4:  BSF    F8A.3
....................    CCP2CON = tmp_ccp2con; 
03FA6:  MOVFF  558,F66
....................     
....................    // turn off adc 
....................    ADON = FALSE; 
03FAA:  BCF    FC2.0
....................     
....................    // return the voltage 
....................    return v_batt_value; 
03FAC:  MOVFF  555,01
03FB0:  MOVFF  556,02
03FB4:  MOVLB  0
03FB6:  RETURN 0
.................... } 
....................  
.................... uint16_t get_vbatt_ISR(int1 charge_state) 
*
02256:  MOVLB  5
02258:  CLRF   x92
0225A:  CLRF   x91
.................... { 
....................    /* Samples the V_EXT_REF to get the battery voltage 
....................     * and returns a uint16_t of the sum of 4 samples 
....................     * charge_state defines if you want the LTC3105 to be: 
....................     * 0 - original state 
....................     * 1 - not charging 
....................     */ 
....................      
....................    uint8_t nn; 
....................    uint16_t v_batt_value = 0; 
....................    int1     tmp_RB3; 
....................    uint8_t  tmp_ccp2con; 
....................     
....................    // save state of RB3, which includes the LTC3105_CTRL line 
....................    tmp_ccp2con = CCP2CON; 
0225C:  MOVFF  F66,594
....................     
....................    // save state of CCP2, which controls charging aggressiveness 
....................    // note that CCP2 will have control of the pin unless it is OFF 
....................    tmp_RB3 = LTC3105_CTRL_pinstate;  
02260:  BCF    x93.0
02262:  BTFSC  F8A.3
02264:  BSF    x93.0
....................     
....................    // turn on ADC 
....................    ADON = TRUE;          
02266:  BSF    FC2.0
....................     
....................    // set adc to VREF 
....................    set_adc_channel(V_EXT_REF); 
02268:  MOVLW  00
0226A:  MOVWF  01
0226C:  MOVF   FC2,W
0226E:  ANDLW  83
02270:  IORWF  01,W
02272:  MOVWF  FC2
....................     
....................    // alter the charge state if necessary 
....................    // charge state off 
....................    if (charge_state == 1) 
02274:  DECFSZ x8F,W
02276:  BRA    227E
....................    { 
....................       setup_ccp2(CCP_OFF);    
02278:  MOVLW  F0
0227A:  ANDWF  F66,F
....................       output_low(LTC3105_CTRL); 
0227C:  BCF    F8A.3
....................    } 
....................     
....................    // sum up 4 samples from the adc 
....................    for (nn=0; nn<4; nn++) 
0227E:  CLRF   x90
02280:  MOVF   x90,W
02282:  SUBLW  03
02284:  BNC   2298
....................    { 
....................       v_batt_value += read_adc(); 
02286:  BSF    FC2.1
02288:  BTFSC  FC2.1
0228A:  BRA    2288
0228C:  MOVF   FC3,W
0228E:  ADDWF  x91,F
02290:  MOVF   FC4,W
02292:  ADDWFC x92,F
02294:  INCF   x90,F
02296:  BRA    2280
....................    } 
....................     
....................    // Now return charger to its previous state 
....................    LTC3105_CTRL_pinstate = tmp_RB3; 
02298:  BCF    F8A.3
0229A:  BTFSC  x93.0
0229C:  BSF    F8A.3
....................    CCP2CON = tmp_ccp2con; 
0229E:  MOVFF  594,F66
....................     
....................    // turn off adc 
....................    ADON = FALSE; 
022A2:  BCF    FC2.0
....................     
....................    // return the voltage 
....................    return v_batt_value; 
022A4:  MOVFF  591,01
022A8:  MOVFF  592,02
022AC:  MOVLB  0
022AE:  RETURN 0
.................... } 
....................  
.................... uint16_t get_vgen(int1 charge_state) 
*
03FB8:  MOVLB  5
03FBA:  CLRF   x56
03FBC:  CLRF   x55
.................... { 
....................    /* Samples the V_GEN to get the battery voltage 
....................     * and returns a uint16_t of the sum of 4 samples 
....................     * charge_state defines if you want the LTC3105 to be: 
....................     * 0 - original state 
....................     * 1 - not charging 
....................     */ 
....................      
....................    uint8_t nn; 
....................    uint16_t vgen_value = 0; 
....................    int1     tmp_RB3; 
....................    uint8_t  tmp_ccp2con; 
....................     
....................    // save state of RB3, which includes the LTC3105_CTRL line 
....................    tmp_ccp2con = CCP2CON; 
03FBE:  MOVFF  F66,558
....................     
....................    // save state of CCP2, which controls charging aggressiveness 
....................    // note that CCP2 will have control of the pin unless it is OFF 
....................    tmp_RB3 = LTC3105_CTRL_pinstate;  
03FC2:  BCF    x57.0
03FC4:  BTFSC  F8A.3
03FC6:  BSF    x57.0
....................     
....................    // turn on ADC 
....................    ADON = TRUE;          
03FC8:  BSF    FC2.0
....................     
....................    // set adc to VREF 
....................    set_adc_channel(V_GEN); 
03FCA:  MOVLW  30
03FCC:  MOVWF  01
03FCE:  MOVF   FC2,W
03FD0:  ANDLW  83
03FD2:  IORWF  01,W
03FD4:  MOVWF  FC2
....................     
....................    // alter the charge state if necessary 
....................    // charge state off 
....................    if (charge_state == 1) 
03FD6:  DECFSZ x53,W
03FD8:  BRA    3FE0
....................    { 
....................       setup_ccp2(CCP_OFF);    
03FDA:  MOVLW  F0
03FDC:  ANDWF  F66,F
....................       output_low(LTC3105_CTRL); 
03FDE:  BCF    F8A.3
....................    } 
....................     
....................    // sum up 3 samples from the adc 
....................    for (nn=0; nn<3; nn++) 
03FE0:  CLRF   x54
03FE2:  MOVF   x54,W
03FE4:  SUBLW  02
03FE6:  BNC   3FFA
....................    { 
....................       vgen_value += read_adc(); 
03FE8:  BSF    FC2.1
03FEA:  BTFSC  FC2.1
03FEC:  BRA    3FEA
03FEE:  MOVF   FC3,W
03FF0:  ADDWF  x55,F
03FF2:  MOVF   FC4,W
03FF4:  ADDWFC x56,F
03FF6:  INCF   x54,F
03FF8:  BRA    3FE2
....................    } 
....................     
....................    // Now return charger to its previous state 
....................    LTC3105_CTRL_pinstate = tmp_RB3; 
03FFA:  BCF    F8A.3
03FFC:  BTFSC  x57.0
03FFE:  BSF    F8A.3
....................    CCP2CON = tmp_ccp2con; 
04000:  MOVFF  558,F66
....................     
....................    // turn off adc 
....................    ADON = FALSE; 
04004:  BCF    FC2.0
....................     
....................    // save vgen to global value 
....................    global_vgen = vgen_value; 
04006:  MOVFF  556,B5
0400A:  MOVFF  555,B4
....................     
....................    // return the voltage 
....................    return vgen_value; 
0400E:  MOVFF  555,01
04012:  MOVFF  556,02
04016:  MOVLB  0
04018:  RETURN 0
.................... } 
....................  
.................... uint16_t calc_vbatt_BCD(uint16_t vref_count) 
.................... { 
....................    /* Takes the voltage count as an input (summed from DAC) 
....................     * and outputs the battery integer and fractional as a single uint32_t 
....................     * It's output is BCD as follows: 
....................     * volts (.) tenths hundredths thousandths 
....................    */ 
....................    uint8_t volts, tenths, hundredths, thousandths; 
....................  
....................    uint32_t tempo_u32, frac_part; 
....................    uint16_t tempo_u16;   
....................     
....................    uint16_t    bat_frac_part;    // in units of mV 
....................     
....................    tempo_u32 = VAL32_FVR_BAT/vref_count;   // = 1 count in volts in 12.20 format 
*
07C62:  MOVFF  554,566
07C66:  MOVFF  553,565
07C6A:  CALL   44B8
07C6E:  MOVLW  9A
07C70:  MOVLB  5
07C72:  MOVWF  x68
07C74:  MOVLW  99
07C76:  MOVWF  x67
07C78:  MOVLW  19
07C7A:  MOVWF  x66
07C7C:  MOVLW  95
07C7E:  MOVWF  x65
07C80:  MOVFF  03,56C
07C84:  MOVFF  02,56B
07C88:  MOVFF  01,56A
07C8C:  MOVFF  00,569
07C90:  MOVLB  0
07C92:  CALL   44EE
07C96:  MOVFF  03,568
07C9A:  MOVFF  02,567
07C9E:  MOVFF  01,566
07CA2:  MOVFF  00,565
07CA6:  CALL   464C
07CAA:  MOVFF  03,55C
07CAE:  MOVFF  02,55B
07CB2:  MOVFF  01,55A
07CB6:  MOVFF  00,559
07CBA:  CLRF   19
07CBC:  BTFSC  FF2.7
07CBE:  BSF    19.7
07CC0:  BCF    FF2.7
....................    tempo_u32 *= 1023;                        // bat voltage in 12.20 format 
07CC2:  MOVFF  55C,58C
07CC6:  MOVFF  55B,58B
07CCA:  MOVFF  55A,58A
07CCE:  MOVFF  559,589
07CD2:  MOVLB  5
07CD4:  CLRF   x90
07CD6:  CLRF   x8F
07CD8:  MOVLW  03
07CDA:  MOVWF  x8E
07CDC:  SETF   x8D
07CDE:  MOVLB  0
07CE0:  CALL   1930
07CE4:  BTFSC  19.7
07CE6:  BSF    FF2.7
07CE8:  MOVFF  03,55C
07CEC:  MOVFF  02,55B
07CF0:  MOVFF  01,55A
07CF4:  MOVFF  00,559
....................    tempo_u16 = (uint16_t)(tempo_u32 >> 8); 
07CF8:  MOVFF  55B,562
07CFC:  MOVFF  55A,561
....................                                              // bat voltage in 4.12 format 
....................    volts = (uint8_t)(tempo_u16 >> 12);       // 2 or 3.....    
07D00:  MOVLB  5
07D02:  SWAPF  x62,W
07D04:  MOVWF  02
07D06:  MOVLW  0F
07D08:  ANDWF  02,F
07D0A:  MOVFF  02,555
....................     
....................    frac_part = (uint32_t)(tempo_u16 & 0x0fff); 
07D0E:  MOVF   x62,W
07D10:  ANDLW  0F
07D12:  MOVFF  561,55D
07D16:  MOVWF  x5E
07D18:  CLRF   x5F
07D1A:  CLRF   x60
07D1C:  CLRF   19
07D1E:  BTFSC  FF2.7
07D20:  BSF    19.7
07D22:  BCF    FF2.7
....................                                        // one count of frac_part is 1/4096 volt 
....................                                        // no rounding, full resolution 
....................    tempo_u32 = (frac_part * 1000);     // We ignore the mV rounding issue 
07D24:  MOVFF  560,58C
07D28:  MOVFF  55F,58B
07D2C:  MOVFF  55E,58A
07D30:  MOVFF  55D,589
07D34:  CLRF   x90
07D36:  CLRF   x8F
07D38:  MOVLW  03
07D3A:  MOVWF  x8E
07D3C:  MOVLW  E8
07D3E:  MOVWF  x8D
07D40:  MOVLB  0
07D42:  CALL   1930
07D46:  BTFSC  19.7
07D48:  BSF    FF2.7
07D4A:  MOVFF  03,55C
07D4E:  MOVFF  02,55B
07D52:  MOVFF  01,55A
07D56:  MOVFF  00,559
....................                                        //  cuz battery measurement doesn't 
....................                                        //  support even mV resolution 
....................    tempo_u32 >>= 12; 
07D5A:  MOVLB  5
07D5C:  MOVFF  55A,559
07D60:  MOVFF  55B,55A
07D64:  MOVFF  55C,55B
07D68:  CLRF   x5C
07D6A:  RRCF   x5C,F
07D6C:  RRCF   x5B,F
07D6E:  RRCF   x5A,F
07D70:  RRCF   x59,F
07D72:  RRCF   x5C,F
07D74:  RRCF   x5B,F
07D76:  RRCF   x5A,F
07D78:  RRCF   x59,F
07D7A:  RRCF   x5C,F
07D7C:  RRCF   x5B,F
07D7E:  RRCF   x5A,F
07D80:  RRCF   x59,F
07D82:  RRCF   x5C,F
07D84:  RRCF   x5B,F
07D86:  RRCF   x5A,F
07D88:  RRCF   x59,F
07D8A:  MOVLW  0F
07D8C:  ANDWF  x5C,F
....................    tempo_u16 = (uint16_t)(tempo_u32); 
07D8E:  MOVFF  55A,562
07D92:  MOVFF  559,561
....................    tenths = tempo_u16/100; 
07D96:  MOVFF  562,572
07D9A:  MOVFF  561,571
07D9E:  CLRF   x74
07DA0:  MOVLW  64
07DA2:  MOVWF  x73
07DA4:  MOVLB  0
07DA6:  CALL   402E
07DAA:  MOVFF  01,556
....................    tempo_u16 -= (uint16_t)(tenths)*100; 
07DAE:  MOVLB  5
07DB0:  CLRF   x66
07DB2:  MOVFF  556,565
07DB6:  MOVFF  566,568
07DBA:  MOVFF  556,567
07DBE:  CLRF   x6A
07DC0:  MOVLW  64
07DC2:  MOVWF  x69
07DC4:  MOVLB  0
07DC6:  CALL   4B3C
07DCA:  MOVF   01,W
07DCC:  MOVLB  5
07DCE:  SUBWF  x61,F
07DD0:  MOVF   02,W
07DD2:  SUBWFB x62,F
....................    hundredths = tempo_u16/10; 
07DD4:  MOVFF  562,572
07DD8:  MOVFF  561,571
07DDC:  CLRF   x74
07DDE:  MOVLW  0A
07DE0:  MOVWF  x73
07DE2:  MOVLB  0
07DE4:  CALL   402E
07DE8:  MOVFF  01,557
....................    thousandths = tempo_u16 % 10; 
07DEC:  MOVFF  562,572
07DF0:  MOVFF  561,571
07DF4:  MOVLB  5
07DF6:  CLRF   x74
07DF8:  MOVLW  0A
07DFA:  MOVWF  x73
07DFC:  MOVLB  0
07DFE:  CALL   402E
07E02:  MOVFF  00,558
07E06:  MOVLB  5
....................  
....................    return ((uint16_t)(volts)*4096 + (uint16_t)(tenths)*256 + (uint16_t)(hundredths)*16 + (uint16_t)(thousandths)); 
07E08:  CLRF   x66
07E0A:  SWAPF  x55,W
07E0C:  MOVWF  x66
07E0E:  CLRF   x65
07E10:  MOVLW  F0
07E12:  ANDWF  x66,F
07E14:  CLRF   x68
07E16:  MOVFF  556,03
07E1A:  MOVLW  00
07E1C:  ADDWF  x65,F
07E1E:  MOVF   x56,W
07E20:  ADDWFC x66,F
07E22:  CLRF   x68
07E24:  RLCF   x57,W
07E26:  MOVWF  02
07E28:  RLCF   x68,W
07E2A:  MOVWF  03
07E2C:  RLCF   02,F
07E2E:  RLCF   03,F
07E30:  RLCF   02,F
07E32:  RLCF   03,F
07E34:  RLCF   02,F
07E36:  RLCF   03,F
07E38:  MOVLW  F0
07E3A:  ANDWF  02,F
07E3C:  MOVF   02,W
07E3E:  ADDWF  x65,F
07E40:  MOVF   03,W
07E42:  ADDWFC x66,F
07E44:  CLRF   03
07E46:  MOVF   x58,W
07E48:  ADDWF  x65,W
07E4A:  MOVWF  01
07E4C:  MOVF   x66,W
07E4E:  ADDWFC 03,F
07E50:  MOVFF  03,02
07E54:  MOVLB  0
07E56:  GOTO   7EBA (RETURN)
.................... } 
....................  
.................... uint32_t calc_vbatt(uint16_t vref_count) 
.................... { 
....................    /* Takes the voltage count as an input (summed from DAC) 
....................     * and outputs the battery integer and fractional as a single uint32_t 
....................     * It's output is (in binary) 00000000IIIIIIIIFFFFFFFFFFFFFFFF 
....................     * Where the first 8 bits are 0, the next 8 represent the integer 
....................     * part of the battery, and the next 16 are the fractional part 
....................     */ 
....................    uint32_t tempo_u32, frac_part; 
....................    uint16_t tempo_u16; 
....................     
....................    uint16_t    bat_frac_part;    // in units of .1mV 
....................    uint8_t     bat_int_part; 
....................     
....................    tempo_u32 = VAL32_FVR_BAT/vref_count;   // = 1 count in volts in 12.20 format 
*
0468E:  MOVFF  54F,566
04692:  MOVFF  54E,565
04696:  RCALL  44B8
04698:  MOVLW  9A
0469A:  MOVLB  5
0469C:  MOVWF  x68
0469E:  MOVLW  99
046A0:  MOVWF  x67
046A2:  MOVLW  19
046A4:  MOVWF  x66
046A6:  MOVLW  95
046A8:  MOVWF  x65
046AA:  MOVFF  03,56C
046AE:  MOVFF  02,56B
046B2:  MOVFF  01,56A
046B6:  MOVFF  00,569
046BA:  MOVLB  0
046BC:  RCALL  44EE
046BE:  MOVFF  03,568
046C2:  MOVFF  02,567
046C6:  MOVFF  01,566
046CA:  MOVFF  00,565
046CE:  RCALL  464C
046D0:  MOVFF  03,553
046D4:  MOVFF  02,552
046D8:  MOVFF  01,551
046DC:  MOVFF  00,550
046E0:  CLRF   19
046E2:  BTFSC  FF2.7
046E4:  BSF    19.7
046E6:  BCF    FF2.7
....................    tempo_u32 *= 1023;                        // bat voltage in 12.20 format 
046E8:  MOVFF  553,58C
046EC:  MOVFF  552,58B
046F0:  MOVFF  551,58A
046F4:  MOVFF  550,589
046F8:  MOVLB  5
046FA:  CLRF   x90
046FC:  CLRF   x8F
046FE:  MOVLW  03
04700:  MOVWF  x8E
04702:  SETF   x8D
04704:  MOVLB  0
04706:  CALL   1930
0470A:  BTFSC  19.7
0470C:  BSF    FF2.7
0470E:  MOVFF  03,553
04712:  MOVFF  02,552
04716:  MOVFF  01,551
0471A:  MOVFF  00,550
....................    tempo_u16 = (uint16_t)(tempo_u32 >> 8); 
0471E:  MOVFF  552,559
04722:  MOVFF  551,558
....................                                              // bat voltage in 4.12 format 
....................                                               
....................    //This stores the integer part shifted into the final result                                     
....................    bat_int_part = (uint8_t)(tempo_u16 >> 12);      // 2 or 3..... 
04726:  MOVLB  5
04728:  SWAPF  x59,W
0472A:  MOVWF  02
0472C:  MOVLW  0F
0472E:  ANDWF  02,F
04730:  MOVFF  02,55C
....................    frac_part = (uint32_t)(tempo_u16 & 0x0fff); 
04734:  MOVF   x59,W
04736:  ANDLW  0F
04738:  MOVFF  558,554
0473C:  MOVWF  x55
0473E:  CLRF   x56
04740:  CLRF   x57
04742:  CLRF   19
04744:  BTFSC  FF2.7
04746:  BSF    19.7
04748:  BCF    FF2.7
....................                                        // one count of frac_part is 1/4096 volt 
....................    tempo_u32 = (frac_part * 10000);    // 
0474A:  MOVFF  557,58C
0474E:  MOVFF  556,58B
04752:  MOVFF  555,58A
04756:  MOVFF  554,589
0475A:  CLRF   x90
0475C:  CLRF   x8F
0475E:  MOVLW  27
04760:  MOVWF  x8E
04762:  MOVLW  10
04764:  MOVWF  x8D
04766:  MOVLB  0
04768:  CALL   1930
0476C:  BTFSC  19.7
0476E:  BSF    FF2.7
04770:  MOVFF  03,553
04774:  MOVFF  02,552
04778:  MOVFF  01,551
0477C:  MOVFF  00,550
....................    tempo_u32 >>= 12; // divide by 4096. temp32 now = frac part (0 to 9999) 
04780:  MOVLB  5
04782:  MOVFF  551,550
04786:  MOVFF  552,551
0478A:  MOVFF  553,552
0478E:  CLRF   x53
04790:  RRCF   x53,F
04792:  RRCF   x52,F
04794:  RRCF   x51,F
04796:  RRCF   x50,F
04798:  RRCF   x53,F
0479A:  RRCF   x52,F
0479C:  RRCF   x51,F
0479E:  RRCF   x50,F
047A0:  RRCF   x53,F
047A2:  RRCF   x52,F
047A4:  RRCF   x51,F
047A6:  RRCF   x50,F
047A8:  RRCF   x53,F
047AA:  RRCF   x52,F
047AC:  RRCF   x51,F
047AE:  RRCF   x50,F
047B0:  MOVLW  0F
047B2:  ANDWF  x53,F
....................    bat_frac_part = (uint16_t)(tempo_u32); 
047B4:  MOVFF  551,55B
047B8:  MOVFF  550,55A
....................     
....................    return ((((uint32_t)bat_int_part) << 16) | (bat_frac_part)); 
047BC:  CLRF   x5E
047BE:  MOVFF  55E,03
047C2:  CLRF   x5D
047C4:  CLRF   x5E
047C6:  MOVF   x5D,W
047C8:  IORWF  x5A,W
047CA:  MOVWF  00
047CC:  MOVF   x5E,W
047CE:  IORWF  x5B,W
047D0:  MOVWF  01
047D2:  MOVFF  55C,02
047D6:  MOVLB  0
047D8:  GOTO   49F4 (RETURN)
....................    //return (uint32_t)bat_frac_part; 
.................... } 
....................  
.................... void check_and_deal_with_battery(void) 
.................... // checks the battery voltage (charging and not charging) and decides to turn on 
.................... // charger/off charger send a warning, or send a warning and shutdown. 
.................... { 
....................    uint16_t batt_chrg, batt_no_chrg; 
....................     
....................    // if the valve is not moving (otherwise, abort) 
....................    if (IS_VLV_COASTING) 
*
08942:  MOVF   F8D,F
08944:  BTFSS  FD8.2
08946:  BRA    8A58
....................    { 
....................       // grab a fresh battery reading 
....................       batt_chrg = get_vbatt(0); 
08948:  MOVLB  5
0894A:  CLRF   x53
0894C:  MOVLB  0
0894E:  CALL   3F5E
08952:  MOVFF  02,548
08956:  MOVFF  01,547
....................       batt_no_chrg = get_vbatt(1); 
0895A:  MOVLW  01
0895C:  MOVLB  5
0895E:  MOVWF  x53
08960:  MOVLB  0
08962:  CALL   3F5E
08966:  MOVFF  02,54A
0896A:  MOVFF  01,549
....................        
....................       // if the battery is dead and system needs to be shutdown 
....................       if (batt_no_chrg > BATTERY_DEAD) 
0896E:  MOVLB  5
08970:  MOVF   x4A,W
08972:  SUBLW  05
08974:  BC    89EA
08976:  XORLW  FF
08978:  BNZ   8980
0897A:  MOVF   x49,W
0897C:  SUBLW  65
0897E:  BC    89EA
....................       { 
....................          global_control_loop_mechanism = BRAKE_AND_CHARGE_START; 
08980:  MOVLB  0
08982:  CLRF   xB8
....................          // set the error bitfield and message 
....................          global_error_message_bitfield |= ERR_MSG_BATT_DEAD_SLEEP; 
08984:  MOVLB  4
08986:  BSF    xF1.0
....................          PUSH_MESSAGE_QUEUE_MACRO(MSG_MOTE_ERROR_MSG); 
08988:  BCF    F7A.1
0898A:  MOVLW  A0
0898C:  MOVLB  5
0898E:  MOVWF  x50
08990:  MOVLB  0
08992:  CALL   4D00
08996:  BSF    F7A.1
....................          // set the shutdown message and schedule a shutdown 
....................          global_shutdown_cause = ERR_BATT_DEAD_SLEEP;  
08998:  MOVLW  0C
0899A:  MOVWF  4D
....................          PUSH_PRIORITY_QUEUE(OPEN_VALVE_UNKNOWN_STATE);   
0899C:  MOVLW  3E
0899E:  MOVLB  5
089A0:  MOVWF  x50
089A2:  MOVLB  0
089A4:  CALL   43F2
....................          PUSH_TIME_QUEUE(global_rtc_time + 10, SHUTDOWN_SYSTEM);   
089A8:  MOVLW  0A
089AA:  ADDWF  x85,W
089AC:  MOVLB  5
089AE:  MOVWF  x4B
089B0:  MOVLW  00
089B2:  MOVLB  0
089B4:  ADDWFC x86,W
089B6:  MOVLB  5
089B8:  MOVWF  x4C
089BA:  MOVLW  00
089BC:  MOVLB  0
089BE:  ADDWFC x87,W
089C0:  MOVLB  5
089C2:  MOVWF  x4D
089C4:  MOVLW  00
089C6:  MOVLB  0
089C8:  ADDWFC x88,W
089CA:  MOVLB  5
089CC:  MOVWF  x4E
089CE:  MOVWF  x55
089D0:  MOVFF  54D,554
089D4:  MOVFF  54C,553
089D8:  MOVFF  54B,552
089DC:  MOVLW  F1
089DE:  MOVWF  x56
089E0:  MOVLB  0
089E2:  CALL   414A
....................       } 
089E6:  BRA    8A58
089E8:  MOVLB  5
....................       // if the battery is almost dead and the manager needs a warning 
....................       else if (batt_no_chrg > BATTERY_WARN) 
089EA:  MOVF   x4A,W
089EC:  SUBLW  05
089EE:  BC    8A16
089F0:  XORLW  FF
089F2:  BNZ   89FA
089F4:  MOVF   x49,W
089F6:  SUBLW  30
089F8:  BC    8A16
....................       { 
....................          global_control_loop_mechanism = BRAKE_AND_CHARGE_START; 
089FA:  MOVLB  0
089FC:  CLRF   xB8
....................          // set the error bitfield and message 
....................          global_error_message_bitfield |= ERR_MSG_BATT_LOW_WARN; 
089FE:  MOVLB  4
08A00:  BSF    xF0.7
....................          PUSH_MESSAGE_QUEUE_MACRO(MSG_MOTE_ERROR_MSG); 
08A02:  BCF    F7A.1
08A04:  MOVLW  A0
08A06:  MOVLB  5
08A08:  MOVWF  x50
08A0A:  MOVLB  0
08A0C:  CALL   4D00
08A10:  BSF    F7A.1
....................       } 
08A12:  BRA    8A58
08A14:  MOVLB  5
....................       // if the battery charging needs to be turned off (is in brake + charge control) 
....................       else if ((batt_chrg < BATTERY_STOP_CHARGING) &&                              \ 
....................          (global_control_loop_mechanism == BRAKE_AND_CHARGE)) 
08A16:  MOVF   x48,W
08A18:  SUBLW  05
08A1A:  BNC   8A38
08A1C:  BNZ   8A24
08A1E:  MOVF   x47,W
08A20:  SUBLW  79
08A22:  BNC   8A38
08A24:  MOVLB  0
08A26:  DECFSZ xB8,W
08A28:  BRA    8A2C
08A2A:  BRA    8A30
08A2C:  MOVLB  5
08A2E:  BRA    8A38
....................       { 
....................          global_control_loop_mechanism = BRAKE_ONLY; 
08A30:  MOVLW  02
08A32:  MOVWF  xB8
....................       } 
08A34:  BRA    8A58
08A36:  MOVLB  5
....................       // if the battery charging needs to be turned on (is in brake only control) 
....................       else if ((batt_no_chrg > BATTERY_START_CHARGING) &&                     \ 
....................          (global_control_loop_mechanism == BRAKE_ONLY)) 
08A38:  MOVF   x4A,W
08A3A:  SUBLW  04
08A3C:  BC    8A5A
08A3E:  XORLW  FF
08A40:  BNZ   8A48
08A42:  MOVF   x49,W
08A44:  SUBLW  D2
08A46:  BC    8A5A
08A48:  MOVLB  0
08A4A:  MOVF   xB8,W
08A4C:  SUBLW  02
08A4E:  BTFSC  FD8.2
08A50:  BRA    8A56
08A52:  MOVLB  5
08A54:  BRA    8A5A
....................       { 
....................          global_control_loop_mechanism = BRAKE_AND_CHARGE_START; 
08A56:  CLRF   xB8
08A58:  MOVLB  5
....................       } 
....................    } 
08A5A:  MOVLB  0
08A5C:  GOTO   A492 (RETURN)
.................... } 
....................           
....................  
....................  
....................  
....................  
.................... #include "stacks_queues.h"   
.................... void clear_priority_queue() 
.................... { 
....................    uint8_t n; 
....................     
....................    for (n = 0; n < MAX_PRIORITY_QUEUE_ITEMS; n++) 
*
03E6A:  MOVLB  5
03E6C:  CLRF   x47
03E6E:  MOVF   x47,W
03E70:  SUBLW  13
03E72:  BNC   3E88
....................    { 
....................       global_priority_queue[n] = EMPTY_PRIORITY_QUEUE; 
03E74:  CLRF   03
03E76:  MOVF   x47,W
03E78:  ADDLW  66
03E7A:  MOVWF  FE9
03E7C:  MOVLW  03
03E7E:  ADDWFC 03,W
03E80:  MOVWF  FEA
03E82:  CLRF   FEF
03E84:  INCF   x47,F
03E86:  BRA    3E6E
....................    } 
03E88:  MOVLB  0
03E8A:  GOTO   98EE (RETURN)
.................... } 
....................  
.................... uint8_t pop_priority_queue() 
.................... // Checks the priority queue and returns the current item to execute 
.................... { 
....................    uint8_t priority_queue_command_to_execute; 
....................     
....................    //no items in the queue (current location is 0-1) 
....................    if (global_current_priority_queue_location == 255) 
*
0598C:  MOVLB  3
0598E:  INCFSZ x7A,W
05990:  BRA    599A
....................    { 
....................       return EMPTY_PRIORITY_QUEUE; 
05992:  MOVLW  00
05994:  MOVWF  01
05996:  BRA    59C4
....................    } 
05998:  BRA    59C4
....................    else 
....................    { 
....................       //save the current command to execute 
....................       priority_queue_command_to_execute = global_priority_queue[global_current_priority_queue_location]; 
0599A:  CLRF   03
0599C:  MOVF   x7A,W
0599E:  ADDLW  66
059A0:  MOVWF  FE9
059A2:  MOVLW  03
059A4:  ADDWFC 03,W
059A6:  MOVWF  FEA
059A8:  MOVFF  FEF,547
....................       //erase the current command and decrement the current queue location 
....................       global_priority_queue[global_current_priority_queue_location] = 0; 
059AC:  CLRF   03
059AE:  MOVF   x7A,W
059B0:  ADDLW  66
059B2:  MOVWF  FE9
059B4:  MOVLW  03
059B6:  ADDWFC 03,W
059B8:  MOVWF  FEA
059BA:  CLRF   FEF
....................       global_current_priority_queue_location--; 
059BC:  DECF   x7A,F
....................       //return the command to execute 
....................       return priority_queue_command_to_execute; 
059BE:  MOVFF  547,01
059C2:  MOVLB  3
....................    } 
059C4:  MOVLB  0
059C6:  GOTO   9A62 (RETURN)
.................... } 
....................  
.................... int1 push_priority_queue(uint8_t new_priority_queue_item) 
.................... // pushes a new item into the priority queue and sorts it. 
.................... // returns 1 if everything is good, 0 if queue is full 
.................... { 
....................    uint8_t n; 
....................    
....................    //if queue is full, return 0 
....................    if (global_current_priority_queue_location == (MAX_PRIORITY_QUEUE_ITEMS - 1)) 
*
043F2:  MOVLB  3
043F4:  MOVF   x7A,W
043F6:  SUBLW  13
043F8:  BNZ   4400
....................    { 
....................       return 0; 
043FA:  MOVLW  00
043FC:  MOVWF  01
043FE:  BRA    44B4
....................    } 
....................     
....................    //increment the queue location and 
....................    //set the new item at the top of the queue (will be sorted in a sec) 
....................    global_current_priority_queue_location++; 
04400:  INCF   x7A,F
....................    global_priority_queue[global_current_priority_queue_location] = new_priority_queue_item; 
04402:  CLRF   03
04404:  MOVF   x7A,W
04406:  ADDLW  66
04408:  MOVWF  FE9
0440A:  MOVLW  03
0440C:  ADDWFC 03,W
0440E:  MOVWF  FEA
04410:  MOVFF  550,FEF
....................     
....................    //starting at the new current queue location, sort through the queue 
....................    //until the new item is in the right place 
....................    for (n = global_current_priority_queue_location; n > 0; n--) 
04414:  MOVFF  37A,551
04418:  MOVLB  5
0441A:  MOVF   x51,F
0441C:  BZ    44AE
....................    { 
....................       //if queue items are not sorted properly 
....................       if (global_priority_queue[n] > global_priority_queue[n-1]) 
0441E:  CLRF   03
04420:  MOVF   x51,W
04422:  ADDLW  66
04424:  MOVWF  FE9
04426:  MOVLW  03
04428:  ADDWFC 03,W
0442A:  MOVWF  FEA
0442C:  MOVFF  FEF,552
04430:  MOVLW  01
04432:  SUBWF  x51,W
04434:  CLRF   03
04436:  ADDLW  66
04438:  MOVWF  FE9
0443A:  MOVLW  03
0443C:  ADDWFC 03,W
0443E:  MOVWF  FEA
04440:  MOVF   FEF,W
04442:  SUBWF  x52,W
04444:  BZ    44A0
04446:  BNC   44A0
....................       { 
....................          //do a swap reusing new queue item variable as a temp 
....................          new_priority_queue_item = global_priority_queue[n]; 
04448:  CLRF   03
0444A:  MOVF   x51,W
0444C:  ADDLW  66
0444E:  MOVWF  FE9
04450:  MOVLW  03
04452:  ADDWFC 03,W
04454:  MOVWF  FEA
04456:  MOVFF  FEF,550
....................          global_priority_queue[n] = global_priority_queue[n-1]; 
0445A:  CLRF   03
0445C:  MOVF   x51,W
0445E:  ADDLW  66
04460:  MOVWF  01
04462:  MOVLW  03
04464:  ADDWFC 03,F
04466:  MOVFF  03,553
0446A:  MOVLW  01
0446C:  SUBWF  x51,W
0446E:  CLRF   03
04470:  ADDLW  66
04472:  MOVWF  FE9
04474:  MOVLW  03
04476:  ADDWFC 03,W
04478:  MOVWF  FEA
0447A:  MOVFF  FEF,554
0447E:  MOVFF  553,FEA
04482:  MOVFF  01,FE9
04486:  MOVFF  554,FEF
....................          global_priority_queue[n-1] = new_priority_queue_item; 
0448A:  MOVLW  01
0448C:  SUBWF  x51,W
0448E:  CLRF   03
04490:  ADDLW  66
04492:  MOVWF  FE9
04494:  MOVLW  03
04496:  ADDWFC 03,W
04498:  MOVWF  FEA
0449A:  MOVFF  550,FEF
....................       } 
0449E:  BRA    44AA
....................       //item is in the proper place (assuming queue always sorted properly) 
....................       else 
....................       { 
....................          return 1; 
044A0:  MOVLW  01
044A2:  MOVWF  01
044A4:  MOVLB  3
044A6:  BRA    44B4
044A8:  MOVLB  5
....................       } 
044AA:  DECF   x51,F
044AC:  BRA    441A
....................    } 
....................    return 1; 
044AE:  MOVLW  01
044B0:  MOVWF  01
044B2:  MOVLB  3
044B4:  MOVLB  0
044B6:  RETURN 0
.................... } 
....................  
.................... void push_priority_queue_ISR(uint8_t new_priority_queue_item) 
.................... // pushes a new item into the priority queue and sorts it. 
.................... // returns 1 if everything is good, 0 if queue is full 
.................... { 
....................    uint8_t n; 
....................    
....................    //if queue is full, return 0 
....................    if (global_current_priority_queue_location == (MAX_PRIORITY_QUEUE_ITEMS - 1)) 
*
007D0:  MOVLB  3
007D2:  MOVF   x7A,W
007D4:  SUBLW  13
007D6:  BNZ   07DA
....................    { 
....................       return; 
007D8:  BRA    087E
....................    } 
....................     
....................    //increment the queue location and 
....................    //set the new item at the top of the queue (will be sorted in a sec) 
....................    global_current_priority_queue_location++; 
007DA:  INCF   x7A,F
....................    global_priority_queue[global_current_priority_queue_location] = new_priority_queue_item; 
007DC:  CLRF   03
007DE:  MOVF   x7A,W
007E0:  ADDLW  66
007E2:  MOVWF  FE9
007E4:  MOVLW  03
007E6:  ADDWFC 03,W
007E8:  MOVWF  FEA
007EA:  MOVFF  59B,FEF
....................     
....................    //starting at the new current queue location, sort through the queue 
....................    //until the new item is in the right place 
....................    for (n = global_current_priority_queue_location; n > 0; n--) 
007EE:  MOVFF  37A,59C
007F2:  MOVLB  5
007F4:  MOVF   x9C,F
007F6:  BZ    087C
....................    { 
....................       //if queue items are not sorted properly 
....................       if (global_priority_queue[n] > global_priority_queue[n-1]) 
007F8:  CLRF   03
007FA:  MOVF   x9C,W
007FC:  ADDLW  66
007FE:  MOVWF  FE9
00800:  MOVLW  03
00802:  ADDWFC 03,W
00804:  MOVWF  FEA
00806:  MOVFF  FEF,59D
0080A:  MOVLW  01
0080C:  SUBWF  x9C,W
0080E:  CLRF   03
00810:  ADDLW  66
00812:  MOVWF  FE9
00814:  MOVLW  03
00816:  ADDWFC 03,W
00818:  MOVWF  FEA
0081A:  MOVF   FEF,W
0081C:  SUBWF  x9D,W
0081E:  BZ    0878
00820:  BNC   0878
....................       { 
....................          //do a swap reusing new queue item variable as a temp 
....................          new_priority_queue_item = global_priority_queue[n]; 
00822:  CLRF   03
00824:  MOVF   x9C,W
00826:  ADDLW  66
00828:  MOVWF  FE9
0082A:  MOVLW  03
0082C:  ADDWFC 03,W
0082E:  MOVWF  FEA
00830:  MOVFF  FEF,59B
....................          global_priority_queue[n] = global_priority_queue[n-1]; 
00834:  CLRF   03
00836:  MOVF   x9C,W
00838:  ADDLW  66
0083A:  MOVWF  01
0083C:  MOVLW  03
0083E:  ADDWFC 03,F
00840:  MOVFF  03,59E
00844:  MOVLW  01
00846:  SUBWF  x9C,W
00848:  CLRF   03
0084A:  ADDLW  66
0084C:  MOVWF  FE9
0084E:  MOVLW  03
00850:  ADDWFC 03,W
00852:  MOVWF  FEA
00854:  MOVFF  FEF,59F
00858:  MOVFF  59E,FEA
0085C:  MOVFF  01,FE9
00860:  MOVFF  59F,FEF
....................          global_priority_queue[n-1] = new_priority_queue_item; 
00864:  MOVLW  01
00866:  SUBWF  x9C,W
00868:  CLRF   03
0086A:  ADDLW  66
0086C:  MOVWF  FE9
0086E:  MOVLW  03
00870:  ADDWFC 03,W
00872:  MOVWF  FEA
00874:  MOVFF  59B,FEF
....................       } 
00878:  DECF   x9C,F
0087A:  BRA    07F4
0087C:  MOVLB  3
....................    } 
....................    return;  
0087E:  MOVLB  0
00880:  RETURN 0
.................... } 
....................  
.................... void clear_time_queue() 
.................... { 
....................    uint8_t n; 
....................     
....................    for (n = 0; n < MAX_TIME_QUEUE_ITEMS; n++) 
*
03E8E:  MOVLB  5
03E90:  CLRF   x47
03E92:  MOVF   x47,W
03E94:  SUBLW  04
03E96:  BNC   3EE8
....................    { 
....................       global_time_queue[n].pq_priority = 0; 
03E98:  MOVF   x47,W
03E9A:  MULLW  05
03E9C:  MOVF   FF3,W
03E9E:  CLRF   x49
03EA0:  MOVWF  x48
03EA2:  MOVLW  04
03EA4:  ADDWF  x48,W
03EA6:  MOVWF  01
03EA8:  MOVLW  00
03EAA:  ADDWFC x49,W
03EAC:  MOVWF  03
03EAE:  MOVF   01,W
03EB0:  ADDLW  7B
03EB2:  MOVWF  FE9
03EB4:  MOVLW  03
03EB6:  ADDWFC 03,W
03EB8:  MOVWF  FEA
03EBA:  CLRF   FEF
....................       global_time_queue[n].time_to_execute = 0; 
03EBC:  MOVF   x47,W
03EBE:  MULLW  05
03EC0:  MOVF   FF3,W
03EC2:  CLRF   x49
03EC4:  MOVWF  x48
03EC6:  MOVLW  7B
03EC8:  ADDWF  x48,W
03ECA:  MOVWF  FE9
03ECC:  MOVLW  03
03ECE:  ADDWFC x49,W
03ED0:  MOVWF  FEA
03ED2:  MOVF   FEE,F
03ED4:  MOVF   FEE,F
03ED6:  CLRF   FEC
03ED8:  MOVF   FED,F
03EDA:  CLRF   FEF
03EDC:  MOVF   FED,F
03EDE:  CLRF   FEF
03EE0:  MOVF   FED,F
03EE2:  CLRF   FEF
03EE4:  INCF   x47,F
03EE6:  BRA    3E92
....................    } 
03EE8:  MOVLB  0
03EEA:  GOTO   98F2 (RETURN)
.................... } 
....................  
.................... int1 pop_time_queue() 
.................... // Checks the time queue and sends the item to execute to the priority queue 
.................... { 
....................    struct TimeQueueItem time_queue_command_to_execute; 
....................     
....................    //no items in the queue (current location is 0-1) 
....................    if (global_current_time_queue_location == (0-1)) 
....................    { 
....................       return EMPTY_TIME_QUEUE; 
....................    } 
....................    else 
....................    { 
....................       //save the current command to execute 
....................       time_queue_command_to_execute.pq_priority = global_time_queue[global_current_time_queue_location].pq_priority; 
....................        
....................       //erase the current command and decrement the current queue location 
....................       global_time_queue[global_current_time_queue_location].pq_priority = 0; 
....................       global_time_queue[global_current_time_queue_location].time_to_execute = 0; 
....................       global_current_time_queue_location--; 
....................        
....................       //send queue item to the priority queue and return the result from adding it to the PQ 
....................       return push_priority_queue(time_queue_command_to_execute.pq_priority); 
....................    } 
.................... } 
....................  
.................... void pop_time_queue_ISR() 
.................... // Checks the time queue and sends the item to execute to the priority queue 
.................... { 
....................    uint8_t priority; 
....................     
....................    //no items in the queue (current location is 0-1) 
....................    if (global_current_time_queue_location == 255) 
*
0203A:  MOVLB  3
0203C:  INCFSZ x94,W
0203E:  BRA    2044
....................    { 
....................       return; 
02040:  BRA    20D0
....................    } 
02042:  BRA    20D0
....................    else 
....................    { 
....................       //save the current command to execute 
....................       priority = global_time_queue[global_current_time_queue_location].pq_priority; 
02044:  MOVF   x94,W
02046:  MULLW  05
02048:  MOVF   FF3,W
0204A:  MOVLB  5
0204C:  CLRF   x81
0204E:  MOVWF  x80
02050:  MOVLW  04
02052:  ADDWF  x80,W
02054:  MOVWF  01
02056:  MOVLW  00
02058:  ADDWFC x81,W
0205A:  MOVWF  03
0205C:  MOVF   01,W
0205E:  ADDLW  7B
02060:  MOVWF  FE9
02062:  MOVLW  03
02064:  ADDWFC 03,W
02066:  MOVWF  FEA
02068:  MOVFF  FEF,57F
....................        
....................       //erase the current command and decrement the current queue location 
....................       global_time_queue[global_current_time_queue_location].pq_priority = 0; 
0206C:  MOVLB  3
0206E:  MOVF   x94,W
02070:  MULLW  05
02072:  MOVF   FF3,W
02074:  MOVLB  5
02076:  CLRF   x81
02078:  MOVWF  x80
0207A:  MOVLW  04
0207C:  ADDWF  x80,W
0207E:  MOVWF  01
02080:  MOVLW  00
02082:  ADDWFC x81,W
02084:  MOVWF  03
02086:  MOVF   01,W
02088:  ADDLW  7B
0208A:  MOVWF  FE9
0208C:  MOVLW  03
0208E:  ADDWFC 03,W
02090:  MOVWF  FEA
02092:  CLRF   FEF
....................       global_time_queue[global_current_time_queue_location].time_to_execute = 0; 
02094:  MOVLB  3
02096:  MOVF   x94,W
02098:  MULLW  05
0209A:  MOVF   FF3,W
0209C:  MOVLB  5
0209E:  CLRF   x81
020A0:  MOVWF  x80
020A2:  MOVLW  7B
020A4:  ADDWF  x80,W
020A6:  MOVWF  FE9
020A8:  MOVLW  03
020AA:  ADDWFC x81,W
020AC:  MOVWF  FEA
020AE:  MOVF   FEE,F
020B0:  MOVF   FEE,F
020B2:  CLRF   FEC
020B4:  MOVF   FED,F
020B6:  CLRF   FEF
020B8:  MOVF   FED,F
020BA:  CLRF   FEF
020BC:  MOVF   FED,F
020BE:  CLRF   FEF
....................       global_current_time_queue_location--; 
020C0:  MOVLB  3
020C2:  DECF   x94,F
....................        
....................       //send queue item to the priority queue and return the result from adding it to the PQ 
....................       push_priority_queue_ISR(priority); 
020C4:  MOVFF  57F,59B
020C8:  MOVLB  0
020CA:  CALL   07D0
....................       return; 
020CE:  MOVLB  3
....................    } 
020D0:  MOVLB  0
020D2:  GOTO   2D16 (RETURN)
.................... } 
....................  
.................... int1 push_time_queue(uint32_t time_to_execute, uint8_t priority) 
.................... // pushes a new item into the time queue and sorts it (by time). 
.................... // returns 1 if everything is good, 0 if queue is full 
.................... { 
....................    uint8_t n; 
....................       
....................    //if queue is full, return 0 
....................    if (global_current_time_queue_location == (MAX_TIME_QUEUE_ITEMS - 1)) 
*
0414A:  MOVLB  3
0414C:  MOVF   x94,W
0414E:  SUBLW  04
04150:  BNZ   4158
....................    { 
....................       return 0; 
04152:  MOVLW  00
04154:  MOVWF  01
04156:  BRA    4394
....................    } 
....................     
....................    // increment the time queue location and 
....................    // set the new item at the top of the queue (will be sorted in a sec) 
....................    global_current_time_queue_location++; 
04158:  INCF   x94,F
....................    global_time_queue[global_current_time_queue_location].pq_priority = priority; 
0415A:  MOVF   x94,W
0415C:  MULLW  05
0415E:  MOVF   FF3,W
04160:  MOVLB  5
04162:  CLRF   x59
04164:  MOVWF  x58
04166:  MOVLW  04
04168:  ADDWF  x58,W
0416A:  MOVWF  01
0416C:  MOVLW  00
0416E:  ADDWFC x59,W
04170:  MOVWF  03
04172:  MOVF   01,W
04174:  ADDLW  7B
04176:  MOVWF  FE9
04178:  MOVLW  03
0417A:  ADDWFC 03,W
0417C:  MOVWF  FEA
0417E:  MOVFF  556,FEF
....................    global_time_queue[global_current_time_queue_location].time_to_execute = time_to_execute; 
04182:  MOVLB  3
04184:  MOVF   x94,W
04186:  MULLW  05
04188:  MOVF   FF3,W
0418A:  MOVLB  5
0418C:  CLRF   x59
0418E:  MOVWF  x58
04190:  MOVLW  7B
04192:  ADDWF  x58,W
04194:  MOVWF  FE9
04196:  MOVLW  03
04198:  ADDWFC x59,W
0419A:  MOVWF  FEA
0419C:  MOVFF  552,FEF
041A0:  MOVFF  553,FEC
041A4:  MOVFF  554,FEC
041A8:  MOVFF  555,FEC
....................     
....................    //starting at the new current queue location, sort through the queue 
....................    //until the new item is in the right place 
....................    for (n = global_current_time_queue_location; n > 0; n--) 
041AC:  MOVFF  394,557
041B0:  MOVF   x57,F
041B2:  BTFSC  FD8.2
041B4:  BRA    438E
....................    { 
....................       //if queue items are not sorted properly 
....................       if (global_time_queue[n].time_to_execute > global_time_queue[n-1].time_to_execute) 
041B6:  MOVF   x57,W
041B8:  MULLW  05
041BA:  MOVF   FF3,W
041BC:  CLRF   x59
041BE:  MOVWF  x58
041C0:  MOVLW  7B
041C2:  ADDWF  x58,W
041C4:  MOVWF  FE9
041C6:  MOVLW  03
041C8:  ADDWFC x59,W
041CA:  MOVWF  FEA
041CC:  MOVFF  FEF,55A
041D0:  MOVFF  FEC,55B
041D4:  MOVFF  FEC,55C
041D8:  MOVFF  FEC,55D
041DC:  MOVLW  01
041DE:  SUBWF  x57,W
041E0:  MULLW  05
041E2:  MOVF   FF3,W
041E4:  CLRF   x5F
041E6:  MOVWF  x5E
041E8:  MOVLW  7B
041EA:  ADDWF  x5E,W
041EC:  MOVWF  FE9
041EE:  MOVLW  03
041F0:  ADDWFC x5F,W
041F2:  MOVWF  FEA
041F4:  MOVFF  FEF,00
041F8:  MOVFF  FEC,01
041FC:  MOVFF  FEC,02
04200:  MOVFF  FEC,03
04204:  MOVF   03,W
04206:  SUBWF  x5D,W
04208:  BTFSS  FD8.0
0420A:  BRA    4380
0420C:  BNZ   422A
0420E:  MOVF   02,W
04210:  SUBWF  x5C,W
04212:  BTFSS  FD8.0
04214:  BRA    4380
04216:  BNZ   422A
04218:  MOVF   01,W
0421A:  SUBWF  x5B,W
0421C:  BTFSS  FD8.0
0421E:  BRA    4380
04220:  BNZ   422A
04222:  MOVF   x5A,W
04224:  SUBWF  00,W
04226:  BTFSC  FD8.0
04228:  BRA    4380
....................       { 
....................          //do a swap reusing new queue item variable as a temp 
....................          priority = global_time_queue[n].pq_priority; 
0422A:  MOVF   x57,W
0422C:  MULLW  05
0422E:  MOVF   FF3,W
04230:  CLRF   x59
04232:  MOVWF  x58
04234:  MOVLW  04
04236:  ADDWF  x58,W
04238:  MOVWF  01
0423A:  MOVLW  00
0423C:  ADDWFC x59,W
0423E:  MOVWF  03
04240:  MOVF   01,W
04242:  ADDLW  7B
04244:  MOVWF  FE9
04246:  MOVLW  03
04248:  ADDWFC 03,W
0424A:  MOVWF  FEA
0424C:  MOVFF  FEF,556
....................          global_time_queue[n].pq_priority = global_time_queue[n-1].pq_priority; 
04250:  MOVF   x57,W
04252:  MULLW  05
04254:  MOVF   FF3,W
04256:  CLRF   x59
04258:  MOVWF  x58
0425A:  MOVLW  04
0425C:  ADDWF  x58,W
0425E:  MOVWF  01
04260:  MOVLW  00
04262:  ADDWFC x59,W
04264:  MOVWF  03
04266:  MOVF   01,W
04268:  ADDLW  7B
0426A:  MOVWF  01
0426C:  MOVLW  03
0426E:  ADDWFC 03,F
04270:  MOVFF  01,558
04274:  MOVFF  03,559
04278:  MOVLW  01
0427A:  SUBWF  x57,W
0427C:  MULLW  05
0427E:  MOVF   FF3,W
04280:  CLRF   x5B
04282:  MOVWF  x5A
04284:  MOVLW  04
04286:  ADDWF  x5A,W
04288:  MOVWF  01
0428A:  MOVLW  00
0428C:  ADDWFC x5B,W
0428E:  MOVWF  03
04290:  MOVF   01,W
04292:  ADDLW  7B
04294:  MOVWF  FE9
04296:  MOVLW  03
04298:  ADDWFC 03,W
0429A:  MOVWF  FEA
0429C:  MOVFF  FEF,55A
042A0:  MOVFF  559,FEA
042A4:  MOVFF  558,FE9
042A8:  MOVFF  55A,FEF
....................          global_time_queue[n-1].pq_priority = priority; 
042AC:  MOVLW  01
042AE:  SUBWF  x57,W
042B0:  MULLW  05
042B2:  MOVF   FF3,W
042B4:  CLRF   x59
042B6:  MOVWF  x58
042B8:  MOVLW  04
042BA:  ADDWF  x58,W
042BC:  MOVWF  01
042BE:  MOVLW  00
042C0:  ADDWFC x59,W
042C2:  MOVWF  03
042C4:  MOVF   01,W
042C6:  ADDLW  7B
042C8:  MOVWF  FE9
042CA:  MOVLW  03
042CC:  ADDWFC 03,W
042CE:  MOVWF  FEA
042D0:  MOVFF  556,FEF
....................          time_to_execute = global_time_queue[n].time_to_execute; 
042D4:  MOVF   x57,W
042D6:  MULLW  05
042D8:  MOVF   FF3,W
042DA:  CLRF   x59
042DC:  MOVWF  x58
042DE:  MOVLW  7B
042E0:  ADDWF  x58,W
042E2:  MOVWF  FE9
042E4:  MOVLW  03
042E6:  ADDWFC x59,W
042E8:  MOVWF  FEA
042EA:  MOVFF  FEF,552
042EE:  MOVFF  FEC,553
042F2:  MOVFF  FEC,554
042F6:  MOVFF  FEC,555
....................          global_time_queue[n].time_to_execute = global_time_queue[n-1].time_to_execute; 
042FA:  MOVF   x57,W
042FC:  MULLW  05
042FE:  MOVF   FF3,W
04300:  CLRF   x59
04302:  MOVWF  x58
04304:  MOVLW  7B
04306:  ADDWF  x58,W
04308:  MOVWF  01
0430A:  MOVLW  03
0430C:  ADDWFC x59,W
0430E:  MOVWF  03
04310:  MOVFF  01,55A
04314:  MOVWF  x5B
04316:  MOVLW  01
04318:  SUBWF  x57,W
0431A:  MULLW  05
0431C:  MOVF   FF3,W
0431E:  CLRF   x5D
04320:  MOVWF  x5C
04322:  MOVLW  7B
04324:  ADDWF  x5C,W
04326:  MOVWF  FE9
04328:  MOVLW  03
0432A:  ADDWFC x5D,W
0432C:  MOVWF  FEA
0432E:  MOVFF  FEF,00
04332:  MOVFF  FEC,01
04336:  MOVFF  FEC,02
0433A:  MOVFF  FEC,03
0433E:  MOVFF  55B,FEA
04342:  MOVFF  55A,FE9
04346:  MOVFF  00,FEF
0434A:  MOVFF  01,FEC
0434E:  MOVFF  02,FEC
04352:  MOVFF  03,FEC
....................          global_time_queue[n-1].time_to_execute = time_to_execute; 
04356:  MOVLW  01
04358:  SUBWF  x57,W
0435A:  MULLW  05
0435C:  MOVF   FF3,W
0435E:  CLRF   x59
04360:  MOVWF  x58
04362:  MOVLW  7B
04364:  ADDWF  x58,W
04366:  MOVWF  FE9
04368:  MOVLW  03
0436A:  ADDWFC x59,W
0436C:  MOVWF  FEA
0436E:  MOVFF  552,FEF
04372:  MOVFF  553,FEC
04376:  MOVFF  554,FEC
0437A:  MOVFF  555,FEC
....................           
....................       } 
0437E:  BRA    438A
....................       //item is in the proper place (assuming queue always sorted properly) 
....................       else 
....................       { 
....................          return 1; 
04380:  MOVLW  01
04382:  MOVWF  01
04384:  MOVLB  3
04386:  BRA    4394
04388:  MOVLB  5
....................       } 
0438A:  DECF   x57,F
0438C:  BRA    41B0
....................    } 
....................    return 1; 
0438E:  MOVLW  01
04390:  MOVWF  01
04392:  MOVLB  3
04394:  MOVLB  0
04396:  RETURN 0
.................... } 
....................  
.................... void push_time_queue_ISR(uint32_t time_to_execute, uint8_t priority) 
.................... // pushes a new item into the time queue and sorts it (by time). 
.................... // returns 1 if everything is good, 0 if queue is full 
.................... { 
....................    uint8_t n; 
....................       
....................    //if queue is full, return 0 
....................    if (global_current_time_queue_location == (MAX_TIME_QUEUE_ITEMS - 1)) 
*
016F6:  MOVLB  3
016F8:  MOVF   x94,W
016FA:  SUBLW  04
016FC:  BNZ   1700
....................    { 
....................       return; 
016FE:  BRA    192C
....................    } 
....................     
....................    // increment the time queue location and 
....................    // set the new item at the top of the queue (will be sorted in a sec) 
....................    global_current_time_queue_location++; 
01700:  INCF   x94,F
....................    global_time_queue[global_current_time_queue_location].pq_priority = priority; 
01702:  MOVF   x94,W
01704:  MULLW  05
01706:  MOVF   FF3,W
01708:  MOVLB  5
0170A:  CLRF   xBE
0170C:  MOVWF  xBD
0170E:  MOVLW  04
01710:  ADDWF  xBD,W
01712:  MOVWF  01
01714:  MOVLW  00
01716:  ADDWFC xBE,W
01718:  MOVWF  03
0171A:  MOVF   01,W
0171C:  ADDLW  7B
0171E:  MOVWF  FE9
01720:  MOVLW  03
01722:  ADDWFC 03,W
01724:  MOVWF  FEA
01726:  MOVFF  5BB,FEF
....................    global_time_queue[global_current_time_queue_location].time_to_execute = time_to_execute; 
0172A:  MOVLB  3
0172C:  MOVF   x94,W
0172E:  MULLW  05
01730:  MOVF   FF3,W
01732:  MOVLB  5
01734:  CLRF   xBE
01736:  MOVWF  xBD
01738:  MOVLW  7B
0173A:  ADDWF  xBD,W
0173C:  MOVWF  FE9
0173E:  MOVLW  03
01740:  ADDWFC xBE,W
01742:  MOVWF  FEA
01744:  MOVFF  5B7,FEF
01748:  MOVFF  5B8,FEC
0174C:  MOVFF  5B9,FEC
01750:  MOVFF  5BA,FEC
....................        
....................    //starting at the new current queue location, sort through the queue 
....................    //until the new item is in the right place 
....................    for (n = global_current_time_queue_location; n > 0; n--) 
01754:  MOVFF  394,5BC
01758:  MOVF   xBC,F
0175A:  BTFSC  FD8.2
0175C:  BRA    192A
....................    { 
....................       //if queue items are not sorted properly 
....................       if (global_time_queue[n].time_to_execute > global_time_queue[n-1].time_to_execute) 
0175E:  MOVF   xBC,W
01760:  MULLW  05
01762:  MOVF   FF3,W
01764:  CLRF   xBE
01766:  MOVWF  xBD
01768:  MOVLW  7B
0176A:  ADDWF  xBD,W
0176C:  MOVWF  FE9
0176E:  MOVLW  03
01770:  ADDWFC xBE,W
01772:  MOVWF  FEA
01774:  MOVFF  FEF,5BF
01778:  MOVFF  FEC,5C0
0177C:  MOVFF  FEC,5C1
01780:  MOVFF  FEC,5C2
01784:  MOVLW  01
01786:  SUBWF  xBC,W
01788:  MULLW  05
0178A:  MOVF   FF3,W
0178C:  CLRF   xC4
0178E:  MOVWF  xC3
01790:  MOVLW  7B
01792:  ADDWF  xC3,W
01794:  MOVWF  FE9
01796:  MOVLW  03
01798:  ADDWFC xC4,W
0179A:  MOVWF  FEA
0179C:  MOVFF  FEF,00
017A0:  MOVFF  FEC,01
017A4:  MOVFF  FEC,02
017A8:  MOVFF  FEC,03
017AC:  MOVF   03,W
017AE:  SUBWF  xC2,W
017B0:  BTFSS  FD8.0
017B2:  BRA    1926
017B4:  BNZ   17D2
017B6:  MOVF   02,W
017B8:  SUBWF  xC1,W
017BA:  BTFSS  FD8.0
017BC:  BRA    1926
017BE:  BNZ   17D2
017C0:  MOVF   01,W
017C2:  SUBWF  xC0,W
017C4:  BTFSS  FD8.0
017C6:  BRA    1926
017C8:  BNZ   17D2
017CA:  MOVF   xBF,W
017CC:  SUBWF  00,W
017CE:  BTFSC  FD8.0
017D0:  BRA    1926
....................       { 
....................          //do a swap reusing new queue item variable as a temp 
....................          priority = global_time_queue[n].pq_priority; 
017D2:  MOVF   xBC,W
017D4:  MULLW  05
017D6:  MOVF   FF3,W
017D8:  CLRF   xBE
017DA:  MOVWF  xBD
017DC:  MOVLW  04
017DE:  ADDWF  xBD,W
017E0:  MOVWF  01
017E2:  MOVLW  00
017E4:  ADDWFC xBE,W
017E6:  MOVWF  03
017E8:  MOVF   01,W
017EA:  ADDLW  7B
017EC:  MOVWF  FE9
017EE:  MOVLW  03
017F0:  ADDWFC 03,W
017F2:  MOVWF  FEA
017F4:  MOVFF  FEF,5BB
....................          global_time_queue[n].pq_priority = global_time_queue[n-1].pq_priority; 
017F8:  MOVF   xBC,W
017FA:  MULLW  05
017FC:  MOVF   FF3,W
017FE:  CLRF   xBE
01800:  MOVWF  xBD
01802:  MOVLW  04
01804:  ADDWF  xBD,W
01806:  MOVWF  01
01808:  MOVLW  00
0180A:  ADDWFC xBE,W
0180C:  MOVWF  03
0180E:  MOVF   01,W
01810:  ADDLW  7B
01812:  MOVWF  01
01814:  MOVLW  03
01816:  ADDWFC 03,F
01818:  MOVFF  01,5BD
0181C:  MOVFF  03,5BE
01820:  MOVLW  01
01822:  SUBWF  xBC,W
01824:  MULLW  05
01826:  MOVF   FF3,W
01828:  CLRF   xC0
0182A:  MOVWF  xBF
0182C:  MOVLW  04
0182E:  ADDWF  xBF,W
01830:  MOVWF  01
01832:  MOVLW  00
01834:  ADDWFC xC0,W
01836:  MOVWF  03
01838:  MOVF   01,W
0183A:  ADDLW  7B
0183C:  MOVWF  FE9
0183E:  MOVLW  03
01840:  ADDWFC 03,W
01842:  MOVWF  FEA
01844:  MOVFF  FEF,5BF
01848:  MOVFF  5BE,FEA
0184C:  MOVFF  5BD,FE9
01850:  MOVFF  5BF,FEF
....................          global_time_queue[n-1].pq_priority = priority; 
01854:  MOVLW  01
01856:  SUBWF  xBC,W
01858:  MULLW  05
0185A:  MOVF   FF3,W
0185C:  CLRF   xBE
0185E:  MOVWF  xBD
01860:  MOVLW  04
01862:  ADDWF  xBD,W
01864:  MOVWF  01
01866:  MOVLW  00
01868:  ADDWFC xBE,W
0186A:  MOVWF  03
0186C:  MOVF   01,W
0186E:  ADDLW  7B
01870:  MOVWF  FE9
01872:  MOVLW  03
01874:  ADDWFC 03,W
01876:  MOVWF  FEA
01878:  MOVFF  5BB,FEF
....................          time_to_execute = global_time_queue[n].time_to_execute; 
0187C:  MOVF   xBC,W
0187E:  MULLW  05
01880:  MOVF   FF3,W
01882:  CLRF   xBE
01884:  MOVWF  xBD
01886:  MOVLW  7B
01888:  ADDWF  xBD,W
0188A:  MOVWF  FE9
0188C:  MOVLW  03
0188E:  ADDWFC xBE,W
01890:  MOVWF  FEA
01892:  MOVFF  FEF,5B7
01896:  MOVFF  FEC,5B8
0189A:  MOVFF  FEC,5B9
0189E:  MOVFF  FEC,5BA
....................          global_time_queue[n].time_to_execute = global_time_queue[n-1].time_to_execute; 
018A2:  MOVF   xBC,W
018A4:  MULLW  05
018A6:  MOVF   FF3,W
018A8:  CLRF   xBE
018AA:  MOVWF  xBD
018AC:  MOVLW  7B
018AE:  ADDWF  xBD,W
018B0:  MOVWF  01
018B2:  MOVLW  03
018B4:  ADDWFC xBE,W
018B6:  MOVWF  03
018B8:  MOVFF  01,5BF
018BC:  MOVWF  xC0
018BE:  MOVLW  01
018C0:  SUBWF  xBC,W
018C2:  MULLW  05
018C4:  MOVF   FF3,W
018C6:  CLRF   xC2
018C8:  MOVWF  xC1
018CA:  MOVLW  7B
018CC:  ADDWF  xC1,W
018CE:  MOVWF  FE9
018D0:  MOVLW  03
018D2:  ADDWFC xC2,W
018D4:  MOVWF  FEA
018D6:  MOVFF  FEF,00
018DA:  MOVFF  FEC,01
018DE:  MOVFF  FEC,02
018E2:  MOVFF  FEC,03
018E6:  MOVFF  5C0,FEA
018EA:  MOVFF  5BF,FE9
018EE:  MOVFF  00,FEF
018F2:  MOVFF  01,FEC
018F6:  MOVFF  02,FEC
018FA:  MOVFF  03,FEC
....................          global_time_queue[n-1].time_to_execute = time_to_execute; 
018FE:  MOVLW  01
01900:  SUBWF  xBC,W
01902:  MULLW  05
01904:  MOVF   FF3,W
01906:  CLRF   xBE
01908:  MOVWF  xBD
0190A:  MOVLW  7B
0190C:  ADDWF  xBD,W
0190E:  MOVWF  FE9
01910:  MOVLW  03
01912:  ADDWFC xBE,W
01914:  MOVWF  FEA
01916:  MOVFF  5B7,FEF
0191A:  MOVFF  5B8,FEC
0191E:  MOVFF  5B9,FEC
01922:  MOVFF  5BA,FEC
....................           
....................       } 
01926:  DECF   xBC,F
01928:  BRA    1758
0192A:  MOVLB  3
....................    } 
....................    return; 
0192C:  MOVLB  0
0192E:  RETURN 0
.................... } 
....................  
.................... void allocate_command_queue(void) 
.................... { 
....................    // allocate the memory for the command queue sprinkler zone settings (can't 
....................    //    easily make a struct array inside a struct in c.) 
....................  
....................    uint8_t n; 
....................     
....................    for (n = 0; n < MAX_COMMAND_QUEUE_ITEMS; n++) 
....................    { 
....................       global_command_queue[n].sprinkler_settings =                            \ 
....................       (struct SprinklerZoneSettingsItem*)                                     \ 
....................       malloc(sizeof (struct SprinklerZoneSettingsItem) * MAX_NUM_SPRINKLER_ZONES); 
....................    } 
.................... } 
....................  
.................... void clear_command_queue(void) 
.................... { 
....................    // clears out the command queue and sets the start times to 0-1 
....................    uint8_t n; 
....................     
....................    // clear the queue compeleted and fill with zeros 
....................    memset(global_command_queue, 0, sizeof global_command_queue); 
....................     
....................    // sets start times to 0-1 (for unsigned int) 
....................    for (n = 0; n < MAX_COMMAND_QUEUE_ITEMS; n++) 
....................    { 
....................       global_command_queue[n].start_time = 0-1; 
....................    } 
....................     
....................    // set the queue location to 0-1 which signifies that there isn't anything 
....................    //    in the queue 
....................    global_current_command_queue_location = 0-1; 
.................... } 
....................  
.................... int1 push_command_queue(struct CommandQueueItem new_command_queue_item) 
.................... // pushes a new item into the command queue and sorts it (by time). 
.................... // returns 1 if everything is good, 0 if queue is full 
.................... { 
....................    uint8_t n; 
....................     
....................    //if queue is full, return 0 
....................    if (global_current_command_queue_location == (MAX_COMMAND_QUEUE_ITEMS - 1)) 
....................    { 
....................       return 0; 
....................    } 
....................     
....................    // increment the command queue location and 
....................    // set the new item at the top of the queue (will be sorted in a sec) 
....................    global_current_command_queue_location++; 
....................    global_command_queue[global_current_command_queue_location] = new_command_queue_item; 
....................     
....................    //starting at the new current queue location, sort through the queue 
....................    //until the new item is in the right place 
....................    for (n = global_current_command_queue_location; n > 0; n--) 
....................    { 
....................       //if queue items are not sorted properly 
....................       if (global_command_queue[n].start_time > global_command_queue[n-1].start_time) 
....................       { 
....................          //do a swap reusing new queue item variable as a temp 
....................          new_command_queue_item = global_time_queue[n]; 
....................          global_time_queue[n] = global_time_queue[n-1]; 
....................          global_time_queue[n-1] = new_command_queue_item; 
....................       } 
....................       //item is in the proper place (assuming queue always sorted properly) 
....................       else 
....................       { 
....................          return 1; 
....................       } 
....................    } 
....................    return 1; 
.................... } 
....................  
.................... void pop_command_queue_ISR() 
.................... // pops a new item off the command queue and sorts it (by time). 
.................... // returns 1 if everything is good, 0 if queue is full 
.................... { 
....................    uint8_t n; 
....................    struct commandQueueItem new_command_queue_item; 
....................     
....................    //if queue is empty, return 0 
....................    if (global_current_command_queue_location == 255) 
....................    { 
....................       return; 
....................    } 
....................     
....................     
....................    // increment the command queue location and 
....................    // set the new item at the top of the queue (will be sorted in a sec) 
....................    global_current_command_queue_location++; 
....................    global_command_queue[global_current_command_queue_location] = new_command_queue_item; 
....................     
....................    //starting at the new current queue location, sort through the queue 
....................    //until the new item is in the right place 
....................    for (n = global_current_command_queue_location; n > 0; n--) 
....................    { 
....................       //if queue items are not sorted properly 
....................       if (global_command_queue[n].start_time > global_command_queue[n-1].start_time) 
....................       { 
....................          //do a swap reusing new queue item variable as a temp 
....................          new_command_queue_item = global_time_queue[n]; 
....................          global_time_queue[n] = global_time_queue[n-1]; 
....................          global_time_queue[n-1] = new_command_queue_item; 
....................       } 
....................       //item is in the proper place (assuming queue always sorted properly) 
....................       else 
....................       { 
....................          return; 
....................       } 
....................    } 
....................    return; 
.................... } 
.................... void clear_sprinkler_queue() 
.................... { 
....................    disable_interrupts(INT_CCP4); 
*
050C0:  BCF    F7A.1
....................    memset(&global_sprinkler_queue, EMPTY_SPINKLER_QUEUE, sizeof(global_sprinkler_queue)); 
050C2:  MOVLW  03
050C4:  MOVWF  FEA
050C6:  MOVLW  95
050C8:  MOVWF  FE9
050CA:  CLRF   00
050CC:  CLRF   02
050CE:  MOVLW  8C
050D0:  MOVWF  01
050D2:  CALL   20D6
....................    global_current_sprinkler_queue_location = 0-1; 
050D6:  MOVLB  4
050D8:  SETF   x21
....................    global_rpm_set_value = 0; 
050DA:  MOVLB  0
050DC:  CLRF   xA5
050DE:  CLRF   xA4
....................    global_control_loop_mechanism = NO_RPM_CONTROL; 
050E0:  MOVLW  05
050E2:  MOVWF  xB8
....................    enable_interrupts(INT_CCP4); 
050E4:  BSF    F7A.1
050E6:  RETURN 0
.................... } 
....................  
.................... void push_spinkler_queue(uint32_t start_time,uint32_t end_time,uint16_t vlv_open_amount,uint16_t spin_rate,uint8_t zone_num, uint8_t control_loop_mechanism) 
.................... // pushes a new item into the sprinkler queue and sorts it (by start time). 
.................... // returns 1 if everything is good, 0 if queue is full 
.................... { 
....................    uint8_t n; 
....................    struct SprinklerQueueItem temp_sprinkler_queue_item; 
....................     
....................    // disable CCP4 interrupt (RTC timer) 
....................    disable_interrupts(INT_CCP4); 
*
06808:  BCF    F7A.1
....................           
....................    //if queue is full, return 0 
....................    if (global_current_sprinkler_queue_location == (MAX_SPRINKLER_QUEUE_ITEMS - 1)) 
0680A:  MOVLB  4
0680C:  MOVF   x21,W
0680E:  SUBLW  09
06810:  BNZ   6816
....................    { 
....................       enable_interrupts(INT_CCP4); 
06812:  BSF    F7A.1
....................       return; 
06814:  BRA    6A42
....................    } 
....................     
....................    // increment the sprinkler queue location and 
....................    // set the new item at the top of the queue (will be sorted in a sec) 
....................    global_current_sprinkler_queue_location++; 
06816:  INCF   x21,F
....................    global_sprinkler_queue[global_current_sprinkler_queue_location].start_time = start_time; 
06818:  MOVF   x21,W
0681A:  MULLW  0E
0681C:  MOVF   FF3,W
0681E:  MOVLB  5
06820:  CLRF   x78
06822:  MOVWF  x77
06824:  MOVLW  95
06826:  ADDWF  x77,W
06828:  MOVWF  FE9
0682A:  MOVLW  03
0682C:  ADDWFC x78,W
0682E:  MOVWF  FEA
06830:  MOVFF  55A,FEF
06834:  MOVFF  55B,FEC
06838:  MOVFF  55C,FEC
0683C:  MOVFF  55D,FEC
....................    global_sprinkler_queue[global_current_sprinkler_queue_location].end_time = end_time; 
06840:  MOVLB  4
06842:  MOVF   x21,W
06844:  MULLW  0E
06846:  MOVF   FF3,W
06848:  MOVLB  5
0684A:  CLRF   x78
0684C:  MOVWF  x77
0684E:  MOVLW  04
06850:  ADDWF  x77,W
06852:  MOVWF  01
06854:  MOVLW  00
06856:  ADDWFC x78,W
06858:  MOVWF  03
0685A:  MOVF   01,W
0685C:  ADDLW  95
0685E:  MOVWF  FE9
06860:  MOVLW  03
06862:  ADDWFC 03,W
06864:  MOVWF  FEA
06866:  MOVFF  55E,FEF
0686A:  MOVFF  55F,FEC
0686E:  MOVFF  560,FEC
06872:  MOVFF  561,FEC
....................    global_sprinkler_queue[global_current_sprinkler_queue_location].vlv_open_amount = vlv_open_amount; 
06876:  MOVLB  4
06878:  MOVF   x21,W
0687A:  MULLW  0E
0687C:  MOVF   FF3,W
0687E:  MOVLB  5
06880:  CLRF   x78
06882:  MOVWF  x77
06884:  MOVLW  08
06886:  ADDWF  x77,W
06888:  MOVWF  01
0688A:  MOVLW  00
0688C:  ADDWFC x78,W
0688E:  MOVWF  03
06890:  MOVF   01,W
06892:  ADDLW  95
06894:  MOVWF  FE9
06896:  MOVLW  03
06898:  ADDWFC 03,W
0689A:  MOVWF  FEA
0689C:  MOVFF  563,FEC
068A0:  MOVF   FED,F
068A2:  MOVFF  562,FEF
....................    global_sprinkler_queue[global_current_sprinkler_queue_location].spin_rate = spin_rate; 
068A6:  MOVLB  4
068A8:  MOVF   x21,W
068AA:  MULLW  0E
068AC:  MOVF   FF3,W
068AE:  MOVLB  5
068B0:  CLRF   x78
068B2:  MOVWF  x77
068B4:  MOVLW  0A
068B6:  ADDWF  x77,W
068B8:  MOVWF  01
068BA:  MOVLW  00
068BC:  ADDWFC x78,W
068BE:  MOVWF  03
068C0:  MOVF   01,W
068C2:  ADDLW  95
068C4:  MOVWF  FE9
068C6:  MOVLW  03
068C8:  ADDWFC 03,W
068CA:  MOVWF  FEA
068CC:  MOVFF  565,FEC
068D0:  MOVF   FED,F
068D2:  MOVFF  564,FEF
....................    global_sprinkler_queue[global_current_sprinkler_queue_location].zone_num = zone_num; 
068D6:  MOVLB  4
068D8:  MOVF   x21,W
068DA:  MULLW  0E
068DC:  MOVF   FF3,W
068DE:  MOVLB  5
068E0:  CLRF   x78
068E2:  MOVWF  x77
068E4:  MOVLW  0C
068E6:  ADDWF  x77,W
068E8:  MOVWF  01
068EA:  MOVLW  00
068EC:  ADDWFC x78,W
068EE:  MOVWF  03
068F0:  MOVF   01,W
068F2:  ADDLW  95
068F4:  MOVWF  FE9
068F6:  MOVLW  03
068F8:  ADDWFC 03,W
068FA:  MOVWF  FEA
068FC:  MOVFF  566,FEF
....................    global_sprinkler_queue[global_current_sprinkler_queue_location].control_loop_mechanism = control_loop_mechanism; 
06900:  MOVLB  4
06902:  MOVF   x21,W
06904:  MULLW  0E
06906:  MOVF   FF3,W
06908:  MOVLB  5
0690A:  CLRF   x78
0690C:  MOVWF  x77
0690E:  MOVLW  0D
06910:  ADDWF  x77,W
06912:  MOVWF  01
06914:  MOVLW  00
06916:  ADDWFC x78,W
06918:  MOVWF  03
0691A:  MOVF   01,W
0691C:  ADDLW  95
0691E:  MOVWF  FE9
06920:  MOVLW  03
06922:  ADDWFC 03,W
06924:  MOVWF  FEA
06926:  MOVFF  567,FEF
....................     
....................     
....................    //starting at the new current queue location, sort through the queue 
....................    //until the new item is in the right place 
....................    for (n = global_current_sprinkler_queue_location; n > 0; n--) 
0692A:  MOVFF  421,568
0692E:  MOVF   x68,F
06930:  BTFSC  FD8.2
06932:  BRA    6A3E
....................    { 
....................       //if queue items are not sorted properly 
....................       if (global_sprinkler_queue[n].start_time > global_sprinkler_queue[n-1].start_time) 
06934:  MOVF   x68,W
06936:  MULLW  0E
06938:  MOVF   FF3,W
0693A:  CLRF   x78
0693C:  MOVWF  x77
0693E:  MOVLW  95
06940:  ADDWF  x77,W
06942:  MOVWF  FE9
06944:  MOVLW  03
06946:  ADDWFC x78,W
06948:  MOVWF  FEA
0694A:  MOVFF  FEF,579
0694E:  MOVFF  FEC,57A
06952:  MOVFF  FEC,57B
06956:  MOVFF  FEC,57C
0695A:  MOVLW  01
0695C:  SUBWF  x68,W
0695E:  MULLW  0E
06960:  MOVF   FF3,W
06962:  CLRF   x7E
06964:  MOVWF  x7D
06966:  MOVLW  95
06968:  ADDWF  x7D,W
0696A:  MOVWF  FE9
0696C:  MOVLW  03
0696E:  ADDWFC x7E,W
06970:  MOVWF  FEA
06972:  MOVFF  FEF,00
06976:  MOVFF  FEC,01
0697A:  MOVFF  FEC,02
0697E:  MOVFF  FEC,03
06982:  MOVF   03,W
06984:  SUBWF  x7C,W
06986:  BNC   6A32
06988:  BNZ   69A0
0698A:  MOVF   02,W
0698C:  SUBWF  x7B,W
0698E:  BNC   6A32
06990:  BNZ   69A0
06992:  MOVF   01,W
06994:  SUBWF  x7A,W
06996:  BNC   6A32
06998:  BNZ   69A0
0699A:  MOVF   x79,W
0699C:  SUBWF  00,W
0699E:  BC    6A32
....................       { 
....................          //do a swap reusing new queue item variable as a temp 
....................          memcpy(&temp_sprinkler_queue_item, &global_sprinkler_queue[n], sizeof(&temp_sprinkler_queue_item)); 
069A0:  MOVF   x68,W
069A2:  MULLW  0E
069A4:  MOVF   FF3,W
069A6:  CLRF   03
069A8:  ADDLW  95
069AA:  MOVWF  01
069AC:  MOVLW  03
069AE:  ADDWFC 03,F
069B0:  MOVFF  03,FE2
069B4:  MOVFF  01,FE1
069B8:  MOVFF  FE6,569
069BC:  MOVFF  FE6,56A
....................          memcpy(&global_sprinkler_queue[n], &global_sprinkler_queue[n-1], sizeof(&global_sprinkler_queue[n])); 
069C0:  MOVF   x68,W
069C2:  MULLW  0E
069C4:  MOVF   FF3,W
069C6:  CLRF   03
069C8:  ADDLW  95
069CA:  MOVWF  01
069CC:  MOVLW  03
069CE:  ADDWFC 03,F
069D0:  MOVFF  01,577
069D4:  MOVFF  03,578
069D8:  MOVLW  01
069DA:  SUBWF  x68,W
069DC:  MULLW  0E
069DE:  MOVF   FF3,W
069E0:  CLRF   03
069E2:  ADDLW  95
069E4:  MOVWF  01
069E6:  MOVLW  03
069E8:  ADDWFC 03,F
069EA:  MOVFF  01,579
069EE:  MOVFF  03,57A
069F2:  MOVFF  578,FEA
069F6:  MOVFF  577,FE9
069FA:  MOVFF  03,FE2
069FE:  MOVFF  01,FE1
06A02:  MOVLW  02
06A04:  MOVWF  01
06A06:  MOVFF  FE6,FEE
06A0A:  DECFSZ 01,F
06A0C:  BRA    6A06
....................          memcpy(&global_sprinkler_queue[n-1], &temp_sprinkler_queue_item, sizeof(&global_sprinkler_queue[n-1])); 
06A0E:  MOVLW  01
06A10:  SUBWF  x68,W
06A12:  MULLW  0E
06A14:  MOVF   FF3,W
06A16:  CLRF   03
06A18:  ADDLW  95
06A1A:  MOVWF  01
06A1C:  MOVLW  03
06A1E:  ADDWFC 03,F
06A20:  MOVFF  03,FEA
06A24:  MOVFF  01,FE9
06A28:  MOVFF  569,FEE
06A2C:  MOVFF  56A,FEE
....................           
....................       } 
06A30:  BRA    6A3A
....................       //item is in the proper place (assuming queue always sorted properly) 
....................       else 
....................       { 
....................          enable_interrupts(INT_CCP4); 
06A32:  BSF    F7A.1
....................          return; 
06A34:  MOVLB  4
06A36:  BRA    6A42
06A38:  MOVLB  5
....................       } 
06A3A:  DECF   x68,F
06A3C:  BRA    692E
....................    } 
....................    enable_interrupts(INT_CCP4); 
06A3E:  BSF    F7A.1
06A40:  MOVLB  4
....................    return; 
06A42:  MOVLB  0
06A44:  RETURN 0
.................... } 
....................  
.................... void pop_sprinkler_queue_ISR(void) 
.................... // Checks the sprinkler queue and sets the sprinkler settings of the item on the top of the queue 
.................... { 
....................    //no items in the queue (current location is 0-1) 
....................    if (global_current_sprinkler_queue_location == 255) 
*
02A3A:  MOVLB  4
02A3C:  INCFSZ x21,W
02A3E:  BRA    2A44
....................    { 
....................       return; 
02A40:  BRA    2C3E
....................    } 
02A42:  BRA    2C3E
....................    // pop top item off queue and onto actual settings 
....................    else 
....................    { 
....................       //erase the current command start time (only important thing) and decrement the current queue location 
....................       global_sprinkler_queue[global_current_sprinkler_queue_location].start_time = 0-1; 
02A44:  MOVF   x21,W
02A46:  MULLW  0E
02A48:  MOVF   FF3,W
02A4A:  MOVLB  5
02A4C:  CLRF   x80
02A4E:  MOVWF  x7F
02A50:  MOVLW  95
02A52:  ADDWF  x7F,W
02A54:  MOVWF  FE9
02A56:  MOVLW  03
02A58:  ADDWFC x80,W
02A5A:  MOVWF  FEA
02A5C:  SETF   00
02A5E:  SETF   01
02A60:  SETF   02
02A62:  SETF   03
02A64:  MOVFF  00,FEF
02A68:  MOVFF  01,FEC
02A6C:  MOVFF  02,FEC
02A70:  MOVFF  03,FEC
....................       global_current_sprinkler_settings_end_time = global_sprinkler_queue[global_current_sprinkler_queue_location].end_time; 
02A74:  MOVLB  4
02A76:  MOVF   x21,W
02A78:  MULLW  0E
02A7A:  MOVF   FF3,W
02A7C:  MOVLB  5
02A7E:  CLRF   x80
02A80:  MOVWF  x7F
02A82:  MOVLW  04
02A84:  ADDWF  x7F,W
02A86:  MOVWF  01
02A88:  MOVLW  00
02A8A:  ADDWFC x80,W
02A8C:  MOVWF  03
02A8E:  MOVF   01,W
02A90:  ADDLW  95
02A92:  MOVWF  FE9
02A94:  MOVLW  03
02A96:  ADDWFC 03,W
02A98:  MOVWF  FEA
02A9A:  MOVFF  FEF,422
02A9E:  MOVFF  FEC,423
02AA2:  MOVFF  FEC,424
02AA6:  MOVFF  FEC,425
....................       global_sprinkler_queue[global_current_sprinkler_queue_location].end_time = 0; 
02AAA:  MOVLB  4
02AAC:  MOVF   x21,W
02AAE:  MULLW  0E
02AB0:  MOVF   FF3,W
02AB2:  MOVLB  5
02AB4:  CLRF   x80
02AB6:  MOVWF  x7F
02AB8:  MOVLW  04
02ABA:  ADDWF  x7F,W
02ABC:  MOVWF  01
02ABE:  MOVLW  00
02AC0:  ADDWFC x80,W
02AC2:  MOVWF  03
02AC4:  MOVF   01,W
02AC6:  ADDLW  95
02AC8:  MOVWF  FE9
02ACA:  MOVLW  03
02ACC:  ADDWFC 03,W
02ACE:  MOVWF  FEA
02AD0:  MOVF   FEE,F
02AD2:  MOVF   FEE,F
02AD4:  CLRF   FEC
02AD6:  MOVF   FED,F
02AD8:  CLRF   FEF
02ADA:  MOVF   FED,F
02ADC:  CLRF   FEF
02ADE:  MOVF   FED,F
02AE0:  CLRF   FEF
....................       global_valve_position_set_value = global_sprinkler_queue[global_current_sprinkler_queue_location].vlv_open_amount; 
02AE2:  MOVLB  4
02AE4:  MOVF   x21,W
02AE6:  MULLW  0E
02AE8:  MOVF   FF3,W
02AEA:  MOVLB  5
02AEC:  CLRF   x80
02AEE:  MOVWF  x7F
02AF0:  MOVLW  08
02AF2:  ADDWF  x7F,W
02AF4:  MOVWF  01
02AF6:  MOVLW  00
02AF8:  ADDWFC x80,W
02AFA:  MOVWF  03
02AFC:  MOVF   01,W
02AFE:  ADDLW  95
02B00:  MOVWF  FE9
02B02:  MOVLW  03
02B04:  ADDWFC 03,W
02B06:  MOVWF  FEA
02B08:  MOVFF  FEC,BC
02B0C:  MOVF   FED,F
02B0E:  MOVFF  FEF,BB
....................       global_sprinkler_queue[global_current_sprinkler_queue_location].vlv_open_amount = 0; 
02B12:  MOVLB  4
02B14:  MOVF   x21,W
02B16:  MULLW  0E
02B18:  MOVF   FF3,W
02B1A:  MOVLB  5
02B1C:  CLRF   x80
02B1E:  MOVWF  x7F
02B20:  MOVLW  08
02B22:  ADDWF  x7F,W
02B24:  MOVWF  01
02B26:  MOVLW  00
02B28:  ADDWFC x80,W
02B2A:  MOVWF  03
02B2C:  MOVF   01,W
02B2E:  ADDLW  95
02B30:  MOVWF  FE9
02B32:  MOVLW  03
02B34:  ADDWFC 03,W
02B36:  MOVWF  FEA
02B38:  CLRF   FEC
02B3A:  MOVF   FED,F
02B3C:  CLRF   FEF
....................       push_time_queue_ISR(global_rtc_time + 3, MOVE_VALVE); 
02B3E:  MOVLW  03
02B40:  MOVLB  0
02B42:  ADDWF  x85,W
02B44:  MOVLB  5
02B46:  MOVWF  x7F
02B48:  MOVLW  00
02B4A:  MOVLB  0
02B4C:  ADDWFC x86,W
02B4E:  MOVLB  5
02B50:  MOVWF  x80
02B52:  MOVLW  00
02B54:  MOVLB  0
02B56:  ADDWFC x87,W
02B58:  MOVLB  5
02B5A:  MOVWF  x81
02B5C:  MOVLW  00
02B5E:  MOVLB  0
02B60:  ADDWFC x88,W
02B62:  MOVLB  5
02B64:  MOVWF  x82
02B66:  CLRF   19
02B68:  BTFSC  FF2.7
02B6A:  BSF    19.7
02B6C:  BCF    FF2.7
02B6E:  MOVWF  xBA
02B70:  MOVFF  581,5B9
02B74:  MOVFF  580,5B8
02B78:  MOVFF  57F,5B7
02B7C:  MOVLW  40
02B7E:  MOVWF  xBB
02B80:  MOVLB  0
02B82:  CALL   16F6
02B86:  BTFSC  19.7
02B88:  BSF    FF2.7
....................       global_rpm_set_value = global_sprinkler_queue[global_current_sprinkler_queue_location].spin_rate; 
02B8A:  MOVLB  4
02B8C:  MOVF   x21,W
02B8E:  MULLW  0E
02B90:  MOVF   FF3,W
02B92:  MOVLB  5
02B94:  CLRF   x80
02B96:  MOVWF  x7F
02B98:  MOVLW  0A
02B9A:  ADDWF  x7F,W
02B9C:  MOVWF  01
02B9E:  MOVLW  00
02BA0:  ADDWFC x80,W
02BA2:  MOVWF  03
02BA4:  MOVF   01,W
02BA6:  ADDLW  95
02BA8:  MOVWF  FE9
02BAA:  MOVLW  03
02BAC:  ADDWFC 03,W
02BAE:  MOVWF  FEA
02BB0:  MOVFF  FEC,A5
02BB4:  MOVF   FED,F
02BB6:  MOVFF  FEF,A4
....................       global_sprinkler_queue[global_current_sprinkler_queue_location].spin_rate = 0; 
02BBA:  MOVLB  4
02BBC:  MOVF   x21,W
02BBE:  MULLW  0E
02BC0:  MOVF   FF3,W
02BC2:  MOVLB  5
02BC4:  CLRF   x80
02BC6:  MOVWF  x7F
02BC8:  MOVLW  0A
02BCA:  ADDWF  x7F,W
02BCC:  MOVWF  01
02BCE:  MOVLW  00
02BD0:  ADDWFC x80,W
02BD2:  MOVWF  03
02BD4:  MOVF   01,W
02BD6:  ADDLW  95
02BD8:  MOVWF  FE9
02BDA:  MOVLW  03
02BDC:  ADDWFC 03,W
02BDE:  MOVWF  FEA
02BE0:  CLRF   FEC
02BE2:  MOVF   FED,F
02BE4:  CLRF   FEF
....................       //global_sprinkler_queue[global_current_sprinkler_queue_location].zone_num; 
....................       global_control_loop_mechanism = global_sprinkler_queue[global_current_sprinkler_queue_location].control_loop_mechanism; 
02BE6:  MOVLB  4
02BE8:  MOVF   x21,W
02BEA:  MULLW  0E
02BEC:  MOVF   FF3,W
02BEE:  MOVLB  5
02BF0:  CLRF   x80
02BF2:  MOVWF  x7F
02BF4:  MOVLW  0D
02BF6:  ADDWF  x7F,W
02BF8:  MOVWF  01
02BFA:  MOVLW  00
02BFC:  ADDWFC x80,W
02BFE:  MOVWF  03
02C00:  MOVF   01,W
02C02:  ADDLW  95
02C04:  MOVWF  FE9
02C06:  MOVLW  03
02C08:  ADDWFC 03,W
02C0A:  MOVWF  FEA
02C0C:  MOVFF  FEF,B8
....................       global_sprinkler_queue[global_current_sprinkler_queue_location].control_loop_mechanism = NO_RPM_CONTROL_DYN_MPPC; 
02C10:  MOVLB  4
02C12:  MOVF   x21,W
02C14:  MULLW  0E
02C16:  MOVF   FF3,W
02C18:  MOVLB  5
02C1A:  CLRF   x80
02C1C:  MOVWF  x7F
02C1E:  MOVLW  0D
02C20:  ADDWF  x7F,W
02C22:  MOVWF  01
02C24:  MOVLW  00
02C26:  ADDWFC x80,W
02C28:  MOVWF  03
02C2A:  MOVF   01,W
02C2C:  ADDLW  95
02C2E:  MOVWF  FE9
02C30:  MOVLW  03
02C32:  ADDWFC 03,W
02C34:  MOVWF  FEA
02C36:  MOVLW  06
02C38:  MOVWF  FEF
....................       global_current_sprinkler_queue_location--; 
02C3A:  MOVLB  4
02C3C:  DECF   x21,F
....................        
....................       return; 
....................    } 
02C3E:  MOVLB  0
02C40:  GOTO   2E6C (RETURN)
.................... } 
....................  
.................... void clear_message_queue(void) 
.................... { 
....................    // disable conflicting interrupts 
....................    disable_interrupts(INT_CCP4);     
*
03EEE:  BCF    F7A.1
....................    memset(&global_message_queue, EMPTY_MESSAGE_QUEUE, sizeof(global_message_queue)); 
03EF0:  MOVLW  04
03EF2:  MOVWF  FEA
03EF4:  MOVLW  9F
03EF6:  MOVWF  FE9
03EF8:  CLRF   00
03EFA:  CLRF   02
03EFC:  MOVLW  50
03EFE:  MOVWF  01
03F00:  CALL   20D6
....................    // disable conflicting interrupts 
....................    disable_interrupts(INT_CCP4); 
03F04:  BCF    F7A.1
03F06:  GOTO   98F6 (RETURN)
.................... } 
....................  
.................... void pop_message_queue_and_send_ISR(void)  
.................... // Sends the top of the message queue out, re-adds it to the message stack with a 
.................... //    later send time (and attempt number) and sorts it properly.  Since this is 
.................... //    only called out of CCP4, all functions are ISR functions 
.................... {                       
....................     
....................    uint8_t n;                                                    
....................    struct MessageQueueItem temp_message_queue_item;        
....................  
....................    // no items in the queue (current location is 0-1) 
....................    if (global_current_message_queue_location == 255) 
*
026C8:  MOVLB  4
026CA:  INCFSZ xEF,W
026CC:  BRA    26D2
....................    { 
....................       return;   
026CE:  BRA    2A34
....................    } 
026D0:  BRA    2A34
....................    else 
....................    {              
....................       // If it has met or exceeded the maximum number of attempts, delete it off the queue, 
....................       //    set an error bit, and queue an error message. Attempt num is counted from 0 
....................       if (global_message_queue[global_current_message_queue_location].attempt_num >= (MAX_UNSOLICITED_MESSAGE_ATTEMPTS)) 
026D2:  MOVF   xEF,W
026D4:  MULLW  08
026D6:  MOVF   FF3,W
026D8:  MOVLB  5
026DA:  CLRF   x89
026DC:  MOVWF  x88
026DE:  MOVLW  07
026E0:  ADDWF  x88,W
026E2:  MOVWF  01
026E4:  MOVLW  00
026E6:  ADDWFC x89,W
026E8:  MOVWF  03
026EA:  MOVF   01,W
026EC:  ADDLW  9F
026EE:  MOVWF  FE9
026F0:  MOVLW  04
026F2:  ADDWFC 03,W
026F4:  MOVWF  FEA
026F6:  MOVF   FEF,W
026F8:  SUBLW  02
026FA:  BC    271C
....................       { 
....................          remove_message_queue_item_ISR(mote_msgSEQ); 
026FC:  MOVFF  35E,589
02700:  MOVFF  35D,588
02704:  MOVLB  0
02706:  BRA    20F0
....................          // set an error bit saying a message was missed 
....................          global_error_message_bitfield |= ERR_MSG_UNSOLICITED_MESSAGE_NOT_ACKD; 
02708:  MOVLB  4
0270A:  BSF    xF0.0
....................          push_message_queue_ISR(MSG_MOTE_ERROR_MSG); 
0270C:  MOVLW  A0
0270E:  MOVLB  5
02710:  MOVWF  x9B
02712:  MOVLB  0
02714:  CALL   0BC0
....................       } 
02718:  BRA    2A32
0271A:  MOVLB  5
....................       // regular message (not @ max attempts)    
....................       else 
....................       {                
....................          // what message type?  
....................          // resend with unsolicited (0x00 identifier) and it's current message seq 
....................          switch(global_message_queue[global_current_message_queue_location].message_type) 
0271C:  MOVLB  4
0271E:  MOVF   xEF,W
02720:  MULLW  08
02722:  MOVF   FF3,W
02724:  MOVLB  5
02726:  CLRF   x89
02728:  MOVWF  x88
0272A:  MOVLW  04
0272C:  ADDWF  x88,W
0272E:  MOVWF  01
02730:  MOVLW  00
02732:  ADDWFC x89,W
02734:  MOVWF  03
02736:  MOVF   01,W
02738:  ADDLW  9F
0273A:  MOVWF  FE9
0273C:  MOVLW  04
0273E:  ADDWFC 03,W
02740:  MOVWF  FEA
02742:  MOVF   FEF,W
02744:  XORLW  91
02746:  MOVLB  0
02748:  BZ    2764
0274A:  XORLW  03
0274C:  BZ    279C
0274E:  XORLW  06
02750:  BZ    27D4
02752:  XORLW  02
02754:  BZ    280C
02756:  XORLW  0E
02758:  BTFSC  FD8.2
0275A:  BRA    2844
0275C:  XORLW  38
0275E:  BTFSC  FD8.2
02760:  BRA    287C
02762:  BRA    28B2
....................          { 
....................             case MSG_MOTE_HEALTH_REPORT: 
....................                send_health_report_ISR(MSG_MOTE_UNSOLICITED, global_message_queue[global_current_message_queue_location].msg_seq); 
02764:  MOVLB  4
02766:  MOVF   xEF,W
02768:  MULLW  08
0276A:  MOVF   FF3,W
0276C:  MOVLB  5
0276E:  CLRF   x89
02770:  MOVWF  x88
02772:  MOVLW  05
02774:  ADDWF  x88,W
02776:  MOVWF  01
02778:  MOVLW  00
0277A:  ADDWFC x89,W
0277C:  MOVWF  03
0277E:  MOVF   01,W
02780:  ADDLW  9F
02782:  MOVWF  FE9
02784:  MOVLW  04
02786:  ADDWFC 03,W
02788:  MOVWF  FEA
0278A:  MOVFF  FEC,58C
0278E:  MOVF   FED,F
02790:  MOVFF  FEF,58B
02794:  CLRF   x8A
02796:  MOVLB  0
02798:  BRA    230C
....................                break;                                                                           
0279A:  BRA    28B2
....................             case MSG_MOTE_VALVE_REPORT:    
....................                send_valve_report_ISR(MSG_MOTE_UNSOLICITED,global_message_queue[global_current_message_queue_location].msg_seq); 
0279C:  MOVLB  4
0279E:  MOVF   xEF,W
027A0:  MULLW  08
027A2:  MOVF   FF3,W
027A4:  MOVLB  5
027A6:  CLRF   x89
027A8:  MOVWF  x88
027AA:  MOVLW  05
027AC:  ADDWF  x88,W
027AE:  MOVWF  01
027B0:  MOVLW  00
027B2:  ADDWFC x89,W
027B4:  MOVWF  03
027B6:  MOVF   01,W
027B8:  ADDLW  9F
027BA:  MOVWF  FE9
027BC:  MOVLW  04
027BE:  ADDWFC 03,W
027C0:  MOVWF  FEA
027C2:  MOVFF  FEC,58C
027C6:  MOVF   FED,F
027C8:  MOVFF  FEF,58B
027CC:  CLRF   x8A
027CE:  MOVLB  0
027D0:  BRA    2486
....................                break; 
027D2:  BRA    28B2
....................             case MSG_MOTE_JOIN_MSG: 
....................                send_join_msg_ISR(MSG_MOTE_UNSOLICITED,global_message_queue[global_current_message_queue_location].msg_seq); 
027D4:  MOVLB  4
027D6:  MOVF   xEF,W
027D8:  MULLW  08
027DA:  MOVF   FF3,W
027DC:  MOVLB  5
027DE:  CLRF   x89
027E0:  MOVWF  x88
027E2:  MOVLW  05
027E4:  ADDWF  x88,W
027E6:  MOVWF  01
027E8:  MOVLW  00
027EA:  ADDWFC x89,W
027EC:  MOVWF  03
027EE:  MOVF   01,W
027F0:  ADDLW  9F
027F2:  MOVWF  FE9
027F4:  MOVLW  04
027F6:  ADDWFC 03,W
027F8:  MOVWF  FEA
027FA:  MOVFF  FEC,58C
027FE:  MOVF   FED,F
02800:  MOVFF  FEF,58B
02804:  CLRF   x8A
02806:  MOVLB  0
02808:  BRA    25B8
....................                break; 
0280A:  BRA    28B2
....................             case MSG_MOTE_GPS_POINT_MSG: 
....................                send_gps_point_msg_ISR(MSG_MOTE_UNSOLICITED,global_message_queue[global_current_message_queue_location].msg_seq); 
0280C:  MOVLB  4
0280E:  MOVF   xEF,W
02810:  MULLW  08
02812:  MOVF   FF3,W
02814:  MOVLB  5
02816:  CLRF   x89
02818:  MOVWF  x88
0281A:  MOVLW  05
0281C:  ADDWF  x88,W
0281E:  MOVWF  01
02820:  MOVLW  00
02822:  ADDWFC x89,W
02824:  MOVWF  03
02826:  MOVF   01,W
02828:  ADDLW  9F
0282A:  MOVWF  FE9
0282C:  MOVLW  04
0282E:  ADDWFC 03,W
02830:  MOVWF  FEA
02832:  MOVFF  FEC,58C
02836:  MOVF   FED,F
02838:  MOVFF  FEF,58B
0283C:  CLRF   x8A
0283E:  MOVLB  0
02840:  BRA    2612
....................                break;                                         
02842:  BRA    28B2
....................             case MSG_MOTE_XDCR_READ_MSG:                                                    
....................                send_pressure_xdcr_msg_ISR(MSG_MOTE_UNSOLICITED,global_message_queue[global_current_message_queue_location].msg_seq); 
02844:  MOVLB  4
02846:  MOVF   xEF,W
02848:  MULLW  08
0284A:  MOVF   FF3,W
0284C:  MOVLB  5
0284E:  CLRF   x89
02850:  MOVWF  x88
02852:  MOVLW  05
02854:  ADDWF  x88,W
02856:  MOVWF  01
02858:  MOVLW  00
0285A:  ADDWFC x89,W
0285C:  MOVWF  03
0285E:  MOVF   01,W
02860:  ADDLW  9F
02862:  MOVWF  FE9
02864:  MOVLW  04
02866:  ADDWFC 03,W
02868:  MOVWF  FEA
0286A:  MOVFF  FEC,58C
0286E:  MOVF   FED,F
02870:  MOVFF  FEF,58B
02874:  CLRF   x8A
02876:  MOVLB  0
02878:  BRA    2644
....................                break; 
0287A:  BRA    28B2
....................             case MSG_MOTE_ERROR_MSG:       
....................                send_error_msg_ISR(MSG_MOTE_UNSOLICITED,global_message_queue[global_current_message_queue_location].msg_seq); 
0287C:  MOVLB  4
0287E:  MOVF   xEF,W
02880:  MULLW  08
02882:  MOVF   FF3,W
02884:  MOVLB  5
02886:  CLRF   x89
02888:  MOVWF  x88
0288A:  MOVLW  05
0288C:  ADDWF  x88,W
0288E:  MOVWF  01
02890:  MOVLW  00
02892:  ADDWFC x89,W
02894:  MOVWF  03
02896:  MOVF   01,W
02898:  ADDLW  9F
0289A:  MOVWF  FE9
0289C:  MOVLW  04
0289E:  ADDWFC 03,W
028A0:  MOVWF  FEA
028A2:  MOVFF  FEC,58C
028A6:  MOVF   FED,F
028A8:  MOVFF  FEF,58B
028AC:  CLRF   x8A
028AE:  MOVLB  0
028B0:  BRA    267E
....................                break; 
....................          } 
....................          // increment attempt number and reschedule it to send at a later time (if not ack'd) 
....................          global_message_queue[global_current_message_queue_location].attempt_num++; 
028B2:  MOVLB  4
028B4:  MOVF   xEF,W
028B6:  MULLW  08
028B8:  MOVF   FF3,W
028BA:  MOVLB  5
028BC:  CLRF   x89
028BE:  MOVWF  x88
028C0:  MOVLW  07
028C2:  ADDWF  x88,W
028C4:  MOVWF  01
028C6:  MOVLW  00
028C8:  ADDWFC x89,W
028CA:  MOVWF  03
028CC:  MOVF   01,W
028CE:  ADDLW  9F
028D0:  MOVWF  FE9
028D2:  MOVLW  04
028D4:  ADDWFC 03,W
028D6:  MOVWF  FEA
028D8:  INCF   FEF,F
....................          global_message_queue[global_current_message_queue_location].time_to_send+=MESSAGE_RESEND_WAIT_PERIOD; 
028DA:  MOVLB  4
028DC:  MOVF   xEF,W
028DE:  MULLW  08
028E0:  MOVF   FF3,W
028E2:  MOVLB  5
028E4:  CLRF   x89
028E6:  MOVWF  x88
028E8:  MOVLW  9F
028EA:  ADDWF  x88,W
028EC:  MOVWF  FE9
028EE:  MOVLW  04
028F0:  ADDWFC x89,W
028F2:  MOVWF  FEA
028F4:  MOVLW  3C
028F6:  ADDWF  FEF,W
028F8:  MOVWF  00
028FA:  MOVLW  00
028FC:  ADDWFC FEC,W
028FE:  MOVWF  01
02900:  MOVLW  00
02902:  ADDWFC FEC,W
02904:  MOVWF  02
02906:  MOVLW  00
02908:  ADDWFC FEC,W
0290A:  MOVF   FED,F
0290C:  MOVF   FED,F
0290E:  MOVF   FED,F
02910:  MOVFF  00,FEF
02914:  MOVFF  01,FEC
02918:  MOVFF  02,FEC
0291C:  MOVWF  FEC
....................           
....................          // starting at the current queue location, sort through the queue 
....................          //    until the item is in the right place 
....................          for (n = global_current_message_queue_location; n > 0; n--)                  
0291E:  MOVFF  4EF,57F
02922:  MOVF   x7F,F
02924:  BTFSC  FD8.2
02926:  BRA    2A30
....................          { 
....................             //if queue items are not sorted properly 
....................             if (global_message_queue[n].time_to_send > global_message_queue[n-1].time_to_send) 
02928:  MOVF   x7F,W
0292A:  MULLW  08
0292C:  MOVF   FF3,W
0292E:  CLRF   x89
02930:  MOVWF  x88
02932:  MOVLW  9F
02934:  ADDWF  x88,W
02936:  MOVWF  FE9
02938:  MOVLW  04
0293A:  ADDWFC x89,W
0293C:  MOVWF  FEA
0293E:  MOVFF  FEF,58A
02942:  MOVFF  FEC,58B
02946:  MOVFF  FEC,58C
0294A:  MOVFF  FEC,58D
0294E:  MOVLW  01
02950:  SUBWF  x7F,W
02952:  MULLW  08
02954:  MOVF   FF3,W
02956:  CLRF   x8F
02958:  MOVWF  x8E
0295A:  MOVLW  9F
0295C:  ADDWF  x8E,W
0295E:  MOVWF  FE9
02960:  MOVLW  04
02962:  ADDWFC x8F,W
02964:  MOVWF  FEA
02966:  MOVFF  FEF,00
0296A:  MOVFF  FEC,01
0296E:  MOVFF  FEC,02
02972:  MOVFF  FEC,03
02976:  MOVF   03,W
02978:  SUBWF  x8D,W
0297A:  BNC   2A26
0297C:  BNZ   2994
0297E:  MOVF   02,W
02980:  SUBWF  x8C,W
02982:  BNC   2A26
02984:  BNZ   2994
02986:  MOVF   01,W
02988:  SUBWF  x8B,W
0298A:  BNC   2A26
0298C:  BNZ   2994
0298E:  MOVF   x8A,W
02990:  SUBWF  00,W
02992:  BC    2A26
....................             { 
....................                //do a swap 
....................                memcpy(&temp_message_queue_item, &global_message_queue[n], sizeof(&temp_message_queue_item)); 
02994:  MOVF   x7F,W
02996:  MULLW  08
02998:  MOVF   FF3,W
0299A:  CLRF   03
0299C:  ADDLW  9F
0299E:  MOVWF  01
029A0:  MOVLW  04
029A2:  ADDWFC 03,F
029A4:  MOVFF  03,FE2
029A8:  MOVFF  01,FE1
029AC:  MOVFF  FE6,580
029B0:  MOVFF  FE6,581
....................                memcpy(&global_message_queue[n], &global_message_queue[n-1], sizeof(&global_message_queue[n])); 
029B4:  MOVF   x7F,W
029B6:  MULLW  08
029B8:  MOVF   FF3,W
029BA:  CLRF   03
029BC:  ADDLW  9F
029BE:  MOVWF  01
029C0:  MOVLW  04
029C2:  ADDWFC 03,F
029C4:  MOVFF  01,588
029C8:  MOVFF  03,589
029CC:  MOVLW  01
029CE:  SUBWF  x7F,W
029D0:  MULLW  08
029D2:  MOVF   FF3,W
029D4:  CLRF   03
029D6:  ADDLW  9F
029D8:  MOVWF  01
029DA:  MOVLW  04
029DC:  ADDWFC 03,F
029DE:  MOVFF  01,58A
029E2:  MOVFF  03,58B
029E6:  MOVFF  589,FEA
029EA:  MOVFF  588,FE9
029EE:  MOVFF  03,FE2
029F2:  MOVFF  01,FE1
029F6:  MOVLW  02
029F8:  MOVWF  01
029FA:  MOVFF  FE6,FEE
029FE:  DECFSZ 01,F
02A00:  BRA    29FA
....................                memcpy(&global_message_queue[n-1], &temp_message_queue_item, sizeof(&global_message_queue[n-1])); 
02A02:  MOVLW  01
02A04:  SUBWF  x7F,W
02A06:  MULLW  08
02A08:  MOVF   FF3,W
02A0A:  CLRF   03
02A0C:  ADDLW  9F
02A0E:  MOVWF  01
02A10:  MOVLW  04
02A12:  ADDWFC 03,F
02A14:  MOVFF  03,FEA
02A18:  MOVFF  01,FE9
02A1C:  MOVFF  580,FEE
02A20:  MOVFF  581,FEE
....................             } 
02A24:  BRA    2A2C
....................             //item is in the proper place (assuming queue always sorted properly) 
....................             else 
....................             { 
....................                return; 
02A26:  MOVLB  4
02A28:  BRA    2A34
02A2A:  MOVLB  5
....................             } 
02A2C:  DECF   x7F,F
02A2E:  BRA    2922
02A30:  MOVLB  0
02A32:  MOVLB  4
....................          } 
....................       } 
....................    } 
02A34:  MOVLB  0
02A36:  GOTO   2D92 (RETURN)
.................... } 
....................                                        
.................... void push_message_queue(uint8_t message_type) 
.................... // pushes a new item (attempt 0) into the message queue and sorts it. 
.................... // returns 1 if everything is good, 0 if queue is full 
.................... {                 
....................    uint8_t n; 
....................    struct MessageQueueItem temp_message_queue_item;                             
....................     
....................    //if queue is full, return 0                                                      
....................    if (global_current_message_queue_location == (MAX_MESSAGE_QUEUE_ITEMS - 1)) 
*
04D00:  MOVLB  4
04D02:  MOVF   xEF,W
04D04:  SUBLW  09
04D06:  BNZ   4D0A
....................    {                                             
....................       return;    
04D08:  BRA    5014
....................    } 
....................                  
....................                                                                                                  
....................    // if you're trying to add an error message...                    
....................    if (message_type == MSG_MOTE_ERROR_MSG) 
04D0A:  MOVLB  5
04D0C:  MOVF   x50,W
04D0E:  SUBLW  A0
04D10:  BTFSS  FD8.2
04D12:  BRA    4E48
....................    { 
....................       // check to see if it is the same as the last error message added and if it has happened too recently to resend 
....................       if ((global_error_message_bitfield == last_error_message_sent_bitfield) && ((global_rtc_time - last_error_message_sent_rtc_time) < ERR_MESSAGE_WAIT_PERIOD)) 
04D14:  MOVLB  4
04D16:  MOVF   xF4,W
04D18:  SUBWF  xF0,W
04D1A:  BNZ   4D8C
04D1C:  MOVF   xF5,W
04D1E:  SUBWF  xF1,W
04D20:  BNZ   4D8C
04D22:  MOVF   xF6,W
04D24:  SUBWF  xF2,W
04D26:  BNZ   4D8C
04D28:  MOVF   xF7,W
04D2A:  SUBWF  xF3,W
04D2C:  BNZ   4D8C
04D2E:  MOVF   xF8,W
04D30:  MOVLB  0
04D32:  SUBWF  x85,W
04D34:  MOVLB  5
04D36:  MOVWF  x5A
04D38:  MOVLB  4
04D3A:  MOVF   xF9,W
04D3C:  MOVLB  0
04D3E:  SUBWFB x86,W
04D40:  MOVLB  5
04D42:  MOVWF  x5B
04D44:  MOVLB  4
04D46:  MOVF   xFA,W
04D48:  MOVLB  0
04D4A:  SUBWFB x87,W
04D4C:  MOVLB  5
04D4E:  MOVWF  x5C
04D50:  MOVLB  4
04D52:  MOVF   xFB,W
04D54:  MOVLB  0
04D56:  SUBWFB x88,W
04D58:  MOVLB  5
04D5A:  MOVWF  x5D
04D5C:  MOVF   x5D,F
04D5E:  BTFSC  FD8.2
04D60:  BRA    4D66
04D62:  MOVLB  4
04D64:  BRA    4D8C
04D66:  MOVF   x5C,F
04D68:  BTFSC  FD8.2
04D6A:  BRA    4D70
04D6C:  MOVLB  4
04D6E:  BRA    4D8C
04D70:  MOVF   x5B,F
04D72:  BTFSC  FD8.2
04D74:  BRA    4D7A
04D76:  MOVLB  4
04D78:  BRA    4D8C
04D7A:  MOVF   x5A,W
04D7C:  SUBLW  3B
04D7E:  BTFSC  FD8.0
04D80:  BRA    4D86
04D82:  MOVLB  4
04D84:  BRA    4D8C
....................       {         
....................          return; 
04D86:  MOVLB  4
04D88:  BRA    5014
....................       } 
04D8A:  BRA    4DAC
....................       else 
....................       { 
....................          // save the error message bitfield and send time for future comparing and rejecting of duplicate messages 
....................          last_error_message_sent_bitfield = global_error_message_bitfield; 
04D8C:  MOVFF  4F3,4F7
04D90:  MOVFF  4F2,4F6
04D94:  MOVFF  4F1,4F5
04D98:  MOVFF  4F0,4F4
....................          last_error_message_sent_rtc_time = global_rtc_time; 
04D9C:  MOVFF  88,4FB
04DA0:  MOVFF  87,4FA
04DA4:  MOVFF  86,4F9
04DA8:  MOVFF  85,4F8
....................       }                              
....................       // look through the current queue 
....................       for (n = global_current_message_queue_location; ((n > 0) && (n != 255)); n--) 
04DAC:  MOVFF  4EF,551
04DB0:  MOVLB  5
04DB2:  MOVF   x51,F
04DB4:  BZ    4E48
04DB6:  INCFSZ x51,W
04DB8:  BRA    4DBC
04DBA:  BRA    4E48
....................       { 
....................          // if there is already another error message on the queue, replace it 
....................          if (global_message_queue[n].message_type == MSG_MOTE_ERROR_MSG) 
04DBC:  MOVF   x51,W
04DBE:  MULLW  08
04DC0:  MOVF   FF3,W
04DC2:  CLRF   x5B
04DC4:  MOVWF  x5A
04DC6:  MOVLW  04
04DC8:  ADDWF  x5A,W
04DCA:  MOVWF  01
04DCC:  MOVLW  00
04DCE:  ADDWFC x5B,W
04DD0:  MOVWF  03
04DD2:  MOVF   01,W
04DD4:  ADDLW  9F
04DD6:  MOVWF  FE9
04DD8:  MOVLW  04
04DDA:  ADDWFC 03,W
04DDC:  MOVWF  FEA
04DDE:  MOVF   FEF,W
04DE0:  SUBLW  A0
04DE2:  BNZ   4E44
....................          { 
....................             // increase the mote sequence number (new message) 
....................             // the ack from the previous one will basically get ignored 
....................             global_message_queue[n].msg_seq = ++mote_msgSEQ; 
04DE4:  MOVF   x51,W
04DE6:  MULLW  08
04DE8:  MOVF   FF3,W
04DEA:  CLRF   x5B
04DEC:  MOVWF  x5A
04DEE:  MOVLW  05
04DF0:  ADDWF  x5A,W
04DF2:  MOVWF  01
04DF4:  MOVLW  00
04DF6:  ADDWFC x5B,W
04DF8:  MOVWF  03
04DFA:  MOVF   01,W
04DFC:  ADDLW  9F
04DFE:  MOVWF  FE9
04E00:  MOVLW  04
04E02:  ADDWFC 03,W
04E04:  MOVWF  FEA
04E06:  MOVLB  3
04E08:  INCF   x5D,F
04E0A:  BTFSC  FD8.2
04E0C:  INCF   x5E,F
04E0E:  MOVFF  35E,FEC
04E12:  MOVF   FED,F
04E14:  MOVFF  35D,FEF
....................             // reset the attempts to 0 (new message) 
....................             global_message_queue[n].attempt_num = 0;      
04E18:  MOVLB  5
04E1A:  MOVF   x51,W
04E1C:  MULLW  08
04E1E:  MOVF   FF3,W
04E20:  CLRF   x5B
04E22:  MOVWF  x5A
04E24:  MOVLW  07
04E26:  ADDWF  x5A,W
04E28:  MOVWF  01
04E2A:  MOVLW  00
04E2C:  ADDWFC x5B,W
04E2E:  MOVWF  03
04E30:  MOVF   01,W
04E32:  ADDLW  9F
04E34:  MOVWF  FE9
04E36:  MOVLW  04
04E38:  ADDWFC 03,W
04E3A:  MOVWF  FEA
04E3C:  CLRF   FEF
....................             return; 
04E3E:  MOVLB  4
04E40:  BRA    5014
04E42:  MOVLB  5
....................          } 
04E44:  DECF   x51,F
04E46:  BRA    4DB2
....................       } 
....................    } 
....................       
....................    // increment the queue location and mote message sequence (always first attempt 
....................    //    at a message in this routine 
....................    global_current_message_queue_location++; 
04E48:  MOVLB  4
04E4A:  INCF   xEF,F
....................    mote_msgSEQ++; 
04E4C:  MOVLB  3
04E4E:  INCF   x5D,F
04E50:  BTFSC  FD8.2
04E52:  INCF   x5E,F
....................     
....................    //set the new item at the top of the queue (will be sorted in a sec) 
....................    global_message_queue[global_current_message_queue_location].time_to_send = global_rtc_time; 
04E54:  MOVLB  4
04E56:  MOVF   xEF,W
04E58:  MULLW  08
04E5A:  MOVF   FF3,W
04E5C:  MOVLB  5
04E5E:  CLRF   x5B
04E60:  MOVWF  x5A
04E62:  MOVLW  9F
04E64:  ADDWF  x5A,W
04E66:  MOVWF  FE9
04E68:  MOVLW  04
04E6A:  ADDWFC x5B,W
04E6C:  MOVWF  FEA
04E6E:  MOVFF  85,FEF
04E72:  MOVFF  86,FEC
04E76:  MOVFF  87,FEC
04E7A:  MOVFF  88,FEC
....................    global_message_queue[global_current_message_queue_location].message_type = message_type; 
04E7E:  MOVLB  4
04E80:  MOVF   xEF,W
04E82:  MULLW  08
04E84:  MOVF   FF3,W
04E86:  MOVLB  5
04E88:  CLRF   x5B
04E8A:  MOVWF  x5A
04E8C:  MOVLW  04
04E8E:  ADDWF  x5A,W
04E90:  MOVWF  01
04E92:  MOVLW  00
04E94:  ADDWFC x5B,W
04E96:  MOVWF  03
04E98:  MOVF   01,W
04E9A:  ADDLW  9F
04E9C:  MOVWF  FE9
04E9E:  MOVLW  04
04EA0:  ADDWFC 03,W
04EA2:  MOVWF  FEA
04EA4:  MOVFF  550,FEF
....................    global_message_queue[global_current_message_queue_location].msg_seq = mote_msgSEQ; 
04EA8:  MOVLB  4
04EAA:  MOVF   xEF,W
04EAC:  MULLW  08
04EAE:  MOVF   FF3,W
04EB0:  MOVLB  5
04EB2:  CLRF   x5B
04EB4:  MOVWF  x5A
04EB6:  MOVLW  05
04EB8:  ADDWF  x5A,W
04EBA:  MOVWF  01
04EBC:  MOVLW  00
04EBE:  ADDWFC x5B,W
04EC0:  MOVWF  03
04EC2:  MOVF   01,W
04EC4:  ADDLW  9F
04EC6:  MOVWF  FE9
04EC8:  MOVLW  04
04ECA:  ADDWFC 03,W
04ECC:  MOVWF  FEA
04ECE:  MOVFF  35E,FEC
04ED2:  MOVF   FED,F
04ED4:  MOVFF  35D,FEF
....................    global_message_queue[global_current_message_queue_location].attempt_num = 0;    
04ED8:  MOVLB  4
04EDA:  MOVF   xEF,W
04EDC:  MULLW  08
04EDE:  MOVF   FF3,W
04EE0:  MOVLB  5
04EE2:  CLRF   x5B
04EE4:  MOVWF  x5A
04EE6:  MOVLW  07
04EE8:  ADDWF  x5A,W
04EEA:  MOVWF  01
04EEC:  MOVLW  00
04EEE:  ADDWFC x5B,W
04EF0:  MOVWF  03
04EF2:  MOVF   01,W
04EF4:  ADDLW  9F
04EF6:  MOVWF  FE9
04EF8:  MOVLW  04
04EFA:  ADDWFC 03,W
04EFC:  MOVWF  FEA
04EFE:  CLRF   FEF
....................           
....................    //starting at the new current queue location, sort through the queue 
....................    //until the new item is in the right place 
....................    for (n = global_current_message_queue_location; n > 0; n--)                    
04F00:  MOVFF  4EF,551
04F04:  MOVF   x51,F
04F06:  BTFSC  FD8.2
04F08:  BRA    5012
....................    {                                                
....................       //if queue items are not sorted properly 
....................       if (global_message_queue[n].time_to_send > global_message_queue[n-1].time_to_send) 
04F0A:  MOVF   x51,W
04F0C:  MULLW  08
04F0E:  MOVF   FF3,W
04F10:  CLRF   x5B
04F12:  MOVWF  x5A
04F14:  MOVLW  9F
04F16:  ADDWF  x5A,W
04F18:  MOVWF  FE9
04F1A:  MOVLW  04
04F1C:  ADDWFC x5B,W
04F1E:  MOVWF  FEA
04F20:  MOVFF  FEF,55C
04F24:  MOVFF  FEC,55D
04F28:  MOVFF  FEC,55E
04F2C:  MOVFF  FEC,55F
04F30:  MOVLW  01
04F32:  SUBWF  x51,W
04F34:  MULLW  08
04F36:  MOVF   FF3,W
04F38:  CLRF   x61
04F3A:  MOVWF  x60
04F3C:  MOVLW  9F
04F3E:  ADDWF  x60,W
04F40:  MOVWF  FE9
04F42:  MOVLW  04
04F44:  ADDWFC x61,W
04F46:  MOVWF  FEA
04F48:  MOVFF  FEF,00
04F4C:  MOVFF  FEC,01
04F50:  MOVFF  FEC,02
04F54:  MOVFF  FEC,03
04F58:  MOVF   03,W
04F5A:  SUBWF  x5F,W
04F5C:  BNC   5008
04F5E:  BNZ   4F76
04F60:  MOVF   02,W
04F62:  SUBWF  x5E,W
04F64:  BNC   5008
04F66:  BNZ   4F76
04F68:  MOVF   01,W
04F6A:  SUBWF  x5D,W
04F6C:  BNC   5008
04F6E:  BNZ   4F76
04F70:  MOVF   x5C,W
04F72:  SUBWF  00,W
04F74:  BC    5008
....................       { 
....................          //do a swap 
....................          memcpy(&temp_message_queue_item, &global_message_queue[n], sizeof(&temp_message_queue_item)); 
04F76:  MOVF   x51,W
04F78:  MULLW  08
04F7A:  MOVF   FF3,W
04F7C:  CLRF   03
04F7E:  ADDLW  9F
04F80:  MOVWF  01
04F82:  MOVLW  04
04F84:  ADDWFC 03,F
04F86:  MOVFF  03,FE2
04F8A:  MOVFF  01,FE1
04F8E:  MOVFF  FE6,552
04F92:  MOVFF  FE6,553
....................          memcpy(&global_message_queue[n], &global_message_queue[n-1], sizeof(&global_message_queue[n])); 
04F96:  MOVF   x51,W
04F98:  MULLW  08
04F9A:  MOVF   FF3,W
04F9C:  CLRF   03
04F9E:  ADDLW  9F
04FA0:  MOVWF  01
04FA2:  MOVLW  04
04FA4:  ADDWFC 03,F
04FA6:  MOVFF  01,55A
04FAA:  MOVFF  03,55B
04FAE:  MOVLW  01
04FB0:  SUBWF  x51,W
04FB2:  MULLW  08
04FB4:  MOVF   FF3,W
04FB6:  CLRF   03
04FB8:  ADDLW  9F
04FBA:  MOVWF  01
04FBC:  MOVLW  04
04FBE:  ADDWFC 03,F
04FC0:  MOVFF  01,55C
04FC4:  MOVFF  03,55D
04FC8:  MOVFF  55B,FEA
04FCC:  MOVFF  55A,FE9
04FD0:  MOVFF  03,FE2
04FD4:  MOVFF  01,FE1
04FD8:  MOVLW  02
04FDA:  MOVWF  01
04FDC:  MOVFF  FE6,FEE
04FE0:  DECFSZ 01,F
04FE2:  BRA    4FDC
....................          memcpy(&global_message_queue[n-1], &temp_message_queue_item, sizeof(&global_message_queue[n-1])); 
04FE4:  MOVLW  01
04FE6:  SUBWF  x51,W
04FE8:  MULLW  08
04FEA:  MOVF   FF3,W
04FEC:  CLRF   03
04FEE:  ADDLW  9F
04FF0:  MOVWF  01
04FF2:  MOVLW  04
04FF4:  ADDWFC 03,F
04FF6:  MOVFF  03,FEA
04FFA:  MOVFF  01,FE9
04FFE:  MOVFF  552,FEE
05002:  MOVFF  553,FEE
....................       } 
05006:  BRA    500E
....................       //item is in the proper place (assuming queue always sorted properly) 
....................       else    
....................       {    
....................          return; 
05008:  MOVLB  4
0500A:  BRA    5014
0500C:  MOVLB  5
....................       } 
0500E:  DECF   x51,F
05010:  BRA    4F04
05012:  MOVLB  4
....................    }     
....................    return; 
05014:  MOVLB  0
05016:  RETURN 0
.................... }                        
....................  
.................... void push_message_queue_ISR(uint8_t message_type) 
.................... // pushes a new item (attempt 0) into the message queue and sorts it. 
.................... // returns 1 if everything is good, 0 if queue is full 
.................... // message queue ISR only gets called in the pop message queue ISR so it's only resends of messages 
.................... //    (don't have to worry about error messages getting screwed up because of duplicate rejection logic) 
.................... { 
....................    uint8_t n; 
....................    struct MessageQueueItem temp_message_queue_item; 
....................    
....................    //if queue is full, return 0 
....................    if (global_current_message_queue_location == (MAX_MESSAGE_QUEUE_ITEMS - 1)) 
*
00BC0:  MOVLB  4
00BC2:  MOVF   xEF,W
00BC4:  SUBLW  09
00BC6:  BNZ   0BCA
....................    { 
....................       return; 
00BC8:  BRA    0E38
....................    } 
....................     
....................    // if you're trying to add an error message... 
....................    if (message_type == MSG_MOTE_ERROR_MSG) 
00BCA:  MOVLB  5
00BCC:  MOVF   x9B,W
00BCE:  SUBLW  A0
00BD0:  BNZ   0C6C
....................    { 
....................       // look through the current queue 
....................       for (n = global_current_message_queue_location; ((n > 0) && (n != 255)); n--) 
00BD2:  MOVFF  4EF,59C
00BD6:  MOVF   x9C,F
00BD8:  BZ    0C6C
00BDA:  INCFSZ x9C,W
00BDC:  BRA    0BE0
00BDE:  BRA    0C6C
....................       { 
....................          // if there is already another error message on the queue, replace it 
....................          if (global_message_queue[n].message_type == MSG_MOTE_ERROR_MSG) 
00BE0:  MOVF   x9C,W
00BE2:  MULLW  08
00BE4:  MOVF   FF3,W
00BE6:  CLRF   xA6
00BE8:  MOVWF  xA5
00BEA:  MOVLW  04
00BEC:  ADDWF  xA5,W
00BEE:  MOVWF  01
00BF0:  MOVLW  00
00BF2:  ADDWFC xA6,W
00BF4:  MOVWF  03
00BF6:  MOVF   01,W
00BF8:  ADDLW  9F
00BFA:  MOVWF  FE9
00BFC:  MOVLW  04
00BFE:  ADDWFC 03,W
00C00:  MOVWF  FEA
00C02:  MOVF   FEF,W
00C04:  SUBLW  A0
00C06:  BNZ   0C68
....................          { 
....................             // increase the mote sequence number (new message) 
....................             // the ack from the previous one will basically get ignored 
....................             global_message_queue[n].msg_seq = ++mote_msgSEQ; 
00C08:  MOVF   x9C,W
00C0A:  MULLW  08
00C0C:  MOVF   FF3,W
00C0E:  CLRF   xA6
00C10:  MOVWF  xA5
00C12:  MOVLW  05
00C14:  ADDWF  xA5,W
00C16:  MOVWF  01
00C18:  MOVLW  00
00C1A:  ADDWFC xA6,W
00C1C:  MOVWF  03
00C1E:  MOVF   01,W
00C20:  ADDLW  9F
00C22:  MOVWF  FE9
00C24:  MOVLW  04
00C26:  ADDWFC 03,W
00C28:  MOVWF  FEA
00C2A:  MOVLB  3
00C2C:  INCF   x5D,F
00C2E:  BTFSC  FD8.2
00C30:  INCF   x5E,F
00C32:  MOVFF  35E,FEC
00C36:  MOVF   FED,F
00C38:  MOVFF  35D,FEF
....................             // reset the attempts to 0 (new message) 
....................             global_message_queue[n].attempt_num = 0; 
00C3C:  MOVLB  5
00C3E:  MOVF   x9C,W
00C40:  MULLW  08
00C42:  MOVF   FF3,W
00C44:  CLRF   xA6
00C46:  MOVWF  xA5
00C48:  MOVLW  07
00C4A:  ADDWF  xA5,W
00C4C:  MOVWF  01
00C4E:  MOVLW  00
00C50:  ADDWFC xA6,W
00C52:  MOVWF  03
00C54:  MOVF   01,W
00C56:  ADDLW  9F
00C58:  MOVWF  FE9
00C5A:  MOVLW  04
00C5C:  ADDWFC 03,W
00C5E:  MOVWF  FEA
00C60:  CLRF   FEF
....................             return; 
00C62:  MOVLB  4
00C64:  BRA    0E38
00C66:  MOVLB  5
....................          } 
00C68:  DECF   x9C,F
00C6A:  BRA    0BD6
....................       } 
....................    } 
....................     
....................    // increment the queue location and mote message sequence (always first attempt 
....................    //    at a message in this routine 
....................    global_current_message_queue_location++; 
00C6C:  MOVLB  4
00C6E:  INCF   xEF,F
....................    mote_msgSEQ++; 
00C70:  MOVLB  3
00C72:  INCF   x5D,F
00C74:  BTFSC  FD8.2
00C76:  INCF   x5E,F
....................     
....................    //set the new item at the top of the queue (will be sorted in a sec) 
....................    global_message_queue[global_current_message_queue_location].time_to_send = global_rtc_time; 
00C78:  MOVLB  4
00C7A:  MOVF   xEF,W
00C7C:  MULLW  08
00C7E:  MOVF   FF3,W
00C80:  MOVLB  5
00C82:  CLRF   xA6
00C84:  MOVWF  xA5
00C86:  MOVLW  9F
00C88:  ADDWF  xA5,W
00C8A:  MOVWF  FE9
00C8C:  MOVLW  04
00C8E:  ADDWFC xA6,W
00C90:  MOVWF  FEA
00C92:  MOVFF  85,FEF
00C96:  MOVFF  86,FEC
00C9A:  MOVFF  87,FEC
00C9E:  MOVFF  88,FEC
....................    global_message_queue[global_current_message_queue_location].message_type = message_type; 
00CA2:  MOVLB  4
00CA4:  MOVF   xEF,W
00CA6:  MULLW  08
00CA8:  MOVF   FF3,W
00CAA:  MOVLB  5
00CAC:  CLRF   xA6
00CAE:  MOVWF  xA5
00CB0:  MOVLW  04
00CB2:  ADDWF  xA5,W
00CB4:  MOVWF  01
00CB6:  MOVLW  00
00CB8:  ADDWFC xA6,W
00CBA:  MOVWF  03
00CBC:  MOVF   01,W
00CBE:  ADDLW  9F
00CC0:  MOVWF  FE9
00CC2:  MOVLW  04
00CC4:  ADDWFC 03,W
00CC6:  MOVWF  FEA
00CC8:  MOVFF  59B,FEF
....................    global_message_queue[global_current_message_queue_location].msg_seq = mote_msgSEQ; 
00CCC:  MOVLB  4
00CCE:  MOVF   xEF,W
00CD0:  MULLW  08
00CD2:  MOVF   FF3,W
00CD4:  MOVLB  5
00CD6:  CLRF   xA6
00CD8:  MOVWF  xA5
00CDA:  MOVLW  05
00CDC:  ADDWF  xA5,W
00CDE:  MOVWF  01
00CE0:  MOVLW  00
00CE2:  ADDWFC xA6,W
00CE4:  MOVWF  03
00CE6:  MOVF   01,W
00CE8:  ADDLW  9F
00CEA:  MOVWF  FE9
00CEC:  MOVLW  04
00CEE:  ADDWFC 03,W
00CF0:  MOVWF  FEA
00CF2:  MOVFF  35E,FEC
00CF6:  MOVF   FED,F
00CF8:  MOVFF  35D,FEF
....................    global_message_queue[global_current_message_queue_location].attempt_num = 0; 
00CFC:  MOVLB  4
00CFE:  MOVF   xEF,W
00D00:  MULLW  08
00D02:  MOVF   FF3,W
00D04:  MOVLB  5
00D06:  CLRF   xA6
00D08:  MOVWF  xA5
00D0A:  MOVLW  07
00D0C:  ADDWF  xA5,W
00D0E:  MOVWF  01
00D10:  MOVLW  00
00D12:  ADDWFC xA6,W
00D14:  MOVWF  03
00D16:  MOVF   01,W
00D18:  ADDLW  9F
00D1A:  MOVWF  FE9
00D1C:  MOVLW  04
00D1E:  ADDWFC 03,W
00D20:  MOVWF  FEA
00D22:  CLRF   FEF
....................     
....................    //starting at the new current queue location, sort through the queue 
....................    //until the new item is in the right place 
....................    for (n = global_current_message_queue_location; n > 0; n--) 
00D24:  MOVFF  4EF,59C
00D28:  MOVF   x9C,F
00D2A:  BTFSC  FD8.2
00D2C:  BRA    0E36
....................    { 
....................       //if queue items are not sorted properly 
....................       if (global_message_queue[n].time_to_send > global_message_queue[n-1].time_to_send) 
00D2E:  MOVF   x9C,W
00D30:  MULLW  08
00D32:  MOVF   FF3,W
00D34:  CLRF   xA6
00D36:  MOVWF  xA5
00D38:  MOVLW  9F
00D3A:  ADDWF  xA5,W
00D3C:  MOVWF  FE9
00D3E:  MOVLW  04
00D40:  ADDWFC xA6,W
00D42:  MOVWF  FEA
00D44:  MOVFF  FEF,5A7
00D48:  MOVFF  FEC,5A8
00D4C:  MOVFF  FEC,5A9
00D50:  MOVFF  FEC,5AA
00D54:  MOVLW  01
00D56:  SUBWF  x9C,W
00D58:  MULLW  08
00D5A:  MOVF   FF3,W
00D5C:  CLRF   xAC
00D5E:  MOVWF  xAB
00D60:  MOVLW  9F
00D62:  ADDWF  xAB,W
00D64:  MOVWF  FE9
00D66:  MOVLW  04
00D68:  ADDWFC xAC,W
00D6A:  MOVWF  FEA
00D6C:  MOVFF  FEF,00
00D70:  MOVFF  FEC,01
00D74:  MOVFF  FEC,02
00D78:  MOVFF  FEC,03
00D7C:  MOVF   03,W
00D7E:  SUBWF  xAA,W
00D80:  BNC   0E2C
00D82:  BNZ   0D9A
00D84:  MOVF   02,W
00D86:  SUBWF  xA9,W
00D88:  BNC   0E2C
00D8A:  BNZ   0D9A
00D8C:  MOVF   01,W
00D8E:  SUBWF  xA8,W
00D90:  BNC   0E2C
00D92:  BNZ   0D9A
00D94:  MOVF   xA7,W
00D96:  SUBWF  00,W
00D98:  BC    0E2C
....................       { 
....................          //do a swap 
....................          memcpy(&temp_message_queue_item, &global_message_queue[n], sizeof(&temp_message_queue_item)); 
00D9A:  MOVF   x9C,W
00D9C:  MULLW  08
00D9E:  MOVF   FF3,W
00DA0:  CLRF   03
00DA2:  ADDLW  9F
00DA4:  MOVWF  01
00DA6:  MOVLW  04
00DA8:  ADDWFC 03,F
00DAA:  MOVFF  03,FE2
00DAE:  MOVFF  01,FE1
00DB2:  MOVFF  FE6,59D
00DB6:  MOVFF  FE6,59E
....................          memcpy(&global_message_queue[n], &global_message_queue[n-1], sizeof(&global_message_queue[n])); 
00DBA:  MOVF   x9C,W
00DBC:  MULLW  08
00DBE:  MOVF   FF3,W
00DC0:  CLRF   03
00DC2:  ADDLW  9F
00DC4:  MOVWF  01
00DC6:  MOVLW  04
00DC8:  ADDWFC 03,F
00DCA:  MOVFF  01,5A5
00DCE:  MOVFF  03,5A6
00DD2:  MOVLW  01
00DD4:  SUBWF  x9C,W
00DD6:  MULLW  08
00DD8:  MOVF   FF3,W
00DDA:  CLRF   03
00DDC:  ADDLW  9F
00DDE:  MOVWF  01
00DE0:  MOVLW  04
00DE2:  ADDWFC 03,F
00DE4:  MOVFF  01,5A7
00DE8:  MOVFF  03,5A8
00DEC:  MOVFF  5A6,FEA
00DF0:  MOVFF  5A5,FE9
00DF4:  MOVFF  03,FE2
00DF8:  MOVFF  01,FE1
00DFC:  MOVLW  02
00DFE:  MOVWF  01
00E00:  MOVFF  FE6,FEE
00E04:  DECFSZ 01,F
00E06:  BRA    0E00
....................          memcpy(&global_message_queue[n-1], &temp_message_queue_item, sizeof(&global_message_queue[n-1])); 
00E08:  MOVLW  01
00E0A:  SUBWF  x9C,W
00E0C:  MULLW  08
00E0E:  MOVF   FF3,W
00E10:  CLRF   03
00E12:  ADDLW  9F
00E14:  MOVWF  01
00E16:  MOVLW  04
00E18:  ADDWFC 03,F
00E1A:  MOVFF  03,FEA
00E1E:  MOVFF  01,FE9
00E22:  MOVFF  59D,FEE
00E26:  MOVFF  59E,FEE
....................       } 
00E2A:  BRA    0E32
....................       //item is in the proper place (assuming queue always sorted properly) 
....................       else 
....................       { 
....................          return; 
00E2C:  MOVLB  4
00E2E:  BRA    0E38
00E30:  MOVLB  5
....................       } 
00E32:  DECF   x9C,F
00E34:  BRA    0D28
00E36:  MOVLB  4
....................    } 
....................    return; 
00E38:  MOVLB  0
00E3A:  RETURN 0
.................... } 
....................  
.................... void remove_message_queue_item(uint16_t msg_seq) 
.................... { 
.................... // Finds the message with the passed msg_seq and removes it from the queue, 
.................... //    shifting all other messages in the queue up 
.................... // Returns 1 if message removed, 0 if not found 
.................... // This function is ONLY run as a result of an ack'd unsolicted message                      
....................  
....................    uint8_t n, m; 
....................     
....................    // no items in the queue (current location is 0-1) 
....................    if (global_current_message_queue_location == 255) 
*
05A04:  MOVLB  4
05A06:  INCFSZ xEF,W
05A08:  BRA    5A0C
....................    {   
....................  
....................       return;   
05A0A:  BRA    5B5C
....................    } 
....................     
....................    // search through the message queue from 0 to the current top of queue 
....................    for (n = 0; n <= global_current_message_queue_location; n++) 
05A0C:  MOVLB  5
05A0E:  CLRF   x50
05A10:  MOVF   x50,W
05A12:  MOVLB  4
05A14:  SUBWF  xEF,W
05A16:  BTFSS  FD8.0
05A18:  BRA    5B5C
....................    { 
....................       // if you find the matching message 
....................       if (global_message_queue[n].msg_seq == msg_seq) 
05A1A:  MOVLB  5
05A1C:  MOVF   x50,W
05A1E:  MULLW  08
05A20:  MOVF   FF3,W
05A22:  CLRF   x53
05A24:  MOVWF  x52
05A26:  MOVLW  05
05A28:  ADDWF  x52,W
05A2A:  MOVWF  01
05A2C:  MOVLW  00
05A2E:  ADDWFC x53,W
05A30:  MOVWF  03
05A32:  MOVF   01,W
05A34:  ADDLW  9F
05A36:  MOVWF  FE9
05A38:  MOVLW  04
05A3A:  ADDWFC 03,W
05A3C:  MOVWF  FEA
05A3E:  MOVFF  FEC,553
05A42:  MOVF   FED,F
05A44:  MOVFF  FEF,552
05A48:  MOVF   x4E,W
05A4A:  SUBWF  x52,W
05A4C:  BTFSS  FD8.2
05A4E:  BRA    5B56
05A50:  MOVF   x4F,W
05A52:  SUBWF  x53,W
05A54:  BTFSS  FD8.2
05A56:  BRA    5B56
....................       { 
....................          // since this is only run from ack'd messages, we can assume this 
....................          //    means the error message was recieved and we can clear the error 
....................          //    bitfield 
....................          if (global_message_queue[n].message_type == MSG_MOTE_ERROR_MSG) 
05A58:  MOVF   x50,W
05A5A:  MULLW  08
05A5C:  MOVF   FF3,W
05A5E:  CLRF   x53
05A60:  MOVWF  x52
05A62:  MOVLW  04
05A64:  ADDWF  x52,W
05A66:  MOVWF  01
05A68:  MOVLW  00
05A6A:  ADDWFC x53,W
05A6C:  MOVWF  03
05A6E:  MOVF   01,W
05A70:  ADDLW  9F
05A72:  MOVWF  FE9
05A74:  MOVLW  04
05A76:  ADDWFC 03,W
05A78:  MOVWF  FEA
05A7A:  MOVF   FEF,W
05A7C:  SUBLW  A0
05A7E:  BNZ   5A8C
....................          { 
....................             global_error_message_bitfield = 0; 
05A80:  MOVLB  4
05A82:  CLRF   xF3
05A84:  CLRF   xF2
05A86:  CLRF   xF1
05A88:  CLRF   xF0
05A8A:  MOVLB  5
....................          } 
....................          // shift everything over 1 place starting by overwriting the item 
....................          //    to remove and ending by copying the top of the queue to the next item 
....................          for (m = n; m < (MAX_MESSAGE_QUEUE_ITEMS - 1); m++) 
05A8C:  MOVFF  550,551
05A90:  MOVF   x51,W
05A92:  SUBLW  08
05A94:  BNC   5B1C
....................          { 
....................             memcpy(&global_message_queue[n], global_message_queue[n+1], sizeof(&global_message_queue[n])); 
05A96:  MOVF   x50,W
05A98:  MULLW  08
05A9A:  MOVF   FF3,W
05A9C:  CLRF   03
05A9E:  ADDLW  9F
05AA0:  MOVWF  01
05AA2:  MOVLW  04
05AA4:  ADDWFC 03,F
05AA6:  MOVFF  01,552
05AAA:  MOVFF  03,553
05AAE:  MOVLW  01
05AB0:  ADDWF  x50,W
05AB2:  MULLW  08
05AB4:  MOVF   FF3,W
05AB6:  CLRF   03
05AB8:  ADDLW  9F
05ABA:  MOVWF  FE9
05ABC:  MOVLW  04
05ABE:  ADDWFC 03,W
05AC0:  MOVWF  FEA
05AC2:  MOVF   FEE,F
05AC4:  MOVF   FEE,F
05AC6:  MOVF   FEE,F
05AC8:  MOVF   FEE,F
05ACA:  MOVF   FEE,F
05ACC:  MOVF   FEE,F
05ACE:  MOVFF  FEC,55B
05AD2:  MOVF   FED,F
05AD4:  MOVFF  FEF,55A
05AD8:  MOVF   FED,F
05ADA:  MOVFF  FEF,559
05ADE:  MOVF   FED,F
05AE0:  MOVFF  FEF,558
05AE4:  MOVF   FED,F
05AE6:  MOVFF  FEF,557
05AEA:  MOVF   FED,F
05AEC:  MOVFF  FEF,556
05AF0:  MOVF   FED,F
05AF2:  MOVFF  FEF,555
05AF6:  MOVF   FED,F
05AF8:  MOVFF  FEF,554
05AFC:  MOVFF  553,FEA
05B00:  MOVFF  01,FE9
05B04:  MOVFF  555,FE2
05B08:  MOVFF  554,FE1
05B0C:  MOVLW  02
05B0E:  MOVWF  01
05B10:  MOVFF  FE6,FEE
05B14:  DECFSZ 01,F
05B16:  BRA    5B10
05B18:  INCF   x51,F
05B1A:  BRA    5A90
....................          } 
....................          // clear out the last item 
....................          memset(&global_message_queue[global_current_message_queue_location],EMPTY_MESSAGE_QUEUE,sizeof(&global_message_queue[global_current_message_queue_location])); 
05B1C:  MOVLB  4
05B1E:  MOVF   xEF,W
05B20:  MULLW  08
05B22:  MOVF   FF3,W
05B24:  CLRF   03
05B26:  ADDLW  9F
05B28:  MOVWF  01
05B2A:  MOVLW  04
05B2C:  ADDWFC 03,F
05B2E:  MOVFF  01,552
05B32:  MOVLB  5
05B34:  MOVFF  03,553
05B38:  MOVFF  03,FEA
05B3C:  MOVFF  01,FE9
05B40:  CLRF   00
05B42:  CLRF   02
05B44:  MOVLW  02
05B46:  MOVWF  01
05B48:  MOVLB  0
05B4A:  CALL   20D6
....................          // decrement the message queue current position 
....................          global_current_message_queue_location--;  
05B4E:  MOVLB  4
05B50:  DECF   xEF,F
....................          return; 
05B52:  BRA    5B5C
05B54:  MOVLB  5
....................       } 
05B56:  INCF   x50,F
05B58:  BRA    5A10
05B5A:  MOVLB  4
....................    } 
....................    return;                      
05B5C:  MOVLB  0
05B5E:  GOTO   6D20 (RETURN)
.................... } 
....................  
.................... void remove_message_queue_item_ISR(uint16_t msg_seq) 
.................... { 
.................... // Finds the message with the passed msg_seq and removes it from the queue, 
.................... //    shifting all other messages in the queue up 
.................... // Returns 1 if message removed, 0 if not found 
.................... // This function is ONLY run as a result of a message not getting ack'd after 
.................... //    being resent numerous times 
....................  
....................    uint8_t n, m; 
....................  
....................    // no items in the queue (current location is 0-1) 
....................    if (global_current_message_queue_location == 255) 
*
020F0:  MOVLB  4
020F2:  INCFSZ xEF,W
020F4:  BRA    20F8
....................    { 
....................       return;   
020F6:  BRA    220E
....................    } 
....................     
....................    // search through the message queue from 0 to the current top of queue 
....................    for (n = 0; n <= global_current_message_queue_location; n++) 
020F8:  MOVLB  5
020FA:  CLRF   x8A
020FC:  MOVF   x8A,W
020FE:  MOVLB  4
02100:  SUBWF  xEF,W
02102:  BTFSS  FD8.0
02104:  BRA    220E
....................    { 
....................       // if you find the matching message 
....................       if (global_message_queue[n].msg_seq == msg_seq) 
02106:  MOVLB  5
02108:  MOVF   x8A,W
0210A:  MULLW  08
0210C:  MOVF   FF3,W
0210E:  CLRF   x8D
02110:  MOVWF  x8C
02112:  MOVLW  05
02114:  ADDWF  x8C,W
02116:  MOVWF  01
02118:  MOVLW  00
0211A:  ADDWFC x8D,W
0211C:  MOVWF  03
0211E:  MOVF   01,W
02120:  ADDLW  9F
02122:  MOVWF  FE9
02124:  MOVLW  04
02126:  ADDWFC 03,W
02128:  MOVWF  FEA
0212A:  MOVFF  FEC,58D
0212E:  MOVF   FED,F
02130:  MOVFF  FEF,58C
02134:  MOVF   x88,W
02136:  SUBWF  x8C,W
02138:  BNZ   2208
0213A:  MOVF   x89,W
0213C:  SUBWF  x8D,W
0213E:  BNZ   2208
....................       { 
....................          // shift everything over 1 place starting by overwriting the item 
....................          //    to remove and ending by copying the top of the queue to the next item 
....................          for (m = n; m < (MAX_MESSAGE_QUEUE_ITEMS - 1); m++) 
02140:  MOVFF  58A,58B
02144:  MOVF   x8B,W
02146:  SUBLW  08
02148:  BNC   21D0
....................          { 
....................             memcpy(&global_message_queue[n], global_message_queue[n+1], sizeof(&global_message_queue[n])); 
0214A:  MOVF   x8A,W
0214C:  MULLW  08
0214E:  MOVF   FF3,W
02150:  CLRF   03
02152:  ADDLW  9F
02154:  MOVWF  01
02156:  MOVLW  04
02158:  ADDWFC 03,F
0215A:  MOVFF  01,58C
0215E:  MOVFF  03,58D
02162:  MOVLW  01
02164:  ADDWF  x8A,W
02166:  MULLW  08
02168:  MOVF   FF3,W
0216A:  CLRF   03
0216C:  ADDLW  9F
0216E:  MOVWF  FE9
02170:  MOVLW  04
02172:  ADDWFC 03,W
02174:  MOVWF  FEA
02176:  MOVF   FEE,F
02178:  MOVF   FEE,F
0217A:  MOVF   FEE,F
0217C:  MOVF   FEE,F
0217E:  MOVF   FEE,F
02180:  MOVF   FEE,F
02182:  MOVFF  FEC,595
02186:  MOVF   FED,F
02188:  MOVFF  FEF,594
0218C:  MOVF   FED,F
0218E:  MOVFF  FEF,593
02192:  MOVF   FED,F
02194:  MOVFF  FEF,592
02198:  MOVF   FED,F
0219A:  MOVFF  FEF,591
0219E:  MOVF   FED,F
021A0:  MOVFF  FEF,590
021A4:  MOVF   FED,F
021A6:  MOVFF  FEF,58F
021AA:  MOVF   FED,F
021AC:  MOVFF  FEF,58E
021B0:  MOVFF  58D,FEA
021B4:  MOVFF  01,FE9
021B8:  MOVFF  58F,FE2
021BC:  MOVFF  58E,FE1
021C0:  MOVLW  02
021C2:  MOVWF  01
021C4:  MOVFF  FE6,FEE
021C8:  DECFSZ 01,F
021CA:  BRA    21C4
021CC:  INCF   x8B,F
021CE:  BRA    2144
....................          } 
....................          // clear out the last item 
....................          memset(&global_message_queue[global_current_message_queue_location],EMPTY_MESSAGE_QUEUE,sizeof(&global_message_queue[global_current_message_queue_location])); 
021D0:  MOVLB  4
021D2:  MOVF   xEF,W
021D4:  MULLW  08
021D6:  MOVF   FF3,W
021D8:  CLRF   03
021DA:  ADDLW  9F
021DC:  MOVWF  01
021DE:  MOVLW  04
021E0:  ADDWFC 03,F
021E2:  MOVFF  01,58C
021E6:  MOVLB  5
021E8:  MOVFF  03,58D
021EC:  MOVFF  03,FEA
021F0:  MOVFF  01,FE9
021F4:  CLRF   00
021F6:  CLRF   02
021F8:  MOVLW  02
021FA:  MOVWF  01
021FC:  MOVLB  0
021FE:  RCALL  20D6
....................          // decrement the message queue current position 
....................          global_current_message_queue_location--; 
02200:  MOVLB  4
02202:  DECF   xEF,F
....................          return; 
02204:  BRA    220E
02206:  MOVLB  5
....................       } 
02208:  INCF   x8A,F
0220A:  BRA    20FC
0220C:  MOVLB  4
....................    } 
....................    return; 
0220E:  MOVLB  0
02210:  GOTO   2708 (RETURN)
.................... } 
....................     
....................  
.................... #include "util.h" 
.................... /* This file contains all functions related to PIC functions 
....................  * 
....................  * 
....................  * 
....................  * 
....................  * 
....................  */ 
....................  
.................... /****************************************/ 
.................... void flash_leds(uint8_t num_of_flashes)                           
.................... { 
....................    uint8_t  n; 
....................     
....................    for (n = 0; n < num_of_flashes; n++) 
....................    { 
....................       LED1_ON 
....................       LED2_ON 
....................       setup_T0_int(T0_50MS); 
....................       while (!TMR0IF); 
....................        
....................       LED1_OFF    
....................       LED2_OFF                       
....................       if (n == (num_of_flashes - 1)) 
....................       { 
....................          return; 
....................       } 
....................       setup_T0_int(T0_50MS); 
....................       while (!TMR0IF);  
....................    }       
.................... } 
.................... void flash_leds_ISR(uint8_t num_of_flashes) 
.................... { 
....................    uint8_t  n; 
....................     
....................    for (n = 0; n < num_of_flashes; n++) 
....................    { 
....................       LED1_ON 
....................       LED2_ON 
....................       setup_T4_int(T4_64MS); 
....................       while (!TMR4IF); 
....................       LED1_OFF 
....................       LED2_OFF 
....................       setup_T4_int(T4_64MS); 
....................       while (!TMR4IF); 
....................    }       
.................... } 
....................  
....................  
.................... void flash_led_1(uint8_t num_of_flashes) 
.................... { 
....................    uint8_t  n; 
....................     
....................    for (n = 0; n < num_of_flashes; n++) 
....................    { 
....................       LED1_ON 
....................       setup_T0_int(T0_100MS); 
....................       while (!TMR0IF); 
....................        
....................       LED1_OFF 
....................       setup_T0_int(T0_100MS); 
....................       while (!TMR0IF);  
....................    }       
.................... } 
....................  
.................... void flash_led_2(uint8_t num_of_flashes) 
.................... { 
....................    uint8_t  n; 
....................     
....................    for (n = 0; n < num_of_flashes; n++) 
....................    { 
....................       LED2_ON 
....................       setup_T0_int(T0_100MS); 
....................       while (!TMR0IF); 
....................        
....................       LED1_OFF 
....................       setup_T0_int(T0_100MS); 
....................       while (!TMR0IF);  
....................    }       
.................... } 
....................  
.................... void happy_lites(void) 
.................... { 
.................... // blink the two leds in a fashion to let the operator know, e.g., 
.................... // that the SW1-initiated search process was successful 
....................    uint8_t  n; 
....................     
....................    for (n=0; n<4; n++) 
*
04ADC:  MOVLB  5
04ADE:  CLRF   x5F
04AE0:  MOVF   x5F,W
04AE2:  SUBLW  03
04AE4:  BNC   4B2A
....................    { 
....................       LED1_ON 
04AE6:  CLRF   F62
04AE8:  MOVLW  E7
04AEA:  MOVWF  F93
04AEC:  BCF    F8A.4
....................        
....................       setup_T0_int(T0_250MS); 
04AEE:  MOVLW  FC
04AF0:  MOVWF  x65
04AF2:  MOVLW  30
04AF4:  MOVWF  x64
04AF6:  MOVLB  0
04AF8:  CALL   356C
....................       while (!TMR0IF); 
04AFC:  BTFSS  FF2.2
04AFE:  BRA    4AFC
....................        
....................       LED1_OFF 
04B00:  MOVLW  F7
04B02:  MOVWF  F93
04B04:  BCF    FF2.0
04B06:  BSF    FF2.3
04B08:  MOVLW  FF
04B0A:  IORWF  F62,F
....................       LED2_ON 
04B0C:  BCF    F89.2
....................        
....................       setup_T0_int(T0_250MS); 
04B0E:  MOVLW  FC
04B10:  MOVLB  5
04B12:  MOVWF  x65
04B14:  MOVLW  30
04B16:  MOVWF  x64
04B18:  MOVLB  0
04B1A:  CALL   356C
....................       while (!TMR0IF); 
04B1E:  BTFSS  FF2.2
04B20:  BRA    4B1E
....................        
....................       LED2_OFF 
04B22:  BSF    F89.2
04B24:  MOVLB  5
04B26:  INCF   x5F,F
04B28:  BRA    4AE0
....................    } 
04B2A:  MOVLB  0
04B2C:  RETURN 0
.................... } 
....................  
.................... char *word_to_4dig_new (uint16_t xword) 
.................... { 
....................    /* Takes a uint16 and converts it to a 4 digit result 
....................     * that is stored in a static char pointer 
....................     */ 
....................      
....................    uint16_t temp_u16; 
....................    static char result[4]; 
....................    ldiv_t      lidiv_temp; 
....................    div_t       idiv_temp; 
....................     
....................    if (xword > 9999) 
....................       return 0; 
....................    else 
....................    {    
....................       lidiv_temp=ldiv(xword,1000); 
....................       result[3] = '0' + lidiv_temp.quot; 
....................       temp_u16 = lidiv_temp.rem; 
....................       lidiv_temp=ldiv(temp_u16,(uint16_t)(100)); 
....................       result[2] = '0' + lidiv_temp.quot; 
....................       idiv_temp = div((uint8_t)(lidiv_temp.rem),10); 
....................       result[1] = '0' + idiv_temp.quot; 
....................       result[0] = '0' + idiv_temp.rem; 
....................       return result; 
....................    } 
.................... } 
.................... uint16_t convert_rpm_to_period(uint16_t rpm) 
.................... { 
....................    uint16_t period; 
....................    return period; 
.................... } 
.................... uint16_t convert_period_to_rpm(uint16_t period) 
.................... { 
....................    uint32_t rpm_32; 
....................    uint16_t rpm_16; 
....................     
....................    rpm_32 = CCP_PER_RPM/(make32(0,0,make8(period,1), make8(period,0))); 
*
05BA4:  MOVFF  554,55B
05BA8:  MOVFF  553,55C
05BAC:  MOVLB  5
05BAE:  CLRF   x60
05BB0:  CLRF   x5F
05BB2:  MOVFF  554,55E
05BB6:  MOVFF  553,55D
05BBA:  BCF    FD8.1
05BBC:  CLRF   19
05BBE:  BTFSC  FF2.7
05BC0:  BSF    19.7
05BC2:  BCF    FF2.7
05BC4:  MOVLW  99
05BC6:  MOVWF  xA0
05BC8:  MOVWF  x9F
05BCA:  MOVWF  x9E
05BCC:  MOVLW  9A
05BCE:  MOVWF  x9D
05BD0:  MOVFF  560,5A4
05BD4:  MOVFF  55F,5A3
05BD8:  MOVFF  554,5A2
05BDC:  MOVFF  553,5A1
05BE0:  MOVLB  0
05BE2:  CALL   2388
05BE6:  BTFSC  19.7
05BE8:  BSF    FF2.7
05BEA:  MOVFF  03,558
05BEE:  MOVFF  02,557
05BF2:  MOVFF  01,556
05BF6:  MOVFF  00,555
....................    rpm_16 = make16(make8(rpm_32,3), make8(rpm_32,2)); 
05BFA:  MOVFF  558,55A
05BFE:  MOVFF  557,559
....................    if (bit_test(rpm_32, 15)) rpm_16++;  
05C02:  MOVLB  5
05C04:  BTFSS  x56.7
05C06:  BRA    5C0E
05C08:  INCF   x59,F
05C0A:  BTFSC  FD8.2
05C0C:  INCF   x5A,F
....................    return rpm_16; 
05C0E:  MOVFF  559,01
05C12:  MOVFF  55A,02
05C16:  MOVLB  0
05C18:  RETURN 0
.................... } 
.................... uint16_t convert_period_to_rpm_ISR(uint16_t period) 
.................... { 
....................    uint32_t rpm_32; 
....................    uint16_t rpm_16; 
....................     
....................    rpm_32 = CCP_PER_RPM/(make32(0,0,make8(period,1), make8(period,0))); 
*
0241C:  MOVFF  590,597
02420:  MOVFF  58F,598
02424:  MOVLB  5
02426:  CLRF   x9C
02428:  CLRF   x9B
0242A:  MOVFF  590,59A
0242E:  MOVFF  58F,599
02432:  BCF    FD8.1
02434:  MOVLW  99
02436:  MOVWF  xA0
02438:  MOVWF  x9F
0243A:  MOVWF  x9E
0243C:  MOVLW  9A
0243E:  MOVWF  x9D
02440:  MOVFF  59C,5A4
02444:  MOVFF  59B,5A3
02448:  MOVFF  590,5A2
0244C:  MOVFF  58F,5A1
02450:  MOVLB  0
02452:  RCALL  2388
02454:  MOVFF  03,594
02458:  MOVFF  02,593
0245C:  MOVFF  01,592
02460:  MOVFF  00,591
....................    rpm_16 = make16(make8(rpm_32,3), make8(rpm_32,2)); 
02464:  MOVFF  594,596
02468:  MOVFF  593,595
....................    if (bit_test(rpm_32, 15)) rpm_16++;  
0246C:  MOVLB  5
0246E:  BTFSS  x92.7
02470:  BRA    2478
02472:  INCF   x95,F
02474:  BTFSC  FD8.2
02476:  INCF   x96,F
....................    return rpm_16; 
02478:  MOVFF  595,01
0247C:  MOVFF  596,02
02480:  MOVLB  0
02482:  GOTO   2584 (RETURN)
.................... } 
.................... uint8_t  hi2asc(uint8_t xbyte) 
.................... { 
....................    xbyte >>= 4; 
*
03012:  MOVLB  5
03014:  SWAPF  x60,F
03016:  MOVLW  0F
03018:  ANDWF  x60,F
....................    if (xbyte < 0x0A) 
0301A:  MOVF   x60,W
0301C:  SUBLW  09
0301E:  BNC   3026
....................       xbyte += 0x30; 
03020:  MOVLW  30
03022:  ADDWF  x60,F
03024:  BRA    302A
....................    else 
....................       xbyte += 0x37; 
03026:  MOVLW  37
03028:  ADDWF  x60,F
....................    return xbyte; 
0302A:  MOVFF  560,01
0302E:  MOVLB  0
03030:  RETURN 0
.................... } 
....................  
....................  
.................... uint8_t  lo2asc(uint8_t xbyte) 
.................... { 
....................    xbyte &= 0x0F; 
03032:  MOVLW  0F
03034:  MOVLB  5
03036:  ANDWF  x60,F
....................    if (xbyte < 0x0A) 
03038:  MOVF   x60,W
0303A:  SUBLW  09
0303C:  BNC   3044
....................       xbyte += 0x30; 
0303E:  MOVLW  30
03040:  ADDWF  x60,F
03042:  BRA    3048
....................    else 
....................       xbyte += 0x37; 
03044:  MOVLW  37
03046:  ADDWF  x60,F
....................    return xbyte; 
03048:  MOVFF  560,01
0304C:  MOVLB  0
0304E:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... void main() 
*
095E2:  CLRF   FF8
095E4:  BCF    FF0.7
095E6:  BCF    FF1.0
095E8:  BCF    FA2.3
095EA:  BCF    FA2.6
095EC:  BSF    F7C.0
095EE:  BCF    F7C.1
095F0:  BSF    F7C.2
095F2:  BSF    FD0.7
095F4:  BSF    07.7
095F6:  BCF    FB8.3
095F8:  MOVLW  01
095FA:  MOVWF  FAF
095FC:  MOVLW  A6
095FE:  MOVWF  FAC
09600:  MOVLW  90
09602:  MOVWF  FAB
09604:  CLRF   4A
09606:  CLRF   49
09608:  CLRF   48
0960A:  CLRF   47
0960C:  CLRF   4C
0960E:  CLRF   4B
09610:  CLRF   4D
09612:  CLRF   4E
09614:  CLRF   54
09616:  CLRF   55
09618:  CLRF   59
0961A:  CLRF   58
0961C:  CLRF   57
0961E:  CLRF   56
09620:  CLRF   5D
09622:  CLRF   5C
09624:  CLRF   5B
09626:  CLRF   5A
09628:  CLRF   5F
0962A:  CLRF   5E
0962C:  CLRF   x61
0962E:  CLRF   x60
09630:  CLRF   x63
09632:  CLRF   x62
09634:  CLRF   x65
09636:  CLRF   x64
09638:  CLRF   x67
0963A:  CLRF   x66
0963C:  CLRF   x69
0963E:  CLRF   x68
09640:  CLRF   x6B
09642:  CLRF   x6A
09644:  CLRF   x6D
09646:  CLRF   x6C
09648:  CLRF   x6F
0964A:  CLRF   x6E
0964C:  CLRF   x83
0964E:  CLRF   x84
09650:  CLRF   x88
09652:  CLRF   x87
09654:  CLRF   x86
09656:  CLRF   x85
09658:  CLRF   x8C
0965A:  CLRF   x8B
0965C:  CLRF   x8A
0965E:  CLRF   x89
09660:  CLRF   x8E
09662:  CLRF   x8D
09664:  CLRF   x9F
09666:  CLRF   xA1
09668:  CLRF   xA0
0966A:  CLRF   xA5
0966C:  MOVLW  64
0966E:  MOVWF  xA4
09670:  CLRF   xA9
09672:  CLRF   xA8
09674:  CLRF   xA7
09676:  CLRF   xA6
09678:  CLRF   xAB
0967A:  CLRF   xAA
0967C:  MOVLW  01
0967E:  MOVWF  xAD
09680:  MOVLW  90
09682:  MOVWF  xAC
09684:  CLRF   xAF
09686:  CLRF   xAE
09688:  MOVLW  01
0968A:  MOVWF  xB1
0968C:  MOVLW  90
0968E:  MOVWF  xB0
09690:  MOVLW  64
09692:  MOVWF  xB2
09694:  MOVWF  xB3
09696:  CLRF   xB5
09698:  CLRF   xB4
0969A:  CLRF   xB7
0969C:  CLRF   xB6
0969E:  MOVLW  06
096A0:  MOVWF  xB8
096A2:  SETF   xBA
096A4:  SETF   xB9
096A6:  MOVLW  20
096A8:  MOVWF  xBC
096AA:  CLRF   xBB
096AC:  MOVLW  05
096AE:  MOVWF  xBE
096B0:  CLRF   xBD
096B2:  MOVWF  xC0
096B4:  CLRF   xBF
096B6:  CLRF   xC2
096B8:  CLRF   xC1
096BA:  CLRF   xC6
096BC:  CLRF   xC5
096BE:  CLRF   xC4
096C0:  CLRF   xC3
096C2:  CLRF   xC7
096C4:  MOVLW  20
096C6:  MOVWF  xC9
096C8:  CLRF   xC8
096CA:  SETF   xCB
096CC:  SETF   xCA
096CE:  CLRF   xCF
096D0:  CLRF   xCE
096D2:  CLRF   xCD
096D4:  CLRF   xCC
096D6:  MOVLB  3
096D8:  CLRF   x49
096DA:  CLRF   x4A
096DC:  CLRF   x57
096DE:  CLRF   x5A
096E0:  CLRF   x5B
096E2:  CLRF   x5C
096E4:  CLRF   x5E
096E6:  CLRF   x5D
096E8:  MOVLW  04
096EA:  MOVWF  x60
096EC:  MOVLW  CD
096EE:  MOVWF  x5F
096F0:  CLRF   x62
096F2:  CLRF   x61
096F4:  CLRF   x63
096F6:  CLRF   x64
096F8:  CLRF   x65
096FA:  SETF   x7A
096FC:  SETF   x94
096FE:  MOVLB  4
09700:  SETF   x21
09702:  SETF   00
09704:  SETF   01
09706:  SETF   02
09708:  SETF   03
0970A:  MOVFF  03,425
0970E:  MOVFF  02,424
09712:  MOVFF  01,423
09716:  MOVFF  00,422
0971A:  SETF   x9E
0971C:  SETF   xEF
0971E:  CLRF   xF3
09720:  CLRF   xF2
09722:  CLRF   xF1
09724:  CLRF   xF0
09726:  CLRF   xF7
09728:  CLRF   xF6
0972A:  CLRF   xF5
0972C:  CLRF   xF4
0972E:  CLRF   xFB
09730:  CLRF   xFA
09732:  CLRF   xF9
09734:  CLRF   xF8
09736:  SETF   xFC
09738:  SETF   xFD
0973A:  MOVLW  10
0973C:  MOVWF  xFF
0973E:  CLRF   xFE
09740:  MOVLW  70
09742:  MOVLB  5
09744:  MOVWF  x01
09746:  CLRF   x00
09748:  CLRF   x03
0974A:  MOVLW  16
0974C:  MOVWF  x02
0974E:  CLRF   x05
09750:  MOVLW  0F
09752:  MOVWF  x04
09754:  CLRF   x07
09756:  MOVWF  x06
09758:  CLRF   x09
0975A:  MOVLW  15
0975C:  MOVWF  x08
0975E:  CLRF   x0B
09760:  MOVLW  12
09762:  MOVWF  x0A
09764:  CLRF   x0D
09766:  MOVLW  0F
09768:  MOVWF  x0C
0976A:  CLRF   x0F
0976C:  MOVLW  1E
0976E:  MOVWF  x0E
09770:  MOVLW  40
09772:  MOVWF  x11
09774:  CLRF   x10
09776:  MOVLW  70
09778:  MOVWF  x13
0977A:  CLRF   x12
0977C:  MOVLW  08
0977E:  MOVWF  x14
09780:  MOVLW  50
09782:  MOVWF  x16
09784:  CLRF   x15
09786:  MOVLW  10
09788:  MOVWF  x18
0978A:  CLRF   x17
0978C:  CLRF   x1A
0978E:  MOVLW  08
09790:  MOVWF  x19
09792:  CLRF   x1C
09794:  MOVLW  78
09796:  MOVWF  x1B
09798:  MOVLW  04
0979A:  MOVWF  x1E
0979C:  MOVLW  B0
0979E:  MOVWF  x1D
097A0:  CLRF   x1F
097A2:  BCF    FB8.3
097A4:  MOVLW  01
097A6:  MOVWF  FAF
097A8:  MOVLW  A6
097AA:  MOVWF  FAC
097AC:  MOVLW  90
097AE:  MOVWF  FAB
097B0:  BCF    FCB.0
097B2:  BCF    FCB.1
097B4:  BCF    FCB.3
097B6:  MOVLW  06
097B8:  MOVWF  FC8
097BA:  MOVLW  28
097BC:  MOVWF  FC6
097BE:  BSF    FC7.7
097C0:  BCF    FC7.6
097C2:  CLRF   x32
097C4:  CLRF   x31
097C6:  CLRF   x34
097C8:  CLRF   x33
097CA:  CLRF   x35
097CC:  CLRF   x36
097CE:  MOVLW  01
097D0:  MOVWF  x37
097D2:  CLRF   x3F
097D4:  CLRF   x3E
097D6:  CLRF   x3D
097D8:  CLRF   x3C
097DA:  CLRF   x41
097DC:  CLRF   x40
097DE:  CLRF   x43
097E0:  CLRF   x42
097E2:  MOVLB  F
097E4:  CLRF   x38
097E6:  CLRF   x39
097E8:  CLRF   x3A
097EA:  CLRF   x3B
097EC:  CLRF   x3C
097EE:  CLRF   F77
097F0:  CLRF   F78
097F2:  CLRF   F79
097F4:  MOVLW  05
097F6:  MOVWF  36
097F8:  MOVLW  C7
097FA:  MOVWF  35
097FC:  MOVLW  09
097FE:  MOVLB  5
09800:  MOVWF  xC8
09802:  MOVLW  6D
09804:  MOVWF  xC7
09806:  CLRF   xCA
09808:  CLRF   xC9
0980A:  MOVLB  0
0980C:  BRA    9852
0980E:  DATA 02,00
09810:  DATA 2F,00
09812:  DATA 00,10
09814:  DATA 00,37
09816:  DATA 44,55
09818:  DATA 53,54
0981A:  DATA 4E,45
0981C:  DATA 54,57
0981E:  DATA 4F,52
09820:  DATA 4B,53
09822:  DATA 52,4F
09824:  DATA 43,4B
09826:  DATA 05,00
09828:  DATA 4F,41
0982A:  DATA 30,30
0982C:  DATA 30,00
0982E:  DATA 10,40
09830:  DATA 8F,00
09832:  DATA 14,43
09834:  DATA 66,00
09836:  DATA 19,43
09838:  DATA 7B,00
0983A:  DATA 8C,43
0983C:  DATA 95,00
0983E:  DATA 78,44
09840:  DATA 26,00
09842:  DATA 50,44
09844:  DATA 9F,00
09846:  DATA 11,45
09848:  DATA 20,00
0984A:  DATA 04,05
0984C:  DATA 38,00
0984E:  DATA 00,00
09850:  DATA 00,00
09852:  MOVLW  00
09854:  MOVWF  FF8
09856:  MOVLW  98
09858:  MOVWF  FF7
0985A:  MOVLW  0E
0985C:  MOVWF  FF6
0985E:  TBLRD*+
09860:  MOVF   FF5,W
09862:  MOVWF  00
09864:  XORLW  00
09866:  BZ    988E
09868:  TBLRD*+
0986A:  MOVF   FF5,W
0986C:  MOVWF  01
0986E:  BTFSC  FE8.7
09870:  BRA    987C
09872:  ANDLW  0F
09874:  MOVWF  FEA
09876:  TBLRD*+
09878:  MOVF   FF5,W
0987A:  MOVWF  FE9
0987C:  BTFSC  01.6
0987E:  TBLRD*+
09880:  BTFSS  01.6
09882:  TBLRD*+
09884:  MOVF   FF5,W
09886:  MOVWF  FEE
09888:  DCFSNZ 00,F
0988A:  BRA    985E
0988C:  BRA    9880
0988E:  CLRF   FF8
09890:  MOVLB  5
09892:  CLRF   x44
.................... {                                                          
....................    // priority queue item that is to be executed  
....................    uint8_t     priority_queue_item_to_execute = EMPTY_PRIORITY_QUEUE;     
....................    // valve setting that is stored when free spin rate is performed (so you can return to it afterwards) 
....................    uint16_t    pre_fsr_valve_setting;                                          
....................                                         
....................    // set system state to init 
....................    global_system_state = SYSTEM_INIT;               
09894:  MOVLB  4
09896:  CLRF   xFD
....................     
....................    // initalize oscillator and timing of rs232, i2c, delay 
....................    osc_init();          
09898:  MOVLB  0
0989A:  GOTO   3006
....................  
....................    // initalize all variables (not really needed as they are initalized properly when CPU is rebooted)                                                         
....................    //vars_init();                   
....................     
....................    // store string version of firmware version in global_firmware_version_string                                                            
....................    global_firmware_version_string[0] = hi2asc(make8(FIRMWARE_VERSION,1)); 
0989E:  MOVLW  E3
098A0:  MOVLB  5
098A2:  MOVWF  x60
098A4:  MOVLB  0
098A6:  CALL   3012
098AA:  MOVFF  01,4F
....................    global_firmware_version_string[1] = lo2asc(make8(FIRMWARE_VERSION,1)); 
098AE:  MOVLW  E3
098B0:  MOVLB  5
098B2:  MOVWF  x60
098B4:  MOVLB  0
098B6:  CALL   3032
098BA:  MOVFF  01,50
....................    global_firmware_version_string[2] = hi2asc(make8(FIRMWARE_VERSION,0));       
098BE:  MOVLW  10
098C0:  MOVLB  5
098C2:  MOVWF  x60
098C4:  MOVLB  0
098C6:  CALL   3012
098CA:  MOVFF  01,51
....................    global_firmware_version_string[3] = lo2asc(make8(FIRMWARE_VERSION,0));    
098CE:  MOVLW  10
098D0:  MOVLB  5
098D2:  MOVWF  x60
098D4:  MOVLB  0
098D6:  CALL   3032
098DA:  MOVFF  01,52
....................  
....................    // grab all eeprom values (e.g. vlv cal, sprinkler number, vlv position) 
....................    read_all_eeprom_values();    
098DE:  GOTO   321E
....................     
....................    // load all changeable eeprom variables  
....................    read_all_eeprom_variables();         
098E2:  GOTO   32E2
....................                                 
....................    // initalize all periphs, timers, ccps, ints    
....................    periph_init(); 
098E6:  GOTO   3D3E
....................                                      
....................    // clear queues     
....................    clear_priority_queue();                                  
098EA:  GOTO   3E6A
....................    clear_time_queue(); 
098EE:  GOTO   3E8E
....................    clear_message_queue();       
098F2:  GOTO   3EEE
....................     
....................    // command queue is not needed/used yet as it is used in conjunction with the "modulation" scheme 
....................    //allocate_command_queue(); 
....................    //clear_command_queue(); 
....................     
....................    // startup rtc, turn on gen_rpm, enable dust chip (check for communication) 
....................    start_rtc();    
098F6:  GOTO   3F0A
....................    setup_gen_rpm();         
098FA:  GOTO   3F3C
....................    mote_init();      
098FE:  GOTO   413E
....................                           
....................    // if cold start was done, reset mote    
....................    if (global_previous_shutdown_cause == COLD_RESTART_REQUEST) 
09902:  MOVF   4E,W
09904:  SUBLW  0A
09906:  BNZ   990C
....................    { 
....................       mote_reset();           
09908:  CALL   4398
....................    }          
....................                           
....................    // DELETE?                              
....................    enable_interrupts(GLOBAL);                      
0990C:  MOVLW  C0
0990E:  IORWF  FF2,F
....................                                        
....................    // if SW1 is asserted during boot, trigger searching alogrithm                
....................    if (!input(SW1n))              
09910:  BTFSC  F81.4
09912:  BRA    9982
....................    {                                             
....................       // set the system state up for searching for a network (not run) 
....................       global_system_state = SYSTEM_SEARCHING_FOR_NETWORK; 
09914:  MOVLW  20
09916:  MOVLB  4
09918:  MOVWF  xFD
....................       strcpy (global_temp_line_buff, "Setup Manager..."); 
0991A:  CLRF   FEA
0991C:  MOVLW  70
0991E:  MOVWF  FE9
09920:  MOVLW  00
09922:  MOVLB  0
09924:  CALL   0610
09928:  TBLRD*-
0992A:  TBLRD*+
0992C:  MOVF   FF5,W
0992E:  MOVWF  FEE
09930:  IORLW  00
09932:  BNZ   992A
....................       LCD_line1(global_temp_line_buff); 
09934:  MOVLB  5
09936:  CLRF   x60
09938:  MOVLW  70
0993A:  MOVWF  x5F
0993C:  MOVLB  0
0993E:  CALL   365A
....................       strcpy (global_temp_line_buff, "  Release SW1   "); 
09942:  CLRF   FEA
09944:  MOVLW  70
09946:  MOVWF  FE9
09948:  MOVLW  00
0994A:  CALL   0632
0994E:  TBLRD*-
09950:  TBLRD*+
09952:  MOVF   FF5,W
09954:  MOVWF  FEE
09956:  IORLW  00
09958:  BNZ   9950
....................       LCD_line2(global_temp_line_buff);      
0995A:  MOVLB  5
0995C:  CLRF   x60
0995E:  MOVLW  70
09960:  MOVWF  x5F
09962:  MOVLB  0
09964:  CALL   36B4
....................       // wait for switch release  
....................       while (!input(SW1n));       
09968:  BTFSS  F81.4
0996A:  BRA    9968
....................       // delay lcd update for a tiny bit                                                                                                                              
....................       global_skip_lcd_update_count = 1; 
0996C:  MOVLW  01
0996E:  MOVWF  x83
....................       // first part of search alorithm sequence                                                                                       
....................       PUSH_PRIORITY_QUEUE_MACRO(SEARCH_FOR_STRONGEST_1);                  
09970:  BCF    F7A.1
09972:  MOVLW  B1
09974:  MOVLB  5
09976:  MOVWF  x50
09978:  MOVLB  0
0997A:  CALL   43F2
0997E:  BSF    F7A.1
....................    }                                  
09980:  BRA    9A2C
....................     
....................    // normal behavior, check mote status.  Join network if necessary.                                                                                                       
....................    else  
....................    {                                  
....................       // Fun startup splash screen (and clear startup screen) 
....................       //LCD_startup_splash();        
....................       //LCD_clear();                   
....................                                                                                      
....................       // dispaly battery voltage (line 0) and restart/shutdown cause (line 1) on screen for a second  
....................       LCD_display_battery_voltage(0);     
09982:  MOVLB  5
09984:  CLRF   x47
09986:  MOVLB  0
09988:  GOTO   49D2
....................       LCD_display_shutdown_cause(1);             
0998C:  MOVLW  01
0998E:  MOVLB  5
09990:  MOVWF  x47
09992:  MOVLB  0
09994:  GOTO   4A82
....................        
....................       // global_skip_lcd_update_count is our way of letting things stay on the lcd for a moment 
....................       //    You set it to the number of times to skip an LCD update + 1 
....................       //    e.g. setting it to 2 means things stay on the screen for 1-2 seconds and then they are cleared 
....................       //    e.g. setting it to 1 means things are cleared right away 
....................       //    e.g. setting it to 0 (or not setting it) means the LCD screen is just overwritten by LCD update 
....................       global_skip_lcd_update_count = 2;         
09998:  MOVLW  02
0999A:  MOVWF  x83
....................  
....................       // all periphs should be initalized (except mote), so system should be ready to run         
....................       global_system_state = SYSTEM_RUN;                
0999C:  MOVLB  4
0999E:  MOVWF  xFD
....................        
....................       // flash the leds to help identify motes    
....................       happy_lites(); 
099A0:  MOVLB  0
099A2:  CALL   4ADC
....................        
....................       // check mote state. If it needs to connect, it will react as it should            
....................       PUSH_TIME_QUEUE_MACRO(global_rtc_time + 5, CHECK_MOTE_STATE);   
099A6:  BCF    F7A.1
099A8:  MOVLW  05
099AA:  ADDWF  x85,W
099AC:  MOVLB  5
099AE:  MOVWF  x47
099B0:  MOVLW  00
099B2:  MOVLB  0
099B4:  ADDWFC x86,W
099B6:  MOVLB  5
099B8:  MOVWF  x48
099BA:  MOVLW  00
099BC:  MOVLB  0
099BE:  ADDWFC x87,W
099C0:  MOVLB  5
099C2:  MOVWF  x49
099C4:  MOVLW  00
099C6:  MOVLB  0
099C8:  ADDWFC x88,W
099CA:  MOVLB  5
099CC:  MOVWF  x4A
099CE:  MOVWF  x55
099D0:  MOVFF  549,554
099D4:  MOVFF  548,553
099D8:  MOVFF  547,552
099DC:  MOVLW  B4
099DE:  MOVWF  x56
099E0:  MOVLB  0
099E2:  CALL   414A
099E6:  BSF    F7A.1
....................        
....................       // check mote info 
....................       PUSH_TIME_QUEUE_MACRO(global_rtc_time + 10, UPDATE_MOTE_NETWORK_INFO); 
099E8:  BCF    F7A.1
099EA:  MOVLW  0A
099EC:  ADDWF  x85,W
099EE:  MOVLB  5
099F0:  MOVWF  x47
099F2:  MOVLW  00
099F4:  MOVLB  0
099F6:  ADDWFC x86,W
099F8:  MOVLB  5
099FA:  MOVWF  x48
099FC:  MOVLW  00
099FE:  MOVLB  0
09A00:  ADDWFC x87,W
09A02:  MOVLB  5
09A04:  MOVWF  x49
09A06:  MOVLW  00
09A08:  MOVLB  0
09A0A:  ADDWFC x88,W
09A0C:  MOVLB  5
09A0E:  MOVWF  x4A
09A10:  MOVWF  x55
09A12:  MOVFF  549,554
09A16:  MOVFF  548,553
09A1A:  MOVFF  547,552
09A1E:  MOVLW  A4
09A20:  MOVWF  x56
09A22:  MOVLB  0
09A24:  CALL   414A
09A28:  BSF    F7A.1
....................              
....................       // setup WDT for 1 second (plenty long for the control loop (~64ms) to    
....................       setup_wdt(WDT_1S); 
09A2A:  BSF    FD1.0
....................    }                                                                  
....................                                                               
....................    // start the queue/control loop timer 
....................    delay_ms(15); 
09A2C:  MOVLW  0F
09A2E:  MOVLB  5
09A30:  MOVWF  x60
09A32:  MOVLB  0
09A34:  CALL   35F0
....................    setup_T2_int(T2_64MS);  
09A38:  MOVLB  5
09A3A:  SETF   x47
09A3C:  MOVLB  0
09A3E:  CALL   4B2E
....................    global_lcd_page_number = 0; 
09A42:  CLRF   x84
....................     
....................    while(1)                    
....................    {             
....................       // restart the watchdog timer     
....................       restart_wdt();     
09A44:  CLRWDT
....................        
....................    // optional trigger for SW1 press    
....................    /*        
....................    if (!input(SW1n))                                                                                                                                  
....................    { 
....................       LCD_display_message_queue(); 
....................    }          
....................    */             
....................     
.................... ////////////////////Start of Priority Queue Handling/////////////////////////// 
....................                                                                        
....................       // Timer 2 is used to signal the priority queue to check for another item 
....................       //    to execute. This is only done once every 64ms to NOT keep the  
....................       //    system in a state with the interrupts disabled all the time. 
....................       // Timer 2 is also used to time the control loop.  How often the set point 
....................       //    is re-evaluated and adjustments are made to the actual values is 
....................       //    controlled by control_loop_delay_cycles_left within update_control_loop() 
....................        
....................       // if it is time to check priority queue/control loop 
....................       if (TMR2IF)  
09A46:  BTFSS  F9E.1
09A48:  GOTO   A492
....................       {   
....................          // reset the timer 2 queue loop interrupt 
....................          setup_T2_int(T2_64MS);       
09A4C:  MOVLB  5
09A4E:  SETF   x47
09A50:  MOVLB  0
09A52:  CALL   4B2E
....................                              
....................          // update the control loop                    
....................          update_control_loop();            
09A56:  GOTO   50E8
....................           
....................          // Safely grab the next item in the priority queue to execute                 
....................          // All interrupts that can modify the queue need to be disabled to                             
....................          //    ensure memory is not corrupted.       
....................          disable_interrupts(INT_CCP4); 
09A5A:  BCF    F7A.1
....................          disable_interrupts(INT_EXT2);    
09A5C:  BCF    FF0.4
....................          priority_queue_item_to_execute = pop_priority_queue();    
09A5E:  GOTO   598C
09A62:  MOVFF  01,544
....................          enable_interrupts(INT_EXT2);    
09A66:  BSF    FF0.4
....................          enable_interrupts(INT_CCP4); 
09A68:  BSF    F7A.1
....................          RBIF = FALSE; 
09A6A:  BCF    FF2.0
....................          enable_interrupts(INT_RB);  
09A6C:  BSF    FF2.3
09A6E:  MOVLW  FF
09A70:  IORWF  F62,F
....................                                                        
....................          // execute the priority queue item     
....................          switch (priority_queue_item_to_execute)                                
09A72:  MOVLB  5
09A74:  MOVF   x44,W
09A76:  XORLW  20
09A78:  MOVLB  0
09A7A:  BTFSC  FD8.2
09A7C:  BRA    9B56
09A7E:  XORLW  11
09A80:  BTFSC  FD8.2
09A82:  BRA    9B96
09A84:  XORLW  03
09A86:  BTFSC  FD8.2
09A88:  BRA    9C30
09A8A:  XORLW  01
09A8C:  BTFSC  FD8.2
09A8E:  BRA    9C50
09A90:  XORLW  07
09A92:  BTFSC  FD8.2
09A94:  BRA    9C72
09A96:  XORLW  01
09A98:  BTFSC  FD8.2
09A9A:  BRA    9C8C
09A9C:  XORLW  03
09A9E:  BTFSC  FD8.2
09AA0:  BRA    9CAC
09AA2:  XORLW  01
09AA4:  BTFSC  FD8.2
09AA6:  BRA    9DAC
09AA8:  XORLW  0F
09AAA:  BTFSC  FD8.2
09AAC:  BRA    9DD4
09AAE:  XORLW  01
09AB0:  BTFSC  FD8.2
09AB2:  BRA    9E28
09AB4:  XORLW  05
09AB6:  BTFSC  FD8.2
09AB8:  BRA    9E32
09ABA:  XORLW  01
09ABC:  BTFSC  FD8.2
09ABE:  BRA    9E50
09AC0:  XORLW  03
09AC2:  BTFSC  FD8.2
09AC4:  BRA    9E6E
09AC6:  XORLW  7E
09AC8:  BTFSC  FD8.2
09ACA:  BRA    9EAE
09ACC:  XORLW  10
09ACE:  BTFSC  FD8.2
09AD0:  BRA    A042
09AD2:  XORLW  01
09AD4:  BTFSC  FD8.2
09AD6:  BRA    A044
09AD8:  XORLW  04
09ADA:  BTFSC  FD8.2
09ADC:  BRA    A046
09ADE:  XORLW  03
09AE0:  BTFSC  FD8.2
09AE2:  BRA    A08C
09AE4:  XORLW  82
09AE6:  BTFSC  FD8.2
09AE8:  BRA    A0A2
09AEA:  XORLW  14
09AEC:  BTFSC  FD8.2
09AEE:  BRA    A0B2
09AF0:  XORLW  D1
09AF2:  BTFSC  FD8.2
09AF4:  BRA    A0D4
09AF6:  XORLW  01
09AF8:  BTFSC  FD8.2
09AFA:  BRA    A10A
09AFC:  XORLW  A4
09AFE:  BTFSC  FD8.2
09B00:  BRA    A15A
09B02:  XORLW  01
09B04:  BTFSC  FD8.2
09B06:  BRA    A160
09B08:  XORLW  16
09B0A:  BTFSC  FD8.2
09B0C:  BRA    A166
09B0E:  XORLW  07
09B10:  BTFSC  FD8.2
09B12:  BRA    A16C
09B14:  XORLW  05
09B16:  BTFSC  FD8.2
09B18:  BRA    A172
09B1A:  XORLW  03
09B1C:  BTFSC  FD8.2
09B1E:  BRA    A178
09B20:  XORLW  13
09B22:  BTFSC  FD8.2
09B24:  BRA    A17E
09B26:  XORLW  03
09B28:  BTFSC  FD8.2
09B2A:  BRA    A206
09B2C:  XORLW  01
09B2E:  BTFSC  FD8.2
09B30:  BRA    A23A
09B32:  XORLW  13
09B34:  BTFSC  FD8.2
09B36:  GOTO   A26E
09B3A:  XORLW  50
09B3C:  BTFSC  FD8.2
09B3E:  GOTO   A274
09B42:  XORLW  01
09B44:  BTFSC  FD8.2
09B46:  GOTO   A31A
09B4A:  XORLW  F1
09B4C:  BTFSC  FD8.2
09B4E:  GOTO   A492
09B52:  GOTO   A492
....................          { 
....................             // Decode a new packet and react/respond appropriately 
....................             case DEAL_WITH_NEW_PACKET:             
....................                // Display that you're dealing with a new packet 
....................                LCD_clear();                                  
09B56:  CALL   59CA
....................                strcpy (global_temp_line_buff, "Deal With Packet"); 
09B5A:  CLRF   FEA
09B5C:  MOVLW  70
09B5E:  MOVWF  FE9
09B60:  MOVLW  00
09B62:  CALL   0654
09B66:  TBLRD*-
09B68:  TBLRD*+
09B6A:  MOVF   FF5,W
09B6C:  MOVWF  FEE
09B6E:  IORLW  00
09B70:  BNZ   9B68
....................                LCD_line1(global_temp_line_buff); 
09B72:  MOVLB  5
09B74:  CLRF   x60
09B76:  MOVLW  70
09B78:  MOVWF  x5F
09B7A:  MOVLB  0
09B7C:  CALL   365A
....................                global_skip_lcd_update_count = 2;      
09B80:  MOVLW  02
09B82:  MOVWF  x83
....................                                                   
....................                // disable ccp4 and mote interrupt so we don't overwrite payload_buff 
....................                //    or have colliding unsolicited messages 
....................                disable_interrupts(INT_CCP4); 
09B84:  BCF    F7A.1
....................                disable_interrupts(INT_EXT2_H2L); 
09B86:  BCF    FF0.4
....................                deal_with_packet();  
09B88:  GOTO   6CC0
....................                enable_interrupts(INT_EXT2_H2L);                        
09B8C:  BSF    FF0.4
09B8E:  BCF    FF1.4
....................                enable_interrupts(INT_CCP4); 
09B90:  BSF    F7A.1
....................                break; 
09B92:  GOTO   A492
....................                 
....................             // Start the somewhat convoluted calibrate valve routine 
....................             // 1. Open valve VLV_CAL_1_MOVEMENT w/ "starting current" 
....................             // 2. Close valve fully w/ current being "normal closing current" 
....................             // 3. Open valve fully w/ normal current regimes 
....................             // 4. Do free spin rate (not done in here at the moment, just skipped).  
....................             // 5. Close valve fully w/ normal current regimes 
....................             // 6. Send valve calibration response to mote    
....................             // steps and system states are handled in COMP and CCP3 ISR as well  
....................             //    as setting the calibration values       
....................                          
....................             case CALIBRATE_VALVE_1: 
....................                // Change system state: initial open for calibrate valve routine 
....................                global_system_state = SYSTEM_CAL_VLV_1;     
09B96:  MOVLW  10
09B98:  MOVLB  4
09B9A:  MOVWF  xFD
....................                // display calibration routine on screen      
....................                LCD_clear();                          
09B9C:  MOVLB  0
09B9E:  CALL   59CA
....................                strcpy (global_temp_line_buff, "VLV Calibration "); 
09BA2:  CLRF   FEA
09BA4:  MOVLW  70
09BA6:  MOVWF  FE9
09BA8:  MOVLW  00
09BAA:  CALL   0676
09BAE:  TBLRD*-
09BB0:  TBLRD*+
09BB2:  MOVF   FF5,W
09BB4:  MOVWF  FEE
09BB6:  IORLW  00
09BB8:  BNZ   9BB0
....................                LCD_line1(global_temp_line_buff); 
09BBA:  MOVLB  5
09BBC:  CLRF   x60
09BBE:  MOVLW  70
09BC0:  MOVWF  x5F
09BC2:  MOVLB  0
09BC4:  CALL   365A
....................                strcpy (global_temp_line_buff, "Begining........"); 
09BC8:  CLRF   FEA
09BCA:  MOVLW  70
09BCC:  MOVWF  FE9
09BCE:  MOVLW  00
09BD0:  CALL   0698
09BD4:  TBLRD*-
09BD6:  TBLRD*+
09BD8:  MOVF   FF5,W
09BDA:  MOVWF  FEE
09BDC:  IORLW  00
09BDE:  BNZ   9BD6
....................                LCD_line2(global_temp_line_buff); 
09BE0:  MOVLB  5
09BE2:  CLRF   x60
09BE4:  MOVLW  70
09BE6:  MOVWF  x5F
09BE8:  MOVLB  0
09BEA:  CALL   36B4
....................                global_skip_lcd_update_count = 2;   
09BEE:  MOVLW  02
09BF0:  MOVWF  x83
....................                // setup brakes and charging for valve calibration 
....................                // (maximum resistance with no RPM Control) 
....................                global_control_loop_mechanism = NO_RPM_CONTROL_DYN_MPPC; 
09BF2:  MOVLW  06
09BF4:  MOVWF  xB8
....................                global_charge_duty_set_value = MAX_CHARGE; 
09BF6:  MOVLW  01
09BF8:  MOVWF  xB1
09BFA:  MOVLW  90
09BFC:  MOVWF  xB0
....................                global_brake_duty_set_value = MAX_BRK; 
09BFE:  MOVLW  01
09C00:  MOVWF  xAF
09C02:  MOVLW  90
09C04:  MOVWF  xAE
....................                // put values to default values (45 seconds open/close)                                
....................                global_valve_time_to_close_1024th = DEFAULT_VLV_TIME_TO_CLOSE;  
09C06:  MOVLW  05
09C08:  MOVWF  xBE
09C0A:  CLRF   xBD
....................                global_valve_time_to_open_1024th = DEFAULT_VLV_TIME_TO_OPEN;               
09C0C:  MOVWF  xC0
09C0E:  CLRF   xBF
....................                // Set the global valve position to the default value (middle)                  
....................                // this gives the valve a reference point to open a little from 
....................                global_valve_position = VLV_PRECALIBRAION_POSITION; 
09C10:  MOVLW  40
09C12:  MOVWF  xBA
09C14:  CLRF   xB9
....................                // Set valve position slightly more open than it is and move valve 
....................                global_valve_position_set_value = (VLV_PRECALIBRAION_POSITION +                        \ 
....................                VLV_CAL_1_MOVEMENT); 
09C16:  MOVLW  60
09C18:  MOVWF  xBC
09C1A:  CLRF   xBB
....................                PUSH_PRIORITY_QUEUE_MACRO(MOVE_VALVE); 
09C1C:  BCF    F7A.1
09C1E:  MOVLW  40
09C20:  MOVLB  5
09C22:  MOVWF  x50
09C24:  MOVLB  0
09C26:  CALL   43F2
09C2A:  BSF    F7A.1
....................                break;                                                       
09C2C:  GOTO   A492
....................                 
....................             case CALIBRATE_VALVE_2:                                                                                                        
....................                // Change system state: fully closed 
....................                global_system_state = SYSTEM_CAL_VLV_2; 
09C30:  MOVLW  11
09C32:  MOVLB  4
09C34:  MOVWF  xFD
....................                // set valve position target to fully closed and move valve 
....................                global_valve_position_set_value = VLV_POSITION_CLOSED; 
09C36:  MOVLB  0
09C38:  CLRF   xBC
09C3A:  CLRF   xBB
....................                PUSH_PRIORITY_QUEUE_MACRO(MOVE_VALVE);                                  
09C3C:  BCF    F7A.1
09C3E:  MOVLW  40
09C40:  MOVLB  5
09C42:  MOVWF  x50
09C44:  MOVLB  0
09C46:  CALL   43F2
09C4A:  BSF    F7A.1
....................                break;    
09C4C:  GOTO   A492
....................                 
....................             case CALIBRATE_VALVE_3: 
....................                // Change system state: fully closed to fully opened 
....................                global_system_state = SYSTEM_CAL_VLV_3; 
09C50:  MOVLW  12
09C52:  MOVLB  4
09C54:  MOVWF  xFD
....................                // set valve position target to fully open and move valve 
....................                global_valve_position_set_value = VLV_POSITION_OPENED; 
09C56:  MOVLW  80
09C58:  MOVLB  0
09C5A:  MOVWF  xBC
09C5C:  CLRF   xBB
....................                PUSH_PRIORITY_QUEUE_MACRO(MOVE_VALVE); 
09C5E:  BCF    F7A.1
09C60:  MOVLW  40
09C62:  MOVLB  5
09C64:  MOVWF  x50
09C66:  MOVLB  0
09C68:  CALL   43F2
09C6C:  BSF    F7A.1
....................                break;      
09C6E:  GOTO   A492
....................              
....................            case CALIBRATE_VALVE_4:  
....................                // Change system state: FSR (not used at the moment) 
....................                global_system_state = SYSTEM_CAL_VLV_4;  
09C72:  MOVLW  13
09C74:  MOVLB  4
09C76:  MOVWF  xFD
....................                // move to the next calibration stage 
....................                PUSH_PRIORITY_QUEUE_MACRO(CALIBRATE_VALVE_5); 
09C78:  BCF    F7A.1
09C7A:  MOVLW  35
09C7C:  MOVLB  5
09C7E:  MOVWF  x50
09C80:  MOVLB  0
09C82:  CALL   43F2
09C86:  BSF    F7A.1
....................                break;       
09C88:  GOTO   A492
....................                 
....................             case CALIBRATE_VALVE_5: 
....................                // Change system state: fully opened to fully closed 
....................                global_system_state = SYSTEM_CAL_VLV_5; 
09C8C:  MOVLW  14
09C8E:  MOVLB  4
09C90:  MOVWF  xFD
....................                // set valve position target to fully closed and move valve 
....................                global_valve_position_set_value = VLV_POSITION_CLOSED; 
09C92:  MOVLB  0
09C94:  CLRF   xBC
09C96:  CLRF   xBB
....................                PUSH_PRIORITY_QUEUE_MACRO(MOVE_VALVE); 
09C98:  BCF    F7A.1
09C9A:  MOVLW  40
09C9C:  MOVLB  5
09C9E:  MOVWF  x50
09CA0:  MOVLB  0
09CA2:  CALL   43F2
09CA6:  BSF    F7A.1
....................                break;      
09CA8:  GOTO   A492
....................              
....................             case CALIBRATE_VALVE_6: 
....................                // Change system state: display calibration and send to manager 
....................                global_system_state = SYSTEM_CAL_VLV_6; 
09CAC:  MOVLW  15
09CAE:  MOVLB  4
09CB0:  MOVWF  xFD
....................                // display calibraion on screen 
....................                LCD_clear(); 
09CB2:  MOVLB  0
09CB4:  CALL   59CA
....................                strcpy (global_temp_line_buff, "Close CCP=      "); 
09CB8:  CLRF   FEA
09CBA:  MOVLW  70
09CBC:  MOVWF  FE9
09CBE:  MOVLW  00
09CC0:  CALL   06BA
09CC4:  TBLRD*-
09CC6:  TBLRD*+
09CC8:  MOVF   FF5,W
09CCA:  MOVWF  FEE
09CCC:  IORLW  00
09CCE:  BNZ   9CC6
....................                LCD_line1(global_temp_line_buff); 
09CD0:  MOVLB  5
09CD2:  CLRF   x60
09CD4:  MOVLW  70
09CD6:  MOVWF  x5F
09CD8:  MOVLB  0
09CDA:  CALL   365A
....................                strcpy (global_temp_line_buff, "Open CCP =      "); 
09CDE:  CLRF   FEA
09CE0:  MOVLW  70
09CE2:  MOVWF  FE9
09CE4:  MOVLW  00
09CE6:  CALL   06DC
09CEA:  TBLRD*-
09CEC:  TBLRD*+
09CEE:  MOVF   FF5,W
09CF0:  MOVWF  FEE
09CF2:  IORLW  00
09CF4:  BNZ   9CEC
....................                LCD_line2(global_temp_line_buff); 
09CF6:  MOVLB  5
09CF8:  CLRF   x60
09CFA:  MOVLW  70
09CFC:  MOVWF  x5F
09CFE:  MOVLB  0
09D00:  CALL   36B4
....................                LCD_place_uint16(global_valve_time_to_close_1024th,0,11,5); 
09D04:  MOVFF  BE,560
09D08:  MOVFF  BD,55F
09D0C:  MOVLB  5
09D0E:  CLRF   x61
09D10:  MOVLW  0B
09D12:  MOVWF  x62
09D14:  MOVLW  05
09D16:  MOVWF  x63
09D18:  MOVLB  0
09D1A:  CALL   4924
....................                LCD_place_uint16(global_valve_time_to_open_1024th,1,11,5); 
09D1E:  MOVFF  C0,560
09D22:  MOVFF  BF,55F
09D26:  MOVLW  01
09D28:  MOVLB  5
09D2A:  MOVWF  x61
09D2C:  MOVLW  0B
09D2E:  MOVWF  x62
09D30:  MOVLW  05
09D32:  MOVWF  x63
09D34:  MOVLB  0
09D36:  CALL   4924
....................                // put calibration stuff on screen for 4 seconds 
....................                global_skip_lcd_update_count = 5;      
09D3A:  MOVLW  05
09D3C:  MOVWF  x83
....................                // if valve calibration time is below the limit, it triggers an error 
....................                //    and throws away the calibration, returning it to the run state. 
....................                if ((global_valve_time_to_close_1024th < ERROR_VLV_CAL_TIME) || \ 
....................                   (global_valve_time_to_open_1024th < ERROR_VLV_CAL_TIME)) 
09D3E:  MOVF   xBE,W
09D40:  SUBLW  02
09D42:  BNC   9D4C
09D44:  BNZ   9D5A
09D46:  MOVF   xBD,W
09D48:  SUBLW  ED
09D4A:  BC    9D5A
09D4C:  MOVF   xC0,W
09D4E:  SUBLW  02
09D50:  BNC   9D7E
09D52:  BNZ   9D5A
09D54:  MOVF   xBF,W
09D56:  SUBLW  ED
09D58:  BNC   9D7E
....................                { 
....................                   // reset valve calibration times to the defaults 
....................                   global_valve_time_to_open_1024th = DEFAULT_VLV_TIME_TO_OPEN; 
09D5A:  MOVLW  05
09D5C:  MOVWF  xC0
09D5E:  CLRF   xBF
....................                   global_valve_time_to_close_1024th = DEFAULT_VLV_TIME_TO_CLOSE; 
09D60:  MOVWF  xBE
09D62:  CLRF   xBD
....................                   // change valve position to unknown 
....................                   global_valve_position = VLV_POSITION_UNKNOWN; 
09D64:  SETF   xBA
09D66:  SETF   xB9
....................                   // set the error bitfield and send an error 
....................                   global_error_message_bitfield |= ERR_MSG_VLV_CAL_FAIL; 
09D68:  MOVLB  4
09D6A:  BSF    xF1.1
....................                   PUSH_MESSAGE_QUEUE_MACRO(MSG_MOTE_ERROR_MSG); 
09D6C:  BCF    F7A.1
09D6E:  MOVLW  A0
09D70:  MOVLB  5
09D72:  MOVWF  x50
09D74:  MOVLB  0
09D76:  CALL   4D00
09D7A:  BSF    F7A.1
....................                } 
09D7C:  BRA    9DA2
....................                // successful/valid calibration time 
....................                else 
....................                { 
....................                   // update the calibration time 
....................                   global_valve_calibration_utc_time = global_utc_time; 
09D7E:  MOVFF  8C,C6
09D82:  MOVFF  8B,C5
09D86:  MOVFF  8A,C4
09D8A:  MOVFF  89,C3
....................                   // store calibrations in eeprom 
....................                   store_vcal_eeprom_values(); 
09D8E:  GOTO   79E2
....................                   // send an unsolicited valve report to the manager 
....................                   PUSH_MESSAGE_QUEUE_MACRO(MSG_MOTE_VALVE_REPORT); 
09D92:  BCF    F7A.1
09D94:  MOVLW  92
09D96:  MOVLB  5
09D98:  MOVWF  x50
09D9A:  MOVLB  0
09D9C:  CALL   4D00
09DA0:  BSF    F7A.1
....................                } 
....................                // put system in run state 
....................                global_system_state = SYSTEM_RUN; 
09DA2:  MOVLW  02
09DA4:  MOVLB  4
09DA6:  MOVWF  xFD
....................                break;      
09DA8:  MOVLB  0
09DAA:  BRA    A492
....................                             
....................             // FSR IS LARGELY UNTESTED EVEN THOUGH IT'S BASICALLY ALL WRITTEN!                
....................             // move valve to position specified by calibrate FSR routine    
....................             case CALIBRATE_FSR_1: 
....................                // set system state                       
....................                global_system_state = SYSTEM_CAL_FSR_1;                                          
09DAC:  MOVLW  18
09DAE:  MOVLB  4
09DB0:  MOVWF  xFD
....................                // save the current valve, so we can return to it later 
....................                pre_fsr_valve_setting = global_valve_position;      
09DB2:  MOVFF  BA,546
09DB6:  MOVFF  B9,545
....................                // move valve to the FSR position                          
....................                global_valve_position_set_value = global_calibrate_fsr_valve_position;  
09DBA:  MOVFF  C9,BC
09DBE:  MOVFF  C8,BB
....................                PUSH_PRIORITY_QUEUE_MACRO(MOVE_VALVE);                             
09DC2:  BCF    F7A.1
09DC4:  MOVLW  40
09DC6:  MOVLB  5
09DC8:  MOVWF  x50
09DCA:  MOVLB  0
09DCC:  CALL   43F2
09DD0:  BSF    F7A.1
....................                break;          
09DD2:  BRA    A492
....................                                                                                          
....................             case CALIBRATE_FSR_2: 
....................                // set system state 
....................                global_system_state = SYSTEM_CAL_FSR_2;    
09DD4:  MOVLW  19
09DD6:  MOVLB  4
09DD8:  MOVWF  xFD
....................                // disable ccp5 for a quick second 
....................                disable_interrupts(INT_CCP5); 
09DDA:  BCF    F7A.2
....................                // actually measure the FSR and store it  
....................                global_calibrate_fsr_period = global_current_period;    
09DDC:  MOVFF  A1,CB
09DE0:  MOVFF  A0,CA
....................                // restore ccp5 
....................                enable_interrupts(INT_CCP5);      
09DE4:  BSF    F7A.2
....................                // store the fsr calibration time 
....................                global_calibrate_fsr_utc_time = global_utc_time;    
09DE6:  MOVFF  8C,CF
09DEA:  MOVFF  8B,CE
09DEE:  MOVFF  8A,CD
09DF2:  MOVFF  89,CC
....................                                      
....................                // move valve to the FSR position 
....................                global_valve_position_set_value = pre_fsr_valve_setting;   
09DF6:  MOVFF  546,BC
09DFA:  MOVFF  545,BB
....................                PUSH_PRIORITY_QUEUE_MACRO(MOVE_VALVE);     
09DFE:  BCF    F7A.1
09E00:  MOVLW  40
09E02:  MOVLB  5
09E04:  MOVWF  x50
09E06:  MOVLB  0
09E08:  CALL   43F2
09E0C:  BSF    F7A.1
....................                                                   
....................                PUSH_MESSAGE_QUEUE_MACRO(MSG_MOTE_VALVE_REPORT); 
09E0E:  BCF    F7A.1
09E10:  MOVLW  92
09E12:  MOVLB  5
09E14:  MOVWF  x50
09E16:  MOVLB  0
09E18:  CALL   4D00
09E1C:  BSF    F7A.1
....................                global_system_state = SYSTEM_RUN; 
09E1E:  MOVLW  02
09E20:  MOVLB  4
09E22:  MOVWF  xFD
....................                break;                                   
09E24:  MOVLB  0
09E26:  BRA    A492
....................                 
....................             case CALIBRATE_FSR_3: 
....................                global_system_state = SYSTEM_CAL_FSR_3; 
09E28:  MOVLW  1A
09E2A:  MOVLB  4
09E2C:  MOVWF  xFD
....................                break;         
09E2E:  MOVLB  0
09E30:  BRA    A492
....................             /*    
....................             case CALIBRATE_FSR_4: 
....................                global_system_state = SYSTEM_CAL_FSR_4; 
....................                LCD_clear(); 
....................                LCD_place_uint16(global_valve_position,0,0,5); 
....................                LCD_place_uint16(global_valve_time_to_close_1024th,0,6,5); 
....................                LCD_place_uint16(global_valve_time_to_open_1024th,0,11,5); 
....................                LCD_place_uint16(global_valve_position,1,0,5); 
....................                LCD_place_uint16(global_valve_position,1,11,5); 
....................                LCD_place_uint16(global_valve_position,1,11,5); 
....................                // put calibration stuff on screen for 4 seconds 
....................                global_skip_lcd_update_count = 5; 
....................                global_calibrate_fsr_utc_time 
....................                 
....................                global_system_state = SYSTEM_RUN; 
....................                break;          
....................                */             
....................                 
....................                 
....................             case MOVE_VALVE_MAG_DECOUPLING_RECOVERY: 
....................                // move the valve to VLV_MAGNETIC_COUPLING_FIX 
....................                global_valve_position_set_value = VLV_MAGNETIC_COUPLING_FIX; 
09E32:  MOVFF  518,BC
09E36:  MOVFF  517,BB
....................                PUSH_PRIORITY_QUEUE_MACRO(MOVE_VALVE); 
09E3A:  BCF    F7A.1
09E3C:  MOVLW  40
09E3E:  MOVLB  5
09E40:  MOVWF  x50
09E42:  MOVLB  0
09E44:  CALL   43F2
09E48:  BSF    F7A.1
....................                // change control loop scheme  
....................                global_control_loop_mechanism = MAG_DECOUPLING_RECOVERY; 
09E4A:  MOVLW  09
09E4C:  MOVWF  xB8
....................                break; 
09E4E:  BRA    A492
....................                 
....................             case MOVE_VALVE_NO_SPIN_RECOVERY: 
....................                // move the valve to VLV_NOT_SPIN_FIX 
....................                global_valve_position_set_value = VLV_NOT_SPIN_FIX; 
09E50:  MOVFF  513,BC
09E54:  MOVFF  512,BB
....................                PUSH_PRIORITY_QUEUE_MACRO(MOVE_VALVE); 
09E58:  BCF    F7A.1
09E5A:  MOVLW  40
09E5C:  MOVLB  5
09E5E:  MOVWF  x50
09E60:  MOVLB  0
09E62:  CALL   43F2
09E66:  BSF    F7A.1
....................                // change control loop scheme 
....................                global_control_loop_mechanism = NO_SPIN_RECOVERY; 
09E68:  MOVLW  08
09E6A:  MOVWF  xB8
....................                break; 
09E6C:  BRA    A492
....................                                                
....................             // Opens valve irrespestive of the position. Used for shutting down the system (and leaving 
....................             //    the valve open).  Added very quickly in Nebraska.                  
....................             case OPEN_VALVE_UNKNOWN_STATE:                             
....................                // clear out the time in motion 
....................                global_valve_time_in_motion_1024ths = 0;      
09E6E:  CLRF   xC2
09E70:  CLRF   xC1
....................                 
....................                global_valve_position_set_value = VLV_POSITION_OPENED; 
09E72:  MOVLW  80
09E74:  MOVWF  xBC
09E76:  CLRF   xBB
....................                CCP_3 = global_valve_time_to_open_1024th;  
09E78:  MOVFF  C0,F5F
09E7C:  MOVFF  BF,F5E
....................                // start the valve opening 
....................                mV_OPENm;          
09E80:  MOVLW  02
09E82:  MOVWF  F8D
....................                // setup/turn on the comparator interrupt (also sets up DAC) 
....................                comparator_setup(); 
09E84:  CALL   7B70
....................                 
....................                // setup and enable CCP3 as well as it's respective timer 
....................                setup_ccp3(CCP_USE_TIMER1_AND_TIMER2 | CCP_COMPARE_RESET_TIMER); 
09E88:  MOVLW  0B
09E8A:  MOVLB  F
09E8C:  MOVWF  x5D
09E8E:  CLRF   x5C
09E90:  CLRF   x5B
09E92:  MOVLW  01
09E94:  MOVWF  x5A
09E96:  MOVLW  3F
09E98:  ANDWF  x49,F
09E9A:  MOVLW  00
09E9C:  IORWF  x49,F
....................                setup_timer_1(T1_ENABLE_SOSC | T1_EXTERNAL_SYNC | T1_DIV_BY_1); 
09E9E:  MOVLW  8B
09EA0:  MOVWF  FCD
09EA2:  CLRF   FCC
....................                set_timer1(0); 
09EA4:  CLRF   FCF
09EA6:  CLRF   FCE
....................                                                                           
....................                // clear any ccp3 interrupt and enable ccp3 interrupt 
....................                clear_interrupt(INT_CCP3);                
09EA8:  BCF    F7B.0
....................                enable_interrupts(INT_CCP3);    
09EAA:  BSF    F7A.0
09EAC:  MOVLB  0
....................                                               
....................             case MOVE_VALVE:                 
....................                // if system is in an undesireable state, don't move the valve 
....................                //    and send an error message 
....................                // Undesirable states such as unkown or init 
....................                if ((global_system_state == SYSTEM_STATE_UNKNOWN)||            \ 
....................                   (global_system_state == SYSTEM_INIT)) 
09EAE:  MOVLB  4
09EB0:  INCFSZ xFD,W
09EB2:  BRA    9EB6
09EB4:  BRA    9EBA
09EB6:  MOVF   xFD,F
09EB8:  BNZ   9ED2
....................                {                                    
....................                   global_error_message_bitfield |= ERR_MSG_INCOMPATIBLE_STATE; 
09EBA:  BSF    xF0.1
....................                   PUSH_MESSAGE_QUEUE_MACRO(MSG_MOTE_ERROR_MSG); 
09EBC:  BCF    F7A.1
09EBE:  MOVLW  A0
09EC0:  MOVLB  5
09EC2:  MOVWF  x50
09EC4:  MOVLB  0
09EC6:  CALL   4D00
09ECA:  BSF    F7A.1
....................                   break;                                  
09ECC:  BRA    A492
....................                } 
09ECE:  BRA    9F04
09ED0:  MOVLB  4
....................                // or if you're in the run state and the valve is uncalibrated 
....................                else if ((global_system_state == SYSTEM_RUN) &&                \ 
....................                   (global_valve_position == VLV_POSITION_UNKNOWN)) 
09ED2:  MOVF   xFD,W
09ED4:  SUBLW  02
09ED6:  BNZ   9F06
09ED8:  MOVLB  0
09EDA:  INCFSZ xB9,W
09EDC:  BRA    9EE0
09EDE:  BRA    9EE4
09EE0:  MOVLB  4
09EE2:  BRA    9F06
09EE4:  INCFSZ xBA,W
09EE6:  BRA    9EEA
09EE8:  BRA    9EEE
09EEA:  MOVLB  4
09EEC:  BRA    9F06
....................                { 
....................                   global_error_message_bitfield |= ERR_MSG_VLV_NOT_CALIBRATED; 
09EEE:  MOVLB  4
09EF0:  BSF    xF0.2
....................                   PUSH_MESSAGE_QUEUE_MACRO(MSG_MOTE_ERROR_MSG); 
09EF2:  BCF    F7A.1
09EF4:  MOVLW  A0
09EF6:  MOVLB  5
09EF8:  MOVWF  x50
09EFA:  MOVLB  0
09EFC:  CALL   4D00
09F00:  BSF    F7A.1
....................                   break; 
09F02:  BRA    A492
09F04:  MOVLB  4
....................                } 
....................  
....................                // if valve movement is not needed (less than one millispan away 
....................                //    and in run state), break out of switch case 
....................                if ((global_system_state == SYSTEM_RUN) &&                     \ 
....................                (((global_valve_position_set_value - global_valve_position) < 0x20) || \ 
....................                ((global_valve_position - global_valve_position_set_value) < 0x20))) 
09F06:  MOVF   xFD,W
09F08:  SUBLW  02
09F0A:  BNZ   9F5A
09F0C:  MOVLB  0
09F0E:  MOVF   xB9,W
09F10:  SUBWF  xBB,W
09F12:  MOVLB  5
09F14:  MOVWF  x47
09F16:  MOVLB  0
09F18:  MOVF   xBA,W
09F1A:  SUBWFB xBC,W
09F1C:  MOVLB  5
09F1E:  MOVWF  x48
09F20:  MOVF   x48,F
09F22:  BNZ   9F2A
09F24:  MOVF   x47,W
09F26:  SUBLW  1F
09F28:  BC    9F54
09F2A:  MOVLB  0
09F2C:  MOVF   xBB,W
09F2E:  SUBWF  xB9,W
09F30:  MOVLB  5
09F32:  MOVWF  x47
09F34:  MOVLB  0
09F36:  MOVF   xBC,W
09F38:  SUBWFB xBA,W
09F3A:  MOVLB  5
09F3C:  MOVWF  x48
09F3E:  MOVF   x48,F
09F40:  BTFSC  FD8.2
09F42:  BRA    9F48
09F44:  MOVLB  4
09F46:  BRA    9F5A
09F48:  MOVF   x47,W
09F4A:  SUBLW  1F
09F4C:  BTFSC  FD8.0
09F4E:  BRA    9F54
09F50:  MOVLB  4
09F52:  BRA    9F5A
....................                {                
....................                   break;    
09F54:  MOVLB  0
09F56:  BRA    A492
09F58:  MOVLB  4
....................                }              
....................                                        
....................                // clear out the time in motion 
....................                global_valve_time_in_motion_1024ths = 0;   
09F5A:  MOVLB  0
09F5C:  CLRF   xC2
09F5E:  CLRF   xC1
....................                 
....................                // increment the movements since hitting an endstop. Also, check if 
....................                // enough valve movements have happened to warrant a recalibration of 
....................                //    the position of the valve by going towards an endstop 
....................                if ((global_valve_movements_since_endstop++) > VLV_MOVES_BEFORE_RECAL) 
09F60:  MOVF   xC7,W
09F62:  INCF   xC7,F
09F64:  SUBLW  19
09F66:  BC    9FAE
....................                { 
....................                   global_system_state = SYSTEM_RECAL_VLV_MOVES;                         
09F68:  MOVLW  16
09F6A:  MOVLB  4
09F6C:  MOVWF  xFD
....................                   // quicker to go to the closed endstop. Start motion. 
....................                   if ((global_valve_position_set_value + global_valve_position) >\ 
....................                      VLV_POSITION_OPENED) 
09F6E:  MOVLB  0
09F70:  MOVF   xB9,W
09F72:  ADDWF  xBB,W
09F74:  MOVLB  5
09F76:  MOVWF  x47
09F78:  MOVLB  0
09F7A:  MOVF   xBA,W
09F7C:  ADDWFC xBC,W
09F7E:  MOVLB  5
09F80:  MOVWF  x48
09F82:  SUBLW  7F
09F84:  BC    9F9E
09F86:  XORLW  FF
09F88:  BNZ   9F90
09F8A:  MOVF   x47,W
09F8C:  SUBLW  00
09F8E:  BC    9F9E
....................                   { 
....................                      CCP_3 = global_valve_time_to_close_1024th; 
09F90:  MOVFF  BE,F5F
09F94:  MOVFF  BD,F5E
....................                      mV_CLOSEm;                                                                    
09F98:  MOVLW  01
09F9A:  MOVWF  F8D
....................                   } 
09F9C:  BRA    9FAA
....................                   // quicker to go to the open endstop. Start motion. 
....................                   else    
....................                   { 
....................                      CCP_3 = global_valve_time_to_open_1024th; 
09F9E:  MOVFF  C0,F5F
09FA2:  MOVFF  BF,F5E
....................                      // don't go to the open endstop to avoid magnetic decoupling 
....................                      //mV_OPENm; 
....................                      mV_CLOSEm; 
09FA6:  MOVLW  01
09FA8:  MOVWF  F8D
....................                   } 
....................                } 
09FAA:  BRA    A014
09FAC:  MOVLB  0
....................                 
....................                // regular valve move (without recalibration) 
....................                else 
....................                { 
....................                   // setup CCP3 and put the valve into motion based on target value 
....................                   if (global_valve_position_set_value > global_valve_position) 
09FAE:  MOVF   xBA,W
09FB0:  SUBWF  xBC,W
09FB2:  BNC   9FCA
09FB4:  BNZ   9FBC
09FB6:  MOVF   xBB,W
09FB8:  SUBWF  xB9,W
09FBA:  BC    9FCA
....................                   { 
....................                      CCP_3 = global_valve_time_to_open_1024th; 
09FBC:  MOVFF  C0,F5F
09FC0:  MOVFF  BF,F5E
....................                      mV_OPENm;  
09FC4:  MOVLW  02
09FC6:  MOVWF  F8D
....................                   } 
09FC8:  BRA    A012
....................                   else if (global_valve_position_set_value < global_valve_position) 
09FCA:  MOVF   xBC,W
09FCC:  SUBWF  xBA,W
09FCE:  BNC   9FE6
09FD0:  BNZ   9FD8
09FD2:  MOVF   xB9,W
09FD4:  SUBWF  xBB,W
09FD6:  BC    9FE6
....................                   { 
....................                      CCP_3 = global_valve_time_to_close_1024th; 
09FD8:  MOVFF  BE,F5F
09FDC:  MOVFF  BD,F5E
....................                      mV_CLOSEm; 
09FE0:  MOVLW  01
09FE2:  MOVWF  F8D
....................                   } 
09FE4:  BRA    A012
....................                   else if (global_valve_position_set_value == VLV_POSITION_OPENED) 
09FE6:  MOVF   xBB,F
09FE8:  BNZ   9FFE
09FEA:  MOVF   xBC,W
09FEC:  SUBLW  80
09FEE:  BNZ   9FFE
....................                   { 
....................                      CCP_3 = global_valve_time_to_open_1024th; 
09FF0:  MOVFF  C0,F5F
09FF4:  MOVFF  BF,F5E
....................                      mV_OPENm;   
09FF8:  MOVLW  02
09FFA:  MOVWF  F8D
....................                   } 
09FFC:  BRA    A012
....................                   else if (global_valve_position_set_value == VLV_POSITION_CLOSED) 
09FFE:  MOVF   xBB,F
0A000:  BNZ   A012
0A002:  MOVF   xBC,F
0A004:  BNZ   A012
....................                   { 
....................                      CCP_3 = global_valve_time_to_close_1024th; 
0A006:  MOVFF  BE,F5F
0A00A:  MOVFF  BD,F5E
....................                      mV_CLOSEm; 
0A00E:  MOVLW  01
0A010:  MOVWF  F8D
0A012:  MOVLB  5
....................                   }                  
....................                }    
....................                 
....................                // setup/turn on the comparator interrupt (also sets up DAC) 
....................                comparator_setup();                                          
0A014:  MOVLB  0
0A016:  CALL   7B70
....................                 
....................                // setup and enable CCP3 as well as it's respective timer 
....................                setup_ccp3(CCP_USE_TIMER1_AND_TIMER2 | CCP_COMPARE_RESET_TIMER); 
0A01A:  MOVLW  0B
0A01C:  MOVLB  F
0A01E:  MOVWF  x5D
0A020:  CLRF   x5C
0A022:  CLRF   x5B
0A024:  MOVLW  01
0A026:  MOVWF  x5A
0A028:  MOVLW  3F
0A02A:  ANDWF  x49,F
0A02C:  MOVLW  00
0A02E:  IORWF  x49,F
....................                setup_timer_1(T1_ENABLE_SOSC | T1_EXTERNAL_SYNC | T1_DIV_BY_1); 
0A030:  MOVLW  8B
0A032:  MOVWF  FCD
0A034:  CLRF   FCC
....................                set_timer1(0); 
0A036:  CLRF   FCF
0A038:  CLRF   FCE
....................                 
....................                // clear any ccp3 interrupt and enable ccp3 interrupt 
....................                clear_interrupt(INT_CCP3); 
0A03A:  BCF    F7B.0
....................                enable_interrupts(INT_CCP3);            
0A03C:  BSF    F7A.0
....................                break; 
0A03E:  MOVLB  0
0A040:  BRA    A492
....................                 
....................             // Start GPS aquisition 
....................             case START_GPS_AQUISITION: 
....................                break; 
0A042:  BRA    A492
....................                                                      
....................             // Check GPS for lock 
....................             case CHECK_GPS_FOR_LOCK:     
....................                break;                    
0A044:  BRA    A492
....................                             
....................             case TAKE_XCDR_MESUREMENT_1: 
....................                // turn on XDCR power (must give ~50ms to settle) 
....................                output_high(XDCR_PWR);                     
0A046:  BSF    F8B.5
....................                // queue up the actual meaurement a second later.                    
....................                PUSH_TIME_QUEUE_MACRO(global_rtc_time + 1, TAKE_XCDR_MESUREMENT_2); 
0A048:  BCF    F7A.1
0A04A:  MOVLW  01
0A04C:  ADDWF  x85,W
0A04E:  MOVLB  5
0A050:  MOVWF  x47
0A052:  MOVLW  00
0A054:  MOVLB  0
0A056:  ADDWFC x86,W
0A058:  MOVLB  5
0A05A:  MOVWF  x48
0A05C:  MOVLW  00
0A05E:  MOVLB  0
0A060:  ADDWFC x87,W
0A062:  MOVLB  5
0A064:  MOVWF  x49
0A066:  MOVLW  00
0A068:  MOVLB  0
0A06A:  ADDWFC x88,W
0A06C:  MOVLB  5
0A06E:  MOVWF  x4A
0A070:  MOVWF  x55
0A072:  MOVFF  549,554
0A076:  MOVFF  548,553
0A07A:  MOVFF  547,552
0A07E:  MOVLW  56
0A080:  MOVWF  x56
0A082:  MOVLB  0
0A084:  CALL   414A
0A088:  BSF    F7A.1
....................                break; 
0A08A:  BRA    A492
....................                                                                                      
....................             case TAKE_XCDR_MESUREMENT_2:    
....................                // take the actual xdcr measurement via the adc (stores the result in global_xdcr_output)     
....................                adc_XDCR_measure();     
0A08C:  GOTO   7B9E
....................                // add xdcr message to queue                       
....................                PUSH_MESSAGE_QUEUE_MACRO(MSG_MOTE_XDCR_READ_MSG);  
0A090:  BCF    F7A.1
0A092:  MOVLW  98
0A094:  MOVLB  5
0A096:  MOVWF  x50
0A098:  MOVLB  0
0A09A:  CALL   4D00
0A09E:  BSF    F7A.1
....................                break;                                             
0A0A0:  BRA    A492
....................                                         
....................             // Update the LCD 
....................             // In the future, we're going to have "pages" controlled by the switch. 
....................             case LCD_UPDATE:           
....................                // instructed to skip this update (to show other things on screen)          
....................                 
....................                // disable button press interrupt while accessing shared global lcd variables 
.................... //               disable_interrupts(INT_RB);    
....................                 
....................                if (global_skip_lcd_update_count > 1)   
0A0A2:  MOVF   x83,W
0A0A4:  SUBLW  01
0A0A6:  BC    A0AC
....................                {                   
....................                   global_skip_lcd_update_count--;     
0A0A8:  DECF   x83,F
....................                } 
0A0AA:  BRA    A0B0
....................                // either normal update or screen clear and update via function call (for multiple pages)     
....................                else                  
....................                {        
....................                   LCD_update_diplay();             
0A0AC:  GOTO   7FF6
....................                } 
....................                 
....................                // disable button press interrupt while accessing shared global lcd variables 
.................... //               enable_interrupts(INT_RB);  
....................                  
....................                break;                                          
0A0B0:  BRA    A492
....................                 
....................             // recovers from an i2c bus collision interrupt 
....................             case BUSCOL_RESET:                    
....................                BCL1IF = FALSE; 
0A0B2:  BCF    FA1.3
....................                SSP1IF = TRUE; 
0A0B4:  BSF    F9E.3
....................                i2c_init(TRUE);             
0A0B6:  BCF    FCB.0
0A0B8:  BCF    FCB.1
0A0BA:  BCF    FCB.3
0A0BC:  MOVLW  06
0A0BE:  MOVWF  FC8
0A0C0:  MOVLW  28
0A0C2:  MOVWF  FC6
0A0C4:  BSF    FC7.7
0A0C6:  BCF    FC7.6
....................                if (global_lcd_enabled) LCD_init();   
0A0C8:  BTFSC  x9F.0
0A0CA:  CALL   3710
....................                enable_interrupts(GLOBAL);          
0A0CE:  MOVLW  C0
0A0D0:  IORWF  FF2,F
....................                break;                                                    
0A0D2:  BRA    A492
....................                 
....................             // Reset the mote (triggers a wait for boot event) 
....................             case RESET_MOTE:      
....................                // display on screen what is happening 
....................                LCD_clear();             
0A0D4:  CALL   59CA
....................                strcpy (global_temp_line_buff, "Resetting Mote!!"); 
0A0D8:  CLRF   FEA
0A0DA:  MOVLW  70
0A0DC:  MOVWF  FE9
0A0DE:  MOVLW  00
0A0E0:  CALL   06FE
0A0E4:  TBLRD*-
0A0E6:  TBLRD*+
0A0E8:  MOVF   FF5,W
0A0EA:  MOVWF  FEE
0A0EC:  IORLW  00
0A0EE:  BNZ   A0E6
....................                LCD_line1(global_temp_line_buff); 
0A0F0:  MOVLB  5
0A0F2:  CLRF   x60
0A0F4:  MOVLW  70
0A0F6:  MOVWF  x5F
0A0F8:  MOVLB  0
0A0FA:  CALL   365A
....................                global_skip_lcd_update_count = 2;    
0A0FE:  MOVLW  02
0A100:  MOVWF  x83
....................                // disable mote enabled flag 
....................                global_dust_enabled = 0;      
0A102:  BCF    x9F.6
....................                // reset the mote    
....................                mote_reset();  
0A104:  CALL   4398
....................                break;                            
0A108:  BRA    A492
....................              
....................             // Make sure the mote is responding to a boot or shutdown 
....................             case WAIT_FOR_BOOT_EVENT:     
....................                // if the mote didn't respond, set error, open valve, shutdown 
....................                if (global_dust_enabled == 0) 
0A10A:  BTFSC  x9F.6
0A10C:  BRA    A158
....................                {         
....................                   //  
....................                   LCD_clear();    
0A10E:  CALL   59CA
....................                   strcpy (global_temp_line_buff, "Mote is Dead    ");   
0A112:  CLRF   FEA
0A114:  MOVLW  70
0A116:  MOVWF  FE9
0A118:  MOVLW  00
0A11A:  CALL   0720
0A11E:  TBLRD*-
0A120:  TBLRD*+
0A122:  MOVF   FF5,W
0A124:  MOVWF  FEE
0A126:  IORLW  00
0A128:  BNZ   A120
....................                   LCD_line1(global_temp_line_buff);                   
0A12A:  MOVLB  5
0A12C:  CLRF   x60
0A12E:  MOVLW  70
0A130:  MOVWF  x5F
0A132:  MOVLB  0
0A134:  CALL   365A
....................                   global_skip_lcd_update_count = 2;   
0A138:  MOVLW  02
0A13A:  MOVWF  x83
....................                   // save shutdown cause and queue shutdown 
....................                   global_shutdown_cause = ERR_FAIL_ON_MOTE_RESET; 
0A13C:  MOVLW  01
0A13E:  MOVWF  4D
....................  
....................                   PUSH_PRIORITY_QUEUE(OPEN_VALVE_UNKNOWN_STATE);   
0A140:  MOVLW  3E
0A142:  MOVLB  5
0A144:  MOVWF  x50
0A146:  MOVLB  0
0A148:  CALL   43F2
....................                   PUSH_PRIORITY_QUEUE(SHUTDOWN_SYSTEM); 
0A14C:  MOVLW  F1
0A14E:  MOVLB  5
0A150:  MOVWF  x50
0A152:  MOVLB  0
0A154:  CALL   43F2
....................                }            
....................                break; 
0A158:  BRA    A492
....................                 
....................             // Check the mote status and react appropriately 
....................             case CHECK_MOTE_STATE: 
....................                mote_state_check(); 
0A15A:  GOTO   8440
....................                break; 
0A15E:  BRA    A492
....................                 
....................             case CHECK_MOTE_INFO: 
....................                mote_info_check(); 
0A160:  GOTO   8798
....................                break; 
0A164:  BRA    A492
....................                
....................             case UPDATE_MOTE_TIME: 
....................                mote_time_update(); 
0A166:  GOTO   8826
....................                break;    
0A16A:  BRA    A492
....................                 
....................             case UPDATE_MOTE_NETWORK_INFO: 
....................                get_mote_net_info(); 
0A16C:  GOTO   88B4
....................                break; 
0A170:  BRA    A492
....................                 
....................             // Check's battery voltage, decides to charge, not charge, tell manager 
....................             // about a low voltage state, or to go to deep sleep 
....................             case CHECK_BATTERY_STATE: 
....................                /* 
....................                LCD_clear(); 
....................                LCD_display_battery_voltage(0); 
....................                LCD_place_uint16(get_vbatt(0),1,0,5); 
....................                global_skip_lcd_update_count = 2; 
....................                */         
....................                check_and_deal_with_battery(); 
0A172:  GOTO   8942
....................                break; 
0A176:  BRA    A492
....................              
....................             // Query the mote for the temp and store it 
....................             case CHECK_MOTE_TEMP: 
....................                mote_temp_check(); 
0A178:  GOTO   8A60
....................                /* 
....................                LCD_clear(); 
....................                strcpy (global_temp_line_buff, "Temp =         C"); 
....................                LCD_line1(global_temp_line_buff); 
....................                LCD_place_uint8(global_mote_temperature,0,7,3); 
....................                global_skip_lcd_update_count = 2; 
....................                */ 
....................                break; 
0A17C:  BRA    A492
....................                 
....................             // First part of the search for strongest algorithm 
....................             case SEARCH_FOR_STRONGEST_1: 
....................                LCD_clear(); 
0A17E:  CALL   59CA
....................                strcpy (global_temp_line_buff, "Search Strong 1 "); 
0A182:  CLRF   FEA
0A184:  MOVLW  70
0A186:  MOVWF  FE9
0A188:  MOVLW  00
0A18A:  CALL   0742
0A18E:  TBLRD*-
0A190:  TBLRD*+
0A192:  MOVF   FF5,W
0A194:  MOVWF  FEE
0A196:  IORLW  00
0A198:  BNZ   A190
....................                LCD_line1(global_temp_line_buff); 
0A19A:  MOVLB  5
0A19C:  CLRF   x60
0A19E:  MOVLW  70
0A1A0:  MOVWF  x5F
0A1A2:  MOVLB  0
0A1A4:  CALL   365A
....................                global_skip_lcd_update_count = 2; 
0A1A8:  MOVLW  02
0A1AA:  MOVWF  x83
....................                // set the state of the system appropriately 
....................                global_system_state = SYSTEM_SEARCHING_FOR_NETWORK; 
0A1AC:  MOVLW  20
0A1AE:  MOVLB  4
0A1B0:  MOVWF  xFD
....................                PUSH_PRIORITY_QUEUE_MACRO(RESET_MOTE); 
0A1B2:  BCF    F7A.1
0A1B4:  MOVLW  11
0A1B6:  MOVLB  5
0A1B8:  MOVWF  x50
0A1BA:  MOVLB  0
0A1BC:  CALL   43F2
0A1C0:  BSF    F7A.1
....................                PUSH_TIME_QUEUE_MACRO((global_rtc_time + 10), SEARCH_FOR_STRONGEST_2); 
0A1C2:  BCF    F7A.1
0A1C4:  MOVLW  0A
0A1C6:  ADDWF  x85,W
0A1C8:  MOVLB  5
0A1CA:  MOVWF  x47
0A1CC:  MOVLW  00
0A1CE:  MOVLB  0
0A1D0:  ADDWFC x86,W
0A1D2:  MOVLB  5
0A1D4:  MOVWF  x48
0A1D6:  MOVLW  00
0A1D8:  MOVLB  0
0A1DA:  ADDWFC x87,W
0A1DC:  MOVLB  5
0A1DE:  MOVWF  x49
0A1E0:  MOVLW  00
0A1E2:  MOVLB  0
0A1E4:  ADDWFC x88,W
0A1E6:  MOVLB  5
0A1E8:  MOVWF  x4A
0A1EA:  MOVWF  x55
0A1EC:  MOVFF  549,554
0A1F0:  MOVFF  548,553
0A1F4:  MOVFF  547,552
0A1F8:  MOVLW  B2
0A1FA:  MOVWF  x56
0A1FC:  MOVLB  0
0A1FE:  CALL   414A
0A202:  BSF    F7A.1
....................                break; 
0A204:  BRA    A492
....................                 
....................             // Second part of the search for strongest algorithm    
....................             case SEARCH_FOR_STRONGEST_2: 
....................                LCD_clear(); 
0A206:  CALL   59CA
....................                strcpy (global_temp_line_buff, "Search Strong 2 "); 
0A20A:  CLRF   FEA
0A20C:  MOVLW  70
0A20E:  MOVWF  FE9
0A210:  MOVLW  00
0A212:  CALL   0764
0A216:  TBLRD*-
0A218:  TBLRD*+
0A21A:  MOVF   FF5,W
0A21C:  MOVWF  FEE
0A21E:  IORLW  00
0A220:  BNZ   A218
....................                LCD_line1(global_temp_line_buff); 
0A222:  MOVLB  5
0A224:  CLRF   x60
0A226:  MOVLW  70
0A228:  MOVWF  x5F
0A22A:  MOVLB  0
0A22C:  CALL   365A
....................                global_skip_lcd_update_count = 2; 
0A230:  MOVLW  02
0A232:  MOVWF  x83
....................                search_for_strongest(); 
0A234:  GOTO   8E78
....................                break; 
0A238:  BRA    A492
....................              
....................             // Initalizes a mote join 
....................             case INIT_JOIN: 
....................                LCD_clear(); 
0A23A:  CALL   59CA
....................                strcpy (global_temp_line_buff, "  Init Join     "); 
0A23E:  CLRF   FEA
0A240:  MOVLW  70
0A242:  MOVWF  FE9
0A244:  MOVLW  00
0A246:  CALL   0786
0A24A:  TBLRD*-
0A24C:  TBLRD*+
0A24E:  MOVF   FF5,W
0A250:  MOVWF  FEE
0A252:  IORLW  00
0A254:  BNZ   A24C
....................                LCD_line1(global_temp_line_buff); 
0A256:  MOVLB  5
0A258:  CLRF   x60
0A25A:  MOVLW  70
0A25C:  MOVWF  x5F
0A25E:  MOVLB  0
0A260:  CALL   365A
....................                global_skip_lcd_update_count = 2;   
0A264:  MOVLW  02
0A266:  MOVWF  x83
....................                initiate_join();                                      
0A268:  GOTO   92A4
....................                break; 
0A26C:  BRA    A492
....................              
....................             // not used anymore 
....................             case OPTIMIZE_MPPC: 
....................                adjust_mppc();   
0A26E:  GOTO   941E
....................                break;             
0A272:  BRA    A492
....................                 
....................             // resets the cpu (if all pending messages are sent)    
....................             case CPU_RESET: 
....................                // if the dust network is operational and the message queue is not empty (location at 255) 
....................                //    wait for the message to be ack'd/resent and reschedule the shutdown.  
....................                if ((global_dust_operational == TRUE) && (global_current_message_queue_location != 255)) 
0A274:  BTFSS  x9F.7
0A276:  BRA    A2CA
0A278:  MOVLB  4
0A27A:  INCFSZ xEF,W
0A27C:  BRA    A284
0A27E:  MOVLB  0
0A280:  BRA    A2CA
0A282:  MOVLB  4
....................                { 
....................                   PUSH_TIME_QUEUE_MACRO((global_rtc_time + 10), CPU_RESET); 
0A284:  BCF    F7A.1
0A286:  MOVLW  0A
0A288:  MOVLB  0
0A28A:  ADDWF  x85,W
0A28C:  MOVLB  5
0A28E:  MOVWF  x47
0A290:  MOVLW  00
0A292:  MOVLB  0
0A294:  ADDWFC x86,W
0A296:  MOVLB  5
0A298:  MOVWF  x48
0A29A:  MOVLW  00
0A29C:  MOVLB  0
0A29E:  ADDWFC x87,W
0A2A0:  MOVLB  5
0A2A2:  MOVWF  x49
0A2A4:  MOVLW  00
0A2A6:  MOVLB  0
0A2A8:  ADDWFC x88,W
0A2AA:  MOVLB  5
0A2AC:  MOVWF  x4A
0A2AE:  MOVWF  x55
0A2B0:  MOVFF  549,554
0A2B4:  MOVFF  548,553
0A2B8:  MOVFF  547,552
0A2BC:  MOVLW  F0
0A2BE:  MOVWF  x56
0A2C0:  MOVLB  0
0A2C2:  CALL   414A
0A2C6:  BSF    F7A.1
....................                } 
0A2C8:  BRA    A318
....................                // if the valve is moving, check again later 
....................                else if (!IS_VLV_COASTING) 
0A2CA:  MOVF   F8D,F
0A2CC:  BZ    A312
....................                {                       
....................                   PUSH_TIME_QUEUE_MACRO((global_rtc_time + 10), CPU_RESET); 
0A2CE:  BCF    F7A.1
0A2D0:  MOVLW  0A
0A2D2:  ADDWF  x85,W
0A2D4:  MOVLB  5
0A2D6:  MOVWF  x47
0A2D8:  MOVLW  00
0A2DA:  MOVLB  0
0A2DC:  ADDWFC x86,W
0A2DE:  MOVLB  5
0A2E0:  MOVWF  x48
0A2E2:  MOVLW  00
0A2E4:  MOVLB  0
0A2E6:  ADDWFC x87,W
0A2E8:  MOVLB  5
0A2EA:  MOVWF  x49
0A2EC:  MOVLW  00
0A2EE:  MOVLB  0
0A2F0:  ADDWFC x88,W
0A2F2:  MOVLB  5
0A2F4:  MOVWF  x4A
0A2F6:  MOVWF  x55
0A2F8:  MOVFF  549,554
0A2FC:  MOVFF  548,553
0A300:  MOVFF  547,552
0A304:  MOVLW  F0
0A306:  MOVWF  x56
0A308:  MOVLB  0
0A30A:  CALL   414A
0A30E:  BSF    F7A.1
....................                } 
0A310:  BRA    A318
....................                // All messages are sent 
....................                else 
....................                { 
....................                   // if it does, restart the entire system 
....................                   store_all_eeprom_values(); 
0A312:  CALL   94F8
....................                   reset_cpu(); 
0A316:  RESET
....................                } 
....................                break; 
0A318:  BRA    A492
....................                 
....................             // Shuts down the pic for a variety of reasons 
....................             case SHUTDOWN_SYSTEM:                
....................                // if the dust network is operational and the message queue is not empty (location at 255) 
....................                //    wait for the message to be ack'd/resent and reschedule the shutdown. 
....................                // I suppose this has potential to be problamatic, but the network should eventually show 
....................                //    up as non-operational in mote-check or get ack'd at some point, I would hope. 
....................                                                               
....................                global_brake_duty_set_value = NO_BRK; 
0A31A:  CLRF   xAF
0A31C:  CLRF   xAE
....................                global_charge_duty_set_value = NO_CHARGE; 
0A31E:  CLRF   xB1
0A320:  CLRF   xB0
....................                global_control_loop_mechanism = NO_RPM_CONTROL_DYN_MPPC; 
0A322:  MOVLW  06
0A324:  MOVWF  xB8
....................                 
....................                if ((global_brake_duty != NO_BRK) || (global_charge_duty != NO_CHARGE)) 
0A326:  MOVF   xAA,F
0A328:  BNZ   A336
0A32A:  MOVF   xAB,F
0A32C:  BNZ   A336
0A32E:  MOVF   xAC,F
0A330:  BNZ   A336
0A332:  MOVF   xAD,F
0A334:  BZ    A33A
....................                { 
....................                   break; 
0A336:  BRA    A492
....................                } 
0A338:  BRA    A490
....................                else if ((global_dust_operational == TRUE) && (global_current_message_queue_location != 255)) 
0A33A:  BTFSS  x9F.7
0A33C:  BRA    A390
0A33E:  MOVLB  4
0A340:  INCFSZ xEF,W
0A342:  BRA    A34A
0A344:  MOVLB  0
0A346:  BRA    A390
0A348:  MOVLB  4
....................                {                                                 
....................                   PUSH_TIME_QUEUE_MACRO((global_rtc_time + 10), SHUTDOWN_SYSTEM); 
0A34A:  BCF    F7A.1
0A34C:  MOVLW  0A
0A34E:  MOVLB  0
0A350:  ADDWF  x85,W
0A352:  MOVLB  5
0A354:  MOVWF  x47
0A356:  MOVLW  00
0A358:  MOVLB  0
0A35A:  ADDWFC x86,W
0A35C:  MOVLB  5
0A35E:  MOVWF  x48
0A360:  MOVLW  00
0A362:  MOVLB  0
0A364:  ADDWFC x87,W
0A366:  MOVLB  5
0A368:  MOVWF  x49
0A36A:  MOVLW  00
0A36C:  MOVLB  0
0A36E:  ADDWFC x88,W
0A370:  MOVLB  5
0A372:  MOVWF  x4A
0A374:  MOVWF  x55
0A376:  MOVFF  549,554
0A37A:  MOVFF  548,553
0A37E:  MOVFF  547,552
0A382:  MOVLW  F1
0A384:  MOVWF  x56
0A386:  MOVLB  0
0A388:  CALL   414A
0A38C:  BSF    F7A.1
....................                } 
0A38E:  BRA    A490
....................                // if the valve is moving, check again later 
....................                else if (!IS_VLV_COASTING) 
0A390:  MOVF   F8D,F
0A392:  BZ    A3D8
....................                { 
....................                   PUSH_TIME_QUEUE_MACRO((global_rtc_time + 10), SHUTDOWN_SYSTEM); 
0A394:  BCF    F7A.1
0A396:  MOVLW  0A
0A398:  ADDWF  x85,W
0A39A:  MOVLB  5
0A39C:  MOVWF  x47
0A39E:  MOVLW  00
0A3A0:  MOVLB  0
0A3A2:  ADDWFC x86,W
0A3A4:  MOVLB  5
0A3A6:  MOVWF  x48
0A3A8:  MOVLW  00
0A3AA:  MOVLB  0
0A3AC:  ADDWFC x87,W
0A3AE:  MOVLB  5
0A3B0:  MOVWF  x49
0A3B2:  MOVLW  00
0A3B4:  MOVLB  0
0A3B6:  ADDWFC x88,W
0A3B8:  MOVLB  5
0A3BA:  MOVWF  x4A
0A3BC:  MOVWF  x55
0A3BE:  MOVFF  549,554
0A3C2:  MOVFF  548,553
0A3C6:  MOVFF  547,552
0A3CA:  MOVLW  F1
0A3CC:  MOVWF  x56
0A3CE:  MOVLB  0
0A3D0:  CALL   414A
0A3D4:  BSF    F7A.1
....................                } 
0A3D6:  BRA    A490
....................                // All messages are sent or system is shutting down due to no network connection 
....................                else if ((global_system_state == SYSTEM_RUN) || ((global_system_state == SYSTEM_RUN) && (global_dust_operational == FALSE))) 
0A3D8:  MOVLB  4
0A3DA:  MOVF   xFD,W
0A3DC:  SUBLW  02
0A3DE:  BZ    A3F2
0A3E0:  MOVF   xFD,W
0A3E2:  SUBLW  02
0A3E4:  BNZ   A44C
0A3E6:  MOVLB  0
0A3E8:  BTFSS  x9F.7
0A3EA:  BRA    A3F0
0A3EC:  MOVLB  4
0A3EE:  BRA    A44C
0A3F0:  MOVLB  4
....................                { 
....................                   // try to put the mote to sleep 
....................                   if (mote_sleep() == NO_ERR) 
0A3F2:  MOVLB  0
0A3F4:  GOTO   956C
0A3F8:  MOVF   01,F
0A3FA:  BNZ   A406
....................                   { 
....................                      // if it does, put the entire system to sleep 
....................                      store_all_eeprom_values(); 
0A3FC:  CALL   94F8
....................                      deep_sleep(); 
0A400:  CALL   8C0A
....................                   } 
0A404:  BRA    A448
....................                   // otherwise, try again in 10 seconds    
....................                   else 
....................                   { 
....................                      PUSH_TIME_QUEUE_MACRO((global_rtc_time + 10), SHUTDOWN_SYSTEM); 
0A406:  BCF    F7A.1
0A408:  MOVLW  0A
0A40A:  ADDWF  x85,W
0A40C:  MOVLB  5
0A40E:  MOVWF  x47
0A410:  MOVLW  00
0A412:  MOVLB  0
0A414:  ADDWFC x86,W
0A416:  MOVLB  5
0A418:  MOVWF  x48
0A41A:  MOVLW  00
0A41C:  MOVLB  0
0A41E:  ADDWFC x87,W
0A420:  MOVLB  5
0A422:  MOVWF  x49
0A424:  MOVLW  00
0A426:  MOVLB  0
0A428:  ADDWFC x88,W
0A42A:  MOVLB  5
0A42C:  MOVWF  x4A
0A42E:  MOVWF  x55
0A430:  MOVFF  549,554
0A434:  MOVFF  548,553
0A438:  MOVFF  547,552
0A43C:  MOVLW  F1
0A43E:  MOVWF  x56
0A440:  MOVLB  0
0A442:  CALL   414A
0A446:  BSF    F7A.1
....................                   } 
....................                } 
0A448:  BRA    A490
0A44A:  MOVLB  4
....................                // Anything else, just wait 
....................                else 
....................                { 
....................                   PUSH_TIME_QUEUE_MACRO((global_rtc_time + 10), SHUTDOWN_SYSTEM); 
0A44C:  BCF    F7A.1
0A44E:  MOVLW  0A
0A450:  MOVLB  0
0A452:  ADDWF  x85,W
0A454:  MOVLB  5
0A456:  MOVWF  x47
0A458:  MOVLW  00
0A45A:  MOVLB  0
0A45C:  ADDWFC x86,W
0A45E:  MOVLB  5
0A460:  MOVWF  x48
0A462:  MOVLW  00
0A464:  MOVLB  0
0A466:  ADDWFC x87,W
0A468:  MOVLB  5
0A46A:  MOVWF  x49
0A46C:  MOVLW  00
0A46E:  MOVLB  0
0A470:  ADDWFC x88,W
0A472:  MOVLB  5
0A474:  MOVWF  x4A
0A476:  MOVWF  x55
0A478:  MOVFF  549,554
0A47C:  MOVFF  548,553
0A480:  MOVFF  547,552
0A484:  MOVLW  F1
0A486:  MOVWF  x56
0A488:  MOVLB  0
0A48A:  CALL   414A
0A48E:  BSF    F7A.1
....................                } 
....................                break; 
0A490:  BRA    A492
....................                 
....................             // updates  
....................             // Default case (nothing to do)                
....................             case EMPTY_PRIORITY_QUEUE: 
....................                //LCD_place_uint32(global_rtc_time, 1, 0, 10); 
....................                break; 
....................          } 
....................           
....................       } 
0A492:  GOTO   9A44
.................... ////////////////////End of Priority Queue Handling///////////////////////////// 
....................    // end of inifinite while loop 
....................    }    
.................... } 
....................  
....................  
.................... //#PRIORITY COMP, CCP5, EXT2, CCP3, CCP4, BUSCOL 
.................... #PRIORITY CCP5, COMP, CCP3, EXT2, TIMER0, CCP4, BUSCOL, INT_RB, EXT           
....................                                                                      
.................... #INT_RB          
.................... void RB_ISR(void)                                
0A496:  SLEEP 
.................... {                           
....................    // Setup in periph init to be called only when RB4 has changed state 
....................    // RB4 is connected to SW1n  
....................     
....................    // keeps track of when the switch was pressed so we can enable the long press functionality      
....................    static uint32_t sw1_start_time = 0;             
....................  
....................    RBIF = FALSE; 
*
007A8:  BCF    FF2.0
....................     
....................    if (!input(SW1n)) 
007AA:  BTFSC  F81.4
007AC:  BRA    07B0
....................    {                             
....................       return;   
007AE:  BRA    07C2
....................    }            
....................     
....................    // if you're incrementing past the last page, reset to the first page   
....................    if (global_lcd_page_number == TOTAL_LCD_PAGES) 
007B0:  MOVF   x84,W
007B2:  SUBLW  03
007B4:  BNZ   07BC
....................    {                                             
....................       global_lcd_page_number = 1;    
007B6:  MOVLW  01
007B8:  MOVWF  x84
....................    }      
007BA:  BRA    07BE
....................    // otherwie, just increment the page number 
....................    else     
....................    { 
....................       global_lcd_page_number++; 
007BC:  INCF   x84,F
....................    }  
....................     
....................    // trigger a full LCD update (including the contstant parts of the lcd) 
....................    global_skip_lcd_update_count = 1;       
007BE:  MOVLW  01
007C0:  MOVWF  x83
....................           
....................    return;    
....................     
....................     
.................... /*       
....................    // not quite ready for prime time long press code (causes boot-looping, but is probably close) 
....................    // if SW1 is depressed (active), take note of the time  
....................    if (!input(SW1n)) 
....................    { 
....................       sw1_start_time = global_rtc_time;   
....................    }                                  
....................    // when SW1 is coming back up  
....................    else                   
....................    {                                         
....................       // if the button has been pressed more than SW1_ISR_LONG_PRESS_TIME     
....................       //    do the long-press action 
....................       if ((global_rtc_time - sw1_start_time) > SW1_ISR_LONG_PRESS_TIME) 
....................       {                   
....................          // long-press action 
....................          flash_leds_ISR(2);  
....................       }         
....................                                            
....................       // if the button had been pressed less than SW1_ISR_LONG_PRESS_TIME, increment the page    
....................       else 
....................       {         
....................          // if you're incrementing past the last page, reset to the first page   
....................          if (global_lcd_page_number == TOTAL_LCD_PAGES) 
....................          {                                             
....................             global_lcd_page_number = 1;    
....................          }      
....................          // otherwie, just increment the page number 
....................          else     
....................          { 
....................             global_lcd_page_number++; 
....................          }  
....................           
....................          // trigger a full LCD update (including the contstant parts of the lcd) 
....................          global_skip_lcd_update_count = 1;                  
....................       } 
....................    }    
.................... */     
.................... } 
....................  
....................  
007C2:  BCF    FF2.0
007C4:  GOTO   00A0
.................... #INT_EXT 
.................... void vgen_wakeup_ISR(void) 
.................... { 
.................... // runs on wakeup from vgen int 
....................    reset_cpu();                  
007C8:  RESET
.................... }                 
....................  
007CA:  BCF    FF2.1
007CC:  GOTO   015E
.................... #INT_BUSCOL 
.................... void BUSCOL_ISR(void) 
.................... {   
.................... // Catches and recovers from an i2c bus collision  
....................  
....................    // are reenabled in MAIN        
....................    disable_interrupts(GLOBAL); 
*
00882:  BCF    FF2.6
00884:  BCF    FF2.7
00886:  BTFSC  FF2.7
00888:  BRA    0884
....................     
....................    // clear bus collision interrupt flag 
....................    BCL1IF = FALSE; 
0088A:  BCF    FA1.3
....................     
....................    // schedule a bus collision reset 
....................    PUSH_PRIORITY_QUEUE_ISR_MACRO(BUSCOL_RESET); 
0088C:  MOVLW  C0
0088E:  MOVLB  5
00890:  MOVWF  x9B
00892:  MOVLB  0
00894:  RCALL  07D0
....................  
....................    // if the lcd is connected, reset it 
....................    if (global_lcd_enabled) 
00896:  BTFSS  x9F.0
00898:  BRA    08A6
....................    {   
....................       output_low(LCD_RESETn); 
0089A:  BCF    F8C.2
....................       delay_cycles(64);       // about 1 millisecond 
0089C:  MOVLW  15
0089E:  MOVWF  00
008A0:  DECFSZ 00,F
008A2:  BRA    08A0
....................       output_high(LCD_RESETn); 
008A4:  BSF    F8C.2
....................    }    
....................     
....................    // send the stack pointer to position 1 (perhaps sort of dangerous) 
....................    STKPTR = 1; 
008A6:  MOVLW  01
008A8:  MOVWF  FFC
.................... } 
....................  
008AA:  BCF    FA1.3
008AC:  GOTO   00A0
.................... #INT_EXT2  
.................... void mote_interrupt(void) 
.................... {    
.................... // interrupt called when mote rts line gets asserted    
....................    uint8_t     tmp_oscccon, tmp_t2con, tmp_pr2, tmp_t0con; 
....................     
....................    // save the current oscillator setup 
....................    tmp_oscccon = OSCCON; 
*
016C6:  MOVFF  FD3,57F
....................    tmp_t2con = T2CON; 
016CA:  MOVFF  FBA,580
....................    tmp_pr2 = PR2; 
016CE:  MOVFF  FBB,581
....................    tmp_t0con = T0CON; 
016D2:  MOVFF  FD5,582
....................     
....................    // start primary (3.8Mhz) crystal for UART communication 
....................    fosc_pri_ISR(); 
016D6:  GOTO   08B0
....................     
....................    // disable int_ccp4 as (unsolicited) message queue can overwrite payload_buff 
....................    disable_interrupts(INT_CCP4); 
016DA:  BCF    F7A.1
....................                                    
....................    // recieve serial data, respond, and schedule deal with packet if necessary 
....................    deal_with_mote_ISR(); 
016DC:  BRA    11E2
....................     
....................    // renable int_ccp4 as we're done touching payload_buff       
....................    enable_interrupts(INT_CCP4);   
016DE:  BSF    F7A.1
....................                                      
....................    // restore the current oscillator 
....................    OSCCON = tmp_oscccon; 
016E0:  MOVFF  57F,FD3
....................    T2CON = tmp_t2con; 
016E4:  MOVFF  580,FBA
....................    T0CON = tmp_t0con; 
016E8:  MOVFF  582,FD5
....................    PR2 = tmp_PR2; 
016EC:  MOVFF  581,FBB
.................... } 
....................  
....................  
016F0:  BCF    FF0.1
016F2:  GOTO   00A0
.................... #INT_COMP 
.................... void comp1_ISR(void) 
.................... { 
.................... // ISR routine that is called when the comparator current limit is reached 
....................    uint16_t    temp16_frac; 
....................     
....................     // if comarator 1 is tripped (INT_COMP is triggered by comp 1 or 2) 
....................    if (C1OUT) 
*
0198C:  BTFSS  F79.6
0198E:  BRA    1D8C
....................    {      
....................       // grab the extra time/2ndary osc ticks since the last 1024th interrupt   
....................       temp16_frac = get_timer1(); 
01990:  MOVF   FCE,W
01992:  MOVLB  5
01994:  MOVWF  x7F
01996:  MOVFF  FCF,580
....................        
....................       // if statements for different calibration routines 
....................       // valve opening a little bit to ensure we dont jam into close endstop 
....................       if (global_system_state ==  SYSTEM_CAL_VLV_1) 
0199A:  MOVLB  4
0199C:  MOVF   xFD,W
0199E:  SUBLW  10
019A0:  BNZ   19F6
....................       { 
....................          global_valve_position = VLV_POSITION_OPENED; 
019A2:  MOVLW  80
019A4:  MOVLB  0
019A6:  MOVWF  xBA
019A8:  CLRF   xB9
....................          // queue up the next stage of the calibration 
....................          push_time_queue_ISR(global_rtc_time + 3, CALIBRATE_VALVE_2); 
019AA:  MOVLW  03
019AC:  ADDWF  x85,W
019AE:  MOVLB  5
019B0:  MOVWF  x81
019B2:  MOVLW  00
019B4:  MOVLB  0
019B6:  ADDWFC x86,W
019B8:  MOVLB  5
019BA:  MOVWF  x82
019BC:  MOVLW  00
019BE:  MOVLB  0
019C0:  ADDWFC x87,W
019C2:  MOVLB  5
019C4:  MOVWF  x83
019C6:  MOVLW  00
019C8:  MOVLB  0
019CA:  ADDWFC x88,W
019CC:  MOVLB  5
019CE:  MOVWF  x84
019D0:  CLRF   19
019D2:  BTFSC  FF2.7
019D4:  BSF    19.7
019D6:  BCF    FF2.7
019D8:  MOVWF  xBA
019DA:  MOVFF  583,5B9
019DE:  MOVFF  582,5B8
019E2:  MOVFF  581,5B7
019E6:  MOVLW  32
019E8:  MOVWF  xBB
019EA:  MOVLB  0
019EC:  RCALL  16F6
019EE:  BTFSC  19.7
019F0:  BSF    FF2.7
....................       } 
019F2:  BRA    1D74
019F4:  MOVLB  4
....................       // valve closing towards closing endstop pre-calibration 
....................       else if (global_system_state == SYSTEM_CAL_VLV_2) 
019F6:  MOVF   xFD,W
019F8:  SUBLW  11
019FA:  BNZ   1A4E
....................       { 
....................          global_valve_position = VLV_POSITION_CLOSED;  
019FC:  MOVLB  0
019FE:  CLRF   xBA
01A00:  CLRF   xB9
....................          // queue up the next stage of the calibration 
....................          push_time_queue_ISR(global_rtc_time + 3, CALIBRATE_VALVE_3); 
01A02:  MOVLW  03
01A04:  ADDWF  x85,W
01A06:  MOVLB  5
01A08:  MOVWF  x81
01A0A:  MOVLW  00
01A0C:  MOVLB  0
01A0E:  ADDWFC x86,W
01A10:  MOVLB  5
01A12:  MOVWF  x82
01A14:  MOVLW  00
01A16:  MOVLB  0
01A18:  ADDWFC x87,W
01A1A:  MOVLB  5
01A1C:  MOVWF  x83
01A1E:  MOVLW  00
01A20:  MOVLB  0
01A22:  ADDWFC x88,W
01A24:  MOVLB  5
01A26:  MOVWF  x84
01A28:  CLRF   19
01A2A:  BTFSC  FF2.7
01A2C:  BSF    19.7
01A2E:  BCF    FF2.7
01A30:  MOVWF  xBA
01A32:  MOVFF  583,5B9
01A36:  MOVFF  582,5B8
01A3A:  MOVFF  581,5B7
01A3E:  MOVLW  33
01A40:  MOVWF  xBB
01A42:  MOVLB  0
01A44:  RCALL  16F6
01A46:  BTFSC  19.7
01A48:  BSF    FF2.7
....................       } 
01A4A:  BRA    1D74
01A4C:  MOVLB  4
....................       // valve opening fully from fully closed for calibration 
....................       else if (global_system_state == SYSTEM_CAL_VLV_3) 
01A4E:  MOVF   xFD,W
01A50:  SUBLW  12
01A52:  BNZ   1B32
....................       { 
....................          // set the valve position to open 
....................          global_valve_position = VLV_POSITION_OPENED;  
01A54:  MOVLW  80
01A56:  MOVLB  0
01A58:  MOVWF  xBA
01A5A:  CLRF   xB9
....................          // recalculate the valve opening time for each 1024th 
....................          //    (valve movements (1024th) * the time it takes for each 1024th 
....................          //    + the extra time) divided by 1024 
....................          global_valve_time_to_open_1024th =                                   \ 
....................          ((((uint32_t) global_valve_time_in_motion_1024ths * (uint32_t) global_valve_time_to_open_1024th) \ 
....................          + temp16_frac) >> 10); 
01A5C:  MOVLB  5
01A5E:  CLRF   x84
01A60:  CLRF   x83
01A62:  MOVFF  C2,582
01A66:  MOVFF  C1,581
01A6A:  MOVFF  BF,00
01A6E:  MOVFF  C0,01
01A72:  CLRF   02
01A74:  CLRF   03
01A76:  MOVFF  03,588
01A7A:  MOVFF  02,587
01A7E:  MOVFF  C0,586
01A82:  MOVFF  BF,585
01A86:  MOVFF  584,58C
01A8A:  MOVFF  583,58B
01A8E:  MOVFF  C2,58A
01A92:  MOVFF  C1,589
01A96:  MOVFF  03,590
01A9A:  MOVFF  02,58F
01A9E:  MOVFF  C0,58E
01AA2:  MOVFF  BF,58D
01AA6:  MOVLB  0
01AA8:  RCALL  1930
01AAA:  MOVFF  03,584
01AAE:  MOVFF  02,583
01AB2:  MOVFF  01,582
01AB6:  MOVFF  00,581
01ABA:  MOVLB  5
01ABC:  MOVF   x7F,W
01ABE:  ADDWF  x81,F
01AC0:  MOVF   x80,W
01AC2:  ADDWFC x82,F
01AC4:  MOVLW  00
01AC6:  ADDWFC x83,F
01AC8:  ADDWFC x84,F
01ACA:  RRCF   x84,W
01ACC:  MOVWF  02
01ACE:  RRCF   x83,W
01AD0:  MOVWF  01
01AD2:  RRCF   x82,W
01AD4:  MOVWF  00
01AD6:  RRCF   02,F
01AD8:  RRCF   01,F
01ADA:  RRCF   00,F
01ADC:  MOVFF  00,BF
01AE0:  MOVLB  0
01AE2:  MOVFF  01,C0
....................          // queue up the next stage of the calibration 
....................          push_time_queue_ISR(global_rtc_time + 3, CALIBRATE_VALVE_5); 
01AE6:  MOVLW  03
01AE8:  ADDWF  x85,W
01AEA:  MOVLB  5
01AEC:  MOVWF  x81
01AEE:  MOVLW  00
01AF0:  MOVLB  0
01AF2:  ADDWFC x86,W
01AF4:  MOVLB  5
01AF6:  MOVWF  x82
01AF8:  MOVLW  00
01AFA:  MOVLB  0
01AFC:  ADDWFC x87,W
01AFE:  MOVLB  5
01B00:  MOVWF  x83
01B02:  MOVLW  00
01B04:  MOVLB  0
01B06:  ADDWFC x88,W
01B08:  MOVLB  5
01B0A:  MOVWF  x84
01B0C:  CLRF   19
01B0E:  BTFSC  FF2.7
01B10:  BSF    19.7
01B12:  BCF    FF2.7
01B14:  MOVWF  xBA
01B16:  MOVFF  583,5B9
01B1A:  MOVFF  582,5B8
01B1E:  MOVFF  581,5B7
01B22:  MOVLW  35
01B24:  MOVWF  xBB
01B26:  MOVLB  0
01B28:  RCALL  16F6
01B2A:  BTFSC  19.7
01B2C:  BSF    FF2.7
....................       } 
01B2E:  BRA    1D74
01B30:  MOVLB  4
....................       // valve closing fully from fully open for calibration 
....................       else if (global_system_state == SYSTEM_CAL_VLV_5) 
01B32:  MOVF   xFD,W
01B34:  SUBLW  14
01B36:  BNZ   1C14
....................       { 
....................          global_valve_position = VLV_POSITION_CLOSED;  
01B38:  MOVLB  0
01B3A:  CLRF   xBA
01B3C:  CLRF   xB9
....................          // recalculate the valve closing time for each 1024th 
....................          //    (valve movements (1024th) * the time it takes for each 1024th 
....................          //    + the extra time) divided by 1024 
....................          global_valve_time_to_close_1024th =                                   \ 
....................          ((((uint32_t) global_valve_time_in_motion_1024ths * (uint32_t) global_valve_time_to_close_1024th) \ 
....................          + temp16_frac) >> 10); 
01B3E:  MOVLB  5
01B40:  CLRF   x84
01B42:  CLRF   x83
01B44:  MOVFF  C2,582
01B48:  MOVFF  C1,581
01B4C:  MOVFF  BD,00
01B50:  MOVFF  BE,01
01B54:  CLRF   02
01B56:  CLRF   03
01B58:  MOVFF  03,588
01B5C:  MOVFF  02,587
01B60:  MOVFF  BE,586
01B64:  MOVFF  BD,585
01B68:  MOVFF  584,58C
01B6C:  MOVFF  583,58B
01B70:  MOVFF  C2,58A
01B74:  MOVFF  C1,589
01B78:  MOVFF  03,590
01B7C:  MOVFF  02,58F
01B80:  MOVFF  BE,58E
01B84:  MOVFF  BD,58D
01B88:  MOVLB  0
01B8A:  RCALL  1930
01B8C:  MOVFF  03,584
01B90:  MOVFF  02,583
01B94:  MOVFF  01,582
01B98:  MOVFF  00,581
01B9C:  MOVLB  5
01B9E:  MOVF   x7F,W
01BA0:  ADDWF  x81,F
01BA2:  MOVF   x80,W
01BA4:  ADDWFC x82,F
01BA6:  MOVLW  00
01BA8:  ADDWFC x83,F
01BAA:  ADDWFC x84,F
01BAC:  RRCF   x84,W
01BAE:  MOVWF  02
01BB0:  RRCF   x83,W
01BB2:  MOVWF  01
01BB4:  RRCF   x82,W
01BB6:  MOVWF  00
01BB8:  RRCF   02,F
01BBA:  RRCF   01,F
01BBC:  RRCF   00,F
01BBE:  MOVFF  00,BD
01BC2:  MOVLB  0
01BC4:  MOVFF  01,BE
....................          // queue up the next stage of the calibration 
....................          push_time_queue_ISR(global_rtc_time + 3, CALIBRATE_VALVE_6); 
01BC8:  MOVLW  03
01BCA:  ADDWF  x85,W
01BCC:  MOVLB  5
01BCE:  MOVWF  x81
01BD0:  MOVLW  00
01BD2:  MOVLB  0
01BD4:  ADDWFC x86,W
01BD6:  MOVLB  5
01BD8:  MOVWF  x82
01BDA:  MOVLW  00
01BDC:  MOVLB  0
01BDE:  ADDWFC x87,W
01BE0:  MOVLB  5
01BE2:  MOVWF  x83
01BE4:  MOVLW  00
01BE6:  MOVLB  0
01BE8:  ADDWFC x88,W
01BEA:  MOVLB  5
01BEC:  MOVWF  x84
01BEE:  CLRF   19
01BF0:  BTFSC  FF2.7
01BF2:  BSF    19.7
01BF4:  BCF    FF2.7
01BF6:  MOVWF  xBA
01BF8:  MOVFF  583,5B9
01BFC:  MOVFF  582,5B8
01C00:  MOVFF  581,5B7
01C04:  MOVLW  36
01C06:  MOVWF  xBB
01C08:  MOVLB  0
01C0A:  RCALL  16F6
01C0C:  BTFSC  19.7
01C0E:  BSF    FF2.7
....................       } 
01C10:  BRA    1D74
01C12:  MOVLB  4
....................       // we are doing a valve endstop detect that we have a known calibration for. 
....................       // We want to check the positional error (if we are too far away from the 
....................       // endstop in position when the endstop is detected).  This applies to  
....................       // normal moves as well as re-calibration moves. 
....................       else 
....................       { 
....................          // valve has closed/opened fully in preparation of a recalibration of  
....................          //    valve position.  Trigger a move valve to move to the pending valve 
....................          //    set position and set system status to run 
....................          if (global_system_state == SYSTEM_RECAL_VLV_MOVES) 
01C14:  MOVF   xFD,W
01C16:  SUBLW  16
01C18:  BNZ   1C6A
....................          { 
....................             push_time_queue_ISR(global_rtc_time + 3, MOVE_VALVE); 
01C1A:  MOVLW  03
01C1C:  MOVLB  0
01C1E:  ADDWF  x85,W
01C20:  MOVLB  5
01C22:  MOVWF  x81
01C24:  MOVLW  00
01C26:  MOVLB  0
01C28:  ADDWFC x86,W
01C2A:  MOVLB  5
01C2C:  MOVWF  x82
01C2E:  MOVLW  00
01C30:  MOVLB  0
01C32:  ADDWFC x87,W
01C34:  MOVLB  5
01C36:  MOVWF  x83
01C38:  MOVLW  00
01C3A:  MOVLB  0
01C3C:  ADDWFC x88,W
01C3E:  MOVLB  5
01C40:  MOVWF  x84
01C42:  CLRF   19
01C44:  BTFSC  FF2.7
01C46:  BSF    19.7
01C48:  BCF    FF2.7
01C4A:  MOVWF  xBA
01C4C:  MOVFF  583,5B9
01C50:  MOVFF  582,5B8
01C54:  MOVFF  581,5B7
01C58:  MOVLW  40
01C5A:  MOVWF  xBB
01C5C:  MOVLB  0
01C5E:  RCALL  16F6
01C60:  BTFSC  19.7
01C62:  BSF    FF2.7
....................             global_system_state = SYSTEM_RUN; 
01C64:  MOVLW  02
01C66:  MOVLB  4
01C68:  MOVWF  xFD
....................          } 
....................          // valve is closing 
....................          if (IS_VLV_CLOSING) 
01C6A:  DECFSZ F8D,W
01C6C:  BRA    1CEC
....................          { 
....................             // error checking if valve movement was longer or shorter than expected 
....................             // We accomplish this by seeing if the valve hit an endstop while it was 
....................             //    outside the VLV_NEAR_CLOSED_RANGE_MAX/VLV_NEAR_OPENED_RANGE_MAX 
....................             if (global_valve_position > VLV_NEAR_CLOSED_RANGE_MAX) 
01C6E:  MOVF   xFF,W
01C70:  MOVLB  0
01C72:  SUBWF  xBA,W
01C74:  BNC   1CE4
01C76:  BNZ   1C88
01C78:  MOVF   xB9,W
01C7A:  MOVLB  4
01C7C:  SUBWF  xFE,W
01C7E:  BTFSS  FD8.0
01C80:  BRA    1C86
01C82:  MOVLB  0
01C84:  BRA    1CE4
01C86:  MOVLB  0
....................             { 
....................                // put system into run mode (in case it's in valve cal routine) 
....................                global_system_state = SYSTEM_RUN; 
01C88:  MOVLW  02
01C8A:  MOVLB  4
01C8C:  MOVWF  xFD
....................                // set valve to unknown position (uncalibrated) 
....................                global_valve_position = VLV_POSITION_UNKNOWN; 
01C8E:  MOVLB  0
01C90:  SETF   xBA
01C92:  SETF   xB9
....................                // set the error bitfield and send an error 
....................                global_error_message_bitfield |= ERR_MSG_VLV_MOVE_FAIL; 
01C94:  MOVLB  4
01C96:  BSF    xF1.2
....................                push_time_queue_ISR(global_rtc_time + 1, MSG_MOTE_ERROR_MSG); 
01C98:  MOVLW  01
01C9A:  MOVLB  0
01C9C:  ADDWF  x85,W
01C9E:  MOVLB  5
01CA0:  MOVWF  x81
01CA2:  MOVLW  00
01CA4:  MOVLB  0
01CA6:  ADDWFC x86,W
01CA8:  MOVLB  5
01CAA:  MOVWF  x82
01CAC:  MOVLW  00
01CAE:  MOVLB  0
01CB0:  ADDWFC x87,W
01CB2:  MOVLB  5
01CB4:  MOVWF  x83
01CB6:  MOVLW  00
01CB8:  MOVLB  0
01CBA:  ADDWFC x88,W
01CBC:  MOVLB  5
01CBE:  MOVWF  x84
01CC0:  CLRF   19
01CC2:  BTFSC  FF2.7
01CC4:  BSF    19.7
01CC6:  BCF    FF2.7
01CC8:  MOVWF  xBA
01CCA:  MOVFF  583,5B9
01CCE:  MOVFF  582,5B8
01CD2:  MOVFF  581,5B7
01CD6:  MOVLW  A0
01CD8:  MOVWF  xBB
01CDA:  MOVLB  0
01CDC:  RCALL  16F6
01CDE:  BTFSC  19.7
01CE0:  BSF    FF2.7
....................             } 
01CE2:  BRA    1CE8
....................             // was an expected endstop, proceed as usual 
....................             else 
....................             { 
....................                global_valve_position = VLV_POSITION_CLOSED;  
01CE4:  CLRF   xBA
01CE6:  CLRF   xB9
....................             } 
....................          } 
01CE8:  BRA    1D74
01CEA:  MOVLB  4
....................          // valve is opening 
....................          else if (IS_VLV_OPENING) 
01CEC:  MOVF   F8D,W
01CEE:  SUBLW  02
01CF0:  BNZ   1D76
....................          { 
....................             // error checking if valve movement was longer or shorter than expected 
....................             // We accomplish this by seeing if the valve hit an endstop while it was 
....................             //    outside the VLV_NEAR_CLOSED_RANGE_MAX/VLV_NEAR_OPENED_RANGE_MAX 
....................             if (global_valve_position < VLV_NEAR_OPENED_RANGE_MAX) 
01CF2:  MOVLB  0
01CF4:  MOVF   xBA,W
01CF6:  MOVLB  5
01CF8:  SUBWF  x01,W
01CFA:  BNC   1D6C
01CFC:  BNZ   1D0E
01CFE:  MOVF   x00,W
01D00:  MOVLB  0
01D02:  SUBWF  xB9,W
01D04:  BTFSS  FD8.0
01D06:  BRA    1D0C
01D08:  MOVLB  5
01D0A:  BRA    1D6C
01D0C:  MOVLB  5
....................             { 
....................                // put system into run mode (in case it's in valve cal routine) 
....................                global_system_state = SYSTEM_RUN; 
01D0E:  MOVLW  02
01D10:  MOVLB  4
01D12:  MOVWF  xFD
....................                // set valve to unknown position (uncalibrated) 
....................                global_valve_position = VLV_POSITION_UNKNOWN; 
01D14:  MOVLB  0
01D16:  SETF   xBA
01D18:  SETF   xB9
....................                // set the error bitfield and send an error 
....................                global_error_message_bitfield |= ERR_MSG_VLV_MOVE_FAIL; 
01D1A:  MOVLB  4
01D1C:  BSF    xF1.2
....................                push_time_queue_ISR(global_rtc_time + 1, MSG_MOTE_ERROR_MSG); 
01D1E:  MOVLW  01
01D20:  MOVLB  0
01D22:  ADDWF  x85,W
01D24:  MOVLB  5
01D26:  MOVWF  x81
01D28:  MOVLW  00
01D2A:  MOVLB  0
01D2C:  ADDWFC x86,W
01D2E:  MOVLB  5
01D30:  MOVWF  x82
01D32:  MOVLW  00
01D34:  MOVLB  0
01D36:  ADDWFC x87,W
01D38:  MOVLB  5
01D3A:  MOVWF  x83
01D3C:  MOVLW  00
01D3E:  MOVLB  0
01D40:  ADDWFC x88,W
01D42:  MOVLB  5
01D44:  MOVWF  x84
01D46:  CLRF   19
01D48:  BTFSC  FF2.7
01D4A:  BSF    19.7
01D4C:  BCF    FF2.7
01D4E:  MOVWF  xBA
01D50:  MOVFF  583,5B9
01D54:  MOVFF  582,5B8
01D58:  MOVFF  581,5B7
01D5C:  MOVLW  A0
01D5E:  MOVWF  xBB
01D60:  MOVLB  0
01D62:  RCALL  16F6
01D64:  BTFSC  19.7
01D66:  BSF    FF2.7
....................             } 
01D68:  BRA    1D74
01D6A:  MOVLB  5
....................             // was an expected endstop, proceed as usual 
....................             else 
....................             { 
....................                global_valve_position = VLV_POSITION_OPENED;  
01D6C:  MOVLW  80
01D6E:  MOVLB  0
01D70:  MOVWF  xBA
01D72:  CLRF   xB9
01D74:  MOVLB  4
....................             } 
....................          } 
....................       } 
....................        
....................       // Update fixture setting 
....................  
....................                   
....................       // Turn off comparator and dac 
....................       setup_DAC(DAC_OFF); 
01D76:  MOVLB  F
01D78:  CLRF   x41
....................       setup_comparator(NC_NC_NC_NC); 
01D7A:  CLRF   F77
01D7C:  MOVLW  04
01D7E:  MOVWF  F78
01D80:  MOVWF  F79
....................        
....................       // Turn off CCP3 interrupt      
....................       disable_interrupts(INT_CCP3); 
01D82:  BCF    F7A.0
....................        
....................       // reset valve movements counter 
....................       global_valve_movements_since_endstop = 0; 
01D84:  MOVLB  0
01D86:  CLRF   xC7
....................        
....................       // turn off the motor 
....................       mV_COASTm; 
01D88:  CLRF   F8D
....................  
....................       // put clock speed down to 250khz again 
....................       //fosc_250k_ISR();    
....................        
....................       // turn off comparator interrupt so it isn't triggered on stop 
....................       clear_interrupt(INT_COMP);      
01D8A:  BCF    FA1.6
....................    } 
.................... } 
....................  
....................  
.................... /* 
.................... #INT_TIMER0 
.................... void tmr0_ISR(void) 
.................... { 
.................... // may not be enabled during normal operation. 
.................... // Need only for IDLING situation (long winters...) wherein every 35minutes 
.................... //  we wake up and check the battery and set a flag if there is a very low 
.................... //  battery, which then tells the idle_sleep routine to go into deep_sleep. 
.................... // this needs work. 
.................... // 
.................... // We can know if we were idling by simply checking the OSCCON for 31250Hz 
.................... //  operation, which occurs ONLY during the long winter.... 
.................... // 
....................    if (cur_state == DEV_IDLE) 
....................    { 
....................    uint8_t  nn; 
....................    // this interrupt occurred during the sleep_idle state 
....................    // check the battery, if it is so low that we need to turn off the radio, 
....................    //  then be sure to set a flag to make that happen... 
....................    // Deep_Sleep may be the result 
....................       output_high(AUX_PWR); 
....................       ADON = TRUE;         // turn on ADC 
....................       delay_cycles(50);    // insurance 
....................       set_adc_channel(V_MEAS_REF);   
....................       VfvrAD = 0;   
....................       for (nn=0; nn<4; nn++) 
....................          VfvrAD += read_adc(); 
....................       ADON = FALSE; 
....................       output_low(AUX_PWR); 
....................       if (VfvrAD > FVR_NODUST) 
....................          fl_batNODUST = TRUE; 
....................    } 
....................    else 
....................    { 
....................    // any other TIMER0 activities we may want 
....................    } 
.................... } 
.................... */ 
....................  
....................                                                           
01D8C:  BCF    FA1.6
01D8E:  GOTO   00A0
.................... #INT_CCP3 HIGH 
.................... void ccp3_ISR(void) 
.................... { 
.................... // For use in timing valve motion 
.................... //    -Updates realtime position of valve 
.................... //    -Keeps track of valve movement time (in 1024th of full scale) 
.................... //    -Turns off valve movement when position is reached 
.................... //    -updates DAC level according to position and direction of movement 
.................... // May be used for other functionality if valve is not moving 
.................... // TMR1 dedicated to CCP3 
....................     
....................    //set_timer1(TIMER1_VLV_MOVE_INIT + get_timer1()); 
....................    //temp16_frac = get_timer1();             
....................           
....................    // If the valve is in motion (not in the braked or coast mode)  
....................    if (IS_VLV_CLOSING || IS_VLV_OPENING) 
*
01ED2:  DECFSZ F8D,W
01ED4:  BRA    1ED8
01ED6:  BRA    1EE0
01ED8:  MOVF   F8D,W
01EDA:  SUBLW  02
01EDC:  BTFSS  FD8.2
01EDE:  BRA    2034
....................    { 
....................       // add to the time in motion variable 
....................       global_valve_time_in_motion_1024ths++; 
01EE0:  INCF   xC1,F
01EE2:  BTFSC  FD8.2
01EE4:  INCF   xC2,F
....................        
....................       //check for valve movement timeout 
....................       if (global_valve_time_in_motion_1024ths > VALVE_TIMEOUT) 
01EE6:  MOVF   xC2,W
01EE8:  SUBLW  04
01EEA:  BC    1F4C
01EEC:  XORLW  FF
01EEE:  BNZ   1EF6
01EF0:  MOVF   xC1,W
01EF2:  SUBLW  DC
01EF4:  BC    1F4C
....................       { 
....................          // turn off comparator interrupt so it isn't triggered on stop 
....................          disable_interrupts(INT_COMP); 
01EF6:  BCF    FA0.6
....................                 
....................          // turn off valve movement 
....................          mV_COASTm; 
01EF8:  CLRF   F8D
....................           
....................          // Error handling for valve motion timeout 
....................          // put system into run mode (in case it's in valve cal routine) 
....................          global_system_state = SYSTEM_RUN; 
01EFA:  MOVLW  02
01EFC:  MOVLB  4
01EFE:  MOVWF  xFD
....................          // set valve to unknown position (uncalibrated) 
....................          global_valve_position = VLV_POSITION_UNKNOWN; 
01F00:  MOVLB  0
01F02:  SETF   xBA
01F04:  SETF   xB9
....................          // set the error bitfield and send an error 
....................          global_error_message_bitfield |= ERR_MSG_VLV_MOVE_FAIL; 
01F06:  MOVLB  4
01F08:  BSF    xF1.2
....................          push_time_queue_ISR(global_rtc_time + 1, MSG_MOTE_ERROR_MSG); 
01F0A:  MOVLW  01
01F0C:  MOVLB  0
01F0E:  ADDWF  x85,W
01F10:  MOVLB  5
01F12:  MOVWF  xB3
01F14:  MOVLW  00
01F16:  MOVLB  0
01F18:  ADDWFC x86,W
01F1A:  MOVLB  5
01F1C:  MOVWF  xB4
01F1E:  MOVLW  00
01F20:  MOVLB  0
01F22:  ADDWFC x87,W
01F24:  MOVLB  5
01F26:  MOVWF  xB5
01F28:  MOVLW  00
01F2A:  MOVLB  0
01F2C:  ADDWFC x88,W
01F2E:  MOVLB  5
01F30:  MOVWF  xB6
01F32:  MOVWF  xBA
01F34:  MOVFF  5B5,5B9
01F38:  MOVFF  5B4,5B8
01F3C:  MOVFF  5B3,5B7
01F40:  MOVLW  A0
01F42:  MOVWF  xBB
01F44:  MOVLB  0
01F46:  CALL   16F6
....................       } 
01F4A:  BRA    2028
....................        
....................       else if (IS_VLV_CLOSING) 
01F4C:  DECFSZ F8D,W
01F4E:  BRA    1F94
....................       {   
....................          //set_timer1(TIMER1_VLV_MOVE_INIT); 
....................          // 0x20 is equal to one 'millispan' 
....................          if (global_valve_position >= 0x20) 
01F50:  MOVF   xBA,F
01F52:  BNZ   1F5A
01F54:  MOVF   xB9,W
01F56:  SUBLW  1F
01F58:  BC    1F64
....................          { 
....................             global_valve_position -= 0x20;     
01F5A:  MOVLW  20
01F5C:  SUBWF  xB9,F
01F5E:  MOVLW  00
01F60:  SUBWFB xBA,F
....................          } 
01F62:  BRA    1F68
....................          // valve is closed, unsigned int thing 
....................          else  
....................          { 
....................             global_valve_position = VLV_POSITION_CLOSED; 
01F64:  CLRF   xBA
01F66:  CLRF   xB9
....................          } 
....................           
....................          // if system is doing a valve recalibration, ignore valve set position 
....................          //    as it is storing the next valve position to move to 
....................          if (global_system_state == SYSTEM_RECAL_VLV_MOVES) 
01F68:  MOVLB  4
01F6A:  MOVF   xFD,W
01F6C:  SUBLW  16
01F6E:  BNZ   1F72
....................          { 
....................             break; 
....................          }                        
01F70:  BRA    1F90
....................          // we have reached or exceeded the set value/target position and 
....................          //    we aren't trying to reach the endstop 
....................          else if ((global_valve_position <= global_valve_position_set_value)&&\ 
....................          (global_valve_position_set_value != VLV_POSITION_CLOSED)) 
01F72:  MOVLB  0
01F74:  MOVF   xBA,W
01F76:  SUBWF  xBC,W
01F78:  BNC   1F8E
01F7A:  BNZ   1F82
01F7C:  MOVF   xB9,W
01F7E:  SUBWF  xBB,W
01F80:  BNC   1F8E
01F82:  MOVF   xBB,F
01F84:  BNZ   1F8A
01F86:  MOVF   xBC,F
01F88:  BZ    1F8E
....................          { 
....................             // turn off comparator interrupt so it isn't triggered on stop 
....................             disable_interrupts(INT_COMP); 
01F8A:  BCF    FA0.6
....................              
....................             // turn off valve movement 
....................             mV_COASTm; 
01F8C:  CLRF   F8D
01F8E:  MOVLB  4
....................          } 
....................       } 
01F90:  BRA    202A
01F92:  MOVLB  0
....................       else if (IS_VLV_OPENING) 
01F94:  MOVF   F8D,W
01F96:  SUBLW  02
01F98:  BNZ   2028
....................       {                   
....................          //0x20 is equal to one 'millispan' 
....................          global_valve_position += 0x20;       
01F9A:  MOVLW  20
01F9C:  ADDWF  xB9,F
01F9E:  MOVLW  00
01FA0:  ADDWFC xBA,F
....................        
....................          if (global_valve_position > VLV_POSITION_OPENED) 
01FA2:  MOVF   xBA,W
01FA4:  SUBLW  7F
01FA6:  BC    1FB8
01FA8:  XORLW  FF
01FAA:  BNZ   1FB2
01FAC:  MOVF   xB9,W
01FAE:  SUBLW  00
01FB0:  BC    1FB8
....................          { 
....................             global_valve_position = VLV_POSITION_OPENED;    
01FB2:  MOVLW  80
01FB4:  MOVWF  xBA
01FB6:  CLRF   xB9
....................          } 
....................           
....................          // if system is doing a valve recalibration, ignore valve set position 
....................          //    as it is storing the next valve position to move to 
....................          if (global_system_state == SYSTEM_RECAL_VLV_MOVES) 
01FB8:  MOVLB  4
01FBA:  MOVF   xFD,W
01FBC:  SUBLW  16
01FBE:  BNZ   1FC2
....................          { 
....................             break; 
....................          } 
01FC0:  BRA    202A
....................          // we have reached or exceeded the set value/target position and 
....................          //    we aren't trying to reach the endstop 
....................          else if ((global_valve_position >= global_valve_position_set_value)&&\ 
....................          (global_valve_position_set_value != VLV_POSITION_OPENED)) 
01FC2:  MOVLB  0
01FC4:  MOVF   xBC,W
01FC6:  SUBWF  xBA,W
01FC8:  BNC   2028
01FCA:  BNZ   1FD2
01FCC:  MOVF   xBB,W
01FCE:  SUBWF  xB9,W
01FD0:  BNC   2028
01FD2:  MOVF   xBB,F
01FD4:  BNZ   1FDC
01FD6:  MOVF   xBC,W
01FD8:  SUBLW  80
01FDA:  BZ    2028
....................          { 
....................             // turn off comparator interrupt so it isn't triggered on stop 
....................             disable_interrupts(INT_COMP); 
01FDC:  BCF    FA0.6
....................              
....................             // turn off valve movement 
....................             mV_COASTm; 
01FDE:  CLRF   F8D
....................              
....................             // Special case: if we are opening during CALIBRATE_VALVE_1 and 
....................             //    have reached our position, start the next calibration  
....................             //    sequence  
....................             if (global_system_state == SYSTEM_CAL_VLV_1) 
01FE0:  MOVLB  4
01FE2:  MOVF   xFD,W
01FE4:  SUBLW  10
01FE6:  BNZ   202A
....................             { 
....................                push_time_queue_ISR(global_rtc_time + 3, CALIBRATE_VALVE_2); 
01FE8:  MOVLW  03
01FEA:  MOVLB  0
01FEC:  ADDWF  x85,W
01FEE:  MOVLB  5
01FF0:  MOVWF  xB3
01FF2:  MOVLW  00
01FF4:  MOVLB  0
01FF6:  ADDWFC x86,W
01FF8:  MOVLB  5
01FFA:  MOVWF  xB4
01FFC:  MOVLW  00
01FFE:  MOVLB  0
02000:  ADDWFC x87,W
02002:  MOVLB  5
02004:  MOVWF  xB5
02006:  MOVLW  00
02008:  MOVLB  0
0200A:  ADDWFC x88,W
0200C:  MOVLB  5
0200E:  MOVWF  xB6
02010:  MOVWF  xBA
02012:  MOVFF  5B5,5B9
02016:  MOVFF  5B4,5B8
0201A:  MOVFF  5B3,5B7
0201E:  MOVLW  32
02020:  MOVWF  xBB
02022:  MOVLB  0
02024:  CALL   16F6
02028:  MOVLB  4
....................             } 
....................          } 
....................       }    
....................       // update the dac setting 
....................       set_comp_dac_level_isr(); 
0202A:  MOVLB  0
0202C:  BRA    1D92
....................        
....................       // update the fixture setting 
....................        
....................       // if the valve is not moving anymore 
....................       if (IS_VLV_COASTING) 
0202E:  MOVF   F8D,F
02030:  BNZ   2034
....................       { 
....................          // switch back to lower clock, turn off CCP3 interrupt 
....................             //fosc_250k_ISR(); 
....................             //#use delay(clock=250KHZ) 
....................          disable_interrupts(INT_CCP3); 
02032:  BCF    F7A.0
....................                                                                                                         
....................       } 
....................    } 
.................... } 
....................  
....................  
02034:  BCF    F7B.0
02036:  GOTO   015E
.................... #INT_CCP4 
.................... void ccp4_isr(void)              
.................... { 
....................    // real time clock interrupts      
....................    // TMR3 dedicated to CCP4      
....................                                                                                       
....................    // increment global system uptime 
....................    global_rtc_time++; 
*
02C74:  MOVLW  01
02C76:  ADDWF  x85,F
02C78:  BTFSC  FD8.0
02C7A:  INCF   x86,F
02C7C:  BTFSC  FD8.2
02C7E:  INCF   x87,F
02C80:  BTFSC  FD8.2
02C82:  INCF   x88,F
....................    // increment utc time if mote is connected 
....................    if (global_dust_enabled) global_utc_time++; 
02C84:  BTFSS  x9F.6
02C86:  BRA    2C98
02C88:  MOVLW  01
02C8A:  ADDWF  x89,F
02C8C:  BTFSC  FD8.0
02C8E:  INCF   x8A,F
02C90:  BTFSC  FD8.2
02C92:  INCF   x8B,F
02C94:  BTFSC  FD8.2
02C96:  INCF   x8C,F
....................  
....................    // check if a time queue item needs to be run 
....................    // make sure it isn't polling an empty queue 
....................    while((global_current_time_queue_location != 255) &&                       \ 
....................    (global_current_priority_queue_location != (MAX_PRIORITY_QUEUE_ITEMS - 1)) \ 
....................    && (global_time_queue[global_current_time_queue_location].time_to_execute  \ 
....................    <= global_rtc_time)) 
02C98:  MOVLB  3
02C9A:  INCFSZ x94,W
02C9C:  BRA    2CA0
02C9E:  BRA    2D1A
02CA0:  MOVF   x7A,W
02CA2:  SUBLW  13
02CA4:  BZ    2D1A
02CA6:  MOVF   x94,W
02CA8:  MULLW  05
02CAA:  MOVF   FF3,W
02CAC:  MOVLB  5
02CAE:  CLRF   x80
02CB0:  MOVWF  x7F
02CB2:  MOVLW  7B
02CB4:  ADDWF  x7F,W
02CB6:  MOVWF  FE9
02CB8:  MOVLW  03
02CBA:  ADDWFC x80,W
02CBC:  MOVWF  FEA
02CBE:  MOVFF  FEF,581
02CC2:  MOVFF  FEC,582
02CC6:  MOVFF  FEC,583
02CCA:  MOVFF  FEC,584
02CCE:  MOVF   x84,W
02CD0:  MOVLB  0
02CD2:  SUBWF  x88,W
02CD4:  BTFSC  FD8.0
02CD6:  BRA    2CDC
02CD8:  MOVLB  3
02CDA:  BRA    2D1A
02CDC:  BNZ   2D12
02CDE:  MOVLB  5
02CE0:  MOVF   x83,W
02CE2:  MOVLB  0
02CE4:  SUBWF  x87,W
02CE6:  BTFSC  FD8.0
02CE8:  BRA    2CEE
02CEA:  MOVLB  3
02CEC:  BRA    2D1A
02CEE:  BNZ   2D12
02CF0:  MOVLB  5
02CF2:  MOVF   x82,W
02CF4:  MOVLB  0
02CF6:  SUBWF  x86,W
02CF8:  BTFSC  FD8.0
02CFA:  BRA    2D00
02CFC:  MOVLB  3
02CFE:  BRA    2D1A
02D00:  BNZ   2D12
02D02:  MOVLB  5
02D04:  MOVF   x81,W
02D06:  MOVLB  0
02D08:  SUBWF  x85,W
02D0A:  BTFSC  FD8.0
02D0C:  BRA    2D12
02D0E:  MOVLB  3
02D10:  BRA    2D1A
....................    {                               
....................       // pop an item off the time queue and push it into the priority queue 
....................       pop_time_queue_ISR();                      
02D12:  GOTO   203A
02D16:  BRA    2C98
02D18:  MOVLB  3
....................    }                         
....................     
....................    // check if a message queue item needs to be run 
....................    // make sure it isn't polling an empty queue 
....................    while((global_current_message_queue_location != 255) &&                      \ 
....................       (global_message_queue[global_current_message_queue_location].time_to_send \ 
....................       <= global_rtc_time))    
02D1A:  MOVLB  4
02D1C:  INCFSZ xEF,W
02D1E:  BRA    2D22
02D20:  BRA    2D9C
02D22:  MOVF   xEF,W
02D24:  MULLW  08
02D26:  MOVF   FF3,W
02D28:  MOVLB  5
02D2A:  CLRF   x80
02D2C:  MOVWF  x7F
02D2E:  MOVLW  9F
02D30:  ADDWF  x7F,W
02D32:  MOVWF  FE9
02D34:  MOVLW  04
02D36:  ADDWFC x80,W
02D38:  MOVWF  FEA
02D3A:  MOVFF  FEF,581
02D3E:  MOVFF  FEC,582
02D42:  MOVFF  FEC,583
02D46:  MOVFF  FEC,584
02D4A:  MOVF   x84,W
02D4C:  MOVLB  0
02D4E:  SUBWF  x88,W
02D50:  BTFSC  FD8.0
02D52:  BRA    2D58
02D54:  MOVLB  4
02D56:  BRA    2D9C
02D58:  BNZ   2D8E
02D5A:  MOVLB  5
02D5C:  MOVF   x83,W
02D5E:  MOVLB  0
02D60:  SUBWF  x87,W
02D62:  BTFSC  FD8.0
02D64:  BRA    2D6A
02D66:  MOVLB  4
02D68:  BRA    2D9C
02D6A:  BNZ   2D8E
02D6C:  MOVLB  5
02D6E:  MOVF   x82,W
02D70:  MOVLB  0
02D72:  SUBWF  x86,W
02D74:  BTFSC  FD8.0
02D76:  BRA    2D7C
02D78:  MOVLB  4
02D7A:  BRA    2D9C
02D7C:  BNZ   2D8E
02D7E:  MOVLB  5
02D80:  MOVF   x81,W
02D82:  MOVLB  0
02D84:  SUBWF  x85,W
02D86:  BTFSC  FD8.0
02D88:  BRA    2D8E
02D8A:  MOVLB  4
02D8C:  BRA    2D9C
....................    {                     
....................       // disable mote interrupt so payload_buf doesn't get overwritten 
....................       disable_interrupts(INT_EXT2_H2L);   
02D8E:  BCF    FF0.4
....................       // send message and requeue it at a later date if not ack'd 
....................       pop_message_queue_and_send_ISR(); 
02D90:  BRA    26C8
....................       // re-enable mote interrupt                     
....................       enable_interrupts(INT_EXT2_H2L);     
02D92:  BSF    FF0.4
02D94:  BCF    FF1.4
02D96:  MOVLB  3
02D98:  BRA    2D1A
02D9A:  MOVLB  4
....................    }                                   
....................     
....................     
....................    // check if a sprinkler queue item needs to be run and make sure it isn't polling an empty queue        
....................    // Note: The queue contains things that are to be run, not the current item running.             
....................    while((global_current_sprinkler_queue_location != 255) &&                      \ 
....................       (global_sprinkler_queue[global_current_sprinkler_queue_location].start_time \ 
....................       <= global_utc_time)) 
02D9C:  INCFSZ x21,W
02D9E:  BRA    2DA2
02DA0:  BRA    2E70
02DA2:  MOVF   x21,W
02DA4:  MULLW  0E
02DA6:  MOVF   FF3,W
02DA8:  MOVLB  5
02DAA:  CLRF   x80
02DAC:  MOVWF  x7F
02DAE:  MOVLW  95
02DB0:  ADDWF  x7F,W
02DB2:  MOVWF  FE9
02DB4:  MOVLW  03
02DB6:  ADDWFC x80,W
02DB8:  MOVWF  FEA
02DBA:  MOVFF  FEF,581
02DBE:  MOVFF  FEC,582
02DC2:  MOVFF  FEC,583
02DC6:  MOVFF  FEC,584
02DCA:  MOVF   x84,W
02DCC:  MOVLB  0
02DCE:  SUBWF  x8C,W
02DD0:  BTFSC  FD8.0
02DD2:  BRA    2DD8
02DD4:  MOVLB  4
02DD6:  BRA    2E70
02DD8:  BNZ   2E0E
02DDA:  MOVLB  5
02DDC:  MOVF   x83,W
02DDE:  MOVLB  0
02DE0:  SUBWF  x8B,W
02DE2:  BTFSC  FD8.0
02DE4:  BRA    2DEA
02DE6:  MOVLB  4
02DE8:  BRA    2E70
02DEA:  BNZ   2E0E
02DEC:  MOVLB  5
02DEE:  MOVF   x82,W
02DF0:  MOVLB  0
02DF2:  SUBWF  x8A,W
02DF4:  BTFSC  FD8.0
02DF6:  BRA    2DFC
02DF8:  MOVLB  4
02DFA:  BRA    2E70
02DFC:  BNZ   2E0E
02DFE:  MOVLB  5
02E00:  MOVF   x81,W
02E02:  MOVLB  0
02E04:  SUBWF  x89,W
02E06:  BTFSC  FD8.0
02E08:  BRA    2E0E
02E0A:  MOVLB  4
02E0C:  BRA    2E70
....................    { 
....................             // if system is not in run state, do not stop the item.  Send an error  
....................       //    stating that the stop time is delayed 
....................       if (global_system_state != SYSTEM_RUN)                        
02E0E:  MOVLB  4
02E10:  MOVF   xFD,W
02E12:  SUBLW  02
02E14:  BZ    2E68
....................       {                       
....................          global_error_message_bitfield |= ERR_MSG_SPINKLER_CMD_DELAYED_INVALID_STATE; 
02E16:  BSF    xF1.6
....................          push_time_queue_ISR(global_rtc_time + 1, MSG_MOTE_ERROR_MSG); 
02E18:  MOVLW  01
02E1A:  MOVLB  0
02E1C:  ADDWF  x85,W
02E1E:  MOVLB  5
02E20:  MOVWF  x7F
02E22:  MOVLW  00
02E24:  MOVLB  0
02E26:  ADDWFC x86,W
02E28:  MOVLB  5
02E2A:  MOVWF  x80
02E2C:  MOVLW  00
02E2E:  MOVLB  0
02E30:  ADDWFC x87,W
02E32:  MOVLB  5
02E34:  MOVWF  x81
02E36:  MOVLW  00
02E38:  MOVLB  0
02E3A:  ADDWFC x88,W
02E3C:  MOVLB  5
02E3E:  MOVWF  x82
02E40:  CLRF   19
02E42:  BTFSC  FF2.7
02E44:  BSF    19.7
02E46:  BCF    FF2.7
02E48:  MOVWF  xBA
02E4A:  MOVFF  581,5B9
02E4E:  MOVFF  580,5B8
02E52:  MOVFF  57F,5B7
02E56:  MOVLW  A0
02E58:  MOVWF  xBB
02E5A:  MOVLB  0
02E5C:  CALL   16F6
02E60:  BTFSC  19.7
02E62:  BSF    FF2.7
....................       } 
02E64:  BRA    2E6C
02E66:  MOVLB  4
....................       else 
....................       { 
....................          // pop an item off the time queue and push it into the priority queue 
....................          pop_sprinkler_queue_ISR(); 
02E68:  MOVLB  0
02E6A:  BRA    2A3A
....................       } 
02E6C:  MOVLB  4
02E6E:  BRA    2D9C
....................    }            
....................                                
....................    // check if a sprinkler queue item needs to be stopped 
....................    if (global_current_sprinkler_settings_end_time <= global_utc_time) 
02E70:  MOVF   x25,W
02E72:  MOVLB  0
02E74:  SUBWF  x8C,W
02E76:  BNC   2EFA
02E78:  BNZ   2E9C
02E7A:  MOVLB  4
02E7C:  MOVF   x24,W
02E7E:  MOVLB  0
02E80:  SUBWF  x8B,W
02E82:  BNC   2EFA
02E84:  BNZ   2E9C
02E86:  MOVLB  4
02E88:  MOVF   x23,W
02E8A:  MOVLB  0
02E8C:  SUBWF  x8A,W
02E8E:  BNC   2EFA
02E90:  BNZ   2E9C
02E92:  MOVLB  4
02E94:  MOVF   x22,W
02E96:  MOVLB  0
02E98:  SUBWF  x89,W
02E9A:  BNC   2EFA
....................    { 
....................       // if system is not in run state, do not stop the item.  Send an error 
....................       //    stating that the stop time is delayed 
....................       if (global_system_state != SYSTEM_RUN) 
02E9C:  MOVLB  4
02E9E:  MOVF   xFD,W
02EA0:  SUBLW  02
02EA2:  BZ    2EF6
....................       { 
....................          global_error_message_bitfield |= ERR_MSG_SPINKLER_CMD_DELAYED_INVALID_STATE; 
02EA4:  BSF    xF1.6
....................          push_time_queue_ISR(global_rtc_time + 1, MSG_MOTE_ERROR_MSG); 
02EA6:  MOVLW  01
02EA8:  MOVLB  0
02EAA:  ADDWF  x85,W
02EAC:  MOVLB  5
02EAE:  MOVWF  x7F
02EB0:  MOVLW  00
02EB2:  MOVLB  0
02EB4:  ADDWFC x86,W
02EB6:  MOVLB  5
02EB8:  MOVWF  x80
02EBA:  MOVLW  00
02EBC:  MOVLB  0
02EBE:  ADDWFC x87,W
02EC0:  MOVLB  5
02EC2:  MOVWF  x81
02EC4:  MOVLW  00
02EC6:  MOVLB  0
02EC8:  ADDWFC x88,W
02ECA:  MOVLB  5
02ECC:  MOVWF  x82
02ECE:  CLRF   19
02ED0:  BTFSC  FF2.7
02ED2:  BSF    19.7
02ED4:  BCF    FF2.7
02ED6:  MOVWF  xBA
02ED8:  MOVFF  581,5B9
02EDC:  MOVFF  580,5B8
02EE0:  MOVFF  57F,5B7
02EE4:  MOVLW  A0
02EE6:  MOVWF  xBB
02EE8:  MOVLB  0
02EEA:  CALL   16F6
02EEE:  BTFSC  19.7
02EF0:  BSF    FF2.7
....................       }       
02EF2:  BRA    2EFA
02EF4:  MOVLB  4
....................        
....................       /* 
....................       // if you're stopping the current item and there are no more in the queue, turn off the control 
....................       //    loop.                             
....................       else if (global_current_sprinkler_queue_location == 255) 
....................       {   
....................          global_control_loop_mechanism = NO_SPRINKLER_CONTROL; 
....................       }        
....................       */ 
....................        
....................       else                                        
....................       { 
....................          // stop the current sprinkler setting 
....................          stop_current_spinkler_setting_ISR(); 
02EF6:  MOVLB  0
02EF8:  BRA    2C44
....................       }                                                   
....................    }                                  
....................     
....................    // update lcd every second                                 
....................    PUSH_PRIORITY_QUEUE_ISR_MACRO(LCD_UPDATE);    
02EFA:  MOVLW  D4
02EFC:  MOVLB  5
02EFE:  MOVWF  x9B
02F00:  MOVLB  0
02F02:  CALL   07D0
....................  
....................    // periodic system checkups (all in one to minimize divides) 
....................    // - mote state (reacts as necessary) 
....................    // - battery state (turns off/on charging, sends warnings, etc.) 
....................    // - mote temp (logs data, sends warnings, etc.) 
....................    // - mote utc time (updates utc time if valid) 
....................    if ((global_rtc_time % PERIODIC_CHECKS_TIME) == 0)     
02F06:  MOVF   x85,W
02F08:  ANDLW  1F
02F0A:  MOVLB  5
02F0C:  MOVWF  x7F
02F0E:  CLRF   x80
02F10:  CLRF   x81
02F12:  CLRF   x82
02F14:  MOVF   x7F,F
02F16:  BNZ   2F54
02F18:  MOVF   x80,F
02F1A:  BNZ   2F54
02F1C:  MOVF   x81,F
02F1E:  BNZ   2F54
02F20:  MOVF   x82,F
02F22:  BNZ   2F54
....................    {                                                  
....................       PUSH_PRIORITY_QUEUE_ISR_MACRO(CHECK_MOTE_STATE);  
02F24:  MOVLW  B4
02F26:  MOVWF  x9B
02F28:  MOVLB  0
02F2A:  CALL   07D0
....................       PUSH_PRIORITY_QUEUE_ISR_MACRO(CHECK_BATTERY_STATE);    
02F2E:  MOVLW  A1
02F30:  MOVLB  5
02F32:  MOVWF  x9B
02F34:  MOVLB  0
02F36:  CALL   07D0
....................       PUSH_PRIORITY_QUEUE_ISR_MACRO(CHECK_MOTE_TEMP); 
02F3A:  MOVLW  A2
02F3C:  MOVLB  5
02F3E:  MOVWF  x9B
02F40:  MOVLB  0
02F42:  CALL   07D0
....................       PUSH_PRIORITY_QUEUE_ISR_MACRO(UPDATE_MOTE_TIME); 
02F46:  MOVLW  A3
02F48:  MOVLB  5
02F4A:  MOVWF  x9B
02F4C:  MOVLB  0
02F4E:  CALL   07D0
02F52:  MOVLB  5
....................    }                                                                                                                           
.................... } 
....................  
02F54:  BCF    F7B.1
02F56:  MOVLB  0
02F58:  GOTO   00A0
.................... #INT_CCP5 FAST 
.................... void CCP5_ISR(void) 
.................... { 
.................... // GEN_RPM event capture for determining speed of rotation 
.................... // We need the CCP5 interrupt routine to be very fast because  
.................... //  the sprinkler can be spinning fast enough to generate 500 pulses per sec! 
.................... // With a 250KHz system clock, 2ms may be trouble with the full normal interrupt 
.................... //  overhead.... 
.................... // TMR5 dedicated to CCP5 
....................     
....................    static uint16_t ccp5_value = 0, ccp5_value_prev = 0; 
....................     
....................    // save previous sample  
....................    ccp5_value_prev = ccp5_value; 
02F5C:  MOVFF  541,543
02F60:  MOVFF  540,542
....................     
....................    // get current sample      
....................    ccp5_value = CCP_5; 
02F64:  MOVFF  F56,541
02F68:  MOVFF  F55,540
....................                                    
....................    // disable INT_CCP4 to ensure safe grabbing of global_rtc_time                        
....................    disable_interrupts(INT_CCP4);     
02F6C:  BCF    F7A.1
....................    // check if a current period measurement is even valid 
....................    if ((global_rtc_time - global_last_rpm_value_time) > RPM_TIMEOUT)   
02F6E:  MOVF   xA6,W
02F70:  SUBWF  x85,W
02F72:  MOVLB  5
02F74:  MOVWF  xB3
02F76:  MOVLB  0
02F78:  MOVF   xA7,W
02F7A:  SUBWFB x86,W
02F7C:  MOVLB  5
02F7E:  MOVWF  xB4
02F80:  MOVLB  0
02F82:  MOVF   xA8,W
02F84:  SUBWFB x87,W
02F86:  MOVLB  5
02F88:  MOVWF  xB5
02F8A:  MOVLB  0
02F8C:  MOVF   xA9,W
02F8E:  SUBWFB x88,W
02F90:  MOVLB  5
02F92:  MOVWF  xB6
02F94:  MOVF   xB6,F
02F96:  BNZ   2FAA
02F98:  MOVF   xB5,F
02F9A:  BNZ   2FAA
02F9C:  MOVF   x1A,W
02F9E:  SUBWF  xB4,W
02FA0:  BNC   2FAC
02FA2:  BNZ   2FAA
02FA4:  MOVF   xB3,W
02FA6:  SUBWF  x19,W
02FA8:  BC    2FAC
....................    {                                                      
....................       break; 
....................    }              
02FAA:  BRA    2FC0
....................    else            
....................    {                           
....................       // calc current difference/global period     
....................       global_current_period = ccp5_value - ccp5_value_prev;    
02FAC:  MOVF   x42,W
02FAE:  SUBWF  x40,W
02FB0:  MOVLB  0
02FB2:  MOVWF  xA0
02FB4:  MOVLB  5
02FB6:  MOVF   x43,W
02FB8:  SUBWFB x41,W
02FBA:  MOVLB  0
02FBC:  MOVWF  xA1
02FBE:  MOVLB  5
....................    }                                           
....................    // save the last time a measurement was take to figure out if system is spinning outside of this routine.     
....................    global_last_rpm_value_time = global_rtc_time;  
02FC0:  MOVFF  88,A9
02FC4:  MOVFF  87,A8
02FC8:  MOVFF  86,A7
02FCC:  MOVFF  85,A6
....................    // re-enable INT_CCP4 after grabbing global rtc time 
....................    enable_interrupts(INT_CCP4);  
02FD0:  BSF    F7A.1
02FD2:  BCF    F7B.2
02FD4:  RETFIE 1
.................... } 
....................                                     

Configuration Fuses:
   Word  1: 8200   HSH NOPLLEN PRIMARY_SW NOFCMEN IESO
   Word  2: 2218   PUT NOBROWNOUT BORV19 WDT_SW WDT256
   Word  3: A800   CCP2B3 NOPBADEN CCP3E0 HFOFST TIMER3B5 CCP2D2 MCLR
   Word  4: 0081   STVREN NOLVP NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
